'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tsSimpleType = require('ts-simple-type');
var tsModuleType = require('typescript');
var vscode = require('vscode-css-languageservice');
var vscode$1 = require('vscode-html-languageservice');
var webComponentAnalyzer = require('web-component-analyzer');
var html5 = require('vscode-html-languageservice/lib/umd/languageFacts/data/html5');
var html5Aria = require('vscode-html-languageservice/lib/umd/languageFacts/data/html5Aria');
var html5Events = require('vscode-html-languageservice/lib/umd/languageFacts/data/html5Events');
var html5Tags = require('vscode-html-languageservice/lib/umd/languageFacts/data/html5Tags');
var fs = require('fs');
var path = require('path');
var didYouMean = require('didyoumean2');
var didYouMean__default = _interopDefault(didYouMean);
var chalk = _interopDefault(require('chalk'));
var fastGlob = require('fast-glob');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var LIT_HTML_PROP_ATTRIBUTE_MODIFIER = ".";
var LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER = "?";
var LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER = "@";
var LIT_HTML_ATTRIBUTE_MODIFIERS = [
    LIT_HTML_PROP_ATTRIBUTE_MODIFIER,
    LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER,
    LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER
];
var DIAGNOSTIC_SOURCE = "lit-plugin";
var TS_IGNORE_FLAG = "@ts-ignore";
var VERSION = "1.1.9";

function isHtmlMember(target) {
    return "kind" in target;
}
function isHtmlAttr(target) {
    return isHtmlMember(target) && target.kind === "attribute";
}
function isHtmlProp(target) {
    return isHtmlMember(target) && target.kind === "property";
}
function isHtmlEvent(target) {
    return !isHtmlMember(target);
}
function litAttributeModifierForTarget(target) {
    if (isHtmlAttr(target)) {
        if (tsSimpleType.isAssignableToSimpleTypeKind(target.getType(), tsSimpleType.SimpleTypeKind.BOOLEAN)) {
            return LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER;
        }
        return "";
    }
    else if (isHtmlProp(target)) {
        return LIT_HTML_PROP_ATTRIBUTE_MODIFIER;
    }
    else {
        return LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER;
    }
}
function descriptionHeader(title, titleLevel, _a) {
    if (titleLevel === void 0) { titleLevel = 0; }
    var markdown = _a.markdown;
    return markdown ? (titleLevel === 0 ? "**" + title.trim() + "**" : "#".repeat(titleLevel) + " " + title) : title;
}
function descriptionListItem(item, _a) {
    var markdown = _a.markdown;
    return markdown ? " * " + item.replace("\n", " ") : " * " + item;
}
function descriptionList(title, items, toString, options) {
    var itemsDesc = items.map(function (item) { return descriptionListItem(toString(item), options); }).join("\n");
    return descriptionHeader(title + ":", 0, options) + "\n" + itemsDesc;
}
function documentationForHtmlTag(htmlTag, options) {
    if (options === void 0) { options = {}; }
    var desc = htmlTag.description || "";
    if (htmlTag.slots.length > 0) {
        var items = htmlTag.slots.sort(function (a, b) { return a.name.localeCompare(b.name); });
        desc += "\n\n" + descriptionList("Slots", items, function (slot) { return "" + descriptionHeader("@slot " + slot.name, 0, options) + (slot.description ? " - " + slot.description : ""); }, options);
    }
    if (htmlTag.events.length > 0) {
        var items = htmlTag.events.sort(function (a, b) { return a.name.localeCompare(b.name); });
        desc += "\n\n" + descriptionList("Events", items, function (event) { return "" + descriptionHeader("@fires " + event.name, 0, options) + (event.description ? " - " + event.description : ""); }, options);
    }
    return desc || undefined;
}
function documentationForTarget(target, options) {
    if (options === void 0) { options = {}; }
    var typeText = targetKindAndTypeText(target, options);
    var documentation = descriptionForTarget(target, options);
    return "" + typeText + (documentation != null ? " \n\n" + documentation : "");
}
function descriptionForTarget(target, options) {
    if (options === void 0) { options = {}; }
    if (target.related != null && target.related.length > 1) {
        var subDocumentation = target.related
            .map(function (t) { return "" + (t.fromTagName ? "<" + t.fromTagName + ">: " : "(global): ") + (t.description || "[no documentation]"); })
            .map(function (doc, i) { return i + 1 + ". " + doc; });
        return descriptionHeader("Multiple declarations (best match first):", 0, options) + "\n" + subDocumentation.join("\n");
    }
    return target.description;
}
function targetKindAndTypeText(target, options) {
    if (options === void 0) { options = {}; }
    var prefix = "(" + targetKindText(target) + ") " + (options.modifier || "") + target.name;
    if (tsSimpleType.isAssignableToSimpleTypeKind(target.getType(), tsSimpleType.SimpleTypeKind.ANY)) {
        return "" + prefix;
    }
    return prefix + ": " + tsSimpleType.toTypeString(target.getType());
}
function targetKindText(target) {
    if (isHtmlMember(target)) {
        return target.kind === "property" ? "property" : "attribute";
    }
    else if (isHtmlEvent(target)) {
        return "event";
    }
    return "unknown";
}
function mergeFirstUnique(items, uniqueOn) {
    var unique = new Set();
    return items.filter(function (item) {
        var identity = uniqueOn(item);
        if (!unique.has(identity)) {
            unique.add(identity);
            return true;
        }
        return false;
    });
}
function mergeHtmlAttrs(attrs) {
    return mergeFirstUnique(attrs, function (attr) { return attr.name; });
}
function mergeHtmlProps(props) {
    return mergeFirstUnique(props, function (prop) { return prop.name; });
}
function mergeHtmlEvents(events) {
    return mergeFirstUnique(events, function (event) { return event.name; });
}
function mergeHtmlSlots(slots) {
    return mergeFirstUnique(slots, function (event) { return event.name; });
}
function mergeHtmlTags(tags) {
    var e_1, _a;
    var mergedTags = new Map();
    try {
        for (var tags_1 = __values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {
            var tag = tags_1_1.value;
            var existingTag = mergedTags.get(tag.tagName);
            if (existingTag != null) {
                mergedTags.set(tag.tagName, __assign({}, tag, { builtIn: tag.builtIn || existingTag.builtIn, global: tag.global || existingTag.global, declaration: tag.declaration || existingTag.declaration, description: tag.description || existingTag.description, attributes: mergeHtmlAttrs(__spread(tag.attributes, existingTag.attributes)), properties: mergeHtmlProps(__spread(tag.properties, existingTag.properties)), events: mergeHtmlEvents(__spread(tag.events, existingTag.events)), slots: mergeHtmlSlots(__spread(tag.slots, existingTag.slots)) }));
            }
            else {
                mergedTags.set(tag.tagName, tag);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(mergedTags.values());
}

var HtmlNodeKind;
(function (HtmlNodeKind) {
    HtmlNodeKind["NODE"] = "NODE";
    HtmlNodeKind["SVG"] = "SVG";
    HtmlNodeKind["STYLE"] = "STYLE";
})(HtmlNodeKind || (HtmlNodeKind = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isHTMLNode(obj) {
    return "tagName" in obj && "location" in obj && "attributes" in obj;
}

var HtmlNodeAttrKind;
(function (HtmlNodeAttrKind) {
    HtmlNodeAttrKind["EVENT_LISTENER"] = "EVENT_LISTENER";
    HtmlNodeAttrKind["ATTRIBUTE"] = "ATTRIBUTE";
    HtmlNodeAttrKind["BOOLEAN_ATTRIBUTE"] = "BOOLEAN_ATTRIBUTE";
    HtmlNodeAttrKind["PROPERTY"] = "PROPERTY";
})(HtmlNodeAttrKind || (HtmlNodeAttrKind = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isHTMLAttr(obj) {
    return "name" in obj && "location" in obj && "htmlNode" in obj;
}

var HtmlNodeAttrAssignmentKind;
(function (HtmlNodeAttrAssignmentKind) {
    HtmlNodeAttrAssignmentKind["BOOLEAN"] = "BOOLEAN";
    HtmlNodeAttrAssignmentKind["EXPRESSION"] = "EXPRESSION";
    HtmlNodeAttrAssignmentKind["STRING"] = "STRING";
    HtmlNodeAttrAssignmentKind["MIXED"] = "MIXED";
})(HtmlNodeAttrAssignmentKind || (HtmlNodeAttrAssignmentKind = {}));

function textPartsToRanges(parts) {
    var offset = 0;
    return parts
        .map(function (p) {
        if (typeof p === "string") {
            var startOffset = offset;
            offset += p.length;
            return {
                start: startOffset,
                end: offset
            };
        }
        else {
            offset += p.getText().length + 3;
        }
        return;
    })
        .filter(function (r) { return r != null; });
}

var TextDocument = /** @class */ (function () {
    function TextDocument(virtualDocument) {
        this.virtualDocument = virtualDocument;
    }
    return TextDocument;
}());

(function (LitHtmlDiagnosticKind) {
    LitHtmlDiagnosticKind["MISSING_IMPORT"] = "MISSING_IMPORT";
    LitHtmlDiagnosticKind["MISSING_REQUIRED_ATTRS"] = "MISSING_REQUIRED_ATTRIBUTES";
    LitHtmlDiagnosticKind["UNKNOWN_TARGET"] = "UNKNOWN_TARGET";
    LitHtmlDiagnosticKind["UNKNOWN_TAG"] = "UNKNOWN_TAG";
    LitHtmlDiagnosticKind["TAG_NOT_CLOSED"] = "TAG_NOT_CLOSED";
    LitHtmlDiagnosticKind["BOOL_MOD_ON_NON_BOOL"] = "BOOL_MOD_ON_NON_BOOL";
    LitHtmlDiagnosticKind["PROPERTY_NEEDS_EXPRESSION"] = "PROPERTY_NEEDS_EXPRESSION";
    LitHtmlDiagnosticKind["NO_EVENT_LISTENER_FUNCTION"] = "NO_EVENT_LISTENER_FUNCTION";
    LitHtmlDiagnosticKind["PRIMITIVE_NOT_ASSIGNABLE_TO_COMPLEX"] = "PRIMITIVE_NOT_BINDING_IN_ATTRIBUTE_BINDING";
    LitHtmlDiagnosticKind["COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING"] = "COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING";
    LitHtmlDiagnosticKind["EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING"] = "EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING";
    LitHtmlDiagnosticKind["INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED"] = "INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED";
    LitHtmlDiagnosticKind["INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL"] = "INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL";
    LitHtmlDiagnosticKind["INVALID_ATTRIBUTE_EXPRESSION_TYPE"] = "INVALID_ATTRIBUTE_EXPRESSION_TYPE";
    LitHtmlDiagnosticKind["INVALID_SLOT_NAME"] = "INVALID_SLOT_NAME";
    LitHtmlDiagnosticKind["MISSING_SLOT_ATTRIBUTE"] = "MISSING_SLOT_ATTRIBUTE";
    LitHtmlDiagnosticKind["DIRECTIVE_NOT_ALLOWED_HERE"] = "DIRECTIVE_NOT_ALLOWED_HERE";
    LitHtmlDiagnosticKind["INVALID_MIXED_BINDING"] = "INVALID_MIXED_BINDING";
})(exports.LitHtmlDiagnosticKind || (exports.LitHtmlDiagnosticKind = {}));

var ALL_RULE_NAMES = [
    "no-unknown-tag-name",
    "no-missing-import",
    "no-unclosed-tag",
    "no-unknown-attribute",
    "no-unknown-property",
    "no-unknown-event",
    "no-unknown-slot",
    "no-unintended-mixed-binding",
    "no-invalid-boolean-binding",
    "no-expressionless-property-binding",
    "no-noncallable-event-binding",
    "no-boolean-in-attribute-binding",
    "no-complex-attribute-binding",
    "no-nullable-attribute-binding",
    "no-incompatible-type-binding",
    "no-invalid-directive-binding",
    "no-incompatible-property-type",
    "no-unknown-property-converter",
    "no-invalid-attribute-name",
    "no-invalid-tag-name",
    "no-invalid-css"
];
var DEFAULT_RULES_NOSTRICT = {
    "no-unknown-tag-name": "off",
    "no-missing-import": "off",
    "no-unclosed-tag": "warn",
    "no-unknown-attribute": "off",
    "no-unknown-property": "off",
    "no-unknown-event": "off",
    "no-unknown-slot": "off",
    "no-unintended-mixed-binding": "warn",
    "no-invalid-boolean-binding": "error",
    "no-expressionless-property-binding": "error",
    "no-noncallable-event-binding": "error",
    "no-boolean-in-attribute-binding": "error",
    "no-complex-attribute-binding": "error",
    "no-nullable-attribute-binding": "error",
    "no-incompatible-type-binding": "error",
    "no-invalid-directive-binding": "error",
    "no-incompatible-property-type": "error",
    "no-unknown-property-converter": "error",
    "no-invalid-attribute-name": "error",
    "no-invalid-tag-name": "error",
    "no-invalid-css": "warn"
};
var DEFAULT_RULES_STRICT = {
    "no-unknown-tag-name": "warn",
    "no-missing-import": "warn",
    "no-unclosed-tag": "error",
    "no-unknown-attribute": "warn",
    "no-unknown-property": "warn",
    "no-unknown-event": "off",
    "no-unknown-slot": "warn",
    "no-unintended-mixed-binding": "warn",
    "no-invalid-boolean-binding": "error",
    "no-expressionless-property-binding": "error",
    "no-noncallable-event-binding": "error",
    "no-boolean-in-attribute-binding": "error",
    "no-complex-attribute-binding": "error",
    "no-nullable-attribute-binding": "error",
    "no-incompatible-type-binding": "error",
    "no-invalid-directive-binding": "error",
    "no-incompatible-property-type": "error",
    "no-unknown-property-converter": "error",
    "no-invalid-attribute-name": "error",
    "no-invalid-tag-name": "error",
    "no-invalid-css": "error"
};
function ruleSeverity(rules, ruleName) {
    if ("rules" in rules)
        return ruleSeverity(rules.rules, ruleName);
    var ruleConfig = rules[ruleName] || "off";
    return Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
}
function isRuleDisabled(config, ruleName) {
    return ["off", 0, false].includes(ruleSeverity(config, ruleName));
}
function isRuleEnabled(config, ruleName) {
    return !isRuleDisabled(config, ruleName);
}
function litDiagnosticRuleSeverity(config, ruleName) {
    switch (ruleSeverity(config, ruleName)) {
        case "off":
        case false:
        case 0:
            return "warning";
        case "warn":
        case "warning":
        case true:
        case 1:
            return "warning";
        case "error":
        case 2:
            return "error";
    }
}
/**
 * Parses a partial user configuration and returns a full options object with defaults.
 * @param userOptions
 */
function makeConfig(userOptions) {
    if (userOptions === void 0) { userOptions = {}; }
    return {
        strict: userOptions.strict || false,
        rules: makeRules(userOptions),
        disable: userOptions.disable || false,
        logging: userOptions.logging || "off",
        cwd: userOptions.cwd || process.cwd(),
        format: {
            disable: userOptions.format != null ? userOptions.format.disable :  false // always disable formating for now
        },
        dontSuggestConfigChanges: userOptions.dontSuggestConfigChanges || false,
        dontShowSuggestions: userOptions.dontShowSuggestions || getDeprecatedOption(userOptions, "skipSuggestions") || false,
        // Template tags
        htmlTemplateTags: userOptions.htmlTemplateTags || ["html", "raw"],
        cssTemplateTags: userOptions.cssTemplateTags || ["css"],
        // Global additions
        globalTags: userOptions.globalTags || getDeprecatedOption(userOptions, "externalHtmlTagNames") || [],
        globalAttributes: userOptions.globalAttributes || [],
        globalEvents: userOptions.globalEvents || [],
        customHtmlData: userOptions.customHtmlData || []
    };
}
function getDeprecatedOption(userOptions, name) {
    return userOptions[name];
}
function makeRules(userOptions) {
    var mappedDeprecatedRules = getDeprecatedMappedRules(userOptions);
    var defaultRules = getDefaultRules(userOptions);
    var userRules = getUserRules(userOptions);
    return Object.assign({}, defaultRules, mappedDeprecatedRules, userRules);
}
function getUserRules(userOptions) {
    return userOptions.rules || {};
}
function getDefaultRules(userOptions) {
    var isStrict = userOptions.strict || false;
    if (isStrict) {
        return DEFAULT_RULES_STRICT;
    }
    else {
        return DEFAULT_RULES_NOSTRICT;
    }
}
function getDeprecatedMappedRules(userOptions) {
    var mappedDeprecatedRules = {};
    if (getDeprecatedOption(userOptions, "skipMissingImports") === true) {
        mappedDeprecatedRules["no-missing-import"] = "off";
    }
    if (getDeprecatedOption(userOptions, "skipUnknownTags") === true) {
        mappedDeprecatedRules["no-unknown-tag-name"] = "off";
    }
    if (getDeprecatedOption(userOptions, "skipUnknownAttributes") === true) {
        mappedDeprecatedRules["no-unknown-attribute"] = "off";
    }
    if (getDeprecatedOption(userOptions, "skipUnknownProperties") === true) {
        mappedDeprecatedRules["no-unknown-property"] = "off";
    }
    if (getDeprecatedOption(userOptions, "skipUnknownSlots") === true) {
        mappedDeprecatedRules["no-unknown-slot"] = "off";
    }
    if (getDeprecatedOption(userOptions, "skipCssChecks") === true) {
        mappedDeprecatedRules["no-invalid-css"] = "off";
    }
    if (getDeprecatedOption(userOptions, "checkUnknownEvents") === true) {
        mappedDeprecatedRules["no-unknown-event"] = "warn";
    }
    if (getDeprecatedOption(userOptions, "skipTypeChecking") === true) {
        Object.assign(mappedDeprecatedRules, {
            "no-invalid-boolean-binding": "off",
            "no-noncallable-event-binding": "off",
            "no-boolean-in-attribute-binding": "off",
            "no-complex-attribute-binding": "off",
            "no-nullable-attribute-binding": "off",
            "no-incompatible-type-binding": "off",
            "no-incompatible-property-type": "off"
        });
    }
    return mappedDeprecatedRules;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
(function (LitAnalyzerLoggerLevel) {
    LitAnalyzerLoggerLevel[LitAnalyzerLoggerLevel["OFF"] = 0] = "OFF";
    LitAnalyzerLoggerLevel[LitAnalyzerLoggerLevel["ERROR"] = 1] = "ERROR";
    LitAnalyzerLoggerLevel[LitAnalyzerLoggerLevel["WARN"] = 2] = "WARN";
    LitAnalyzerLoggerLevel[LitAnalyzerLoggerLevel["DEBUG"] = 3] = "DEBUG";
    LitAnalyzerLoggerLevel[LitAnalyzerLoggerLevel["VERBOSE"] = 4] = "VERBOSE";
})(exports.LitAnalyzerLoggerLevel || (exports.LitAnalyzerLoggerLevel = {}));
var DefaultLitAnalyzerLogger = /** @class */ (function () {
    function DefaultLitAnalyzerLogger() {
        this.level = exports.LitAnalyzerLoggerLevel.OFF;
    }
    /**
     * Logs if this.level >= DEBUG
     * @param args
     */
    DefaultLitAnalyzerLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.log.apply(this, __spread([exports.LitAnalyzerLoggerLevel.DEBUG], args));
    };
    /**
     * Logs if this.level >= ERROR
     * @param args
     */
    DefaultLitAnalyzerLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.log.apply(this, __spread([exports.LitAnalyzerLoggerLevel.ERROR], args));
    };
    /**
     * Logs if level >= WARN
     * @param args
     */
    DefaultLitAnalyzerLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.log.apply(this, __spread([exports.LitAnalyzerLoggerLevel.WARN], args));
    };
    /**
     * Logs if level >= VERBOSE
     * @param args
     */
    DefaultLitAnalyzerLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.log.apply(this, __spread([exports.LitAnalyzerLoggerLevel.VERBOSE], args));
    };
    DefaultLitAnalyzerLogger.prototype.log = function (level) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // Only log for the set level
        if (level > this.level) {
            return;
        }
        var prefix = "[" + this.severityPrefix(level) + "]";
        switch (level) {
            case exports.LitAnalyzerLoggerLevel.VERBOSE:
                // eslint-disable-next-line no-console
                console.log.apply(console, __spread([prefix], args));
                return;
            case exports.LitAnalyzerLoggerLevel.DEBUG:
                // eslint-disable-next-line no-console
                console.debug.apply(console, __spread([prefix], args));
                return;
            case exports.LitAnalyzerLoggerLevel.WARN:
                // eslint-disable-next-line no-console
                console.warn.apply(console, __spread([prefix], args));
                return;
            case exports.LitAnalyzerLoggerLevel.ERROR:
                // eslint-disable-next-line no-console
                console.error.apply(console, __spread([prefix], args));
                return;
            case exports.LitAnalyzerLoggerLevel.OFF:
                return;
        }
    };
    DefaultLitAnalyzerLogger.prototype.severityPrefix = function (level) {
        switch (level) {
            case exports.LitAnalyzerLoggerLevel.VERBOSE:
                return "\x1b[36mVERBOSE\x1b[0m"; // CYAN
            case exports.LitAnalyzerLoggerLevel.DEBUG:
                return "\x1b[33mDEBUG\x1b[0m"; // YELLOW
            case exports.LitAnalyzerLoggerLevel.WARN:
                return "\x1b[35mWARN\x1b[0m"; // PURPLE
            case exports.LitAnalyzerLoggerLevel.ERROR:
                return "\x1b[31mERROR\x1b[0m"; // RED
            case exports.LitAnalyzerLoggerLevel.OFF:
                return "";
        }
    };
    return DefaultLitAnalyzerLogger;
}());

var tsModule = { ts: tsModuleType };
function setTypescriptModule(newModule) {
    tsModule.ts = newModule;
}

/**
 * Returns if a position is within start and end.
 * @param position
 * @param start
 * @param end
 */
function intersects(position, _a) {
    var start = _a.start, end = _a.end;
    if (typeof position === "number") {
        return start <= position && position <= end;
    }
    else {
        return start <= position.start && position.end <= end;
    }
}
/**
 * Flattens a nested array
 * @param items
 */
function flatten(items) {
    return items.reduce(function (acc, item) { return __spread(acc, item); }, []);
}
/**
 * Parses an attribute name returning a name and eg. a modifier.
 * Examples:
 *  - ?disabled="..."
 *  - .myProp="..."
 *  - @click="..."
 * @param attributeName
 */
function parseLitAttrName(attributeName) {
    var _a = __read(attributeName.match(/^([.?@])?(.*)/), 3), modifier = _a[1], name = _a[2];
    return { name: name, modifier: modifier };
}
function lazy(func) {
    var called = false;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var value;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (called)
            return value;
        called = true;
        return (value = func.apply(void 0, __spread(args)));
    });
}
function isCustomElementTagName(tagName) {
    return tagName.includes("-");
}

function getPartLength(part) {
    var end = part.parent && tsModule.ts.isTemplateSpan(part.parent) ? part.parent.literal.getStart() : part.getEnd();
    return end - part.getFullStart();
}
var VirtualAstDocument = /** @class */ (function () {
    function VirtualAstDocument(astNodeOrParts, location, fileName) {
        var _this = this;
        if (Array.isArray(astNodeOrParts)) {
            this.parts = astNodeOrParts.map(function (p, i) {
                return typeof p === "string" ? "" + (i !== 0 ? "}" : "") + p + (i !== astNodeOrParts.length - 1 ? "${" : "") : p;
            });
            this.location = location;
            this.fileName = fileName;
        }
        else {
            var _a = getPartsFromTaggedTemplate(astNodeOrParts), expressionParts_1 = _a.expressionParts, literalParts = _a.literalParts;
            // Text contains both the ` of the template string and ${  +  }.
            // Strip these chars and make it possible to substitute even ${ and }!
            this.parts = [];
            literalParts.forEach(function (p, i) {
                var expressionPart = expressionParts_1[i];
                _this.parts.push(p.getText().slice(i === 0 ? 1 : 0, expressionPart == null ? -1 : undefined));
                if (expressionPart != null)
                    _this.parts.push(expressionPart);
            });
            this.location = {
                start: astNodeOrParts.template.getStart() + 1,
                end: astNodeOrParts.template.getEnd() - 1
            };
            this.fileName = this.fileName = astNodeOrParts.getSourceFile().fileName;
        }
    }
    Object.defineProperty(VirtualAstDocument.prototype, "text", {
        get: function () {
            var _this = this;
            if (this._text == null) {
                var str_1 = "";
                var prevPart_1 = "";
                this.parts.forEach(function (part, i) {
                    var isLastPart = i >= _this.parts.length - 1;
                    if (typeof part === "string") {
                        str_1 += part.substring(i === 0 ? 0 : 1, part.length - (isLastPart ? 0 : 2));
                        prevPart_1 = part;
                    }
                    else {
                        var length_1 = getPartLength(part) + 3;
                        var substitution = _this.substituteExpression(length_1, part, prevPart_1, _this.parts[i + 1]);
                        str_1 += substitution;
                    }
                });
                this._text = str_1;
            }
            return this._text;
        },
        enumerable: true,
        configurable: true
    });
    VirtualAstDocument.prototype.getPartsAtOffsetRange = function (range) {
        var _this = this;
        if (range == null) {
            return this.parts;
        }
        var resultParts = [];
        var offset = 0;
        this.parts.forEach(function (part, i) {
            var isLastPart = i >= _this.parts.length - 1;
            var startOffset = offset;
            if (typeof part === "string") {
                var startPadding = i === 0 ? 0 : 1;
                var endPadding = isLastPart ? 0 : 2;
                offset += part.length;
                var literalPartRange = {
                    start: startOffset + startPadding,
                    end: offset - endPadding
                };
                if ((range.start < literalPartRange.start && range.end > literalPartRange.end) ||
                    (intersects(range.start + 1, literalPartRange) || intersects(range.end - 1, literalPartRange))) {
                    var strStart = Math.max(literalPartRange.start, range.start);
                    var strEnd = Math.min(literalPartRange.end, range.end);
                    var substr = _this.text.substring(strStart, strEnd);
                    resultParts.push(substr);
                }
            }
            else {
                offset += getPartLength(part);
                var expressionPartRange = {
                    start: startOffset,
                    end: offset
                };
                if (intersects(expressionPartRange, range)) {
                    resultParts.push(part);
                }
            }
        });
        return resultParts;
    };
    VirtualAstDocument.prototype.scPositionToOffset = function (position) {
        return position - this.location.start;
    };
    VirtualAstDocument.prototype.offsetToSCPosition = function (offset) {
        return this.location.start + offset;
    };
    VirtualAstDocument.prototype.substituteExpression = function (length, expression, prev, next) {
        return "_".repeat(length);
    };
    return VirtualAstDocument;
}());
function getPartsFromTaggedTemplate(astNode) {
    var e_1, _a;
    var expressionParts = [];
    var literalParts = [];
    var template = astNode.template;
    if (tsModule.ts.isTemplateExpression(template)) {
        literalParts.push(template.head);
        try {
            for (var _b = __values(template.templateSpans), _c = _b.next(); !_c.done; _c = _b.next()) {
                var templateSpan = _c.value;
                var expression = templateSpan.expression;
                expressionParts.push(expression);
                literalParts.push(templateSpan.literal);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else if (tsModule.ts.isNoSubstitutionTemplateLiteral(template)) {
        literalParts.push(template);
    }
    return { expressionParts: expressionParts, literalParts: literalParts };
}

var VirtualAstHtmlDocument = /** @class */ (function (_super) {
    __extends(VirtualAstHtmlDocument, _super);
    function VirtualAstHtmlDocument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VirtualAstHtmlDocument.prototype.substituteExpression = function (length, expression) {
        return "_".repeat(length);
    };
    return VirtualAstHtmlDocument;
}(VirtualAstDocument));

var HtmlDocument = /** @class */ (function (_super) {
    __extends(HtmlDocument, _super);
    function HtmlDocument(virtualDocument, rootNodes) {
        var _this = _super.call(this, virtualDocument) || this;
        _this.rootNodes = rootNodes;
        return _this;
    }
    HtmlDocument.prototype.htmlAttrAreaAtOffset = function (offset) {
        return this.mapFindOne(function (node) {
            var e_1, _a;
            if (offset > node.location.name.end && intersects(offset, node.location.startTag)) {
                try {
                    // Check if the position intersects any attributes. Break if so.
                    for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var htmlAttr = _c.value;
                        if (intersects(offset, htmlAttr.location)) {
                            return undefined;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return node;
            }
            return;
        });
    };
    HtmlDocument.prototype.htmlAttrAssignmentAtOffset = function (offset) {
        return this.findAttr(function (attr) {
            return attr.assignment != null && attr.assignment.location != null ? intersects(offset, attr.assignment.location) : false;
        });
    };
    HtmlDocument.prototype.htmlAttrNameAtOffset = function (offset) {
        return this.findAttr(function (attr) { return intersects(offset, attr.location.name); });
    };
    HtmlDocument.prototype.htmlNodeNameAtOffset = function (offset) {
        return this.findNode(function (node) { return intersects(offset, node.location.name) || (node.location.endTag != null && intersects(offset, node.location.endTag)); });
    };
    HtmlDocument.prototype.htmlNodeOrAttrAtOffset = function (offset) {
        var htmlNode = this.htmlNodeNameAtOffset(offset);
        if (htmlNode != null)
            return htmlNode;
        var htmlAttr = this.htmlAttrNameAtOffset(offset);
        if (htmlAttr != null)
            return htmlAttr;
        return;
    };
    /**
     * Finds the closest node to offset.
     * This method can be used to find out which tag to close in the HTML.
     * @param offset
     */
    HtmlDocument.prototype.htmlNodeClosestToOffset = function (offset) {
        var closestNode = undefined;
        // Use 'findNode' to iterate nodes. Keep track of the closest node.
        this.findNode(function (node) {
            if (offset < node.location.startTag.end) {
                // Break as soon as we find a node that starts AFTER the offset.
                // The closestNode would now be the previous found node.
                return true;
            }
            else if (node.location.endTag == null || offset < node.location.endTag.end) {
                // Save closest node if the node doesn't have an end tag of the node ends AFTER the offset.
                closestNode = node;
            }
            return false;
        });
        return closestNode;
    };
    HtmlDocument.prototype.findAttr = function (test) {
        return this.mapFindOne(function (node) {
            var e_2, _a;
            try {
                for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var attr = _c.value;
                    if (test(attr))
                        return attr;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return;
        });
    };
    HtmlDocument.prototype.findNode = function (test) {
        return this.mapFindOne(function (node) {
            if (test(node))
                return node;
            return;
        });
    };
    HtmlDocument.prototype.mapNodes = function (map) {
        var items = [];
        function childrenLoop(node) {
            items.push(map(node));
            node.children.forEach(function (childNode) { return childrenLoop(childNode); });
        }
        this.rootNodes.forEach(function (rootNode) { return childrenLoop(rootNode); });
        return items;
    };
    HtmlDocument.prototype.mapFindOne = function (map) {
        var e_3, _a;
        function innerTest(node) {
            var e_4, _a;
            var res = map(node);
            if (res)
                return res;
            try {
                for (var _b = __values(node.children || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    var found = innerTest(childNode);
                    if (found != null)
                        return found;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return;
        }
        try {
            for (var _b = __values(this.rootNodes || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rootNode = _c.value;
                var found = innerTest(rootNode);
                if (found != null) {
                    return found;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return;
    };
    return HtmlDocument;
}(TextDocument));

(function (CodeActionKind) {
    CodeActionKind["DOCUMENT_TEXT_CHANGE"] = "TEXT_CHANGE";
    CodeActionKind["IMPORT_COMPONENT"] = "IMPORT_COMPONENT";
})(exports.CodeActionKind || (exports.CodeActionKind = {}));

(function (CodeFixKind) {
    CodeFixKind["RENAME"] = "RENAME";
    CodeFixKind["ADD_TEXT"] = "ADD_TEXT";
    CodeFixKind["CHANGE_LIT_MODIFIER"] = "CHANGE_LIT_MODIFIER";
    CodeFixKind["IMPORT_COMPONENT"] = "IMPORT_COMPONENT";
})(exports.CodeFixKind || (exports.CodeFixKind = {}));

(function (DefinitionKind) {
    DefinitionKind["COMPONENT"] = "COMPONENT";
    DefinitionKind["MEMBER"] = "MEMBER";
    DefinitionKind["EVENT"] = "EVENT";
})(exports.DefinitionKind || (exports.DefinitionKind = {}));

(function (LitOutliningSpanKind) {
    LitOutliningSpanKind["Comment"] = "comment";
    LitOutliningSpanKind["Region"] = "region";
    LitOutliningSpanKind["Code"] = "code";
    LitOutliningSpanKind["Imports"] = "imports";
})(exports.LitOutliningSpanKind || (exports.LitOutliningSpanKind = {}));

var VirtualAstCssDocument = /** @class */ (function (_super) {
    __extends(VirtualAstCssDocument, _super);
    function VirtualAstCssDocument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VirtualAstCssDocument.prototype.substituteExpression = function (length, expression, prev, next) {
        var hasLeftColon = prev.match(/:\s*\${$/) != null;
        var hasRightColon = next != null && next.match(/^}\s*:\s+/) != null;
        var hasRightSemicolon = next != null && next.match(/^}\s*;/) != null;
        var hasRightPercentage = next != null && next.match(/^}%/) != null;
        // Inspired by https://github.com/Microsoft/typescript-styled-plugin/blob/909d4f17d61562fe77f24587ea443713b8da851d/src/_substituter.ts#L62
        // If this substitution contains both a property and a key, replace it with "$_:_"
        //   Example:
        //     div {
        //       ${unsafeCSS("color: red)};
        //     }
        if (hasRightSemicolon && !hasLeftColon) {
            var prefix = "$_:_";
            return ("" + prefix + "_".repeat(Math.max(0, length - prefix.length))).slice(0, length);
        }
        // If there is "%" to the right of this substitution, replace with a number, because the parser expects a number unit
        //    Example:
        //	    div {
        //        transform-origin: ${x}% ${y}%;
        //      }
        else if (hasRightPercentage) {
            return "0".repeat(length);
        }
        // If there is a ": " to the right of this substitution, replace it with an identifier
        //     Example:
        //       div {
        //         ${unsafeCSS("color")}: red
        //       }
        else if (hasRightColon) {
            return "$" + "_".repeat(length - 1);
        }
        // Else replace with an identifier "_"
        return "_".repeat(length);
    };
    return VirtualAstCssDocument;
}(VirtualAstDocument));

var CssDocument = /** @class */ (function (_super) {
    __extends(CssDocument, _super);
    function CssDocument(virtualDocument) {
        return _super.call(this, virtualDocument) || this;
    }
    return CssDocument;
}(TextDocument));

/**
 * Returns information about the position in a document.
 * @param document
 * @param offset
 */
function getPositionContextInDocument(document, offset) {
    var text = document.virtualDocument.text;
    var leftWord = grabWordInDirection({
        stopChar: /[/=<>\s"${}]/,
        direction: "left",
        text: text,
        startOffset: offset
    });
    var rightWord = grabWordInDirection({
        stopChar: /[/=<>\s"${}]/,
        direction: "right",
        text: text,
        startOffset: offset
    });
    var word = leftWord + rightWord;
    var beforeWord = text[Math.max(0, offset - leftWord.length - 1)];
    var afterWord = text[Math.min(text.length - 1, offset + rightWord.length)];
    return {
        offset: offset,
        text: text,
        word: word,
        leftWord: leftWord,
        rightWord: rightWord,
        beforeWord: beforeWord,
        afterWord: afterWord
    };
}
/**
 * Reads a word in a specific direction.
 * Stops if "stopChar" is encountered.
 * @param startPosition
 * @param stopChar
 * @param direction
 * @param text
 */
function grabWordInDirection(_a) {
    var startOffset = _a.startOffset, stopChar = _a.stopChar, direction = _a.direction, text = _a.text;
    var dir = direction === "left" ? -1 : 1;
    var curPosition = startOffset - (dir < 0 ? 1 : 0);
    while (curPosition > 0 && curPosition < text.length) {
        if (text[curPosition].match(stopChar))
            break;
        curPosition += dir;
        if (curPosition > text.length || curPosition < 0)
            return "";
    }
    var a = curPosition;
    var b = startOffset;
    return text.substring(Math.min(a, b) + (dir < 0 ? 1 : 0), Math.max(a, b));
}

function iterableMap(iterable, map) {
    var iterable_2, iterable_2_1, item, e_3_1;
    var e_3, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _b.trys.push([0, 5, 6, 7]);
                iterable_2 = __values(iterable), iterable_2_1 = iterable_2.next();
                _b.label = 1;
            case 1:
                if (!!iterable_2_1.done) return [3 /*break*/, 4];
                item = iterable_2_1.value;
                return [4 /*yield*/, map(item)];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                iterable_2_1 = iterable_2.next();
                return [3 /*break*/, 1];
            case 4: return [3 /*break*/, 7];
            case 5:
                e_3_1 = _b.sent();
                e_3 = { error: e_3_1 };
                return [3 /*break*/, 7];
            case 6:
                try {
                    if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) _a.call(iterable_2);
                }
                finally { if (e_3) throw e_3.error; }
                return [7 /*endfinally*/];
            case 7: return [2 /*return*/];
        }
    });
}
function iterableFilter(iterable, filter) {
    var iterable_3, iterable_3_1, item, e_4_1;
    var e_4, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _b.trys.push([0, 5, 6, 7]);
                iterable_3 = __values(iterable), iterable_3_1 = iterable_3.next();
                _b.label = 1;
            case 1:
                if (!!iterable_3_1.done) return [3 /*break*/, 4];
                item = iterable_3_1.value;
                if (!filter(item)) return [3 /*break*/, 3];
                return [4 /*yield*/, item];
            case 2:
                _b.sent();
                _b.label = 3;
            case 3:
                iterable_3_1 = iterable_3.next();
                return [3 /*break*/, 1];
            case 4: return [3 /*break*/, 7];
            case 5:
                e_4_1 = _b.sent();
                e_4 = { error: e_4_1 };
                return [3 /*break*/, 7];
            case 6:
                try {
                    if (iterable_3_1 && !iterable_3_1.done && (_a = iterable_3.return)) _a.call(iterable_3);
                }
                finally { if (e_4) throw e_4.error; }
                return [7 /*endfinally*/];
            case 7: return [2 /*return*/];
        }
    });
}
function iterableDefined(iterable) {
    return iterable.filter(function (i) { return i != null; });
}

function makeVscTextDocument(cssDocument) {
    return vscode.TextDocument.create("untitled://embedded.css", "css", 1, cssDocument.virtualDocument.text);
}
var LitCssVscodeService = /** @class */ (function () {
    function LitCssVscodeService() {
        this.dataProvider = new LitVscodeCSSDataProvider();
    }
    Object.defineProperty(LitCssVscodeService.prototype, "cssService", {
        get: function () {
            return vscode.getCSSLanguageService({ customDataProviders: [this.dataProvider.provider] });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LitCssVscodeService.prototype, "scssService", {
        get: function () {
            return vscode.getSCSSLanguageService({ customDataProviders: [this.dataProvider.provider] });
        },
        enumerable: true,
        configurable: true
    });
    LitCssVscodeService.prototype.getDiagnostics = function (document, context) {
        this.dataProvider.update(context.htmlStore);
        var vscTextDocument = makeVscTextDocument(document);
        // Return nothing if this is a one liner css snippet.
        // Example: css`100px`
        if (!vscTextDocument.getText().includes("\n")) {
            return [];
        }
        var vscStylesheet = this.makeVscStylesheet(vscTextDocument);
        var diagnostics = this.scssService.doValidation(vscTextDocument, vscStylesheet);
        if (isRuleDisabled(context.config, "no-invalid-css")) {
            return [];
        }
        return diagnostics
            .filter(function (diagnostic) { return diagnostic.range.start.line !== 0 && diagnostic.range.start.line < vscTextDocument.lineCount - 1; })
            .map(function (diagnostic) {
            return ({
                severity: diagnostic.severity === vscode.DiagnosticSeverity.Error ? "error" : "warning",
                location: {
                    document: document,
                    start: vscTextDocument.offsetAt(diagnostic.range.start),
                    end: vscTextDocument.offsetAt(diagnostic.range.end)
                },
                message: diagnostic.message
            });
        });
    };
    LitCssVscodeService.prototype.getQuickInfo = function (document, offset, context) {
        var e_1, _a;
        this.dataProvider.update(context.htmlStore);
        var vscTextDocument = makeVscTextDocument(document);
        var vscStylesheet = this.makeVscStylesheet(vscTextDocument);
        var vscPosition = vscTextDocument.positionAt(offset);
        var hover = this.scssService.doHover(vscTextDocument, vscPosition, vscStylesheet);
        if (hover == null || hover.range == null)
            return;
        var contents = Array.isArray(hover.contents) ? hover.contents : [hover.contents];
        var primaryInfo = undefined;
        var secondaryInfo = undefined;
        try {
            for (var contents_1 = __values(contents), contents_1_1 = contents_1.next(); !contents_1_1.done; contents_1_1 = contents_1.next()) {
                var content = contents_1_1.value;
                var text = typeof content === "string" ? content : content.value;
                if (typeof content === "object" && "language" in content) {
                    if (content.language === "html") {
                        primaryInfo = "" + (primaryInfo == null ? "" : "\n\n") + text;
                    }
                }
                else {
                    secondaryInfo = text;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (contents_1_1 && !contents_1_1.done && (_a = contents_1.return)) _a.call(contents_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return {
            primaryInfo: primaryInfo || "",
            secondaryInfo: secondaryInfo,
            range: {
                document: document,
                start: vscTextDocument.offsetAt(hover.range.start),
                end: vscTextDocument.offsetAt(hover.range.end)
            }
        };
    };
    LitCssVscodeService.prototype.getCompletions = function (document, offset, request) {
        this.dataProvider.update(request.htmlStore);
        var vscTextDocument = makeVscTextDocument(document);
        var vscStylesheet = this.makeVscStylesheet(vscTextDocument);
        var vscPosition = vscTextDocument.positionAt(offset);
        var items = this.cssService.doComplete(vscTextDocument, vscPosition, vscStylesheet);
        return items.items.map(function (i) {
            return ({
                kind: i.kind == null ? "unknown" : translateCompletionItemKind(i.kind),
                insert: i.label,
                name: i.label,
                kindModifiers: i.kind === vscode.CompletionItemKind.Color ? "color" : undefined,
                importance: i.label.startsWith("@") || i.label.startsWith("-") ? "low" : i.label.startsWith(":") ? "medium" : "high",
                documentation: lazy(function () { return (typeof i.documentation === "string" || i.documentation == null ? i.documentation : i.documentation.value); })
            });
        });
    };
    LitCssVscodeService.prototype.makeVscStylesheet = function (vscTextDocument) {
        return this.scssService.parseStylesheet(vscTextDocument);
    };
    return LitCssVscodeService;
}());
function translateCompletionItemKind(kind) {
    switch (kind) {
        case vscode.CompletionItemKind.Method:
            return "memberFunctionElement";
        case vscode.CompletionItemKind.Function:
            return "functionElement";
        case vscode.CompletionItemKind.Constructor:
            return "constructorImplementationElement";
        case vscode.CompletionItemKind.Field:
        case vscode.CompletionItemKind.Variable:
            return "variableElement";
        case vscode.CompletionItemKind.Class:
            return "classElement";
        case vscode.CompletionItemKind.Interface:
            return "interfaceElement";
        case vscode.CompletionItemKind.Module:
            return "moduleElement";
        case vscode.CompletionItemKind.Property:
            return "memberVariableElement";
        case vscode.CompletionItemKind.Unit:
        case vscode.CompletionItemKind.Value:
            return "constElement";
        case vscode.CompletionItemKind.Enum:
            return "enumElement";
        case vscode.CompletionItemKind.Keyword:
            return "keyword";
        case vscode.CompletionItemKind.Color:
            return "constElement";
        case vscode.CompletionItemKind.Reference:
            return "alias";
        case vscode.CompletionItemKind.File:
            return "moduleElement";
        case vscode.CompletionItemKind.Snippet:
        case vscode.CompletionItemKind.Text:
        default:
            return "unknown";
    }
}
var LitVscodeCSSDataProvider = /** @class */ (function () {
    function LitVscodeCSSDataProvider() {
        var _this = this;
        this.pseudoElementData = [];
        this.customDataProvider = (function () {
            var provider = _this;
            return {
                providePseudoElements: function () {
                    return provider.pseudoElementData;
                },
                provideAtDirectives: function () {
                    return [];
                },
                providePseudoClasses: function () {
                    return [
                        {
                            browsers: [],
                            description: "Allows you to select elements that have been exposed via a part attribute.",
                            name: "part",
                            status: "standard"
                        },
                        {
                            browsers: [],
                            description: "Unlike ::part, ::theme matches elements parts with that theme name, anywhere in the document.",
                            name: "theme",
                            status: "nonstandard"
                        }
                    ];
                },
                provideProperties: function () {
                    return [];
                }
            };
        })();
    }
    Object.defineProperty(LitVscodeCSSDataProvider.prototype, "provider", {
        get: function () {
            return this.customDataProvider;
        },
        enumerable: true,
        configurable: true
    });
    LitVscodeCSSDataProvider.prototype.update = function (htmlStore) {
        this.pseudoElementData = Array.from(iterableMap(iterableFilter(htmlStore.getGlobalTags(), function (tag) { return !tag.builtIn; }), function (tag) {
            return ({
                browsers: [],
                description: tag.description,
                name: tag.tagName,
                status: "standard"
            });
        }));
    };
    return LitVscodeCSSDataProvider;
}());

var LitCssDocumentAnalyzer = /** @class */ (function () {
    function LitCssDocumentAnalyzer() {
        this.vscodeCssService = new LitCssVscodeService();
        this.completionsCache = [];
    }
    LitCssDocumentAnalyzer.prototype.getCompletionDetailsAtOffset = function (document, offset, name, request) {
        var completionWithName = this.completionsCache.find(function (completion) { return completion.name === name; });
        if (completionWithName == null || completionWithName.documentation == null)
            return undefined;
        var primaryInfo = completionWithName.documentation();
        if (primaryInfo == null)
            return undefined;
        return {
            name: name,
            kind: completionWithName.kind,
            primaryInfo: primaryInfo
        };
    };
    LitCssDocumentAnalyzer.prototype.getCompletionsAtOffset = function (document, offset, request) {
        this.completionsCache = this.vscodeCssService.getCompletions(document, offset, request);
        return this.completionsCache;
    };
    LitCssDocumentAnalyzer.prototype.getQuickInfoAtOffset = function (document, offset, request) {
        return this.vscodeCssService.getQuickInfo(document, offset, request);
    };
    LitCssDocumentAnalyzer.prototype.getDiagnostics = function (document, request) {
        return this.vscodeCssService.getDiagnostics(document, request);
    };
    LitCssDocumentAnalyzer.prototype.getDefinitionAtOffset = function (document, offset, request) {
        var positionContext = getPositionContextInDocument(document, offset);
        var tagNameMatch = positionContext.word.match(/^[a-zA-Z-1-9]+/);
        if (tagNameMatch == null)
            return undefined;
        var tagName = tagNameMatch[0];
        var definition = request.definitionStore.getDefinitionForTagName(tagName);
        if (definition != null) {
            var start = offset - positionContext.leftWord.length;
            var end = start + tagName.length;
            return {
                kind: exports.DefinitionKind.COMPONENT,
                fromRange: { document: document, start: start, end: end },
                target: definition.declaration
            };
        }
        return undefined;
    };
    return LitCssDocumentAnalyzer;
}());

function codeFixesForHtmlReport(htmlReport, _a) {
    var document = _a.document, htmlStore = _a.htmlStore;
    switch (htmlReport.kind) {
        case exports.LitHtmlDiagnosticKind.UNKNOWN_TARGET: {
            var fixes = [];
            switch (htmlReport.htmlAttr.kind) {
                case HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE:
                case HtmlNodeAttrKind.ATTRIBUTE:
                    fixes.push({
                        kind: exports.CodeFixKind.RENAME,
                        message: "Change attribute to 'data-" + htmlReport.htmlAttr.name + "'",
                        htmlReport: htmlReport,
                        actions: [
                            {
                                kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                                change: {
                                    range: {
                                        document: document,
                                        start: htmlReport.htmlAttr.location.name.start,
                                        end: htmlReport.htmlAttr.location.name.start
                                    },
                                    newText: "data-"
                                }
                            }
                        ]
                    });
                    break;
            }
            if (htmlReport.suggestedTarget != null) {
                var newText = "" + litAttributeModifierForTarget(htmlReport.suggestedTarget) + htmlReport.suggestedTarget.name;
                fixes.push({
                    kind: exports.CodeFixKind.RENAME,
                    message: "Change " + (htmlReport.htmlAttr.kind === HtmlNodeAttrKind.PROPERTY ? "property" : "attribute") + " to '" + newText + "'",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                // Make a range that includes the modifier.
                                range: {
                                    document: document,
                                    start: htmlReport.htmlAttr.location.start,
                                    end: htmlReport.htmlAttr.location.name.end
                                },
                                newText: newText
                            }
                        }
                    ]
                });
            }
            return fixes;
        }
        case exports.LitHtmlDiagnosticKind.UNKNOWN_TAG: {
            if (htmlReport.suggestedName == null)
                break;
            var endTagRange = htmlReport.htmlNode.location.endTag;
            return [
                {
                    kind: exports.CodeFixKind.RENAME,
                    message: "Change tag name to '" + htmlReport.suggestedName + "'",
                    htmlReport: htmlReport,
                    actions: __spread([
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: __assign({ document: document }, htmlReport.location),
                                newText: htmlReport.suggestedName
                            }
                        }
                    ], (endTagRange == null
                        ? []
                        : [
                            {
                                kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                                change: {
                                    range: {
                                        document: document,
                                        start: endTagRange.start + 2,
                                        end: endTagRange.end - 1
                                    },
                                    newText: htmlReport.suggestedName
                                }
                            }
                        ]))
                }
            ];
        }
        case exports.LitHtmlDiagnosticKind.BOOL_MOD_ON_NON_BOOL:
        case exports.LitHtmlDiagnosticKind.PRIMITIVE_NOT_ASSIGNABLE_TO_COMPLEX: {
            var htmlAttr = htmlReport.htmlAttr;
            var existingModifierLength = htmlAttr.modifier ? htmlAttr.modifier.length : 0;
            var htmlAttrTarget = htmlStore.getHtmlAttrTarget(htmlAttr);
            var newModifier = htmlAttrTarget == null ? "." : htmlReport.kind === exports.LitHtmlDiagnosticKind.BOOL_MOD_ON_NON_BOOL ? "" : ".";
            return [
                {
                    kind: exports.CodeFixKind.CHANGE_LIT_MODIFIER,
                    message: newModifier.length === 0 ? "Remove '" + (htmlAttr.modifier || "") + "' modifier" : "Use '" + newModifier + "' modifier instead",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: {
                                    document: document,
                                    start: htmlAttr.location.name.start - existingModifierLength,
                                    end: htmlAttr.location.name.start
                                },
                                newText: newModifier
                            }
                        }
                    ]
                }
            ];
        }
        case exports.LitHtmlDiagnosticKind.MISSING_IMPORT:
            return [
                {
                    kind: exports.CodeFixKind.IMPORT_COMPONENT,
                    message: "Import \"" + (htmlReport.definition.declaration.className || "component") + "\" from module \"" + htmlReport.importPath + "\"",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.IMPORT_COMPONENT,
                            importPath: htmlReport.importPath
                        }
                    ]
                }
            ];
        case exports.LitHtmlDiagnosticKind.MISSING_SLOT_ATTRIBUTE:
            return [
                {
                    kind: exports.CodeFixKind.ADD_TEXT,
                    message: "Add slot attribute.",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: {
                                    document: document,
                                    start: htmlReport.htmlNode.location.name.end,
                                    end: htmlReport.htmlNode.location.name.end
                                },
                                newText: " slot=\"\""
                            }
                        }
                    ]
                }
            ];
        case exports.LitHtmlDiagnosticKind.EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING: {
            var newText = "" + LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER + htmlReport.htmlAttr.name;
            return [
                {
                    kind: exports.CodeFixKind.ADD_TEXT,
                    message: "Change to '" + newText + "'",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: __assign({ document: document }, htmlReport.htmlAttr.location.name),
                                newText: newText
                            }
                        }
                    ]
                }
            ];
        }
        case exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED: {
            var assignment = htmlReport.htmlAttr.assignment;
            return [
                {
                    kind: exports.CodeFixKind.ADD_TEXT,
                    message: "Use the 'ifDefined' directive.",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: {
                                    document: document,
                                    start: assignment.location.start + 2,
                                    end: assignment.location.end - 1 // Offset 1 for '}'
                                },
                                newText: "ifDefined(" + assignment.expression.getText() + ")"
                            }
                        }
                    ]
                }
            ];
        }
        case exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL: {
            var assignment = htmlReport.htmlAttr.assignment;
            var newText = "ifDefined(" + assignment.expression.getText() + " === null ? undefined : " + assignment.expression.getText() + ")";
            return [
                {
                    kind: exports.CodeFixKind.ADD_TEXT,
                    message: "Use '" + newText + "'",
                    htmlReport: htmlReport,
                    actions: [
                        {
                            kind: exports.CodeActionKind.DOCUMENT_TEXT_CHANGE,
                            change: {
                                range: {
                                    document: document,
                                    start: assignment.location.start + 2,
                                    end: assignment.location.end - 1 // Offset 1 for '}'
                                },
                                newText: newText
                            }
                        }
                    ]
                }
            ];
        }
    }
    return [];
}

function completionsForHtmlAttrValues(htmlNodeAttr, location, _a) {
    var htmlStore = _a.htmlStore;
    // There is not point in showing completions for event listener bindings
    if (htmlNodeAttr.kind === HtmlNodeAttrKind.EVENT_LISTENER)
        return [];
    // Don't show completions inside assignments with expressions
    if (htmlNodeAttr.assignment && htmlNodeAttr.assignment.kind === HtmlNodeAttrAssignmentKind.EXPRESSION)
        return [];
    var htmlTagMember = htmlStore.getHtmlAttrTarget(htmlNodeAttr);
    if (htmlTagMember == null)
        return [];
    // Special case for handling slot attr as we need to look at its parent
    if (htmlNodeAttr.name === "slot") {
        var parentHtmlTag = htmlNodeAttr.htmlNode.parent && htmlStore.getHtmlTag(htmlNodeAttr.htmlNode.parent);
        if (parentHtmlTag != null && parentHtmlTag.slots.length > 0) {
            return parentHtmlTag.slots.map(function (slot) {
                return ({
                    name: slot.name || " ",
                    insert: slot.name || "",
                    documentation: function () { return slot.description; },
                    kind: "enumElement"
                });
            });
        }
    }
    var options = getOptionsFromType(htmlTagMember.getType());
    return options.map(function (option) {
        return ({
            name: option,
            insert: option,
            kind: "enumElement"
        });
    });
}
function getOptionsFromType(type) {
    switch (type.kind) {
        case tsSimpleType.SimpleTypeKind.UNION:
            return type.types.filter(tsSimpleType.isSimpleTypeLiteral).map(function (t) { return t.value.toString(); });
        case tsSimpleType.SimpleTypeKind.ENUM:
            return type.types
                .map(function (m) { return m.type; })
                .filter(tsSimpleType.isSimpleTypeLiteral)
                .map(function (t) { return t.value.toString(); });
        case tsSimpleType.SimpleTypeKind.ALIAS:
            return getOptionsFromType(type.target);
    }
    return [];
}

function completionsForHtmlAttrs(htmlNode, location, _a) {
    var htmlStore = _a.htmlStore;
    var onTagName = htmlNode.tagName;
    // Code completions for ".[...]";
    if (location.word.startsWith(LIT_HTML_PROP_ATTRIBUTE_MODIFIER)) {
        var alreadyUsedPropNames_1 = htmlNode.attributes.filter(function (a) { return a.modifier === LIT_HTML_PROP_ATTRIBUTE_MODIFIER; }).map(function (a) { return a.name; });
        var unusedProps = iterableFilter(htmlStore.getAllPropertiesForTag(htmlNode), function (prop) { return !alreadyUsedPropNames_1.includes(prop.name); });
        return Array.from(iterableMap(unusedProps, function (prop) {
            return targetToCompletion(prop, {
                modifier: LIT_HTML_PROP_ATTRIBUTE_MODIFIER,
                onTagName: onTagName
            });
        }));
    }
    // Code completions for "?[...]";
    else if (location.word.startsWith(LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER)) {
        var alreadyUsedAttrNames_1 = htmlNode.attributes
            .filter(function (a) { return a.modifier === LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER || a.modifier == null; })
            .map(function (a) { return a.name; });
        var unusedAttrs_1 = iterableFilter(htmlStore.getAllAttributesForTag(htmlNode), function (prop) { return !alreadyUsedAttrNames_1.includes(prop.name); });
        var booleanAttributes = iterableFilter(unusedAttrs_1, function (prop) { return isAssignableToBoolean(prop.getType()); });
        return Array.from(iterableMap(booleanAttributes, function (attr) {
            return targetToCompletion(attr, {
                modifier: LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER,
                onTagName: onTagName
            });
        }));
    }
    // Code completions for "@[...]";
    else if (location.word.startsWith(LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER)) {
        var alreadyUsedEventNames_1 = htmlNode.attributes.filter(function (a) { return a.modifier === LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER; }).map(function (a) { return a.name; });
        var unusedEvents = iterableFilter(htmlStore.getAllEventsForTag(htmlNode), function (prop) { return !alreadyUsedEventNames_1.includes(prop.name); });
        return Array.from(iterableMap(unusedEvents, function (prop) {
            return targetToCompletion(prop, {
                modifier: LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER,
                onTagName: onTagName
            });
        }));
    }
    var alreadyUsedAttrNames = htmlNode.attributes.filter(function (a) { return a.modifier == null; }).map(function (a) { return a.name; });
    var unusedAttrs = iterableFilter(htmlStore.getAllAttributesForTag(htmlNode), function (prop) { return !alreadyUsedAttrNames.includes(prop.name); });
    return Array.from(iterableMap(unusedAttrs, function (prop) { return targetToCompletion(prop, { modifier: "", onTagName: onTagName }); }));
}
function isAssignableToBoolean(type, _a) {
    var matchAny = (_a === void 0 ? { matchAny: true } : _a).matchAny;
    return tsSimpleType.isAssignableToSimpleTypeKind(type, [tsSimpleType.SimpleTypeKind.BOOLEAN, tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL], {
        op: "or",
        matchAny: matchAny
    });
}
function targetToCompletion(target, _a) {
    var modifier = _a.modifier, insertModifier = _a.insertModifier, onTagName = _a.onTagName;
    if (modifier == null) {
        if (isHtmlAttr(target)) {
            if (isAssignableToBoolean(target.getType(), { matchAny: false })) {
                modifier = LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER;
            }
            else {
                modifier = "";
            }
        }
        else if (isHtmlProp(target)) {
            modifier = LIT_HTML_PROP_ATTRIBUTE_MODIFIER;
        }
        else if (isHtmlEvent(target)) {
            modifier = LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER;
        }
    }
    var isMember = onTagName && target.fromTagName === onTagName;
    var isBuiltIn = target.builtIn;
    return {
        name: "" + (modifier || "") + target.name + ("required" in target && target.required ? "!" : ""),
        insert: "" + (insertModifier ? modifier : "") + target.name,
        kind: isBuiltIn ? "enumElement" : isMember ? "member" : "label",
        importance: isBuiltIn ? "low" : isMember ? "high" : "medium",
        documentation: lazy(function () { return documentationForTarget(target, { modifier: modifier }); })
    };
}

function completionsForHtmlNodes(intersectingClosestNode, _a, _b) {
    var offset = _a.offset, leftWord = _a.leftWord, rightWord = _a.rightWord, beforeWord = _a.beforeWord, afterWord = _a.afterWord;
    var document = _b.document, htmlStore = _b.htmlStore, logger = _b.logger;
    var isClosingTag = beforeWord === "/";
    // This case handles closing the closest intersecting node.
    // For this case we only suggest closing the closest intersecting node: so 1 single suggestion.
    // Example:   <my-element></|
    // This doesn't handle:   <my-element></my-el|ement> , because in that case we would like to show all options to the user.
    if (isClosingTag && leftWord === "" && rightWord === "" && afterWord !== ">" && intersectingClosestNode != null) {
        var insert = "</" + intersectingClosestNode.tagName + ">";
        return [
            {
                name: insert,
                insert: insert,
                kind: "enumElement",
                importance: "high",
                range: {
                    document: document,
                    start: offset - leftWord.length - 2,
                    end: offset + rightWord.length
                },
                documentation: lazy(function () {
                    var htmlTag = htmlStore.getHtmlTag(intersectingClosestNode);
                    return htmlTag != null ? documentationForHtmlTag(htmlTag) : undefined;
                })
            }
        ];
    }
    var htmlTags = Array.from(htmlStore.getGlobalTags());
    return htmlTags.map(function (htmlTag) {
        var isBuiltIn = !isCustomElementTagName(htmlTag.tagName);
        var hasDeclaration = htmlTag.declaration != null;
        var insert = isClosingTag ? "</" + htmlTag.tagName + ">" : htmlTag.tagName;
        return {
            name: insert,
            insert: insert,
            kind: isBuiltIn ? "enumElement" : hasDeclaration ? "member" : "label",
            importance: isBuiltIn ? "low" : hasDeclaration ? "high" : "medium",
            range: {
                document: document,
                start: offset - leftWord.length - (isClosingTag ? 2 : 0),
                end: offset + rightWord.length + (isClosingTag && afterWord === ">" ? 1 : 0)
            },
            documentation: lazy(function () { return documentationForHtmlTag(htmlTag); })
        };
    });
}

function completionsAtOffset(document, offset, request) {
    var positionContext = getPositionContextInDocument(document, offset);
    var beforeWord = positionContext.beforeWord;
    // Get possible intersecting html attribute or attribute area.
    var intersectingAttr = document.htmlAttrNameAtOffset(offset);
    var intersectingAttrAreaNode = document.htmlAttrAreaAtOffset(offset);
    var intersectingAttrAssignment = document.htmlAttrAssignmentAtOffset(offset);
    var intersectingClosestNode = document.htmlNodeClosestToOffset(offset);
    // Get entries from the extensions
    if (intersectingAttr != null) {
        var entries = completionsForHtmlAttrs(intersectingAttr.htmlNode, positionContext, request);
        // Make sure that every entry overwrites the entire attribute name.
        return entries.map(function (entry) { return (__assign({}, entry, { range: __assign({ document: request.document }, intersectingAttr.location.name) })); });
    }
    else if (intersectingAttrAssignment != null) {
        return completionsForHtmlAttrValues(intersectingAttrAssignment, positionContext, request);
    }
    else if (intersectingAttrAreaNode != null) {
        return completionsForHtmlAttrs(intersectingAttrAreaNode, positionContext, request);
    }
    else if (beforeWord === "<" || beforeWord === "/") {
        return completionsForHtmlNodes(intersectingClosestNode, positionContext, request);
    }
    return [];
}

function definitionForHtmlAttr(htmlAttr, _a) {
    var htmlStore = _a.htmlStore, document = _a.document;
    var target = htmlStore.getHtmlAttrTarget(htmlAttr);
    if (target == null)
        return undefined;
    if (isHtmlMember(target) && target.declaration != null) {
        return {
            kind: exports.DefinitionKind.MEMBER,
            fromRange: __assign({ document: document }, htmlAttr.location.name),
            target: target.declaration
        };
    }
    else if (isHtmlEvent(target) && target.declaration != null) {
        return {
            kind: exports.DefinitionKind.EVENT,
            fromRange: __assign({ document: document }, htmlAttr.location.name),
            target: target.declaration
        };
    }
    return;
}

function definitionForHtmlNode(htmlNode, _a) {
    var document = _a.document, htmlStore = _a.htmlStore;
    var tag = htmlStore.getHtmlTag(htmlNode);
    if (tag == null || tag.declaration == null)
        return undefined;
    return {
        kind: exports.DefinitionKind.COMPONENT,
        fromRange: __assign({ document: document }, htmlNode.location.name),
        target: tag.declaration
    };
}

function validateHtmlNode(htmlNode, request) {
    var e_1, _a;
    try {
        for (var _b = __values(request.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
            var rule = _c.value;
            if (isRuleEnabled(request.config, rule.name) && rule.visitHtmlNode != null) {
                var result = rule.visitHtmlNode(htmlNode, request);
                if (result != null) {
                    return result;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return [];
}

function validateHtmlAttr(htmlAttr, request) {
    var e_1, _a;
    try {
        for (var _b = __values(request.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
            var rule = _c.value;
            if (isRuleEnabled(request.config, rule.name) && rule.visitHtmlAttribute != null) {
                var result = rule.visitHtmlAttribute(htmlAttr, request);
                if (result != null) {
                    return result;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return [];
}

function validateHtmlAttrAssignment(assignment, request) {
    var e_1, _a;
    try {
        for (var _b = __values(request.rules), _c = _b.next(); !_c.done; _c = _b.next()) {
            var rule = _c.value;
            if (isRuleEnabled(request.config, rule.name) && rule.visitHtmlAssignment != null) {
                var result = rule.visitHtmlAssignment(assignment, request);
                if (result != null) {
                    return result;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return [];
}

function validateHTMLDocument(htmlDocument, request) {
    var reports = [];
    var iterateNodes = function (nodes) {
        var e_1, _a;
        try {
            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
                var childNode = nodes_1_1.value;
                reports.push.apply(reports, __spread(validateHtmlNode(childNode, request)));
                var iterateAttrs = function (attrs) {
                    var e_2, _a;
                    try {
                        for (var attrs_1 = (e_2 = void 0, __values(attrs)), attrs_1_1 = attrs_1.next(); !attrs_1_1.done; attrs_1_1 = attrs_1.next()) {
                            var attr = attrs_1_1.value;
                            reports.push.apply(reports, __spread(validateHtmlAttr(attr, request)));
                            if (attr.assignment != null) {
                                reports.push.apply(reports, __spread(validateHtmlAttrAssignment(attr.assignment, request)));
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (attrs_1_1 && !attrs_1_1.done && (_a = attrs_1.return)) _a.call(attrs_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                };
                iterateAttrs(childNode.attributes);
                iterateNodes(childNode.children);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    iterateNodes(htmlDocument.rootNodes);
    return reports;
}

var htmlService = vscode$1.getLanguageService();
function makeVscTextDocument$1(htmlDocument) {
    return vscode$1.TextDocument.create("untitled://embedded.html", "html", 1, htmlDocument.virtualDocument.text);
}
function makeVscHtmlDocument(vscTextDocument) {
    return htmlService.parseHTMLDocument(vscTextDocument);
}
var LitHtmlVscodeService = /** @class */ (function () {
    function LitHtmlVscodeService() {
    }
    LitHtmlVscodeService.prototype.getClosingTagAtOffset = function (document, offset) {
        var vscTextDocument = makeVscTextDocument$1(document);
        var vscHtmlDocument = makeVscHtmlDocument(vscTextDocument);
        var htmlLSPosition = vscTextDocument.positionAt(offset);
        var tagComplete = htmlService.doTagComplete(vscTextDocument, htmlLSPosition, vscHtmlDocument);
        if (tagComplete == null)
            return;
        // Html returns completions with snippet placeholders. Strip these out.
        return {
            newText: tagComplete.replace(/\$\d/g, "")
        };
    };
    LitHtmlVscodeService.prototype.format = function (document, settings) {
        var parts = document.virtualDocument.getPartsAtOffsetRange({
            start: 0,
            end: document.virtualDocument.location.end - document.virtualDocument.location.start
        });
        var ranges = textPartsToRanges(parts);
        var originalHtml = parts.map(function (p) { return (typeof p === "string" ? p : "[#" + "#".repeat(p.getText().length) + "]"); }).join("");
        var vscTextDocument = vscode$1.TextDocument.create("untitled://embedded.html", "html", 1, originalHtml);
        var edits = htmlService.format(vscTextDocument, undefined, {
            tabSize: settings.tabSize,
            insertSpaces: !!settings.convertTabsToSpaces,
            wrapLineLength: 90,
            unformatted: "",
            contentUnformatted: "pre,code,textarea",
            indentInnerHtml: true,
            preserveNewLines: true,
            maxPreserveNewLines: undefined,
            indentHandlebars: false,
            endWithNewline: false,
            extraLiners: "head, body, /html",
            wrapAttributes: "auto"
        });
        var hasLeadingNewline = originalHtml.startsWith("\n");
        var hasTrailingNewline = originalHtml.endsWith("\n");
        var newHtml = "" + (hasLeadingNewline ? "\n" : "") + vscode$1.TextDocument.applyEdits(vscTextDocument, edits) + (hasTrailingNewline ? "\n" : "");
        var splitted = newHtml.split(/\[#+\]/);
        return splitted.map(function (newText, i) {
            var range = ranges[i];
            return { range: __assign({ document: document }, range), newText: newText };
        });
    };
    return LitHtmlVscodeService;
}());

function quickInfoForHtmlAttr(htmlAttr, _a) {
    var document = _a.document, htmlStore = _a.htmlStore;
    var target = htmlStore.getHtmlAttrTarget(htmlAttr);
    if (target == null)
        return undefined;
    return {
        range: __assign({ document: document }, htmlAttr.location.name),
        primaryInfo: targetKindAndTypeText(target, { modifier: htmlAttr.modifier }),
        secondaryInfo: descriptionForTarget(target, { markdown: true })
    };
}

function quickInfoForHtmlNode(htmlNode, _a) {
    var htmlStore = _a.htmlStore, document = _a.document;
    var htmlTag = htmlStore.getHtmlTag(htmlNode);
    if (htmlTag == null)
        return undefined;
    return {
        range: __assign({ document: document }, htmlNode.location.name),
        primaryInfo: "<" + htmlNode.tagName + ">",
        secondaryInfo: documentationForHtmlTag(htmlTag, { markdown: true })
    };
}

/**
 * Tests nodes recursively walking up the tree using parent nodes.
 * @param node
 * @param test
 */
function findParent(node, test) {
    if (node == null)
        return;
    return test(node) ? node : findParent(node.parent, test);
}
function findChild(node, test) {
    if (!node)
        return;
    if (test(node))
        return node;
    return node.forEachChild(function (child) { return findChild(child, test); });
}
/**
 * Returns a node at a specific position.
 * @param node
 * @param position
 */
function getNodeAtPosition(node, position) {
    if (!intersects(position, { start: node.pos, end: node.end })) {
        return;
    }
    return node.forEachChild(function (child) { return getNodeAtPosition(child, position); }) || node;
}
function nodeIntersects(nodeA, nodeB) {
    return intersects({
        start: nodeA.getStart(),
        end: nodeA.getEnd()
    }, {
        start: nodeB.getStart(),
        end: nodeB.getEnd()
    });
}

function renameLocationsForTagName(tagName, request) {
    var e_1, _a, e_2, _b;
    var locations = [];
    try {
        for (var _c = __values(request.program.getSourceFiles()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var sourceFile = _d.value;
            var documents = request.documentStore.getDocumentsInFile(sourceFile, request.config);
            var _loop_1 = function (document_1) {
                if (document_1 instanceof HtmlDocument) {
                    document_1.rootNodes.forEach(function (rootNode) {
                        return visitHtmlNode(rootNode, {
                            document: document_1,
                            tagName: tagName,
                            emitRenameLocation: function (location) {
                                locations.push(location);
                            }
                        });
                    });
                }
            };
            try {
                for (var documents_1 = (e_2 = void 0, __values(documents)), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
                    var document_1 = documents_1_1.value;
                    _loop_1(document_1);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (documents_1_1 && !documents_1_1.done && (_b = documents_1.return)) _b.call(documents_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var definition = request.definitionStore.getDefinitionForTagName(tagName);
    if (definition != null) {
        var definitionNode = definition.node;
        var fileName = definitionNode.getSourceFile().fileName;
        if (request.ts.isCallLikeExpression(definitionNode)) {
            var stringLiteralNode = findChild(definitionNode, function (child) { return request.ts.isStringLiteralLike(child) && child.text === tagName; });
            if (stringLiteralNode != null) {
                locations.push({
                    fileName: fileName,
                    range: { start: stringLiteralNode.getStart() + 1, end: stringLiteralNode.getEnd() - 1 }
                });
            }
        }
        else if (definitionNode.kind === request.ts.SyntaxKind.JSDocTag) {
            var jsDocTagNode = definitionNode;
            if (jsDocTagNode.comment != null) {
                var start = jsDocTagNode.tagName.getEnd() + 1;
                locations.push({
                    fileName: fileName,
                    range: { start: start, end: start + jsDocTagNode.comment.length }
                });
            }
        }
        else if (request.ts.isInterfaceDeclaration(definitionNode)) {
            var stringLiteralNode = findChild(definitionNode, function (child) { return request.ts.isStringLiteralLike(child) && child.text === tagName; });
            if (stringLiteralNode != null) {
                locations.push({
                    fileName: fileName,
                    range: { start: stringLiteralNode.getStart() + 1, end: stringLiteralNode.getEnd() - 1 }
                });
            }
        }
    }
    return locations;
}
function visitHtmlNode(node, context) {
    if (node.tagName === context.tagName) {
        context.emitRenameLocation({
            range: __assign({ document: context.document }, node.location.name),
            fileName: context.document.virtualDocument.fileName
        });
        if (node.location.endTag != null) {
            var _a = node.location.endTag, start = _a.start, end = _a.end;
            context.emitRenameLocation({
                range: { document: context.document, start: start + 2, end: end - 1 },
                fileName: context.document.virtualDocument.fileName
            });
        }
    }
    node.children.forEach(function (childNode) { return visitHtmlNode(childNode, context); });
}

function renameLocationsAtOffset(document, offset, request) {
    var hit = document.htmlNodeOrAttrAtOffset(offset);
    if (hit == null)
        return [];
    if (isHTMLNode(hit)) {
        return renameLocationsForTagName(hit.tagName, request);
    }
    return [];
}

var LitHtmlDocumentAnalyzer = /** @class */ (function () {
    function LitHtmlDocumentAnalyzer() {
        this.vscodeHtmlService = new LitHtmlVscodeService();
        this.completionsCache = [];
    }
    LitHtmlDocumentAnalyzer.prototype.getCompletionDetailsAtOffset = function (document, offset, name, request) {
        var completionWithName = this.completionsCache.find(function (completion) { return completion.name === name; });
        if (completionWithName == null || completionWithName.documentation == null)
            return undefined;
        var primaryInfo = completionWithName.documentation();
        if (primaryInfo == null)
            return undefined;
        return {
            name: name,
            kind: completionWithName.kind,
            primaryInfo: primaryInfo
        };
    };
    LitHtmlDocumentAnalyzer.prototype.getCompletionsAtOffset = function (document, offset, request) {
        this.completionsCache = completionsAtOffset(document, offset, request);
        return completionsAtOffset(document, offset, request);
    };
    LitHtmlDocumentAnalyzer.prototype.getDiagnostics = function (document, request) {
        return validateHTMLDocument(document, request);
    };
    LitHtmlDocumentAnalyzer.prototype.getClosingTagAtOffset = function (document, offset) {
        return this.vscodeHtmlService.getClosingTagAtOffset(document, offset);
    };
    LitHtmlDocumentAnalyzer.prototype.getCodeFixesAtOffsetRange = function (document, offsetRange, request) {
        var hit = document.htmlNodeOrAttrAtOffset(offsetRange);
        if (hit == null)
            return [];
        var reports = validateHTMLDocument(document, request);
        return flatten(reports.filter(function (report) { return intersects(offsetRange, report.location); }).map(function (report) { return codeFixesForHtmlReport(report, request); }));
    };
    LitHtmlDocumentAnalyzer.prototype.getDefinitionAtOffset = function (document, offset, request) {
        var hit = document.htmlNodeOrAttrAtOffset(offset);
        if (hit == null)
            return undefined;
        if (isHTMLNode(hit)) {
            return definitionForHtmlNode(hit, request);
        }
        else if (isHTMLAttr(hit)) {
            return definitionForHtmlAttr(hit, request);
        }
        return;
    };
    LitHtmlDocumentAnalyzer.prototype.getRenameInfoAtOffset = function (document, offset, request) {
        var hit = document.htmlNodeOrAttrAtOffset(offset);
        if (hit == null)
            return undefined;
        if (isHTMLNode(hit)) {
            return {
                kind: "memberVariableElement",
                fullDisplayName: hit.tagName,
                displayName: hit.tagName,
                range: __assign({ document: document }, hit.location.name),
                document: document,
                target: hit
            };
        }
        return;
    };
    LitHtmlDocumentAnalyzer.prototype.getRenameLocationsAtOffset = function (document, offset, request) {
        return renameLocationsAtOffset(document, offset, request);
    };
    LitHtmlDocumentAnalyzer.prototype.getQuickInfoAtOffset = function (document, offset, request) {
        var hit = document.htmlNodeOrAttrAtOffset(offset);
        if (hit == null)
            return undefined;
        if (isHTMLNode(hit)) {
            return quickInfoForHtmlNode(hit, request);
        }
        if (isHTMLAttr(hit)) {
            return quickInfoForHtmlAttr(hit, request);
        }
        return;
    };
    LitHtmlDocumentAnalyzer.prototype.getOutliningSpans = function (document) {
        return iterableDefined(document.mapNodes(function (node) {
            if (node.location.endTag == null)
                return undefined;
            // Calculate last index of the collapsed span.
            // We don't want to include the last line because it will include the </endtag> in the collapsed region
            var endIndex = (function () {
                var lastChild = node.children[node.children.length - 1];
                if (lastChild != null) {
                    return lastChild.location.endTag != null ? lastChild.location.endTag.start : lastChild.location.startTag.end;
                }
                return node.location.endTag.start;
            })();
            return {
                autoCollapse: false,
                bannerText: node.tagName,
                kind: exports.LitOutliningSpanKind.Code,
                location: { document: document, start: node.location.startTag.end, end: endIndex }
            };
        }));
    };
    LitHtmlDocumentAnalyzer.prototype.getFormatEdits = function (document, settings) {
        return this.vscodeHtmlService.format(document, settings);
    };
    return LitHtmlDocumentAnalyzer;
}());

var LitAnalyzer = /** @class */ (function () {
    function LitAnalyzer(context) {
        this.context = context;
        this.litHtmlDocumentAnalyzer = new LitHtmlDocumentAnalyzer();
        this.litCssDocumentAnalyzer = new LitCssDocumentAnalyzer();
        // Set the Typescript module
        // I plan on removing these methods, so only "context.ts" is used.
        setTypescriptModule(context.ts);
        tsSimpleType.setTypescriptModule(context.ts);
    }
    LitAnalyzer.prototype.getOutliningSpansInFile = function (file) {
        var _this = this;
        var documents = this.getDocumentsInFile(file);
        this.context.updateComponents(file);
        return flatten(documents.map(function (document) {
            if (document instanceof CssDocument) {
                return [];
            }
            else if (document instanceof HtmlDocument) {
                return _this.litHtmlDocumentAnalyzer.getOutliningSpans(document);
            }
            return [];
        }));
    };
    LitAnalyzer.prototype.getDefinitionAtPosition = function (file, position) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document == null)
            return undefined;
        this.context.updateComponents(file);
        var request = this.makeRequest({ file: file, document: document });
        if (document instanceof CssDocument) {
            return this.litCssDocumentAnalyzer.getDefinitionAtOffset(document, offset, request);
        }
        else if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getDefinitionAtOffset(document, offset, request);
        }
        return;
    };
    LitAnalyzer.prototype.getQuickInfoAtPosition = function (file, position) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document == null)
            return undefined;
        this.context.updateComponents(file);
        var request = this.makeRequest({ file: file, document: document });
        if (document instanceof CssDocument) {
            return this.litCssDocumentAnalyzer.getQuickInfoAtOffset(document, offset, request);
        }
        else if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getQuickInfoAtOffset(document, offset, request);
        }
        return;
    };
    LitAnalyzer.prototype.getRenameInfoAtPosition = function (file, position) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document != null) {
            var request = this.makeRequest({ file: file, document: document });
            if (document instanceof CssDocument) {
                return undefined;
            }
            else if (document instanceof HtmlDocument) {
                return this.litHtmlDocumentAnalyzer.getRenameInfoAtOffset(document, offset, request);
            }
        }
        else {
            var nodeUnderCursor = getNodeAtPosition(file, position);
            if (nodeUnderCursor == null)
                return undefined;
            if (this.context.ts.isStringLiteralLike(nodeUnderCursor)) {
                var tagName = nodeUnderCursor.text;
                var definition = this.context.definitionStore.getDefinitionForTagName(tagName);
                if (definition != null && nodeIntersects(nodeUnderCursor, definition.node)) {
                    return {
                        fullDisplayName: tagName,
                        displayName: tagName,
                        range: { start: nodeUnderCursor.getStart() + 1, end: nodeUnderCursor.getEnd() - 1 },
                        kind: "label",
                        target: definition
                    };
                }
            }
        }
        return;
    };
    LitAnalyzer.prototype.getRenameLocationsAtPosition = function (file, position) {
        var renameInfo = this.getRenameInfoAtPosition(file, position);
        if (renameInfo == null)
            return [];
        if ("document" in renameInfo) {
            var document_1 = renameInfo.document;
            var offset = document_1.virtualDocument.scPositionToOffset(position);
            var request = this.makeRequest({ file: file, document: document_1 });
            if (document_1 instanceof CssDocument) {
                return [];
            }
            else {
                return this.litHtmlDocumentAnalyzer.getRenameLocationsAtOffset(document_1, offset, request);
            }
        }
        else {
            return renameLocationsForTagName(renameInfo.target.tagName, this.context);
        }
    };
    LitAnalyzer.prototype.getClosingTagAtPosition = function (file, position) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document == null)
            return undefined;
        this.context.updateComponents(file);
        if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getClosingTagAtOffset(document, offset);
        }
        return;
    };
    LitAnalyzer.prototype.getCompletionDetailsAtPosition = function (file, position, name) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document == null)
            return undefined;
        var request = this.makeRequest({ file: file, document: document });
        if (document instanceof CssDocument) {
            return this.litCssDocumentAnalyzer.getCompletionDetailsAtOffset(document, offset, name, request);
        }
        else if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getCompletionDetailsAtOffset(document, offset, name, request);
        }
        return;
    };
    LitAnalyzer.prototype.getCompletionsAtPosition = function (file, position) {
        var _a = this.getDocumentAndOffsetAtPosition(file, position), document = _a.document, offset = _a.offset;
        if (document == null)
            return undefined;
        this.context.updateComponents(file);
        var request = this.makeRequest({ file: file, document: document });
        if (document instanceof CssDocument) {
            return this.litCssDocumentAnalyzer.getCompletionsAtOffset(document, offset, request);
        }
        else if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getCompletionsAtOffset(document, offset, request);
        }
        return;
    };
    LitAnalyzer.prototype.getDiagnosticsInFile = function (file) {
        var _this = this;
        var documents = this.getDocumentsInFile(file);
        this.context.updateComponents(file);
        this.context.updateDependencies(file);
        var documentDiagnostics = flatten(documents.map(function (document) {
            var request = _this.makeRequest({ document: document, file: file });
            if (document instanceof CssDocument) {
                return _this.litCssDocumentAnalyzer.getDiagnostics(document, request);
            }
            else if (document instanceof HtmlDocument) {
                return _this.litHtmlDocumentAnalyzer.getDiagnostics(document, request);
            }
            return [];
        }));
        var analyzeDiagnostics = this.context.definitionStore.getAnalysisDiagnosticsInFile(file).map(function (diagnostic) {
            return ({
                file: diagnostic.node.getSourceFile(),
                message: diagnostic.message,
                severity: diagnostic.severity,
                location: {
                    start: diagnostic.node.getStart(),
                    end: diagnostic.node.getEnd()
                }
            });
        });
        return __spread(documentDiagnostics, analyzeDiagnostics);
    };
    LitAnalyzer.prototype.getCodeFixesAtPositionRange = function (file, positionRange) {
        var document = this.getDocumentAndOffsetAtPosition(file, positionRange.start).document;
        if (document == null)
            return [];
        this.context.updateComponents(file);
        this.context.updateDependencies(file);
        var offsetRange = {
            start: document.virtualDocument.scPositionToOffset(positionRange.start),
            end: document.virtualDocument.scPositionToOffset(positionRange.end)
        };
        var request = this.makeRequest({ file: file, document: document });
        if (document instanceof HtmlDocument) {
            return this.litHtmlDocumentAnalyzer.getCodeFixesAtOffsetRange(document, offsetRange, request);
        }
        return [];
    };
    LitAnalyzer.prototype.getFormatEditsInFile = function (file, settings) {
        var _this = this;
        var documents = this.getDocumentsInFile(file);
        return flatten(documents.map(function (document) {
            if (document instanceof CssDocument) {
                return [];
            }
            else if (document instanceof HtmlDocument) {
                return _this.litHtmlDocumentAnalyzer.getFormatEdits(document, settings);
            }
            return [];
        }));
    };
    /*private sendRequest<FuncName extends keyof LitDocumentAnalyzer, Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>>( funcName: "getCompletionsAtOffset", { file, document }: { file: SourceFile; document: TextDocument }, offset: number);
     private sendRequest<FuncName extends keyof LitDocumentAnalyzer, Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>>( funcName: FuncName, { file, document }: { file: SourceFile; document: TextDocument }, arg1: number ) {
     const request = this.makeRequest({ file, document });

     const func = (() => {
     if (document instanceof CssDocument) {
     //return this.litCssDocumentAnalyzer[funcName];
     } else if (document instanceof HtmlDocument) {
     return this.litHtmlDocumentAnalyzer[funcName];
     }
     })() as LitDocumentAnalyzer[FuncName];

     if (func == null) return undefined;

     switch (funcName) {
     case "getCompletionsAtOffset":
     return func(document, arg1, request);
     }
     }*/
    /*private sendRequest<
     FuncName extends keyof LitDocumentAnalyzer,
     Params extends Parameters<NonNullable<LitDocumentAnalyzer[FuncName]>>,
     Arg = Params extends { length: infer L } ? (L extends 1 ? never : (L extends 2 ? never : Params[1])) : never
     >(funcName: FuncName, { file, document }: { file: SourceFile; document: TextDocument }, arg1: Arg) {
     const request = this.makeRequest({ file, document });

     const func = (() => {
     if (document instanceof CssDocument) {
     return this.litCssDocumentAnalyzer[funcName];
     } else if (document instanceof HtmlDocument) {
     return this.litHtmlDocumentAnalyzer[funcName];
     }
     })();

     if (arg1 == null) {
     }
     }*/
    LitAnalyzer.prototype.makeRequest = function (options) {
        var _a = this.context, project = _a.project, htmlStore = _a.htmlStore, dependencyStore = _a.dependencyStore, definitionStore = _a.definitionStore, config = _a.config, updateDependencies = _a.updateDependencies, updateComponents = _a.updateComponents, ts = _a.ts, program = _a.program, documentStore = _a.documentStore, logger = _a.logger, updateConfig = _a.updateConfig, rules = _a.rules;
        return __assign({ htmlStore: htmlStore,
            dependencyStore: dependencyStore,
            definitionStore: definitionStore,
            config: config,
            updateDependencies: updateDependencies,
            updateComponents: updateComponents,
            ts: ts,
            project: project,
            program: program,
            documentStore: documentStore,
            logger: logger,
            updateConfig: updateConfig,
            rules: rules }, options);
    };
    LitAnalyzer.prototype.getDocumentAndOffsetAtPosition = function (sourceFile, position) {
        var document = this.context.documentStore.getDocumentAtPosition(sourceFile, position, this.context.config);
        return {
            document: document,
            offset: document != null ? document.virtualDocument.scPositionToOffset(position) : -1
        };
    };
    LitAnalyzer.prototype.getDocumentsInFile = function (sourceFile) {
        return this.context.documentStore.getDocumentsInFile(sourceFile, this.context.config);
    };
    return LitAnalyzer;
}());

function parseHtmlData(data) {
    switch (data.version) {
        case 1:
            return parseDataV1(data);
    }
}
function parseDataV1(data) {
    var valueSetTypeMap = valueSetsToTypeMap(data.valueSets || []);
    valueSetTypeMap.set("v", { kind: tsSimpleType.SimpleTypeKind.BOOLEAN });
    var tags = (data.tags || []).map(function (tagData) { return tagDataToHtmlTag(tagData, valueSetTypeMap); });
    var attrs = (data.globalAttributes || []).map(function (tagDataAttr) { return tagDataToHtmlTagAttr(tagDataAttr, valueSetTypeMap); });
    return {
        tags: tags,
        attrs: attrs,
        events: []
    };
}
function tagDataToHtmlTag(tagData, typeMap) {
    var name = tagData.name, description = tagData.description;
    var attributes = tagData.attributes.map(function (tagDataAttr) { return tagDataToHtmlTagAttr(tagDataAttr, typeMap, name); });
    return {
        tagName: name,
        description: description,
        attributes: attributes,
        properties: [],
        events: [],
        slots: []
    };
}
function tagDataToHtmlTagAttr(tagDataAttr, typeMap, fromTagName) {
    var name = tagDataAttr.name, description = tagDataAttr.description, valueSet = tagDataAttr.valueSet, values = tagDataAttr.values;
    var type = valueSet != null ? typeMap.get(valueSet) : values != null ? attrValuesToUnion(values) : undefined;
    return {
        kind: "attribute",
        name: name,
        description: description,
        fromTagName: fromTagName,
        getType: lazy(function () { return type || { kind: tsSimpleType.SimpleTypeKind.ANY }; })
    };
}
function valueSetsToTypeMap(valueSets) {
    var entries = valueSets.map(function (valueSet) { return [valueSet.name, attrValuesToUnion(valueSet.values)]; });
    return new Map(entries);
}
function attrValuesToUnion(attrValues) {
    return {
        kind: tsSimpleType.SimpleTypeKind.UNION,
        types: attrValues.map(function (value) {
            return ({
                value: value.name,
                kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL
            });
        })
    };
}

var HTML_5_ATTR_TYPES = {
    onafterprint: "string",
    onbeforeprint: "string",
    onbeforeunload: "string",
    onhashchange: "string",
    onlanguagechange: "string",
    onmessage: "string",
    onoffline: "string",
    ononline: "string",
    onpagehide: "string",
    onpageshow: "string",
    onpopstate: "string",
    onstorage: "string",
    onunload: "string",
    "aria-activedescendant": "",
    "aria-colcount": "",
    "aria-colindex": "",
    "aria-colspan": "",
    "aria-controls": "",
    "aria-describedat": "",
    "aria-describedby": "",
    "aria-errormessage": "",
    "aria-flowto": "",
    "aria-kbdshortcuts": "",
    "aria-label": "",
    "aria-labelledby": "",
    "aria-level": "",
    "aria-owns": "",
    "aria-placeholder": "",
    "aria-posinset": "",
    "aria-roledescription": "",
    "aria-rowcount": "",
    "aria-rowindex": "",
    "aria-rowspan": "",
    "aria-setsize": "",
    "aria-valuemax": "",
    "aria-valuemin": "",
    "aria-valuenow": "",
    "aria-valuetext": "",
    accesskey: "string",
    class: "string",
    contextmenu: "string",
    dropzone: ["copy", "move", "link"],
    id: "string",
    itemid: "",
    itemprop: "",
    itemref: "",
    itemtype: "",
    lang: "string",
    style: "string",
    tabindex: "number",
    title: "string",
    manifest: "",
    href: "string",
    target: ["_blank", "_parent", "_self", "_top"],
    rel: "",
    media: "",
    hreflang: "",
    type: "",
    sizes: "",
    name: "string",
    "http-equiv": "",
    content: "",
    charset: "",
    nonce: "",
    cite: "",
    start: "",
    value: "string",
    download: "boolean|string",
    ping: "",
    datetime: "",
    alt: "string",
    src: "string",
    srcset: "",
    usemap: "",
    width: "number|string",
    height: "number|string",
    srcdoc: "",
    data: "",
    form: "string",
    poster: "string",
    mediagroup: "",
    label: "string",
    srclang: "string",
    coords: "string",
    border: ["0", "1"],
    span: "number",
    colspan: "number",
    rowspan: "number",
    headers: "string",
    sorted: "",
    abbr: "string",
    "accept-charset": "string",
    action: "string",
    for: "string",
    accept: "string",
    dirname: "string",
    formaction: "string",
    formtarget: ["_self", "_blank", "_parent", "_top"],
    list: "string",
    max: "number",
    maxlength: "number",
    min: "number",
    minlength: "number",
    pattern: "string",
    placeholder: "string",
    size: "number",
    step: "number",
    cols: "number",
    rows: "number",
    low: "number",
    high: "number",
    optimum: "number"
};
function hasTypeForAttrName(attrName) {
    return HTML_5_ATTR_TYPES[attrName] != null && HTML_5_ATTR_TYPES[attrName].length > 0;
}
function html5TagAttrType(attrName) {
    return stringToSimpleType(HTML_5_ATTR_TYPES[attrName] || "", attrName);
}
function stringToSimpleType(typeString, name) {
    if (Array.isArray(typeString)) {
        return {
            kind: tsSimpleType.SimpleTypeKind.UNION,
            types: typeString.map(function (value) { return ({ kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL, value: value }); })
        };
    }
    if (typeString.includes("|")) {
        return {
            kind: tsSimpleType.SimpleTypeKind.UNION,
            types: typeString.split("|").map(function (typeStr) { return stringToSimpleType(typeStr); })
        };
    }
    switch (typeString) {
        case "number":
            return { kind: tsSimpleType.SimpleTypeKind.NUMBER, name: name };
        case "boolean":
            return { kind: tsSimpleType.SimpleTypeKind.BOOLEAN, name: name };
        case "string":
            return { kind: tsSimpleType.SimpleTypeKind.STRING, name: name };
        default:
            return { kind: tsSimpleType.SimpleTypeKind.ANY, name: name };
    }
}
/**
 * Data from vscode-html-languageservice
 */
var EXTRA_HTML5_EVENTS = [
    {
        name: "onabort",
        description: "The loading of a resource has been aborted."
    },
    {
        name: "onabort",
        description: "Progression has been terminated (not due to an error)."
    },
    {
        name: "onabort",
        description: "A transaction has been aborted."
    },
    {
        name: "onafterprint",
        description: "The associated document has started printing or the print preview has been closed."
    },
    {
        name: "onanimationend",
        description: "A CSS animation has completed."
    },
    {
        name: "onanimationiteration",
        description: "A CSS animation is repeated."
    },
    {
        name: "onanimationstart",
        description: "A CSS animation has started."
    },
    {
        name: "onappinstalled",
        description: "A web application is successfully installed as a progressive web app."
    },
    {
        name: "onaudioprocess",
        description: "The input buffer of a ScriptProcessorNode is ready to be processed."
    },
    {
        name: "onaudioend",
        description: "The user agent has finished capturing audio for speech recognition."
    },
    {
        name: "onaudiostart",
        description: "The user agent has started to capture audio for speech recognition."
    },
    {
        name: "onbeforeprint",
        description: "The associated document is about to be printed or previewed for printing."
    },
    {
        name: "onbeforeunload",
        description: "The window, the document and its resources are about to be unloaded."
    },
    {
        name: "onbeginEvent",
        description: "A SMIL animation element begins."
    },
    {
        name: "onblocked",
        description: "An open connection to a database is blocking a versionchange transaction on the same database."
    },
    {
        name: "onblur",
        description: "An element has lost focus (does not bubble)."
    },
    {
        name: "onboundary",
        description: "The spoken utterance reaches a word or sentence boundary"
    },
    {
        name: "oncached",
        description: "The resources listed in the manifest have been downloaded, and the application is now cached."
    },
    {
        name: "oncanplay",
        description: "The user agent can play the media, but estimates that not enough data has been loaded to play the media up to its end without having to stop for further buffering of content."
    },
    {
        name: "oncanplaythrough",
        description: "The user agent can play the media up to its end without having to stop for further buffering of content."
    },
    {
        name: "onchange",
        description: "The change event is fired for <input>, <select>, and <textarea> elements when a change to the element's value is committed by the user."
    },
    {
        name: "onchargingchange",
        description: "The battery begins or stops charging."
    },
    {
        name: "onchargingtimechange",
        description: "The chargingTime attribute has been updated."
    },
    {
        name: "onchecking",
        description: "The user agent is checking for an update, or attempting to download the cache manifest for the first time."
    },
    {
        name: "onclick",
        description: "A pointing device button has been pressed and released on an element."
    },
    {
        name: "onclose",
        description: "A WebSocket connection has been closed."
    },
    {
        name: "oncomplete",
        description: "A transaction successfully completed."
    },
    {
        name: "oncomplete",
        description: "The rendering of an OfflineAudioContext is terminated."
    },
    {
        name: "oncompositionend",
        description: "The composition of a passage of text has been completed or canceled."
    },
    {
        name: "oncompositionstart",
        description: "The composition of a passage of text is prepared (similar to keydown for a keyboard input, but works with other inputs such as speech recognition)."
    },
    {
        name: "oncompositionupdate",
        description: "A character is added to a passage of text being composed."
    },
    {
        name: "oncontextmenu",
        description: "The right button of the mouse is clicked (before the context menu is displayed)."
    },
    {
        name: "oncopy",
        description: "The text selection has been added to the clipboard."
    },
    {
        name: "oncut",
        description: "The text selection has been removed from the document and added to the clipboard."
    },
    {
        name: "ondblclick",
        description: "A pointing device button is clicked twice on an element."
    },
    {
        name: "ondevicechange",
        description: "A media device such as a camera, microphone, or speaker is connected or removed from the system."
    },
    {
        name: "ondevicelight",
        description: "Fresh data is available from a light sensor."
    },
    {
        name: "ondevicemotion",
        description: "Fresh data is available from a motion sensor."
    },
    {
        name: "ondeviceorientation",
        description: "Fresh data is available from an orientation sensor."
    },
    {
        name: "ondeviceproximity",
        description: "Fresh data is available from a proximity sensor (indicates an approximated distance between the device and a nearby object)."
    },
    {
        name: "ondischargingtimechange",
        description: "The dischargingTime attribute has been updated."
    },
    {
        name: "onDOMActivate",
        description: "A button, link or state changing element is activated (use click instead)."
    },
    {
        name: "onDOMAttributeNameChanged",
        description: "The name of an attribute changed (use mutation observers instead)."
    },
    {
        name: "onDOMAttrModified",
        description: "The value of an attribute has been modified (use mutation observers instead)."
    },
    {
        name: "onDOMCharacterDataModified",
        description: "A text or another CharacterData has changed (use mutation observers instead)."
    },
    {
        name: "onDOMContentLoaded",
        description: "The document has finished loading (but not its dependent resources)."
    },
    {
        name: "onDOMElementNameChanged",
        description: "The name of an element changed (use mutation observers instead)."
    },
    {
        name: "onDOMFocusIn",
        description: "An element has received focus (use focus or focusin instead)."
    },
    {
        name: "onDOMFocusOut",
        description: "An element has lost focus (use blur or focusout instead)."
    },
    {
        name: "onDOMNodeInserted",
        description: "A node has been added as a child of another node (use mutation observers instead)."
    },
    {
        name: "onDOMNodeInsertedIntoDocument",
        description: "A node has been inserted into the document (use mutation observers instead)."
    },
    {
        name: "onDOMNodeRemoved",
        description: "A node has been removed from its parent node (use mutation observers instead)."
    },
    {
        name: "onDOMNodeRemovedFromDocument",
        description: "A node has been removed from the document (use mutation observers instead)."
    },
    {
        name: "onDOMSubtreeModified",
        description: "A change happened in the document (use mutation observers instead)."
    },
    {
        name: "ondownloading",
        description: "The user agent has found an update and is fetching it, or is downloading the resources listed by the cache manifest for the first time."
    },
    {
        name: "ondrag",
        description: "An element or text selection is being dragged (every 350ms)."
    },
    {
        name: "ondragend",
        description: "A drag operation is being ended (by releasing a mouse button or hitting the escape key)."
    },
    {
        name: "ondragenter",
        description: "A dragged element or text selection enters a valid drop target."
    },
    {
        name: "ondragleave",
        description: "A dragged element or text selection leaves a valid drop target."
    },
    {
        name: "ondragover",
        description: "An element or text selection is being dragged over a valid drop target (every 350ms)."
    },
    {
        name: "ondragstart",
        description: "The user starts dragging an element or text selection."
    },
    {
        name: "ondrop",
        description: "An element is dropped on a valid drop target."
    },
    {
        name: "ondurationchange",
        description: "The duration attribute has been updated."
    },
    {
        name: "onemptied",
        description: "The media has become empty; for example, this event is sent if the media has already been loaded (or partially loaded), and the load() method is called to reload it."
    },
    {
        name: "onend",
        description: "The speech recognition service has disconnected."
    },
    {
        name: "onend",
        description: "The utterance has finished being spoken."
    },
    {
        name: "onended",
        description: "Playback has stopped because the end of the media was reached."
    },
    {
        name: "onended",
        description: "Playback has stopped because the end of the media was reached."
    },
    {
        name: "onendEvent",
        description: "A SMIL animation element ends."
    },
    {
        name: "onerror",
        description: "A resource failed to load."
    },
    {
        name: "onerror",
        description: "Progression has failed."
    },
    {
        name: "onerror",
        description: "An error occurred while downloading the cache manifest or updating the content of the application."
    },
    {
        name: "onerror",
        description: "A WebSocket connection has been closed with prejudice (some data couldn't be sent for example)."
    },
    {
        name: "onerror",
        description: "An event source connection has been failed."
    },
    {
        name: "onerror",
        description: "A request caused an error and failed."
    },
    {
        name: "onerror",
        description: "A speech recognition error occurs."
    },
    {
        name: "onerror",
        description: "An error occurs that prevents the utterance from being successfully spoken."
    },
    {
        name: "onfocus",
        description: "An element has received focus (does not bubble)."
    },
    {
        name: "onfocusin",
        description: "An element is about to receive focus (bubbles)."
    },
    {
        name: "onfocusout",
        description: "An element is about to lose focus (bubbles)."
    },
    {
        name: "onfullscreenchange",
        description: "An element was turned to fullscreen mode or back to normal mode."
    },
    {
        name: "onfullscreenerror",
        description: "It was impossible to switch to fullscreen mode for technical reasons or because the permission was denied."
    },
    {
        name: "ongamepadconnected",
        description: "A gamepad has been connected."
    },
    {
        name: "ongamepaddisconnected",
        description: "A gamepad has been disconnected."
    },
    {
        name: "ongotpointercapture",
        description: "Element receives pointer capture."
    },
    {
        name: "onhashchange",
        description: "The fragment identifier of the URL has changed (the part of the URL after the #)."
    },
    {
        name: "onlostpointercapture",
        description: "Element lost pointer capture."
    },
    {
        name: "oninput",
        description: "The value of an element changes or the content of an element with the attribute contenteditable is modified."
    },
    {
        name: "oninvalid",
        description: "A submittable element has been checked and doesn't satisfy its constraints."
    },
    {
        name: "onkeydown",
        description: "A key is pressed down."
    },
    {
        name: "onkeypress",
        description: "A key is pressed down and that key normally produces a character value (use input instead)."
    },
    {
        name: "onkeyup",
        description: "A key is released."
    },
    {
        name: "onlanguagechange",
        description: "The user's preferred languages have changed."
    },
    {
        name: "onlevelchange",
        description: "The level attribute has been updated."
    },
    {
        name: "onload",
        description: "A resource and its dependent resources have finished loading."
    },
    {
        name: "onload",
        description: "Progression has been successful."
    },
    {
        name: "onloadeddata",
        description: "The first frame of the media has finished loading."
    },
    {
        name: "onloadedmetadata",
        description: "The metadata has been loaded."
    },
    {
        name: "onloadend",
        description: 'Progress has stopped (after "error", "abort" or "load" have been dispatched).'
    },
    {
        name: "onloadstart",
        description: "Progress has begun."
    },
    {
        name: "onmark",
        description: 'The spoken utterance reaches a named SSML "mark" tag.'
    },
    {
        name: "onmessage",
        description: "A message is received through a WebSocket."
    },
    {
        name: "onmessage",
        description: "A message is received from a Web Worker."
    },
    {
        name: "onmessage",
        description: "A message is received from a child (i)frame or a parent window."
    },
    {
        name: "onmessage",
        description: "A message is received through an event source."
    },
    {
        name: "onmessageerror",
        description: "A message error is raised when a message is received by an object."
    },
    {
        name: "onmessage",
        description: "A message is received from a service worker, or a message is received in a service worker from another context."
    },
    {
        name: "onmousedown",
        description: "A pointing device button (usually a mouse) is pressed on an element."
    },
    {
        name: "onmouseenter",
        description: "A pointing device is moved onto the element that has the listener attached."
    },
    {
        name: "onmouseleave",
        description: "A pointing device is moved off the element that has the listener attached."
    },
    {
        name: "onmousemove",
        description: "A pointing device is moved over an element."
    },
    {
        name: "onmouseout",
        description: "A pointing device is moved off the element that has the listener attached or off one of its children."
    },
    {
        name: "onmouseover",
        description: "A pointing device is moved onto the element that has the listener attached or onto one of its children."
    },
    {
        name: "onmouseup",
        description: "A pointing device button is released over an element."
    },
    {
        name: "onnomatch",
        description: "The speech recognition service returns a final result with no significant recognition."
    },
    {
        name: "onnotificationclick",
        description: "A system notification spawned by ServiceWorkerRegistration.showNotification() has been clicked."
    },
    {
        name: "onnoupdate",
        description: "The manifest hadn't changed."
    },
    {
        name: "onobsolete",
        description: "The manifest was found to have become a 404 or 410 page, so the application cache is being deleted."
    },
    {
        name: "onoffline",
        description: "The browser has lost access to the network."
    },
    {
        name: "ononline",
        description: "The browser has gained access to the network (but particular websites might be unreachable)."
    },
    {
        name: "onopen",
        description: "A WebSocket connection has been established."
    },
    {
        name: "onopen",
        description: "An event source connection has been established."
    },
    {
        name: "onorientationchange",
        description: "The orientation of the device (portrait/landscape) has changed"
    },
    {
        name: "onpagehide",
        description: "A session history entry is being traversed from."
    },
    {
        name: "onpageshow",
        description: "A session history entry is being traversed to."
    },
    {
        name: "onpaste",
        description: "Data has been transferred from the system clipboard to the document."
    },
    {
        name: "onpause",
        description: "Playback has been paused."
    },
    {
        name: "onpause",
        description: "The utterance is paused part way through."
    },
    {
        name: "onpointercancel",
        description: "The pointer is unlikely to produce any more events."
    },
    {
        name: "onpointerdown",
        description: "The pointer enters the active buttons state."
    },
    {
        name: "onpointerenter",
        description: "Pointing device is moved inside the hit-testing boundary."
    },
    {
        name: "onpointerleave",
        description: "Pointing device is moved out of the hit-testing boundary."
    },
    {
        name: "onpointerlockchange",
        description: "The pointer was locked or released."
    },
    {
        name: "onpointerlockerror",
        description: "It was impossible to lock the pointer for technical reasons or because the permission was denied."
    },
    {
        name: "onpointermove",
        description: "The pointer changed coordinates."
    },
    {
        name: "onpointerout",
        description: "The pointing device moved out of hit-testing boundary or leaves detectable hover range."
    },
    {
        name: "onpointerover",
        description: "The pointing device is moved into the hit-testing boundary."
    },
    {
        name: "onpointerup",
        description: "The pointer leaves the active buttons state."
    },
    {
        name: "onplay",
        description: "Playback has begun."
    },
    {
        name: "onplaying",
        description: "Playback is ready to start after having been paused or delayed due to lack of data."
    },
    {
        name: "onpopstate",
        description: "A session history entry is being navigated to (in certain cases)."
    },
    {
        name: "onprogress",
        description: "In progress."
    },
    {
        name: "onprogress",
        description: "The user agent is downloading resources listed by the manifest."
    },
    {
        name: "onpush",
        description: "A Service Worker has received a push message."
    },
    {
        name: "onpushsubscriptionchange",
        description: "A PushSubscription has expired."
    },
    {
        name: "onratechange",
        description: "The playback rate has changed."
    },
    {
        name: "onreadystatechange",
        description: "The readyState attribute of a document has changed."
    },
    {
        name: "onrepeatEvent",
        description: "A SMIL animation element is repeated."
    },
    {
        name: "onreset",
        description: "A form is reset."
    },
    {
        name: "onresize",
        description: "The document view has been resized."
    },
    {
        name: "onresourcetimingbufferfull",
        description: "The browser's resource timing buffer is full."
    },
    {
        name: "onresult",
        description: "The speech recognition service returns a result  a word or phrase has been positively recognized and this has been communicated back to the app."
    },
    {
        name: "onresume",
        description: "A paused utterance is resumed."
    },
    {
        name: "onscroll",
        description: "The document view or an element has been scrolled."
    },
    {
        name: "onseeked",
        description: "A seek operation completed."
    },
    {
        name: "onseeking",
        description: "A seek operation began."
    },
    {
        name: "onselect",
        description: "Some text is being selected."
    },
    {
        name: "onselectstart",
        description: "A selection just started."
    },
    {
        name: "onselectionchange",
        description: "The selection in the document has been changed."
    },
    {
        name: "onshow",
        description: "A contextmenu event was fired on/bubbled to an element that has a contextmenu attribute"
    },
    {
        name: "onslotchange",
        description: "The node contents of a HTMLSlotElement (<slot>) have changed."
    },
    {
        name: "onsoundend",
        description: "Any sound  recognisable speech or not  has stopped being detected."
    },
    {
        name: "onsoundstart",
        description: "Any sound  recognisable speech or not  has been detected."
    },
    {
        name: "onspeechend",
        description: "Speech recognised by the speech recognition service has stopped being detected."
    },
    {
        name: "onspeechstart",
        description: "Sound that is recognised by the speech recognition service as speech has been detected."
    },
    {
        name: "onstalled",
        description: "The user agent is trying to fetch media data, but data is unexpectedly not forthcoming."
    },
    {
        name: "onstart",
        description: "The speech recognition service has begun listening to incoming audio with intent to recognize grammars associated with the current SpeechRecognition."
    },
    {
        name: "onstart",
        description: "The utterance has begun to be spoken."
    },
    {
        name: "onstorage",
        description: "A storage area (localStorage or sessionStorage) has changed."
    },
    {
        name: "onsubmit",
        description: "A form is submitted."
    },
    {
        name: "onsuccess",
        description: "A request successfully completed."
    },
    {
        name: "onsuspend",
        description: "Media data loading has been suspended."
    },
    {
        name: "onSVGAbort",
        description: "Page loading has been stopped before the SVG was loaded."
    },
    {
        name: "onSVGError",
        description: "An error has occurred before the SVG was loaded."
    },
    {
        name: "onSVGLoad",
        description: "An SVG document has been loaded and parsed."
    },
    {
        name: "onSVGResize",
        description: "An SVG document is being resized."
    },
    {
        name: "onSVGScroll",
        description: "An SVG document is being scrolled."
    },
    {
        name: "onSVGUnload",
        description: "An SVG document has been removed from a window or frame."
    },
    {
        name: "onSVGZoom",
        description: "An SVG document is being zoomed."
    },
    {
        name: "ontimeout",
        description: ""
    },
    {
        name: "ontimeupdate",
        description: "The time indicated by the currentTime attribute has been updated."
    },
    {
        name: "ontouchcancel",
        description: "A touch point has been disrupted in an implementation-specific manners (too many touch points for example)."
    },
    {
        name: "ontouchend",
        description: "A touch point is removed from the touch surface."
    },
    {
        name: "ontouchmove",
        description: "A touch point is moved along the touch surface."
    },
    {
        name: "ontouchstart",
        description: "A touch point is placed on the touch surface."
    },
    {
        name: "ontransitionend",
        description: "A CSS transition has completed."
    },
    {
        name: "onunload",
        description: "The document or a dependent resource is being unloaded."
    },
    {
        name: "onupdateready",
        description: "The resources listed in the manifest have been newly redownloaded, and the script can use swapCache() to switch to the new cache."
    },
    {
        name: "onupgradeneeded",
        description: "An attempt was made to open a database with a version number higher than its current version. A versionchange transaction has been created."
    },
    {
        name: "onuserproximity",
        description: "Fresh data is available from a proximity sensor (indicates whether the nearby object is near the device or not)."
    },
    {
        name: "onvoiceschanged",
        description: "The list of SpeechSynthesisVoice objects that would be returned by the SpeechSynthesis.getVoices() method has changed (when the voiceschanged event fires.)"
    },
    {
        name: "onversionchange",
        description: "A versionchange transaction completed."
    },
    {
        name: "onvisibilitychange",
        description: "The content of a tab has become visible or has been hidden."
    },
    {
        name: "onvolumechange",
        description: "The volume has changed."
    },
    {
        name: "onwaiting",
        description: "Playback has stopped because of a temporary lack of data."
    },
    {
        name: "onwheel",
        description: "A wheel button of a pointing device is rotated in any direction."
    },
    { name: "onforminput" },
    { name: "onformchange" },
    { name: "onmousewheel" }
];

function getBuiltInHtmlCollection() {
    var e_1, _a;
    // Combine data with extra html5 events because vscode-html-language-service hasn't included all events yet.
    var ALL_HTML5_EVENTS = __spread(html5Events.HTML5_EVENTS, EXTRA_HTML5_EVENTS.filter(function (evt) { return html5Events.HTML5_EVENTS.find(function (existingEvt) { return existingEvt.name === evt.name; }) == null; }));
    // It seems like the autocompletion value map for <select>, <textarea> and <input> needs "on" and "off" values
    var EXTENDED_HTML5_VALUE_MAP = html5.HTML5_VALUE_MAP.map(function (VALUE_MAP) {
        switch (VALUE_MAP.name) {
            case "inputautocomplete":
                return __assign({}, VALUE_MAP, { values: __spread([{ name: "on" }, { name: "off" }], VALUE_MAP.values) });
            default:
                return VALUE_MAP;
        }
    });
    var result = parseHtmlData({
        version: 1,
        tags: html5Tags.HTML5_TAGS,
        globalAttributes: __spread(html5.HTML5_GLOBAL_ATTRIBUTES, ALL_HTML5_EVENTS, html5Aria.ARIA_ATTRIBUTES),
        valueSets: EXTENDED_HTML5_VALUE_MAP
    });
    result.tags.push({
        attributes: [],
        properties: [],
        events: [],
        slots: [],
        tagName: "svg",
        description: ""
    });
    result.tags.push({
        properties: [],
        events: [
            {
                name: "slotchange",
                description: "The slotchange event is fired on an HTMLSlotElement instance (<slot> element) when the node(s) contained in that slot change.\n\nNote: the slotchange event doesn't fire if the children of a slotted node change  only if you change (e.g. add or delete) the actual nodes themselves.",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.ANY }); }),
                fromTagName: "slot",
                builtIn: true
            }
        ],
        slots: [],
        attributes: [
            {
                kind: "attribute",
                name: "name",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
                fromTagName: "slot",
                builtIn: true
            },
            {
                kind: "attribute",
                name: "onslotchange",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
                fromTagName: "slot",
                builtIn: true
            }
        ],
        tagName: "slot",
        description: ""
    });
    result.attrs.push({
        kind: "attribute",
        name: "slot",
        getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
        builtIn: true
    });
    result.attrs.push({
        kind: "attribute",
        name: "part",
        description: "This attribute specifies a \"styleable\" part on the element in your shadow tree.",
        getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
        builtIn: true
    });
    result.attrs.push({
        kind: "attribute",
        name: "theme",
        description: "This attribute specifies a global \"styleable\" part on the element.",
        getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
        builtIn: true
    });
    result.attrs.push({
        kind: "attribute",
        name: "exportparts",
        description: "This attribute is used to explicitly forward a child\u2019s part to be styleable outside of the parent\u2019s shadow tree.\n\nThe value must be a comma-separated list of part mappings:\n  - \"some-box, some-input\"\n  - \"some-input: foo-input\"\n",
        getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
        builtIn: true
    });
    var textareaElement = result.tags.find(function (t) { return t.tagName === "textarea"; });
    if (textareaElement != null) {
        textareaElement.properties.push({
            kind: "property",
            name: "value",
            builtIn: true,
            fromTagName: "textarea",
            getType: lazy(function () {
                return ({
                    kind: tsSimpleType.SimpleTypeKind.UNION,
                    types: [{ kind: tsSimpleType.SimpleTypeKind.STRING }, { kind: tsSimpleType.SimpleTypeKind.NULL }]
                });
            })
        });
    }
    var imageElement = result.tags.find(function (t) { return t.tagName === "img"; });
    if (imageElement != null) {
        imageElement.attributes.push({
            kind: "attribute",
            name: "loading",
            builtIn: true,
            fromTagName: "img",
            getType: lazy(function () {
                return ({
                    kind: tsSimpleType.SimpleTypeKind.UNION,
                    types: [
                        {
                            kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                            value: "lazy"
                        },
                        {
                            kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                            value: "auto"
                        },
                        { kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL, value: "eager" }
                    ]
                });
            })
        });
    }
    var inputElement = result.tags.find(function (t) { return t.tagName === "input"; });
    if (inputElement != null) {
        inputElement.properties.push({
            kind: "property",
            name: "value",
            builtIn: true,
            fromTagName: "input",
            getType: lazy(function () {
                return ({
                    kind: tsSimpleType.SimpleTypeKind.UNION,
                    types: [{ kind: tsSimpleType.SimpleTypeKind.STRING }, { kind: tsSimpleType.SimpleTypeKind.NULL }]
                });
            })
        });
    }
    var audioElement = result.tags.find(function (t) { return t.tagName === "audio"; });
    if (audioElement != null) {
        audioElement.attributes = __spread(audioElement.attributes, [
            {
                kind: "attribute",
                fromTagName: "audio",
                builtIn: true,
                name: "controlslist",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); })
            }
        ]);
    }
    var videoElement = result.tags.find(function (t) { return t.tagName === "video"; });
    if (videoElement != null) {
        videoElement.attributes = __spread(videoElement.attributes, [
            {
                kind: "attribute",
                fromTagName: "video",
                builtIn: true,
                name: "controlslist",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); })
            },
            {
                kind: "attribute",
                fromTagName: "video",
                builtIn: true,
                name: "playsinline",
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.BOOLEAN }); }),
                description: 'The playsinline attribute is a boolean attribute. If present, it serves as a hint to the user agent that the video ought to be displayed "inline" in the document by default, constrained to the element\'s playback area, instead of being displayed fullscreen or in an independent resizable window.'
            }
        ]);
    }
    try {
        for (var ALL_HTML5_EVENTS_1 = __values(ALL_HTML5_EVENTS), ALL_HTML5_EVENTS_1_1 = ALL_HTML5_EVENTS_1.next(); !ALL_HTML5_EVENTS_1_1.done; ALL_HTML5_EVENTS_1_1 = ALL_HTML5_EVENTS_1.next()) {
            var globalEvent = ALL_HTML5_EVENTS_1_1.value;
            result.events.push({
                name: globalEvent.name.replace(/^on/, ""),
                description: globalEvent.description,
                getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.ANY }); }),
                builtIn: true
            });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ALL_HTML5_EVENTS_1_1 && !ALL_HTML5_EVENTS_1_1.done && (_a = ALL_HTML5_EVENTS_1.return)) _a.call(ALL_HTML5_EVENTS_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return __assign({}, result, { tags: result.tags.map(function (tag) { return (__assign({}, tag, { builtIn: true, attributes: addMissingAttrTypes(tag.attributes.map(function (attr) { return (__assign({}, attr, { builtIn: true })); })) })); }), attrs: addMissingAttrTypes(result.attrs.map(function (attr) { return (__assign({}, attr, { builtIn: true })); })), events: result.events.map(function (event) { return (__assign({}, event, { builtIn: true })); }) });
}
function addMissingAttrTypes(attrs) {
    return attrs.map(function (attr) {
        if (hasTypeForAttrName(attr.name) || attr.getType().kind === tsSimpleType.SimpleTypeKind.ANY) {
            var newType_1 = html5TagAttrType(attr.name);
            return __assign({}, attr, { getType: lazy(function () { return newType_1; }) });
        }
        return attr;
    });
}

function getUserConfigHtmlCollection(config) {
    var collection = (function () {
        var e_1, _a;
        var collection = { tags: [], events: [], attrs: [] };
        try {
            for (var _b = __values(Array.isArray(config.customHtmlData) ? config.customHtmlData : [config.customHtmlData]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var customHtmlData = _c.value;
                try {
                    var data = typeof customHtmlData === "string" && fs.existsSync(customHtmlData)
                        ? JSON.parse(fs.readFileSync(customHtmlData, "utf8").toString())
                        : customHtmlData;
                    var parsedCollection = parseHtmlData(data);
                    collection = {
                        tags: mergeHtmlTags(__spread(collection.tags, parsedCollection.tags)),
                        attrs: mergeHtmlAttrs(__spread(collection.attrs, parsedCollection.attrs)),
                        events: mergeHtmlEvents(__spread(collection.events, parsedCollection.events))
                    };
                }
                catch (e) {
                    //logger.error("Error parsing user configuration 'customHtmlData'", e, customHtmlData);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return collection;
    })();
    var tags = config.globalTags.map(function (tagName) {
        return ({
            tagName: tagName,
            properties: [],
            attributes: [],
            events: [],
            slots: []
        });
    });
    var attrs = config.globalAttributes.map(function (attrName) {
        return ({
            name: attrName,
            kind: "attribute",
            getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.ANY }); })
        });
    });
    var events = config.globalEvents.map(function (eventName) {
        return ({
            name: eventName,
            kind: "event",
            getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.ANY }); })
        });
    });
    return {
        tags: __spread(tags, collection.tags),
        attrs: __spread(attrs, collection.attrs),
        events: __spread(events, collection.events)
    };
}

function removeUndefinedFromType(type) {
    switch (type.kind) {
        case tsSimpleType.SimpleTypeKind.ALIAS:
            return __assign({}, type, { target: removeUndefinedFromType(type.target) });
        case tsSimpleType.SimpleTypeKind.UNION:
            return __assign({}, type, { types: type.types.filter(function (t) { return !tsSimpleType.isAssignableToSimpleTypeKind(t, tsSimpleType.SimpleTypeKind.UNDEFINED); }) });
    }
    return type;
}

/**
 * Checks whether a type is a lit directive.
 * It will return true if the type is a function that takes a Part type and returns a void.
 * @param type
 */
function isLitDirective(type) {
    switch (type.kind) {
        case tsSimpleType.SimpleTypeKind.ALIAS:
            return type.name === "DirectiveFn" || isLitDirective(type.target);
        case tsSimpleType.SimpleTypeKind.FUNCTION:
            return (type.kind === tsSimpleType.SimpleTypeKind.FUNCTION &&
                type.argTypes != null &&
                type.argTypes.length > 0 &&
                ["Part", "NodePart", "AttributePart", "PropertyPart"].includes(type.argTypes[0].type.name || "") &&
                type.returnType != null &&
                type.returnType.kind === tsSimpleType.SimpleTypeKind.VOID);
        case tsSimpleType.SimpleTypeKind.GENERIC_ARGUMENTS:
            // Test for the built in type from lit-html: Directive<NodePart>
            return type.target.kind === tsSimpleType.SimpleTypeKind.FUNCTION && type.target.name === "Directive";
        default:
            return false;
    }
}

function getDirective(assignment, request) {
    var ts = request.ts, program = request.program;
    var checker = program.getTypeChecker();
    if (assignment.kind !== HtmlNodeAttrAssignmentKind.EXPRESSION)
        return;
    // Type check lit-html directives
    if (ts.isCallExpression(assignment.expression)) {
        var functionName = assignment.expression.expression.getText();
        var args_1 = Array.from(assignment.expression.arguments);
        switch (functionName) {
            case "ifDefined": {
                // Example: html`<img src="${ifDefined(imageUrl)}">`;
                // Take the argument to ifDefined and remove undefined from the type union (if possible).
                // This new type becomes the actual type of the expression
                var actualType = (function () {
                    if (args_1.length === 1) {
                        var returnType = tsSimpleType.toSimpleType(checker.getTypeAtLocation(args_1[0]), checker);
                        return removeUndefinedFromType(returnType);
                    }
                    return undefined;
                })();
                return {
                    kind: "ifDefined",
                    actualType: actualType,
                    args: args_1
                };
            }
            case "guard": {
                // Example: html`<img src="${guard([imageUrl], () => Math.random() > 0.5 ? imageUrl : "nothing.png")}>`;
                // The return type of the function becomes the actual type of the expression
                var actualType = (function () {
                    if (args_1.length === 2) {
                        var returnFunctionType = tsSimpleType.toSimpleType(checker.getTypeAtLocation(args_1[1]), checker);
                        if (returnFunctionType.kind === tsSimpleType.SimpleTypeKind.FUNCTION) {
                            return returnFunctionType.returnType;
                        }
                    }
                    return undefined;
                })();
                return {
                    kind: "guard",
                    actualType: actualType,
                    args: args_1
                };
            }
            case "classMap":
            case "styleMap":
                return {
                    kind: functionName,
                    actualType: { kind: tsSimpleType.SimpleTypeKind.STRING },
                    args: args_1
                };
            case "unsafeHTML":
            case "cache":
            case "repeat":
            case "asyncReplace":
            case "asyncAppend":
                return {
                    kind: functionName,
                    args: args_1
                };
            default:
                // Grab the type of the expression and get a SimpleType
                if (assignment.kind === HtmlNodeAttrAssignmentKind.EXPRESSION) {
                    var typeB = tsSimpleType.toSimpleType(checker.getTypeAtLocation(assignment.expression), checker);
                    if (isLitDirective(typeB)) {
                        // Now we have an unknown (user defined) directive.
                        return {
                            kind: {
                                name: functionName
                            },
                            args: args_1
                        };
                    }
                }
        }
    }
    return;
}

var cache = new WeakMap();
function extractBindingTypes(assignment, request) {
    if (cache.has(assignment)) {
        return cache.get(assignment);
    }
    var checker = request.program.getTypeChecker();
    // Infer the type of the RHS
    //const typeBInferred = shouldRelaxTypeB ? ({ kind: SimpleTypeKind.ANY } as SimpleType) : inferTypeFromAssignment(assignment, checker);
    var typeBInferred = inferTypeFromAssignment(assignment, checker);
    // Convert typeB to SimpleType
    var typeB = (function () {
        var type = tsSimpleType.isSimpleType(typeBInferred) ? typeBInferred : tsSimpleType.toSimpleType(typeBInferred, checker);
        return  type;
    })();
    // Find a corresponding target for this attribute
    var htmlAttrTarget = request.htmlStore.getHtmlAttrTarget(assignment.htmlAttr);
    //if (htmlAttrTarget == null) return [];
    var typeA = htmlAttrTarget == null ? { kind: tsSimpleType.SimpleTypeKind.ANY } : htmlAttrTarget.getType();
    // Handle directives
    var directive = getDirective(assignment, request);
    if (directive != null && directive.actualType != null) {
        typeB = directive.actualType;
    }
    // Cache the result
    var result = { typeA: typeA, typeB: typeB };
    cache.set(assignment, result);
    return result;
}
function inferTypeFromAssignment(assignment, checker) {
    switch (assignment.kind) {
        case HtmlNodeAttrAssignmentKind.STRING:
            return { kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL, value: assignment.value };
        case HtmlNodeAttrAssignmentKind.BOOLEAN:
            return { kind: tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL, value: true };
        case HtmlNodeAttrAssignmentKind.EXPRESSION:
            return checker.getTypeAtLocation(assignment.expression);
        case HtmlNodeAttrAssignmentKind.MIXED:
            // Event bindings always looks at the first expression
            // Therefore, return the type of the first expression
            if (assignment.htmlAttr.kind === HtmlNodeAttrKind.EVENT_LISTENER) {
                var expression = assignment.values.find(function (val) { return typeof val !== "string"; });
                if (expression != null) {
                    return checker.getTypeAtLocation(expression);
                }
            }
            return { kind: tsSimpleType.SimpleTypeKind.STRING };
    }
}

function isAssignableToType(_a, request, options) {
    var typeA = _a.typeA, typeB = _a.typeB;
    var inJsFile = request.file.fileName.endsWith(".js");
    return tsSimpleType.isAssignableToType(typeA, typeB, request.program, __assign({}, (inJsFile ? { strict: false } : {}), (options || {})));
}

/**
 * This rule validates that you are not binding a boolean type in an attribute binding
 * This would result in binding the string 'true' or 'false' and a '?' binding should be used instead.
 */
var rule = {
    name: "no-boolean-in-attribute-binding",
    visitHtmlAssignment: function (assignment, request) {
        // Don't validate boolean attribute bindings.
        if (assignment.kind === HtmlNodeAttrAssignmentKind.BOOLEAN)
            return;
        // Only validate attribute bindings.
        var htmlAttr = assignment.htmlAttr;
        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE)
            return;
        var _a = extractBindingTypes(assignment, request), typeA = _a.typeA, typeB = _a.typeB;
        // Return early if the attribute is like 'required=""' because this is assignable to boolean.
        if (typeB.kind === tsSimpleType.SimpleTypeKind.STRING_LITERAL && typeB.value.length === 0) {
            return;
        }
        // Check that typeB is not of any|unknown type and typeB is assignable to boolean.
        // Report a diagnostic if typeB is assignable to boolean type because this would result in binding the boolean coerced to string.
        if (!tsSimpleType.isAssignableToSimpleTypeKind(typeB, [tsSimpleType.SimpleTypeKind.ANY, tsSimpleType.SimpleTypeKind.UNKNOWN], { op: "or" }) &&
            isAssignableToType({ typeA: { kind: tsSimpleType.SimpleTypeKind.BOOLEAN }, typeB: typeB }, request)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING,
                    severity: litDiagnosticRuleSeverity(request.config, "no-boolean-in-attribute-binding"),
                    source: "no-boolean-in-attribute-binding",
                    message: "The type '" + tsSimpleType.toTypeString(typeB) + "' is a boolean type but you are not using a boolean binding.",
                    fix: "Change to boolean binding?",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        // Check that typeA is not of any|unknown type and typeA is assignable to boolean.
        // Report a diagnostic if typeA is assignable to boolean type because then
        //   we should probably be using a boolean binding instead of an attribute binding.
        if (!tsSimpleType.isAssignableToSimpleTypeKind(typeA, [tsSimpleType.SimpleTypeKind.ANY, tsSimpleType.SimpleTypeKind.UNKNOWN], { op: "or" }) &&
            isAssignableToType({
                typeA: { kind: tsSimpleType.SimpleTypeKind.BOOLEAN },
                typeB: typeA
            }, request)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.EXPRESSION_ONLY_ASSIGNABLE_WITH_BOOLEAN_BINDING,
                    severity: litDiagnosticRuleSeverity(request.config, "no-boolean-in-attribute-binding"),
                    source: "no-boolean-in-attribute-binding",
                    message: "The '" + htmlAttr.name + "' attribute is of boolean type but you are not using a boolean binding.",
                    fix: "Change to boolean binding?",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        return;
    }
};

/**
 * This rule validates that complex types are not used within an expression in an attribute binding.
 */
var rule$1 = {
    name: "no-complex-attribute-binding",
    visitHtmlAssignment: function (assignment, request) {
        // Only validate attribute bindings, because you are able to assign complex types in property bindings.
        var htmlAttr = assignment.htmlAttr;
        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE)
            return;
        var _a = extractBindingTypes(assignment, request), typeA = _a.typeA, typeB = _a.typeB;
        // Don't validate directives in this rule, because they are assignable even though they are complex types (functions).
        if (isLitDirective(typeB))
            return;
        // Only primitive types should be allowed as "typeB"
        if (!tsSimpleType.isAssignableToPrimitiveType(typeB)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.COMPLEX_NOT_BINDABLE_IN_ATTRIBUTE_BINDING,
                    severity: litDiagnosticRuleSeverity(request.config, "no-complex-attribute-binding"),
                    source: "no-complex-attribute-binding",
                    message: "You are binding a non-primitive type '" + tsSimpleType.toTypeString(typeB) + "'. This could result in binding the string \"[object Object]\".",
                    fix: "Use '.' binding instead?",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        // Only primitive types should be allowed as "typeA"
        if (!tsSimpleType.isAssignableToPrimitiveType(typeA)) {
            var message = "You are assigning the primitive '" + tsSimpleType.toTypeString(typeB) + "' to a non-primitive type '" + tsSimpleType.toTypeString(typeA) + "'.";
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.PRIMITIVE_NOT_ASSIGNABLE_TO_COMPLEX,
                    severity: litDiagnosticRuleSeverity(request.config, "no-complex-attribute-binding"),
                    source: "no-complex-attribute-binding",
                    message: message,
                    fix: "Use '.' binding instead?",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        return;
    }
};

/**
 * This rule validates that non-attribute bindings are always used with an expression.
 */
var rule$2 = {
    name: "no-expressionless-property-binding",
    visitHtmlAssignment: function (assignment, request) {
        var htmlAttr = assignment.htmlAttr;
        // Only make this check non-expression type assignments.
        switch (assignment.kind) {
            case HtmlNodeAttrAssignmentKind.STRING:
            case HtmlNodeAttrAssignmentKind.BOOLEAN:
                switch (htmlAttr.kind) {
                    case HtmlNodeAttrKind.EVENT_LISTENER:
                        return [
                            {
                                kind: exports.LitHtmlDiagnosticKind.PROPERTY_NEEDS_EXPRESSION,
                                message: "You are using an event listener binding without an expression",
                                severity: litDiagnosticRuleSeverity(request.config, "no-expressionless-property-binding"),
                                source: "no-expressionless-property-binding",
                                location: __assign({ document: request.document }, htmlAttr.location.name)
                            }
                        ];
                    case HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE:
                        return [
                            {
                                kind: exports.LitHtmlDiagnosticKind.PROPERTY_NEEDS_EXPRESSION,
                                message: "You are using a boolean attribute binding without an expression",
                                severity: litDiagnosticRuleSeverity(request.config, "no-expressionless-property-binding"),
                                source: "no-expressionless-property-binding",
                                location: __assign({ document: request.document }, htmlAttr.location.name)
                            }
                        ];
                    case HtmlNodeAttrKind.PROPERTY:
                        return [
                            {
                                kind: exports.LitHtmlDiagnosticKind.PROPERTY_NEEDS_EXPRESSION,
                                message: "You are using a property binding without an expression",
                                severity: litDiagnosticRuleSeverity(request.config, "no-expressionless-property-binding"),
                                source: "no-expressionless-property-binding",
                                location: __assign({ document: request.document }, htmlAttr.location.name)
                            }
                        ];
                }
        }
        return;
    }
};

function isAssignableInAttributeBinding(htmlAttr, _a, request) {
    var typeA = _a.typeA, typeB = _a.typeB;
    var assignment = htmlAttr.assignment;
    if (assignment == null)
        return undefined;
    if (assignment.kind === HtmlNodeAttrAssignmentKind.BOOLEAN) {
        if (!isAssignableToType({ typeA: typeA, typeB: typeB }, request)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE,
                    message: "Type '" + tsSimpleType.toTypeString(typeB) + "' is not assignable to '" + tsSimpleType.toTypeString(typeA) + "'",
                    severity: litDiagnosticRuleSeverity(request.config, "no-incompatible-type-binding"),
                    source: "no-incompatible-type-binding",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
    }
    else {
        if (!isAssignableToType({ typeA: typeA, typeB: typeB }, request, { isAssignable: isAssignableToTypeWithStringCoercion })) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE,
                    message: "Type '" + tsSimpleType.toTypeString(typeB) + "' is not assignable to '" + tsSimpleType.toTypeString(typeA) + "'",
                    severity: litDiagnosticRuleSeverity(request.config, "no-incompatible-type-binding"),
                    source: "no-incompatible-type-binding",
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
    }
    return undefined;
}
/**
 * Assignability check that simulates string coercion
 * This is used to type check attribute bindings
 * @param typeA
 * @param typeB
 * @param options
 */
function isAssignableToTypeWithStringCoercion(typeA, typeB, options) {
    var safeOptions = __assign({}, options, { isAssignable: undefined });
    switch (typeB.kind) {
        /*case SimpleTypeKind.NULL:
         return _isAssignableToType(typeA, { kind: SimpleTypeKind.STRING_LITERAL, value: "null" }, safeOptions);

         case SimpleTypeKind.UNDEFINED:
         return _isAssignableToType(typeA, { kind: SimpleTypeKind.STRING_LITERAL, value: "undefined" }, safeOptions);
         */
        case tsSimpleType.SimpleTypeKind.ALIAS:
        case tsSimpleType.SimpleTypeKind.FUNCTION:
        case tsSimpleType.SimpleTypeKind.GENERIC_ARGUMENTS:
            // Always return true if this is a lit directive
            if (isLitDirective(typeB)) {
                return true;
            }
            break;
        case tsSimpleType.SimpleTypeKind.OBJECT:
        case tsSimpleType.SimpleTypeKind.CLASS:
        case tsSimpleType.SimpleTypeKind.INTERFACE:
            // This allows for types like: string | (part: Part) => void
            return tsSimpleType.isAssignableToType(typeA, {
                kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                value: "[object Object]"
            }, safeOptions);
        case tsSimpleType.SimpleTypeKind.STRING_LITERAL:
            // Take into account that the empty string is is equal to true
            if (typeB.value.length === 0) {
                if (tsSimpleType.isAssignableToType(typeA, { kind: tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL, value: true }, safeOptions)) {
                    return true;
                }
            }
            // Test if a potential string literal is a assignable to a number
            // Example: max="123"
            if (!isNaN(typeB.value)) {
                if (tsSimpleType.isAssignableToType(typeA, {
                    kind: tsSimpleType.SimpleTypeKind.NUMBER_LITERAL,
                    value: Number(typeB.value)
                }, safeOptions)) {
                    return true;
                }
            }
            break;
        case tsSimpleType.SimpleTypeKind.BOOLEAN:
            // Test if a boolean coerced string is possible.
            // Example: aria-expanded="${this.open}"
            return tsSimpleType.isAssignableToType(typeA, {
                kind: tsSimpleType.SimpleTypeKind.UNION,
                types: [
                    {
                        kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                        value: "true"
                    },
                    { kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL, value: "false" }
                ]
            }, safeOptions);
        case tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL:
            /**
             * Test if a boolean literal coerced to string is possible
             * Example: aria-expanded="${this.open}"
             */
            return tsSimpleType.isAssignableToType(typeA, {
                kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                value: String(typeB.value)
            }, safeOptions);
        case tsSimpleType.SimpleTypeKind.NUMBER:
            // Test if a number coerced to string is possible
            // Example: value="${this.max}"
            if (tsSimpleType.isAssignableToType(typeA, { kind: tsSimpleType.SimpleTypeKind.STRING }, safeOptions)) {
                return true;
            }
            break;
        case tsSimpleType.SimpleTypeKind.NUMBER_LITERAL:
            // Test if a number literal coerced to string is possible
            // Example: value="${this.max}"
            if (tsSimpleType.isAssignableToType(typeA, {
                kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                value: String(typeB.value)
            }, safeOptions)) {
                return true;
            }
            break;
    }
    return undefined;
}

function isAssignableInBooleanBinding(htmlAttr, _a, request) {
    var typeA = _a.typeA, typeB = _a.typeB;
    // Test if the user is trying to use ? modifier on a non-boolean type.
    if (!isAssignableToType({ typeA: { kind: tsSimpleType.SimpleTypeKind.BOOLEAN }, typeB: typeB }, request)) {
        return [
            {
                kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE,
                message: "Type '" + tsSimpleType.toTypeString(typeB) + "' is not assignable to 'boolean'",
                severity: litDiagnosticRuleSeverity(request.config, "no-incompatible-type-binding"),
                source: "no-incompatible-type-binding",
                location: __assign({ document: request.document }, htmlAttr.location.name),
                htmlAttr: htmlAttr,
                typeA: typeA,
                typeB: typeB
            }
        ];
    }
    // Test if the user is trying to use the ? modifier on a non-boolean type.
    if (!isAssignableToType({ typeA: typeA, typeB: { kind: tsSimpleType.SimpleTypeKind.BOOLEAN } }, request)) {
        return [
            {
                kind: exports.LitHtmlDiagnosticKind.BOOL_MOD_ON_NON_BOOL,
                message: "You are using a boolean binding on a non boolean type '" + tsSimpleType.toTypeString(typeA) + "'",
                severity: litDiagnosticRuleSeverity(request.config, "no-incompatible-type-binding"),
                source: "no-incompatible-type-binding",
                location: __assign({ document: request.document }, htmlAttr.location.name),
                htmlAttr: htmlAttr,
                typeA: { kind: tsSimpleType.SimpleTypeKind.BOOLEAN },
                typeB: typeB
            }
        ];
    }
    return undefined;
}

function isAssignableInPropertyBinding(htmlAttr, _a, request) {
    var typeA = _a.typeA, typeB = _a.typeB;
    if (!isAssignableToType({ typeA: typeA, typeB: typeB }, request)) {
        return [
            {
                kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE,
                message: "Type '" + tsSimpleType.toTypeString(typeB) + "' is not assignable to '" + tsSimpleType.toTypeString(typeA) + "'",
                severity: litDiagnosticRuleSeverity(request.config, "no-incompatible-type-binding"),
                source: "no-incompatible-type-binding",
                location: __assign({ document: request.document }, htmlAttr.location.name),
                htmlAttr: htmlAttr,
                typeA: typeA,
                typeB: typeB
            }
        ];
    }
    return undefined;
}

/**
 * This rule validate if the types of a binding are assignable.
 */
var rule$3 = {
    name: "no-incompatible-type-binding",
    visitHtmlAssignment: function (assignment, request) {
        var htmlAttr = assignment.htmlAttr;
        var _a = extractBindingTypes(assignment, request), typeA = _a.typeA, typeB = _a.typeB;
        // Validate types based on the binding in which they appear
        switch (htmlAttr.modifier) {
            case LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER:
                return isAssignableInBooleanBinding(htmlAttr, { typeA: typeA, typeB: typeB }, request);
            case LIT_HTML_PROP_ATTRIBUTE_MODIFIER:
                return isAssignableInPropertyBinding(htmlAttr, { typeA: typeA, typeB: typeB }, request);
            case LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER:
                break;
            default: {
                return isAssignableInAttributeBinding(htmlAttr, { typeA: typeA, typeB: typeB }, request);
            }
        }
        return;
    }
};

/**
 * This rule validates that directives are used properly.
 */
var rule$4 = {
    name: "no-invalid-directive-binding",
    visitHtmlAssignment: function (assignment, request) {
        var htmlAttr = assignment.htmlAttr;
        // Only validate expression because this is where directives can be used.
        if (assignment.kind !== HtmlNodeAttrAssignmentKind.EXPRESSION)
            return;
        // Check if the expression is a directive
        var directive = getDirective(assignment, request);
        if (directive == null)
            return;
        // Validate built-in directive kind
        var document = request.document;
        if (typeof directive.kind === "string") {
            switch (directive.kind) {
                case "ifDefined":
                    // Example: html`<img src="${ifDefined(imageUrl)}">`;
                    // Take the argument to ifDefined and remove undefined from the type union (if possible).
                    // Then test if this result is now assignable to the attribute type.
                    if (directive.args.length === 1) {
                        // "ifDefined" only has an effect on "attribute" bindings
                        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE) {
                            return [
                                {
                                    kind: exports.LitHtmlDiagnosticKind.DIRECTIVE_NOT_ALLOWED_HERE,
                                    source: "no-invalid-directive-binding",
                                    severity: litDiagnosticRuleSeverity(request.config, "no-invalid-directive-binding"),
                                    message: "The 'ifDefined' directive has no effect here.",
                                    location: __assign({ document: document }, htmlAttr.location.name)
                                }
                            ];
                        }
                    }
                    break;
                case "classMap":
                    // Report error if "classMap" is not being used on the "class" attribute.
                    if (htmlAttr.name !== "class" || htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE) {
                        return [
                            {
                                kind: exports.LitHtmlDiagnosticKind.DIRECTIVE_NOT_ALLOWED_HERE,
                                message: "The 'classMap' directive can only be used in an attribute binding for the 'class' attribute",
                                source: "no-invalid-directive-binding",
                                severity: litDiagnosticRuleSeverity(request.config, "no-invalid-directive-binding"),
                                location: __assign({ document: document }, htmlAttr.location.name)
                            }
                        ];
                    }
                    break;
                case "styleMap":
                    // Report error if "styleMap" is not being used on the "style" attribute.
                    if (htmlAttr.name !== "style" || htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE) {
                        return [
                            {
                                kind: exports.LitHtmlDiagnosticKind.DIRECTIVE_NOT_ALLOWED_HERE,
                                message: "The 'styleMap' directive can only be used in an attribute binding for the 'style' attribute",
                                source: "no-invalid-directive-binding",
                                severity: litDiagnosticRuleSeverity(request.config, "no-invalid-directive-binding"),
                                location: __assign({ document: document }, htmlAttr.location.name)
                            }
                        ];
                    }
                    break;
                case "unsafeHTML":
                case "cache":
                case "repeat":
                case "asyncReplace":
                case "asyncAppend":
                    // These directives can only be used within a text binding.
                    // This function validating assignments is per definition used NOT in a text binding
                    return [
                        {
                            kind: exports.LitHtmlDiagnosticKind.DIRECTIVE_NOT_ALLOWED_HERE,
                            message: "The '" + directive.kind + "' directive can only be used within a text binding.",
                            source: "no-invalid-directive-binding",
                            severity: litDiagnosticRuleSeverity(request.config, "no-invalid-directive-binding"),
                            location: __assign({ document: document }, htmlAttr.location.name)
                        }
                    ];
            }
        }
        else {
            // Now we have an unknown (user defined) directive.
            // Return empty array and opt out of any more type checking for this directive
            return [];
        }
        return;
    }
};

var CONTROL_CHARACTERS = ["'", '"', "}", "/"];
/**
 * This rule validates that bindings are not followed by certain characters that indicate typos.
 *
 * Examples:
 *   <input value=${val}' />
 *   <input value='${val}'' />
 *   <input value=${val}} />
 */
var rule$5 = {
    name: "no-unintended-mixed-binding",
    visitHtmlAssignment: function (assignment, request) {
        // Check mixed bindings
        if (assignment.kind !== HtmlNodeAttrAssignmentKind.MIXED) {
            return;
        }
        // Only check mixed bindings with 2 values
        if (assignment.values.length !== 2) {
            return;
        }
        // Event listener binding ignores mixed bindings.
        // This kind of binding only uses the first expression present in the mixed binding.
        if (assignment.htmlAttr.kind === HtmlNodeAttrKind.EVENT_LISTENER) {
            return;
        }
        // Ensure the last value is a string literal
        var secondAssignment = assignment.values[1];
        if (typeof secondAssignment !== "string") {
            return;
        }
        // Report error if the string literal is one of the control characters
        if (CONTROL_CHARACTERS.includes(secondAssignment)) {
            var quoteChar_1 = secondAssignment === "'" ? '"' : "'";
            var message = (function () {
                switch (secondAssignment) {
                    case "/":
                        return "This binding is directly followed by a '/' which is probably unintended.";
                    default:
                        return "This binding is directly followed by an unmatched " + quoteChar_1 + secondAssignment + quoteChar_1 + " which is probably unintended.";
                }
            })();
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_MIXED_BINDING,
                    severity: litDiagnosticRuleSeverity(request.config, "no-unintended-mixed-binding"),
                    source: "no-unintended-mixed-binding",
                    message: message,
                    location: __assign({ document: request.document }, assignment.htmlAttr.location.name)
                }
            ];
        }
        return;
    }
};

/**
 * This rule validates that only callable types are used within event binding expressions.
 * This rule catches typos like: @click="onClick()"
 */
var rule$6 = {
    name: "no-noncallable-event-binding",
    visitHtmlAssignment: function (assignment, request) {
        // Only validate event listener bindings.
        var htmlAttr = assignment.htmlAttr;
        if (htmlAttr.kind !== HtmlNodeAttrKind.EVENT_LISTENER)
            return;
        var typeB = extractBindingTypes(assignment, request).typeB;
        // Make sure that the expression given to the event listener binding a function or an object with "handleEvent" property.
        if (!isTypeBindableToEventListener(typeB)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.NO_EVENT_LISTENER_FUNCTION,
                    message: "You are setting up an event listener with a non-callable type '" + tsSimpleType.toTypeString(typeB) + "'",
                    source: "no-noncallable-event-binding",
                    severity: litDiagnosticRuleSeverity(request.config, "no-noncallable-event-binding"),
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    typeB: typeB
                }
            ];
        }
        return;
    }
};
/**
 * Returns if this type can be used in a event listener binding
 * @param type
 */
function isTypeBindableToEventListener(type) {
    // Callable types can be used in the binding
    if (tsSimpleType.isAssignableToSimpleTypeKind(type, [tsSimpleType.SimpleTypeKind.FUNCTION, tsSimpleType.SimpleTypeKind.METHOD, tsSimpleType.SimpleTypeKind.UNKNOWN], {
        matchAny: true,
        op: "or"
    })) {
        return true;
    }
    // Object types with attributes for the setup function of the event listener can be used
    if (type.kind === tsSimpleType.SimpleTypeKind.OBJECT || type.kind === tsSimpleType.SimpleTypeKind.INTERFACE) {
        // The "handleEvent" property must be present
        var handleEventFunction = type.members != null ? type.members.find(function (m) { return m.name === "handleEvent"; }) : undefined;
        // The "handleEvent" property must be callable
        if (handleEventFunction != null) {
            return isTypeBindableToEventListener(handleEventFunction.type);
        }
    }
    return false;
}

/**
 * This rule validates that "null" and "undefined" types are not bound in an attribute binding.
 */
var rule$7 = {
    name: "no-nullable-attribute-binding",
    visitHtmlAssignment: function (assignment, request) {
        // Only validate "expression" kind bindings.
        if (assignment.kind !== HtmlNodeAttrAssignmentKind.EXPRESSION)
            return;
        // Only validate "attribute" bindings because these will coerce null|undefined to a string.
        var htmlAttr = assignment.htmlAttr;
        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE)
            return;
        var _a = extractBindingTypes(assignment, request), typeA = _a.typeA, typeB = _a.typeB;
        // Test if removing "null" from typeB would work and suggest using "ifDefined(exp === null ? undefined : exp)".
        if (tsSimpleType.isAssignableToSimpleTypeKind(typeB, tsSimpleType.SimpleTypeKind.NULL)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_NULL,
                    message: "This attribute binds the type '" + tsSimpleType.toTypeString(typeB) + "' which can be 'null'.",
                    fix: "Use the 'ifDefined' directive and strict null check?",
                    source: "no-nullable-attribute-binding",
                    severity: litDiagnosticRuleSeverity(request.config, "no-nullable-attribute-binding"),
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        // Test if removing "undefined" from typeB would work and suggest using "ifDefined".
        else if (tsSimpleType.isAssignableToSimpleTypeKind(typeB, tsSimpleType.SimpleTypeKind.UNDEFINED)) {
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_ATTRIBUTE_EXPRESSION_TYPE_UNDEFINED,
                    message: "This attribute binds the type '" + tsSimpleType.toTypeString(typeB) + "' which can be 'undefined'.",
                    fix: "Use the 'ifDefined' directive?",
                    source: "no-nullable-attribute-binding",
                    severity: litDiagnosticRuleSeverity(request.config, "no-nullable-attribute-binding"),
                    location: __assign({ document: request.document }, htmlAttr.location.name),
                    htmlAttr: htmlAttr,
                    typeA: typeA,
                    typeB: typeB
                }
            ];
        }
        return;
    }
};

/**
 * This rule checks validates the slot attribute
 *   and makes sure that slot names used have been defined using jsdoc.
 */
var rule$8 = {
    name: "no-unknown-slot",
    visitHtmlNode: function (htmlNode, _a) {
        // This visitor function validates that a "slot" attribute is present on children elements if a slot name is required.
        var htmlStore = _a.htmlStore, document = _a.document, config = _a.config;
        // Get available slot names from the parent node of this node, because this node defined what slots are available.
        // Example: <my-element><input slot="footer" /></my-element>
        var slots = htmlNode.parent && Array.from(htmlStore.getAllSlotsForTag(htmlNode.parent.tagName));
        // Validate slots for this attribute if any slots have been defined on the parent element, else opt out.
        if (slots == null || slots.length === 0)
            return;
        // Find out if it's possible to use an unnamed slot.
        var unnamedSlot = slots.find(function (s) { return s.name === ""; });
        if (unnamedSlot == null) {
            // If it's not possible to use an unnamed slot, see if there is a "slot" attribute present.
            var slotAttr = htmlNode.attributes.find(function (a) { return a.name === "slot"; });
            if (slotAttr == null) {
                var parentTagName = (htmlNode.parent && htmlNode.parent.tagName) || "";
                // The slot attribute is missing, and it's not possible to use an unnamed slot.
                return [
                    {
                        kind: exports.LitHtmlDiagnosticKind.MISSING_SLOT_ATTRIBUTE,
                        validSlotNames: slots.map(function (s) { return s.name; }),
                        htmlNode: htmlNode,
                        message: "Missing slot attribute. Parent element <" + parentTagName + "> only allows named slots as children.",
                        severity: litDiagnosticRuleSeverity(config, "no-unknown-slot"),
                        source: "no-unknown-slot",
                        location: __assign({ document: document }, htmlNode.location.name)
                    }
                ];
            }
        }
        return;
    },
    visitHtmlAssignment: function (assignment, request) {
        // This visitor function validates that the value of a "slot" attribute is valid.
        var htmlAttr = assignment.htmlAttr;
        // Only validate attributes with the name "slot"
        if (htmlAttr.name !== "slot")
            return;
        // Only validate attributes that are bound to the attribute
        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE)
            return;
        // Only validate assignments of kind "string"
        if (assignment.kind !== HtmlNodeAttrAssignmentKind.STRING)
            return;
        // Grab the parent node of this attribute. The parent node defines what slot names are valid.
        var parent = htmlAttr.htmlNode.parent;
        if (parent == null)
            return;
        // Validate slots for this attribute if any slots have been defined on the parent element, else opt out.
        var parentHtmlTag = request.htmlStore.getHtmlTag(parent.tagName);
        if (parentHtmlTag == null || parentHtmlTag.slots.length === 0)
            return;
        // Grab the slot name of the "slot" attribute.
        var slotName = assignment.value;
        // Find which slots names are valid, and find if the slot name matches any of these.
        var validSlots = Array.from(request.htmlStore.getAllSlotsForTag(parentHtmlTag.tagName));
        var matchingSlot = validSlots.find(function (slot) { return slot.name === slotName; });
        if (matchingSlot == null) {
            // The slot name doesn't mach any slots! Generate a diagnostic.
            var validSlotNames = validSlots.map(function (s) { return s.name; });
            var message = validSlotNames.length === 1 && validSlotNames[0].length === 0
                ? "Invalid slot name '" + slotName + "'. Only the unnamed slot is valid for <" + parentHtmlTag.tagName + ">"
                : "Invalid slot name '" + slotName + "'. Valid slot names for <" + parentHtmlTag.tagName + "> are: " + validSlotNames.map(function (n) { return "'" + n + "'"; }).join(" | ");
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.INVALID_SLOT_NAME,
                    message: message,
                    validSlotNames: validSlotNames,
                    source: "no-unknown-slot",
                    severity: litDiagnosticRuleSeverity(request.config, "no-unknown-slot"),
                    location: __assign({ document: request.document }, htmlAttr.location.name)
                }
            ];
        }
        return;
    }
};

/**
 * This rule makes sure that all custom elements used are imported in a given file.
 */
var rule$9 = {
    name: "no-missing-import",
    visitHtmlNode: function (htmlNode, _a) {
        var htmlStore = _a.htmlStore, config = _a.config, definitionStore = _a.definitionStore, dependencyStore = _a.dependencyStore, document = _a.document;
        // Return if the html tag doesn't exists or if the html tag doesn't have a declaration
        var htmlTag = htmlStore.getHtmlTag(htmlNode);
        if (htmlTag == null)
            return;
        // Only check if custom elements have been imported.
        var isCustomElement = isCustomElementTagName(htmlNode.tagName);
        if (!isCustomElement)
            return;
        // Don't continue if this tag name doesn't have a definition.
        // If the html tag doesn't have a definition we won't know how to import it.
        var definition = definitionStore.getDefinitionForTagName(htmlNode.tagName);
        if (definition == null)
            return;
        // Check if the tag name has been imported in the file of the template.
        var fromFileName = document.virtualDocument.fileName;
        var isDefinitionImported = dependencyStore.hasTagNameBeenImported(fromFileName, htmlNode.tagName);
        // Report diagnostic if the html tag hasn't been imported.
        if (!isDefinitionImported) {
            // Get the import path and the position where it can be placed
            var importPath = getRelativePathForImport(fromFileName, definition.node.getSourceFile().fileName);
            var report = {
                kind: exports.LitHtmlDiagnosticKind.MISSING_IMPORT,
                message: "Missing import for <" + htmlNode.tagName + ">",
                suggestion: config.dontSuggestConfigChanges ? undefined : "You can disable this check by disabling the 'no-missing-import' rule.",
                source: "no-missing-import",
                severity: litDiagnosticRuleSeverity(config, "no-missing-import"),
                location: __assign({ document: document }, htmlNode.location.name),
                htmlNode: htmlNode,
                definition: definition,
                importPath: importPath
            };
            if (config.dontSuggestConfigChanges) {
                report.suggestion = undefined;
            }
            return [report];
        }
        return;
    }
};
/**
 * Returns a relative path from a file path to another file path.
 * This path can be used in an import statement.
 * @param fromFileName
 * @param toFileName
 */
function getRelativePathForImport(fromFileName, toFileName) {
    var path$1 = path.relative(path.dirname(fromFileName), path.dirname(toFileName));
    var filenameWithoutExt = path.basename(toFileName).replace(/\.[^/.]+$/, "");
    var importPath = "./" + (path$1 ? path$1 + "/" : "") + filenameWithoutExt;
    return importPath
        .replace(/^.*node_modules\//, "")
        .replace(/\.d$/, "")
        .replace(/\/index$/, "");
}

/**
 * This rule validates that all tags are closed properly.
 */
var rule$a = {
    name: "no-unclosed-tag",
    visitHtmlNode: function (htmlNode, request) {
        if (!htmlNode.selfClosed && htmlNode.location.endTag == null) {
            // Report specifically that a custom element cannot be self closing
            //   if the user is trying to close a custom element.
            var isCustomElement = isCustomElementTagName(htmlNode.tagName);
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.TAG_NOT_CLOSED,
                    message: htmlNode.selfClosed + ", This tag isn't closed." + (isCustomElement ? " Custom elements cannot be self closing." : ""),
                    severity: litDiagnosticRuleSeverity(request.config, "no-unclosed-tag"),
                    source: "no-unclosed-tag",
                    location: __assign({ document: request.document }, htmlNode.location.name),
                    htmlNode: htmlNode
                }
            ];
        }
        return;
    }
};

function findBestMatch(find, elements, options) {
    options.caseSensitive = "caseSensitive" in options ? options.caseSensitive : false;
    options.threshold = "threshold" in options ? options.threshold : 0.5;
    return didYouMean__default(find, elements, {
        caseSensitive: options.caseSensitive,
        threshold: options.threshold,
        matchPath: [options.matchKey],
        returnType: didYouMean.ReturnTypeEnums.FIRST_CLOSEST_MATCH,
        trimSpaces: false
    });
}
function findBestStringMatch(find, elements, options) {
    if (options === void 0) { options = {
        caseSensitive: true,
        threshold: 0.5
    }; }
    var matches = didYouMean__default(find, elements, options);
    return typeof matches === "string" ? matches : Array.isArray(matches) ? matches[0] : undefined;
}

/**
 * This rule checks that all tag names used in a template are defined.
 */
var rule$b = {
    name: "no-unknown-tag-name",
    visitHtmlNode: function (htmlNode, _a) {
        var htmlStore = _a.htmlStore, config = _a.config, document = _a.document;
        // Don't validate style and svg yet
        if (htmlNode.kind !== HtmlNodeKind.NODE)
            return;
        // Get the html tag from the html store
        var htmlTag = htmlStore.getHtmlTag(htmlNode);
        // Add diagnostics if the tag couldn't be found (not defined anywhere)
        if (htmlTag == null) {
            // Find a suggested name in the set of defined tag names. Maybe this tag name is a typo?
            var suggestedName = findBestStringMatch(htmlNode.tagName, Array.from(htmlStore.getGlobalTags()).map(function (tag) { return tag.tagName; }));
            // Build a suggestion text
            var suggestion = "Check that you've imported the element, and that it's declared on the HTMLElementTagNameMap.";
            if (!config.dontSuggestConfigChanges) {
                suggestion += " If it can't be imported, consider adding it to the 'globalTags' plugin configuration or disabling the 'no-unknown-tag' rule.";
            }
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.UNKNOWN_TAG,
                    message: "Unknown tag \"" + htmlNode.tagName + "\".",
                    fix: suggestedName == null ? undefined : "Did you mean '" + suggestedName + "'?",
                    location: __assign({ document: document }, htmlNode.location.name),
                    source: "no-unknown-tag-name",
                    severity: litDiagnosticRuleSeverity(config, "no-unknown-tag-name"),
                    suggestion: suggestion,
                    htmlNode: htmlNode,
                    suggestedName: suggestedName
                }
            ];
        }
        return;
    }
};

function suggestTargetForHtmlAttr(htmlNodeAttr, htmlStore) {
    var properties = htmlStore.getAllPropertiesForTag(htmlNodeAttr.htmlNode);
    var attributes = htmlStore.getAllAttributesForTag(htmlNodeAttr.htmlNode);
    var events = htmlStore.getAllEventsForTag(htmlNodeAttr.htmlNode);
    switch (htmlNodeAttr.kind) {
        case HtmlNodeAttrKind.EVENT_LISTENER:
            return findSuggestedTarget(htmlNodeAttr.name, events);
        case HtmlNodeAttrKind.PROPERTY:
            return findSuggestedTarget(htmlNodeAttr.name, properties, attributes);
        case HtmlNodeAttrKind.ATTRIBUTE:
        case HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE:
            return findSuggestedTarget(htmlNodeAttr.name, attributes, properties);
    }
}
function findSuggestedTarget(name) {
    var e_1, _a;
    var tests = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        tests[_i - 1] = arguments[_i];
    }
    try {
        for (var tests_1 = __values(tests), tests_1_1 = tests_1.next(); !tests_1_1.done; tests_1_1 = tests_1.next()) {
            var test = tests_1_1.value;
            var match = findBestMatch(name, __spread(test), { matchKey: "name", caseSensitive: false });
            if (match != null) {
                return match;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tests_1_1 && !tests_1_1.done && (_a = tests_1.return)) _a.call(tests_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return;
}

/**
 * This rule validates that only known attributes are used in attribute bindings.
 */
var rule$c = {
    name: "no-unknown-attribute",
    visitHtmlAttribute: function (htmlAttr, _a) {
        var htmlStore = _a.htmlStore, config = _a.config, definitionStore = _a.definitionStore, document = _a.document;
        // Ignore "style" and "svg" attrs because I don't yet have all data for them.
        if (htmlAttr.htmlNode.kind !== HtmlNodeKind.NODE)
            return;
        // Only validate attribute bindings.
        if (htmlAttr.kind !== HtmlNodeAttrKind.ATTRIBUTE && htmlAttr.kind !== HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE)
            return;
        // Report a diagnostic if the target is unknown
        var htmlAttrTarget = htmlStore.getHtmlAttrTarget(htmlAttr);
        if (htmlAttrTarget == null) {
            // Don't report unknown attributes on unknown tag names
            var htmlTag = htmlStore.getHtmlTag(htmlAttr.htmlNode);
            if (htmlTag == null)
                return;
            // Ignore unknown "data-" attributes
            if (htmlAttr.name.startsWith("data-"))
                return;
            // Get suggested target
            var suggestedTarget = suggestTargetForHtmlAttr(htmlAttr, htmlStore);
            var suggestedMemberName = (suggestedTarget && "" + litAttributeModifierForTarget(suggestedTarget) + suggestedTarget.name) || undefined;
            var suggestion = getSuggestionText({ config: config, htmlTag: htmlTag, definitionStore: definitionStore });
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.UNKNOWN_TARGET,
                    message: "Unknown attribute '" + htmlAttr.name + "'.",
                    fix: suggestedMemberName == null ? undefined : "Did you mean '" + suggestedMemberName + "'?",
                    location: __assign({ document: document }, htmlAttr.location.name),
                    source: "no-unknown-attribute",
                    severity: litDiagnosticRuleSeverity(config, "no-unknown-attribute"),
                    suggestion: suggestion,
                    htmlAttr: htmlAttr,
                    suggestedTarget: suggestedTarget
                }
            ];
        }
        return;
    }
};
/**
 * Returns are suggestion for the unknown attribute rule.
 * @param config
 * @param definitionStore
 * @param htmlTag
 */
function getSuggestionText(_a) {
    var config = _a.config, definitionStore = _a.definitionStore, htmlTag = _a.htmlTag;
    if (config.dontSuggestConfigChanges) {
        return "Please consider using a data-* attribute.";
    }
    var definition = definitionStore.getDefinitionForTagName(htmlTag.tagName);
    var tagHasDeclaration = htmlTag.declaration != null;
    var tagIsBuiltIn = htmlTag.builtIn || false;
    var tagIsFromLibrary = definition != null && definition.declaration.node.getSourceFile().isDeclarationFile;
    return tagIsBuiltIn
        ? "This is a built in tag. Please consider using a 'data-*' attribute, adding the attribute to 'globalAttributes' or disabling the 'no-unknown-attribute' rule."
        : tagIsFromLibrary
            ? "If you are not the author of this component please consider using a 'data-*' attribute, adding the attribute to 'globalAttributes' or disabling the 'no-unknown-attribute' rule."
            : tagHasDeclaration
                ? "Please consider adding it as an attribute on the component, adding '@attr' tag to jsdoc on the component class or using a 'data-*' attribute instead."
                : "Please consider using a 'data-*' attribute.";
}

/**
 * This rule validates that only known properties are used in bindings.
 */
var rule$d = {
    name: "no-unknown-property",
    visitHtmlAttribute: function (htmlAttr, _a) {
        var htmlStore = _a.htmlStore, config = _a.config, definitionStore = _a.definitionStore, document = _a.document;
        // Ignore "style" and "svg" attrs because I don't yet have all data for them.
        if (htmlAttr.htmlNode.kind !== HtmlNodeKind.NODE)
            return;
        // Only validate property bindings.
        if (htmlAttr.kind !== HtmlNodeAttrKind.PROPERTY)
            return;
        // Report a diagnostic if the target is unknown.
        var htmlAttrTarget = htmlStore.getHtmlAttrTarget(htmlAttr);
        if (htmlAttrTarget == null) {
            // Don't report unknown properties on unknown tags
            var htmlTag = htmlStore.getHtmlTag(htmlAttr.htmlNode);
            if (htmlTag == null)
                return;
            // Get suggested target because the name could be a typo.
            var suggestedTarget = suggestTargetForHtmlAttr(htmlAttr, htmlStore);
            var suggestedMemberName = (suggestedTarget && "" + litAttributeModifierForTarget(suggestedTarget) + suggestedTarget.name) || undefined;
            var suggestion = getSuggestionText$1({ config: config, definitionStore: definitionStore, htmlTag: htmlTag });
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.UNKNOWN_TARGET,
                    message: "Unknown property '" + htmlAttr.name + "'.",
                    fix: suggestedMemberName == null ? undefined : "Did you mean '" + suggestedMemberName + "'?",
                    location: __assign({ document: document }, htmlAttr.location.name),
                    source: "no-unknown-property",
                    severity: litDiagnosticRuleSeverity(config, "no-unknown-property"),
                    suggestion: suggestion,
                    htmlAttr: htmlAttr,
                    suggestedTarget: suggestedTarget
                }
            ];
        }
        return;
    }
};
/**
 * Generates a suggestion for the unknown property rule.
 * @param config
 * @param definitionStore
 * @param htmlTag
 */
function getSuggestionText$1(_a) {
    var config = _a.config, definitionStore = _a.definitionStore, htmlTag = _a.htmlTag;
    // Don't generate suggestion if config changes has been disabled.
    if (config.dontSuggestConfigChanges) {
        return undefined;
    }
    var definition = definitionStore.getDefinitionForTagName(htmlTag.tagName);
    var tagHasDeclaration = htmlTag.declaration != null;
    var tagIsBuiltIn = htmlTag.builtIn || false;
    var tagIsFromLibrary = definition != null && definition.declaration.node.getSourceFile().isDeclarationFile;
    return tagIsBuiltIn
        ? "This is a built in tag. Please consider disabling the 'no-unknown-property' rule."
        : tagIsFromLibrary
            ? "If you are not the author of this component please consider disabling the 'no-unknown-property' rule."
            : tagHasDeclaration
                ? "This plugin can't automatically find all properties yet. Please consider adding a '@prop' tag to jsdoc on the component class or disabling the 'no-unknown-property' rule."
                : "Please consider disabling the 'no-unknown-property' rule.";
}

/**
 * This rule validates that only known events are used in event listener bindings.
 */
var rule$e = {
    name: "no-unknown-event",
    visitHtmlAttribute: function (htmlAttr, _a) {
        var htmlStore = _a.htmlStore, config = _a.config, definitionStore = _a.definitionStore, document = _a.document;
        // Ignore "style" and "svg" attrs because I don't yet have all data for them.
        if (htmlAttr.htmlNode.kind !== HtmlNodeKind.NODE)
            return;
        // Only validate event listener bindings.
        if (htmlAttr.kind !== HtmlNodeAttrKind.EVENT_LISTENER)
            return;
        // Report a diagnostic if the target is unknown
        var htmlAttrTarget = htmlStore.getHtmlAttrTarget(htmlAttr);
        if (htmlAttrTarget == null) {
            // Don't report unknown properties on unknown tags
            var htmlTag = htmlStore.getHtmlTag(htmlAttr.htmlNode);
            if (htmlTag == null)
                return;
            // Get suggested target
            var suggestedTarget = suggestTargetForHtmlAttr(htmlAttr, htmlStore);
            var suggestedMemberName = (suggestedTarget && "" + litAttributeModifierForTarget(suggestedTarget) + suggestedTarget.name) || undefined;
            var suggestion = getSuggestionText$2({ config: config, definitionStore: definitionStore, htmlTag: htmlTag });
            return [
                {
                    kind: exports.LitHtmlDiagnosticKind.UNKNOWN_TARGET,
                    message: "Unknown event '" + htmlAttr.name + "'.",
                    fix: suggestedMemberName == null ? undefined : "Did you mean '" + suggestedMemberName + "'?",
                    location: __assign({ document: document }, htmlAttr.location.name),
                    source: "no-unknown-event",
                    severity: litDiagnosticRuleSeverity(config, "no-unknown-event"),
                    suggestion: suggestion,
                    htmlAttr: htmlAttr,
                    suggestedTarget: suggestedTarget
                }
            ];
        }
        return;
    }
};
/**
 * Returns a suggestion text for the unknown event rule.
 * @param config
 * @param definitionStore
 * @param htmlTag
 */
function getSuggestionText$2(_a) {
    var config = _a.config, definitionStore = _a.definitionStore, htmlTag = _a.htmlTag;
    if (config.dontSuggestConfigChanges) {
        return "Please consider adding '@fires " + htmlTag.tagName + "' to the jsdoc on a component class";
    }
    return "Please consider adding '@fires " + htmlTag.tagName + "' to the jsdoc on a component class, adding it to 'globalEvents' or disabling the 'no-unknown-event' rule.";
}

function convertAnalyzeResultToHtmlCollection(result, options) {
    var tags = result.componentDefinitions.map(function (definition) { return convertComponentDeclarationToHtmlTag(definition.declaration, definition, options); });
    return {
        tags: tags,
        events: [],
        attrs: []
    };
}
function convertComponentDeclarationToHtmlTag(declaration, definition, _a) {
    var e_1, _b, e_2, _c, e_3, _d;
    var checker = _a.checker, addDeclarationPropertiesAsAttributes = _a.addDeclarationPropertiesAsAttributes;
    var tagName = (definition && definition.tagName) || "";
    var builtIn = definition == null || definition.fromLib;
    var htmlTag = {
        declaration: declaration,
        tagName: tagName,
        builtIn: builtIn,
        description: descriptionFromJsDoc(declaration.jsDoc),
        attributes: [],
        properties: [],
        slots: [],
        events: []
    };
    var _loop_1 = function (event_1) {
        htmlTag.events.push({
            declaration: event_1,
            description: descriptionFromJsDoc(event_1.jsDoc),
            name: event_1.name,
            getType: lazy(function () { return (tsSimpleType.isSimpleType(event_1.type) ? event_1.type : tsSimpleType.toSimpleType(event_1.type, checker)); }),
            fromTagName: tagName,
            builtIn: builtIn
        });
        htmlTag.attributes.push({
            kind: "attribute",
            name: "on" + event_1.name,
            description: descriptionFromJsDoc(event_1.jsDoc),
            getType: lazy(function () { return ({ kind: tsSimpleType.SimpleTypeKind.STRING }); }),
            fromTagName: tagName,
            declaration: {
                attrName: "on" + event_1.name,
                jsDoc: event_1.jsDoc,
                kind: "attribute",
                node: event_1.node,
                type: { kind: tsSimpleType.SimpleTypeKind.ANY }
            },
            builtIn: builtIn
        });
    };
    try {
        for (var _e = __values(declaration.events), _f = _e.next(); !_f.done; _f = _e.next()) {
            var event_1 = _f.value;
            _loop_1(event_1);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var _g = __values(declaration.slots), _h = _g.next(); !_h.done; _h = _g.next()) {
            var slot = _h.value;
            htmlTag.slots.push({
                declaration: slot,
                description: descriptionFromJsDoc(slot.jsDoc),
                name: slot.name || "",
                fromTagName: tagName
            });
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var _loop_2 = function (member) {
        var base = {
            declaration: member,
            description: descriptionFromJsDoc(member.jsDoc),
            getType: lazy(function () { return (tsSimpleType.isSimpleType(member.type) ? member.type : tsSimpleType.toSimpleType(member.type, checker)); }),
            fromTagName: tagName,
            builtIn: builtIn
        };
        if (member.kind === "method")
            return "continue";
        if (member.kind === "property") {
            htmlTag.properties.push(__assign({}, base, { kind: "property", name: member.propName, required: member.required }));
            if (!("attrName" in member) && addDeclarationPropertiesAsAttributes && (definition != null && !definition.fromLib)) {
                if (declaration.node.getSourceFile().isDeclarationFile) {
                    htmlTag.attributes.push(__assign({}, base, { kind: "attribute", name: member.propName }));
                }
            }
        }
        if ("attrName" in member && member.attrName != null) {
            htmlTag.attributes.push(__assign({}, base, { kind: "attribute", name: member.attrName, required: member.required }));
        }
    };
    try {
        for (var _j = __values(declaration.members), _k = _j.next(); !_k.done; _k = _j.next()) {
            var member = _k.value;
            _loop_2(member);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_k && !_k.done && (_d = _j.return)) _d.call(_j);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return htmlTag;
}
function descriptionFromJsDoc(jsDoc) {
    return (jsDoc && jsDoc.comment) || undefined;
}

/**
 * Visits dependencies recursively.
 * @param node
 * @param context
 */
function visitDependencies(node, context) {
    if (node == null)
        return;
    if (context.ts.isSourceFile(node)) {
        var existingResult = context.getImportedDefinitionsInFile(node);
        if (existingResult != null) {
            // It's already cached
            context.addDefinitionsForFile(node, existingResult, false);
        }
        else {
            var result_1 = __spread((context.getDefinitionsInFile(node) || []));
            var isCircular_1 = false;
            // Pick up all new components and add them to the scope of this file.
            var newContext_1 = __assign({}, context, { 
                // Expand locked files with this file
                lockedFiles: __spread(context.lockedFiles, [node.fileName]), addDefinitionsForFile: function (file, newResults, isCircular) {
                    context.addDefinitionsForFile(file, newResults, isCircular);
                    result_1.push.apply(result_1, __spread(newResults));
                },
                addCircularReference: function () {
                    isCircular_1 = true;
                } });
            node.forEachChild(function (child) { return visitDependencies(child, newContext_1); });
            // Filter out duplicates in the "components" array. Eg two files depend on the same elements.
            var uniqueResults = Array.from(new Set(result_1));
            context.addDefinitionsForFile(node, uniqueResults, isCircular_1);
            return;
        }
    }
    else if (context.ts.isImportDeclaration(node) || context.ts.isExportDeclaration(node)) {
        if (node.moduleSpecifier != null && context.ts.isStringLiteral(node.moduleSpecifier)) {
            visitModuleWithName(node.moduleSpecifier.text, node, context);
        }
    }
    else if (context.ts.isCallExpression(node) && node.expression.kind === context.ts.SyntaxKind.ImportKeyword) {
        var moduleSpecifier = node.arguments[0];
        if (moduleSpecifier != null && context.ts.isStringLiteralLike(moduleSpecifier)) {
            visitModuleWithName(moduleSpecifier.text, node, context);
        }
    }
    else {
        node.forEachChild(function (child) { return visitDependencies(child, context); });
    }
}
function visitModuleWithName(moduleSpecifier, node, context) {
    // Resolve the imported string
    var result = context.project
        ? context.project.getResolvedModuleWithFailedLookupLocationsFromCache(moduleSpecifier, node.getSourceFile().fileName)
        : "getResolvedModuleWithFailedLookupLocationsFromCache" in context.program
            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
                context.program["getResolvedModuleWithFailedLookupLocationsFromCache"](moduleSpecifier, node.getSourceFile().fileName)
            : undefined;
    var mod = result != null ? result.resolvedModule : undefined;
    if (mod != null) {
        var isCircularImport = context.lockedFiles.includes(mod.resolvedFileName);
        var sourceFile = context.program.getSourceFile(mod.resolvedFileName);
        if (!isCircularImport) {
            if (sourceFile != null) {
                // Visit dependencies in the import recursively
                visitDependencies(sourceFile, context);
            }
        }
        else if (sourceFile != null) {
            // Stop! Prevent infinite loop due to circular imports
            context.addCircularReference(node.getSourceFile(), sourceFile);
        }
    }
}

var map = new WeakMap();
/**
 * Returns a map of component declarations in each file encountered from a source file recursively.
 * @param sourceFile
 * @param context
 */
function parseDependencies(sourceFile, context) {
    var definitions = [];
    visitDependencies(sourceFile, {
        project: context.project,
        program: context.program,
        ts: context.ts,
        lockedFiles: [],
        addDefinitionsForFile: function (file, results, isCircular) {
            // Only set the result if this isn't a circular import and file is equal to the start file.
            if (!isCircular) {
                map.set(file, results);
            }
            // Always safe the definitions if the results comes from this file
            if (file === sourceFile) {
                definitions = Array.from(new Set(results));
            }
        },
        getImportedDefinitionsInFile: function (file) {
            return map.get(file);
        },
        getDefinitionsInFile: function (file) {
            return context.definitionStore.getDefinitionsInFile(file);
        },
        addCircularReference: function (fromFile, toFile) { }
    });
    return definitions;
}

var DefaultAnalyzerDefinitionStore = /** @class */ (function () {
    function DefaultAnalyzerDefinitionStore() {
        this.analysisResultForFile = new Map();
        this.definitionForTagName = new Map();
    }
    DefaultAnalyzerDefinitionStore.prototype.absorbAnalysisResult = function (sourceFile, result) {
        var _this = this;
        this.analysisResultForFile.set(sourceFile.fileName, result);
        result.componentDefinitions.forEach(function (definition) {
            _this.definitionForTagName.set(definition.tagName, definition);
        });
    };
    DefaultAnalyzerDefinitionStore.prototype.forgetAnalysisResultForFile = function (sourceFile) {
        var _this = this;
        var result = this.analysisResultForFile.get(sourceFile.fileName);
        if (result == null)
            return;
        result.componentDefinitions.forEach(function (definition) {
            _this.definitionForTagName.delete(definition.tagName);
        });
        this.analysisResultForFile.delete(sourceFile.fileName);
    };
    DefaultAnalyzerDefinitionStore.prototype.getAnalysisResultForFile = function (sourceFile) {
        return this.analysisResultForFile.get(sourceFile.fileName);
    };
    DefaultAnalyzerDefinitionStore.prototype.getAnalysisDiagnosticsInFile = function (sourceFile) {
        var diagnosticForNode = new Map();
        this.analysisResultForFile.forEach(function (def) {
            return def.diagnostics.forEach(function (diagnostic) {
                if (diagnostic.node.getSourceFile() === sourceFile) {
                    diagnosticForNode.set(diagnostic.node, diagnostic);
                }
            });
        });
        //flatten(Array.from(this.analysisResultForFile.values()).map(def => def.diagnostics.filter(diagnostic => diagnostic.node.getSourceFile() === sourceFile)));
        return Array.from(diagnosticForNode.values());
    };
    DefaultAnalyzerDefinitionStore.prototype.getDefinitionsWithDeclarationInFile = function (sourceFile) {
        return Array.from(this.definitionForTagName.values()).filter(function (d) {
            return __spread([d.declaration.node], (d.declaration.inheritNodes || [])).map(function (n) { return n.getSourceFile(); }).find(function (sf) { return sf.fileName === sourceFile.fileName; });
        });
    };
    DefaultAnalyzerDefinitionStore.prototype.getDefinitionForTagName = function (tagName) {
        return this.definitionForTagName.get(tagName);
    };
    DefaultAnalyzerDefinitionStore.prototype.getDefinitionsInFile = function (sourceFile) {
        var result = this.analysisResultForFile.get(sourceFile.fileName);
        return (result != null && result.componentDefinitions) || [];
    };
    return DefaultAnalyzerDefinitionStore;
}());

var DefaultAnalyzerDependencyStore = /** @class */ (function () {
    function DefaultAnalyzerDependencyStore() {
        this.importedComponentDefinitionsInFile = new Map();
    }
    DefaultAnalyzerDependencyStore.prototype.absorbComponentDefinitionsForFile = function (sourceFile, result) {
        this.importedComponentDefinitionsInFile.set(sourceFile.fileName, result);
    };
    /**
     * Returns if a component for a specific file has been imported.
     * @param fileName
     * @param tagName
     */
    DefaultAnalyzerDependencyStore.prototype.hasTagNameBeenImported = function (fileName, tagName) {
        var e_1, _a;
        try {
            for (var _b = __values(this.importedComponentDefinitionsInFile.get(fileName) || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var file = _c.value;
                if (file.tagName === tagName) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    return DefaultAnalyzerDependencyStore;
}());

function findTaggedTemplates(sourceFile, templateTags, position) {
    if (position != null) {
        var token = getNodeAtPosition(sourceFile, position);
        var node = findParent(token, tsModule.ts.isTaggedTemplateExpression);
        if (node != null && tsModule.ts.isTaggedTemplateExpression(node)) {
            if (templateTags.includes(node.tag.getText())) {
                return node;
            }
        }
        return undefined;
    }
    else {
        var taggedTemplates_1 = [];
        visitTaggedTemplateNodes(sourceFile, {
            shouldCheckTemplateTag: function (templateTag) {
                return templateTags.includes(templateTag);
            },
            emitTaggedTemplateNode: function (node) {
                taggedTemplates_1.push(node);
            }
        });
        return taggedTemplates_1;
    }
}
function visitTaggedTemplateNodes(astNode, context) {
    var newContext = __assign({}, context);
    if (tsModule.ts.isTaggedTemplateExpression(astNode) && context.shouldCheckTemplateTag(astNode.tag.getText())) {
        // Only visit the template expression if the leading comments does not include the ts-ignore flag.
        //if (!leadingCommentsIncludes(astNode.getSourceFile().getText(), astNode.getFullStart(), TS_IGNORE_FLAG)) {
        newContext.parent = astNode;
        context.emitTaggedTemplateNode(astNode);
    }
    astNode.forEachChild(function (child) { return visitTaggedTemplateNodes(child, context); });
}

function getSourceLocation(node) {
    var nodeWithLocation = node;
    return nodeWithLocation.sourceCodeLocation || nodeWithLocation.__location;
}

var parseFragment = require("parse5").parseFragment;
/**
 * Returns if a p5Node is a tag node.
 * @param node
 */
function isTagNode(node) {
    return !node.nodeName.includes("#");
}
/**
 * Returns if a p5Node is a comment node.
 * @param node
 */
function isCommentNode(node) {
    return node.nodeName === "#comment";
}
/**
 * Parse a html string into p5Nodes.
 * @param html
 */
function parseHtml(html) {
    return parseFragment(html, { sourceCodeLocationInfo: true, locationInfo: true });
}

/**
 * Parses a html attribute assignment.
 * @param p5Node
 * @param p5Attr
 * @param htmlAttr
 * @param context
 */
function parseHtmlAttrAssignment(p5Node, p5Attr, htmlAttr, context) {
    var location = getAssignmentLocation(p5Node, p5Attr, htmlAttr, context);
    if (location == null) {
        return { kind: HtmlNodeAttrAssignmentKind.BOOLEAN, htmlAttr: htmlAttr };
    }
    var values = context.getPartsAtOffsetRange(location);
    if (values.length === 0) {
        return undefined;
    }
    else if (values.length === 1) {
        var value = values[0];
        if (typeof value === "string") {
            return {
                kind: HtmlNodeAttrAssignmentKind.STRING,
                location: location,
                value: value,
                htmlAttr: htmlAttr
            };
        }
        else {
            return {
                kind: HtmlNodeAttrAssignmentKind.EXPRESSION,
                location: location,
                expression: value,
                htmlAttr: htmlAttr
            };
        }
    }
    else {
        return {
            kind: HtmlNodeAttrAssignmentKind.MIXED,
            location: location,
            values: values,
            htmlAttr: htmlAttr
        };
    }
}
function getAssignmentLocation(p5Node, p5Attr, htmlAttr, context) {
    var sourceLocation = getSourceLocation(p5Node);
    if (sourceLocation == null) {
        return undefined;
    }
    var htmlAttrLocation = (sourceLocation.startTag.attrs || {})[p5Attr.name];
    if (htmlAttrLocation == null)
        return undefined;
    var nameEndOffset = htmlAttr.location.name.end;
    var htmlAfterName = context.html.substring(nameEndOffset, htmlAttrLocation.endOffset);
    var firstQuote = indexOfRegExp(htmlAfterName, /^([\s=]*)(['"])/);
    var lastQuote = indexOfRegExp(htmlAfterName, /['"]\s*$/);
    var firstEquals = indexOfRegExp(htmlAfterName, /=/);
    // Example: attr
    if (firstEquals == null)
        return undefined;
    // Example: attr=myvalue | attr=myvalue" | attr="myvalue
    if (firstQuote == null || lastQuote == null) {
        return {
            start: nameEndOffset + firstEquals + 1,
            end: htmlAttrLocation.endOffset
        };
    }
    // Example: attr="myvalue"
    return {
        start: nameEndOffset + firstQuote + 1,
        end: nameEndOffset + lastQuote
    };
}
/**
 * Returns the index of a regex match.
 * Returns -1 when no match is found.
 * @param text
 * @param reg
 */
function indexOfRegExp(text, reg) {
    var match = text.match(reg);
    if (match == null)
        return undefined;
    // Support matching with a prefix group that counts as padding
    if (match.length === 3) {
        return match[1].length;
    }
    return match.index;
}

/**
 * Creates multiple html attributes based on multiple p5Attributes.
 * @param p5Node
 * @param context
 */
function parseHtmlNodeAttrs(p5Node, context) {
    return p5Node.attrs
        .map(function (htmlAttr) {
        return parseHtmlNodeAttr(p5Node, htmlAttr, __assign({}, context, { htmlNode: context.htmlNode }));
    })
        .filter(function (attr) { return attr != null; });
}
/**
 * Creates a html attr based on a p5Attr.
 * @param p5Node
 * @param p5Attr
 * @param context
 */
function parseHtmlNodeAttr(p5Node, p5Attr, context) {
    var htmlNode = context.htmlNode;
    var _a = parseLitAttrName(p5Attr.name), name = _a.name, modifier = _a.modifier;
    var location = makeHtmlAttrLocation(p5Node, p5Attr);
    if (location == null) {
        return undefined;
    }
    var htmlAttrBase = {
        name: name.toLowerCase(),
        modifier: modifier,
        htmlNode: htmlNode,
        location: location
    };
    var htmlAttr = parseHtmlAttrBase(htmlAttrBase);
    htmlAttr.assignment = parseHtmlAttrAssignment(p5Node, p5Attr, htmlAttr, context);
    return htmlAttr;
}
/**
 * Returns source code location based on a p5Node.
 * @param p5Node
 * @param p5Attr
 * @param context
 */
function makeHtmlAttrLocation(p5Node, p5Attr, context) {
    var _a = parseLitAttrName(p5Attr.name), name = _a.name, modifier = _a.modifier;
    var sourceLocation = getSourceLocation(p5Node);
    if (sourceLocation == null) {
        return undefined;
    }
    // Explicitly call "toLowerCase()" because of inconsistencies in parse5.
    // Parse5 lowercases source code location attr keys but doesnt lowercase the attr name when it comes to svg.
    // It would be correct not to lowercase the attr names because svg is case sensitive
    var sourceCodeLocationName = ("" + (p5Attr.prefix || "") + ((p5Attr.prefix && ":") || "") + p5Attr.name).toLowerCase();
    var htmlAttrLocation = (sourceLocation.startTag.attrs || {})[sourceCodeLocationName];
    var start = htmlAttrLocation.startOffset;
    var end = htmlAttrLocation.endOffset;
    return {
        start: start,
        end: end,
        name: {
            start: start + (modifier ? modifier.length : 0),
            end: start + (modifier ? modifier.length : 0) + name.length
        }
    };
}
function parseHtmlAttrBase(htmlAttrBase) {
    var modifier = htmlAttrBase.modifier;
    switch (modifier) {
        case LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER:
            return __assign({ kind: HtmlNodeAttrKind.EVENT_LISTENER }, htmlAttrBase, { modifier: modifier });
        case LIT_HTML_PROP_ATTRIBUTE_MODIFIER:
            return __assign({ kind: HtmlNodeAttrKind.PROPERTY }, htmlAttrBase, { modifier: modifier });
        case LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER:
            return __assign({ kind: HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE }, htmlAttrBase, { modifier: modifier });
        default:
            return __assign({ kind: HtmlNodeAttrKind.ATTRIBUTE }, htmlAttrBase, { modifier: undefined });
    }
}

/**
 * Parses multiple p5Nodes into multiple html nodes.
 * @param p5Nodes
 * @param parent
 * @param context
 */
function parseHtmlNodes(p5Nodes, parent, context) {
    var e_1, _a;
    var htmlNodes = [];
    var ignoreNextNode = false;
    try {
        for (var p5Nodes_1 = __values(p5Nodes), p5Nodes_1_1 = p5Nodes_1.next(); !p5Nodes_1_1.done; p5Nodes_1_1 = p5Nodes_1.next()) {
            var p5Node = p5Nodes_1_1.value;
            // Check ts-ignore comments and indicate that we wan't to ignore the next node
            if (isCommentNode(p5Node)) {
                if (p5Node.data != null && p5Node.data.includes(TS_IGNORE_FLAG)) {
                    ignoreNextNode = true;
                }
            }
            if (isTagNode(p5Node)) {
                if (!ignoreNextNode) {
                    var htmlNode = parseHtmlNode(p5Node, parent, context);
                    if (htmlNode != null) {
                        htmlNodes.push(htmlNode);
                    }
                }
                else {
                    ignoreNextNode = false;
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (p5Nodes_1_1 && !p5Nodes_1_1.done && (_a = p5Nodes_1.return)) _a.call(p5Nodes_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return htmlNodes;
}
/**
 * Parses a single p5Node into a html node.
 * @param p5Node
 * @param parent
 * @param context
 */
function parseHtmlNode(p5Node, parent, context) {
    // `sourceCodeLocation` will be undefined if the element was implicitly created by the parser.
    if (getSourceLocation(p5Node) == null)
        return undefined;
    var htmlNodeBase = {
        tagName: p5Node.tagName.toLowerCase(),
        selfClosed: isSelfClosed(p5Node),
        attributes: [],
        location: makeHtmlNodeLocation(p5Node),
        children: [],
        parent: parent
    };
    var htmlNode = parseHtmlNodeBase(htmlNodeBase);
    // Don't parse children of <style> and <svg> as of now
    if (htmlNode.kind === HtmlNodeKind.NODE) {
        htmlNode.children = parseHtmlNodes(p5Node.childNodes || [], htmlNode, context);
    }
    htmlNode.attributes = parseHtmlNodeAttrs(p5Node, __assign({}, context, { htmlNode: htmlNode }));
    return htmlNode;
}
/**
 * Returns if this node is self-closed.
 * @param p5Node
 * @param context
 */
function isSelfClosed(p5Node, context) {
    var isEmpty = p5Node.childNodes == null || p5Node.childNodes.length === 0;
    var isSelfClosed = getSourceLocation(p5Node).startTag.endOffset === getSourceLocation(p5Node).endOffset;
    return isEmpty && isSelfClosed;
}
/**
 * Creates source code location from a p5Node.
 * @param p5Node
 * @param context
 */
function makeHtmlNodeLocation(p5Node, context) {
    var loc = getSourceLocation(p5Node);
    return {
        start: loc.startOffset,
        end: loc.endOffset,
        name: {
            start: loc.startTag.startOffset + 1,
            end: loc.startTag.startOffset + 1 + p5Node.tagName.length
        },
        startTag: {
            start: loc.startTag.startOffset,
            end: loc.startTag.endOffset
        },
        endTag: loc.endTag == null
            ? undefined
            : {
                start: loc.endTag.startOffset,
                end: loc.endTag.endOffset
            }
    };
}
function parseHtmlNodeBase(htmlNodeBase) {
    if (htmlNodeBase.tagName === "style") {
        return __assign({ kind: HtmlNodeKind.STYLE, children: [] }, htmlNodeBase);
    }
    else if (htmlNodeBase.tagName === "svg") {
        // Ignore children of "svg" for now
        return __assign({ kind: HtmlNodeKind.SVG, children: [] }, htmlNodeBase);
    }
    return __assign({ kind: HtmlNodeKind.NODE }, htmlNodeBase);
    /*if (component != null) {
     return {
     ...htmlNodeBase,
     kind: HtmlNodeKind.COMPONENT,
     component
     };
     }

     if (isBuiltInTag(htmlNodeBase.tagName)) {
     // For now: opt out of svg and style children tags
     // TODO: Handle svg and style tags
     const isBlacklisted = ["svg", "style"].includes(htmlNodeBase.tagName);

     return {
     ...htmlNodeBase,
     kind: HtmlNodeKind.BUILT_IN,
     children: isBlacklisted ? [] : htmlNodeBase.children
     };
     }*/
    /*return {
     kind: HtmlNodeKind.UNKNOWN,
     ...htmlNodeBase
     };*/
}

function parseHtmlDocument(node) {
    var virtualDocument = new VirtualAstHtmlDocument(node);
    var html = virtualDocument.text;
    var htmlAst = parseHtml(html);
    var context = {
        html: html,
        getPartsAtOffsetRange: function (range) {
            return virtualDocument.getPartsAtOffsetRange(range);
        }
    };
    var childNodes = parseHtmlNodes(htmlAst.childNodes, undefined, context);
    return new HtmlDocument(virtualDocument, childNodes);
}

function parseDocumentsInSourceFile(sourceFile, options, position) {
    // Parse html tags in the relevant source file
    var templateTags = __spread(options.cssTags, options.htmlTags);
    var taggedTemplates = findTaggedTemplates(sourceFile, templateTags, position);
    var result = undefined;
    if (taggedTemplates == null) {
        return undefined;
    }
    else if (Array.isArray(taggedTemplates)) {
        result = taggedTemplates.map(function (t) { return taggedTemplateToDocument(t, options); });
    }
    else {
        result = taggedTemplateToDocument(taggedTemplates, options);
    }
    if (result == null)
        return undefined;
    if (Array.isArray(result)) {
        return flatten(result.map(function (document) { return __spread([document], (unpackHtmlDocument(document, position) || [])); }));
    }
    else {
        var nestedDocuments = unpackHtmlDocument(result, position);
        if (position != null && nestedDocuments != null) {
            return nestedDocuments;
        }
    }
    return result;
}
function taggedTemplateToDocument(taggedTemplate, _a) {
    var cssTags = _a.cssTags;
    var tag = taggedTemplate.tag.getText();
    if (cssTags.includes(tag)) {
        return new CssDocument(new VirtualAstCssDocument(taggedTemplate));
    }
    else {
        return parseHtmlDocument(taggedTemplate);
    }
}
function unpackHtmlDocument(textDocument, position) {
    var e_1, _a;
    var documents = [];
    if (textDocument instanceof HtmlDocument) {
        try {
            for (var _b = __values(textDocument.rootNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rootNode = _c.value;
                if (rootNode.kind === HtmlNodeKind.STYLE && rootNode.location.endTag != null) {
                    if (position == null) {
                        var nestedDocument = styleHtmlNodeToCssDocument(textDocument, rootNode);
                        if (nestedDocument != null) {
                            documents.push(nestedDocument);
                        }
                    }
                    else if (intersects(textDocument.virtualDocument.scPositionToOffset(position), {
                        start: rootNode.location.startTag.end,
                        end: rootNode.location.endTag.start
                    })) {
                        return styleHtmlNodeToCssDocument(textDocument, rootNode);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    if (position != null)
        return undefined;
    return documents;
}
function styleHtmlNodeToCssDocument(htmlDocument, styleNode) {
    if (styleNode.location.endTag == null)
        return undefined;
    var cssDocumentParts = htmlDocument.virtualDocument.getPartsAtOffsetRange({
        start: styleNode.location.startTag.end,
        end: styleNode.location.endTag.start
    });
    var cssVirtualDocument = new VirtualAstCssDocument(cssDocumentParts, {
        start: htmlDocument.virtualDocument.offsetToSCPosition(styleNode.location.startTag.end),
        end: htmlDocument.virtualDocument.offsetToSCPosition(styleNode.location.endTag.start)
    }, htmlDocument.virtualDocument.fileName);
    return new CssDocument(cssVirtualDocument);
}

var DefaultAnalyzerDocumentStore = /** @class */ (function () {
    function DefaultAnalyzerDocumentStore() {
    }
    DefaultAnalyzerDocumentStore.prototype.getDocumentAtPosition = function (sourceFile, position, options) {
        return parseDocumentsInSourceFile(sourceFile, {
            htmlTags: options.htmlTemplateTags,
            cssTags: options.cssTemplateTags
        }, position);
    };
    DefaultAnalyzerDocumentStore.prototype.getDocumentsInFile = function (sourceFile, config) {
        return parseDocumentsInSourceFile(sourceFile, {
            htmlTags: config.htmlTemplateTags,
            cssTags: config.cssTemplateTags
        });
    };
    return DefaultAnalyzerDocumentStore;
}());

var HtmlDataSource = /** @class */ (function () {
    function HtmlDataSource() {
        this._globalTags = new Map();
        this._globalAttributes = new Map();
        this._globalEvents = new Map();
    }
    Object.defineProperty(HtmlDataSource.prototype, "globalTags", {
        get: function () {
            return this._globalTags;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HtmlDataSource.prototype, "globalAttributes", {
        get: function () {
            return this._globalAttributes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HtmlDataSource.prototype, "globalEvents", {
        get: function () {
            return this._globalEvents;
        },
        enumerable: true,
        configurable: true
    });
    HtmlDataSource.prototype.absorbCollection = function (collection) {
        var _this = this;
        if (collection.tags != null) {
            // For now, lowercase all names because "parse5" doesn't distinguish when parsing
            collection.tags.forEach(function (tag) { return _this._globalTags.set(tag.tagName.toLowerCase(), tag); });
        }
        if (collection.attrs != null) {
            // For now, lowercase all names because "parse5" doesn't distinguish when parsing
            collection.attrs.forEach(function (attr) { return _this._globalAttributes.set(attr.name.toLowerCase(), attr); });
        }
        if (collection.events != null) {
            // For now, lowercase all names because "parse5" doesn't distinguish when parsing
            collection.events.forEach(function (evt) { return _this._globalEvents.set(evt.name.toLowerCase(), evt); });
        }
    };
    HtmlDataSource.prototype.forgetCollection = function (_a) {
        var _this = this;
        var tags = _a.tags, events = _a.events, attrs = _a.attrs;
        if (tags != null)
            tags.forEach(function (tagName) { return _this._globalTags.delete(tagName); });
        if (events != null)
            events.forEach(function (tagName) { return _this._globalEvents.delete(tagName); });
        if (attrs != null)
            attrs.forEach(function (tagName) { return _this._globalAttributes.delete(tagName); });
    };
    HtmlDataSource.prototype.getGlobalTag = function (tagName) {
        return this._globalTags.get(tagName);
    };
    HtmlDataSource.prototype.getGlobalAttribute = function (attrName) {
        return this._globalAttributes.get(attrName);
    };
    HtmlDataSource.prototype.getGlobalEvent = function (eventName) {
        return this._globalEvents.get(eventName);
    };
    return HtmlDataSource;
}());

var HtmlDataSourceKind;
(function (HtmlDataSourceKind) {
    HtmlDataSourceKind[HtmlDataSourceKind["DECLARED"] = 0] = "DECLARED";
    HtmlDataSourceKind[HtmlDataSourceKind["USER"] = 1] = "USER";
    HtmlDataSourceKind[HtmlDataSourceKind["BUILD_IN"] = 2] = "BUILD_IN";
})(HtmlDataSourceKind || (HtmlDataSourceKind = {}));
var HtmlDataSourceMerged = /** @class */ (function () {
    function HtmlDataSourceMerged() {
        this.subclassExtensions = new Map();
        this.htmlDataSources = (function () {
            var array = [];
            array[HtmlDataSourceKind.BUILD_IN] = new HtmlDataSource();
            array[HtmlDataSourceKind.USER] = new HtmlDataSource();
            array[HtmlDataSourceKind.DECLARED] = new HtmlDataSource();
            return array;
        })();
        this.combinedHtmlDataSource = new HtmlDataSource();
        this.relatedForTagName = {
            attrs: new Map(),
            events: new Map(),
            slots: new Map(),
            props: new Map()
        };
    }
    Object.defineProperty(HtmlDataSourceMerged.prototype, "globalTags", {
        get: function () {
            return this.combinedHtmlDataSource.globalTags;
        },
        enumerable: true,
        configurable: true
    });
    HtmlDataSourceMerged.prototype.invalidateCache = function (collection) {
        if (collection == null) {
            Object.values(this.relatedForTagName).forEach(function (map) { return map.clear(); });
            return;
        }
        var events = collection.events, attrs = collection.attrs, tags = collection.tags;
        if (tags && tags.length > 0) {
            Object.values(this.relatedForTagName).forEach(function (map) { return tags.forEach(function (tagName) { return map.delete(tagName); }); });
        }
        if (attrs && attrs.length > 0) {
            this.relatedForTagName.attrs.clear();
        }
        if (events && events.length > 0) {
            this.relatedForTagName.events.clear();
        }
    };
    HtmlDataSourceMerged.prototype.mergeDataSourcesAndInvalidate = function (collection) {
        var e_1, _a, e_2, _b, e_3, _c;
        var tags = collection.tags, attrs = collection.attrs, events = collection.events;
        if (tags != null) {
            var _loop_1 = function (tagName) {
                var allTags = iterableDefined(this_1.htmlDataSources.map(function (r) { return r.getGlobalTag(tagName); }));
                if (allTags.length > 0) {
                    var mergedTags = allTags.length === 1 ? allTags : mergeHtmlTags(allTags);
                    this_1.combinedHtmlDataSource.absorbCollection({ tags: mergedTags });
                }
            };
            var this_1 = this;
            try {
                for (var tags_1 = __values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {
                    var tagName = tags_1_1.value;
                    _loop_1(tagName);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (attrs != null) {
            var _loop_2 = function (attrName) {
                var allAttrs = iterableDefined(this_2.htmlDataSources.map(function (r) { return r.getGlobalAttribute(attrName); }));
                if (allAttrs.length > 0) {
                    var mergedAttrs = allAttrs.length === 1 ? allAttrs : mergeHtmlAttrs(allAttrs);
                    this_2.combinedHtmlDataSource.absorbCollection({ attrs: mergedAttrs });
                }
            };
            var this_2 = this;
            try {
                for (var attrs_1 = __values(attrs), attrs_1_1 = attrs_1.next(); !attrs_1_1.done; attrs_1_1 = attrs_1.next()) {
                    var attrName = attrs_1_1.value;
                    _loop_2(attrName);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (attrs_1_1 && !attrs_1_1.done && (_b = attrs_1.return)) _b.call(attrs_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (events != null) {
            var _loop_3 = function (eventName) {
                var allEvents = iterableDefined(this_3.htmlDataSources.map(function (r) { return r.getGlobalEvent(eventName); }));
                if (allEvents.length > 0) {
                    var mergedEvents = allEvents.length === 1 ? allEvents : mergeHtmlEvents(allEvents);
                    this_3.combinedHtmlDataSource.absorbCollection({ events: mergedEvents });
                }
            };
            var this_3 = this;
            try {
                for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
                    var eventName = events_1_1.value;
                    _loop_3(eventName);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (events_1_1 && !events_1_1.done && (_c = events_1.return)) _c.call(events_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        this.invalidateCache(collection);
    };
    HtmlDataSourceMerged.prototype.forgetCollection = function (collection, dataSource) {
        if (dataSource == null) {
            this.htmlDataSources.forEach(function (ds) { return ds.forgetCollection(collection); });
        }
        else {
            this.htmlDataSources[dataSource].forgetCollection(collection);
        }
        this.combinedHtmlDataSource.forgetCollection(collection);
        this.mergeDataSourcesAndInvalidate(collection);
    };
    HtmlDataSourceMerged.prototype.absorbCollection = function (collection, register) {
        this.htmlDataSources[register].absorbCollection(collection);
        this.mergeDataSourcesAndInvalidate({
            tags: collection.tags.map(function (t) { return t.tagName; }),
            events: collection.events.map(function (t) { return t.name; }),
            attrs: collection.attrs.map(function (t) { return t.name; })
        });
    };
    HtmlDataSourceMerged.prototype.getHtmlTag = function (tagName) {
        return this.combinedHtmlDataSource.getGlobalTag(tagName);
    };
    HtmlDataSourceMerged.prototype.absorbSubclassExtension = function (name, extension) {
        this.subclassExtensions.set(name, extension);
    };
    HtmlDataSourceMerged.prototype.getSubclassExtensions = function (tagName) {
        // Right now, always return "HTMLElement" subclass extension
        var extension = this.subclassExtensions.get("HTMLElement");
        return extension != null ? [extension] : [];
    };
    HtmlDataSourceMerged.prototype.getAllAttributesForTag = function (tagName) {
        if (!this.relatedForTagName.attrs.has(tagName)) {
            this.relatedForTagName.attrs.set(tagName, mergeRelatedMembers(this.iterateAllAttributesForNode(tagName)));
        }
        return this.relatedForTagName.attrs.get(tagName);
    };
    HtmlDataSourceMerged.prototype.getAllPropertiesForTag = function (tagName) {
        if (!this.relatedForTagName.props.has(tagName)) {
            this.relatedForTagName.props.set(tagName, mergeRelatedMembers(this.iterateAllPropertiesForNode(tagName)));
        }
        return this.relatedForTagName.props.get(tagName);
    };
    HtmlDataSourceMerged.prototype.getAllEventsForTag = function (tagName) {
        if (!this.relatedForTagName.events.has(tagName)) {
            this.relatedForTagName.events.set(tagName, mergeRelatedEvents(this.iterateAllEventsForNode(tagName)));
        }
        return this.relatedForTagName.events.get(tagName);
    };
    HtmlDataSourceMerged.prototype.getAllSlotForTag = function (tagName) {
        if (!this.relatedForTagName.slots.has(tagName)) {
            this.relatedForTagName.slots.set(tagName, mergeRelatedSlots(this.iterateAllSlotsForNode(tagName)));
        }
        return this.relatedForTagName.slots.get(tagName);
    };
    HtmlDataSourceMerged.prototype.iterateGlobalAttributes = function () {
        return this.combinedHtmlDataSource.globalAttributes.values();
    };
    HtmlDataSourceMerged.prototype.iterateGlobalEvents = function () {
        return this.combinedHtmlDataSource.globalEvents.values();
    };
    HtmlDataSourceMerged.prototype.iterateAllPropertiesForNode = function (tagName) {
        var htmlTag, extensions, extensions_1, extensions_1_1, extTag, e_4_1;
        var e_4, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    htmlTag = this.getHtmlTag(tagName);
                    if (!(htmlTag != null)) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(htmlTag.properties)];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    extensions = this.getSubclassExtensions(tagName);
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 8, 9, 10]);
                    extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next();
                    _b.label = 4;
                case 4:
                    if (!!extensions_1_1.done) return [3 /*break*/, 7];
                    extTag = extensions_1_1.value;
                    return [5 /*yield**/, __values(extTag.properties)];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6:
                    extensions_1_1 = extensions_1.next();
                    return [3 /*break*/, 4];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_4_1 = _b.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/];
            }
        });
    };
    HtmlDataSourceMerged.prototype.iterateAllEventsForNode = function (tagName) {
        var htmlTag, extensions, extensions_2, extensions_2_1, extTag, e_5_1, _a, _b, tag, e_6_1, eventNameSet, _c, _d, tag, _e, _f, evt, e_7_1, e_8_1, _g, _h, evt, e_9_1;
        var e_5, _j, e_6, _k, e_8, _l, e_7, _m, e_9, _o;
        return __generator(this, function (_p) {
            switch (_p.label) {
                case 0:
                    htmlTag = this.getHtmlTag(tagName);
                    if (!(htmlTag != null)) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(htmlTag.events)];
                case 1:
                    _p.sent();
                    _p.label = 2;
                case 2:
                    extensions = this.getSubclassExtensions(tagName);
                    _p.label = 3;
                case 3:
                    _p.trys.push([3, 8, 9, 10]);
                    extensions_2 = __values(extensions), extensions_2_1 = extensions_2.next();
                    _p.label = 4;
                case 4:
                    if (!!extensions_2_1.done) return [3 /*break*/, 7];
                    extTag = extensions_2_1.value;
                    return [5 /*yield**/, __values(extTag.events)];
                case 5:
                    _p.sent();
                    _p.label = 6;
                case 6:
                    extensions_2_1 = extensions_2.next();
                    return [3 /*break*/, 4];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_5_1 = _p.sent();
                    e_5 = { error: e_5_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (extensions_2_1 && !extensions_2_1.done && (_j = extensions_2.return)) _j.call(extensions_2);
                    }
                    finally { if (e_5) throw e_5.error; }
                    return [7 /*endfinally*/];
                case 10:
                    if (!(htmlTag == null || htmlTag.events.length === 0)) return [3 /*break*/, 20];
                    _p.label = 11;
                case 11:
                    _p.trys.push([11, 16, 17, 18]);
                    _a = __values(this.globalTags.values()), _b = _a.next();
                    _p.label = 12;
                case 12:
                    if (!!_b.done) return [3 /*break*/, 15];
                    tag = _b.value;
                    if (!(tag.tagName !== tagName)) return [3 /*break*/, 14];
                    return [5 /*yield**/, __values(tag.events)];
                case 13:
                    _p.sent();
                    _p.label = 14;
                case 14:
                    _b = _a.next();
                    return [3 /*break*/, 12];
                case 15: return [3 /*break*/, 18];
                case 16:
                    e_6_1 = _p.sent();
                    e_6 = { error: e_6_1 };
                    return [3 /*break*/, 18];
                case 17:
                    try {
                        if (_b && !_b.done && (_k = _a.return)) _k.call(_a);
                    }
                    finally { if (e_6) throw e_6.error; }
                    return [7 /*endfinally*/];
                case 18: 
                // Global events
                return [5 /*yield**/, __values(this.iterateGlobalEvents())];
                case 19:
                    // Global events
                    _p.sent();
                    return [3 /*break*/, 41];
                case 20:
                    eventNameSet = new Set(htmlTag.events.map(function (e) { return e.name; }));
                    _p.label = 21;
                case 21:
                    _p.trys.push([21, 32, 33, 34]);
                    _c = __values(this.globalTags.values()), _d = _c.next();
                    _p.label = 22;
                case 22:
                    if (!!_d.done) return [3 /*break*/, 31];
                    tag = _d.value;
                    if (!(tag.tagName !== tagName)) return [3 /*break*/, 30];
                    _p.label = 23;
                case 23:
                    _p.trys.push([23, 28, 29, 30]);
                    _e = (e_7 = void 0, __values(tag.events)), _f = _e.next();
                    _p.label = 24;
                case 24:
                    if (!!_f.done) return [3 /*break*/, 27];
                    evt = _f.value;
                    if (!!eventNameSet.has(evt.name)) return [3 /*break*/, 26];
                    return [4 /*yield*/, evt];
                case 25:
                    _p.sent();
                    _p.label = 26;
                case 26:
                    _f = _e.next();
                    return [3 /*break*/, 24];
                case 27: return [3 /*break*/, 30];
                case 28:
                    e_7_1 = _p.sent();
                    e_7 = { error: e_7_1 };
                    return [3 /*break*/, 30];
                case 29:
                    try {
                        if (_f && !_f.done && (_m = _e.return)) _m.call(_e);
                    }
                    finally { if (e_7) throw e_7.error; }
                    return [7 /*endfinally*/];
                case 30:
                    _d = _c.next();
                    return [3 /*break*/, 22];
                case 31: return [3 /*break*/, 34];
                case 32:
                    e_8_1 = _p.sent();
                    e_8 = { error: e_8_1 };
                    return [3 /*break*/, 34];
                case 33:
                    try {
                        if (_d && !_d.done && (_l = _c.return)) _l.call(_c);
                    }
                    finally { if (e_8) throw e_8.error; }
                    return [7 /*endfinally*/];
                case 34:
                    _p.trys.push([34, 39, 40, 41]);
                    _g = __values(this.iterateGlobalEvents()), _h = _g.next();
                    _p.label = 35;
                case 35:
                    if (!!_h.done) return [3 /*break*/, 38];
                    evt = _h.value;
                    if (!!eventNameSet.has(evt.name)) return [3 /*break*/, 37];
                    return [4 /*yield*/, evt];
                case 36:
                    _p.sent();
                    _p.label = 37;
                case 37:
                    _h = _g.next();
                    return [3 /*break*/, 35];
                case 38: return [3 /*break*/, 41];
                case 39:
                    e_9_1 = _p.sent();
                    e_9 = { error: e_9_1 };
                    return [3 /*break*/, 41];
                case 40:
                    try {
                        if (_h && !_h.done && (_o = _g.return)) _o.call(_g);
                    }
                    finally { if (e_9) throw e_9.error; }
                    return [7 /*endfinally*/];
                case 41: return [2 /*return*/];
            }
        });
    };
    HtmlDataSourceMerged.prototype.iterateAllAttributesForNode = function (tagName) {
        var htmlTag, extensions, extensions_3, extensions_3_1, extTag, e_10_1;
        var e_10, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    htmlTag = this.getHtmlTag(tagName);
                    if (!(htmlTag != null)) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(htmlTag.attributes)];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    extensions = this.getSubclassExtensions(tagName);
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 8, 9, 10]);
                    extensions_3 = __values(extensions), extensions_3_1 = extensions_3.next();
                    _b.label = 4;
                case 4:
                    if (!!extensions_3_1.done) return [3 /*break*/, 7];
                    extTag = extensions_3_1.value;
                    return [5 /*yield**/, __values(extTag.attributes)];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6:
                    extensions_3_1 = extensions_3.next();
                    return [3 /*break*/, 4];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_10_1 = _b.sent();
                    e_10 = { error: e_10_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (extensions_3_1 && !extensions_3_1.done && (_a = extensions_3.return)) _a.call(extensions_3);
                    }
                    finally { if (e_10) throw e_10.error; }
                    return [7 /*endfinally*/];
                case 10: 
                // Global attributes
                return [5 /*yield**/, __values(this.iterateGlobalAttributes())];
                case 11:
                    // Global attributes
                    _b.sent();
                    return [2 /*return*/];
            }
        });
    };
    HtmlDataSourceMerged.prototype.iterateAllSlotsForNode = function (tagName) {
        var htmlTag, extensions, extensions_4, extensions_4_1, extTag, e_11_1;
        var e_11, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    htmlTag = this.getHtmlTag(tagName);
                    if (!(htmlTag != null)) return [3 /*break*/, 2];
                    return [5 /*yield**/, __values(htmlTag.slots)];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    extensions = this.getSubclassExtensions(tagName);
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 8, 9, 10]);
                    extensions_4 = __values(extensions), extensions_4_1 = extensions_4.next();
                    _b.label = 4;
                case 4:
                    if (!!extensions_4_1.done) return [3 /*break*/, 7];
                    extTag = extensions_4_1.value;
                    return [5 /*yield**/, __values(extTag.slots)];
                case 5:
                    _b.sent();
                    _b.label = 6;
                case 6:
                    extensions_4_1 = extensions_4.next();
                    return [3 /*break*/, 4];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_11_1 = _b.sent();
                    e_11 = { error: e_11_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (extensions_4_1 && !extensions_4_1.done && (_a = extensions_4.return)) _a.call(extensions_4);
                    }
                    finally { if (e_11) throw e_11.error; }
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/];
            }
        });
    };
    return HtmlDataSourceMerged;
}());
function mergeRelatedMembers(attrs) {
    var e_12, _a;
    var mergedMembers = new Map();
    var _loop_4 = function (attr) {
        // For now, lowercase all names because "parse5" doesn't distinguish between uppercase and lowercase
        var name_1 = attr.name.toLowerCase();
        var existingAttr = mergedMembers.get(name_1);
        if (existingAttr == null) {
            mergedMembers.set(name_1, attr);
        }
        else {
            var prevType_1 = existingAttr.getType;
            mergedMembers.set(name_1, __assign({}, existingAttr, { description: undefined, required: existingAttr.required && attr.required, builtIn: existingAttr.required && attr.required, fromTagName: existingAttr.fromTagName || attr.fromTagName, getType: lazy(function () { return mergeRelatedTypeToUnion(prevType_1(), attr.getType()); }), related: existingAttr.related == null ? [existingAttr, attr] : __spread(existingAttr.related, [attr]) }));
        }
    };
    try {
        for (var attrs_2 = __values(attrs), attrs_2_1 = attrs_2.next(); !attrs_2_1.done; attrs_2_1 = attrs_2.next()) {
            var attr = attrs_2_1.value;
            _loop_4(attr);
        }
    }
    catch (e_12_1) { e_12 = { error: e_12_1 }; }
    finally {
        try {
            if (attrs_2_1 && !attrs_2_1.done && (_a = attrs_2.return)) _a.call(attrs_2);
        }
        finally { if (e_12) throw e_12.error; }
    }
    return mergedMembers;
}
function mergeRelatedTypeToUnion(typeA, typeB) {
    if (typeA.kind === typeB.kind) {
        switch (typeA.kind) {
            case tsSimpleType.SimpleTypeKind.ANY:
                return typeA;
        }
    }
    switch (typeA.kind) {
        case tsSimpleType.SimpleTypeKind.UNION:
            if (typeB.kind === tsSimpleType.SimpleTypeKind.ANY && typeA.types.find(function (t) { return t.kind === tsSimpleType.SimpleTypeKind.ANY; }) != null) {
                return typeA;
            }
            else {
                return __assign({}, typeA, { types: __spread(typeA.types, [typeB]) });
            }
    }
    return {
        kind: tsSimpleType.SimpleTypeKind.UNION,
        types: [typeA, typeB]
    };
}
function mergeRelatedSlots(slots) {
    var e_13, _a;
    var mergedSlots = new Map();
    try {
        for (var slots_1 = __values(slots), slots_1_1 = slots_1.next(); !slots_1_1.done; slots_1_1 = slots_1.next()) {
            var slot = slots_1_1.value;
            // For now, lowercase all names because "parse5" doesn't distinguish between uppercase and lowercase
            var name_2 = slot.name.toLowerCase();
            mergedSlots.set(name_2, slot);
        }
    }
    catch (e_13_1) { e_13 = { error: e_13_1 }; }
    finally {
        try {
            if (slots_1_1 && !slots_1_1.done && (_a = slots_1.return)) _a.call(slots_1);
        }
        finally { if (e_13) throw e_13.error; }
    }
    return mergedSlots;
}
function mergeRelatedEvents(events) {
    var e_14, _a;
    var mergedAttrs = new Map();
    var _loop_5 = function (event_1) {
        // For now, lowercase all names because "parse5" doesn't distinguish between uppercase and lowercase
        var name_3 = event_1.name.toLowerCase();
        var existingEvent = mergedAttrs.get(name_3);
        if (existingEvent == null) {
            mergedAttrs.set(name_3, event_1);
        }
        else {
            var prevType_2 = existingEvent.getType;
            mergedAttrs.set(name_3, __assign({}, existingEvent, { global: existingEvent.global && event_1.global, description: undefined, getType: lazy(function () { return mergeRelatedTypeToUnion(prevType_2(), event_1.getType()); }), related: existingEvent.related == null ? [existingEvent, event_1] : __spread(existingEvent.related, [event_1]), fromTagName: existingEvent.fromTagName || event_1.fromTagName }));
        }
    };
    try {
        for (var events_2 = __values(events), events_2_1 = events_2.next(); !events_2_1.done; events_2_1 = events_2.next()) {
            var event_1 = events_2_1.value;
            _loop_5(event_1);
        }
    }
    catch (e_14_1) { e_14 = { error: e_14_1 }; }
    finally {
        try {
            if (events_2_1 && !events_2_1.done && (_a = events_2.return)) _a.call(events_2);
        }
        finally { if (e_14) throw e_14.error; }
    }
    return mergedAttrs;
}

var DefaultAnalyzerHtmlStore = /** @class */ (function () {
    function DefaultAnalyzerHtmlStore() {
        this.dataSource = new HtmlDataSourceMerged();
    }
    DefaultAnalyzerHtmlStore.prototype.absorbSubclassExtension = function (name, extension) {
        this.dataSource.absorbSubclassExtension(name, extension);
    };
    DefaultAnalyzerHtmlStore.prototype.absorbCollection = function (collection, register) {
        this.dataSource.absorbCollection(collection, register);
    };
    DefaultAnalyzerHtmlStore.prototype.forgetCollection = function (collection, register) {
        this.dataSource.forgetCollection(collection, register);
    };
    DefaultAnalyzerHtmlStore.prototype.getHtmlTag = function (htmlNode) {
        return this.dataSource.getHtmlTag(typeof htmlNode === "string" ? htmlNode : htmlNode.tagName);
    };
    DefaultAnalyzerHtmlStore.prototype.getGlobalTags = function () {
        return this.dataSource.globalTags.values();
    };
    DefaultAnalyzerHtmlStore.prototype.getAllAttributesForTag = function (htmlNode) {
        return this.dataSource.getAllAttributesForTag(typeof htmlNode === "string" ? htmlNode : htmlNode.tagName).values();
    };
    DefaultAnalyzerHtmlStore.prototype.getAllPropertiesForTag = function (htmlNode) {
        return this.dataSource.getAllPropertiesForTag(typeof htmlNode === "string" ? htmlNode : htmlNode.tagName).values();
    };
    DefaultAnalyzerHtmlStore.prototype.getAllEventsForTag = function (htmlNode) {
        return this.dataSource.getAllEventsForTag(typeof htmlNode === "string" ? htmlNode : htmlNode.tagName).values();
    };
    DefaultAnalyzerHtmlStore.prototype.getAllSlotsForTag = function (htmlNode) {
        return this.dataSource.getAllSlotForTag(typeof htmlNode === "string" ? htmlNode : htmlNode.tagName).values();
    };
    DefaultAnalyzerHtmlStore.prototype.getHtmlAttrTarget = function (htmlNodeAttr) {
        var name = htmlNodeAttr.name.toLowerCase();
        switch (htmlNodeAttr.kind) {
            case HtmlNodeAttrKind.EVENT_LISTENER:
                return this.dataSource.getAllEventsForTag(htmlNodeAttr.htmlNode.tagName).get(name);
            case HtmlNodeAttrKind.BOOLEAN_ATTRIBUTE:
            case HtmlNodeAttrKind.ATTRIBUTE:
                return this.dataSource.getAllAttributesForTag(htmlNodeAttr.htmlNode.tagName).get(name);
            case HtmlNodeAttrKind.PROPERTY:
                return this.dataSource.getAllPropertiesForTag(htmlNodeAttr.htmlNode.tagName).get(name);
        }
    };
    return DefaultAnalyzerHtmlStore;
}());

/**
 * Yields source files that have changed since last time this function was called.
 */
function changedSourceFileIterator() {
    var sourceFileCache = new WeakSet();
    var iterator = function (sourceFiles) {
        var sourceFiles_1, sourceFiles_1_1, sourceFile, e_1_1;
        var e_1, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 5, 6, 7]);
                    sourceFiles_1 = __values(sourceFiles), sourceFiles_1_1 = sourceFiles_1.next();
                    _b.label = 1;
                case 1:
                    if (!!sourceFiles_1_1.done) return [3 /*break*/, 4];
                    sourceFile = sourceFiles_1_1.value;
                    if (!!sourceFileCache.has(sourceFile)) return [3 /*break*/, 3];
                    return [4 /*yield*/, sourceFile];
                case 2:
                    _b.sent();
                    sourceFileCache.add(sourceFile);
                    _b.label = 3;
                case 3:
                    sourceFiles_1_1 = sourceFiles_1.next();
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 7];
                case 5:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 7];
                case 6:
                    try {
                        if (sourceFiles_1_1 && !sourceFiles_1_1.done && (_a = sourceFiles_1.return)) _a.call(sourceFiles_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    };
    return Object.assign(iterator, {
        invalidate: function (sourceFile) {
            sourceFileCache.delete(sourceFile);
        }
    });
}

var rules = [
    rule$2,
    rule$5,
    rule$8,
    rule$6,
    rule$7,
    rule$1,
    rule,
    rule$4,
    rule$3,
    rule$9,
    rule$a,
    rule$b,
    rule$c,
    rule$d,
    rule$e
];
var DefaultLitAnalyzerContext = /** @class */ (function () {
    function DefaultLitAnalyzerContext(handler) {
        this.handler = handler;
        this.componentSourceFileIterator = changedSourceFileIterator();
        this.hasAnalyzedSubclassExtensions = false;
        this._config = makeConfig({});
        this.htmlStore = new DefaultAnalyzerHtmlStore();
        this.dependencyStore = new DefaultAnalyzerDependencyStore();
        this.documentStore = new DefaultAnalyzerDocumentStore();
        this.definitionStore = new DefaultAnalyzerDefinitionStore();
        this.logger = new DefaultLitAnalyzerLogger();
        // Add all HTML5 tags and attributes
        var builtInCollection = getBuiltInHtmlCollection();
        this.htmlStore.absorbCollection(builtInCollection, HtmlDataSourceKind.BUILD_IN);
    }
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "ts", {
        get: function () {
            return this.handler.ts || tsModuleType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "program", {
        get: function () {
            return this.handler.getProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "project", {
        get: function () {
            return this.handler.getProject != null ? this.handler.getProject() : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "rules", {
        get: function () {
            return rules;
        },
        enumerable: true,
        configurable: true
    });
    DefaultLitAnalyzerContext.prototype.updateConfig = function (config) {
        this._config = config;
        this.logger.level = (function () {
            switch (config.logging) {
                case "off":
                    return exports.LitAnalyzerLoggerLevel.OFF;
                case "error":
                    return exports.LitAnalyzerLoggerLevel.ERROR;
                case "warn":
                    return exports.LitAnalyzerLoggerLevel.WARN;
                case "debug":
                    return exports.LitAnalyzerLoggerLevel.DEBUG;
                case "verbose":
                    return exports.LitAnalyzerLoggerLevel.VERBOSE;
                default:
                    return exports.LitAnalyzerLoggerLevel.OFF;
            }
        })();
        // Add user configured HTML5 collection
        var collection = getUserConfigHtmlCollection(config);
        this.htmlStore.absorbCollection(collection, HtmlDataSourceKind.USER);
    };
    DefaultLitAnalyzerContext.prototype.updateDependencies = function (file) {
        this.findDependenciesInFile(file);
    };
    DefaultLitAnalyzerContext.prototype.updateComponents = function (file) {
        this.findInvalidatedComponents();
        this.analyzeSubclassExtensions();
    };
    Object.defineProperty(DefaultLitAnalyzerContext.prototype, "checker", {
        get: function () {
            return this.program.getTypeChecker();
        },
        enumerable: true,
        configurable: true
    });
    DefaultLitAnalyzerContext.prototype.findInvalidatedComponents = function () {
        var e_1, _a, e_2, _b;
        var _this = this;
        var seenFiles = new Set();
        var invalidatedFiles = new Set();
        try {
            // Find components in all changed files
            for (var _c = __values(this.componentSourceFileIterator(this.program.getSourceFiles())), _d = _c.next(); !_d.done; _d = _c.next()) {
                var sourceFile = _d.value;
                seenFiles.add(sourceFile);
                this.definitionStore.getDefinitionsWithDeclarationInFile(sourceFile).forEach(function (definition) {
                    var sf = _this.program.getSourceFile(definition.node.getSourceFile().fileName);
                    if (sf != null) {
                        invalidatedFiles.add(sf);
                    }
                });
                this.findComponentsInFile(sourceFile);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var invalidatedFiles_1 = __values(invalidatedFiles), invalidatedFiles_1_1 = invalidatedFiles_1.next(); !invalidatedFiles_1_1.done; invalidatedFiles_1_1 = invalidatedFiles_1.next()) {
                var sourceFile = invalidatedFiles_1_1.value;
                if (!seenFiles.has(sourceFile)) {
                    seenFiles.add(sourceFile);
                    this.findComponentsInFile(sourceFile);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (invalidatedFiles_1_1 && !invalidatedFiles_1_1.done && (_b = invalidatedFiles_1.return)) _b.call(invalidatedFiles_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.logger.verbose("Analyzed " + seenFiles.size + " files (" + invalidatedFiles.size + " invalidated)");
    };
    DefaultLitAnalyzerContext.prototype.findComponentsInFile = function (sourceFile) {
        var analyzeResult = webComponentAnalyzer.analyzeComponents(sourceFile, {
            checker: this.checker,
            ts: this.ts,
            config: { diagnostics: true, analyzeLibDom: true, excludedDeclarationNames: ["HTMLElement"] }
        });
        // Forget
        var existingResult = this.definitionStore.getAnalysisResultForFile(sourceFile);
        if (existingResult != null) {
            this.htmlStore.forgetCollection({
                tags: existingResult.componentDefinitions.map(function (d) { return d.tagName; }),
                events: existingResult.globalEvents.map(function (e) { return e.name; }),
                attrs: []
            }, HtmlDataSourceKind.DECLARED);
            this.definitionStore.forgetAnalysisResultForFile(sourceFile);
        }
        // Absorb
        this.definitionStore.absorbAnalysisResult(sourceFile, analyzeResult);
        var htmlCollection = convertAnalyzeResultToHtmlCollection(analyzeResult, {
            checker: this.checker,
            addDeclarationPropertiesAsAttributes: true
        });
        this.htmlStore.absorbCollection(htmlCollection, HtmlDataSourceKind.DECLARED);
    };
    DefaultLitAnalyzerContext.prototype.analyzeSubclassExtensions = function () {
        if (this.hasAnalyzedSubclassExtensions)
            return;
        var result = webComponentAnalyzer.analyzeLibDomHtmlElement(this.program, this.ts);
        if (result != null) {
            var extension = convertComponentDeclarationToHtmlTag(result, undefined, { checker: this.checker });
            this.htmlStore.absorbSubclassExtension("HTMLElement", extension);
            this.hasAnalyzedSubclassExtensions = true;
        }
    };
    DefaultLitAnalyzerContext.prototype.findDependenciesInFile = function (file) {
        if (isRuleDisabled(this.config, "no-missing-import"))
            return;
        // Build a graph of component dependencies
        var res = parseDependencies(file, this);
        this.dependencyStore.importedComponentDefinitionsInFile.set(file.fileName, res);
    };
    return DefaultLitAnalyzerContext;
}());

/**
 * The most general version of compiler options.
 */
var defaultOptions = {
    noEmitOnError: false,
    allowJs: true,
    experimentalDecorators: true,
    target: tsModuleType.ScriptTarget.Latest,
    downlevelIteration: true,
    module: tsModuleType.ModuleKind.ESNext,
    //module: ModuleKind.CommonJS,
    //lib: ["esnext", "dom"],
    strictNullChecks: true,
    moduleResolution: tsModuleType.ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    noEmit: true,
    allowSyntheticDefaultImports: true,
    allowUnreachableCode: true,
    allowUnusedLabels: true,
    skipLibCheck: true,
    isolatedModules: true
};
/**
 * Compiles an array of file paths using typescript.
 * @param filePaths
 */
function compileTypescript(filePaths) {
    //const options2 = readTsConfig() || defaultOptions;
    var options = defaultOptions;
    filePaths = Array.isArray(filePaths) ? filePaths : [filePaths];
    var program = tsModuleType.createProgram(filePaths, options);
    var diagnostics = tsModuleType.getPreEmitDiagnostics(program);
    var files = program.getSourceFiles().filter(function (sf) { return filePaths.includes(sf.fileName); });
    return { diagnostics: diagnostics, program: program, files: files };
}
function readTsConfig(tsConfigPath) {
    tsConfigPath = tsConfigPath || path.join(process.cwd(), "tsconfig.json");
    if (fs.existsSync(tsConfigPath)) {
        try {
            var content = fs.readFileSync(tsConfigPath, "utf8");
            var config = JSON.parse(content);
            return config.compilerOptions;
        }
        catch (_a) {
            return undefined;
        }
    }
    return undefined;
}
function readTsLitPluginConfig(options) {
    options = options || readTsConfig();
    if (options != null && "plugins" in options) {
        var plugins = options.plugins;
        var tsLitPluginOptions = plugins.find(function (plugin) { return plugin.name === "ts-lit-plugin"; });
        if (tsLitPluginOptions != null) {
            return makeConfig(tsLitPluginOptions);
        }
    }
    return undefined;
}

//const IGNORE_GLOBS = ["!**/node_modules/**", "!**/web_modules/**"];
var IGNORE_GLOBS = [];
var DEFAULT_DIR_GLOB = "**/*.{js,jsx,ts,tsx}";
/**
 * Parses and analyses all globs and calls some callbacks while doing it.
 * @param globs
 * @param config
 * @param context
 */
function analyzeGlobs(globs, config, context) {
    if (context === void 0) { context = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var filePaths, _a, program, files, diagnostics, files_1, files_1_1, file, result;
        var e_1, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, expandGlobs(globs)];
                case 1:
                    filePaths = _c.sent();
                    if (config.debug) {
                        // eslint-disable-next-line no-console
                        console.log(filePaths);
                    }
                    // Callbacks
                    if (context.didExpandGlobs != null)
                        context.didExpandGlobs(filePaths);
                    if (context.willAnalyzeFiles != null)
                        context.willAnalyzeFiles(filePaths);
                    _a = compileTypescript(filePaths), program = _a.program, files = _a.files, diagnostics = _a.diagnostics;
                    if (diagnostics.length > 0) {
                        if (config.debug) {
                            // eslint-disable-next-line no-console
                            console.dir(diagnostics.map(function (d) { return ((d.file && d.file.fileName) || "unknown") + ": " + tsModuleType.flattenDiagnosticMessageText(d.messageText, "\n"); }));
                        }
                        if (context.didFindTypescriptDiagnostics != null)
                            context.didFindTypescriptDiagnostics(diagnostics, { program: program });
                    }
                    try {
                        // Analyze each file
                        for (files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                            file = files_1_1.value;
                            // Analyze
                            if (context.analyzeSourceFile != null) {
                                result = context.analyzeSourceFile(file, { program: program });
                                if (result === false)
                                    break;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (files_1_1 && !files_1_1.done && (_b = files_1.return)) _b.call(files_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    return [2 /*return*/, { program: program, diagnostics: diagnostics, files: files }];
            }
        });
    });
}
/**
 * Expands the globs.
 * @param globs
 */
function expandGlobs(globs) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    globs = Array.isArray(globs) ? globs : [globs];
                    _a = flatten;
                    return [4 /*yield*/, Promise.all(globs.map(function (g) {
                            try {
                                // Test if the glob points to a directory.
                                // If so, return the result of a new glob that searches for files in the directory excluding node_modules..
                                var dirExists = fs.existsSync(g) && fs.lstatSync(g).isDirectory();
                                if (dirExists) {
                                    return fastGlob.async(__spread(IGNORE_GLOBS, [path.join(g, DEFAULT_DIR_GLOB)]), {
                                        absolute: true,
                                        followSymlinkedDirectories: false
                                    });
                                }
                            }
                            catch (_a) {
                                // Do nothing
                            }
                            // Return the result of globbing
                            return fastGlob.async(__spread(IGNORE_GLOBS, [g]), {
                                absolute: true,
                                followSymlinkedDirectories: false
                            });
                        }))];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}

function generalReport(stats) {
    function numberStatText(n, text) {
        return n + " " + text + (n === 1 ? "" : "s");
    }
    if (stats.diagnostics > 0) {
        return "\n" + chalk.red("  \u2716 " + numberStatText(stats.diagnostics, "problem") + " in " + numberStatText(stats.filesWithProblems, "file") + " (" + numberStatText(stats.errors, "error") + ", " + numberStatText(stats.warnings, "warning") + ")");
    }
    else {
        return "\n" + chalk.green("  \u2713 Found 0 problems in " + numberStatText(stats.totalFiles, "file"));
    }
}
function relativeFileName(fileName) {
    return fileName.replace(process.cwd(), ".");
}
function markText(text, range, colorFunction) {
    if (colorFunction === void 0) { colorFunction = chalk.bgRedBright; }
    return (text.substring(0, range.start) + chalk.bold(colorFunction(text.substr(range.start, range.length))) + text.substring(range.start + range.length));
}
function textPad(str, _a) {
    var width = _a.width, fill = _a.fill, dir = _a.dir;
    var padding = (fill || " ").repeat(Math.max(0, width - str.length));
    return "" + (dir !== "right" ? padding : "") + str + (dir === "right" ? padding : "");
}
function translateRange(range) {
    if (range.document != null) {
        return {
            start: range.document.virtualDocument.offsetToSCPosition(range.start),
            length: range.end - range.start
        };
    }
    return {
        start: range.start,
        length: range.end - range.start
    };
}

var CodeDiagnosticFormatter = /** @class */ (function () {
    function CodeDiagnosticFormatter() {
    }
    CodeDiagnosticFormatter.prototype.report = function (stats) {
        return generalReport(stats);
    };
    CodeDiagnosticFormatter.prototype.diagnosticTextForFile = function (file, diagnostics) {
        if (diagnostics.length === 0)
            return undefined;
        var diagnosticText = diagnostics.map(function (diagnostic) { return diagnosticTextForFile(file, diagnostic); }).join("\n");
        return "\n" + chalk.underline("" + relativeFileName(file.fileName)) + "\n" + diagnosticText;
    };
    return CodeDiagnosticFormatter;
}());
function diagnosticTextForFile(file, diagnostic) {
    var textSpan = translateRange(diagnostic.location);
    var MAX_LINE_WIDTH = 50;
    var MIN_MESSAGE_PADDING = 10;
    // Get line and character of start position
    var lineContext = file.getLineAndCharacterOfPosition(textSpan.start);
    // Get start and end position of the line
    var linePositionRange = {
        start: file.getPositionOfLineAndCharacter(lineContext.line, 0),
        end: file.getLineEndOfPosition(textSpan.start)
    };
    // Modify the line position range if the width of the line exceeds MAX_LINE_WIDTH
    if (linePositionRange.end - linePositionRange.start > MAX_LINE_WIDTH) {
        // Calculate even padding to both sides
        var padding = Math.max(MIN_MESSAGE_PADDING, Math.round((MAX_LINE_WIDTH - textSpan.length) / 2));
        // Calculate new start and end position without exceeding the line position range
        var start = Math.max(linePositionRange.start, textSpan.start - padding);
        var end = Math.min(linePositionRange.end, textSpan.start + textSpan.length + padding);
        linePositionRange = { start: start, end: end };
    }
    // Get the source file text on the position range
    var lineText = file.getFullText().substring(linePositionRange.start, linePositionRange.end);
    // Highlight the error in the text
    // The highlighting range is offsetted by subtracting the line start position
    var highlightingColorFunction = function (str) { return chalk.black(diagnostic.severity === "error" ? chalk.bgRedBright(str) : chalk.bgYellow(str)); };
    var markedLine = markText(lineText, {
        start: textSpan.start - linePositionRange.start,
        length: textSpan.length
    }, highlightingColorFunction).replace(/^\s*/, " ");
    var block = [
        chalk.bold(diagnostic.message),
        chalk.gray(lineContext.line + 1 + ":") + " " + markedLine,
        diagnostic.source == null ? undefined : chalk.gray("" + diagnostic.source)
    ]
        .filter(function (line) { return line != null; })
        .map(function (line) { return "    " + line; })
        .join("\n");
    return "\n" + block + "\n";
}

var ListDiagnosticFormatter = /** @class */ (function () {
    function ListDiagnosticFormatter() {
    }
    ListDiagnosticFormatter.prototype.report = function (stats) {
        return generalReport(stats);
    };
    ListDiagnosticFormatter.prototype.diagnosticTextForFile = function (file, diagnostics) {
        if (diagnostics.length === 0)
            return undefined;
        return diagnosticTextForFile$1(file, diagnostics);
    };
    return ListDiagnosticFormatter;
}());
function diagnosticTextForFile$1(file, diagnostics) {
    var diagnosticText = diagnostics.map(function (diagnostic) { return litDiagnosticToErrorText(file, diagnostic); }).join("\n");
    return "\n" + chalk.underline("" + relativeFileName(file.fileName)) + "\n" + diagnosticText;
}
// @ts-ignore
function litDiagnosticToErrorText(file, diagnostic) {
    var textSpan = translateRange(diagnostic.location);
    var lineContext = file.getLineAndCharacterOfPosition(textSpan.start);
    var linePart = textPad("" + (lineContext.line + 1), { width: 5 }) + ":" + textPad("" + lineContext.character, {
        width: 4,
        dir: "right"
    });
    var severityPart = "" + textPad(diagnostic.severity === "warning" ? chalk.yellow("warning") : chalk.red("error"), {
        width: 18,
        dir: "right"
    });
    var messagePart = diagnostic.message;
    return linePart + " " + severityPart + " " + messagePart;
}

/**
 * Highlights some text
 * @param text
 */
function markdownHighlight(text) {
    return "`" + text + "`";
}
/**
 * Returns a markdown header with a specific level
 * @param level
 * @param title
 */
function markdownHeader(level, title) {
    return "#".repeat(level) + " " + title;
}
var DEFAULT_MARKDOWN_TABLE_OPTIONS = {
    removeEmptyColumns: true,
    minCellWidth: 3,
    maxCellWidth: 50,
    cellPadding: 1
};
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param options
 */
function markdownTable(rows, options) {
    if (options === void 0) { options = {}; }
    // Constants for pretty printing the markdown tables
    var MIN_CELL_WIDTH = options.minCellWidth || DEFAULT_MARKDOWN_TABLE_OPTIONS.minCellWidth;
    var MAX_CELL_WIDTH = options.maxCellWidth || DEFAULT_MARKDOWN_TABLE_OPTIONS.maxCellWidth;
    var CELL_PADDING = options.cellPadding || DEFAULT_MARKDOWN_TABLE_OPTIONS.cellPadding;
    // Count the number of columns
    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
    if (options.removeEmptyColumns) {
        // Create a boolean array where each entry tells if a column is used or not (excluding the header)
        var emptyColumns_1 = Array(columnCount)
            .fill(false)
            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });
        // Remove unused columns if necessary
        if (emptyColumns_1.includes(true)) {
            // Filter out the unused columns in each row
            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });
            // Adjust the column count
            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
        }
    }
    // Escape all cells in the markdown output
    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });
    // Create a boolean array where each entry corresponds to the preferred column width.
    // This is done by taking the largest width of all cells in each column.
    var columnWidths = Array(columnCount)
        .fill(0)
        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || "").length; }))) + CELL_PADDING * 2); });
    // Build up the table
    return "\n|" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|\n|" + columnWidths.map(function (c) { return "-".repeat(c); }).join("|") + "|\n" + rows
        .slice(1)
        .map(function (r) { return "|" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|"; })
        .join("\n") + "\n";
}
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
function markdownEscapeTableCell(text) {
    return text.replace(/\n/g, "<br />").replace(/\|/g, "\\|");
}
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
function fillWidth(text, width, paddingStart) {
    return " ".repeat(paddingStart) + text + " ".repeat(Math.max(1, width - text.length - paddingStart));
}

var MarkdownDiagnosticFormatter = /** @class */ (function () {
    function MarkdownDiagnosticFormatter() {
    }
    MarkdownDiagnosticFormatter.prototype.report = function (stats) {
        return "\n" + markdownHeader(2, "Summary") + "\n" + markdownTable([
            ["Files analyzed", "Files with problems", "Problems", "Errors", "Warnings"],
            [stats.totalFiles, stats.filesWithProblems, stats.diagnostics, stats.errors, stats.warnings].map(function (v) { return v.toString(); })
        ]);
    };
    MarkdownDiagnosticFormatter.prototype.diagnosticTextForFile = function (file, diagnostics) {
        if (diagnostics.length === 0)
            return undefined;
        return "\n" + markdownHeader(2, "" + relativeFileName(file.fileName)) + "\n" + markdownDiagnosticTable(file, diagnostics);
    };
    return MarkdownDiagnosticFormatter;
}());
function markdownDiagnosticTable(file, diagnostics) {
    var headerRow = ["Line", "Column", "Type", "Rule", "Message"];
    var rows = diagnostics.map(function (diagnostic) {
        var textSpan = translateRange(diagnostic.location);
        var lineContext = file.getLineAndCharacterOfPosition(textSpan.start);
        return [
            (lineContext.line + 1).toString(),
            (lineContext.character + 1).toString(),
            diagnostic.severity === "error" ? markdownHighlight("error") : "warning",
            diagnostic.source || "",
            diagnostic.message
        ];
    });
    return markdownTable(__spread([headerRow], rows), { removeEmptyColumns: true });
}

function printText(text, config) {
    if (config.outFile != null) {
        fs.appendFileSync(config.outFile, text);
    }
    else {
        // eslint-disable-next-line no-console
        console.log(text);
    }
}
function analyzeCommand(globs, config) {
    return __awaiter(this, void 0, void 0, function () {
        var program, context, newConfig, configSeed, analyzer, stats, formatter, statsText;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    program = undefined;
                    context = new DefaultLitAnalyzerContext({
                        getProgram: function () {
                            return program;
                        }
                    });
                    newConfig = readTsLitPluginConfig();
                    // Create a default config
                    if (newConfig == null) {
                        configSeed = {};
                        // Assign "strict" setting from the CLI command (which overwrites tsconfig rules)
                        if (config.strict != null) {
                            configSeed.strict = config.strict;
                        }
                        // Assign "logging" based on "debug" option from the CLI command
                        configSeed.logging = config.debug ? "verbose" : "off";
                        // Make config based on the seed
                        newConfig = makeConfig(configSeed);
                    }
                    // Assign rules from the CLI command (which overwrites tsconfig rules)
                    Object.assign(newConfig.rules, config.rules);
                    // Set the config on the context
                    context.updateConfig(newConfig);
                    // Debug config
                    context.logger.verbose("Lit Analyzer Configuration", newConfig);
                    analyzer = new LitAnalyzer(context);
                    stats = { errors: 0, warnings: 0, filesWithProblems: 0, totalFiles: 0, diagnostics: 0 };
                    formatter = getFormatter(config.format || "code");
                    return [4 /*yield*/, analyzeGlobs(globs, config, {
                            didExpandGlobs: function (filePaths) {
                                if (filePaths.length === 0) {
                                    // eslint-disable-next-line no-console
                                    console.log("\n" + chalk.red("   Couldn't find any files to analyze"));
                                }
                                else {
                                    // eslint-disable-next-line no-console
                                    console.log("Analyzing " + filePaths.length + " files...");
                                }
                            },
                            willAnalyzeFiles: function (filePaths) {
                                // Prepare output file
                                if (config.outFile != null) {
                                    fs.writeFileSync(config.outFile, "");
                                }
                            },
                            analyzeSourceFile: function (file, options) {
                                program = options.program;
                                var diagnostics = analyzer.getDiagnosticsInFile(file);
                                diagnostics = config.quiet ? diagnostics.filter(function (d) { return d.severity === "error"; }) : diagnostics;
                                diagnostics = config.failFast && diagnostics.length > 1 ? [diagnostics[0]] : diagnostics;
                                var fileDiagnosticsText = formatter.diagnosticTextForFile(file, diagnostics, config);
                                if (fileDiagnosticsText != null) {
                                    printText(fileDiagnosticsText, config);
                                }
                                stats.diagnostics += diagnostics.length;
                                stats.totalFiles += 1;
                                if (diagnostics.length > 0) {
                                    stats.errors += diagnostics.filter(function (d) { return d.severity === "error"; }).length;
                                    stats.warnings += diagnostics.filter(function (d) { return d.severity === "warning"; }).length;
                                    stats.filesWithProblems += 1;
                                    if (config.failFast) {
                                        return false;
                                    }
                                }
                            }
                        })];
                case 1:
                    _a.sent();
                    statsText = formatter.report(stats, config);
                    if (statsText != null) {
                        printText(statsText, config);
                    }
                    return [2 /*return*/, stats.diagnostics <= (config.maxWarnings || 0) || config.maxWarnings === -1];
            }
        });
    });
}
function getFormatter(format) {
    switch (format) {
        case "list":
            return new ListDiagnosticFormatter();
        case "code":
            return new CodeDiagnosticFormatter();
        case "markdown":
            return new MarkdownDiagnosticFormatter();
        default:
            throw new Error("Unknown format: '" + format + "'");
    }
}

/**
 * Converts from snake case to camel case
 * @param str
 */
function dashToCamelCase(str) {
    return str.replace(/(-\w)/g, function (m) { return m[1].toUpperCase(); });
}
/**
 * Converts from camel case to snake case
 * @param str
 */
function camelToDashCase(str) {
    return str.replace(/[A-Z]/g, function (m) { return "-" + m.toLowerCase(); });
}

/**
 * Parses CLI arguments.
 * @param args
 */
function parseCliArguments(args) {
    var result = { _: [] };
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        // Parses: "--key", "-k", "--key=value", "--key value"
        if (arg.startsWith("-")) {
            // Parses: "--key=value"
            if (arg.includes("=")) {
                var _a = __read(arg.split("="), 2), key = _a[0], value = _a[1];
                assignValue(result, key, value);
            }
            // Parses: "--key value", "--key", "-k
            else {
                var key = transformKey(arg);
                // Parses: "--key value"
                if (i < args.length - 1) {
                    var value = args[i + 1];
                    if (!value.startsWith("-")) {
                        assignValue(result, key, value);
                        i++;
                        continue;
                    }
                }
                // Parses: "--key", "-k"
                assignValue(result, key, true);
            }
        }
        // Parses: "arg1", "arg2", ...
        else {
            result._.push(arg);
        }
    }
    return result;
}
/**
 * Transform a string to a primitive type.
 * @param value
 */
function transformValue(value) {
    if (typeof value === "boolean") {
        return value;
    }
    else if (!isNaN(Number(value))) {
        return Number(value);
    }
    else if (value === "true" || value === "false") {
        return value === "true";
    }
    return value;
}
/**
 * Transform a key by removing the first "-" characters.
 * @param key
 */
function transformKey(key) {
    return dashToCamelCase(key.replace(/^-*/g, ""));
}
/**
 * Assigns a value on a specific key and transforms the value at the same time.
 * @param obj
 * @param key
 * @param value
 */
function assignValue(obj, key, value) {
    // The key could be "nested.key"
    var keys = transformKey(key).split(".");
    keys.forEach(function (k, i) {
        // Assign the final value
        if (i >= keys.length - 1) {
            obj[k] = transformValue(value);
        }
        // Create nested objects
        else {
            if (!(k in obj)) {
                obj[k] = {};
            }
            obj = obj[k];
        }
    });
}

var DEFAULT_GLOB = "src/**/*.{js,jsx,ts,tsx}";
var DEFAULT_CONFIG = {
    noColor: false,
    quiet: false,
    maxWarnings: 0,
    debug: false,
    help: false,
    failFast: false,
    format: "code",
    strict: false,
    rules: {}
};
/**
 * The main function of the cli.
 */
function cli() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, args, rest, globs, config, success;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = parseCliArguments(process.argv.slice(2)), args = _a._, rest = __rest(_a, ["_"]);
                    globs = args.length > 0 ? args : [DEFAULT_GLOB];
                    config = __assign({}, DEFAULT_CONFIG, rest);
                    if (config.debug) {
                        // eslint-disable-next-line no-console
                        console.log("CLI Config", config);
                    }
                    // Always convert "rules" to "dash case" because "rules" expects it.
                    config.rules = Object.entries(config.rules || {}).reduce(function (acc, _a) {
                        var _b = __read(_a, 2), k = _b[0], v = _b[1];
                        acc[camelToDashCase(k)] = v;
                        return acc;
                    }, {});
                    if (config.help) {
                        // eslint-disable-next-line no-console
                        console.log("\n\n  Usage\n    lit-analyzer [<file|directory|glob>]\n    \n  Options\n    --help                Print this message.\n    --format FORMAT       Specify output format. The possible options are:\n                            o code                Highlight problems in the code (default)\n                            o list                Short and precise list of problems\n                            o markdown            Markdown format\n    --noColor             Print results without color\n    --outFile FILE        Emit all output to a single file\n    --maxWarnings NUMBER  Fail only when the number of warnings is larger than this number\n    --quiet               Report only errors and not warnings\n    --failFast            Exit the process right after the first problem has been found\n    --strict              Enable strict mode. This change the default ruleset.\n    --rules.___ SEVERITY  Enable or disable a rule (example: --rules.no-unknown-tag-name off). \n                          Severity can be: \"off\" | \"warn\" | \"error\". The possible rules are:\n                          o  no-unknown-tag-name\n                          o  no-missing-import\n                          o  no-unclosed-tag\n                          o  no-unknown-attribute\n                          o  no-unknown-property\n                          o  no-unknown-event\n                          o  no-unknown-slot\n                          o  no-invalid-boolean-binding\n                          o  no-expressionless-property-binding\n                          o  no-noncallable-event-binding\n                          o  no-boolean-in-attribute-binding\n                          o  no-complex-attribute-binding\n                          o  no-nullable-attribute-binding\n                          o  no-incompatible-type-binding\n                          o  no-invalid-directive-binding\n                          o  no-incompatible-property-type\n                          o  no-unknown-property-converter\n                          o  no-invalid-attribute-name\n                          o  no-invalid-tag-name\n                          o  no-invalid-css\n    \n  Examples\n    lit-analyzer src\n    lit-analyzer \"src/**/*.{js,ts}\"\n    lit-analyzer my-element.js\n\t\t");
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, analyzeCommand(globs, config)];
                case 1:
                    success = _b.sent();
                    process.exit(success ? 0 : 1);
                    return [2 /*return*/];
            }
        });
    });
}

exports.ALL_RULE_NAMES = ALL_RULE_NAMES;
exports.DIAGNOSTIC_SOURCE = DIAGNOSTIC_SOURCE;
exports.DefaultLitAnalyzerContext = DefaultLitAnalyzerContext;
exports.DefaultLitAnalyzerLogger = DefaultLitAnalyzerLogger;
exports.LIT_HTML_ATTRIBUTE_MODIFIERS = LIT_HTML_ATTRIBUTE_MODIFIERS;
exports.LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER = LIT_HTML_BOOLEAN_ATTRIBUTE_MODIFIER;
exports.LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER = LIT_HTML_EVENT_LISTENER_ATTRIBUTE_MODIFIER;
exports.LIT_HTML_PROP_ATTRIBUTE_MODIFIER = LIT_HTML_PROP_ATTRIBUTE_MODIFIER;
exports.LitAnalyzer = LitAnalyzer;
exports.TS_IGNORE_FLAG = TS_IGNORE_FLAG;
exports.VERSION = VERSION;
exports.cli = cli;
exports.isRuleDisabled = isRuleDisabled;
exports.isRuleEnabled = isRuleEnabled;
exports.litDiagnosticRuleSeverity = litDiagnosticRuleSeverity;
exports.makeConfig = makeConfig;
exports.makeRules = makeRules;
exports.ruleSeverity = ruleSeverity;
