{"/emmet/package.json":"{\n    \"name\": \"emmet\",\n    \"displayName\": \"Emmet\",\n    \"description\": \"%description%\",\n    \"version\": \"1.0.0\",\n    \"publisher\": \"vscode\",\n    \"engines\": {\n        \"vscode\": \"^1.13.0\"\n    },\n    \"icon\": \"images/icon.png\",\n    \"categories\": [\"Other\"],\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/Microsoft/vscode-emmet\"\n    },\n    \"activationEvents\": [\"*\", \"onCommand:emmet.expandAbbreviation\", \"onLanguage:html\", \"onLanguage:css\", \"onLanguage:scss\", \"onLanguage:less\"],\n    \"main\": \"./dist/extension\",\n    \"contributes\": {\n        \"configuration\": {\n            \"type\": \"object\",\n            \"title\": \"Emmet\",\n            \"properties\": {\n                \"emmet.showExpandedAbbreviation\": {\n                    \"type\": [\"string\"],\n                    \"enum\": [\"never\", \"always\", \"inMarkupAndStylesheetFilesOnly\"],\n                    \"default\": \"always\",\n                    \"markdownDescription\": \"%emmetShowExpandedAbbreviation%\"\n                },\n                \"emmet.showAbbreviationSuggestions\": {\n                    \"type\": \"boolean\",\n                    \"default\": true,\n                    \"markdownDescription\": \"%emmetShowAbbreviationSuggestions%\"\n                },\n                \"emmet.includeLanguages\": {\n                    \"type\": \"object\",\n                    \"default\": {},\n                    \"markdownDescription\": \"%emmetIncludeLanguages%\"\n                },\n                \"emmet.variables\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"lang\": {\n                            \"type\": \"string\",\n                            \"default\": \"en\"\n                        },\n                        \"charset\": {\n                            \"type\": \"string\",\n                            \"default\": \"UTF-8\"\n                        }\n                    },\n                    \"default\": {},\n                    \"description\": \"%emmetVariables%\"\n                },\n                \"emmet.syntaxProfiles\": {\n                    \"type\": \"object\",\n                    \"default\": {},\n                    \"description\": \"%emmetSyntaxProfiles%\"\n                },\n                \"emmet.excludeLanguages\": {\n                    \"type\": \"array\",\n                    \"default\": [\"markdown\"],\n                    \"description\": \"%emmetExclude%\"\n                },\n                \"emmet.extensionsPath\": {\n                    \"type\": \"string\",\n                    \"default\": null,\n                    \"description\": \"%emmetExtensionsPath%\"\n                },\n                \"emmet.triggerExpansionOnTab\": {\n                    \"type\": \"boolean\",\n                    \"default\": false,\n                    \"description\": \"%emmetTriggerExpansionOnTab%\"\n                },\n                \"emmet.preferences\": {\n                    \"type\": \"object\",\n                    \"default\": {},\n                    \"description\": \"%emmetPreferences%\",\n                    \"properties\": {\n                        \"css.intUnit\": {\n                            \"type\": \"string\",\n                            \"default\": \"px\",\n                            \"description\": \"%emmetPreferencesIntUnit%\"\n                        },\n                        \"css.floatUnit\": {\n                            \"type\": \"string\",\n                            \"default\": \"em\",\n                            \"description\": \"%emmetPreferencesFloatUnit%\"\n                        },\n                        \"css.propertyEnd\": {\n                            \"type\": \"string\",\n                            \"default\": \";\",\n                            \"description\": \"%emmetPreferencesCssAfter%\"\n                        },\n                        \"sass.propertyEnd\": {\n                            \"type\": \"string\",\n                            \"default\": \"\",\n                            \"description\": \"%emmetPreferencesSassAfter%\"\n                        },\n                        \"stylus.propertyEnd\": {\n                            \"type\": \"string\",\n                            \"default\": \"\",\n                            \"description\": \"%emmetPreferencesStylusAfter%\"\n                        },\n                        \"css.valueSeparator\": {\n                            \"type\": \"string\",\n                            \"default\": \": \",\n                            \"description\": \"%emmetPreferencesCssBetween%\"\n                        },\n                        \"sass.valueSeparator\": {\n                            \"type\": \"string\",\n                            \"default\": \": \",\n                            \"description\": \"%emmetPreferencesSassBetween%\"\n                        },\n                        \"stylus.valueSeparator\": {\n                            \"type\": \"string\",\n                            \"default\": \" \",\n                            \"description\": \"%emmetPreferencesStylusBetween%\"\n                        },\n                        \"bem.elementSeparator\": {\n                            \"type\": \"string\",\n                            \"default\": \"__\",\n                            \"description\": \"%emmetPreferencesBemElementSeparator%\"\n                        },\n                        \"bem.modifierSeparator\": {\n                            \"type\": \"string\",\n                            \"default\": \"_\",\n                            \"description\": \"%emmetPreferencesBemModifierSeparator%\"\n                        },\n                        \"filter.commentBefore\": {\n                            \"type\": \"string\",\n                            \"default\": \"\",\n                            \"description\": \"%emmetPreferencesFilterCommentBefore%\"\n                        },\n                        \"filter.commentAfter\": {\n                            \"type\": \"string\",\n                            \"default\": \"\\n<!-- /[#ID][.CLASS] -->\",\n                            \"description\": \"%emmetPreferencesFilterCommentAfter%\"\n                        },\n                        \"filter.commentTrigger\": {\n                            \"type\": \"array\",\n                            \"default\": [\"id\", \"class\"],\n                            \"description\": \"%emmetPreferencesFilterCommentTrigger%\"\n                        },\n                        \"format.noIndentTags\": {\n                            \"type\": \"array\",\n                            \"default\": [\"html\"],\n                            \"description\": \"%emmetPreferencesFormatNoIndentTags%\"\n                        },\n                        \"format.forceIndentationForTags\": {\n                            \"type\": \"array\",\n                            \"default\": [\"body\"],\n                            \"description\": \"%emmetPreferencesFormatForceIndentTags%\"\n                        },\n                        \"profile.allowCompactBoolean\": {\n                            \"type\": \"boolean\",\n                            \"default\": false,\n                            \"description\": \"%emmetPreferencesAllowCompactBoolean%\"\n                        },\n                        \"css.webkitProperties\": {\n                            \"type\": \"string\",\n                            \"default\": null,\n                            \"markdownDescription\": \"%emmetPreferencesCssWebkitProperties%\"\n                        },\n                        \"css.mozProperties\": {\n                            \"type\": \"string\",\n                            \"default\": null,\n                            \"markdownDescription\": \"%emmetPreferencesCssMozProperties%\"\n                        },\n                        \"css.oProperties\": {\n                            \"type\": \"string\",\n                            \"default\": null,\n                            \"markdownDescription\": \"%emmetPreferencesCssOProperties%\"\n                        },\n                        \"css.msProperties\": {\n                            \"type\": \"string\",\n                            \"default\": null,\n                            \"markdownDescription\": \"%emmetPreferencesCssMsProperties%\"\n                        },\n                        \"css.fuzzySearchMinScore\": {\n                            \"type\": \"number\",\n                            \"default\": 0.3,\n                            \"description\": \"%emmetPreferencesCssFuzzySearchMinScore%\"\n                        }\n                    }\n                },\n                \"emmet.showSuggestionsAsSnippets\": {\n                    \"type\": \"boolean\",\n                    \"default\": false,\n                    \"markdownDescription\": \"%emmetShowSuggestionsAsSnippets%\"\n                },\n                \"emmet.optimizeStylesheetParsing\": {\n                    \"type\": \"boolean\",\n                    \"default\": true,\n                    \"markdownDescription\": \"%emmetOptimizeStylesheetParsing%\"\n                }\n            }\n        },\n        \"commands\": [{\n            \"command\": \"editor.emmet.action.wrapIndividualLinesWithAbbreviation\",\n            \"title\": \"%command.wrapIndividualLinesWithAbbreviation%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.wrapWithAbbreviation\",\n            \"title\": \"%command.wrapWithAbbreviation%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.removeTag\",\n            \"title\": \"%command.removeTag%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.updateTag\",\n            \"title\": \"%command.updateTag%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.matchTag\",\n            \"title\": \"%command.matchTag%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.balanceIn\",\n            \"title\": \"%command.balanceIn%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.balanceOut\",\n            \"title\": \"%command.balanceOut%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.prevEditPoint\",\n            \"title\": \"%command.prevEditPoint%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.nextEditPoint\",\n            \"title\": \"%command.nextEditPoint%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.mergeLines\",\n            \"title\": \"%command.mergeLines%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.selectPrevItem\",\n            \"title\": \"%command.selectPrevItem%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.selectNextItem\",\n            \"title\": \"%command.selectNextItem%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.splitJoinTag\",\n            \"title\": \"%command.splitJoinTag%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.toggleComment\",\n            \"title\": \"%command.toggleComment%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.evaluateMathExpression\",\n            \"title\": \"%command.evaluateMathExpression%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.updateImageSize\",\n            \"title\": \"%command.updateImageSize%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.incrementNumberByOneTenth\",\n            \"title\": \"%command.incrementNumberByOneTenth%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.incrementNumberByOne\",\n            \"title\": \"%command.incrementNumberByOne%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.incrementNumberByTen\",\n            \"title\": \"%command.incrementNumberByTen%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.decrementNumberByOneTenth\",\n            \"title\": \"%command.decrementNumberByOneTenth%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.decrementNumberByOne\",\n            \"title\": \"%command.decrementNumberByOne%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.decrementNumberByTen\",\n            \"title\": \"%command.decrementNumberByTen%\",\n            \"category\": \"Emmet\"\n        }, {\n            \"command\": \"editor.emmet.action.reflectCSSValue\",\n            \"title\": \"%command.reflectCSSValue%\",\n            \"category\": \"Emmet\"\n        }],\n        \"menus\": {\n            \"commandPalette\": [{\n                \"command\": \"editor.emmet.action.wrapIndividualLinesWithAbbreviation\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.wrapWithAbbreviation\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.removeTag\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.updateTag\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.matchTag\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.balanceIn\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.balanceOut\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.prevEditPoint\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.nextEditPoint\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.mergeLines\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.selectPrevItem\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.selectNextItem\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.splitJoinTag\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.toggleComment\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.evaluateMathExpression\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.updateImageSize\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.incrementNumberByOneTenth\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.incrementNumberByOne\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.incrementNumberByTen\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.decrementNumberByOneTenth\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.decrementNumberByOne\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.decrementNumberByTen\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }, {\n                \"command\": \"editor.emmet.action.reflectCSSValue\",\n                \"when\": \"resourceScheme =~ /^untitled$|^file$/\"\n            }]\n        }\n    },\n    \"scripts\": {\n        \"watch\": \"gulp watch-extension:emmet\",\n        \"compile\": \"gulp compile-extension:emmet\",\n        \"deps\": \"yarn add vscode-emmet-helper\"\n    },\n    \"devDependencies\": {\n        \"@types/node\": \"8.0.33\",\n        \"mocha-junit-reporter\": \"^1.17.0\",\n        \"mocha-multi-reporters\": \"^1.1.7\",\n        \"vscode\": \"1.0.1\"\n    },\n    \"dependencies\": {\n        \"@emmetio/css-parser\": \"ramya-rao-a/css-parser#vscode\",\n        \"@emmetio/html-matcher\": \"^0.3.3\",\n        \"@emmetio/math-expression\": \"^0.1.1\",\n        \"image-size\": \"^0.5.2\",\n        \"vscode-emmet-helper\": \"^1.2.15\"\n    }\n}","/emmet/dist/extension.js":"!function(e,t){for(var n in t)e[n]=t[n]}(exports,function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=20)}([function(e,t,n){\"use strict\";n.d(t,\"b\",function(){return s}),n.d(t,\"f\",function(){return a}),n.d(t,\"c\",function(){return c}),n.d(t,\"e\",function(){return u}),n.d(t,\"d\",function(){return l}),n.d(t,\"g\",function(){return d}),n.d(t,\"h\",function(){return f}),n.d(t,\"a\",function(){return h});const r=39,i=34,o={escape:92,throws:!1};var s=function(e,t){t=t?Object.assign({},o,t):o;const n=e.pos,r=e.peek();if(e.eat(a)){for(;!e.eof();)switch(e.next()){case r:return e.start=n,!0;case t.escape:e.next()}if(e.pos=n,t.throws)throw e.error(\"Unable to consume quoted string\")}return!1};function a(e){return e===r||e===i}function u(e){return e>47&&e<58}function c(e,t,n){return t=t||65,n=n||90,(e&=-33)>=t&&e<=n}function l(e){return u(e)||c(e)}function f(e){return 32===e||9===e||160===e}function d(e){return f(e)||10===e||13===e}const p={escape:92,throws:!1};function h(e,t,n,r){r=r?Object.assign({},p,r):p;const i=e.pos;if(e.eat(t)){let o,a=1;for(;!e.eof();)if(!s(e,r))if((o=e.next())===t)a++;else if(o===n){if(!--a)return e.start=i,!0}else o===r.escape&&e.next();if(e.pos=i,r.throws)throw e.error(`Unable to find matching pair for ${String.fromCharCode(t)}`)}return!1}},function(e,t){e.exports=require(\"vscode\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(22),o=n(6),s=n(4);let a,u=void 0;function c(){if(!a)return;let e=r.workspace.getConfiguration(\"emmet\").extensionsPath;u!==e&&(u=e,a.updateExtensionsPath(e,r.workspace.rootPath).then(null,e=>r.window.showErrorMessage(e)))}function l(e){return[\"css\",\"scss\",\"sass\",\"less\",\"stylus\"].indexOf(e)>-1}function f(e,t=!0){let n=l(e.languageId)?o.default:i.default;try{return n(new s.DocumentStreamReader(e))}catch(e){t&&r.window.showErrorMessage(\"Emmet: Failed to parse the file\")}}t.getEmmetHelper=function(){return a||(a=n(23)),c(),a},t.updateEmmetExtensionsPath=c,t.LANGUAGE_MODES={html:[\"!\",\".\",\"}\",\":\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],jade:[\"!\",\".\",\"}\",\":\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],slim:[\"!\",\".\",\"}\",\":\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],haml:[\"!\",\".\",\"}\",\":\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],xml:[\".\",\"}\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],xsl:[\"!\",\".\",\"}\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],css:[\":\",\"-\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],scss:[\":\",\"-\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],sass:[\":\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],less:[\":\",\"-\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],stylus:[\":\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],javascriptreact:[\"!\",\".\",\"}\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"],typescriptreact:[\"!\",\".\",\"}\",\"*\",\"$\",\"]\",\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]},t.isStyleSheet=l,t.validate=function(e=!0){let t=r.window.activeTextEditor;return t?!(!e&&l(t.document.languageId)):(r.window.showInformationMessage(\"No editor is active\"),!1)},t.getMappingForIncludedLanguages=function(){const e=Object.create(null);let n=r.workspace.getConfiguration(\"emmet\").includeLanguages,i=Object.assign({},{handlebars:\"html\",php:\"html\"},n||{});return Object.keys(i).forEach(n=>{\"string\"==typeof i[n]&&t.LANGUAGE_MODES[i[n]]&&(e[n]=i[n])}),e},t.getEmmetMode=function(e,t){if(!e||t.indexOf(e)>-1)return;return/\\b(typescriptreact|javascriptreact|jsx-tags)\\b/.test(e)?\"jsx\":\"sass-indented\"===e?\"sass\":\"jade\"===e?\"pug\":[\"html\",\"pug\",\"slim\",\"haml\",\"xml\",\"xsl\",\"jsx\",\"css\",\"scss\",\"sass\",\"less\",\"stylus\"].indexOf(e)>-1?e:void 0},t.parseDocument=f;const d=125,p=123,h=47,m=42;function g(e,t,n){if(!e)return null;let r=e.firstChild,i=null;for(;r;){const e=r.start,o=r.end;e.isBefore(t)&&o.isAfter(t)||n&&e.isBeforeOrEqual(t)&&o.isAfterOrEqual(t)?(i=r,r=r.firstChild):r=r.nextSibling}return i}function v(e){if(e.close)return new r.Range(e.open.end,e.close.start)}function w(e,t){return!(!e||!t)&&(e.start.isEqual(t.start)&&e.end.isEqual(t.end))}t.parsePartialStylesheet=function(e,t){const n=\"css\"===e.languageId;let i=new r.Position(0,0),a=new r.Position(e.lineCount-1,e.lineAt(e.lineCount-1).text.length);const u=e.offsetAt(t)-5e3,c=u>0?e.positionAt(u):i,l=new s.DocumentStreamReader(e,t);function f(){if(!n&&b!==l.pos.line){b=l.pos.line;let t=e.lineAt(b).text.indexOf(\"//\");t>-1&&(l.pos=new r.Position(b,t))}}function g(){l.peek()===h&&(l.backUp(1)===m?l.pos=function(t){let n=e.getText(new r.Range(0,0,t.line,t.character)).lastIndexOf(\"/*\");if(-1!==n)return e.positionAt(n)}(l.pos)||i:l.next())}function v(){l.eat(h)&&(l.eat(h)&&!n?l.pos=new r.Position(l.pos.line+1,0):l.eat(m)&&(l.pos=function(t){let n=e.getText(new r.Range(t.line,t.character,e.lineCount-1,e.lineAt(e.lineCount-1).text.length)).indexOf(\"*/\");if(-1!==n)return n+=2+e.offsetAt(t),e.positionAt(n)}(l.pos)||a))}for(;!l.eof()&&!l.eat(d);)l.peek()===h?v():l.next();l.eof()||(a=l.pos),l.pos=t;let w=1,b=t.line,x=!1;for(;!x&&w>0&&!l.sof();){switch(f(),l.backUp(1)){case p:w--;break;case d:n?(l.next(),i=l.pos,x=!0):w++;break;case h:g()}(t.line-l.pos.line>100||l.pos.isBeforeOrEqual(c))&&(x=!0)}b=l.pos.line,w=0;let y=!1;for(;!x&&!l.sof()&&!y&&w>=0;){f();const e=l.backUp(1);if(!/\\s/.test(String.fromCharCode(e))){switch(e){case h:g();break;case d:w++;break;case p:w--;break;default:w||(y=!0)}!l.sof()&&y&&(i=l.pos)}}try{return o.default(new s.DocumentStreamReader(e,i,new r.Range(i,a)))}catch(e){return}},t.getNode=g,t.allowedMimeTypesInScriptTag=[\"text/html\",\"text/plain\",\"text/x-template\",\"text/template\",\"text/ng-template\"],t.getHtmlNode=function(e,n,o,a){let u=g(n,o,a);if(!u)return;if(\"script\"===u.name&&u.attributes&&u.attributes.some(e=>\"type\"===e.name.toString()&&t.allowedMimeTypesInScriptTag.indexOf(e.value.toString())>-1)&&u.close&&o.isAfter(u.open.end)&&o.isBefore(u.close.start)){let t=new s.DocumentStreamReader(e,u.open.end,new r.Range(u.open.end,u.close.start));try{u=g(i.default(t),o,a)||u}catch(e){}}return u},t.getInnerRange=v,t.getDeepestNode=function e(t){if(!t||!t.children||0===t.children.length||!t.children.find(e=>\"comment\"!==e.type))return t;for(let n=t.children.length-1;n>=0;n--)if(\"comment\"!==t.children[n].type)return e(t.children[n])},t.findNextWord=function(e,t){let n,r,i=-1===t,o=!1,s=!1;for(;t<e.length-1;)if(t++,i){if(!i||o||\" \"!==e[t])if(o){if(\" \"===e[t]){r=t,s=!0;break}}else n=t,o=!0}else\" \"===e[t]&&(i=!0);return o&&!s&&(r=e.length),[n,r]},t.findPrevWord=function(e,t){let n,r,i=t===e.length,o=!1,s=!1;for(;t>-1;)if(t--,i){if(!i||s||\" \"!==e[t])if(s){if(\" \"===e[t]){n=t+1,o=!0;break}}else r=t+1,s=!0}else\" \"===e[t]&&(i=!0);return s&&!o&&(n=0),[n,r]},t.getNodesInBetween=function(e,t){if(w(e,t))return[e];if(!w(e.parent,t.parent)){if(t.start.isBefore(e.start))return[t];if(t.start.isBefore(e.end))return[e];for(;e.parent&&e.parent.end.isBefore(t.start);)e=e.parent;for(;t.parent&&t.parent.start.isAfter(e.start);)t=t.parent}const n=[];let r=e;const i=t.end;for(;r&&i.isAfter(r.start);)n.push(r),r=r.nextSibling;return n},t.sameNodes=w,t.getEmmetConfiguration=function(e){const t=r.workspace.getConfiguration(\"emmet\"),n=Object.assign({},t.syntaxProfiles||{}),i=Object.assign({},t.preferences||{});return\"jsx\"!==e&&\"xml\"!==e&&\"xsl\"!==e||(n[e]=n[e]||{},\"object\"!=typeof n[e]||n[e].hasOwnProperty(\"self_closing_tag\")||n[e].hasOwnProperty(\"selfClosingStyle\")||(n[e]=Object.assign({},n[e],{selfClosingStyle:\"xml\"}))),{preferences:i,showExpandedAbbreviation:t.showExpandedAbbreviation,showAbbreviationSuggestions:t.showAbbreviationSuggestions,syntaxProfiles:n,variables:t.variables,excludeLanguages:t.excludeLanguages,showSuggestionsAsSnippets:t.showSuggestionsAsSnippets}},t.iterateCSSToken=function e(t,n){for(let r=0,i=t.size;r<i;r++)if(!1===n(t.item(r))||!1===e(t.item(r),n))return!1;return!0},t.getCssPropertyFromRule=function(e,t){return e.children.find(e=>\"property\"===e.type&&e.name===t)},t.getCssPropertyFromDocument=function(e,t){const n=g(f(e.document),t,!0);if(l(e.document.languageId))return n&&\"property\"===n.type?n:null;let i=n;if(i&&\"style\"===i.name&&i.open.end.isBefore(t)&&i.close.start.isAfter(t)){let n=new s.DocumentStreamReader(e.document,i.start,new r.Range(i.start,i.end));const a=g(o.default(n),t,!0);return a&&\"property\"===a.type?a:null}return null},t.getEmbeddedCssNodeIfAny=function(e,t,n){if(!t)return;const i=t;if(i&&i.close){const t=v(i);if(t&&t.contains(n)&&\"style\"===i.name&&i.open.end.isBefore(n)&&i.close.start.isAfter(n)){let t=new s.DocumentStreamReader(e,i.open.end,new r.Range(i.open.end,i.close.start));return o.default(t)}}},t.isStyleAttribute=function(e,t){if(!e)return!1;const n=e,r=(n.attributes||[]).findIndex(e=>\"style\"===e.name.toString());if(-1===r)return!1;const i=n.attributes[r];return t.isAfterOrEqual(i.value.start)&&t.isBeforeOrEqual(i.value.end)}},function(e,t,n){\"use strict\";t.a=class{constructor(e,t,n){null==n&&\"string\"==typeof e&&(n=e.length),this.string=e,this.pos=this.start=t||0,this.end=n}eof(){return this.pos>=this.end}limit(e,t){return new this.constructor(this.string,e,t)}peek(){return this.string.charCodeAt(this.pos)}next(){if(this.pos<this.string.length)return this.string.charCodeAt(this.pos++)}eat(e){const t=this.peek(),n=\"function\"==typeof e?e(t):t===e;return n&&this.next(),n}eatWhile(e){const t=this.pos;for(;!this.eof()&&this.eat(e););return this.pos!==t}backUp(e){this.pos-=e||1}current(){return this.substring(this.start,this.pos)}substring(e,t){return this.string.slice(e,t)}error(e){const t=new Error(`${e} at char ${this.pos+1}`);return t.originalMessage=e,t.pos=this.pos,t.string=this.string,t}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1);class i{constructor(e,t,n){this.document=e,this.start=this.pos=t||new r.Position(0,0),this._sof=n?n.start:new r.Position(0,0),this._eof=n?n.end:new r.Position(this.document.lineCount-1,this._lineLength(this.document.lineCount-1)),this._eol=this.document.eol===r.EndOfLine.LF?\"\\n\":\"\\r\\n\"}sof(){return this.pos.isBeforeOrEqual(this._sof)}eof(){return this.pos.isAfterOrEqual(this._eof)}limit(e,t){return new i(this.document,e,new r.Range(e,t))}peek(){if(this.eof())return NaN;const e=this.document.lineAt(this.pos.line).text;return this.pos.character<e.length?e.charCodeAt(this.pos.character):this._eol.charCodeAt(this.pos.character-e.length)}next(){if(this.eof())return NaN;const e=this.document.lineAt(this.pos.line).text;let t;return this.pos.character<e.length?(t=e.charCodeAt(this.pos.character),this.pos=this.pos.translate(0,1)):(t=this._eol.charCodeAt(this.pos.character-e.length),this.pos=new r.Position(this.pos.line+1,0)),this.eof()&&(this.pos=new r.Position(this._eof.line,this._eof.character)),t}backUp(e){let t=this.pos.line,n=this.pos.character;for(n-=e||1;t>=0&&n<0;)t--,n+=this._lineLength(t);return this.pos=t<0||n<0?new r.Position(0,0):new r.Position(t,n),this.peek()}current(){return this.substring(this.start,this.pos)}substring(e,t){return this.document.getText(new r.Range(e,t))}error(e){return new Error(`${e} at row ${this.pos.line}, column ${this.pos.character}`)}_lineLength(e){return e===this.document.lineCount-1?this.document.lineAt(e).text.length:this.document.lineAt(e).text.length+this._eol.length}eat(e){const t=this.peek(),n=\"function\"==typeof e?e(t):t===e;return n&&this.next(),n}eatWhile(e){const t=this.pos;for(;!this.eof()&&this.eat(e););return!this.pos.isEqual(t)}}t.DocumentStreamReader=i},function(e,t){e.exports=require(\"path\")},function(e,t,n){\"use strict\";n.r(t),n.d(t,\"lexer\",function(){return pt}),n.d(t,\"Token\",function(){return h}),n.d(t,\"any\",function(){return He}),n.d(t,\"selector\",function(){return Ve}),n.d(t,\"value\",function(){return Ge}),n.d(t,\"keyword\",function(){return Je}),n.d(t,\"variable\",function(){return We}),n.d(t,\"formatting\",function(){return Ke}),n.d(t,\"comment\",function(){return G}),n.d(t,\"whitespace\",function(){return Y}),n.d(t,\"ident\",function(){return A}),n.d(t,\"string\",function(){return U}),n.d(t,\"url\",function(){return qe}),n.d(t,\"interpolation\",function(){return D}),n.d(t,\"backtick\",function(){return se}),n.d(t,\"parseMediaExpression\",function(){return Ze}),n.d(t,\"parsePropertyName\",function(){return Qe}),n.d(t,\"parsePropertyValue\",function(){return Ye}),n.d(t,\"parseSelector\",function(){return Xe}),n.d(t,\"createProperty\",function(){return ot}),n.d(t,\"createRule\",function(){return tt}),n.d(t,\"createAtRule\",function(){return rt});var r=n(3),i=n(0);class o{constructor(e){this.type=e,this.children=[],this.parent=null}get firstChild(){return this.children[0]}get nextSibling(){const e=this.index();return-1!==e?this.parent.children[e+1]:null}get previousSibling(){const e=this.index();return-1!==e?this.parent.children[e-1]:null}index(){return this.parent?this.parent.children.indexOf(this):-1}add(e){return e&&(e.remove(),this.children.push(e),e.parent=this),this}remove(){if(this.parent){const e=this.index();-1!==e&&(this.parent.children.splice(e,1),this.parent=null)}return this}}class s extends o{constructor(){super(\"stylesheet\"),this.comments=[]}get start(){const e=this.firstChild;return e&&e.start}get end(){const e=this.children[this.children.length-1];return e&&e.end}addComment(e){this.comments.push(e)}}function a(e){return function(e){let t;for(e=e.slice();t!==e.length;)t=e.length,u(e[0])&&e.shift(),u(d(e))&&e.pop();return e}(e)}function u(e){const t=e&&e.type;return\"whitespace\"===t||\"comment\"===t}function c(e,t){const n=e.pos;for(let r=0,i=t.length;r<i;r++)if(!e.eat(t.charCodeAt(r)))return e.pos=n,!1;return!0}function l(e,t){const n=e.pos;return!!e.eat(t)&&(e.start=n,!0)}function f(e,t){const n=e.pos;return!!e.eatWhile(t)&&(e.start=n,!0)}function d(e){return e[e.length-1]}function p(e){return e&&e.valueOf()}class h{constructor(e,t,n,r){this.stream=e,this.start=null!=n?n:e.start,this.end=null!=r?r:e.pos,this.type=t,this._props=null,this._value=null,this._items=null}get size(){return this._items?this._items.length:0}get items(){return this._items}clone(e,t){return new this.constructor(this.stream,this.type,null!=e?e:this.start,null!=t?t:this.end)}add(e){if(Array.isArray(e))for(let t=0,n=e.length;t<n;t++)this.add(e[t]);else e&&(this._items?this._items.push(e):this._items=[e]);return this}remove(e){if(this._items){const t=this._items.indexOf(e);-1!==t&&this._items.splice(t,1)}return this}item(e){const t=this.size;return this._items&&this._items[(t+e)%t]}limit(){return this.stream.limit(this.start,this.end)}slice(e,t){const n=this.clone(),r=this._items&&this._items.slice(e,t);return r&&r.length?(n.start=r[0].start,n.end=r[r.length-1].end,n.add(r)):r&&(n.start=n.end),n}property(e,t){return void 0!==t&&(this._props||(this._props={}),this._props[e]=t),this._props&&this._props[e]}toString(){return`${this.valueOf()} [${this.start}, ${this.end}] (${this.type})`}valueOf(){return null===this._value&&(this._value=this.stream.substring(this.start,this.end)),this._value}}const m=44,g=58,v=59,w=123,b=125,x=(new Map).set(m,\"comma\").set(g,\"propertyDelimiter\").set(v,\"propertyTerminator\").set(w,\"ruleStart\").set(b,\"ruleEnd\");function y(e){if(function(e){return e===m||e===g||e===v||e===w||e===b}(e.peek())){const t=e.pos,n=x.get(e.next()),r=new h(e,\"separator\",t);return r.property(\"type\",n),r}}var E=function(e,t){if(40===e.peek()){const n=e.pos;e.next();const r=[];let i,o=!1;for(;!e.eof()&&!T(e.peek())&&!e.eat(41)&&(i=t(e));)O(i)&&(o=!0),r.push(i);return e.start=n,function(e,t,n){const r=new h(e,\"arguments\"),i=n?O:C;let o=[];for(let n,s=0,a=t.length;s<a;s++)n=t[s],i(n)?(r.add(S(e,o)||k(e,n.start)),o.length=0):o.push(n);o.length&&r.add(S(e,o));return r}(e,r,o)}};function T(e){return e===w||e===b}function S(e,t){if((t=a(t)).length){const n=new h(e,\"argument\",t[0].start,d(t).end);for(let e=0;e<t.length;e++)n.add(t[e]);return n}}function k(e,t){const n=new h(e,\"argument\",t,t);return n.property(\"empty\",!0),n}function C(e){return\"comma\"===e.property(\"type\")}function O(e){return\"propertyTerminator\"===e.property(\"type\")}const I=45,_=95;function A(e){return R(e)&&new h(e,\"ident\")}function R(e){const t=e.pos;return e.eat(I),e.eat(P)?(e.eatWhile(j),e.start=t,!0):(e.pos=t,!1)}function P(e){return e===_||e===I||Object(i.c)(e)||e>=128}function j(e){return Object(i.e)(e)||P(e)}function M(e,t,n,r,i){const o=e.pos;if(e.eat(n)){const n=r(e,o);if(n||i)return e.start=o,new h(e,t,o).add(n)}e.pos=o}const N=64;function B(e){return M(e,\"at-keyword\",N,A)}const L=35,q=64;function D(e,t){const n=e.pos;if(t=t||W,(e.eat(L)||e.eat(q))&&e.eat(w)){const r=new h(e,\"interpolation\",n);let i,o=1;for(;!e.eof();)if(e.eat(w))o++;else if(e.eat(b)){if(!--o)return r.end=e.pos,r}else{if(!(i=t(e)))break;r.add(i)}}e.pos=n}function $(e){const t=e.pos;return(e.eat(L)||e.eat(q))&&Object(i.a)(e,w,b)?(e.start=t,!0):(e.pos=t,!1)}function W(e){const t=e.pos;for(;!e.eof()&&e.peek()!==b;)F(e)||e.next();if(t!==e.pos)return new h(e,\"expression\",t)}function U(e){return F(e,!0)}function F(e,t){let n,r,o,s=e.peek();if(Object(i.f)(s)){e.start=e.pos,e.next();const i=s,a=e.pos;for(;!e.eof()&&(n=e.pos,!e.eat(i)&&!e.eat(z));)e.eat(92)?e.eat(z):t&&(o=D(e))&&(r?r.push(o):r=[o]),e.next();if(t){const t=new h(e,\"string\"),o=new h(e,\"unquoted\",a,n);return o.add(r),t.add(o),t.property(\"quote\",i),t}return!0}return!1}function z(e){return 10===e||13===e}const H=42,V=47;var G=function(e){return function(e){if(K(e)){const t=new h(e,\"comment\");return t.property(\"type\",\"single-line\"),t}}(e)||function(e){if(X(e)){const t=new h(e,\"comment\");return t.property(\"type\",\"multiline\"),t}}(e)};function J(e){return K(e)||X(e)}function K(e){const t=e.pos;if(e.eat(V)&&e.eat(V)){for(e.start=t;!e.eof()&&!Q(e.next()););return!0}return e.pos=t,!1}function X(e){const t=e.pos;if(e.eat(V)&&e.eat(H)){for(;!(e.eof()||e.next()===H&&e.eat(V)););return e.start=t,!0}return e.pos=t,!1}function Q(e){return 10===e||13===e}function Y(e){return Z(e)&&new h(e,\"whitespace\")}function Z(e){return f(e,i.g)}const ee=91,te=93;function ne(e){const t=e.pos;if(e.eat(ee)){re(e);const n=A(e);re(e);const r=function(e){return f(e,ie)&&new h(e,\"operator\")}(e);re(e);const i=U(e)||A(e);return re(e),e.eat(te),new h(e,\"attribute\",t).add(n).add(r).add(i)}}function re(e){for(;!e.eof();)if(!Z(e)&&!J(e))return!0}function ie(e){return 126===e||124===e||94===e||36===e||42===e||61===e}const oe=96;function se(e){if(ae(e))return new h(e,\"backtick\")}function ae(e){const t=e.pos;return!!Object(i.a)(e,oe,oe)&&(e.start=t,!0)}const ue=46;const ce=43,le=126,fe=62,de=38,pe={[ce]:\"adjacentSibling\",[le]:\"generalSibling\",[fe]:\"child\",[de]:\"nesting\"};var he=function(e){if(function(e){return e===ce||e===le||e===de||e===fe}(e.peek())){const t=e.pos,n=pe[e.next()],r=new h(e,\"combinator\",t);return r.property(\"type\",n),r}};const me=35;function ge(e){if(function(e){return f(e,ve)}(e))return new h(e,\"hash-value\")}function ve(e){return Object(i.e)(e)||Object(i.c)(e,65,70)||95===e||45===e||e>128}const we=35;const be=33;const xe=46;function ye(e){if(function(e){const t=e.pos;if(e.eat(Ee),e.eatWhile(i.e)){e.start=t;const n=e.pos;return e.eat(xe)&&e.eatWhile(i.e)||(e.pos=n),!0}if(e.eat(xe)&&e.eatWhile(i.e))return e.start=t,!0;return e.pos=t,!1}(e)){const t=e.start,n=new h(e,\"value\"),r=function(e){return R(e)||function(e){return l(e,37)}(e)}(e)?new h(e,\"unit\"):null;return new h(e,\"number\",t).add(n).add(r)}}function Ee(e){return 45===e||43===e}const Te=33,Se=42,ke=43,Ce=45,Oe=47,Ie=60,_e=61,Ae=62;function Re(e){return function(e){if(l(e,Pe))return e.eatWhile(_e),!0;if(l(e,je))return!0;return!1}(e)&&new h(e,\"operator\")}function Pe(e){return e===Te||e===Ie||e===_e||e===Ae}function je(e){return e===Se||e===ke||e===Ce||e===Oe||Pe(e)}var Me=function(e){const t=e.pos;if(e.eatWhile(58)){const n=A(e);if(n)return new h(e,\"pseudo\",t).add(n)}e.pos=t},Ne=function(e){return Be(e)&&new h(e,\"unquoted\")};function Be(e){return f(e,Le)}function Le(e){return!(isNaN(e)||Object(i.f)(e)||Object(i.g)(e)||40===e||41===e||92===e||function(e){return e>=0&&e<=8||11===e||e>=14&&e<=31||127===e}(e))}function qe(e){const t=e.pos;if(c(e,\"url(\")){Z(e);const n=U(e)||Ne(e);return Z(e),e.eat(41),new h(e,\"url\",t).add(n)}e.pos=t}function De(e){const t=e.pos;return c(e,\"url(\")?(Z(e),F(e)||Be(e),Z(e),e.eat(41),e.start=t,!0):(e.pos=t,!1)}const $e=36;function We(e){return M(e,\"variable\",$e,Ue)}function Ue(e){if(function(e){return f(e,Fe)}(e))return new h(e,\"name\")}function Fe(e){return e===$e||j(e)}function ze(e){const t=He(e)||E(e,ze);if(t&&\"ident\"===t.type){const n=E(e,ze);if(n)return new h(e,\"function\",t.start,n.end).add(t).add(n)}return t||function(e){if(e.start=e.pos,null!=e.next())return new h(e,\"unknown\")}(e)}function He(e){return Ke(e)||qe(e)||Ve(e)||Ge(e)||y(e)}function Ve(e){return D(e)||se(e)||A(e)||B(e)||function(e){return M(e,\"class\",ue,A)}(e)||function(e){return M(e,\"id\",we,A)}(e)||Me(e)||ne(e)||he(e)}function Ge(e){return qe(e)||U(e)||D(e)||se(e)||ye(e)||function(e){return M(e,\"hash\",me,ge,!0)}(e)||Je(e)||function(e){return M(e,\"important\",be,A)}(e)||Re(e)}function Je(e){return se(e)||We(e)||B(e)||A(e)}function Ke(e){return G(e)||Y(e)}function Xe(e){return et(e,\"selector\")}function Qe(e){const t=\"string\"==typeof e?new r.a(e):e,n=[];for(;!t.eof();)n.push(ze(t));let i;if(1===n.length)i=n[0];else{i=new h(t,\"property-name\",t.start,t.end);for(let e=0,t=n.length;e<t;e++)i.add(n[e])}return i}function Ye(e){return et(e)}function Ze(e){return et(e)}function et(e,t){t=t||\"item\";const n=\"string\"==typeof e?new r.a(e):e,i=[],o=[],s=()=>{const e=a(o);if(e.length){const r=new h(n,t,e[0].start,d(e).end);for(let t=0;t<e.length;t++)r.add(e[t]);i.push(r)}o.length=0};let u;for(;!n.eof();)if(n.eat(44))s();else{if(!(u=ze(n)))throw n.error(\"Unexpected character\");\"comment\"!==u.type&&o.push(u)}return s(),i}function tt(e,t,n,r){if(!t.length)return null;const i=t[0];return i.end=d(t).end,new nt(e,i,n,r)}class nt extends o{constructor(e,t,n,r){super(\"rule\"),this.stream=e,this.selectorToken=t,this.contentStartToken=n,this.contentEndToken=r||n,this._parsedSelector=null}get selector(){return p(this.selectorToken)}get parsedSelector(){return this._parsedSelector||(this._parsedSelector=Xe(this.selectorToken.limit())),this._parsedSelector}get start(){return this.selectorToken&&this.selectorToken.start}get end(){const e=this.contentEndToken||this.contentStartToken||this.nameToken;return e&&e.end}}function rt(e,t,n,r){if(!t.length)return null;let i,o=0;const s=t[o++];return o<t.length?((i=t[o++]).type=\"expression\",i.end=d(t).end):i=new h(e,\"expression\",s.end,s.end),new it(e,s,i,n,r)}class it extends o{constructor(e,t,n,r,i){super(\"at-rule\"),this.stream=e,this.nameToken=t,this.expressionToken=n,this.contentStartToken=r,this.contentEndToken=i||r,this._parsedExpression=null}get name(){return p(this.nameToken&&this.nameToken.item(0))}get expression(){return p(this.expressionToken)}get parsedExpression(){return this._parsedExpression||(this._parsedExpression=Ze(this.expressionToken.limit())),this._parsedExpression}get start(){return this.nameToken&&this.nameToken.start}get end(){const e=this.contentEndToken||this.contentStartToken||this.nameToken;return e&&e.end}}function ot(e,t,n){if(!t.length)return null;let r,i,o=0;const s=t[o++];return o<t.length&&((i=t[o++]).type=\"value\",i.end=d(t).end),s&&i&&(r=new h(e,\"separator\",s.end,i.start)),new st(e,s,i,r,n)}class st extends o{constructor(e,t,n,r,i){super(\"property\"),this.stream=e,this.nameToken=t,this.valueToken=n,this._parsedName=null,this._parsedValue=null,this.separatorToken=r,this.terminatorToken=i}get name(){return p(this.nameToken)}get parsedName(){return this._parsedName||(this._parsedName=Qe(this.nameToken.limit())),this._parsedName}get value(){return p(this.valueToken)}get parsedValue(){return this._parsedValue||(this._parsedValue=Ye(this.valueToken.limit())),this._parsedValue}get separator(){return p(this.separatorToken)}get terminator(){return p(this.terminatorToken)}get start(){const e=this.nameToken||this.separatorToken||this.valueToken||this.terminatorToken;return e&&e.start}get end(){const e=this.terminatorToken||this.valueToken||this.separatorToken||this.nameToken;return e&&e.end}}const at=40,ut=41,ct=58,lt=59,ft=123,dt=125;function pt(e,t){t=t||ze;const n=\"string\"==typeof e?new r.a(e):e,i=[];let o;for(;!n.eof()&&(o=t(n));)i.push(o);return i}function ht(e,t){if(e.eat(at)){let n,r=1;for(;!e.eof();)if(e.eat(ut)){if(!--r)break}else if(e.eat(at))r++;else{if(De(e)||F(e))continue;if(n=G(e)){t.addComment(n);continue}e.next()}return!0}return!1}t.default=function(e){const t=\"string\"==typeof e?new r.a(e):e,n=new s;let i,o,a,u=n,c=[];const l=()=>{o&&(c.push(o),o=null)};for(;!t.eof();)if(!Z(t))if(a=G(t))n.addComment(a);else if(t.start=t.pos,t.eatWhile(ct))c.length||(o?l():o=new h(t,\"preparse\"));else if(t.eat(lt))l(),u.add(ot(t,c,new h(t,\"termintator\"))),c.length=0;else if(t.eat(ft))l(),c.length>0&&(i=\"at-keyword\"===c[0].type?rt(t,c,new h(t,\"body-start\")):tt(t,c,new h(t,\"body-start\")),u.add(i),u=i,c.length=0);else if(t.eat(dt))l(),u.add(ot(t,c)),\"stylesheet\"!==u.type&&(u.contentEndToken=new h(t,\"body-end\"),u=u.parent),c.length=0;else if(a=B(t))l(),c.push(a);else{if(!(De(t)||$(t)||ae(t)||ht(t,n)||F(t)||t.next()))throw new Error(`Unexpected end-of-stream at ${t.pos}`);(o=o||new h(t,\"preparse\")).end=t.pos}for(o&&c.push(o),u.add(ot(t,c)),t.start=t.pos;u&&u!==n;)u.contentEndToken=new h(t,\"body-end\"),u=u.parent;return n}},function(e,t){e.exports=require(\"fs\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2),o=/[\\u00a0]*[\\d#\\-\\*\\u2022]+\\.?/,s=/^#[\\da-fA-F]{0,6}$/,a=[\"a\",\"abbr\",\"acronym\",\"applet\",\"b\",\"basefont\",\"bdo\",\"big\",\"br\",\"button\",\"cite\",\"code\",\"del\",\"dfn\",\"em\",\"font\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"label\",\"map\",\"object\",\"q\",\"s\",\"samp\",\"select\",\"small\",\"span\",\"strike\",\"strong\",\"sub\",\"sup\",\"textarea\",\"tt\",\"u\",\"var\"];function u(e,t){if(!i.validate(!1)||!r.window.activeTextEditor)return;const n=r.window.activeTextEditor;if(e){if(1===n.selections.length&&n.selection.isEmpty)return void r.window.showInformationMessage(\"Select more than 1 line and try again.\");if(n.selections.find(e=>e.isEmpty))return void r.window.showInformationMessage(\"Select more than 1 line in each selection and try again.\")}(t=t||{}).language||(t.language=n.document.languageId);const o=p(t)||\"html\",s=i.parseDocument(n.document,!1);let a=!1,u=\"\";const c=i.getEmmetHelper();let l=n.selections.sort((e,t)=>e.start.compareTo(t.start)).map(t=>{let o=t.isReversed?new r.Range(t.active,t.anchor):t;if(o.isSingleLine||0!==o.end.character){if(o.isEmpty){const{active:e}=t,a=i.getNode(s,e,!0);o=!a||a.start.line!==e.line&&a.end.line!==e.line?new r.Range(o.start.line,0,o.start.line,n.document.lineAt(o.start.line).text.length):new r.Range(a.start,a.end)}}else{const e=o.end.line-1,t=n.document.lineAt(e).text.length;o=new r.Range(o.start,new r.Position(e,t))}const a=n.document.lineAt(o.start).text.substr(o.start.character).match(/^(\\s*)/),u=a?a[1].length:0;let c;o=new r.Range(o.start.line,o.start.character+u,o.end.line,o.end.character);let l=n.document.getText(o);if(e)c=l.split(\"\\n\").map(e=>e.trim());else{const e=n.document.lineAt(o.start).text.match(/^(\\s*)/),t=e?e[1]:\"\";c=o.isSingleLine?[l]:[\"\\n\\t\"+l.split(\"\\n\"+t).join(\"\\n\\t\")+\"\\n\"]}return{previewRange:o,originalRange:o,originalContent:l,textToWrapInPreview:c=c.map(e=>e.replace(/(\\$\\d)/g,\"\\\\$1\"))}});function h(){return n.edit(e=>{for(const t of l)e.replace(t.previewRange,t.originalContent),t.previewRange=t.originalRange},{undoStopBefore:!1,undoStopAfter:!1})}function m(t,i){if(!t||!t.trim()||!c.isAbbreviationValid(o,t))return a?h().then(()=>!1):Promise.resolve(a);let s=c.extractAbbreviationFromText(t);if(!s)return Promise.resolve(a);s.abbreviation;let{abbreviation:u,filter:p}=s;if(i){return(a?h():Promise.resolve()).then(()=>{const t=l.map(t=>{let n,r=t.originalRange;return n=e?t.textToWrapInPreview:r.isSingleLine?[\"$TM_SELECTED_TEXT\"]:[\"\\n\\t$TM_SELECTED_TEXT\\n\"],{syntax:o||\"\",abbreviation:u,rangeToReplace:r,textToWrap:n,filter:p}});return f(n,t,!e).then(()=>!0)})}return function(e){let t=new r.Range(0,0,0,0),i=new r.Range(0,0,0,0),o=0;return n.edit(s=>{for(let a=0;a<l.length;a++){const u=d(e[a])||\"\";if(!u)break;const c=l[a].previewRange,f=(n.document.getText(new r.Range(c.start.line,0,c.start.line,c.start.character)).match(/^(\\s*)/)||[\"\",\"\"])[1];let p=u.replace(/\\n/g,\"\\n\"+f);p=(p=p.replace(/\\$\\{[\\d]*\\}/g,\"|\")).replace(/\\$\\{[\\d]*(:[^}]*)?\\}/g,e=>e.replace(/^\\$\\{[\\d]*:/,\"\").replace(\"}\",\"\")),s.replace(c,p);const h=p.split(\"\\n\"),m=c.end.line-c.start.line+1,g=h.length-m;let v=c.start.line+o,w=c.start.character;const b=c.end.line+o+g;let x=h[h.length-1].length;a>0&&b===i.end.line?x+=w=i.end.character+(c.start.character-t.end.character):a>0&&v===i.end.line?w=i.end.character+(c.start.character-t.end.character):1===h.length&&(x+=c.start.character),t=l[a].previewRange,l[a].previewRange=i=new r.Range(v,w,b,x),o+=g}},{undoStopBefore:!1,undoStopAfter:!1})}(l.map(e=>({syntax:o||\"\",abbreviation:u,rangeToReplace:e.originalRange,textToWrap:e.textToWrapInPreview,filter:p})))}return(t&&t.abbreviation?Promise.resolve(t.abbreviation):r.window.showInputBox({prompt:\"Enter Abbreviation\",validateInput:function(e){return e!==u&&(u=e,m(e,!1).then(e=>{\"boolean\"==typeof e&&(a=e)})),\"\"}})).then(e=>m(e,!0))}function c(){return!0===r.workspace.getConfiguration(\"emmet\").triggerExpansionOnTab?r.commands.executeCommand(\"tab\"):Promise.resolve(!0)}function l(e,t,n,o,a,u){if(i.isStyleSheet(o)){if(t&&(t.comments||[]).some(e=>a.isAfterOrEqual(e.start)&&a.isBeforeOrEqual(e.end)))return!1;if(!n)return!0;if(\"sass\"!==o&&\"stylus\"!==o&&\"property\"===n.type){if(n.parent&&\"rule\"!==n.parent.type&&\"at-rule\"!==n.parent.type)return!1;const t=e.getText(new r.Range(u.start.line,u.start.character,u.end.line,u.end.character)),i=n;if(i.terminatorToken&&i.separator&&a.isAfterOrEqual(i.separatorToken.end)&&a.isBeforeOrEqual(i.terminatorToken.start)&&-1===t.indexOf(\":\"))return s.test(t)||\"!\"===t;if(!i.terminatorToken&&i.separator&&a.isAfterOrEqual(i.separatorToken.end)&&-1===t.indexOf(\":\"))return s.test(t)||\"!\"===t;if(s.test(t)||\"!\"===t)return!1}if(\"rule\"!==n.type&&\"at-rule\"!==n.type)return!0;const i=n;return!!a.isAfter(i.contentStartToken.end)||!(!i.parent||\"rule\"!==i.parent.type&&\"at-rule\"!==i.parent.type||!i.selectorToken||a.line===i.selectorToken.end.line||i.selectorToken.start.character!==u.start.character||i.selectorToken.start.line!==u.start.line)}const c=n;let l=new r.Position(0,0);if(c){if(\"script\"===c.name){const e=(c.attributes||[]).filter(e=>\"type\"===e.name.toString())[0],t=e?e.value.toString():\"\";return i.allowedMimeTypesInScriptTag.indexOf(t)>-1||!(t&&\"application/javascript\"!==t&&\"text/javascript\"!==t)&&!!p({language:\"javascript\"})}const e=i.getInnerRange(c);if(!e||!e.contains(a))return!1;l=e.start;let t=c.firstChild;for(;t&&!t.end.isAfter(a);)l=t.end,t=t.nextSibling}let f=e.getText(new r.Range(l.line,l.character,u.start.line,u.start.character));if(f.length>500&&(f=f.substr(f.length-500)),!f.trim())return!0;let d=!0,h=!1,m=f.length-1;if(\"<\"===f[m])return!1;for(;m>=0;){const e=f[m];if(m--,h||!/\\s/.test(e))if(\"?\"!==e||\"<\"!==f[m]){if(/\\s/.test(e)&&\"<\"===f[m])m--;else if(\"<\"===e||\">\"===e)if(m>=0&&\"\\\\\"===f[m])m--;else{if(\">\"===e){if(m>=0&&\"=\"===f[m])continue;break}if(\"<\"===e){d=!h;break}}}else m--;else h=!0}return d}function f(e,t,n){if(!t||0===t.length)return Promise.resolve(!1);let i=[];if(!n)return t.sort((e,t)=>t.rangeToReplace.start.compareTo(e.rangeToReplace.start)).forEach(t=>{let n=d(t);n&&i.push(e.insertSnippet(new r.SnippetString(n),t.rangeToReplace,{undoStopBefore:!1,undoStopAfter:!1}))}),0===i.length?Promise.resolve(!1):Promise.all(i).then(()=>Promise.resolve(!0));let o=d(t[0]),s=t.map(e=>new r.Range(e.rangeToReplace.start.line,e.rangeToReplace.start.character,e.rangeToReplace.end.line,e.rangeToReplace.end.character));return o?e.insertSnippet(new r.SnippetString(o),s):Promise.resolve(!1)}function d(e){const t=i.getEmmetHelper(),n=t.getExpandOptions(e.syntax,i.getEmmetConfiguration(e.syntax),e.filter);let s;e.textToWrap&&(e.filter&&e.filter.indexOf(\"t\")>-1&&(e.textToWrap=e.textToWrap.map(e=>e.replace(o,\"\").trim())),n.text=e.textToWrap,e.rangeToReplace.isSingleLine||(n.profile.inlineBreak=1));try{if(e.textToWrap){let r=t.parseAbbreviation(e.abbreviation,n);if(e.rangeToReplace.isSingleLine&&1===e.textToWrap.length){let e=r;for(;e&&e.children&&e.children.length>0;)e=e.children[e.children.length-1];!e||-1!==a.indexOf(e.name)||n.profile.hasOwnProperty(\"format\")&&!n.profile.format||(e.value=\"\\n\\t\"+e.value+\"\\n\")}s=(s=t.expandAbbreviation(r,n)).replace(\"\\\\$TM_SELECTED_TEXT\",\"$TM_SELECTED_TEXT\")}else s=t.expandAbbreviation(e.abbreviation,n)}catch(e){r.window.showErrorMessage(\"Failed to expand abbreviation\")}return s}function p(e){const t=i.getMappingForIncludedLanguages(),n=e.language,o=e.parentMode,s=r.workspace.getConfiguration(\"emmet\").excludeLanguages?r.workspace.getConfiguration(\"emmet\").excludeLanguages:[];if(s.indexOf(n)>-1)return;let a=i.getEmmetMode(t[n]?t[n]:n,s);return a||(a=i.getEmmetMode(t[o]?t[o]:o,s)),a}t.wrapWithAbbreviation=function(e){return u(!1,e)},t.wrapIndividualLinesWithAbbreviation=function(e){return u(!0,e)},t.expandEmmetAbbreviation=function(e){if(!i.validate()||!r.window.activeTextEditor)return c();if((e=e||{}).language){if((r.workspace.getConfiguration(\"emmet\").excludeLanguages?r.workspace.getConfiguration(\"emmet\").excludeLanguages:[]).indexOf(r.window.activeTextEditor.document.languageId)>-1)return c()}else e.language=r.window.activeTextEditor.document.languageId;const t=p(e);if(!t)return c();const n=r.window.activeTextEditor;let o,s=!0===r.workspace.getConfiguration(\"emmet\").optimizeStylesheetParsing;if(o=1===n.selections.length&&i.isStyleSheet(n.document.languageId)&&s&&n.document.lineCount>1e3?i.parsePartialStylesheet(n.document,n.selection.isReversed?n.selection.anchor:n.selection.active):i.parseDocument(n.document,!1),!0===r.workspace.getConfiguration(\"emmet\").triggerExpansionOnTab&&n.selections.find(e=>!e.isEmpty))return c();let a,u=[],d=!0;const h=i.getEmmetHelper();let m=n.selections.slice(0);return m.sort((e,t)=>{const n=e.isReversed?e.anchor:e.active,r=t.isReversed?t.anchor:t.active;return-1*n.compareTo(r)}),m.forEach(e=>{let s=e.isReversed?e.anchor:e.active,[c,f,p]=((e,t,i,o)=>{let s=t,a=e.getText(s);if(!s.isEmpty){let e=h.extractAbbreviationFromText(a);return e?[s,e.abbreviation,e.filter]:[null,\"\",\"\"]}const u=n.document.lineAt(i.line).text.substr(0,i.character);if(\"html\"===o){let e=u.match(/<(\\w+)$/);if(e)return a=e[1],[s=new r.Range(i.translate(0,-(a.length+1)),i),a,\"\"]}let c=h.extractAbbreviation(n.document,i,!1);if(!c)return[null,\"\",\"\"];let{abbreviationRange:l,abbreviation:f,filter:d}=c;return[new r.Range(l.start.line,l.start.character,l.end.line,l.end.character),f,d]})(n.document,e,s,t);if(!c)return;if(!h.isAbbreviationValid(t,f))return;let m=i.getNode(o,s,!0),g=!0,v=t;if(\"html\"===n.document.languageId)if(i.isStyleAttribute(m,s))v=\"css\",g=!1;else{const e=i.getEmbeddedCssNodeIfAny(n.document,m,s);e&&(m=i.getNode(e,s,!0),v=\"css\")}g&&!l(n.document,o,m,v,s,c)||(a?d&&a!==f&&(d=!1):a=f,u.push({syntax:v,abbreviation:f,rangeToReplace:c,filter:p}))}),f(n,u,d).then(e=>e?Promise.resolve(void 0):c())},t.isValidLocationForEmmetAbbreviation=l},function(e,t,n){\"use strict\";e.exports=[\"bmp\",\"gif\",\"jpg\",\"png\",\"psd\",\"svg\",\"tiff\",\"webp\",\"dds\"]},function(e,t,n){var r={\"./bmp\":11,\"./bmp.js\":11,\"./dds\":12,\"./dds.js\":12,\"./gif\":13,\"./gif.js\":13,\"./jpg\":14,\"./jpg.js\":14,\"./png\":15,\"./png.js\":15,\"./psd\":16,\"./psd.js\":16,\"./svg\":17,\"./svg.js\":17,\"./tiff\":18,\"./tiff.js\":18,\"./webp\":19,\"./webp.js\":19};function i(e){var t=o(e);return n(t)}function o(e){var t=r[e];if(!(t+1)){var n=new Error(\"Cannot find module '\"+e+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}return t}i.keys=function(){return Object.keys(r)},i.resolve=o,e.exports=i,i.id=10},function(e,t,n){\"use strict\";e.exports={detect:function(e){return\"BM\"===e.toString(\"ascii\",0,2)},calculate:function(e){return{width:e.readUInt32LE(18),height:Math.abs(e.readInt32LE(22))}}}},function(e,t,n){\"use strict\";e.exports={detect:function(e){return 542327876===e.readUInt32LE(0)},calculate:function(e){return{height:e.readUInt32LE(12),width:e.readUInt32LE(16)}}}},function(e,t,n){\"use strict\";var r=/^GIF8[79]a/;e.exports={detect:function(e){var t=e.toString(\"ascii\",0,6);return r.test(t)},calculate:function(e){return{width:e.readUInt16LE(6),height:e.readUInt16LE(8)}}}},function(e,t,n){\"use strict\";function r(e,t){return{height:e.readUInt16BE(t),width:e.readUInt16BE(t+2)}}function i(e,t){if(t>e.length)throw new TypeError(\"Corrupt JPG, exceeded buffer limits\");if(255!==e[t])throw new TypeError(\"Invalid JPG, marker table corrupted\")}e.exports={detect:function(e){return\"ffd8\"===e.toString(\"hex\",0,2)},calculate:function(e){var t,n;for(e=e.slice(4);e.length;){if(i(e,t=e.readUInt16BE(0)),192===(n=e[t+1])||193===n||194===n)return r(e,t+5);e=e.slice(t+2)}throw new TypeError(\"Invalid JPG, no size found\")}}},function(e,t,n){\"use strict\";var r=\"PNG\\r\\n\u001a\\n\",i=\"IHDR\",o=\"CgBI\";e.exports={detect:function(e){if(r===e.toString(\"ascii\",1,8)){var t=e.toString(\"ascii\",12,16);if(t===o&&(t=e.toString(\"ascii\",28,32)),t!==i)throw new TypeError(\"invalid png\");return!0}},calculate:function(e){return e.toString(\"ascii\",12,16)===o?{width:e.readUInt32BE(32),height:e.readUInt32BE(36)}:{width:e.readUInt32BE(16),height:e.readUInt32BE(20)}}}},function(e,t,n){\"use strict\";e.exports={detect:function(e){return\"8BPS\"===e.toString(\"ascii\",0,4)},calculate:function(e){return{width:e.readUInt32BE(18),height:e.readUInt32BE(14)}}}},function(e,t,n){\"use strict\";var r=/<svg[^>]+[^>]*>/;var i={root:/<svg\\s[^>]+>/,width:/\\bwidth=(['\"])([^%]+?)\\1/,height:/\\bheight=(['\"])([^%]+?)\\1/,viewbox:/\\bviewBox=(['\"])(.+?)\\1/};function o(e){var t=e.match(i.width),n=e.match(i.height),r=e.match(i.viewbox);return{width:t&&parseInt(t[2],10),height:n&&parseInt(n[2],10),viewbox:r&&function(e){var t=e.split(\" \");return{width:parseInt(t[2],10),height:parseInt(t[3],10)}}(r[2])}}e.exports={detect:function(e){return r.test(e)},calculate:function(e){var t=e.toString(\"utf8\").match(i.root);if(t){var n=o(t[0]);if(n.width&&n.height)return function(e){return{width:e.width,height:e.height}}(n);if(n.viewbox)return function(e){var t=e.viewbox.width/e.viewbox.height;return e.width?{width:e.width,height:Math.floor(e.width/t)}:e.height?{width:Math.floor(e.height*t),height:e.height}:{width:e.viewbox.width,height:e.viewbox.height}}(n)}throw new TypeError(\"invalid svg\")}}},function(e,t,n){\"use strict\";var r=n(7),i=n(46);function o(e,t){var n=i(e,16,8,t);return(i(e,16,10,t)<<16)+n}function s(e){if(e.length>24)return e.slice(12)}e.exports={detect:function(e){var t=e.toString(\"hex\",0,4);return\"49492a00\"===t||\"4d4d002a\"===t},calculate:function(e,t){if(!t)throw new TypeError(\"Tiff doesn't support buffer\");var n=\"BE\"===function(e){var t=e.toString(\"ascii\",0,2);return\"II\"===t?\"LE\":\"MM\"===t?\"BE\":void 0}(e),a=function(e,t){for(var n,r,a,u={};e&&e.length&&(n=i(e,16,0,t),r=i(e,16,2,t),a=i(e,32,4,t),0!==n);)1!==a||3!==r&&4!==r||(u[n]=o(e,t)),e=s(e);return u}(function(e,t,n){var o=i(e,32,4,n),s=1024,a=r.statSync(t).size;o+s>a&&(s=a-o-10);var u=new Buffer(s),c=r.openSync(t,\"r\");return r.readSync(c,u,0,s,o),u.slice(2)}(e,t,n),n),u=a[256],c=a[257];if(!u||!c)throw new TypeError(\"Invalid Tiff, missing tags\");return{width:u,height:c}}}},function(e,t,n){\"use strict\";e.exports={detect:function(e){var t=\"RIFF\"===e.toString(\"ascii\",0,4),n=\"WEBP\"===e.toString(\"ascii\",8,12),r=\"VP8\"===e.toString(\"ascii\",12,15);return t&&n&&r},calculate:function(e){var t=e.toString(\"ascii\",12,16);if(e=e.slice(20,30),\"VP8X\"===t){var n=e[0];return!(0!=(192&n)||0!=(1&n))&&function(e){return{width:1+e.readUIntLE(4,3),height:1+e.readUIntLE(7,3)}}(e)}if(\"VP8 \"===t&&47!==e[0])return function(e){return{width:16383&e.readInt16LE(6),height:16383&e.readInt16LE(8)}}(e);var r=e.toString(\"hex\",3,6);return\"VP8L\"===t&&\"9d012a\"!==r&&function(e){return{width:1+((63&e[2])<<8|e[1]),height:1+((15&e[4])<<10|e[3]<<2|(192&e[2])>>6)}}(e)}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(21),o=n(8),s=n(24),a=n(25),u=n(26),c=n(27),l=n(28),f=n(29),d=n(30),p=n(31),h=n(32),m=n(36),g=n(38),v=n(2),w=n(39),b=n(48);t.activate=function(e){E(e),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.wrapWithAbbreviation\",e=>{o.wrapWithAbbreviation(e)})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.wrapIndividualLinesWithAbbreviation\",e=>{o.wrapIndividualLinesWithAbbreviation(e)})),e.subscriptions.push(r.commands.registerCommand(\"emmet.expandAbbreviation\",e=>{o.expandEmmetAbbreviation(e)})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.removeTag\",()=>s.removeTag())),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.updateTag\",e=>e&&\"string\"==typeof e?a.updateTag(e):r.window.showInputBox({prompt:\"Enter Tag\"}).then(e=>{if(e){const t=a.updateTag(e);return t||!1}return!1}))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.matchTag\",()=>{u.matchTag()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.balanceOut\",()=>{c.balanceOut()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.balanceIn\",()=>{c.balanceIn()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.splitJoinTag\",()=>l.splitJoinTag())),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.mergeLines\",()=>{f.mergeLines()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.toggleComment\",()=>{d.toggleComment()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.nextEditPoint\",()=>{p.fetchEditPoint(\"next\")})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.prevEditPoint\",()=>{p.fetchEditPoint(\"prev\")})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.selectNextItem\",()=>{h.fetchSelectItem(\"next\")})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.selectPrevItem\",()=>{h.fetchSelectItem(\"prev\")})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.evaluateMathExpression\",()=>{m.evaluateMathExpression()})),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.incrementNumberByOneTenth\",()=>g.incrementDecrement(.1))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.incrementNumberByOne\",()=>g.incrementDecrement(1))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.incrementNumberByTen\",()=>g.incrementDecrement(10))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.decrementNumberByOneTenth\",()=>g.incrementDecrement(-.1))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.decrementNumberByOne\",()=>g.incrementDecrement(-1))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.decrementNumberByTen\",()=>g.incrementDecrement(-10))),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.updateImageSize\",()=>w.updateImageSize())),e.subscriptions.push(r.commands.registerCommand(\"editor.emmet.action.reflectCSSValue\",()=>b.reflectCssValue())),v.updateEmmetExtensionsPath(),e.subscriptions.push(r.workspace.onDidChangeConfiguration(t=>{t.affectsConfiguration(\"emmet.includeLanguages\")&&E(e),t.affectsConfiguration(\"emmet.extensionsPath\")&&v.updateEmmetExtensionsPath()}))};const x=new Map,y=new Map;function E(e){let t=new i.DefaultCompletionItemProvider,n=v.getMappingForIncludedLanguages();Object.keys(n).forEach(i=>{if(x.has(i)&&x.get(i)===n[i])return;if(x.has(i)){const e=y.get(i);e&&e.dispose(),x.delete(i),y.delete(i)}const o=r.languages.registerCompletionItemProvider([{language:i,scheme:\"file\"},{language:i,scheme:\"untitled\"}],t,...v.LANGUAGE_MODES[n[i]]);e.subscriptions.push(o),x.set(i,n[i]),y.set(i,o)}),Object.keys(v.LANGUAGE_MODES).forEach(n=>{if(!x.has(n)){const i=r.languages.registerCompletionItemProvider([{language:n,scheme:\"file\"},{language:n,scheme:\"untitled\"}],t,...v.LANGUAGE_MODES[n]);e.subscriptions.push(i),x.set(n,n),y.set(n,i)}})}t.deactivate=function(){}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(8),o=n(2);t.DefaultCompletionItemProvider=class{provideCompletionItems(e,t,n,r){const i=this.provideCompletionItemsInternal(e,t,r);if(i)return i.then(e=>{if(!e||!e.items.length)return this.lastCompletionType=void 0,e;const t=e.items[0],n=t.documentation?t.documentation.toString():\"\";return n.startsWith(\"<\")?this.lastCompletionType=\"html\":n.indexOf(\":\")>0&&n.endsWith(\";\")?this.lastCompletionType=\"css\":this.lastCompletionType=void 0,e});this.lastCompletionType=void 0}provideCompletionItemsInternal(e,t,n){const s=r.workspace.getConfiguration(\"emmet\"),a=s.excludeLanguages?s.excludeLanguages:[];if(a.indexOf(e.languageId)>-1)return;const u=o.getMappingForIncludedLanguages(),c=!!u[e.languageId];let l=o.getEmmetMode(c?u[e.languageId]:e.languageId,a);if(!l||\"never\"===s.showExpandedAbbreviation||(c||\"jsx\"===l)&&\"always\"!==s.showExpandedAbbreviation)return;const f=o.getEmmetHelper();let d=\"html\"===l||\"jsx\"===l||\"xml\"===l,p=void 0,h=null;if(\"html\"===e.languageId){if(n.triggerKind===r.CompletionTriggerKind.TriggerForIncompleteCompletions)switch(this.lastCompletionType){case\"html\":d=!1;break;case\"css\":d=!1,l=\"css\"}if(d)if(p=o.parseDocument(e,!1),h=o.getNode(p,t,!0),o.isStyleAttribute(h,t))l=\"css\",d=!1;else{const n=o.getEmbeddedCssNodeIfAny(e,h,t);n&&(h=o.getNode(n,t,!0),l=\"css\")}}const m=f.extractAbbreviation(e,t,!o.isStyleSheet(l));if(!m||!f.isAbbreviationValid(l,m.abbreviation))return;if(o.isStyleSheet(e.languageId)&&n.triggerKind!==r.CompletionTriggerKind.TriggerForIncompleteCompletions){if(d=!0,!(p=!0===r.workspace.getConfiguration(\"emmet\").optimizeStylesheetParsing&&e.lineCount>1e3?o.parsePartialStylesheet(e,t):o.parseDocument(e,!1)))return;h=o.getNode(p,t,!0)}if(d&&!i.isValidLocationForEmmetAbbreviation(e,p,h,l,t,m.abbreviationRange))return;let g=Promise.resolve();if(!o.isStyleSheet(l)&&(\"javascript\"===e.languageId||\"javascriptreact\"===e.languageId||\"typescript\"===e.languageId||\"typescriptreact\"===e.languageId)){let t=m.abbreviation;g=t.startsWith(\"this.\")?Promise.resolve(!0):r.commands.executeCommand(\"vscode.executeDocumentSymbolProvider\",e.uri).then(e=>e&&e.find(e=>t===e.name||t.startsWith(e.name+\".\")&&!/>|\\*|\\+/.test(t)))}return g.then(n=>{if(n)return;let i=f.doComplete(e,t,l,o.getEmmetConfiguration(l)),a=[];return i&&i.items&&i.items.forEach(e=>{let t=new r.CompletionItem(e.label);t.documentation=e.documentation,t.detail=e.detail,t.insertText=new r.SnippetString(e.textEdit.newText);let n=e.textEdit.range;t.range=new r.Range(n.start.line,n.start.character,n.end.line,n.end.character),t.filterText=e.filterText,t.sortText=e.sortText,!0===s.showSuggestionsAsSnippets&&(t.kind=r.CompletionItemKind.Snippet),a.push(t)}),new r.CompletionList(a,!0)})}}},function(e,t,n){\"use strict\";n.r(t),n.d(t,\"defaultOptions\",function(){return j}),n.d(t,\"match\",function(){return M});var r=n(3),i=n(0);class o{constructor(e,t,n,r){this.stream=e,this.type=t,this.open=n,this.close=r,this.children=[],this.parent=null}get name(){return\"tag\"===this.type&&this.open?this.open&&this.open.name&&this.open.name.value:\"#\"+this.type}get attributes(){return this.open&&this.open.attributes}get start(){return this.open&&this.open.start}get end(){return this.close?this.close.end:this.open&&this.open.end}get firstChild(){return this.children[0]}get nextSibling(){const e=this.getIndex();return-1!==e?this.parent.children[e+1]:null}get previousSibling(){const e=this.getIndex();return-1!==e?this.parent.children[e-1]:null}getIndex(){return this.parent?this.parent.children.indexOf(this):-1}addChild(e){return this.removeChild(e),this.children.push(e),e.parent=this,this}removeChild(e){const t=this.children.indexOf(e);return-1!==t&&(this.children.splice(t,1),e.parent=null),this}}var s=function(e,t,n){return\"function\"==typeof t?function(e,t){const n=e.pos;if(e.eatWhile(t))return new a(e,n,e.pos);e.pos=n}(e,t):new a(e,t,n)};class a{constructor(e,t,n){this.stream=e,this.start=null!=t?t:e.start,this.end=null!=n?n:e.pos,this._value=null}get value(){if(null===this._value){const e=this.stream.start,t=this.stream.pos;this.stream.start=this.start,this.stream.pos=this.end,this._value=this.stream.current(),this.stream.start=e,this.stream.pos=t}return this._value}toString(){return this.value}valueOf(){return`${this.value} [${this.start}; ${this.end}]`}}const u={throws:!0};var c=function(e){const t=e.pos;if(Object(i.a)(e,60,62,u)||Object(i.a)(e,91,93,u)||Object(i.a)(e,40,41,u)||Object(i.a)(e,123,125,u))return s(e,t)};const l=47,f=61,d=62;function p(e){return c(e)||s(e,m)}function h(e){const t=e.pos;if(Object(i.b)(e)){const n=e.pos;let r,i;e.pos=t,e.next(),r=e.start=e.pos,e.pos=n,e.backUp(1),i=e.pos;const o=s(e,r,i);return e.pos=n,o}return c(e)||function(e){return s(e,v)}(e)}function m(e){return e!==f&&!g(e)&&!Object(i.g)(e)}function g(e){return e===d||e===l}function v(e){return!(isNaN(e)||Object(i.f)(e)||Object(i.g)(e)||g(e))}const w=45,b=46,x=58,y=95;var E=function(e){const t=e.pos;if(e.eat(60)){const n={type:e.eat(47)?\"close\":\"open\"};if((n.name=function(e){return s(e,T)}(e))&&(\"close\"!==n.type&&(n.attributes=function(e){const t=[];let n;for(;!e.eof();)if(e.eatWhile(i.g),(n={start:e.pos}).name=p(e))e.eat(f)?n.value=h(e):n.boolean=!0,n.end=e.pos,t.push(n);else{if(g(e.peek()))break;e.next()}return t}(e),e.eatWhile(i.g),n.selfClosing=e.eat(47)),e.eat(62)))return Object.assign(s(e,t),n)}return e.pos=t,null};function T(e){return Object(i.d)(e)||e===x||e===b||e===w||e===y}function S(e,t){const n=e.pos;for(let r=0;r<t.length;r++)if(!e.eat(t[r]))return e.pos=n,!1;return e.start=n,!0}function k(e,t,n,r){const i=e.pos;if(S(e,t)){for(;!e.eof();){if(S(e,n))return!0;e.next()}return!!r||(e.pos=i,!1)}return e.pos=i,null}function C(e){return e.split(\"\").map(e=>e.charCodeAt(0))}const O=C(\"\\x3c!--\"),I=C(\"--\\x3e\");var _=function(e){const t=e.pos;if(k(e,O,I,!0)){const n=s(e,t);return n.type=\"comment\",n}return null};const A=C(\"<![CDATA[\"),R=C(\"]]>\");var P=function(e){const t=e.pos;if(k(e,A,R,!0)){const n=s(e,t);return n.type=\"cdata\",n}return null};const j={xml:!1,special:[\"script\",\"style\"],empty:[\"img\",\"meta\",\"link\",\"br\",\"base\",\"hr\",\"area\",\"wbr\",\"col\",\"embed\",\"input\",\"param\",\"source\",\"track\"]};function M(e){if(60===e.peek())return _(e)||P(e)||E(e)}function N(e,t){const n=e.pos;for(;!e.eof();){if(S(e,t))return e.pos=e.start,E(e);e.next()}return e.pos=n,null}function B(e){return e.name?e.name.value.toLowerCase():`#${e.type}`}function L(e){return e[e.length-1]}t.default=function(e,t){t=Object.assign({},j,t);const n=\"string\"==typeof e?new r.a(e):e,i=new o(n,\"root\"),s=new Set(t.empty),a=t.special.reduce((e,t)=>e.set(t,C(`</${t}>`)),new Map),u=(e,n)=>e.selfClosing||!t.xml&&s.has(n);let c,l,f,d=[i];for(;!n.eof();)if(c=M(n))if(f=B(c),\"open\"===c.type)l=new o(n,\"tag\",c),L(d).addChild(l),a.has(f)?l.close=N(n,a.get(f)):u(c,f)||d.push(l);else if(\"close\"===c.type){for(let e=d.length-1;e>0;e--)if(d[e].name.toLowerCase()===f){d[e].close=c,d=d.slice(0,e);break}}else L(d).addChild(new o(n,c.type,c));else n.next();return i}},function(e,t){e.exports=require(\"vscode-emmet-helper\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);t.removeTag=function(){if(!i.validate(!1)||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=i.parseDocument(e.document);if(!t)return;let n=\"\";const o=e.options.tabSize?+e.options.tabSize:0;for(let e=0;e<o;e++)n+=\" \";let s=[];return e.selections.reverse().forEach(o=>{s=s.concat(function(e,t,n,o){let s=i.getHtmlNode(e.document,t,n.start,!0);if(!s)return[];let a=new r.Range(s.open.start,s.open.end),u=null;s.close&&(u=new r.Range(s.close.start,s.close.end));let c=[a];if(u){for(let t=a.start.line+1;t<=u.start.line;t++){let n=e.document.lineAt(t).text;n.startsWith(\"\\t\")?c.push(new r.Range(t,0,t,1)):n.startsWith(o)&&c.push(new r.Range(t,0,t,o.length))}c.push(u)}return c}(e,t,o,n))}),e.edit(e=>{s.forEach(t=>{e.replace(t,\"\")})})}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);t.updateTag=function(e){if(!i.validate(!1)||!r.window.activeTextEditor)return;let t=r.window.activeTextEditor,n=i.parseDocument(t.document);if(!n)return;let o=[];return t.selections.reverse().forEach(e=>{o=o.concat(function(e,t,n){let o=i.getHtmlNode(e.document,n,t.start,!0);if(!o)return[];let s=o.open.start.translate(0,1),a=s.translate(0,o.name.length),u=[new r.Range(s,a)];if(o.close){let e=o.close.start.translate(0,2),t=o.close.end.translate(0,-1);u.push(new r.Range(e,t))}return u}(t,e,n))}),t.edit(t=>{o.forEach(n=>{t.replace(n,e)})})}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);t.matchTag=function(){if(!i.validate(!1)||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=i.parseDocument(e.document);if(!t)return;let n=[];e.selections.forEach(o=>{let s=function(e,t,n){let o=i.getHtmlNode(e.document,n,t,!0);if(!o)return;if(!o.close||t.isAfter(o.open.end)&&t.isBefore(o.close.start))return;let s=t.isBeforeOrEqual(o.open.end)?o.close.start.translate(0,2):o.open.start.translate(0,1);return new r.Selection(s,s)}(e,o.start,t);s&&n.push(s)}),n.length>0&&(e.selections=n,e.revealRange(e.selections[n.length-1]))}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);let o=[],s=!1,a=[];function u(e){if(!i.validate(!1)||!r.window.activeTextEditor)return;const t=r.window.activeTextEditor;let n=i.parseDocument(t.document);if(!n)return;let u=e?c:l,d=[];t.selections.forEach(e=>{let r=u(t.document,e,n);d.push(r)}),f(d,t.selections)||(f(a,t.selections)?e?(o.length||o.push(t.selections),o.push(d)):(s&&o.pop(),d=o.pop()||d):o=e?[t.selections,d]:[],s=e,a=t.selections=d)}function c(e,t,n){let o=i.getHtmlNode(e,n,t.start,!1);if(!o)return t;if(!o.close)return new r.Selection(o.start,o.end);let s=new r.Selection(o.open.end,o.close.start),a=new r.Selection(o.start,o.end);return s.contains(t)&&!s.isEqual(t)?s:a.contains(t)&&!a.isEqual(t)?a:t}function l(e,t,n){let o=i.getHtmlNode(e,n,t.start,!0);if(!o)return t;if(o.close){const e=t.start.isEqual(o.start)&&t.end.isEqual(o.end),n=t.start.isAfter(o.open.start)&&t.start.isBefore(o.open.end),i=t.start.isAfter(o.close.start)&&t.start.isBefore(o.close.end);if(e||n||i)return new r.Selection(o.open.end,o.close.start)}return o.firstChild?t.start.isEqual(o.firstChild.start)&&t.end.isEqual(o.firstChild.end)&&o.firstChild.close?new r.Selection(o.firstChild.open.end,o.firstChild.close.start):new r.Selection(o.firstChild.start,o.firstChild.end):t}function f(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!e[n].isEqual(t[n]))return!1;return!0}t.balanceOut=function(){u(!0)},t.balanceIn=function(){u(!1)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);t.splitJoinTag=function(){if(!i.validate(!1)||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=i.parseDocument(e.document);return t?e.edit(n=>{e.selections.reverse().forEach(o=>{let s=i.getHtmlNode(e.document,t,o.start,!0);if(s){let t=function(e,t){let n,o;if(t.close){let s=t.open.end.translate(0,-1),a=t.end;n=new r.Range(s,a),o=\"/>\";const u=i.getEmmetMode(e.languageId,[])||\"\",c=i.getEmmetConfiguration(u);u&&c.syntaxProfiles[u]&&(\"xhtml\"===c.syntaxProfiles[u].selfClosingStyle||\"xhtml\"===c.syntaxProfiles[u].self_closing_tag)&&(o=\" \"+o)}else{let i=e.getText(new r.Range(t.start,t.end)),s=i.match(/(\\s*\\/)?>$/),a=t.end,u=s?a.translate(0,-s[0].length):a;n=new r.Range(u,a),o=`></${t.name}>`}return new r.TextEdit(n,o)}(e.document,s);n.replace(t.range,t.newText)}})}):void 0}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);t.mergeLines=function(){if(!i.validate(!1)||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=i.parseDocument(e.document);return t?e.edit(n=>{e.selections.reverse().forEach(o=>{let s=function(e,t,n){let o,s;if(t.isEmpty?o=s=i.getNode(n,t.start,!0):(o=i.getNode(n,t.start,!0),s=i.getNode(n,t.end,!0)),!o||!s||o.start.line===s.end.line)return;let a=new r.Range(o.start,s.end),u=e.lineAt(o.start.line).text.substr(o.start.character);for(let t=o.start.line+1;t<=s.end.line;t++)u+=e.lineAt(t).text.trim();return new r.TextEdit(a,u)}(e.document,o,t);s&&n.replace(s.range,s.newText)})}):void 0}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2),o=n(6),s=n(4),a=\"/*\",u=\"*/\",c=\"\\x3c!--\",l=\"--\\x3e\";function f(e,t){let n=e.isReversed?e.active:e.anchor,o=e.isReversed?e.anchor:e.active,s=i.getNode(t,n,!0),c=i.getNode(t,o,!0);e.isEmpty?s&&(n=s.start,o=s.end,e=new r.Selection(n,o)):(n=function(e,t,n){for(const e of n.comments){let n=new r.Range(e.start,e.end);if(n.contains(t))return t}if(!e)return t;if(\"property\"===e.type)return e.start;const i=e;if(t.isBefore(i.contentStartToken.end)||!i.firstChild)return i.start;if(t.isBefore(i.firstChild.start))return t;let o=i.firstChild;for(;o.nextSibling&&t.isAfter(o.end);)o=o.nextSibling;return o.start}(s,n,t),o=function(e,t,n){for(const e of n.comments){let n=new r.Range(e.start,e.end);if(n.contains(t))return t}if(!e)return t;if(\"property\"===e.type)return e.end;const i=e;if(t.isEqual(i.contentEndToken.end)||!i.firstChild)return i.end;if(t.isAfter(i.children[i.children.length-1].end))return t;let o=i.children[i.children.length-1];for(;o.previousSibling&&t.isBefore(o.start);)o=o.previousSibling;return o.end}(c,o,t),e=new r.Selection(n,o));let l=[],f=[];return t.comments.forEach(t=>{let n=new r.Range(t.start,t.end);e.intersection(n)&&(l.push(n),f.push(new r.TextEdit(new r.Range(t.start,t.start.translate(0,a.length)),\"\")),f.push(new r.TextEdit(new r.Range(t.end.translate(0,-u.length),t.end),\"\")))}),f.length>0?f:[new r.TextEdit(new r.Range(e.start,e.start),a),new r.TextEdit(new r.Range(e.end,e.end),u)]}t.toggleComment=function(){if(!i.validate()||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=i.parseDocument(e.document);return t?e.edit(n=>{let a=[];e.selections.reverse().forEach(n=>{let u=i.isStyleSheet(e.document.languageId)?f(n,t):function(e,t,n){const a=t.isReversed?t.active:t.anchor,u=t.isReversed?t.anchor:t.active;let d=i.getHtmlNode(e,n,a,!0),p=i.getHtmlNode(e,n,u,!0);if(!d||!p)return[];if(i.sameNodes(d,p)&&\"style\"===d.name&&d.open.end.isBefore(a)&&d.close.start.isAfter(u)){let n=new s.DocumentStreamReader(e,d.open.end,new r.Range(d.open.end,d.close.start)),i=o.default(n);return f(t,i)}let h=i.getNodesInBetween(d,p),m=[];return h.forEach(t=>{m=m.concat(function e(t,n){let i=[];return\"comment\"===t.type?(i.push(new r.TextEdit(new r.Range(t.start,t.start.translate(0,c.length)),\"\")),i.push(new r.TextEdit(new r.Range(t.end.translate(0,-l.length),t.end),\"\")),i):(t.children.forEach(t=>{i=i.concat(e(t,n))}),i)}(t,e))}),\"comment\"===d.type?m:(m.push(new r.TextEdit(new r.Range(h[0].start,h[0].start),c)),m.push(new r.TextEdit(new r.Range(h[h.length-1].end,h[h.length-1].end),l)),m)}(e.document,n,t);u.length>0&&a.push(u)}),a.sort((e,t)=>{let n=e[0].range.start.line-t[0].range.start.line;return 0===n?e[0].range.start.character-t[0].range.start.character:n});let u=new r.Position(0,0);for(const e of a)e[0].range.end.isAfterOrEqual(u)&&e.forEach(e=>{n.replace(e.range,e.newText),u=e.range.end})}):void 0}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);function o(e,t,n,i){let o=t.document.lineAt(e),s=o.text;if(e!==n.line&&o.isEmptyOrWhitespace)return new r.Selection(e,s.length,e,s.length);e===n.line&&\"prev\"===i&&(s=s.substr(0,n.character));let a=\"next\"===i?s.indexOf('\"\"',e===n.line?n.character:0):s.lastIndexOf('\"\"'),u=\"next\"===i?s.indexOf(\"><\",e===n.line?n.character:0):s.lastIndexOf(\"><\"),c=-1;return(c=a>-1&&u>-1?\"next\"===i?Math.min(a,u):Math.max(a,u):a>-1?a:u)>-1?new r.Selection(e,c+1,e,c+1):void 0}t.fetchEditPoint=function(e){if(!i.validate()||!r.window.activeTextEditor)return;const t=r.window.activeTextEditor;let n=[];t.selections.forEach(r=>{let i=\"next\"===e?function(e,t){for(let n=e.anchor.line;n<t.document.lineCount;n++){let r=o(n,t,e.anchor,\"next\");if(r)return r}return e}(r,t):function(e,t){for(let n=e.anchor.line;n>=0;n--){let r=o(n,t,e.anchor,\"prev\");if(r)return r}return e}(r,t);n.push(i)}),t.selections=n,t.revealRange(t.selections[t.selections.length-1])}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2),o=n(33),s=n(35);t.fetchSelectItem=function(e){if(!i.validate()||!r.window.activeTextEditor)return;const t=r.window.activeTextEditor;let n=i.parseDocument(t.document);if(!n)return;let a=[];t.selections.forEach(r=>{const u=r.isReversed?r.active:r.anchor,c=r.isReversed?r.anchor:r.active;let l;l=i.isStyleSheet(t.document.languageId)?\"next\"===e?s.nextItemStylesheet(u,c,n):s.prevItemStylesheet(u,c,n):\"next\"===e?o.nextItemHTML(u,c,t,n):o.prevItemHTML(u,c,t,n),a.push(l||r)}),t.selections=a,t.revealRange(t.selections[t.selections.length-1])}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2),o=n(34);function s(e){if(e&&e.open){let t=e.open.start.translate(0,1),n=t.translate(0,e.name.length);return new r.Selection(t,n)}}t.nextItemHTML=function(e,t,n,a){let u=i.getHtmlNode(n.document,a,t,!1),c=void 0;if(u){if(\"comment\"!==u.type){if(t.isBefore(u.open.start.translate(0,u.name.length)))return s(u);if(t.isBefore(u.open.end)){let n=function(e,t,n){if(n.attributes&&0!==n.attributes.length&&\"comment\"!==n.type)for(const s of n.attributes){if(t.isBefore(s.start))return new r.Selection(s.start,s.end);if(!s.value||s.value.start.isEqual(s.value.end))continue;if(e.isEqual(s.start)&&t.isEqual(s.end)||t.isBefore(s.value.start))return new r.Selection(s.value.start,s.value.end);if(-1===s.value.toString().indexOf(\" \"))continue;let n=void 0;if(e.isEqual(s.value.start)&&t.isEqual(s.value.end)&&(n=-1),void 0===n&&t.isBefore(s.end)&&(n=t.character-s.value.start.character-1),void 0!==n){let[e,t]=i.findNextWord(s.value.toString(),n);if(!o.isNumber(e)||!o.isNumber(t))return;if(e>=0&&t>=0){const n=s.value.start.translate(0,e),i=s.value.start.translate(0,t);return new r.Selection(n,i)}}}}(e,t,u);if(n)return n}for(c=u.firstChild;c&&(t.isAfterOrEqual(c.end)||\"comment\"===c.type);)c=c.nextSibling}for(;!c&&u;)u.nextSibling?\"comment\"!==u.nextSibling.type?c=u.nextSibling:u=u.nextSibling:u=u.parent;return c&&s(c)}},t.prevItemHTML=function(e,t,n,a){let u=i.getHtmlNode(n.document,a,e,!1),c=void 0;if(!u)return;if(\"comment\"!==u.type&&e.translate(0,-1).isAfter(u.open.start))if(e.isBefore(u.open.end)||!u.firstChild||t.isBeforeOrEqual(u.firstChild.start))c=u;else{c=u.firstChild;let t=void 0;for(;c.nextSibling&&e.isAfterOrEqual(c.nextSibling.end);)c&&\"comment\"!==c.type&&(t=c),c=c.nextSibling;c=i.getDeepestNode(c&&\"comment\"!==c.type?c:t)}for(;!c&&u;)u.previousSibling?\"comment\"!==u.previousSibling.type?c=i.getDeepestNode(u.previousSibling):u=u.previousSibling:c=u.parent;if(!c)return;let l=function(e,t,n){if(n.attributes&&0!==n.attributes.length&&\"comment\"!==n.type)for(let s=n.attributes.length-1;s>=0;s--){let a=n.attributes[s];if(e.isBeforeOrEqual(a.start))continue;if(!a.value||a.value.start.isEqual(a.value.end)||e.isBefore(a.value.start))return new r.Selection(a.start,a.end);if(e.isEqual(a.value.start))return t.isAfterOrEqual(a.value.end)?new r.Selection(a.start,a.end):new r.Selection(a.value.start,a.value.end);let u=e.isAfter(a.value.end)?a.value.toString().length:e.character-a.value.start.character,[c,l]=i.findPrevWord(a.value.toString(),u);if(!o.isNumber(c)||!o.isNumber(l))return;if(c>=0&&l>=0){const e=a.value.start.translate(0,c),t=a.value.start.translate(0,l);return new r.Selection(e,t)}}}(e,t,c);return l||s(c)}},function(e,t){e.exports=require(\"util\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2);function o(e){if(!e)return;let t=\"rule\"===e.type?e.selectorToken:e;return new r.Selection(t.start,t.end)}function s(e,t,n,o,s){if(!e||\"property\"!==e.type)return;const a=e;let u=a.valueToken.stream.substring(a.valueToken.start,a.valueToken.end);if(o=o||\"prev\"===s&&t.isEqual(a.valueToken.start)&&n.isBefore(a.valueToken.end))return new r.Selection(a.valueToken.start,a.valueToken.end);let c=-1;if(\"prev\"===s){if(t.isEqual(a.valueToken.start))return;c=t.isAfter(a.valueToken.end)?u.length:t.character-a.valueToken.start.character}if(\"next\"===s){if(n.isEqual(a.valueToken.end)&&(t.isAfter(a.valueToken.start)||-1===u.indexOf(\" \")))return;c=n.isEqual(a.valueToken.end)?-1:n.character-a.valueToken.start.character-1}let[l,f]=\"prev\"===s?i.findPrevWord(u,c):i.findNextWord(u,c);if(!l&&!f)return;const d=a.valueToken.start.translate(0,l),p=a.valueToken.start.translate(0,f);return new r.Selection(d,p)}t.nextItemStylesheet=function(e,t,n){let r=i.getNode(n,t,!0);if(r||(r=n),!r)return;if(\"property\"===r.type&&e.isEqual(r.start)&&t.isEqual(r.end))return s(r,e,t,!0,\"next\");if(\"property\"===r.type&&e.isAfterOrEqual(r.valueToken.start)&&t.isBeforeOrEqual(r.valueToken.end)){let n=s(r,e,t,!1,\"next\");if(n)return n}if(\"rule\"===r.type&&t.isBefore(r.selectorToken.end)||\"property\"===r.type&&t.isBefore(r.valueToken.end))return o(r);let a=r.firstChild;for(;a&&t.isAfterOrEqual(a.end);)a=a.nextSibling;for(;!a&&r;)a=r.nextSibling,r=r.parent;return o(a)},t.prevItemStylesheet=function(e,t,n){let r=i.getNode(n,e,!1);if(r||(r=n),!r)return;if(\"property\"===r.type&&e.isEqual(r.valueToken.start)&&t.isEqual(r.valueToken.end))return o(r);if(\"property\"===r.type&&e.isAfterOrEqual(r.valueToken.start)&&t.isBeforeOrEqual(r.valueToken.end)){let n=s(r,e,t,!1,\"prev\");if(n)return n}if(\"property\"===r.type||!r.firstChild||\"rule\"===r.type&&e.isBeforeOrEqual(r.firstChild.start))return o(r);let a=r.firstChild;for(;a.nextSibling&&e.isAfterOrEqual(a.nextSibling.end);)a=a.nextSibling;return s(a=i.getDeepestNode(a),e,t,!1,\"prev\")}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(37),o=n(4);t.evaluateMathExpression=function(){if(!r.window.activeTextEditor)return void r.window.showInformationMessage(\"No editor is active\");const e=r.window.activeTextEditor,t=new o.DocumentStreamReader(e.document);e.edit(n=>{e.selections.forEach(e=>{const o=e.isReversed?e.anchor:e.active;t.pos=o;try{const e=String(i.default(t,!0));n.replace(new r.Range(t.pos,o),e)}catch(e){r.window.showErrorMessage(\"Could not evaluate expression\"),console.warn(\"Math evaluation error\",e)}})})}},function(e,t,n){\"use strict\";n.r(t),n.d(t,\"parse\",function(){return C});var r=n(3),i=n(0);function o(e){return e.sof?e.sof():e.pos<=0}const s=46;var a=function(e,t){return t?function(e){const t=e.pos;let n,r=!1,a=!1,u=0;for(;!o(e);){if(e.backUp(1),(n=e.peek())===s&&!r&&a)r=!0;else if(!Object(i.e)(n)){e.next();break}a=!0,u++}if(u){const n=e.pos;return e.start=n,e.pos=t,!0}return e.pos=t,!1}(e):function(e){const t=e.pos;if(e.eat(s)&&e.eatWhile(i.e))return!0;if(e.eatWhile(i.e)&&(!e.eat(s)||e.eatWhile(i.e)))return!0;return e.pos=t,!1}(e)};const u=\"num\",c=\"op1\",l=\"op2\",f=43,d=45,p=42,h=47,m=92,g=40,v=41,w=1,b=2,x=4,y=8,E=16,T=32;class S{constructor(e,t,n){this.type=e,this.value=t,this.priority=n||0}}const k=new S(T);function C(e,t){return t?function(e){let t;\"object\"==typeof e?t=e:(t=new r.a(e)).start=t.pos=e.length;let n,s=0,u=w|y;const c=[];for(;!o(t);)if(a(t,!0))0==(u&w)&&P(\"Unexpected number\",t),c.push(_(t.current())),u=b|E|x,t.pos=t.start;else if(t.backUp(1),N(n=t.peek()))if(j(n)&&u&E&&I(t))M(n)&&c.push(A(n,s)),u=x|y|b|w;else{if(0==(u&b)){t.next();break}c.push(R(n,s)),u=w|y}else if(n===v){if(0==(u&y)){t.next();break}s+=10,u=w|y|x}else if(n===g){if(s-=10,u&T)c.push(k);else if(0==(u&x)){t.next();break}u=b|E|x|T}else if(!Object(i.h)(n)){t.next();break}(s<0||s>=10)&&P('Unmatched \"()\"',t);const l=O(c.reverse());null===l&&P(\"Parity\",t);return t.eatWhile(i.h),l}(e):function(e){const t=\"object\"==typeof e?e:new r.a(e);let n,o=0,s=w|x|E;const u=[];for(;!t.eof();)t.eatWhile(i.h),t.start=t.pos,a(t)?(0==(s&w)&&P(\"Unexpected number\",t),u.push(_(t.current())),s=b|y):N(t.peek())?j(n=t.next())&&s&E?(M(n)&&u.push(A(n,o)),s=w|x|E):(0==(s&b)&&P(\"Unexpected operator\",t),u.push(R(n,o)),s=w|x|E):t.eat(g)?(0==(s&x)&&P('Unexpected \"(\"',t),o+=10,s=w|x|E|T):t.eat(v)?(o-=10,s&T?u.push(k):0==(s&y)&&P('Unexpected \")\"',t),s=b|y|x):P(\"Unknown character\",t);(o<0||o>=10)&&P('Unmatched \"()\"',t);const c=O(u);null===c&&P(\"Parity\",t);return c}(e)}function O(e){const t=[],n=[];let r=0;for(let i,o=0;o<e.length;o++)if((i=e[o]).type===u)n.push(i);else{for(r+=i.type===c?1:2;t.length&&i.priority<=t[t.length-1].priority;)n.push(t.pop());t.push(i)}return r+1===n.length+t.length?n.concat(t.reverse()):null}function I(e){const t=e.pos;let n,r=!0;for(;!o(e);)if(e.backUp(1),n=e.peek(),!Object(i.h)(n)){r=n===g||N(n);break}return e.pos=t,r}function _(e,t){return new S(u,parseFloat(e),t)}function A(e,t){return e===d&&(t+=2),new S(c,e,t)}function R(e,t){return e===p?t+=1:e!==h&&e!==m||(t+=2),new S(l,e,t)}function P(e,t){throw t&&(e+=` at column ${t.start} of expression`),new Error(e)}function j(e){return function(e){return e===f}(e)||M(e)}function M(e){return e===d}function N(e){return e===f||e===d||e===p||e===h||e===m}const B={[d]:e=>-e},L={[f]:(e,t)=>e+t,[d]:(e,t)=>e-t,[p]:(e,t)=>e*t,[h]:(e,t)=>e/t,[m]:(e,t)=>Math.floor(e/t)};t.default=function(e,t){if(Array.isArray(e)||(e=C(e,t)),!e||!e.length)return null;const n=[];let r,i,o;for(let t,s=0,a=e.length;s<a;s++)if((t=e[s]).type===u)n.push(t.value);else if(t.type===l)i=n.pop(),r=n.pop(),o=L[t.value],n.push(o(r,i));else{if(t.type!==c)throw new Error(\"Invalid expression\");r=n.pop(),o=B[t.value],n.push(o(r))}if(n.length>1)throw new Error(\"Invalid Expression (parity)\");return n[0]}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=/[0-9]/;function o(e,t){let n,r=(n=e.match(/\\.(\\d+)$/))?n[1].length:1,i=String((parseFloat(e)+t).toFixed(r)).replace(/\\.0+$/,\"\");return(n=e.match(/^\\-?(0\\d+)/))&&(i=i.replace(/^(\\-?)(\\d+)/,(e,t,r)=>t+\"0\".repeat(Math.max(0,(n?n[1].length:0)-r.length))+r)),/^\\-?\\./.test(e)&&(i=i.replace(/^(\\-?)0+/,\"$1\")),i}function s(e,t){const n=e.lineAt(t.line).text;let o,s=t.character,u=t.character,c=!1,l=!1;for(;s>0;){if(\"-\"===(o=n[--s])){l=!0;break}if(\".\"!==o||c){if(!i.test(o)){s++;break}}else c=!0}for(\"-\"!==n[u]||l||u++;u<n.length;)if(\".\"===(o=n[u++])&&!c&&i.test(n[u]))c=!0;else if(!i.test(o)){u--;break}if(s!==u&&a(n.slice(s,u)))return new r.Range(t.line,s,t.line,u)}function a(e){return!!e&&!isNaN(parseFloat(e))}t.incrementDecrement=function(e){if(!r.window.activeTextEditor)return void r.window.showInformationMessage(\"No editor is active\");const t=r.window.activeTextEditor;return t.edit(n=>{t.selections.forEach(r=>{let i=s(t.document,r.isReversed?r.anchor:r.active);if(!i)return;const u=t.document.getText(i);a(u)&&n.replace(i,o(u,e))})})},t.update=o,t.locate=s},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(5),o=n(40),s=n(2),a=n(47),u=n(6),c=n(4);function l(e,t,n){const u=n(e,t),c=u&&h(u,t);return c?a.locateFile(i.dirname(e.document.fileName),c).then(o.getImageSize).then(i=>{const o=n(e,t);return o&&h(o,t)===c?function(e,t,n,i){const o=t.parent,a=s.getCssPropertyFromRule(o,\"width\"),u=s.getCssPropertyFromRule(o,\"height\"),c=t.separator||\": \",l=function(e,t){let n;if(n=t.previousSibling||t.parent.contentStartToken)return e.document.getText(new r.Range(n.end,t.start));if(n=t.nextSibling||t.parent.contentEndToken)return e.document.getText(new r.Range(t.end,n.start));return\"\"}(e,t);let f=[];t.terminatorToken||f.push(new r.TextEdit(new r.Range(t.end,t.end),\";\"));let d=\"\";a?f.push(new r.TextEdit(new r.Range(a.valueToken.start,a.valueToken.end),`${n}px`)):d+=`${l}width${c}${n}px;`;u?f.push(new r.TextEdit(new r.Range(u.valueToken.start,u.valueToken.end),`${i}px`)):d+=`${l}height${c}${i}px;`;d&&f.push(new r.TextEdit(new r.Range(t.end,t.end),d));return f}(e,o,i.width,i.height):[]}).catch(e=>(console.warn(\"Error while updating image size:\",e),[])):Promise.reject(new Error(\"No valid image source\"))}function f(e,t){const n=s.parseDocument(e.document),r=s.getNode(n,t,!0);return r&&\"img\"===r.name.toLowerCase()?r:null}function d(e,t){const n=s.parseDocument(e.document),r=s.getNode(n,t,!0);return r&&\"property\"===r.type?r:null}function p(e){const t=m(e,\"src\");if(t)return t.value.value}function h(e,t){if(!e)return;const n=function(e,t){for(let n,r=0,i=e.parsedValue.length;r<i;r++)if(s.iterateCSSToken(e.parsedValue[r],e=>\"url\"!==e.type||!e.start.isBeforeOrEqual(t)||!e.end.isAfterOrEqual(t)||(n=e,!1)),n)return n;return}(e,t);if(!n)return;let r=n.item(0);return r&&\"string\"===r.type&&(r=r.item(0)),r&&r.valueOf()}function m(e,t){return t=t.toLowerCase(),e&&e.open.attributes.find(e=>e.name.value.toLowerCase()===t)}t.updateImageSize=function(){if(!s.validate()||!r.window.activeTextEditor)return;const e=r.window.activeTextEditor;let t=e.selections.reverse().map(t=>{let n=t.isReversed?t.active:t.anchor;return s.isStyleSheet(e.document.languageId)?function(e,t){return l(e,t,d)}(e,n):function(e,t){const n=f(e,t),d=n&&p(n);return d?a.locateFile(i.dirname(e.document.fileName),d).then(o.getImageSize).then(n=>{const i=f(e,t);return i&&p(i)===d?function(e,t,n,i){const o=m(t,\"src\"),s=m(t,\"width\"),a=m(t,\"height\"),u=function(e,t){const n=new r.Range(t.value?t.value.end:t.end,t.end);return n.isEmpty?\"\":e.document.getText(n)}(e,o),c=t.attributes[t.attributes.length-1].end;let l=[],f=\"\";return s?l.push(new r.TextEdit(new r.Range(s.value.start,s.value.end),String(n))):f+=` width=${u}${n}${u}`,a?l.push(new r.TextEdit(new r.Range(a.value.start,a.value.end),String(i))):f+=` height=${u}${i}${u}`,f&&l.push(new r.TextEdit(new r.Range(c,c),f)),l}(e,i,n.width,n.height):[]}).catch(e=>(console.warn(\"Error while updating image size:\",e),[])):function(e,t){return l(e,t,e=>{const n=s.parseDocument(e.document),i=s.getNode(n,t,!0);if(i&&\"style\"===i.name&&i.open.end.isBefore(t)&&i.close.start.isAfter(t)){let n=new c.DocumentStreamReader(e.document,i.open.end,new r.Range(i.open.end,i.close.start)),o=u.default(n);const a=s.getNode(o,t,!0);return a&&\"property\"===a.type?a:null}return null})}(e,t)}(e,n)});return Promise.all(t).then(t=>e.edit(e=>{t.forEach(t=>{t.forEach(t=>{e.replace(t.range,t.newText)})})}))}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(5),i=n(41),o=n(42),s=n(43),a=n(44),u=/^https?:/;function c(e,t){const n=e.match(/@(\\d+)x\\./),r=n?+n[1]:1;return{realWidth:t.width,realHeight:t.height,width:Math.floor(t.width/r),height:Math.floor(t.height/r)}}t.getImageSize=function(e){return e=e.replace(/^file:\\/\\//,\"\"),u.test(e)?function(e){return new Promise((t,n)=>{const u=s.parse(e),l=\"https:\"===u.protocol?o.get:i.get;if(!u.pathname)return n(\"Given url doesnt have pathname property\");const f=u.pathname;l(u,e=>{const i=[];let o=0;const s=n=>{try{const i=a(Buffer.concat(n,o));e.removeListener(\"data\",u),e.destroy(),t(c(r.basename(f),i))}catch(e){}},u=e=>{o+=e.length,i.push(e),s(i)};e.on(\"data\",u).on(\"end\",()=>s(i)).once(\"error\",t=>{e.removeListener(\"data\",u),n(t)})}).once(\"error\",n)})}(e):function(e){return new Promise((t,n)=>{const i=e.match(/^data:.+?;base64,/);if(i)try{const r=Buffer.from(e.slice(i[0].length),\"base64\");return t(c(\"\",a(r)))}catch(e){return n(e)}a(e,(i,o)=>{i?n(i):t(c(r.basename(e),o))})})}(e)}},function(e,t){e.exports=require(\"http\")},function(e,t){e.exports=require(\"https\")},function(e,t){e.exports=require(\"url\")},function(e,t,n){\"use strict\";var r=n(7),i=n(5),o=n(45),s={},a=n(9);a.forEach(function(e){s[e]=n(10)(\"./\"+e)});var u=131072;function c(e,t){var n=o(e,t);if(n in s){var r=s[n].calculate(e,t);if(!1!==r)return r.type=n,r}throw new TypeError(\"unsupported file type: \"+n+\" (file: \"+t+\")\")}e.exports=function(e,t){if(Buffer.isBuffer(e))return c(e);if(\"string\"!=typeof e)throw new TypeError(\"invalid invocation\");var n=i.resolve(e);if(\"function\"!=typeof t)return c(function(e){var t=r.openSync(e,\"r\"),n=r.fstatSync(t).size,i=Math.min(n,u),o=new Buffer(i);return r.readSync(t,o,0,i,0),r.closeSync(t),o}(n),n);!function(e,t){r.open(e,\"r\",function(n,i){if(n)return t(n);var o=r.fstatSync(i).size;if(o<=0)return t(new Error(\"File size is not greater than 0  \"+e));var s=Math.min(o,u),a=new Buffer(s);r.read(i,a,0,s,0,function(e){if(e)return t(e);r.close(i,function(e){t(e,a)})})})}(n,function(e,r){if(e)return t(e);var i;try{i=c(r,n)}catch(t){e=t}t(e,i)})},e.exports.types=a},function(e,t,n){\"use strict\";var r={};n(9).forEach(function(e){r[e]=n(10)(\"./\"+e).detect}),e.exports=function(e,t){var n;for(n in r)if(r[n](e,t))return n}},function(e,t,n){\"use strict\";e.exports=function(e,t,n,r){return n=n||0,e[\"readUInt\"+t+(r?\"BE\":\"LE\")].call(e,n)}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(5),i=n(7),o=\"/\"===r.sep?/^\\/+/:/^\\\\+/;function s(e){return new Promise((t,n)=>{i.stat(e,(r,i)=>r?n(r):i.isFile()?void t(e):n(new Error(`${e} is not a file`)))})}t.locateFile=function(e,t){return/^\\w+:/.test(t)?Promise.resolve(t):(t=r.normalize(t),o.test(t)?function(e,t){return new Promise((n,i)=>{t=t.replace(o,\"\");const a=e=>{s(r.resolve(e,t)).then(n,()=>{const n=r.dirname(e);if(!n||n===e)return i(`Unable to locate absolute file ${t}`);a(n)})};a(e)})}(e,t):function(e,t){return s(r.resolve(e,t))}(e,t))}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(1),i=n(2),o=[\"-webkit-\",\"-moz-\",\"-ms-\",\"-o-\",\"\"];t.reflectCssValue=function(){let e=r.window.activeTextEditor;if(!e)return void r.window.showInformationMessage(\"No editor is active.\");let t=i.getCssPropertyFromDocument(e,e.selection.active);return t?function(e,t){const n=t.parent;let s=\"\";for(const e of o)if(t.name.startsWith(e)){s=e;break}const a=t.name.substr(s.length),u=t.value;return e.edit(e=>{o.forEach(t=>{if(t===s)return;let o=i.getCssPropertyFromRule(n,t+a);o&&e.replace(new r.Range(o.valueToken.start,o.valueToken.end),u)})})}(e,t):void 0}}]));\n//# sourceMappingURL=https://ticino.blob.core.windows.net/sourcemaps/05f146c7a8f7f78e80261aa3b2a2e642586f9eb3/extensions/emmet/dist/extension.js.map","/merge-conflict/package.json":"{\n  \"name\": \"merge-conflict\",\n  \"publisher\": \"vscode\",\n  \"displayName\": \"%displayName%\",\n  \"description\": \"%description%\",\n  \"icon\": \"resources/icons/merge-conflict.png\",\n  \"version\": \"1.0.0\",\n  \"aiKey\": \"AIF-d9b70cd4-b9f9-4d70-929b-a071c400b217\",\n  \"engines\": {\n    \"vscode\": \"^1.5.0\"\n  },\n  \"categories\": [\"Other\"],\n  \"activationEvents\": [\"*\"],\n  \"main\": \"./dist/extension\",\n  \"scripts\": {\n    \"compile\": \"gulp compile-extension:merge-conflict\",\n    \"watch\": \"gulp watch-extension:merge-conflict\"\n  },\n  \"contributes\": {\n    \"commands\": [{\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.all-current%\",\n      \"original\": \"Accept All Current\",\n      \"command\": \"merge-conflict.accept.all-current\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.all-incoming%\",\n      \"original\": \"Accept All Incoming\",\n      \"command\": \"merge-conflict.accept.all-incoming\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.all-both%\",\n      \"original\": \"Accept All Both\",\n      \"command\": \"merge-conflict.accept.all-both\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.current%\",\n      \"original\": \"Accept Current\",\n      \"command\": \"merge-conflict.accept.current\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.incoming%\",\n      \"original\": \"Accept Incoming\",\n      \"command\": \"merge-conflict.accept.incoming\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.selection%\",\n      \"original\": \"Accept Selection\",\n      \"command\": \"merge-conflict.accept.selection\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.accept.both%\",\n      \"original\": \"Accept Both\",\n      \"command\": \"merge-conflict.accept.both\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.next%\",\n      \"original\": \"Next Conflict\",\n      \"command\": \"merge-conflict.next\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.previous%\",\n      \"original\": \"Previous Conflict\",\n      \"command\": \"merge-conflict.previous\"\n    }, {\n      \"category\": \"%command.category%\",\n      \"title\": \"%command.compare%\",\n      \"original\": \"Compare Current Conflict\",\n      \"command\": \"merge-conflict.compare\"\n    }],\n    \"menus\": {\n      \"scm/resourceState/context\": [{\n        \"command\": \"merge-conflict.accept.all-current\",\n        \"when\": \"scmProvider == git && scmResourceGroup == merge\",\n        \"group\": \"1_modification\"\n      }, {\n        \"command\": \"merge-conflict.accept.all-incoming\",\n        \"when\": \"scmProvider == git && scmResourceGroup == merge\",\n        \"group\": \"1_modification\"\n      }]\n    },\n    \"configuration\": {\n      \"title\": \"%config.title%\",\n      \"properties\": {\n        \"merge-conflict.codeLens.enabled\": {\n          \"type\": \"boolean\",\n          \"description\": \"%config.codeLensEnabled%\",\n          \"default\": true\n        },\n        \"merge-conflict.decorators.enabled\": {\n          \"type\": \"boolean\",\n          \"description\": \"%config.decoratorsEnabled%\",\n          \"default\": true\n        },\n        \"merge-conflict.autoNavigateNextConflict.enabled\": {\n          \"type\": \"boolean\",\n          \"description\": \"%config.autoNavigateNextConflictEnabled%\",\n          \"default\": false\n        }\n      }\n    }\n  },\n  \"dependencies\": {\n    \"vscode-nls\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"8.0.33\"\n  }\n}","/merge-conflict/dist/extension.js":"!function(e,t){for(var n in t)e[n]=t[n]}(exports,function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=4)}([function(e,t){e.exports=require(\"vscode\")},function(e,t){e.exports=require(\"path\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r,o,i,s,a,c=n(1),l=n(11),u=Object.prototype.toString;function d(e){return void 0!==e}function g(e){return\"[object String]\"===u.call(e)}function h(e){return JSON.parse(l.readFileSync(e,\"utf8\"))}function f(e,t){return a&&(e=\"\"+e.replace(/[aouei]/g,\"$&$&\")+\"\"),0===t.length?e:e.replace(/\\{(\\d+)\\}/g,function(e,n){var r=n[0],o=t[r],i=e;return\"string\"==typeof o?i=o:\"number\"!=typeof o&&\"boolean\"!=typeof o&&void 0!==o&&null!==o||(i=String(o)),i})}function m(e){return function(t,n){for(var r=[],o=2;o<arguments.length;o++)r[o-2]=arguments[o];return function(e){return\"[object Number]\"===u.call(e)}(t)?t>=e.length?void console.error(\"Broken localize call found. Index out of bounds. Stacktrace is\\n: \"+new Error(\"\").stack):f(e[t],r):g(n)?(console.warn(\"Message \"+n+\" didn't get externalized correctly.\"),f(n,r)):void console.error(\"Broken localize call found. Stacktrace is\\n: \"+new Error(\"\").stack)}}function p(e,t){for(var n=[],r=2;r<arguments.length;r++)n[r-2]=arguments[r];return f(t,n)}function v(e,t){return i[e]=t,t}function w(e,t){var n,r=c.join(s.cacheRoot,e.id+\"-\"+e.hash+\".json\"),o=!1,i=!1;try{return n=JSON.parse(l.readFileSync(r,{encoding:\"utf8\",flag:\"r\"})),function(e){var t=new Date;l.utimes(e,t,t,function(){})}(r),n}catch(e){if(\"ENOENT\"===e.code)i=!0;else{if(!(e instanceof SyntaxError))throw e;console.log(\"Syntax error parsing message bundle: \"+e.message+\".\"),l.unlink(r,function(e){e&&console.error(\"Deleting corrupted bundle \"+r+\" failed.\")}),o=!0}}if(!(n=function(e,t){var n=s.translationsConfig[e.id];if(n){var r=h(n).contents,o=h(c.join(t,\"nls.metadata.json\")),i=Object.create(null);for(var a in o){var l=o[a],u=r[e.outDir+\"/\"+a];if(u){for(var d=[],f=0;f<l.keys.length;f++){var m=l.keys[f],p=u[g(m)?m:m.key];void 0===p&&(p=l.messages[f]),d.push(p)}i[a]=d}else i[a]=l.messages}return i}}(e,t))||o)return n;if(i)try{l.writeFileSync(r,JSON.stringify(n),{encoding:\"utf8\",flag:\"wx\"})}catch(e){if(\"EEXIST\"===e.code)return n;throw e}return n}function C(e){try{return function(e){var t=h(c.join(e,\"nls.metadata.json\")),n=Object.create(null);for(var r in t){var o=t[r];n[r]=o.messages}return n}(e)}catch(e){return void console.log(\"Generating default bundle from meta data failed.\",e)}}function y(e,t){var n;if(!0===s.languagePackSupport&&void 0!==s.cacheRoot&&void 0!==s.languagePackId&&void 0!==s.translationsConfigFile&&void 0!==s.translationsConfig)try{n=w(e,t)}catch(e){console.log(\"Load or create bundle failed \",e)}if(!n){if(s.languagePackSupport)return C(t);var r=function(e){for(var t=s.locale;t;){var n=c.join(e,\"nls.bundle.\"+t+\".json\");if(l.existsSync(n))return n;var r=t.lastIndexOf(\"-\");t=r>0?t.substring(0,r):void 0}if(void 0===t&&(n=c.join(e,\"nls.bundle.json\"),l.existsSync(n)))return n}(t);if(r)try{return h(r)}catch(e){console.log(\"Loading in the box message bundle failed.\",e)}n=C(t)}return n}function b(e){if(!e)return p;var t=c.extname(e);if(t&&(e=e.substr(0,e.length-t.length)),s.messageFormat===r.both||s.messageFormat===r.bundle){var n=function(e){for(var t,n=c.dirname(e);t=c.join(n,\"nls.metadata.header.json\"),!l.existsSync(t);){var r=c.dirname(n);if(r===n){t=void 0;break}n=r}return t}(e);if(n){var o=c.dirname(n),u=i[o];if(void 0===u)try{var g=JSON.parse(l.readFileSync(n,\"utf8\"));try{var f=y(g,o);u=v(o,f?{header:g,nlsBundle:f}:null)}catch(e){console.error(\"Failed to load nls bundle\",e),u=v(o,null)}}catch(e){console.error(\"Failed to read header file\",e),u=v(o,null)}if(u){var w=e.substr(o.length+1).replace(/\\\\/g,\"/\"),C=u.nlsBundle[w];return void 0===C?(console.error(\"Messages for file \"+e+\" not found. See console for details.\"),function(){return\"Messages not found.\"}):m(C)}}}if(s.messageFormat===r.both||s.messageFormat===r.file)try{var b=h(function(e){var t;if(s.cacheLanguageResolution&&t)t=t;else{if(a||!s.locale)t=\".nls.json\";else for(var n=s.locale;n;){var r=\".nls.\"+n+\".json\";if(l.existsSync(e+r)){t=r;break}var o=n.lastIndexOf(\"-\");o>0?n=n.substring(0,o):(t=\".nls.json\",n=null)}s.cacheLanguageResolution&&(t=t)}return e+t}(e));return Array.isArray(b)?m(b):d(b.messages)&&d(b.keys)?m(b.messages):(console.error(\"String bundle '\"+e+\"' uses an unsupported format.\"),function(){return\"File bundle has unsupported format. See console for details\"})}catch(e){\"ENOENT\"!==e.code&&console.error(\"Failed to load single file bundle\",e)}return console.error(\"Failed to load message bundle for file \"+e),function(){return\"Failed to load message bundle. See console for details.\"}}!function(e){e.file=\"file\",e.bundle=\"bundle\",e.both=\"both\"}(r=t.MessageFormat||(t.MessageFormat={})),function(e){e.is=function(e){var t=e;return t&&d(t.key)&&d(t.comment)}}(o||(o={})),function(){if(s={locale:void 0,languagePackSupport:!1,cacheLanguageResolution:!0,messageFormat:r.bundle},g(process.env.VSCODE_NLS_CONFIG))try{var e=JSON.parse(process.env.VSCODE_NLS_CONFIG);if(g(e.locale)&&(s.locale=e.locale.toLowerCase()),function(e){return!0===e||!1===e}(e._languagePackSupport)&&(s.languagePackSupport=e._languagePackSupport),g(e._cacheRoot)&&(s.cacheRoot=e._cacheRoot),g(e._languagePackId)&&(s.languagePackId=e._languagePackId),g(e._translationsConfigFile)){s.translationsConfigFile=e._translationsConfigFile;try{s.translationsConfig=h(s.translationsConfigFile)}catch(t){e._corruptedFile&&l.writeFile(e._corruptedFile,\"corrupted\",\"utf8\",function(e){console.error(e)})}}}catch(e){}a=\"pseudo\"===s.locale,void 0,i=Object.create(null)}(),t.loadMessageBundle=b,t.config=function(e){return e&&(g(e.locale)&&(s.locale=e.locale.toLowerCase(),void 0,i=Object.create(null)),void 0!==e.messageFormat&&(s.messageFormat=e.messageFormat)),a=\"pseudo\"===s.locale,b}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0);class o{constructor(e){this.context=e}begin(){this.context.subscriptions.push(r.workspace.registerTextDocumentContentProvider(o.scheme,this))}dispose(){}async provideTextDocumentContent(e){try{const{scheme:t,range:n}=JSON.parse(e.query),[o,i]=n;return(await r.workspace.openTextDocument(e.with({scheme:t,query:\"\"}))).getText(new r.Range(o.line,o.character,i.line,i.character))}catch(e){return await r.window.showErrorMessage(\"Unable to show comparison\"),null}}}o.scheme=\"merge-conflict.conflict-diff\",t.default=o},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(5);t.activate=function(e){const t=new r.default(e);t.begin(),e.subscriptions.push(t)},t.deactivate=function(){}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0),o=n(6),i=n(10),s=n(12),a=n(3),c=n(13),l=\"merge-conflict\";t.default=class{constructor(e){this.context=e,this.services=[]}begin(){let e=this.createExtensionConfiguration();const t=new o.default;this.services.push(t,new s.default(t),new i.default(t),new a.default(this.context),new c.default(this.context,t)),this.services.forEach(t=>{t.begin&&t.begin instanceof Function&&t.begin(e)}),r.workspace.onDidChangeConfiguration(()=>{this.services.forEach(e=>{e.configurationUpdated&&e.configurationUpdated instanceof Function&&e.configurationUpdated(this.createExtensionConfiguration())})})}createExtensionConfiguration(){const e=r.workspace.getConfiguration(l),t=e.get(\"codeLens.enabled\",!0),n=e.get(\"decorators.enabled\",!0);return{enableCodeLens:t,enableDecorations:n,enableEditorOverview:n}}dispose(){this.services.forEach(e=>e.dispose()),this.services=[]}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(7),o=n(9);class i{constructor(e,t){this.origins=new Set,this.origins.add(t),this.delayTask=new o.Delayer(e)}addOrigin(e){return this.origins.has(e),!1}hasOrigin(e){return this.origins.has(e)}}class s{constructor(e,t){this.parent=e,this.origin=t}getConflicts(e){return this.parent.getConflicts(e,this.origin)}isPending(e){return this.parent.isPending(e,this.origin)}forget(e){this.parent.forget(e)}}t.default=class{constructor(){this.cache=new Map,this.delayExpireTime=250}getConflicts(e,t){let n=this.getCacheKey(e);if(!n)return Promise.resolve(this.getConflictsOrEmpty(e,[t]));let r=this.cache.get(n);return r?r.addOrigin(t):(r=new i(this.delayExpireTime,t),this.cache.set(n,r)),r.delayTask.trigger(()=>{let t=this.getConflictsOrEmpty(e,Array.from(r.origins));return this.cache&&this.cache.delete(n),t})}isPending(e,t){if(!e)return!1;let n=this.getCacheKey(e);if(!n)return!1;const r=this.cache.get(n);return!!r&&r.hasOrigin(t)}createTracker(e){return new s(this,e)}forget(e){let t=this.getCacheKey(e);t&&this.cache.delete(t)}dispose(){this.cache.clear()}getConflictsOrEmpty(e,t){return r.MergeConflictParser.containsConflict(e)?r.MergeConflictParser.scanDocument(e):[]}getCacheKey(e){return e.uri?e.uri.toString():null}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0),o=n(8),i=\"<<<<<<<\",s=\"|||||||\",a=\"=======\",c=\">>>>>>>\";class l{static scanDocument(e){let t=null;const n=[];for(let r=0;r<e.lineCount;r++){const o=e.lineAt(r);if(o&&!o.isEmptyOrWhitespace)if(o.text.startsWith(i)){if(null!==t){t=null;break}t={startHeader:o,commonAncestors:[]}}else if(t&&!t.splitter&&o.text.startsWith(s))t.commonAncestors.push(o);else if(t&&!t.splitter&&o.text.startsWith(a))t.splitter=o;else if(t&&o.text.startsWith(c)){t.endFooter=o;let r=l.scanItemTolMergeConflictDescriptor(e,t);null!==r&&n.push(r),t=null}}return n.filter(Boolean).map(e=>new o.DocumentMergeConflict(e))}static scanItemTolMergeConflictDescriptor(e,t){if(!t.startHeader||!t.splitter||!t.endFooter)return null;let n=t.commonAncestors[0]||t.splitter;return{current:{header:t.startHeader.range,decoratorContent:new r.Range(t.startHeader.rangeIncludingLineBreak.end,l.shiftBackOneCharacter(e,n.range.start,t.startHeader.rangeIncludingLineBreak.end)),content:new r.Range(t.startHeader.rangeIncludingLineBreak.end,n.range.start),name:t.startHeader.text.substring(i.length+1)},commonAncestors:t.commonAncestors.map((n,o,i)=>{let a=i[o+1]||t.splitter;return{header:n.range,decoratorContent:new r.Range(n.rangeIncludingLineBreak.end,l.shiftBackOneCharacter(e,a.range.start,n.rangeIncludingLineBreak.end)),content:new r.Range(n.rangeIncludingLineBreak.end,a.range.start),name:n.text.substring(s.length+1)}}),splitter:t.splitter.range,incoming:{header:t.endFooter.range,decoratorContent:new r.Range(t.splitter.rangeIncludingLineBreak.end,l.shiftBackOneCharacter(e,t.endFooter.range.start,t.splitter.rangeIncludingLineBreak.end)),content:new r.Range(t.splitter.rangeIncludingLineBreak.end,t.endFooter.range.start),name:t.endFooter.text.substring(c.length+1)},range:new r.Range(t.startHeader.range.start,t.endFooter.rangeIncludingLineBreak.end)}}static containsConflict(e){if(!e)return!1;let t=e.getText();return t.includes(i)&&t.includes(c)}static shiftBackOneCharacter(e,t,n){if(t.isEqual(n))return t;let o=t.line,i=t.character-1;return i<0&&(o--,i=e.lineAt(o).range.end.character),new r.Position(o,i)}}t.MergeConflictParser=l},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.DocumentMergeConflict=class{constructor(e){this.range=e.range,this.current=e.current,this.incoming=e.incoming,this.commonAncestors=e.commonAncestors,this.splitter=e.splitter}commitEdit(e,t,n){return n?(this.applyEdit(e,t,n),Promise.resolve(!0)):t.edit(n=>this.applyEdit(e,t,n))}applyEdit(e,t,n){if(0===e){let e=t.document.getText(this.current.content);this.replaceRangeWithContent(e,n)}else if(1===e){let e=t.document.getText(this.incoming.content);this.replaceRangeWithContent(e,n)}else if(2===e){const e=t.document.getText(this.current.content),r=t.document.getText(this.incoming.content);n.replace(this.range,e.concat(r))}}replaceRangeWithContent(e,t){this.isNewlineOnly(e)?t.replace(this.range,\"\"):t.replace(this.range,e)}isNewlineOnly(e){return\"\\n\"===e||\"\\r\\n\"===e}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});t.Delayer=class{constructor(e){this.defaultDelay=e,this.timeout=null,this.completionPromise=null,this.onSuccess=null,this.task=null}trigger(e,t=this.defaultDelay){return this.task=e,t>=0&&this.cancelTimeout(),this.completionPromise||(this.completionPromise=new Promise(e=>{this.onSuccess=e}).then(()=>{this.completionPromise=null,this.onSuccess=null;let e=this.task();return this.task=null,e})),(t>=0||null===this.timeout)&&(this.timeout=setTimeout(()=>{this.timeout=null,this.onSuccess(void 0)},t>=0?t:this.defaultDelay)),this.completionPromise}forceDelivery(){if(!this.completionPromise)return null;this.cancelTimeout();let e=this.completionPromise;return this.onSuccess(void 0),e}isTriggered(){return null!==this.timeout}cancel(){this.cancelTimeout(),this.completionPromise=null}cancelTimeout(){null!==this.timeout&&(clearTimeout(this.timeout),this.timeout=null)}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0),o=n(2).loadMessageBundle(n(1).join(__dirname,\"codelensProvider.ts\"));t.default=class{constructor(e){this.tracker=e.createTracker(\"codelens\")}begin(e){this.config=e,this.config.enableCodeLens&&this.registerCodeLensProvider()}configurationUpdated(e){!1===e.enableCodeLens&&this.codeLensRegistrationHandle?(this.codeLensRegistrationHandle.dispose(),this.codeLensRegistrationHandle=null):!0!==e.enableCodeLens||this.codeLensRegistrationHandle||this.registerCodeLensProvider(),this.config=e}dispose(){this.codeLensRegistrationHandle&&(this.codeLensRegistrationHandle.dispose(),this.codeLensRegistrationHandle=null)}async provideCodeLenses(e,t){if(!this.config||!this.config.enableCodeLens)return null;let n=await this.tracker.getConflicts(e);if(!n||0===n.length)return null;let i=[];return n.forEach(e=>{let t={command:\"merge-conflict.accept.current\",title:o(0,null),arguments:[\"known-conflict\",e]},n={command:\"merge-conflict.accept.incoming\",title:o(1,null),arguments:[\"known-conflict\",e]},s={command:\"merge-conflict.accept.both\",title:o(2,null),arguments:[\"known-conflict\",e]},a={command:\"merge-conflict.compare\",title:o(3,null),arguments:[e]};i.push(new r.CodeLens(e.range,t),new r.CodeLens(e.range.with(e.range.start.with({character:e.range.start.character+1})),n),new r.CodeLens(e.range.with(e.range.start.with({character:e.range.start.character+2})),s),new r.CodeLens(e.range.with(e.range.start.with({character:e.range.start.character+3})),a))}),i}registerCodeLensProvider(){this.codeLensRegistrationHandle=r.languages.registerCodeLensProvider([{scheme:\"file\"},{scheme:\"untitled\"}],this)}}},function(e,t){e.exports=require(\"fs\")},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0),o=n(3),i=n(1),s=n(2).loadMessageBundle(n(1).join(__dirname,\"commandHandler.ts\"));var a;!function(e){e[e.Forwards=0]=\"Forwards\",e[e.Backwards=1]=\"Backwards\"}(a||(a={}));t.default=class{constructor(e){this.disposables=[],this.tracker=e.createTracker(\"commands\")}begin(){this.disposables.push(this.registerTextEditorCommand(\"merge-conflict.accept.current\",this.acceptCurrent),this.registerTextEditorCommand(\"merge-conflict.accept.incoming\",this.acceptIncoming),this.registerTextEditorCommand(\"merge-conflict.accept.selection\",this.acceptSelection),this.registerTextEditorCommand(\"merge-conflict.accept.both\",this.acceptBoth),this.registerTextEditorCommand(\"merge-conflict.accept.all-current\",this.acceptAllCurrent),this.registerTextEditorCommand(\"merge-conflict.accept.all-incoming\",this.acceptAllIncoming),this.registerTextEditorCommand(\"merge-conflict.accept.all-both\",this.acceptAllBoth),this.registerTextEditorCommand(\"merge-conflict.next\",this.navigateNext),this.registerTextEditorCommand(\"merge-conflict.previous\",this.navigatePrevious),this.registerTextEditorCommand(\"merge-conflict.compare\",this.compare))}registerTextEditorCommand(e,t){return r.commands.registerCommand(e,(...e)=>{const n=r.window.activeTextEditor;return n&&t.call(this,n,...e)})}acceptCurrent(e,...t){return this.accept(0,e,...t)}acceptIncoming(e,...t){return this.accept(1,e,...t)}acceptBoth(e,...t){return this.accept(2,e,...t)}acceptAllCurrent(e){return this.acceptAll(0,e)}acceptAllIncoming(e){return this.acceptAll(1,e)}acceptAllBoth(e){return this.acceptAll(2,e)}async compare(e,t){const n=i.basename(e.document.uri.fsPath);if(!t&&!(t=await this.findConflictContainingSelection(e)))return void r.window.showWarningMessage(s(0,null));const a=e.document.uri.scheme;let c=t.current.content;const l=e.document.uri.with({scheme:o.default.scheme,query:JSON.stringify({scheme:a,range:c})});c=t.incoming.content;const u=l.with({query:JSON.stringify({scheme:a,range:c})}),d=s(1,null,n);r.commands.executeCommand(\"vscode.diff\",l,u,d)}navigateNext(e){return this.navigate(e,a.Forwards)}navigatePrevious(e){return this.navigate(e,a.Backwards)}async acceptSelection(e){let t,n=await this.findConflictContainingSelection(e);if(!n)return void r.window.showWarningMessage(s(2,null));let o=n.splitter;if(n.commonAncestors.length>0&&(o=n.commonAncestors[0].header),e.selection.active.isBefore(o.start))t=0;else{if(!e.selection.active.isAfter(n.splitter.end))return e.selection.active.isBefore(n.splitter.start)?void r.window.showWarningMessage(s(3,null)):void r.window.showWarningMessage(s(4,null));t=1}this.tracker.forget(e.document),n.commitEdit(t,e)}dispose(){this.disposables.forEach(e=>e.dispose()),this.disposables=[]}async navigate(e,t){let n=await this.findConflictForNavigation(e,t);if(n)n.canNavigate?n.conflict&&(e.selection=new r.Selection(n.conflict.range.start,n.conflict.range.start),e.revealRange(n.conflict.range,r.TextEditorRevealType.Default)):r.window.showWarningMessage(s(6,null));else{if(r.workspace.getConfiguration(\"merge-conflict\").get(\"autoNavigateNextConflict.enabled\"))return;r.window.showWarningMessage(s(5,null))}}async accept(e,t,...n){let o;(o=\"known-conflict\"===n[0]?n[1]:await this.findConflictContainingSelection(t))?(this.tracker.forget(t.document),o.commitEdit(e,t),r.workspace.getConfiguration(\"merge-conflict\").get(\"autoNavigateNextConflict.enabled\")&&this.navigateNext(t)):r.window.showWarningMessage(s(7,null))}async acceptAll(e,t){let n=await this.tracker.getConflicts(t.document);n&&0!==n.length?(this.tracker.forget(t.document),await t.edit(r=>n.forEach(n=>{n.applyEdit(e,t,r)}))):r.window.showWarningMessage(s(8,null))}async findConflictContainingSelection(e,t){if(t||(t=await this.tracker.getConflicts(e.document)),!t||0===t.length)return null;for(const n of t)if(n.range.contains(e.selection.active))return n;return null}async findConflictForNavigation(e,t,n){if(n||(n=await this.tracker.getConflicts(e.document)),!n||0===n.length)return null;let r,o,i=e.selection.active;if(1===n.length)return n[0].range.contains(i)?{canNavigate:!1}:{canNavigate:!0,conflict:n[0]};if(t===a.Forwards)r=(e=>i.isBefore(e.range.start)),o=(()=>n[0]);else{if(t!==a.Backwards)throw new Error(`Unsupported direction ${t}`);r=(e=>i.isAfter(e.range.start)),o=(()=>n[n.length-1])}for(const e of n)if(r(e)&&!e.range.contains(i))return{canNavigate:!0,conflict:e};return{canNavigate:!0,conflict:o()}}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});const r=n(0),o=n(2).loadMessageBundle(n(1).join(__dirname,\"mergeDecorator.ts\"));t.default=class{constructor(e,t){this.context=e,this.decorations={},this.decorationUsesWholeLine=!0,this.updating=new Map,this.tracker=t.createTracker(\"decorator\")}begin(e){this.config=e,this.registerDecorationTypes(e),r.window.visibleTextEditors.forEach(e=>this.applyDecorations(e)),r.workspace.onDidOpenTextDocument(e=>{this.applyDecorationsFromEvent(e)},null,this.context.subscriptions),r.workspace.onDidChangeTextDocument(e=>{this.applyDecorationsFromEvent(e.document)},null,this.context.subscriptions),r.window.onDidChangeVisibleTextEditors(e=>{e.forEach(e=>this.applyDecorations(e))},null,this.context.subscriptions)}configurationUpdated(e){this.config=e,this.registerDecorationTypes(e),r.window.visibleTextEditors.forEach(e=>{this.removeDecorations(e),this.applyDecorations(e)})}registerDecorationTypes(e){Object.keys(this.decorations).forEach(e=>this.decorations[e].dispose()),this.decorations={},e.enableDecorations&&e.enableEditorOverview&&((e.enableDecorations||e.enableEditorOverview)&&(this.decorations[\"current.content\"]=r.window.createTextEditorDecorationType(this.generateBlockRenderOptions(\"merge.currentContentBackground\",\"editorOverviewRuler.currentContentForeground\",e)),this.decorations[\"incoming.content\"]=r.window.createTextEditorDecorationType(this.generateBlockRenderOptions(\"merge.incomingContentBackground\",\"editorOverviewRuler.incomingContentForeground\",e)),this.decorations[\"commonAncestors.content\"]=r.window.createTextEditorDecorationType(this.generateBlockRenderOptions(\"merge.commonContentBackground\",\"editorOverviewRuler.commonContentForeground\",e))),e.enableDecorations&&(this.decorations[\"current.header\"]=r.window.createTextEditorDecorationType({isWholeLine:this.decorationUsesWholeLine,backgroundColor:new r.ThemeColor(\"merge.currentHeaderBackground\"),color:new r.ThemeColor(\"editor.foreground\"),outlineStyle:\"solid\",outlineWidth:\"1pt\",outlineColor:new r.ThemeColor(\"merge.border\"),after:{contentText:\" \"+o(0,null),color:new r.ThemeColor(\"descriptionForeground\")}}),this.decorations[\"commonAncestors.header\"]=r.window.createTextEditorDecorationType({isWholeLine:this.decorationUsesWholeLine,backgroundColor:new r.ThemeColor(\"merge.commonHeaderBackground\"),color:new r.ThemeColor(\"editor.foreground\"),outlineStyle:\"solid\",outlineWidth:\"1pt\",outlineColor:new r.ThemeColor(\"merge.border\")}),this.decorations.splitter=r.window.createTextEditorDecorationType({color:new r.ThemeColor(\"editor.foreground\"),outlineStyle:\"solid\",outlineWidth:\"1pt\",outlineColor:new r.ThemeColor(\"merge.border\"),isWholeLine:this.decorationUsesWholeLine}),this.decorations[\"incoming.header\"]=r.window.createTextEditorDecorationType({backgroundColor:new r.ThemeColor(\"merge.incomingHeaderBackground\"),color:new r.ThemeColor(\"editor.foreground\"),outlineStyle:\"solid\",outlineWidth:\"1pt\",outlineColor:new r.ThemeColor(\"merge.border\"),isWholeLine:this.decorationUsesWholeLine,after:{contentText:\" \"+o(1,null),color:new r.ThemeColor(\"descriptionForeground\")}})))}dispose(){Object.keys(this.decorations).forEach(e=>{this.decorations[e].dispose()}),this.decorations={}}generateBlockRenderOptions(e,t,n){let o={};return n.enableDecorations&&(o.backgroundColor=new r.ThemeColor(e),o.isWholeLine=this.decorationUsesWholeLine),n.enableEditorOverview&&(o.overviewRulerColor=new r.ThemeColor(t),o.overviewRulerLane=r.OverviewRulerLane.Full),o}applyDecorationsFromEvent(e){for(const t of r.window.visibleTextEditors)t.document===e&&this.applyDecorations(t)}async applyDecorations(e){if(e&&e.document&&this.config&&(this.config.enableDecorations||this.config.enableEditorOverview)&&!this.updating.get(e))try{this.updating.set(e,!0);let t=await this.tracker.getConflicts(e.document);if(-1===r.window.visibleTextEditors.indexOf(e))return;if(0===t.length)return void this.removeDecorations(e);let n={},o=(e,t)=>{n[e]=n[e]||[],n[e].push(t)};t.forEach(e=>{e.current.decoratorContent.isEmpty||o(\"current.content\",e.current.decoratorContent),e.incoming.decoratorContent.isEmpty||o(\"incoming.content\",e.incoming.decoratorContent),e.commonAncestors.forEach(e=>{e.decoratorContent.isEmpty||o(\"commonAncestors.content\",e.decoratorContent)}),this.config.enableDecorations&&(o(\"current.header\",e.current.header),o(\"splitter\",e.splitter),o(\"incoming.header\",e.incoming.header),e.commonAncestors.forEach(e=>{o(\"commonAncestors.header\",e.header)}))}),Object.keys(n).forEach(t=>{let r=this.decorations[t];r&&e.setDecorations(r,n[t])})}finally{this.updating.delete(e)}}removeDecorations(e){Object.keys(this.decorations).forEach(t=>{let n=this.decorations[t];n&&e.setDecorations(n,[])})}}}]));\n//# sourceMappingURL=https://ticino.blob.core.windows.net/sourcemaps/05f146c7a8f7f78e80261aa3b2a2e642586f9eb3/extensions/merge-conflict/dist/extension.js.map","/merge-conflict/dist/nls.metadata.header.json":"{\"id\":\"vscode.merge-conflict\",\"type\":\"extensionBundle\",\"hash\":\"75c438e5b05c0f1d51085335bb607945\",\"outDir\":\"out\"}","/merge-conflict/dist/nls.metadata.json":"{\"mergeDecorator\":{\"messages\":[\"(Current Change)\",\"(Incoming Change)\"],\"keys\":[\"currentChange\",\"incomingChange\"]},\"commandHandler\":{\"messages\":[\"Editor cursor is not within a merge conflict\",\"{0}: Current Changes  Incoming Changes\",\"Editor cursor is not within a merge conflict\",\"Editor cursor is within the common ancestors block, please move it to either the \\\"current\\\" or \\\"incoming\\\" block\",\"Editor cursor is within the merge conflict splitter, please move it to either the \\\"current\\\" or \\\"incoming\\\" block\",\"No merge conflicts found in this file\",\"No other merge conflicts within this file\",\"Editor cursor is not within a merge conflict\",\"No merge conflicts found in this file\"],\"keys\":[\"cursorNotInConflict\",\"compareChangesTitle\",\"cursorNotInConflict\",\"cursorOnCommonAncestorsRange\",\"cursorOnSplitterRange\",\"noConflicts\",\"noOtherConflictsInThisFile\",\"cursorNotInConflict\",\"noConflicts\"]},\"codelensProvider\":{\"messages\":[\"Accept Current Change\",\"Accept Incoming Change\",\"Accept Both Changes\",\"Compare Changes\"],\"keys\":[\"acceptCurrentChange\",\"acceptIncomingChange\",\"acceptBothChanges\",\"compareChanges\"]}}","/typescript-language-features/package.json":"{\n  \"name\": \"typescript-language-features\",\n  \"description\": \"%description%\",\n  \"displayName\": \"%displayName%\",\n  \"version\": \"1.0.0\",\n  \"icon\": \"icon.png\",\n  \"author\": \"vscode\",\n  \"publisher\": \"vscode\",\n  \"license\": \"MIT\",\n  \"aiKey\": \"AIF-d9b70cd4-b9f9-4d70-929b-a071c400b217\",\n  \"enableProposedApi\": true,\n  \"engines\": {\n    \"vscode\": \"^1.30.0\"\n  },\n  \"categories\": [\n    \"Programming Languages\"\n  ],\n  \"dependencies\": {\n    \"jsonc-parser\": \"^2.1.1\",\n    \"rimraf\": \"^2.6.3\",\n    \"semver\": \"5.5.1\",\n    \"vscode-extension-telemetry\": \"0.1.1\",\n    \"vscode-nls\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^10.14.8\",\n    \"@types/semver\": \"^5.5.0\",\n    \"@types/rimraf\": \"2.0.2\",\n    \"vscode\": \"^1.1.10\"\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"node ../../node_modules/gulp/bin/gulp.js --gulpfile ../../build/gulpfile.extensions.js compile-extension:typescript ./tsconfig.json\"\n  },\n  \"activationEvents\": [\n    \"onLanguage:javascript\",\n    \"onLanguage:javascriptreact\",\n    \"onLanguage:typescript\",\n    \"onLanguage:typescriptreact\",\n    \"onLanguage:jsx-tags\",\n    \"onCommand:typescript.reloadProjects\",\n    \"onCommand:javascript.reloadProjects\",\n    \"onCommand:typescript.selectTypeScriptVersion\",\n    \"onCommand:javascript.goToProjectConfig\",\n    \"onCommand:typescript.goToProjectConfig\",\n    \"onCommand:typescript.openTsServerLog\",\n    \"onCommand:workbench.action.tasks.runTask\",\n    \"onCommand:_typescript.configurePlugin\",\n    \"onLanguage:jsonc\"\n  ],\n  \"main\": \"./out/extension\",\n  \"contributes\": {\n    \"jsonValidation\": [\n      {\n        \"fileMatch\": \"package.json\",\n        \"url\": \"./schemas/package.schema.json\"\n      }\n    ],\n    \"configuration\": {\n      \"type\": \"object\",\n      \"title\": \"%configuration.typescript%\",\n      \"order\": 20,\n      \"properties\": {\n        \"typescript.tsdk\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"default\": null,\n          \"description\": \"%typescript.tsdk.desc%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.disableAutomaticTypeAcquisition\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%typescript.disableAutomaticTypeAcquisition%\",\n          \"scope\": \"window\",\n          \"tags\": [\n            \"usesOnlineServices\"\n          ]\n        },\n        \"typescript.npm\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"default\": null,\n          \"description\": \"%typescript.npm%\",\n          \"scope\": \"machine\"\n        },\n        \"typescript.check.npmIsInstalled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.check.npmIsInstalled%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.referencesCodeLens.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%javascript.referencesCodeLens.enabled%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.referencesCodeLens.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%typescript.referencesCodeLens.enabled%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.implementationsCodeLens.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%typescript.implementationsCodeLens.enabled%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.tsserver.log\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"off\",\n            \"terse\",\n            \"normal\",\n            \"verbose\"\n          ],\n          \"default\": \"off\",\n          \"description\": \"%typescript.tsserver.log%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.tsserver.pluginPaths\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\",\n            \"description\": \"%typescript.tsserver.pluginPaths.item%\"\n          },\n          \"default\": [],\n          \"description\": \"%typescript.tsserver.pluginPaths%\",\n          \"scope\": \"machine\"\n        },\n        \"typescript.tsserver.trace\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"off\",\n            \"messages\",\n            \"verbose\"\n          ],\n          \"default\": \"off\",\n          \"description\": \"%typescript.tsserver.trace%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.suggest.completeFunctionCalls\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%configuration.suggest.completeFunctionCalls%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggest.completeFunctionCalls\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%configuration.suggest.completeFunctionCalls%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.reportStyleChecksAsWarnings\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.reportStyleChecksAsWarnings%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.validate.enable\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.validate.enable%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.format.enable\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.format.enable%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.format.insertSpaceAfterCommaDelimiter\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterCommaDelimiter%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterConstructor\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterConstructor%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterSemicolonInForStatements\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterSemicolonInForStatements%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceBeforeAndAfterBinaryOperators\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceBeforeAndAfterBinaryOperators%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterKeywordsInControlFlowStatements\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterKeywordsInControlFlowStatements%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterFunctionKeywordForAnonymousFunctions%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceBeforeFunctionParenthesis\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceBeforeFunctionParenthesis%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.insertSpaceAfterTypeAssertion\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterTypeAssertion%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.placeOpenBraceOnNewLineForFunctions\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.placeOpenBraceOnNewLineForFunctions%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.format.placeOpenBraceOnNewLineForControlBlocks\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.placeOpenBraceOnNewLineForControlBlocks%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.validate.enable\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%javascript.validate.enable%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.format.enable\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%javascript.format.enable%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.format.insertSpaceAfterCommaDelimiter\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterCommaDelimiter%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterConstructor\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterConstructor%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterSemicolonInForStatements\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterSemicolonInForStatements%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceBeforeAndAfterBinaryOperators\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceBeforeAndAfterBinaryOperators%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterKeywordsInControlFlowStatements\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterKeywordsInControlFlowStatements%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterFunctionKeywordForAnonymousFunctions\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterFunctionKeywordForAnonymousFunctions%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceBeforeFunctionParenthesis\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceBeforeFunctionParenthesis%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.placeOpenBraceOnNewLineForFunctions\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.placeOpenBraceOnNewLineForFunctions%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.format.placeOpenBraceOnNewLineForControlBlocks\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%format.placeOpenBraceOnNewLineForControlBlocks%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.implicitProjectConfig.checkJs\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"%javascript.implicitProjectConfig.checkJs%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.implicitProjectConfig.experimentalDecorators\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"markdownDescription\": \"%javascript.implicitProjectConfig.experimentalDecorators%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.suggest.names\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.names%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.tsc.autoDetect\": {\n          \"type\": \"string\",\n          \"default\": \"on\",\n          \"enum\": [\n            \"on\",\n            \"off\",\n            \"build\",\n            \"watch\"\n          ],\n          \"markdownEnumDescriptions\": [\n            \"%typescript.tsc.autoDetect.on%\",\n            \"%typescript.tsc.autoDetect.off%\",\n            \"%typescript.tsc.autoDetect.build%\",\n            \"%typescript.tsc.autoDetect.watch%\"\n          ],\n          \"description\": \"%typescript.tsc.autoDetect%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.suggest.paths\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.paths%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggest.paths\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.paths%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.suggest.autoImports\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.autoImports%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggest.autoImports\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.autoImports%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.suggest.completeJSDocs\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.completeJSDocs%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggest.completeJSDocs\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.suggest.completeJSDocs%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.locale\": {\n          \"type\": [\n            \"string\",\n            \"null\"\n          ],\n          \"enum\": [\n            \"de\",\n            \"es\",\n            \"en\",\n            \"fr\",\n            \"it\",\n            \"ja\",\n            \"ko\",\n            \"ru\",\n            \"zh-CN\",\n            \"zh-TW\",\n            null\n          ],\n          \"default\": null,\n          \"markdownDescription\": \"%typescript.locale%\",\n          \"scope\": \"window\"\n        },\n        \"javascript.suggestionActions.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%javascript.suggestionActions.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggestionActions.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.suggestionActions.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.preferences.quoteStyle\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"auto\",\n            \"single\",\n            \"double\"\n          ],\n          \"default\": \"auto\",\n          \"markdownDescription\": \"%typescript.preferences.quoteStyle%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.preferences.quoteStyle\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"auto\",\n            \"single\",\n            \"double\"\n          ],\n          \"default\": \"auto\",\n          \"markdownDescription\": \"%typescript.preferences.quoteStyle%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.preferences.importModuleSpecifier\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"auto\",\n            \"relative\",\n            \"non-relative\"\n          ],\n          \"markdownEnumDescriptions\": [\n            \"%typescript.preferences.importModuleSpecifier.auto%\",\n            \"%typescript.preferences.importModuleSpecifier.relative%\",\n            \"%typescript.preferences.importModuleSpecifier.nonRelative%\"\n          ],\n          \"default\": \"auto\",\n          \"description\": \"%typescript.preferences.importModuleSpecifier%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.preferences.importModuleSpecifier\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"auto\",\n            \"relative\",\n            \"non-relative\"\n          ],\n          \"markdownEnumDescriptions\": [\n            \"%typescript.preferences.importModuleSpecifier.auto%\",\n            \"%typescript.preferences.importModuleSpecifier.relative%\",\n            \"%typescript.preferences.importModuleSpecifier.nonRelative%\"\n          ],\n          \"default\": \"auto\",\n          \"description\": \"%typescript.preferences.importModuleSpecifier%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.preferences.renameShorthandProperties\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.preferences.renameShorthandProperties%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.preferences.renameShorthandProperties\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.preferences.renameShorthandProperties%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.updateImportsOnFileMove.enabled\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"prompt\",\n            \"always\",\n            \"never\"\n          ],\n          \"markdownEnumDescriptions\": [\n            \"%typescript.updateImportsOnFileMove.enabled.prompt%\",\n            \"%typescript.updateImportsOnFileMove.enabled.always%\",\n            \"%typescript.updateImportsOnFileMove.enabled.never%\"\n          ],\n          \"default\": \"prompt\",\n          \"description\": \"%typescript.updateImportsOnFileMove.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"javascript.updateImportsOnFileMove.enabled\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"prompt\",\n            \"always\",\n            \"never\"\n          ],\n          \"markdownEnumDescriptions\": [\n            \"%typescript.updateImportsOnFileMove.enabled.prompt%\",\n            \"%typescript.updateImportsOnFileMove.enabled.always%\",\n            \"%typescript.updateImportsOnFileMove.enabled.never%\"\n          ],\n          \"default\": \"prompt\",\n          \"description\": \"%typescript.updateImportsOnFileMove.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.autoClosingTags\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.autoClosingTags%\"\n        },\n        \"javascript.autoClosingTags\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.autoClosingTags%\"\n        },\n        \"javascript.suggest.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.suggest.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.suggest.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%typescript.suggest.enabled%\",\n          \"scope\": \"resource\"\n        },\n        \"typescript.surveys.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.surveys.enabled%\",\n          \"scope\": \"window\"\n        },\n        \"typescript.tsserver.useSeparateSyntaxServer\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"%configuration.tsserver.useSeparateSyntaxServer%\",\n          \"scope\": \"window\"\n        }\n      }\n    },\n    \"commands\": [\n      {\n        \"command\": \"typescript.reloadProjects\",\n        \"title\": \"%reloadProjects.title%\",\n        \"category\": \"TypeScript\"\n      },\n      {\n        \"command\": \"javascript.reloadProjects\",\n        \"title\": \"%reloadProjects.title%\",\n        \"category\": \"JavaScript\"\n      },\n      {\n        \"command\": \"typescript.selectTypeScriptVersion\",\n        \"title\": \"%typescript.selectTypeScriptVersion.title%\",\n        \"category\": \"TypeScript\"\n      },\n      {\n        \"command\": \"typescript.goToProjectConfig\",\n        \"title\": \"%goToProjectConfig.title%\",\n        \"category\": \"TypeScript\"\n      },\n      {\n        \"command\": \"javascript.goToProjectConfig\",\n        \"title\": \"%goToProjectConfig.title%\",\n        \"category\": \"JavaScript\"\n      },\n      {\n        \"command\": \"typescript.openTsServerLog\",\n        \"title\": \"%typescript.openTsServerLog.title%\",\n        \"category\": \"TypeScript\"\n      },\n      {\n        \"command\": \"typescript.restartTsServer\",\n        \"title\": \"%typescript.restartTsServer%\",\n        \"category\": \"TypeScript\"\n      }\n    ],\n    \"menus\": {\n      \"commandPalette\": [\n        {\n          \"command\": \"typescript.reloadProjects\",\n          \"when\": \"editorLangId == typescript && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.reloadProjects\",\n          \"when\": \"editorLangId == typescriptreact && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"javascript.reloadProjects\",\n          \"when\": \"editorLangId == javascript && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"javascript.reloadProjects\",\n          \"when\": \"editorLangId == javascriptreact && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.goToProjectConfig\",\n          \"when\": \"editorLangId == typescript && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.goToProjectConfig\",\n          \"when\": \"editorLangId == typescriptreact\"\n        },\n        {\n          \"command\": \"javascript.goToProjectConfig\",\n          \"when\": \"editorLangId == javascript && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"javascript.goToProjectConfig\",\n          \"when\": \"editorLangId == javascriptreact && typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.selectTypeScriptVersion\",\n          \"when\": \"typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.openTsServerLog\",\n          \"when\": \"typescript.isManagedFile\"\n        },\n        {\n          \"command\": \"typescript.restartTsServer\",\n          \"when\": \"typescript.isManagedFile\"\n        }\n      ]\n    },\n    \"breakpoints\": [\n      {\n        \"language\": \"typescript\"\n      },\n      {\n        \"language\": \"typescriptreact\"\n      }\n    ],\n    \"taskDefinitions\": [\n      {\n        \"type\": \"typescript\",\n        \"required\": [\n          \"tsconfig\"\n        ],\n        \"properties\": {\n          \"tsconfig\": {\n            \"type\": \"string\",\n            \"description\": \"%taskDefinition.tsconfig.description%\"\n          },\n          \"option\": {\n            \"type\": \"string\"\n          }\n        }\n      }\n    ],\n    \"problemPatterns\": [\n      {\n        \"name\": \"tsc\",\n        \"regexp\": \"^([^\\\\s].*)[\\\\(:](\\\\d+)[,:](\\\\d+)(?:\\\\):\\\\s+|\\\\s+-\\\\s+)(error|warning|info)\\\\s+TS(\\\\d+)\\\\s*:\\\\s*(.*)$\",\n        \"file\": 1,\n        \"line\": 2,\n        \"column\": 3,\n        \"severity\": 4,\n        \"code\": 5,\n        \"message\": 6\n      }\n    ],\n    \"problemMatchers\": [\n      {\n        \"name\": \"tsc\",\n        \"label\": \"%typescript.problemMatchers.tsc.label%\",\n        \"owner\": \"typescript\",\n        \"source\": \"ts\",\n        \"applyTo\": \"closedDocuments\",\n        \"fileLocation\": [\n          \"relative\",\n          \"${cwd}\"\n        ],\n        \"pattern\": \"$tsc\"\n      },\n      {\n        \"name\": \"tsc-watch\",\n        \"label\": \"%typescript.problemMatchers.tscWatch.label%\",\n        \"owner\": \"typescript\",\n        \"source\": \"ts\",\n        \"applyTo\": \"closedDocuments\",\n        \"fileLocation\": [\n          \"relative\",\n          \"${cwd}\"\n        ],\n        \"pattern\": \"$tsc\",\n        \"background\": {\n          \"activeOnStart\": true,\n          \"beginsPattern\": {\n            \"regexp\": \"^\\\\s*(?:message TS6032:|\\\\[?\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM| a\\\\.m\\\\.| p\\\\.m\\\\.)?(?:\\\\]| -)) File change detected\\\\. Starting incremental compilation\\\\.\\\\.\\\\.\"\n          },\n          \"endsPattern\": {\n            \"regexp\": \"^\\\\s*(?:message TS6042:|\\\\[?\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}(?: AM| PM| a\\\\.m\\\\.| p\\\\.m\\\\.)?(?:\\\\]| -)) (?:Compilation complete\\\\.|Found \\\\d+ errors?\\\\.) Watching for file changes\\\\.\"\n          }\n        }\n      }\n    ]\n  }\n}\n","/typescript-language-features/out/extension.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"./api\");\r\nconst index_1 = require(\"./commands/index\");\r\nconst languageConfiguration_1 = require(\"./features/languageConfiguration\");\r\nconst typeScriptServiceClientHost_1 = require(\"./typeScriptServiceClientHost\");\r\nconst arrays_1 = require(\"./utils/arrays\");\r\nconst electron = require(\"./utils/electron\");\r\nconst rimraf = require(\"rimraf\");\r\nconst commandManager_1 = require(\"./utils/commandManager\");\r\nconst fileSchemes = require(\"./utils/fileSchemes\");\r\nconst languageDescription_1 = require(\"./utils/languageDescription\");\r\nconst lazy_1 = require(\"./utils/lazy\");\r\nconst logDirectoryProvider_1 = require(\"./utils/logDirectoryProvider\");\r\nconst managedFileContext_1 = require(\"./utils/managedFileContext\");\r\nconst plugins_1 = require(\"./utils/plugins\");\r\nconst ProjectStatus = require(\"./utils/projectStatus\");\r\nconst surveyor_1 = require(\"./utils/surveyor\");\r\nconst task_1 = require(\"./features/task\");\r\nfunction activate(context) {\r\n    const pluginManager = new plugins_1.PluginManager();\r\n    context.subscriptions.push(pluginManager);\r\n    const commandManager = new commandManager_1.CommandManager();\r\n    context.subscriptions.push(commandManager);\r\n    const onCompletionAccepted = new vscode.EventEmitter();\r\n    context.subscriptions.push(onCompletionAccepted);\r\n    const lazyClientHost = createLazyClientHost(context, pluginManager, commandManager, item => {\r\n        onCompletionAccepted.fire(item);\r\n    });\r\n    index_1.registerCommands(commandManager, lazyClientHost, pluginManager);\r\n    context.subscriptions.push(vscode.workspace.registerTaskProvider('typescript', new task_1.default(lazyClientHost.map(x => x.serviceClient))));\r\n    context.subscriptions.push(new languageConfiguration_1.LanguageConfigurationManager());\r\n    Promise.resolve().then(() => require('./features/tsconfig')).then(module => {\r\n        context.subscriptions.push(module.register());\r\n    });\r\n    context.subscriptions.push(lazilyActivateClient(lazyClientHost, pluginManager));\r\n    return api_1.getExtensionApi(onCompletionAccepted.event, pluginManager);\r\n}\r\nexports.activate = activate;\r\nfunction createLazyClientHost(context, pluginManager, commandManager, onCompletionAccepted) {\r\n    return lazy_1.lazy(() => {\r\n        const logDirectoryProvider = new logDirectoryProvider_1.default(context);\r\n        const clientHost = new typeScriptServiceClientHost_1.default(languageDescription_1.standardLanguageDescriptions, context.workspaceState, pluginManager, commandManager, logDirectoryProvider, onCompletionAccepted);\r\n        context.subscriptions.push(clientHost);\r\n        context.subscriptions.push(new surveyor_1.Surveyor(context.globalState, clientHost.serviceClient));\r\n        clientHost.serviceClient.onReady(() => {\r\n            context.subscriptions.push(ProjectStatus.create(clientHost.serviceClient, clientHost.serviceClient.telemetryReporter));\r\n        });\r\n        return clientHost;\r\n    });\r\n}\r\nfunction lazilyActivateClient(lazyClientHost, pluginManager) {\r\n    const disposables = [];\r\n    const supportedLanguage = arrays_1.flatten([\r\n        ...languageDescription_1.standardLanguageDescriptions.map(x => x.modeIds),\r\n        ...pluginManager.plugins.map(x => x.languages)\r\n    ]);\r\n    let hasActivated = false;\r\n    const maybeActivate = (textDocument) => {\r\n        if (!hasActivated && isSupportedDocument(supportedLanguage, textDocument)) {\r\n            hasActivated = true;\r\n            // Force activation\r\n            // tslint:disable-next-line:no-unused-expression\r\n            void lazyClientHost.value;\r\n            disposables.push(new managedFileContext_1.default(resource => {\r\n                return lazyClientHost.value.serviceClient.toPath(resource);\r\n            }));\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    const didActivate = vscode.workspace.textDocuments.some(maybeActivate);\r\n    if (!didActivate) {\r\n        const openListener = vscode.workspace.onDidOpenTextDocument(doc => {\r\n            if (maybeActivate(doc)) {\r\n                openListener.dispose();\r\n            }\r\n        }, undefined, disposables);\r\n    }\r\n    return vscode.Disposable.from(...disposables);\r\n}\r\nfunction isSupportedDocument(supportedLanguage, document) {\r\n    if (supportedLanguage.indexOf(document.languageId) < 0) {\r\n        return false;\r\n    }\r\n    return fileSchemes.isSupportedScheme(document.uri.scheme);\r\n}\r\nfunction deactivate() {\r\n    rimraf.sync(electron.getInstanceDir());\r\n}\r\nexports.deactivate = deactivate;\r\n//# sourceMappingURL=extension.js.map","/typescript-language-features/out/api.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass ApiV0 {\r\n    constructor(onCompletionAccepted, _pluginManager) {\r\n        this.onCompletionAccepted = onCompletionAccepted;\r\n        this._pluginManager = _pluginManager;\r\n    }\r\n    configurePlugin(pluginId, configuration) {\r\n        this._pluginManager.setConfiguration(pluginId, configuration);\r\n    }\r\n}\r\nfunction getExtensionApi(onCompletionAccepted, pluginManager) {\r\n    return {\r\n        getAPI(version) {\r\n            if (version === 0) {\r\n                return new ApiV0(onCompletionAccepted, pluginManager);\r\n            }\r\n            return undefined;\r\n        }\r\n    };\r\n}\r\nexports.getExtensionApi = getExtensionApi;\r\n//# sourceMappingURL=api.js.map","/typescript-language-features/out/commands/index.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst configurePlugin_1 = require(\"./configurePlugin\");\r\nconst goToProjectConfiguration_1 = require(\"./goToProjectConfiguration\");\r\nconst openTsServerLog_1 = require(\"./openTsServerLog\");\r\nconst reloadProject_1 = require(\"./reloadProject\");\r\nconst restartTsServer_1 = require(\"./restartTsServer\");\r\nconst selectTypeScriptVersion_1 = require(\"./selectTypeScriptVersion\");\r\nfunction registerCommands(commandManager, lazyClientHost, pluginManager) {\r\n    commandManager.register(new reloadProject_1.ReloadTypeScriptProjectsCommand(lazyClientHost));\r\n    commandManager.register(new reloadProject_1.ReloadJavaScriptProjectsCommand(lazyClientHost));\r\n    commandManager.register(new selectTypeScriptVersion_1.SelectTypeScriptVersionCommand(lazyClientHost));\r\n    commandManager.register(new openTsServerLog_1.OpenTsServerLogCommand(lazyClientHost));\r\n    commandManager.register(new restartTsServer_1.RestartTsServerCommand(lazyClientHost));\r\n    commandManager.register(new goToProjectConfiguration_1.TypeScriptGoToProjectConfigCommand(lazyClientHost));\r\n    commandManager.register(new goToProjectConfiguration_1.JavaScriptGoToProjectConfigCommand(lazyClientHost));\r\n    commandManager.register(new configurePlugin_1.ConfigurePluginCommand(pluginManager));\r\n}\r\nexports.registerCommands = registerCommands;\r\n//# sourceMappingURL=index.js.map","/typescript-language-features/out/commands/configurePlugin.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass ConfigurePluginCommand {\r\n    constructor(pluginManager) {\r\n        this.pluginManager = pluginManager;\r\n        this.id = '_typescript.configurePlugin';\r\n    }\r\n    execute(pluginId, configuration) {\r\n        this.pluginManager.setConfiguration(pluginId, configuration);\r\n    }\r\n}\r\nexports.ConfigurePluginCommand = ConfigurePluginCommand;\r\n//# sourceMappingURL=configurePlugin.js.map","/typescript-language-features/out/commands/goToProjectConfiguration.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst tsconfig_1 = require(\"../utils/tsconfig\");\r\nconst localize = nls.loadMessageBundle();\r\nclass TypeScriptGoToProjectConfigCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'typescript.goToProjectConfig';\r\n    }\r\n    execute() {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor) {\r\n            goToProjectConfig(this.lazyClientHost.value, true, editor.document.uri);\r\n        }\r\n    }\r\n}\r\nexports.TypeScriptGoToProjectConfigCommand = TypeScriptGoToProjectConfigCommand;\r\nclass JavaScriptGoToProjectConfigCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'javascript.goToProjectConfig';\r\n    }\r\n    execute() {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor) {\r\n            goToProjectConfig(this.lazyClientHost.value, false, editor.document.uri);\r\n        }\r\n    }\r\n}\r\nexports.JavaScriptGoToProjectConfigCommand = JavaScriptGoToProjectConfigCommand;\r\nasync function goToProjectConfig(clientHost, isTypeScriptProject, resource) {\r\n    const client = clientHost.serviceClient;\r\n    const rootPath = client.getWorkspaceRootForResource(resource);\r\n    if (!rootPath) {\r\n        vscode.window.showInformationMessage(localize('typescript.projectConfigNoWorkspace', 'Please open a folder in VS Code to use a TypeScript or JavaScript project'));\r\n        return;\r\n    }\r\n    const file = client.toPath(resource);\r\n    // TSServer errors when 'projectInfo' is invoked on a non js/ts file\r\n    if (!file || !await clientHost.handles(resource)) {\r\n        vscode.window.showWarningMessage(localize('typescript.projectConfigUnsupportedFile', 'Could not determine TypeScript or JavaScript project. Unsupported file type'));\r\n        return;\r\n    }\r\n    let res;\r\n    try {\r\n        res = await client.execute('projectInfo', { file, needFileNameList: false }, cancellation_1.nulToken);\r\n    }\r\n    catch (_a) {\r\n        // noop\r\n    }\r\n    if (!res || res.type !== 'response' || !res.body) {\r\n        vscode.window.showWarningMessage(localize('typescript.projectConfigCouldNotGetInfo', 'Could not determine TypeScript or JavaScript project'));\r\n        return;\r\n    }\r\n    const { configFileName } = res.body;\r\n    if (configFileName && !tsconfig_1.isImplicitProjectConfigFile(configFileName)) {\r\n        const doc = await vscode.workspace.openTextDocument(configFileName);\r\n        vscode.window.showTextDocument(doc, vscode.window.activeTextEditor ? vscode.window.activeTextEditor.viewColumn : undefined);\r\n        return;\r\n    }\r\n    let ProjectConfigAction;\r\n    (function (ProjectConfigAction) {\r\n        ProjectConfigAction[ProjectConfigAction[\"None\"] = 0] = \"None\";\r\n        ProjectConfigAction[ProjectConfigAction[\"CreateConfig\"] = 1] = \"CreateConfig\";\r\n        ProjectConfigAction[ProjectConfigAction[\"LearnMore\"] = 2] = \"LearnMore\";\r\n    })(ProjectConfigAction || (ProjectConfigAction = {}));\r\n    const selected = await vscode.window.showInformationMessage((isTypeScriptProject\r\n        ? localize('typescript.noTypeScriptProjectConfig', 'File is not part of a TypeScript project. Click [here]({0}) to learn more.', 'https://go.microsoft.com/fwlink/?linkid=841896')\r\n        : localize('typescript.noJavaScriptProjectConfig', 'File is not part of a JavaScript project Click [here]({0}) to learn more.', 'https://go.microsoft.com/fwlink/?linkid=759670')), {\r\n        title: isTypeScriptProject\r\n            ? localize('typescript.configureTsconfigQuickPick', 'Configure tsconfig.json')\r\n            : localize('typescript.configureJsconfigQuickPick', 'Configure jsconfig.json'),\r\n        id: ProjectConfigAction.CreateConfig,\r\n    });\r\n    switch (selected && selected.id) {\r\n        case ProjectConfigAction.CreateConfig:\r\n            tsconfig_1.openOrCreateConfigFile(isTypeScriptProject, rootPath, client.configuration);\r\n            return;\r\n    }\r\n}\r\n//# sourceMappingURL=goToProjectConfiguration.js.map","/typescript-language-features/node_modules/vscode-nls/package.json":"{\n\t\"name\": \"vscode-nls\",\n\t\"version\": \"4.0.0\",\n\t\"description\": \"NPM module to externalize and localize VSCode extensions\",\n\t\"author\": \"Microsoft Corporation\",\n\t\"license\": \"MIT\",\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://github.com/Microsoft/vscode-nls.git\"\n\t},\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/Microsoft/vscode-nls/issues\"\n\t},\n\t\"main\": \"./lib/main.js\",\n\t\"typings\": \"./lib/main\",\n\t\"devDependencies\": {\n\t\t\"@types/node\": \"^6.0.96\",\n\t\t\"@types/mocha\": \"^2.2.46\",\n\t\t\"mocha\": \"^5.0.0\",\n\t\t\"typescript\": \"^2.6.2\"\n\t},\n\t\"scripts\": {\n\t\t\"prepublish\": \"tsc -p ./src\",\n\t\t\"compile\": \"tsc -p ./src\",\n\t\t\"watch\": \"tsc -w -p ./src\",\n\t\t\"test\": \"mocha\"\n\t}\n}\n","/typescript-language-features/node_modules/vscode-nls/lib/main.js":"/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar path = require(\"path\");\r\nvar fs = require(\"fs\");\r\nvar toString = Object.prototype.toString;\r\nfunction isDefined(value) {\r\n    return typeof value !== 'undefined';\r\n}\r\nfunction isNumber(value) {\r\n    return toString.call(value) === '[object Number]';\r\n}\r\nfunction isString(value) {\r\n    return toString.call(value) === '[object String]';\r\n}\r\nfunction isBoolean(value) {\r\n    return value === true || value === false;\r\n}\r\nfunction readJsonFileSync(filename) {\r\n    return JSON.parse(fs.readFileSync(filename, 'utf8'));\r\n}\r\nvar MessageFormat;\r\n(function (MessageFormat) {\r\n    MessageFormat[\"file\"] = \"file\";\r\n    MessageFormat[\"bundle\"] = \"bundle\";\r\n    MessageFormat[\"both\"] = \"both\";\r\n})(MessageFormat = exports.MessageFormat || (exports.MessageFormat = {}));\r\nvar LocalizeInfo;\r\n(function (LocalizeInfo) {\r\n    function is(value) {\r\n        var candidate = value;\r\n        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);\r\n    }\r\n    LocalizeInfo.is = is;\r\n})(LocalizeInfo || (LocalizeInfo = {}));\r\nvar resolvedLanguage;\r\nvar resolvedBundles;\r\nvar options;\r\nvar isPseudo;\r\nfunction initializeSettings() {\r\n    options = { locale: undefined, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: MessageFormat.bundle };\r\n    if (isString(process.env.VSCODE_NLS_CONFIG)) {\r\n        try {\r\n            var vscodeOptions = JSON.parse(process.env.VSCODE_NLS_CONFIG);\r\n            if (isString(vscodeOptions.locale)) {\r\n                options.locale = vscodeOptions.locale.toLowerCase();\r\n            }\r\n            if (isBoolean(vscodeOptions._languagePackSupport)) {\r\n                options.languagePackSupport = vscodeOptions._languagePackSupport;\r\n            }\r\n            if (isString(vscodeOptions._cacheRoot)) {\r\n                options.cacheRoot = vscodeOptions._cacheRoot;\r\n            }\r\n            if (isString(vscodeOptions._languagePackId)) {\r\n                options.languagePackId = vscodeOptions._languagePackId;\r\n            }\r\n            if (isString(vscodeOptions._translationsConfigFile)) {\r\n                options.translationsConfigFile = vscodeOptions._translationsConfigFile;\r\n                try {\r\n                    options.translationsConfig = readJsonFileSync(options.translationsConfigFile);\r\n                }\r\n                catch (error) {\r\n                    // We can't read the translation config file. Mark the cache as corrupted.\r\n                    if (vscodeOptions._corruptedFile) {\r\n                        fs.writeFile(vscodeOptions._corruptedFile, 'corrupted', 'utf8', function (err) {\r\n                            console.error(err);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // Do nothing.\r\n        }\r\n    }\r\n    isPseudo = options.locale === 'pseudo';\r\n    resolvedLanguage = undefined;\r\n    resolvedBundles = Object.create(null);\r\n}\r\ninitializeSettings();\r\nfunction supportsLanguagePack() {\r\n    return options.languagePackSupport === true && options.cacheRoot !== undefined && options.languagePackId !== undefined && options.translationsConfigFile !== undefined\r\n        && options.translationsConfig !== undefined;\r\n}\r\nfunction format(message, args) {\r\n    var result;\r\n    if (isPseudo) {\r\n        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\r\n        message = '\\uFF3B' + message.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\r\n    }\r\n    if (args.length === 0) {\r\n        result = message;\r\n    }\r\n    else {\r\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\r\n            var index = rest[0];\r\n            var arg = args[index];\r\n            var replaced = match;\r\n            if (typeof arg === 'string') {\r\n                replaced = arg;\r\n            }\r\n            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\r\n                replaced = String(arg);\r\n            }\r\n            return replaced;\r\n        });\r\n    }\r\n    return result;\r\n}\r\nfunction createScopedLocalizeFunction(messages) {\r\n    return function (key, message) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        if (isNumber(key)) {\r\n            if (key >= messages.length) {\r\n                console.error(\"Broken localize call found. Index out of bounds. Stacktrace is\\n: \" + new Error('').stack);\r\n                return;\r\n            }\r\n            return format(messages[key], args);\r\n        }\r\n        else {\r\n            if (isString(message)) {\r\n                console.warn(\"Message \" + message + \" didn't get externalized correctly.\");\r\n                return format(message, args);\r\n            }\r\n            else {\r\n                console.error(\"Broken localize call found. Stacktrace is\\n: \" + new Error('').stack);\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction localize(key, message) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    return format(message, args);\r\n}\r\nfunction resolveLanguage(file) {\r\n    var resolvedLanguage;\r\n    if (options.cacheLanguageResolution && resolvedLanguage) {\r\n        resolvedLanguage = resolvedLanguage;\r\n    }\r\n    else {\r\n        if (isPseudo || !options.locale) {\r\n            resolvedLanguage = '.nls.json';\r\n        }\r\n        else {\r\n            var locale = options.locale;\r\n            while (locale) {\r\n                var candidate = '.nls.' + locale + '.json';\r\n                if (fs.existsSync(file + candidate)) {\r\n                    resolvedLanguage = candidate;\r\n                    break;\r\n                }\r\n                else {\r\n                    var index = locale.lastIndexOf('-');\r\n                    if (index > 0) {\r\n                        locale = locale.substring(0, index);\r\n                    }\r\n                    else {\r\n                        resolvedLanguage = '.nls.json';\r\n                        locale = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (options.cacheLanguageResolution) {\r\n            resolvedLanguage = resolvedLanguage;\r\n        }\r\n    }\r\n    return file + resolvedLanguage;\r\n}\r\nfunction findInTheBoxBundle(root) {\r\n    var locale = options.locale;\r\n    while (locale) {\r\n        var candidate = path.join(root, \"nls.bundle.\" + locale + \".json\");\r\n        if (fs.existsSync(candidate)) {\r\n            return candidate;\r\n        }\r\n        else {\r\n            var index = locale.lastIndexOf('-');\r\n            if (index > 0) {\r\n                locale = locale.substring(0, index);\r\n            }\r\n            else {\r\n                locale = undefined;\r\n            }\r\n        }\r\n    }\r\n    // Test if we can reslove the default bundle.\r\n    if (locale === undefined) {\r\n        var candidate = path.join(root, 'nls.bundle.json');\r\n        if (fs.existsSync(candidate)) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nfunction mkdir(directory) {\r\n    try {\r\n        fs.mkdirSync(directory);\r\n    }\r\n    catch (err) {\r\n        if (err.code === 'EEXIST') {\r\n            return;\r\n        }\r\n        else if (err.code === 'ENOENT') {\r\n            var parent = path.dirname(directory);\r\n            if (parent !== directory) {\r\n                mkdir(parent);\r\n                fs.mkdirSync(directory);\r\n            }\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n}\r\nfunction createDefaultNlsBundle(folder) {\r\n    var metaData = readJsonFileSync(path.join(folder, 'nls.metadata.json'));\r\n    var result = Object.create(null);\r\n    for (var module_1 in metaData) {\r\n        var entry = metaData[module_1];\r\n        result[module_1] = entry.messages;\r\n    }\r\n    return result;\r\n}\r\nfunction createNLSBundle(header, metaDataPath) {\r\n    var languagePackLocation = options.translationsConfig[header.id];\r\n    if (!languagePackLocation) {\r\n        return undefined;\r\n    }\r\n    var languagePack = readJsonFileSync(languagePackLocation).contents;\r\n    var metaData = readJsonFileSync(path.join(metaDataPath, 'nls.metadata.json'));\r\n    var result = Object.create(null);\r\n    for (var module_2 in metaData) {\r\n        var entry = metaData[module_2];\r\n        var translations = languagePack[header.outDir + \"/\" + module_2];\r\n        if (translations) {\r\n            var resultMessages = [];\r\n            for (var i = 0; i < entry.keys.length; i++) {\r\n                var messageKey = entry.keys[i];\r\n                var key = isString(messageKey) ? messageKey : messageKey.key;\r\n                var translatedMessage = translations[key];\r\n                if (translatedMessage === undefined) {\r\n                    translatedMessage = entry.messages[i];\r\n                }\r\n                resultMessages.push(translatedMessage);\r\n            }\r\n            result[module_2] = resultMessages;\r\n        }\r\n        else {\r\n            result[module_2] = entry.messages;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction touch(file) {\r\n    var d = new Date();\r\n    fs.utimes(file, d, d, function () {\r\n        // Do nothing. Ignore\r\n    });\r\n}\r\nfunction cacheBundle(key, bundle) {\r\n    resolvedBundles[key] = bundle;\r\n    return bundle;\r\n}\r\nfunction loadNlsBundleOrCreateFromI18n(header, bundlePath) {\r\n    var result;\r\n    var bundle = path.join(options.cacheRoot, header.id + \"-\" + header.hash + \".json\");\r\n    var useMemoryOnly = false;\r\n    var writeBundle = false;\r\n    try {\r\n        result = JSON.parse(fs.readFileSync(bundle, { encoding: 'utf8', flag: 'r' }));\r\n        touch(bundle);\r\n        return result;\r\n    }\r\n    catch (err) {\r\n        if (err.code === 'ENOENT') {\r\n            writeBundle = true;\r\n        }\r\n        else if (err instanceof SyntaxError) {\r\n            // We have a syntax error. So no valid JSON. Use\r\n            console.log(\"Syntax error parsing message bundle: \" + err.message + \".\");\r\n            fs.unlink(bundle, function (err) {\r\n                if (err) {\r\n                    console.error(\"Deleting corrupted bundle \" + bundle + \" failed.\");\r\n                }\r\n            });\r\n            useMemoryOnly = true;\r\n        }\r\n        else {\r\n            throw err;\r\n        }\r\n    }\r\n    result = createNLSBundle(header, bundlePath);\r\n    if (!result || useMemoryOnly) {\r\n        return result;\r\n    }\r\n    if (writeBundle) {\r\n        try {\r\n            fs.writeFileSync(bundle, JSON.stringify(result), { encoding: 'utf8', flag: 'wx' });\r\n        }\r\n        catch (err) {\r\n            if (err.code === 'EEXIST') {\r\n                return result;\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction loadDefaultNlsBundle(bundlePath) {\r\n    try {\r\n        return createDefaultNlsBundle(bundlePath);\r\n    }\r\n    catch (err) {\r\n        console.log(\"Generating default bundle from meta data failed.\", err);\r\n        return undefined;\r\n    }\r\n}\r\nfunction loadNlsBundle(header, bundlePath) {\r\n    var result;\r\n    // Core decided to use a language pack. Do the same in the extension\r\n    if (supportsLanguagePack()) {\r\n        try {\r\n            result = loadNlsBundleOrCreateFromI18n(header, bundlePath);\r\n        }\r\n        catch (err) {\r\n            console.log(\"Load or create bundle failed \", err);\r\n        }\r\n    }\r\n    if (!result) {\r\n        // No language pack found, but core is running in language pack mode\r\n        // Don't try to use old in the box bundles since the might be stale\r\n        // Fall right back to the default bundle.\r\n        if (options.languagePackSupport) {\r\n            return loadDefaultNlsBundle(bundlePath);\r\n        }\r\n        var candidate = findInTheBoxBundle(bundlePath);\r\n        if (candidate) {\r\n            try {\r\n                return readJsonFileSync(candidate);\r\n            }\r\n            catch (err) {\r\n                console.log(\"Loading in the box message bundle failed.\", err);\r\n            }\r\n        }\r\n        result = loadDefaultNlsBundle(bundlePath);\r\n    }\r\n    return result;\r\n}\r\nfunction tryFindMetaDataHeaderFile(file) {\r\n    var result;\r\n    var dirname = path.dirname(file);\r\n    while (true) {\r\n        result = path.join(dirname, 'nls.metadata.header.json');\r\n        if (fs.existsSync(result)) {\r\n            break;\r\n        }\r\n        var parent = path.dirname(dirname);\r\n        if (parent === dirname) {\r\n            result = undefined;\r\n            break;\r\n        }\r\n        else {\r\n            dirname = parent;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction loadMessageBundle(file) {\r\n    if (!file) {\r\n        // No file. We are in dev mode. Return the default\r\n        // localize function.\r\n        return localize;\r\n    }\r\n    // Remove extension since we load json files.\r\n    var ext = path.extname(file);\r\n    if (ext) {\r\n        file = file.substr(0, file.length - ext.length);\r\n    }\r\n    if (options.messageFormat === MessageFormat.both || options.messageFormat === MessageFormat.bundle) {\r\n        var headerFile = tryFindMetaDataHeaderFile(file);\r\n        if (headerFile) {\r\n            var bundlePath = path.dirname(headerFile);\r\n            var bundle = resolvedBundles[bundlePath];\r\n            if (bundle === undefined) {\r\n                try {\r\n                    var header = JSON.parse(fs.readFileSync(headerFile, 'utf8'));\r\n                    try {\r\n                        var nlsBundle = loadNlsBundle(header, bundlePath);\r\n                        bundle = cacheBundle(bundlePath, nlsBundle ? { header: header, nlsBundle: nlsBundle } : null);\r\n                    }\r\n                    catch (err) {\r\n                        console.error('Failed to load nls bundle', err);\r\n                        bundle = cacheBundle(bundlePath, null);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    console.error('Failed to read header file', err);\r\n                    bundle = cacheBundle(bundlePath, null);\r\n                }\r\n            }\r\n            if (bundle) {\r\n                var module_3 = file.substr(bundlePath.length + 1).replace(/\\\\/g, '/');\r\n                var messages = bundle.nlsBundle[module_3];\r\n                if (messages === undefined) {\r\n                    console.error(\"Messages for file \" + file + \" not found. See console for details.\");\r\n                    return function () {\r\n                        return 'Messages not found.';\r\n                    };\r\n                }\r\n                return createScopedLocalizeFunction(messages);\r\n            }\r\n        }\r\n    }\r\n    if (options.messageFormat === MessageFormat.both || options.messageFormat === MessageFormat.file) {\r\n        // Try to load a single file bundle\r\n        try {\r\n            var json = readJsonFileSync(resolveLanguage(file));\r\n            if (Array.isArray(json)) {\r\n                return createScopedLocalizeFunction(json);\r\n            }\r\n            else {\r\n                if (isDefined(json.messages) && isDefined(json.keys)) {\r\n                    return createScopedLocalizeFunction(json.messages);\r\n                }\r\n                else {\r\n                    console.error(\"String bundle '\" + file + \"' uses an unsupported format.\");\r\n                    return function () {\r\n                        return 'File bundle has unsupported format. See console for details';\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err.code !== 'ENOENT') {\r\n                console.error('Failed to load single file bundle', err);\r\n            }\r\n        }\r\n    }\r\n    console.error(\"Failed to load message bundle for file \" + file);\r\n    return function () {\r\n        return 'Failed to load message bundle. See console for details.';\r\n    };\r\n}\r\nexports.loadMessageBundle = loadMessageBundle;\r\nfunction config(opts) {\r\n    if (opts) {\r\n        if (isString(opts.locale)) {\r\n            options.locale = opts.locale.toLowerCase();\r\n            resolvedLanguage = undefined;\r\n            resolvedBundles = Object.create(null);\r\n        }\r\n        if (opts.messageFormat !== undefined) {\r\n            options.messageFormat = opts.messageFormat;\r\n        }\r\n    }\r\n    isPseudo = options.locale === 'pseudo';\r\n    return loadMessageBundle;\r\n}\r\nexports.config = config;\r\n//# sourceMappingURL=main.js.map","/typescript-language-features/out/utils/cancellation.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nulTokenSource = new vscode.CancellationTokenSource();\r\nexports.nulToken = nulTokenSource.token;\r\n//# sourceMappingURL=cancellation.js.map","/typescript-language-features/out/utils/tsconfig.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nfunction isImplicitProjectConfigFile(configFileName) {\r\n    return configFileName.indexOf('/dev/null/') === 0;\r\n}\r\nexports.isImplicitProjectConfigFile = isImplicitProjectConfigFile;\r\nfunction inferredProjectConfig(config) {\r\n    const base = {\r\n        module: 'commonjs',\r\n        target: 'es2016',\r\n        jsx: 'preserve'\r\n    };\r\n    if (config.checkJs) {\r\n        base.checkJs = true;\r\n    }\r\n    if (config.experimentalDecorators) {\r\n        base.experimentalDecorators = true;\r\n    }\r\n    return base;\r\n}\r\nexports.inferredProjectConfig = inferredProjectConfig;\r\nfunction inferredProjectConfigSnippet(config) {\r\n    const baseConfig = inferredProjectConfig(config);\r\n    const compilerOptions = Object.keys(baseConfig).map(key => `\"${key}\": ${JSON.stringify(baseConfig[key])}`);\r\n    return new vscode.SnippetString(`{\n\t\"compilerOptions\": {\n\t\t${compilerOptions.join(',\\n\\t\\t')}$0\n\t},\n\t\"exclude\": [\n\t\t\"node_modules\",\n\t\t\"**/node_modules/*\"\n\t]\n}`);\r\n}\r\nasync function openOrCreateConfigFile(isTypeScriptProject, rootPath, config) {\r\n    const configFile = vscode.Uri.file(path.join(rootPath, isTypeScriptProject ? 'tsconfig.json' : 'jsconfig.json'));\r\n    const col = vscode.window.activeTextEditor ? vscode.window.activeTextEditor.viewColumn : undefined;\r\n    try {\r\n        const doc = await vscode.workspace.openTextDocument(configFile);\r\n        return vscode.window.showTextDocument(doc, col);\r\n    }\r\n    catch (_a) {\r\n        const doc = await vscode.workspace.openTextDocument(configFile.with({ scheme: 'untitled' }));\r\n        const editor = await vscode.window.showTextDocument(doc, col);\r\n        if (editor.document.getText().length === 0) {\r\n            await editor.insertSnippet(inferredProjectConfigSnippet(config));\r\n        }\r\n        return editor;\r\n    }\r\n}\r\nexports.openOrCreateConfigFile = openOrCreateConfigFile;\r\n//# sourceMappingURL=tsconfig.js.map","/typescript-language-features/out/commands/openTsServerLog.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass OpenTsServerLogCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'typescript.openTsServerLog';\r\n    }\r\n    execute() {\r\n        this.lazyClientHost.value.serviceClient.openTsServerLogFile();\r\n    }\r\n}\r\nexports.OpenTsServerLogCommand = OpenTsServerLogCommand;\r\n//# sourceMappingURL=openTsServerLog.js.map","/typescript-language-features/out/commands/reloadProject.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass ReloadTypeScriptProjectsCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'typescript.reloadProjects';\r\n    }\r\n    execute() {\r\n        this.lazyClientHost.value.reloadProjects();\r\n    }\r\n}\r\nexports.ReloadTypeScriptProjectsCommand = ReloadTypeScriptProjectsCommand;\r\nclass ReloadJavaScriptProjectsCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'javascript.reloadProjects';\r\n    }\r\n    execute() {\r\n        this.lazyClientHost.value.reloadProjects();\r\n    }\r\n}\r\nexports.ReloadJavaScriptProjectsCommand = ReloadJavaScriptProjectsCommand;\r\n//# sourceMappingURL=reloadProject.js.map","/typescript-language-features/out/commands/restartTsServer.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass RestartTsServerCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'typescript.restartTsServer';\r\n    }\r\n    execute() {\r\n        this.lazyClientHost.value.serviceClient.restartTsServer();\r\n    }\r\n}\r\nexports.RestartTsServerCommand = RestartTsServerCommand;\r\n//# sourceMappingURL=restartTsServer.js.map","/typescript-language-features/out/commands/selectTypeScriptVersion.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass SelectTypeScriptVersionCommand {\r\n    constructor(lazyClientHost) {\r\n        this.lazyClientHost = lazyClientHost;\r\n        this.id = 'typescript.selectTypeScriptVersion';\r\n    }\r\n    execute() {\r\n        this.lazyClientHost.value.serviceClient.onVersionStatusClicked();\r\n    }\r\n}\r\nexports.SelectTypeScriptVersionCommand = SelectTypeScriptVersionCommand;\r\n//# sourceMappingURL=selectTypeScriptVersion.js.map","/typescript-language-features/out/features/languageConfiguration.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* --------------------------------------------------------------------------------------------\r\n * Includes code from typescript-sublime-plugin project, obtained from\r\n * https://github.com/Microsoft/TypeScript-Sublime-Plugin/blob/master/TypeScript%20Indent.tmPreferences\r\n * ------------------------------------------------------------------------------------------ */\r\nconst vscode = require(\"vscode\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nconst languageModeIds = require(\"../utils/languageModeIds\");\r\nconst jsTsLanguageConfiguration = {\r\n    indentationRules: {\r\n        decreaseIndentPattern: /^((?!.*?\\/\\*).*\\*\\/)?\\s*[\\}\\]].*$/,\r\n        increaseIndentPattern: /^((?!\\/\\/).)*(\\{[^}\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$/\r\n    },\r\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g,\r\n    onEnterRules: [\r\n        {\r\n            // e.g. /** | */\r\n            beforeText: /^\\s*\\/\\*\\*(?!\\/)([^\\*]|\\*(?!\\/))*$/,\r\n            afterText: /^\\s*\\*\\/$/,\r\n            action: { indentAction: vscode.IndentAction.IndentOutdent, appendText: ' * ' },\r\n        }, {\r\n            // e.g. /** ...|\r\n            beforeText: /^\\s*\\/\\*\\*(?!\\/)([^\\*]|\\*(?!\\/))*$/,\r\n            action: { indentAction: vscode.IndentAction.None, appendText: ' * ' },\r\n        }, {\r\n            // e.g.  * ...|\r\n            beforeText: /^(\\t|[ ])*[ ]\\*([ ]([^\\*]|\\*(?!\\/))*)?$/,\r\n            oneLineAboveText: /^(\\s*(\\/\\*\\*|\\*)).*/,\r\n            action: { indentAction: vscode.IndentAction.None, appendText: '* ' },\r\n        }, {\r\n            // e.g.  */|\r\n            beforeText: /^(\\t|[ ])*[ ]\\*\\/\\s*$/,\r\n            action: { indentAction: vscode.IndentAction.None, removeText: 1 },\r\n        },\r\n        {\r\n            // e.g.  *-----*/|\r\n            beforeText: /^(\\t|[ ])*[ ]\\*[^/]*\\*\\/\\s*$/,\r\n            action: { indentAction: vscode.IndentAction.None, removeText: 1 },\r\n        },\r\n        {\r\n            beforeText: /^\\s*(\\bcase\\s.+:|\\bdefault:)$/,\r\n            afterText: /^(?!\\s*(\\bcase\\b|\\bdefault\\b))/,\r\n            action: { indentAction: vscode.IndentAction.Indent },\r\n        }\r\n    ]\r\n};\r\nconst EMPTY_ELEMENTS = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr'];\r\nconst jsxTagsLanguageConfiguration = {\r\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\$\\^\\&\\*\\(\\)\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\s]+)/g,\r\n    onEnterRules: [\r\n        {\r\n            beforeText: new RegExp(`<(?!(?:${EMPTY_ELEMENTS.join('|')}))([_:\\\\w][_:\\\\w\\\\-.\\\\d]*)([^/>]*(?!/)>)[^<]*$`, 'i'),\r\n            afterText: /^<\\/([_:\\w][_:\\w-.\\d]*)\\s*>$/i,\r\n            action: { indentAction: vscode.IndentAction.IndentOutdent }\r\n        },\r\n        {\r\n            beforeText: new RegExp(`<(?!(?:${EMPTY_ELEMENTS.join('|')}))([_:\\\\w][_:\\\\w\\\\-.\\\\d]*)([^/>]*(?!/)>)[^<]*$`, 'i'),\r\n            action: { indentAction: vscode.IndentAction.Indent }\r\n        },\r\n        {\r\n            // `beforeText` only applies to tokens of a given language. Since we are dealing with jsx-tags,\r\n            // make sure we apply to the closing `>` of a tag so that mixed language spans\r\n            // such as `<div onclick={1}>` are handled properly.\r\n            beforeText: /^>$/,\r\n            afterText: /^<\\/([_:\\w][_:\\w-.\\d]*)\\s*>$/i,\r\n            action: { indentAction: vscode.IndentAction.IndentOutdent }\r\n        },\r\n        {\r\n            beforeText: /^>$/,\r\n            action: { indentAction: vscode.IndentAction.Indent }\r\n        },\r\n    ],\r\n};\r\nclass LanguageConfigurationManager extends dispose_1.Disposable {\r\n    constructor() {\r\n        super();\r\n        const standardLanguages = [\r\n            languageModeIds.javascript,\r\n            languageModeIds.javascriptreact,\r\n            languageModeIds.typescript,\r\n            languageModeIds.typescriptreact,\r\n        ];\r\n        for (const language of standardLanguages) {\r\n            this.registerConfiguration(language, jsTsLanguageConfiguration);\r\n        }\r\n        this.registerConfiguration(languageModeIds.jsxTags, jsxTagsLanguageConfiguration);\r\n    }\r\n    registerConfiguration(language, config) {\r\n        this._register(vscode.languages.setLanguageConfiguration(language, config));\r\n    }\r\n}\r\nexports.LanguageConfigurationManager = LanguageConfigurationManager;\r\n//# sourceMappingURL=languageConfiguration.js.map","/typescript-language-features/out/utils/dispose.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction disposeAll(disposables) {\r\n    while (disposables.length) {\r\n        const item = disposables.pop();\r\n        if (item) {\r\n            item.dispose();\r\n        }\r\n    }\r\n}\r\nexports.disposeAll = disposeAll;\r\nclass Disposable {\r\n    constructor() {\r\n        this._isDisposed = false;\r\n        this._disposables = [];\r\n    }\r\n    dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        this._isDisposed = true;\r\n        disposeAll(this._disposables);\r\n    }\r\n    _register(value) {\r\n        if (this._isDisposed) {\r\n            value.dispose();\r\n        }\r\n        else {\r\n            this._disposables.push(value);\r\n        }\r\n        return value;\r\n    }\r\n    get isDisposed() {\r\n        return this._isDisposed;\r\n    }\r\n}\r\nexports.Disposable = Disposable;\r\n//# sourceMappingURL=dispose.js.map","/typescript-language-features/out/utils/languageModeIds.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nexports.typescript = 'typescript';\r\nexports.typescriptreact = 'typescriptreact';\r\nexports.javascript = 'javascript';\r\nexports.javascriptreact = 'javascriptreact';\r\nexports.jsxTags = 'jsx-tags';\r\nfunction isSupportedLanguageMode(doc) {\r\n    return vscode.languages.match([exports.typescript, exports.typescriptreact, exports.javascript, exports.javascriptreact], doc) > 0;\r\n}\r\nexports.isSupportedLanguageMode = isSupportedLanguageMode;\r\nfunction isTypeScriptDocument(doc) {\r\n    return vscode.languages.match([exports.typescript, exports.typescriptreact], doc) > 0;\r\n}\r\nexports.isTypeScriptDocument = isTypeScriptDocument;\r\n//# sourceMappingURL=languageModeIds.js.map","/typescript-language-features/out/typeScriptServiceClientHost.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/* --------------------------------------------------------------------------------------------\r\n * Includes code from typescript-sublime-plugin project, obtained from\r\n * https://github.com/Microsoft/TypeScript-Sublime-Plugin/blob/master/TypeScript%20Indent.tmPreferences\r\n * ------------------------------------------------------------------------------------------ */\r\nconst vscode = require(\"vscode\");\r\nconst fileConfigurationManager_1 = require(\"./features/fileConfigurationManager\");\r\nconst languageProvider_1 = require(\"./languageProvider\");\r\nconst PConst = require(\"./protocol.const\");\r\nconst typescriptServiceClient_1 = require(\"./typescriptServiceClient\");\r\nconst api_1 = require(\"./utils/api\");\r\nconst dispose_1 = require(\"./utils/dispose\");\r\nconst typeConverters = require(\"./utils/typeConverters\");\r\nconst typingsStatus_1 = require(\"./utils/typingsStatus\");\r\nconst versionStatus_1 = require(\"./utils/versionStatus\");\r\nconst arrays_1 = require(\"./utils/arrays\");\r\n// Style check diagnostics that can be reported as warnings\r\nconst styleCheckDiagnostics = [\r\n    6133,\r\n    6138,\r\n    6192,\r\n    7027,\r\n    7028,\r\n    7029,\r\n    7030 // not all code paths return a value\r\n];\r\nclass TypeScriptServiceClientHost extends dispose_1.Disposable {\r\n    constructor(descriptions, workspaceState, pluginManager, commandManager, logDirectoryProvider, onCompletionAccepted) {\r\n        super();\r\n        this.commandManager = commandManager;\r\n        this.languages = [];\r\n        this.languagePerId = new Map();\r\n        this.reportStyleCheckAsWarnings = true;\r\n        const handleProjectCreateOrDelete = () => {\r\n            this.triggerAllDiagnostics();\r\n        };\r\n        const handleProjectChange = () => {\r\n            setTimeout(() => {\r\n                this.triggerAllDiagnostics();\r\n            }, 1500);\r\n        };\r\n        const configFileWatcher = this._register(vscode.workspace.createFileSystemWatcher('**/[tj]sconfig.json'));\r\n        configFileWatcher.onDidCreate(handleProjectCreateOrDelete, this, this._disposables);\r\n        configFileWatcher.onDidDelete(handleProjectCreateOrDelete, this, this._disposables);\r\n        configFileWatcher.onDidChange(handleProjectChange, this, this._disposables);\r\n        const allModeIds = this.getAllModeIds(descriptions, pluginManager);\r\n        this.client = this._register(new typescriptServiceClient_1.default(workspaceState, version => this.versionStatus.onDidChangeTypeScriptVersion(version), pluginManager, logDirectoryProvider, allModeIds));\r\n        this.client.onDiagnosticsReceived(({ kind, resource, diagnostics }) => {\r\n            this.diagnosticsReceived(kind, resource, diagnostics);\r\n        }, null, this._disposables);\r\n        this.client.onConfigDiagnosticsReceived(diag => this.configFileDiagnosticsReceived(diag), null, this._disposables);\r\n        this.client.onResendModelsRequested(() => this.populateService(), null, this._disposables);\r\n        this.versionStatus = this._register(new versionStatus_1.default(resource => this.client.toPath(resource)));\r\n        this._register(new typingsStatus_1.AtaProgressReporter(this.client));\r\n        this.typingsStatus = this._register(new typingsStatus_1.default(this.client));\r\n        this.fileConfigurationManager = this._register(new fileConfigurationManager_1.default(this.client));\r\n        for (const description of descriptions) {\r\n            const manager = new languageProvider_1.default(this.client, description, this.commandManager, this.client.telemetryReporter, this.typingsStatus, this.fileConfigurationManager, onCompletionAccepted);\r\n            this.languages.push(manager);\r\n            this._register(manager);\r\n            this.languagePerId.set(description.id, manager);\r\n        }\r\n        Promise.resolve().then(() => require('./features/updatePathsOnRename')).then(module => this._register(module.register(this.client, this.fileConfigurationManager, uri => this.handles(uri))));\r\n        Promise.resolve().then(() => require('./features/workspaceSymbols')).then(module => this._register(module.register(this.client, allModeIds)));\r\n        this.client.ensureServiceStarted();\r\n        this.client.onReady(() => {\r\n            if (this.client.apiVersion.lt(api_1.default.v230)) {\r\n                return;\r\n            }\r\n            const languages = new Set();\r\n            for (const plugin of pluginManager.plugins) {\r\n                for (const language of plugin.languages) {\r\n                    languages.add(language);\r\n                }\r\n            }\r\n            if (languages.size) {\r\n                const description = {\r\n                    id: 'typescript-plugins',\r\n                    modeIds: Array.from(languages.values()),\r\n                    diagnosticSource: 'ts-plugin',\r\n                    diagnosticLanguage: 1 /* TypeScript */,\r\n                    diagnosticOwner: 'typescript',\r\n                    isExternal: true\r\n                };\r\n                const manager = new languageProvider_1.default(this.client, description, this.commandManager, this.client.telemetryReporter, this.typingsStatus, this.fileConfigurationManager, onCompletionAccepted);\r\n                this.languages.push(manager);\r\n                this._register(manager);\r\n                this.languagePerId.set(description.id, manager);\r\n            }\r\n        });\r\n        this.client.onTsServerStarted(() => {\r\n            this.triggerAllDiagnostics();\r\n        });\r\n        vscode.workspace.onDidChangeConfiguration(this.configurationChanged, this, this._disposables);\r\n        this.configurationChanged();\r\n    }\r\n    getAllModeIds(descriptions, pluginManager) {\r\n        const allModeIds = arrays_1.flatten([\r\n            ...descriptions.map(x => x.modeIds),\r\n            ...pluginManager.plugins.map(x => x.languages)\r\n        ]);\r\n        return allModeIds;\r\n    }\r\n    get serviceClient() {\r\n        return this.client;\r\n    }\r\n    reloadProjects() {\r\n        this.client.executeWithoutWaitingForResponse('reloadProjects', null);\r\n        this.triggerAllDiagnostics();\r\n    }\r\n    async handles(resource) {\r\n        const provider = await this.findLanguage(resource);\r\n        if (provider) {\r\n            return true;\r\n        }\r\n        return this.client.bufferSyncSupport.handles(resource);\r\n    }\r\n    configurationChanged() {\r\n        const typescriptConfig = vscode.workspace.getConfiguration('typescript');\r\n        this.reportStyleCheckAsWarnings = typescriptConfig.get('reportStyleChecksAsWarnings', true);\r\n    }\r\n    async findLanguage(resource) {\r\n        try {\r\n            const doc = await vscode.workspace.openTextDocument(resource);\r\n            return this.languages.find(language => language.handles(resource, doc));\r\n        }\r\n        catch (_a) {\r\n            return undefined;\r\n        }\r\n    }\r\n    triggerAllDiagnostics() {\r\n        for (const language of this.languagePerId.values()) {\r\n            language.triggerAllDiagnostics();\r\n        }\r\n    }\r\n    populateService() {\r\n        this.fileConfigurationManager.reset();\r\n        this.client.bufferSyncSupport.reOpenDocuments();\r\n        this.client.bufferSyncSupport.requestAllDiagnostics();\r\n        // See https://github.com/Microsoft/TypeScript/issues/5530\r\n        vscode.workspace.saveAll(false).then(() => {\r\n            for (const language of this.languagePerId.values()) {\r\n                language.reInitialize();\r\n            }\r\n        });\r\n    }\r\n    async diagnosticsReceived(kind, resource, diagnostics) {\r\n        const language = await this.findLanguage(resource);\r\n        if (language) {\r\n            language.diagnosticsReceived(kind, resource, this.createMarkerDatas(diagnostics, language.diagnosticSource));\r\n        }\r\n    }\r\n    configFileDiagnosticsReceived(event) {\r\n        // See https://github.com/Microsoft/TypeScript/issues/10384\r\n        const body = event.body;\r\n        if (!body || !body.diagnostics || !body.configFile) {\r\n            return;\r\n        }\r\n        this.findLanguage(this.client.toResource(body.configFile)).then(language => {\r\n            if (!language) {\r\n                return;\r\n            }\r\n            language.configFileDiagnosticsReceived(this.client.toResource(body.configFile), body.diagnostics.map(tsDiag => {\r\n                const range = tsDiag.start && tsDiag.end ? typeConverters.Range.fromTextSpan(tsDiag) : new vscode.Range(0, 0, 0, 1);\r\n                const diagnostic = new vscode.Diagnostic(range, body.diagnostics[0].text, this.getDiagnosticSeverity(tsDiag));\r\n                diagnostic.source = language.diagnosticSource;\r\n                return diagnostic;\r\n            }));\r\n        });\r\n    }\r\n    createMarkerDatas(diagnostics, source) {\r\n        return diagnostics.map(tsDiag => this.tsDiagnosticToVsDiagnostic(tsDiag, source));\r\n    }\r\n    tsDiagnosticToVsDiagnostic(diagnostic, source) {\r\n        const { start, end, text } = diagnostic;\r\n        const range = new vscode.Range(typeConverters.Position.fromLocation(start), typeConverters.Position.fromLocation(end));\r\n        const converted = new vscode.Diagnostic(range, text, this.getDiagnosticSeverity(diagnostic));\r\n        converted.source = diagnostic.source || source;\r\n        if (diagnostic.code) {\r\n            converted.code = diagnostic.code;\r\n        }\r\n        const relatedInformation = diagnostic.relatedInformation;\r\n        if (relatedInformation) {\r\n            converted.relatedInformation = relatedInformation.map((info) => {\r\n                let span = info.span;\r\n                if (!span) {\r\n                    return undefined;\r\n                }\r\n                return new vscode.DiagnosticRelatedInformation(typeConverters.Location.fromTextSpan(this.client.toResource(span.file), span), info.message);\r\n            }).filter((x) => !!x);\r\n        }\r\n        if (diagnostic.reportsUnnecessary) {\r\n            converted.tags = [vscode.DiagnosticTag.Unnecessary];\r\n        }\r\n        converted.reportUnnecessary = diagnostic.reportsUnnecessary;\r\n        return converted;\r\n    }\r\n    getDiagnosticSeverity(diagnostic) {\r\n        if (this.reportStyleCheckAsWarnings\r\n            && this.isStyleCheckDiagnostic(diagnostic.code)\r\n            && diagnostic.category === PConst.DiagnosticCategory.error) {\r\n            return vscode.DiagnosticSeverity.Warning;\r\n        }\r\n        switch (diagnostic.category) {\r\n            case PConst.DiagnosticCategory.error:\r\n                return vscode.DiagnosticSeverity.Error;\r\n            case PConst.DiagnosticCategory.warning:\r\n                return vscode.DiagnosticSeverity.Warning;\r\n            case PConst.DiagnosticCategory.suggestion:\r\n                return vscode.DiagnosticSeverity.Hint;\r\n            default:\r\n                return vscode.DiagnosticSeverity.Error;\r\n        }\r\n    }\r\n    isStyleCheckDiagnostic(code) {\r\n        return code ? styleCheckDiagnostics.indexOf(code) !== -1 : false;\r\n    }\r\n}\r\nexports.default = TypeScriptServiceClientHost;\r\n//# sourceMappingURL=typeScriptServiceClientHost.js.map","/typescript-language-features/out/features/fileConfigurationManager.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst languageModeIds_1 = require(\"../utils/languageModeIds\");\r\nconst resourceMap_1 = require(\"../utils/resourceMap\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nfunction objsAreEqual(a, b) {\r\n    let keys = Object.keys(a);\r\n    for (const key of keys) {\r\n        if (a[key] !== b[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction areFileConfigurationsEqual(a, b) {\r\n    return (objsAreEqual(a.formatOptions, b.formatOptions)\r\n        && objsAreEqual(a.preferences, b.preferences));\r\n}\r\nclass FileConfigurationManager extends dispose_1.Disposable {\r\n    constructor(client) {\r\n        super();\r\n        this.client = client;\r\n        this.formatOptions = new resourceMap_1.ResourceMap();\r\n        vscode.workspace.onDidCloseTextDocument(textDocument => {\r\n            // When a document gets closed delete the cached formatting options.\r\n            // This is necessary since the tsserver now closed a project when its\r\n            // last file in it closes which drops the stored formatting options\r\n            // as well.\r\n            this.formatOptions.delete(textDocument.uri);\r\n        }, undefined, this._disposables);\r\n    }\r\n    async ensureConfigurationForDocument(document, token) {\r\n        const formattingOptions = this.getFormattingOptions(document);\r\n        if (formattingOptions) {\r\n            return this.ensureConfigurationOptions(document, formattingOptions, token);\r\n        }\r\n    }\r\n    getFormattingOptions(document) {\r\n        const editor = vscode.window.visibleTextEditors.find(editor => editor.document.fileName === document.fileName);\r\n        return editor\r\n            ? {\r\n                tabSize: editor.options.tabSize,\r\n                insertSpaces: editor.options.insertSpaces\r\n            }\r\n            : undefined;\r\n    }\r\n    async ensureConfigurationOptions(document, options, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return;\r\n        }\r\n        const currentOptions = this.getFileOptions(document, options);\r\n        const cachedOptions = this.formatOptions.get(document.uri);\r\n        if (cachedOptions) {\r\n            const cachedOptionsValue = await cachedOptions;\r\n            if (cachedOptionsValue && areFileConfigurationsEqual(cachedOptionsValue, currentOptions)) {\r\n                return;\r\n            }\r\n        }\r\n        let resolve;\r\n        this.formatOptions.set(document.uri, new Promise(r => resolve = r));\r\n        const args = {\r\n            file,\r\n            ...currentOptions,\r\n        };\r\n        try {\r\n            const response = await this.client.execute('configure', args, token);\r\n            resolve(response.type === 'response' ? currentOptions : undefined);\r\n        }\r\n        finally {\r\n            resolve(undefined);\r\n        }\r\n    }\r\n    async setGlobalConfigurationFromDocument(document, token) {\r\n        const formattingOptions = this.getFormattingOptions(document);\r\n        if (!formattingOptions) {\r\n            return;\r\n        }\r\n        const args = {\r\n            file: undefined /*global*/,\r\n            ...this.getFileOptions(document, formattingOptions),\r\n        };\r\n        await this.client.execute('configure', args, token);\r\n    }\r\n    reset() {\r\n        this.formatOptions.clear();\r\n    }\r\n    getFileOptions(document, options) {\r\n        return {\r\n            formatOptions: this.getFormatOptions(document, options),\r\n            preferences: this.getPreferences(document)\r\n        };\r\n    }\r\n    getFormatOptions(document, options) {\r\n        const config = vscode.workspace.getConfiguration(languageModeIds_1.isTypeScriptDocument(document) ? 'typescript.format' : 'javascript.format', document.uri);\r\n        return {\r\n            tabSize: options.tabSize,\r\n            indentSize: options.tabSize,\r\n            convertTabsToSpaces: options.insertSpaces,\r\n            // We can use \\n here since the editor normalizes later on to its line endings.\r\n            newLineCharacter: '\\n',\r\n            insertSpaceAfterCommaDelimiter: config.get('insertSpaceAfterCommaDelimiter'),\r\n            insertSpaceAfterConstructor: config.get('insertSpaceAfterConstructor'),\r\n            insertSpaceAfterSemicolonInForStatements: config.get('insertSpaceAfterSemicolonInForStatements'),\r\n            insertSpaceBeforeAndAfterBinaryOperators: config.get('insertSpaceBeforeAndAfterBinaryOperators'),\r\n            insertSpaceAfterKeywordsInControlFlowStatements: config.get('insertSpaceAfterKeywordsInControlFlowStatements'),\r\n            insertSpaceAfterFunctionKeywordForAnonymousFunctions: config.get('insertSpaceAfterFunctionKeywordForAnonymousFunctions'),\r\n            insertSpaceBeforeFunctionParenthesis: config.get('insertSpaceBeforeFunctionParenthesis'),\r\n            insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: config.get('insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis'),\r\n            insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: config.get('insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets'),\r\n            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: config.get('insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces'),\r\n            insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: config.get('insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces'),\r\n            insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: config.get('insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces'),\r\n            insertSpaceAfterTypeAssertion: config.get('insertSpaceAfterTypeAssertion'),\r\n            placeOpenBraceOnNewLineForFunctions: config.get('placeOpenBraceOnNewLineForFunctions'),\r\n            placeOpenBraceOnNewLineForControlBlocks: config.get('placeOpenBraceOnNewLineForControlBlocks'),\r\n        };\r\n    }\r\n    getPreferences(document) {\r\n        if (this.client.apiVersion.lt(api_1.default.v290)) {\r\n            return {};\r\n        }\r\n        const config = vscode.workspace.getConfiguration(languageModeIds_1.isTypeScriptDocument(document) ? 'typescript.preferences' : 'javascript.preferences', document.uri);\r\n        return {\r\n            quotePreference: this.getQuoteStylePreference(config),\r\n            importModuleSpecifierPreference: getImportModuleSpecifierPreference(config),\r\n            allowTextChangesInNewFiles: document.uri.scheme === 'file',\r\n            providePrefixAndSuffixTextForRename: config.get('renameShorthandProperties', true),\r\n            allowRenameOfImportPath: true,\r\n        };\r\n    }\r\n    getQuoteStylePreference(config) {\r\n        switch (config.get('quoteStyle')) {\r\n            case 'single': return 'single';\r\n            case 'double': return 'double';\r\n            default: return this.client.apiVersion.gte(api_1.default.v333) ? 'auto' : undefined;\r\n        }\r\n    }\r\n}\r\nexports.default = FileConfigurationManager;\r\nfunction getImportModuleSpecifierPreference(config) {\r\n    switch (config.get('importModuleSpecifier')) {\r\n        case 'relative': return 'relative';\r\n        case 'non-relative': return 'non-relative';\r\n        default: return undefined;\r\n    }\r\n}\r\n//# sourceMappingURL=fileConfigurationManager.js.map","/typescript-language-features/out/utils/api.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst semver = require(\"semver\");\r\nconst nls = require(\"vscode-nls\");\r\nconst localize = nls.loadMessageBundle();\r\nclass API {\r\n    constructor(versionString, version) {\r\n        this.versionString = versionString;\r\n        this.version = version;\r\n    }\r\n    static fromSimpleString(value) {\r\n        return new API(value, value);\r\n    }\r\n    static fromVersionString(versionString) {\r\n        let version = semver.valid(versionString);\r\n        if (!version) {\r\n            return new API(localize('invalidVersion', 'invalid version'), '1.0.0');\r\n        }\r\n        // Cut off any prerelease tag since we sometimes consume those on purpose.\r\n        const index = versionString.indexOf('-');\r\n        if (index >= 0) {\r\n            version = version.substr(0, index);\r\n        }\r\n        return new API(versionString, version);\r\n    }\r\n    gte(other) {\r\n        return semver.gte(this.version, other.version);\r\n    }\r\n    lt(other) {\r\n        return !this.gte(other);\r\n    }\r\n}\r\nAPI.defaultVersion = API.fromSimpleString('1.0.0');\r\nAPI.v203 = API.fromSimpleString('2.0.3');\r\nAPI.v206 = API.fromSimpleString('2.0.6');\r\nAPI.v208 = API.fromSimpleString('2.0.8');\r\nAPI.v213 = API.fromSimpleString('2.1.3');\r\nAPI.v220 = API.fromSimpleString('2.2.0');\r\nAPI.v222 = API.fromSimpleString('2.2.2');\r\nAPI.v230 = API.fromSimpleString('2.3.0');\r\nAPI.v234 = API.fromSimpleString('2.3.4');\r\nAPI.v240 = API.fromSimpleString('2.4.0');\r\nAPI.v250 = API.fromSimpleString('2.5.0');\r\nAPI.v260 = API.fromSimpleString('2.6.0');\r\nAPI.v270 = API.fromSimpleString('2.7.0');\r\nAPI.v280 = API.fromSimpleString('2.8.0');\r\nAPI.v290 = API.fromSimpleString('2.9.0');\r\nAPI.v291 = API.fromSimpleString('2.9.1');\r\nAPI.v292 = API.fromSimpleString('2.9.2');\r\nAPI.v300 = API.fromSimpleString('3.0.0');\r\nAPI.v310 = API.fromSimpleString('3.1.0');\r\nAPI.v314 = API.fromSimpleString('3.1.4');\r\nAPI.v320 = API.fromSimpleString('3.2.0');\r\nAPI.v330 = API.fromSimpleString('3.3.0');\r\nAPI.v333 = API.fromSimpleString('3.3.3');\r\nAPI.v340 = API.fromSimpleString('3.4.0');\r\nAPI.v345 = API.fromSimpleString('3.4.5');\r\nAPI.v350 = API.fromSimpleString('3.5.0');\r\nexports.default = API;\r\n//# sourceMappingURL=api.js.map","/typescript-language-features/node_modules/semver/package.json":"{\n  \"name\": \"semver\",\n  \"version\": \"5.5.1\",\n  \"description\": \"The semantic version parser used by npm.\",\n  \"main\": \"semver.js\",\n  \"scripts\": {\n    \"test\": \"tap test/*.js --cov -J\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^12.0.1\"\n  },\n  \"license\": \"ISC\",\n  \"repository\": \"https://github.com/npm/node-semver\",\n  \"bin\": {\n    \"semver\": \"./bin/semver\"\n  },\n  \"files\": [\n    \"bin\",\n    \"range.bnf\",\n    \"semver.js\"\n  ]\n}\n","/typescript-language-features/node_modules/semver/semver.js":"exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++;\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\nComparator.prototype.intersects = function(comp, loose) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n\n  var rangeTmp;\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, loose);\n    return satisfies(this.value, rangeTmp, loose);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, loose);\n    return satisfies(comp.semver, rangeTmp, loose);\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, loose) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'));\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, loose) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'));\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if (range instanceof Range) {\n    if (range.loose === loose) {\n      return range;\n    } else {\n      return new Range(range.raw, loose);\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, loose);\n  }\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\nRange.prototype.intersects = function(range, loose) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n\n  return this.set.some(function(thisComparators) {\n    return thisComparators.every(function(thisComparator) {\n      return range.set.some(function(rangeComparators) {\n        return rangeComparators.every(function(rangeComparator) {\n          return thisComparator.intersects(rangeComparator, loose);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, loose);\n      }\n    }\n  })\n  return max;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, loose);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) { // satisfies(v, range, loose)\n      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, loose);\n      }\n    }\n  })\n  return min;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n\nexports.intersects = intersects;\nfunction intersects(r1, r2, loose) {\n  r1 = new Range(r1, loose)\n  r2 = new Range(r2, loose)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce;\nfunction coerce(version) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  var match = version.match(re[COERCE]);\n\n  if (match == null)\n    return null;\n\n  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); \n}\n","/typescript-language-features/out/utils/resourceMap.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst memoize_1 = require(\"./memoize\");\r\nconst temp_1 = require(\"./temp\");\r\n/**\r\n * Maps of file resources\r\n *\r\n * Attempts to handle correct mapping on both case sensitive and case in-sensitive\r\n * file systems.\r\n */\r\nclass ResourceMap {\r\n    constructor(_normalizePath = (resource) => resource.fsPath) {\r\n        this._normalizePath = _normalizePath;\r\n        this._map = new Map();\r\n    }\r\n    get size() {\r\n        return this._map.size;\r\n    }\r\n    has(resource) {\r\n        const file = this.toKey(resource);\r\n        return !!file && this._map.has(file);\r\n    }\r\n    get(resource) {\r\n        const file = this.toKey(resource);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const entry = this._map.get(file);\r\n        return entry ? entry.value : undefined;\r\n    }\r\n    set(resource, value) {\r\n        const file = this.toKey(resource);\r\n        if (!file) {\r\n            return;\r\n        }\r\n        const entry = this._map.get(file);\r\n        if (entry) {\r\n            entry.value = value;\r\n        }\r\n        else {\r\n            this._map.set(file, { resource, value });\r\n        }\r\n    }\r\n    delete(resource) {\r\n        const file = this.toKey(resource);\r\n        if (file) {\r\n            this._map.delete(file);\r\n        }\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n    }\r\n    get values() {\r\n        return Array.from(this._map.values()).map(x => x.value);\r\n    }\r\n    get entries() {\r\n        return this._map.values();\r\n    }\r\n    toKey(resource) {\r\n        const key = this._normalizePath(resource);\r\n        if (!key) {\r\n            return key;\r\n        }\r\n        return this.isCaseInsensitivePath(key) ? key.toLowerCase() : key;\r\n    }\r\n    isCaseInsensitivePath(path) {\r\n        if (isWindowsPath(path)) {\r\n            return true;\r\n        }\r\n        return path[0] === '/' && this.onIsCaseInsenitiveFileSystem;\r\n    }\r\n    get onIsCaseInsenitiveFileSystem() {\r\n        if (process.platform === 'win32') {\r\n            return true;\r\n        }\r\n        if (process.platform !== 'darwin') {\r\n            return false;\r\n        }\r\n        const temp = temp_1.getTempFile('typescript-case-check');\r\n        fs.writeFileSync(temp, '');\r\n        return fs.existsSync(temp.toUpperCase());\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], ResourceMap.prototype, \"onIsCaseInsenitiveFileSystem\", null);\r\nexports.ResourceMap = ResourceMap;\r\nfunction isWindowsPath(path) {\r\n    return /^[a-zA-Z]:\\\\/.test(path);\r\n}\r\nexports.isWindowsPath = isWindowsPath;\r\n//# sourceMappingURL=resourceMap.js.map","/typescript-language-features/out/utils/memoize.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction memoize(_target, key, descriptor) {\r\n    let fnKey;\r\n    let fn;\r\n    if (typeof descriptor.value === 'function') {\r\n        fnKey = 'value';\r\n        fn = descriptor.value;\r\n    }\r\n    else if (typeof descriptor.get === 'function') {\r\n        fnKey = 'get';\r\n        fn = descriptor.get;\r\n    }\r\n    else {\r\n        throw new Error('not supported');\r\n    }\r\n    const memoizeKey = `$memoize$${key}`;\r\n    descriptor[fnKey] = function (...args) {\r\n        if (!this.hasOwnProperty(memoizeKey)) {\r\n            Object.defineProperty(this, memoizeKey, {\r\n                configurable: false,\r\n                enumerable: false,\r\n                writable: false,\r\n                value: fn.apply(this, args)\r\n            });\r\n        }\r\n        return this[memoizeKey];\r\n    };\r\n}\r\nexports.memoize = memoize;\r\n//# sourceMappingURL=memoize.js.map","/typescript-language-features/out/utils/temp.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst os = require(\"os\");\r\nfunction makeRandomHexString(length) {\r\n    const chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\r\n    let result = '';\r\n    for (let i = 0; i < length; i++) {\r\n        const idx = Math.floor(chars.length * Math.random());\r\n        result += chars[idx];\r\n    }\r\n    return result;\r\n}\r\nexports.makeRandomHexString = makeRandomHexString;\r\nfunction getTempFile(name) {\r\n    return path.join(os.tmpdir(), name);\r\n}\r\nexports.getTempFile = getTempFile;\r\n//# sourceMappingURL=temp.js.map","/typescript-language-features/out/languageProvider.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_1 = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst cachedResponse_1 = require(\"./tsServer/cachedResponse\");\r\nconst dispose_1 = require(\"./utils/dispose\");\r\nconst fileSchemes = require(\"./utils/fileSchemes\");\r\nconst memoize_1 = require(\"./utils/memoize\");\r\nconst validateSetting = 'validate.enable';\r\nconst suggestionSetting = 'suggestionActions.enabled';\r\nclass LanguageProvider extends dispose_1.Disposable {\r\n    constructor(client, description, commandManager, telemetryReporter, typingsStatus, fileConfigurationManager, onCompletionAccepted) {\r\n        super();\r\n        this.client = client;\r\n        this.description = description;\r\n        this.commandManager = commandManager;\r\n        this.telemetryReporter = telemetryReporter;\r\n        this.typingsStatus = typingsStatus;\r\n        this.fileConfigurationManager = fileConfigurationManager;\r\n        this.onCompletionAccepted = onCompletionAccepted;\r\n        vscode.workspace.onDidChangeConfiguration(this.configurationChanged, this, this._disposables);\r\n        this.configurationChanged();\r\n        client.onReady(() => this.registerProviders());\r\n    }\r\n    get documentSelector() {\r\n        const documentSelector = [];\r\n        for (const language of this.description.modeIds) {\r\n            for (const scheme of fileSchemes.supportedSchemes) {\r\n                documentSelector.push({ language, scheme });\r\n            }\r\n        }\r\n        return documentSelector;\r\n    }\r\n    async registerProviders() {\r\n        const selector = this.documentSelector;\r\n        const cachedResponse = new cachedResponse_1.CachedResponse();\r\n        await Promise.all([\r\n            Promise.resolve().then(() => require('./features/completions')).then(provider => this._register(provider.register(selector, this.description.id, this.client, this.typingsStatus, this.fileConfigurationManager, this.commandManager, this.telemetryReporter, this.onCompletionAccepted))),\r\n            Promise.resolve().then(() => require('./features/definitions')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/directiveCommentCompletions')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/documentHighlight')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/documentSymbol')).then(provider => this._register(provider.register(selector, this.client, cachedResponse))),\r\n            Promise.resolve().then(() => require('./features/folding')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/formatting')).then(provider => this._register(provider.register(selector, this.description.id, this.client, this.fileConfigurationManager))),\r\n            Promise.resolve().then(() => require('./features/hover')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/implementations')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/implementationsCodeLens')).then(provider => this._register(provider.register(selector, this.description.id, this.client, cachedResponse))),\r\n            Promise.resolve().then(() => require('./features/jsDocCompletions')).then(provider => this._register(provider.register(selector, this.description.id, this.client))),\r\n            Promise.resolve().then(() => require('./features/organizeImports')).then(provider => this._register(provider.register(selector, this.client, this.commandManager, this.fileConfigurationManager, this.telemetryReporter))),\r\n            Promise.resolve().then(() => require('./features/quickFix')).then(provider => this._register(provider.register(selector, this.client, this.fileConfigurationManager, this.commandManager, this.client.diagnosticsManager, this.telemetryReporter))),\r\n            Promise.resolve().then(() => require('./features/fixAll')).then(provider => this._register(provider.register(selector, this.client, this.fileConfigurationManager, this.client.diagnosticsManager))),\r\n            Promise.resolve().then(() => require('./features/refactor')).then(provider => this._register(provider.register(selector, this.client, this.fileConfigurationManager, this.commandManager, this.telemetryReporter))),\r\n            Promise.resolve().then(() => require('./features/references')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/referencesCodeLens')).then(provider => this._register(provider.register(selector, this.description.id, this.client, cachedResponse))),\r\n            Promise.resolve().then(() => require('./features/rename')).then(provider => this._register(provider.register(selector, this.client, this.fileConfigurationManager))),\r\n            Promise.resolve().then(() => require('./features/smartSelect')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/signatureHelp')).then(provider => this._register(provider.register(selector, this.client))),\r\n            Promise.resolve().then(() => require('./features/tagClosing')).then(provider => this._register(provider.register(selector, this.description.id, this.client))),\r\n            Promise.resolve().then(() => require('./features/typeDefinitions')).then(provider => this._register(provider.register(selector, this.client))),\r\n        ]);\r\n    }\r\n    configurationChanged() {\r\n        const config = vscode.workspace.getConfiguration(this.id, null);\r\n        this.updateValidate(config.get(validateSetting, true));\r\n        this.updateSuggestionDiagnostics(config.get(suggestionSetting, true));\r\n    }\r\n    handles(resource, doc) {\r\n        if (doc && this.description.modeIds.indexOf(doc.languageId) >= 0) {\r\n            return true;\r\n        }\r\n        const base = path_1.basename(resource.fsPath);\r\n        return !!base && (!!this.description.configFilePattern && this.description.configFilePattern.test(base));\r\n    }\r\n    get id() {\r\n        return this.description.id;\r\n    }\r\n    get diagnosticSource() {\r\n        return this.description.diagnosticSource;\r\n    }\r\n    updateValidate(value) {\r\n        this.client.diagnosticsManager.setValidate(this._diagnosticLanguage, value);\r\n    }\r\n    updateSuggestionDiagnostics(value) {\r\n        this.client.diagnosticsManager.setEnableSuggestions(this._diagnosticLanguage, value);\r\n    }\r\n    reInitialize() {\r\n        this.client.diagnosticsManager.reInitialize();\r\n    }\r\n    triggerAllDiagnostics() {\r\n        this.client.bufferSyncSupport.requestAllDiagnostics();\r\n    }\r\n    diagnosticsReceived(diagnosticsKind, file, diagnostics) {\r\n        const config = vscode.workspace.getConfiguration(this.id, file);\r\n        const reportUnnecessary = config.get('showUnused', true);\r\n        this.client.diagnosticsManager.updateDiagnostics(file, this._diagnosticLanguage, diagnosticsKind, diagnostics.filter(diag => {\r\n            if (!reportUnnecessary) {\r\n                diag.tags = undefined;\r\n                if (diag.reportUnnecessary && diag.severity === vscode.DiagnosticSeverity.Hint) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }));\r\n    }\r\n    configFileDiagnosticsReceived(file, diagnostics) {\r\n        this.client.diagnosticsManager.configFileDiagnosticsReceived(file, diagnostics);\r\n    }\r\n    get _diagnosticLanguage() {\r\n        return this.description.diagnosticLanguage;\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], LanguageProvider.prototype, \"documentSelector\", null);\r\nexports.default = LanguageProvider;\r\n//# sourceMappingURL=languageProvider.js.map","/typescript-language-features/out/tsServer/cachedResponse.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Caches a class of TS Server request based on document.\r\n */\r\nclass CachedResponse {\r\n    constructor() {\r\n        this.version = -1;\r\n        this.document = '';\r\n    }\r\n    /**\r\n     * Execute a request. May return cached value or resolve the new value\r\n     *\r\n     * Caller must ensure that all input `resolve` functions return equivilent results (keyed only off of document).\r\n     */\r\n    execute(document, resolve) {\r\n        if (this.response && this.matches(document)) {\r\n            // Chain so that on cancellation we fall back to the next resolve\r\n            return this.response = this.response.then(result => result.type === 'cancelled' ? resolve() : result);\r\n        }\r\n        return this.reset(document, resolve);\r\n    }\r\n    matches(document) {\r\n        return this.version === document.version && this.document === document.uri.toString();\r\n    }\r\n    async reset(document, resolve) {\r\n        this.version = document.version;\r\n        this.document = document.uri.toString();\r\n        return this.response = resolve();\r\n    }\r\n}\r\nexports.CachedResponse = CachedResponse;\r\n//# sourceMappingURL=cachedResponse.js.map","/typescript-language-features/out/utils/fileSchemes.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.file = 'file';\r\nexports.untitled = 'untitled';\r\nexports.walkThroughSnippet = 'walkThroughSnippet';\r\nexports.supportedSchemes = [\r\n    exports.file,\r\n    exports.untitled,\r\n    exports.walkThroughSnippet\r\n];\r\nfunction isSupportedScheme(scheme) {\r\n    return exports.supportedSchemes.indexOf(scheme) >= 0;\r\n}\r\nexports.isSupportedScheme = isSupportedScheme;\r\n//# sourceMappingURL=fileSchemes.js.map","/typescript-language-features/out/protocol.const.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Kind {\r\n}\r\nKind.alias = 'alias';\r\nKind.callSignature = 'call';\r\nKind.class = 'class';\r\nKind.const = 'const';\r\nKind.constructorImplementation = 'constructor';\r\nKind.constructSignature = 'construct';\r\nKind.directory = 'directory';\r\nKind.enum = 'enum';\r\nKind.externalModuleName = 'external module name';\r\nKind.function = 'function';\r\nKind.indexSignature = 'index';\r\nKind.interface = 'interface';\r\nKind.keyword = 'keyword';\r\nKind.let = 'let';\r\nKind.localFunction = 'local function';\r\nKind.localVariable = 'local var';\r\nKind.memberFunction = 'method';\r\nKind.memberGetAccessor = 'getter';\r\nKind.memberSetAccessor = 'setter';\r\nKind.memberVariable = 'property';\r\nKind.module = 'module';\r\nKind.primitiveType = 'primitive type';\r\nKind.script = 'script';\r\nKind.type = 'type';\r\nKind.variable = 'var';\r\nKind.warning = 'warning';\r\nKind.string = 'string';\r\nKind.parameter = 'parameter';\r\nexports.Kind = Kind;\r\nclass DiagnosticCategory {\r\n}\r\nDiagnosticCategory.error = 'error';\r\nDiagnosticCategory.warning = 'warning';\r\nDiagnosticCategory.suggestion = 'suggestion';\r\nexports.DiagnosticCategory = DiagnosticCategory;\r\nclass KindModifiers {\r\n}\r\nKindModifiers.optional = 'optional';\r\nKindModifiers.color = 'color';\r\nKindModifiers.dtsFile = '.d.ts';\r\nKindModifiers.tsFile = '.ts';\r\nKindModifiers.tsxFile = '.tsx';\r\nKindModifiers.jsFile = '.js';\r\nKindModifiers.jsxFile = '.jsx';\r\nKindModifiers.jsonFile = '.json';\r\nKindModifiers.fileExtensionKindModifiers = [\r\n    KindModifiers.dtsFile,\r\n    KindModifiers.tsFile,\r\n    KindModifiers.tsxFile,\r\n    KindModifiers.jsFile,\r\n    KindModifiers.jsxFile,\r\n    KindModifiers.jsonFile,\r\n];\r\nexports.KindModifiers = KindModifiers;\r\nclass DisplayPartKind {\r\n}\r\nDisplayPartKind.functionName = 'functionName';\r\nDisplayPartKind.methodName = 'methodName';\r\nDisplayPartKind.parameterName = 'parameterName';\r\nDisplayPartKind.propertyName = 'propertyName';\r\nDisplayPartKind.punctuation = 'punctuation';\r\nDisplayPartKind.text = 'text';\r\nexports.DisplayPartKind = DisplayPartKind;\r\n//# sourceMappingURL=protocol.const.js.map","/typescript-language-features/out/typescriptServiceClient.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst bufferSyncSupport_1 = require(\"./features/bufferSyncSupport\");\r\nconst diagnostics_1 = require(\"./features/diagnostics\");\r\nconst api_1 = require(\"./utils/api\");\r\nconst configuration_1 = require(\"./utils/configuration\");\r\nconst dispose_1 = require(\"./utils/dispose\");\r\nconst fileSchemes = require(\"./utils/fileSchemes\");\r\nconst logger_1 = require(\"./utils/logger\");\r\nconst pluginPathsProvider_1 = require(\"./utils/pluginPathsProvider\");\r\nconst telemetry_1 = require(\"./utils/telemetry\");\r\nconst tracer_1 = require(\"./utils/tracer\");\r\nconst tsconfig_1 = require(\"./utils/tsconfig\");\r\nconst versionPicker_1 = require(\"./utils/versionPicker\");\r\nconst versionProvider_1 = require(\"./utils/versionProvider\");\r\nconst spawner_1 = require(\"./tsServer/spawner\");\r\nconst localize = nls.loadMessageBundle();\r\nvar ServerState;\r\n(function (ServerState) {\r\n    ServerState.None = new class {\r\n        constructor() {\r\n            this.type = 0 /* None */;\r\n        }\r\n    };\r\n    class Running {\r\n        constructor(server, \r\n        /**\r\n         * API version obtained from the version picker after checking the corresponding path exists.\r\n         */\r\n        apiVersion, \r\n        /**\r\n         * Version reported by currently-running tsserver.\r\n         */\r\n        tsserverVersion, langaugeServiceEnabled) {\r\n            this.server = server;\r\n            this.apiVersion = apiVersion;\r\n            this.tsserverVersion = tsserverVersion;\r\n            this.langaugeServiceEnabled = langaugeServiceEnabled;\r\n            this.type = 1 /* Running */;\r\n        }\r\n    }\r\n    ServerState.Running = Running;\r\n    class Errored {\r\n        constructor(error) {\r\n            this.error = error;\r\n            this.type = 2 /* Errored */;\r\n        }\r\n    }\r\n    ServerState.Errored = Errored;\r\n})(ServerState || (ServerState = {}));\r\nclass TypeScriptServiceClient extends dispose_1.Disposable {\r\n    constructor(workspaceState, onDidChangeTypeScriptVersion, pluginManager, logDirectoryProvider, allModeIds) {\r\n        super();\r\n        this.workspaceState = workspaceState;\r\n        this.onDidChangeTypeScriptVersion = onDidChangeTypeScriptVersion;\r\n        this.pluginManager = pluginManager;\r\n        this.logDirectoryProvider = logDirectoryProvider;\r\n        this.logger = new logger_1.default();\r\n        this.serverState = ServerState.None;\r\n        this.isRestarting = false;\r\n        this.loadingIndicator = new ServerInitializingIndicator();\r\n        this._onTsServerStarted = this._register(new vscode.EventEmitter());\r\n        this.onTsServerStarted = this._onTsServerStarted.event;\r\n        this._onDiagnosticsReceived = this._register(new vscode.EventEmitter());\r\n        this.onDiagnosticsReceived = this._onDiagnosticsReceived.event;\r\n        this._onConfigDiagnosticsReceived = this._register(new vscode.EventEmitter());\r\n        this.onConfigDiagnosticsReceived = this._onConfigDiagnosticsReceived.event;\r\n        this._onResendModelsRequested = this._register(new vscode.EventEmitter());\r\n        this.onResendModelsRequested = this._onResendModelsRequested.event;\r\n        this._onProjectLanguageServiceStateChanged = this._register(new vscode.EventEmitter());\r\n        this.onProjectLanguageServiceStateChanged = this._onProjectLanguageServiceStateChanged.event;\r\n        this._onDidBeginInstallTypings = this._register(new vscode.EventEmitter());\r\n        this.onDidBeginInstallTypings = this._onDidBeginInstallTypings.event;\r\n        this._onDidEndInstallTypings = this._register(new vscode.EventEmitter());\r\n        this.onDidEndInstallTypings = this._onDidEndInstallTypings.event;\r\n        this._onTypesInstallerInitializationFailed = this._register(new vscode.EventEmitter());\r\n        this.onTypesInstallerInitializationFailed = this._onTypesInstallerInitializationFailed.event;\r\n        this._onSurveyReady = this._register(new vscode.EventEmitter());\r\n        this.onSurveyReady = this._onSurveyReady.event;\r\n        this.token = 0;\r\n        this.pathSeparator = path.sep;\r\n        this.lastStart = Date.now();\r\n        // tslint:disable-next-line: no-var-keyword\r\n        var p = new Promise((resolve, reject) => {\r\n            this._onReady = { promise: p, resolve, reject };\r\n        });\r\n        this._onReady.promise = p;\r\n        this.numberRestarts = 0;\r\n        this._configuration = configuration_1.TypeScriptServiceConfiguration.loadFromWorkspace();\r\n        this.versionProvider = new versionProvider_1.TypeScriptVersionProvider(this._configuration);\r\n        this.pluginPathsProvider = new pluginPathsProvider_1.TypeScriptPluginPathsProvider(this._configuration);\r\n        this.versionPicker = new versionPicker_1.TypeScriptVersionPicker(this.versionProvider, this.workspaceState);\r\n        this.tracer = new tracer_1.default(this.logger);\r\n        this.bufferSyncSupport = new bufferSyncSupport_1.default(this, allModeIds);\r\n        this.onReady(() => { this.bufferSyncSupport.listen(); });\r\n        this.diagnosticsManager = new diagnostics_1.DiagnosticsManager('typescript');\r\n        this.bufferSyncSupport.onDelete(resource => {\r\n            this.diagnosticsManager.delete(resource);\r\n        }, null, this._disposables);\r\n        vscode.workspace.onDidChangeConfiguration(() => {\r\n            const oldConfiguration = this._configuration;\r\n            this._configuration = configuration_1.TypeScriptServiceConfiguration.loadFromWorkspace();\r\n            this.versionProvider.updateConfiguration(this._configuration);\r\n            this.pluginPathsProvider.updateConfiguration(this._configuration);\r\n            this.tracer.updateConfiguration();\r\n            if (this.serverState.type === 1 /* Running */) {\r\n                if (this._configuration.checkJs !== oldConfiguration.checkJs\r\n                    || this._configuration.experimentalDecorators !== oldConfiguration.experimentalDecorators) {\r\n                    this.setCompilerOptionsForInferredProjects(this._configuration);\r\n                }\r\n                if (!this._configuration.isEqualTo(oldConfiguration)) {\r\n                    this.restartTsServer();\r\n                }\r\n            }\r\n        }, this, this._disposables);\r\n        this.telemetryReporter = this._register(new telemetry_1.VSCodeTelemetryReporter(() => {\r\n            if (this.serverState.type === 1 /* Running */) {\r\n                if (this.serverState.tsserverVersion) {\r\n                    return this.serverState.tsserverVersion;\r\n                }\r\n            }\r\n            return this.apiVersion.versionString;\r\n        }));\r\n        this.typescriptServerSpawner = new spawner_1.TypeScriptServerSpawner(this.versionProvider, this.logDirectoryProvider, this.pluginPathsProvider, this.logger, this.telemetryReporter, this.tracer);\r\n        this._register(this.pluginManager.onDidUpdateConfig(update => {\r\n            this.configurePlugin(update.pluginId, update.config);\r\n        }));\r\n        this._register(this.pluginManager.onDidChangePlugins(() => {\r\n            this.restartTsServer();\r\n        }));\r\n    }\r\n    get configuration() {\r\n        return this._configuration;\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this.bufferSyncSupport.dispose();\r\n        if (this.serverState.type === 1 /* Running */) {\r\n            this.serverState.server.kill();\r\n        }\r\n        this.loadingIndicator.reset();\r\n    }\r\n    restartTsServer() {\r\n        if (this.serverState.type === 1 /* Running */) {\r\n            this.info('Killing TS Server');\r\n            this.isRestarting = true;\r\n            this.serverState.server.kill();\r\n        }\r\n        this.serverState = this.startService(true);\r\n    }\r\n    get apiVersion() {\r\n        if (this.serverState.type === 1 /* Running */) {\r\n            return this.serverState.apiVersion;\r\n        }\r\n        return api_1.default.defaultVersion;\r\n    }\r\n    onReady(f) {\r\n        return this._onReady.promise.then(f);\r\n    }\r\n    info(message, data) {\r\n        this.logger.info(message, data);\r\n    }\r\n    error(message, data) {\r\n        this.logger.error(message, data);\r\n    }\r\n    logTelemetry(eventName, properties) {\r\n        this.telemetryReporter.logTelemetry(eventName, properties);\r\n    }\r\n    service() {\r\n        if (this.serverState.type === 1 /* Running */) {\r\n            return this.serverState;\r\n        }\r\n        if (this.serverState.type === 2 /* Errored */) {\r\n            throw this.serverState.error;\r\n        }\r\n        const newState = this.startService();\r\n        if (newState.type === 1 /* Running */) {\r\n            return newState;\r\n        }\r\n        throw new Error('Could not create TS service');\r\n    }\r\n    ensureServiceStarted() {\r\n        if (this.serverState.type !== 1 /* Running */) {\r\n            this.startService();\r\n        }\r\n    }\r\n    startService(resendModels = false) {\r\n        if (this.isDisposed) {\r\n            return ServerState.None;\r\n        }\r\n        let currentVersion = this.versionPicker.currentVersion;\r\n        this.info(`Using tsserver from: ${currentVersion.path}`);\r\n        if (!fs.existsSync(currentVersion.tsServerPath)) {\r\n            vscode.window.showWarningMessage(localize('noServerFound', 'The path {0} doesn\\'t point to a valid tsserver install. Falling back to bundled TypeScript version.', currentVersion.path));\r\n            this.versionPicker.useBundledVersion();\r\n            currentVersion = this.versionPicker.currentVersion;\r\n        }\r\n        const apiVersion = this.versionPicker.currentVersion.apiVersion || api_1.default.defaultVersion;\r\n        this.onDidChangeTypeScriptVersion(currentVersion);\r\n        let mytoken = ++this.token;\r\n        const handle = this.typescriptServerSpawner.spawn(currentVersion, this.configuration, this.pluginManager);\r\n        this.serverState = new ServerState.Running(handle, apiVersion, undefined, true);\r\n        this.lastStart = Date.now();\r\n        handle.onError((err) => {\r\n            if (this.token !== mytoken) {\r\n                // this is coming from an old process\r\n                return;\r\n            }\r\n            if (err) {\r\n                vscode.window.showErrorMessage(localize('serverExitedWithError', 'TypeScript language server exited with error. Error message is: {0}', err.message || err.name));\r\n            }\r\n            this.serverState = new ServerState.Errored(err);\r\n            this.error('TSServer errored with error.', err);\r\n            if (handle.tsServerLogFile) {\r\n                this.error(`TSServer log file: ${handle.tsServerLogFile}`);\r\n            }\r\n            /* __GDPR__\r\n                \"tsserver.error\" : {\r\n                    \"${include}\": [\r\n                        \"${TypeScriptCommonProperties}\"\r\n                    ]\r\n                }\r\n            */\r\n            this.logTelemetry('tsserver.error');\r\n            this.serviceExited(false);\r\n        });\r\n        handle.onExit((code) => {\r\n            if (this.token !== mytoken) {\r\n                // this is coming from an old process\r\n                return;\r\n            }\r\n            if (code === null || typeof code === 'undefined') {\r\n                this.info('TSServer exited');\r\n            }\r\n            else {\r\n                this.error(`TSServer exited with code: ${code}`);\r\n                /* __GDPR__\r\n                    \"tsserver.exitWithCode\" : {\r\n                        \"code\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\r\n                        \"${include}\": [\r\n                            \"${TypeScriptCommonProperties}\"\r\n                        ]\r\n                    }\r\n                */\r\n                this.logTelemetry('tsserver.exitWithCode', { code: code });\r\n            }\r\n            if (handle.tsServerLogFile) {\r\n                this.info(`TSServer log file: ${handle.tsServerLogFile}`);\r\n            }\r\n            this.serviceExited(!this.isRestarting);\r\n            this.isRestarting = false;\r\n        });\r\n        handle.onReaderError(error => this.error('ReaderError', error));\r\n        handle.onEvent(event => this.dispatchEvent(event));\r\n        this._onReady.resolve();\r\n        this._onTsServerStarted.fire(currentVersion.apiVersion);\r\n        if (apiVersion.gte(api_1.default.v300)) {\r\n            this.loadingIndicator.startedLoadingProject(undefined /* projectName */);\r\n        }\r\n        this.serviceStarted(resendModels);\r\n        return this.serverState;\r\n    }\r\n    onVersionStatusClicked() {\r\n        return this.showVersionPicker(false);\r\n    }\r\n    showVersionPicker(firstRun) {\r\n        return this.versionPicker.show(firstRun).then(change => {\r\n            if (firstRun || !change.newVersion || !change.oldVersion || change.oldVersion.path === change.newVersion.path) {\r\n                return;\r\n            }\r\n            this.restartTsServer();\r\n        });\r\n    }\r\n    async openTsServerLogFile() {\r\n        if (this.apiVersion.lt(api_1.default.v222)) {\r\n            vscode.window.showErrorMessage(localize('typescript.openTsServerLog.notSupported', 'TS Server logging requires TS 2.2.2+'));\r\n            return false;\r\n        }\r\n        if (this._configuration.tsServerLogLevel === configuration_1.TsServerLogLevel.Off) {\r\n            vscode.window.showErrorMessage(localize('typescript.openTsServerLog.loggingNotEnabled', 'TS Server logging is off. Please set `typescript.tsserver.log` and restart the TS server to enable logging'), {\r\n                title: localize('typescript.openTsServerLog.enableAndReloadOption', 'Enable logging and restart TS server'),\r\n            })\r\n                .then(selection => {\r\n                if (selection) {\r\n                    return vscode.workspace.getConfiguration().update('typescript.tsserver.log', 'verbose', true).then(() => {\r\n                        this.restartTsServer();\r\n                    });\r\n                }\r\n                return undefined;\r\n            });\r\n            return false;\r\n        }\r\n        if (this.serverState.type !== 1 /* Running */ || !this.serverState.server.tsServerLogFile) {\r\n            vscode.window.showWarningMessage(localize('typescript.openTsServerLog.noLogFile', 'TS Server has not started logging.'));\r\n            return false;\r\n        }\r\n        try {\r\n            const doc = await vscode.workspace.openTextDocument(vscode.Uri.file(this.serverState.server.tsServerLogFile));\r\n            await vscode.window.showTextDocument(doc);\r\n            return true;\r\n        }\r\n        catch (_a) {\r\n            // noop\r\n        }\r\n        try {\r\n            await vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(this.serverState.server.tsServerLogFile));\r\n            return true;\r\n        }\r\n        catch (_b) {\r\n            vscode.window.showWarningMessage(localize('openTsServerLog.openFileFailedFailed', 'Could not open TS Server log file'));\r\n            return false;\r\n        }\r\n    }\r\n    serviceStarted(resendModels) {\r\n        const configureOptions = {\r\n            hostInfo: 'vscode',\r\n            preferences: {\r\n                providePrefixAndSuffixTextForRename: true,\r\n                allowRenameOfImportPath: true,\r\n            }\r\n        };\r\n        this.executeWithoutWaitingForResponse('configure', configureOptions);\r\n        this.setCompilerOptionsForInferredProjects(this._configuration);\r\n        if (resendModels) {\r\n            this._onResendModelsRequested.fire();\r\n        }\r\n        // Reconfigure any plugins\r\n        for (const [config, pluginName] of this.pluginManager.configurations()) {\r\n            this.configurePlugin(config, pluginName);\r\n        }\r\n    }\r\n    setCompilerOptionsForInferredProjects(configuration) {\r\n        if (this.apiVersion.lt(api_1.default.v206)) {\r\n            return;\r\n        }\r\n        const args = {\r\n            options: this.getCompilerOptionsForInferredProjects(configuration)\r\n        };\r\n        this.executeWithoutWaitingForResponse('compilerOptionsForInferredProjects', args);\r\n    }\r\n    getCompilerOptionsForInferredProjects(configuration) {\r\n        return {\r\n            ...tsconfig_1.inferredProjectConfig(configuration),\r\n            allowJs: true,\r\n            allowSyntheticDefaultImports: true,\r\n            allowNonTsExtensions: true,\r\n        };\r\n    }\r\n    serviceExited(restart) {\r\n        this.loadingIndicator.reset();\r\n        let MessageAction;\r\n        (function (MessageAction) {\r\n            MessageAction[MessageAction[\"reportIssue\"] = 0] = \"reportIssue\";\r\n        })(MessageAction || (MessageAction = {}));\r\n        this.serverState = ServerState.None;\r\n        if (restart) {\r\n            const diff = Date.now() - this.lastStart;\r\n            this.numberRestarts++;\r\n            let startService = true;\r\n            if (this.numberRestarts > 5) {\r\n                let prompt = undefined;\r\n                this.numberRestarts = 0;\r\n                if (diff < 10 * 1000 /* 10 seconds */) {\r\n                    this.lastStart = Date.now();\r\n                    startService = false;\r\n                    prompt = vscode.window.showErrorMessage(localize('serverDiedAfterStart', 'The TypeScript language service died 5 times right after it got started. The service will not be restarted.'), {\r\n                        title: localize('serverDiedReportIssue', 'Report Issue'),\r\n                        id: MessageAction.reportIssue,\r\n                    });\r\n                    /* __GDPR__\r\n                        \"serviceExited\" : {\r\n                            \"${include}\": [\r\n                                \"${TypeScriptCommonProperties}\"\r\n                            ]\r\n                        }\r\n                    */\r\n                    this.logTelemetry('serviceExited');\r\n                }\r\n                else if (diff < 60 * 1000 /* 1 Minutes */) {\r\n                    this.lastStart = Date.now();\r\n                    prompt = vscode.window.showWarningMessage(localize('serverDied', 'The TypeScript language service died unexpectedly 5 times in the last 5 Minutes.'), {\r\n                        title: localize('serverDiedReportIssue', 'Report Issue'),\r\n                        id: MessageAction.reportIssue\r\n                    });\r\n                }\r\n                if (prompt) {\r\n                    prompt.then(item => {\r\n                        if (item && item.id === MessageAction.reportIssue) {\r\n                            return vscode.commands.executeCommand('workbench.action.reportIssues');\r\n                        }\r\n                        return undefined;\r\n                    });\r\n                }\r\n            }\r\n            if (startService) {\r\n                this.startService(true);\r\n            }\r\n        }\r\n    }\r\n    normalizedPath(resource) {\r\n        if (this.apiVersion.gte(api_1.default.v213)) {\r\n            if (resource.scheme === fileSchemes.walkThroughSnippet || resource.scheme === fileSchemes.untitled) {\r\n                const dirName = path.dirname(resource.path);\r\n                const fileName = this.inMemoryResourcePrefix + path.basename(resource.path);\r\n                return resource.with({ path: path.posix.join(dirName, fileName) }).toString(true);\r\n            }\r\n        }\r\n        if (resource.scheme !== fileSchemes.file) {\r\n            return undefined;\r\n        }\r\n        const result = resource.fsPath;\r\n        if (!result) {\r\n            return undefined;\r\n        }\r\n        // Both \\ and / must be escaped in regular expressions\r\n        return result.replace(new RegExp('\\\\' + this.pathSeparator, 'g'), '/');\r\n    }\r\n    toPath(resource) {\r\n        return this.normalizedPath(resource);\r\n    }\r\n    toOpenedFilePath(document) {\r\n        if (!this.bufferSyncSupport.handles(document.uri)) {\r\n            console.error(`Unexpected resource ${document.uri}`);\r\n            return undefined;\r\n        }\r\n        return this.toPath(document.uri) || undefined;\r\n    }\r\n    get inMemoryResourcePrefix() {\r\n        return this.apiVersion.gte(api_1.default.v270) ? '^' : '';\r\n    }\r\n    toResource(filepath) {\r\n        if (this.apiVersion.gte(api_1.default.v213)) {\r\n            if (filepath.startsWith(TypeScriptServiceClient.WALK_THROUGH_SNIPPET_SCHEME_COLON) || (filepath.startsWith(fileSchemes.untitled + ':'))) {\r\n                let resource = vscode.Uri.parse(filepath);\r\n                if (this.inMemoryResourcePrefix) {\r\n                    const dirName = path.dirname(resource.path);\r\n                    const fileName = path.basename(resource.path);\r\n                    if (fileName.startsWith(this.inMemoryResourcePrefix)) {\r\n                        resource = resource.with({ path: path.posix.join(dirName, fileName.slice(this.inMemoryResourcePrefix.length)) });\r\n                    }\r\n                }\r\n                return resource;\r\n            }\r\n        }\r\n        return this.bufferSyncSupport.toResource(filepath);\r\n    }\r\n    getWorkspaceRootForResource(resource) {\r\n        const roots = vscode.workspace.workspaceFolders;\r\n        if (!roots || !roots.length) {\r\n            return undefined;\r\n        }\r\n        if (resource.scheme === fileSchemes.file || resource.scheme === fileSchemes.untitled) {\r\n            for (const root of roots.sort((a, b) => a.uri.fsPath.length - b.uri.fsPath.length)) {\r\n                if (resource.fsPath.startsWith(root.uri.fsPath + path.sep)) {\r\n                    return root.uri.fsPath;\r\n                }\r\n            }\r\n            return roots[0].uri.fsPath;\r\n        }\r\n        return undefined;\r\n    }\r\n    execute(command, args, token, config) {\r\n        return this.executeImpl(command, args, {\r\n            isAsync: false,\r\n            token,\r\n            expectsResult: true,\r\n            lowPriority: config ? config.lowPriority : undefined\r\n        });\r\n    }\r\n    executeWithoutWaitingForResponse(command, args) {\r\n        this.executeImpl(command, args, {\r\n            isAsync: false,\r\n            token: undefined,\r\n            expectsResult: false\r\n        });\r\n    }\r\n    executeAsync(command, args, token) {\r\n        return this.executeImpl(command, args, {\r\n            isAsync: true,\r\n            token,\r\n            expectsResult: true\r\n        });\r\n    }\r\n    executeImpl(command, args, executeInfo) {\r\n        this.bufferSyncSupport.beforeCommand(command);\r\n        const runningServerState = this.service();\r\n        return runningServerState.server.executeImpl(command, args, executeInfo);\r\n    }\r\n    interruptGetErr(f) {\r\n        return this.bufferSyncSupport.interuptGetErr(f);\r\n    }\r\n    dispatchEvent(event) {\r\n        switch (event.event) {\r\n            case 'syntaxDiag':\r\n            case 'semanticDiag':\r\n            case 'suggestionDiag':\r\n                // This event also roughly signals that projects have been loaded successfully (since the TS server is synchronous)\r\n                this.loadingIndicator.reset();\r\n                const diagnosticEvent = event;\r\n                if (diagnosticEvent.body && diagnosticEvent.body.diagnostics) {\r\n                    this._onDiagnosticsReceived.fire({\r\n                        kind: getDignosticsKind(event),\r\n                        resource: this.toResource(diagnosticEvent.body.file),\r\n                        diagnostics: diagnosticEvent.body.diagnostics\r\n                    });\r\n                }\r\n                break;\r\n            case 'configFileDiag':\r\n                this._onConfigDiagnosticsReceived.fire(event);\r\n                break;\r\n            case 'telemetry':\r\n                {\r\n                    const body = event.body;\r\n                    this.dispatchTelemetryEvent(body);\r\n                    break;\r\n                }\r\n            case 'projectLanguageServiceState':\r\n                {\r\n                    const body = event.body;\r\n                    if (this.serverState.type === 1 /* Running */) {\r\n                        this.serverState = {\r\n                            ...this.serverState,\r\n                            langaugeServiceEnabled: body.languageServiceEnabled,\r\n                        };\r\n                    }\r\n                    this._onProjectLanguageServiceStateChanged.fire(body);\r\n                    break;\r\n                }\r\n            case 'projectsUpdatedInBackground':\r\n                const body = event.body;\r\n                const resources = body.openFiles.map(vscode.Uri.file);\r\n                this.bufferSyncSupport.getErr(resources);\r\n                break;\r\n            case 'beginInstallTypes':\r\n                this._onDidBeginInstallTypings.fire(event.body);\r\n                break;\r\n            case 'endInstallTypes':\r\n                this._onDidEndInstallTypings.fire(event.body);\r\n                break;\r\n            case 'typesInstallerInitializationFailed':\r\n                this._onTypesInstallerInitializationFailed.fire(event.body);\r\n                break;\r\n            case 'surveyReady':\r\n                this._onSurveyReady.fire(event.body);\r\n                break;\r\n            case 'projectLoadingStart':\r\n                this.loadingIndicator.startedLoadingProject(event.body.projectName);\r\n                break;\r\n            case 'projectLoadingFinish':\r\n                this.loadingIndicator.finishedLoadingProject(event.body.projectName);\r\n                break;\r\n        }\r\n    }\r\n    dispatchTelemetryEvent(telemetryData) {\r\n        const properties = Object.create(null);\r\n        switch (telemetryData.telemetryEventName) {\r\n            case 'typingsInstalled':\r\n                const typingsInstalledPayload = telemetryData.payload;\r\n                properties['installedPackages'] = typingsInstalledPayload.installedPackages;\r\n                if (typeof typingsInstalledPayload.installSuccess === 'boolean') {\r\n                    properties['installSuccess'] = typingsInstalledPayload.installSuccess.toString();\r\n                }\r\n                if (typeof typingsInstalledPayload.typingsInstallerVersion === 'string') {\r\n                    properties['typingsInstallerVersion'] = typingsInstalledPayload.typingsInstallerVersion;\r\n                }\r\n                break;\r\n            default:\r\n                const payload = telemetryData.payload;\r\n                if (payload) {\r\n                    Object.keys(payload).forEach((key) => {\r\n                        try {\r\n                            if (payload.hasOwnProperty(key)) {\r\n                                properties[key] = typeof payload[key] === 'string' ? payload[key] : JSON.stringify(payload[key]);\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            // noop\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n        }\r\n        if (telemetryData.telemetryEventName === 'projectInfo') {\r\n            if (this.serverState.type === 1 /* Running */) {\r\n                this.serverState = {\r\n                    ...this.serverState,\r\n                    tsserverVersion: properties['version']\r\n                };\r\n            }\r\n        }\r\n        /* __GDPR__\r\n            \"typingsInstalled\" : {\r\n                \"installedPackages\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                \"installSuccess\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\r\n                \"typingsInstallerVersion\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\" },\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        // __GDPR__COMMENT__: Other events are defined by TypeScript.\r\n        this.logTelemetry(telemetryData.telemetryEventName, properties);\r\n    }\r\n    configurePlugin(pluginName, configuration) {\r\n        if (this.apiVersion.gte(api_1.default.v314)) {\r\n            this.executeWithoutWaitingForResponse('configurePlugin', { pluginName, configuration });\r\n        }\r\n    }\r\n}\r\nTypeScriptServiceClient.WALK_THROUGH_SNIPPET_SCHEME_COLON = `${fileSchemes.walkThroughSnippet}:`;\r\nexports.default = TypeScriptServiceClient;\r\nfunction getDignosticsKind(event) {\r\n    switch (event.event) {\r\n        case 'syntaxDiag': return 0 /* Syntax */;\r\n        case 'semanticDiag': return 1 /* Semantic */;\r\n        case 'suggestionDiag': return 2 /* Suggestion */;\r\n    }\r\n    throw new Error('Unknown dignostics kind');\r\n}\r\nclass ServerInitializingIndicator extends dispose_1.Disposable {\r\n    reset() {\r\n        if (this._task) {\r\n            this._task.reject();\r\n            this._task = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Signal that a project has started loading.\r\n     */\r\n    startedLoadingProject(projectName) {\r\n        // TS projects are loaded sequentially. Cancel existing task because it should always be resolved before\r\n        // the incoming project loading task is.\r\n        this.reset();\r\n        vscode.window.withProgress({\r\n            location: vscode.ProgressLocation.Window,\r\n            title: localize('serverLoading.progress', \"Initializing JS/TS language features\"),\r\n        }, () => new Promise((resolve, reject) => {\r\n            this._task = { project: projectName, resolve, reject };\r\n        }));\r\n    }\r\n    finishedLoadingProject(projectName) {\r\n        if (this._task && this._task.project === projectName) {\r\n            this._task.resolve();\r\n            this._task = undefined;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=typescriptServiceClient.js.map","/typescript-language-features/out/features/bufferSyncSupport.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst async_1 = require(\"../utils/async\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nconst languageModeIds = require(\"../utils/languageModeIds\");\r\nconst resourceMap_1 = require(\"../utils/resourceMap\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nfunction mode2ScriptKind(mode) {\r\n    switch (mode) {\r\n        case languageModeIds.typescript: return 'TS';\r\n        case languageModeIds.typescriptreact: return 'TSX';\r\n        case languageModeIds.javascript: return 'JS';\r\n        case languageModeIds.javascriptreact: return 'JSX';\r\n    }\r\n    return undefined;\r\n}\r\nclass CloseOperation {\r\n    constructor(args) {\r\n        this.args = args;\r\n        this.type = 'close';\r\n    }\r\n}\r\nclass OpenOperation {\r\n    constructor(args) {\r\n        this.args = args;\r\n        this.type = 'open';\r\n    }\r\n}\r\nclass ChangeOperation {\r\n    constructor(args) {\r\n        this.args = args;\r\n        this.type = 'change';\r\n    }\r\n}\r\n/**\r\n * Manages synchronization of buffers with the TS server.\r\n *\r\n * If supported, batches together file changes. This allows the TS server to more efficiently process changes.\r\n */\r\nclass BufferSynchronizer {\r\n    constructor(client) {\r\n        this.client = client;\r\n        this._pending = new Map();\r\n    }\r\n    open(args) {\r\n        if (this.supportsBatching) {\r\n            this.updatePending(args.file, pending => {\r\n                pending.set(args.file, new OpenOperation(args));\r\n            });\r\n        }\r\n        else {\r\n            this.client.executeWithoutWaitingForResponse('open', args);\r\n        }\r\n    }\r\n    close(filepath) {\r\n        if (this.supportsBatching) {\r\n            this.updatePending(filepath, pending => {\r\n                pending.set(filepath, new CloseOperation(filepath));\r\n            });\r\n        }\r\n        else {\r\n            const args = { file: filepath };\r\n            this.client.executeWithoutWaitingForResponse('close', args);\r\n        }\r\n    }\r\n    change(filepath, events) {\r\n        if (!events.length) {\r\n            return;\r\n        }\r\n        if (this.supportsBatching) {\r\n            this.updatePending(filepath, pending => {\r\n                pending.set(filepath, new ChangeOperation({\r\n                    fileName: filepath,\r\n                    textChanges: events.map((change) => ({\r\n                        newText: change.text,\r\n                        start: typeConverters.Position.toLocation(change.range.start),\r\n                        end: typeConverters.Position.toLocation(change.range.end),\r\n                    })).reverse(),\r\n                }));\r\n            });\r\n        }\r\n        else {\r\n            for (const { range, text } of events) {\r\n                const args = {\r\n                    insertString: text,\r\n                    ...typeConverters.Range.toFormattingRequestArgs(filepath, range)\r\n                };\r\n                this.client.executeWithoutWaitingForResponse('change', args);\r\n            }\r\n        }\r\n    }\r\n    beforeCommand(command) {\r\n        if (command === 'updateOpen') {\r\n            return;\r\n        }\r\n        this.flush();\r\n    }\r\n    flush() {\r\n        if (!this.supportsBatching) {\r\n            // We've already eagerly synchronized\r\n            this._pending.clear();\r\n            return;\r\n        }\r\n        if (this._pending.size > 0) {\r\n            const closedFiles = [];\r\n            const openFiles = [];\r\n            const changedFiles = [];\r\n            for (const change of this._pending.values()) {\r\n                switch (change.type) {\r\n                    case 'change':\r\n                        changedFiles.push(change.args);\r\n                        break;\r\n                    case 'open':\r\n                        openFiles.push(change.args);\r\n                        break;\r\n                    case 'close':\r\n                        closedFiles.push(change.args);\r\n                        break;\r\n                }\r\n            }\r\n            this.client.executeWithoutWaitingForResponse('updateOpen', { changedFiles, closedFiles, openFiles });\r\n            this._pending.clear();\r\n        }\r\n    }\r\n    get supportsBatching() {\r\n        return this.client.apiVersion.gte(api_1.default.v340) && vscode.workspace.getConfiguration('typescript', null).get('useBatchedBufferSync', true);\r\n    }\r\n    updatePending(filepath, f) {\r\n        if (this._pending.has(filepath)) {\r\n            // we saw this file before, make sure we flush before working with it again\r\n            this.flush();\r\n        }\r\n        f(this._pending);\r\n    }\r\n}\r\nclass SyncedBuffer {\r\n    constructor(document, filepath, client, synchronizer) {\r\n        this.document = document;\r\n        this.filepath = filepath;\r\n        this.client = client;\r\n        this.synchronizer = synchronizer;\r\n        this.state = 1 /* Initial */;\r\n    }\r\n    open() {\r\n        const args = {\r\n            file: this.filepath,\r\n            fileContent: this.document.getText(),\r\n        };\r\n        if (this.client.apiVersion.gte(api_1.default.v203)) {\r\n            const scriptKind = mode2ScriptKind(this.document.languageId);\r\n            if (scriptKind) {\r\n                args.scriptKindName = scriptKind;\r\n            }\r\n        }\r\n        if (this.client.apiVersion.gte(api_1.default.v230)) {\r\n            args.projectRootPath = this.client.getWorkspaceRootForResource(this.document.uri);\r\n        }\r\n        if (this.client.apiVersion.gte(api_1.default.v240)) {\r\n            const tsPluginsForDocument = this.client.pluginManager.plugins\r\n                .filter(x => x.languages.indexOf(this.document.languageId) >= 0);\r\n            if (tsPluginsForDocument.length) {\r\n                args.plugins = tsPluginsForDocument.map(plugin => plugin.name);\r\n            }\r\n        }\r\n        this.synchronizer.open(args);\r\n        this.state = 2 /* Open */;\r\n    }\r\n    get resource() {\r\n        return this.document.uri;\r\n    }\r\n    get lineCount() {\r\n        return this.document.lineCount;\r\n    }\r\n    get kind() {\r\n        switch (this.document.languageId) {\r\n            case languageModeIds.javascript:\r\n            case languageModeIds.javascriptreact:\r\n                return 2 /* JavaScript */;\r\n            case languageModeIds.typescript:\r\n            case languageModeIds.typescriptreact:\r\n            default:\r\n                return 1 /* TypeScript */;\r\n        }\r\n    }\r\n    close() {\r\n        this.synchronizer.close(this.filepath);\r\n        this.state = 2 /* Closed */;\r\n    }\r\n    onContentChanged(events) {\r\n        if (this.state !== 2 /* Open */) {\r\n            console.error(`Unexpected buffer state: ${this.state}`);\r\n        }\r\n        this.synchronizer.change(this.filepath, events);\r\n    }\r\n}\r\nclass SyncedBufferMap extends resourceMap_1.ResourceMap {\r\n    getForPath(filePath) {\r\n        return this.get(vscode.Uri.file(filePath));\r\n    }\r\n    get allBuffers() {\r\n        return this.values;\r\n    }\r\n}\r\nclass PendingDiagnostics extends resourceMap_1.ResourceMap {\r\n    getOrderedFileSet() {\r\n        const orderedResources = Array.from(this.entries)\r\n            .sort((a, b) => a.value - b.value)\r\n            .map(entry => entry.resource);\r\n        const map = new resourceMap_1.ResourceMap();\r\n        for (const resource of orderedResources) {\r\n            map.set(resource, undefined);\r\n        }\r\n        return map;\r\n    }\r\n}\r\nclass GetErrRequest {\r\n    constructor(client, files, _token, onDone) {\r\n        this.files = files;\r\n        this._token = _token;\r\n        this._done = false;\r\n        const args = {\r\n            delay: 0,\r\n            files: Array.from(files.entries)\r\n                .map(entry => client.normalizedPath(entry.resource))\r\n                .filter(x => !!x)\r\n        };\r\n        client.executeAsync('geterr', args, _token.token)\r\n            .finally(() => {\r\n            if (this._done) {\r\n                return;\r\n            }\r\n            this._done = true;\r\n            onDone();\r\n        });\r\n    }\r\n    static executeGetErrRequest(client, files, onDone) {\r\n        const token = new vscode.CancellationTokenSource();\r\n        return new GetErrRequest(client, files, token, onDone);\r\n    }\r\n    cancel() {\r\n        if (!this._done) {\r\n            this._token.cancel();\r\n        }\r\n        this._token.dispose();\r\n    }\r\n}\r\nclass BufferSyncSupport extends dispose_1.Disposable {\r\n    constructor(client, modeIds) {\r\n        super();\r\n        this._validateJavaScript = true;\r\n        this._validateTypeScript = true;\r\n        this.listening = false;\r\n        this._onDelete = this._register(new vscode.EventEmitter());\r\n        this.onDelete = this._onDelete.event;\r\n        this.client = client;\r\n        this.modeIds = new Set(modeIds);\r\n        this.diagnosticDelayer = new async_1.Delayer(300);\r\n        const pathNormalizer = (path) => this.client.normalizedPath(path);\r\n        this.syncedBuffers = new SyncedBufferMap(pathNormalizer);\r\n        this.pendingDiagnostics = new PendingDiagnostics(pathNormalizer);\r\n        this.synchronizer = new BufferSynchronizer(client);\r\n        this.updateConfiguration();\r\n        vscode.workspace.onDidChangeConfiguration(this.updateConfiguration, this, this._disposables);\r\n    }\r\n    listen() {\r\n        if (this.listening) {\r\n            return;\r\n        }\r\n        this.listening = true;\r\n        vscode.workspace.onDidOpenTextDocument(this.openTextDocument, this, this._disposables);\r\n        vscode.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this._disposables);\r\n        vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this._disposables);\r\n        vscode.workspace.textDocuments.forEach(this.openTextDocument, this);\r\n    }\r\n    handles(resource) {\r\n        return this.syncedBuffers.has(resource);\r\n    }\r\n    toResource(filePath) {\r\n        const buffer = this.syncedBuffers.getForPath(filePath);\r\n        if (buffer) {\r\n            return buffer.resource;\r\n        }\r\n        return vscode.Uri.file(filePath);\r\n    }\r\n    reOpenDocuments() {\r\n        for (const buffer of this.syncedBuffers.allBuffers) {\r\n            buffer.open();\r\n        }\r\n    }\r\n    openTextDocument(document) {\r\n        if (!this.modeIds.has(document.languageId)) {\r\n            return;\r\n        }\r\n        const resource = document.uri;\r\n        const filepath = this.client.normalizedPath(resource);\r\n        if (!filepath) {\r\n            return;\r\n        }\r\n        if (this.syncedBuffers.has(resource)) {\r\n            return;\r\n        }\r\n        const syncedBuffer = new SyncedBuffer(document, filepath, this.client, this.synchronizer);\r\n        this.syncedBuffers.set(resource, syncedBuffer);\r\n        syncedBuffer.open();\r\n        this.requestDiagnostic(syncedBuffer);\r\n    }\r\n    closeResource(resource) {\r\n        const syncedBuffer = this.syncedBuffers.get(resource);\r\n        if (!syncedBuffer) {\r\n            return;\r\n        }\r\n        this.pendingDiagnostics.delete(resource);\r\n        this.syncedBuffers.delete(resource);\r\n        syncedBuffer.close();\r\n        this._onDelete.fire(resource);\r\n        this.requestAllDiagnostics();\r\n    }\r\n    interuptGetErr(f) {\r\n        if (!this.pendingGetErr) {\r\n            return f();\r\n        }\r\n        this.pendingGetErr.cancel();\r\n        this.pendingGetErr = undefined;\r\n        const result = f();\r\n        this.triggerDiagnostics();\r\n        return result;\r\n    }\r\n    beforeCommand(command) {\r\n        this.synchronizer.beforeCommand(command);\r\n    }\r\n    onDidCloseTextDocument(document) {\r\n        this.closeResource(document.uri);\r\n    }\r\n    onDidChangeTextDocument(e) {\r\n        const syncedBuffer = this.syncedBuffers.get(e.document.uri);\r\n        if (!syncedBuffer) {\r\n            return;\r\n        }\r\n        syncedBuffer.onContentChanged(e.contentChanges);\r\n        const didTrigger = this.requestDiagnostic(syncedBuffer);\r\n        if (!didTrigger && this.pendingGetErr) {\r\n            // In this case we always want to re-trigger all diagnostics\r\n            this.pendingGetErr.cancel();\r\n            this.pendingGetErr = undefined;\r\n            this.triggerDiagnostics();\r\n        }\r\n    }\r\n    requestAllDiagnostics() {\r\n        for (const buffer of this.syncedBuffers.allBuffers) {\r\n            if (this.shouldValidate(buffer)) {\r\n                this.pendingDiagnostics.set(buffer.resource, Date.now());\r\n            }\r\n        }\r\n        this.triggerDiagnostics();\r\n    }\r\n    getErr(resources) {\r\n        const handledResources = resources.filter(resource => this.handles(resource));\r\n        if (!handledResources.length) {\r\n            return;\r\n        }\r\n        for (const resource of handledResources) {\r\n            this.pendingDiagnostics.set(resource, Date.now());\r\n        }\r\n        this.triggerDiagnostics();\r\n    }\r\n    triggerDiagnostics(delay = 200) {\r\n        this.diagnosticDelayer.trigger(() => {\r\n            this.sendPendingDiagnostics();\r\n        }, delay);\r\n    }\r\n    requestDiagnostic(buffer) {\r\n        if (!this.shouldValidate(buffer)) {\r\n            return false;\r\n        }\r\n        this.pendingDiagnostics.set(buffer.resource, Date.now());\r\n        const delay = Math.min(Math.max(Math.ceil(buffer.lineCount / 20), 300), 800);\r\n        this.triggerDiagnostics(delay);\r\n        return true;\r\n    }\r\n    hasPendingDiagnostics(resource) {\r\n        return this.pendingDiagnostics.has(resource);\r\n    }\r\n    sendPendingDiagnostics() {\r\n        const orderedFileSet = this.pendingDiagnostics.getOrderedFileSet();\r\n        if (this.pendingGetErr) {\r\n            this.pendingGetErr.cancel();\r\n            for (const file of this.pendingGetErr.files.entries) {\r\n                orderedFileSet.set(file.resource, undefined);\r\n            }\r\n        }\r\n        // Add all open TS buffers to the geterr request. They might be visible\r\n        for (const buffer of this.syncedBuffers.values) {\r\n            orderedFileSet.set(buffer.resource, undefined);\r\n        }\r\n        if (orderedFileSet.size) {\r\n            const getErr = this.pendingGetErr = GetErrRequest.executeGetErrRequest(this.client, orderedFileSet, () => {\r\n                if (this.pendingGetErr === getErr) {\r\n                    this.pendingGetErr = undefined;\r\n                }\r\n            });\r\n        }\r\n        this.pendingDiagnostics.clear();\r\n    }\r\n    updateConfiguration() {\r\n        const jsConfig = vscode.workspace.getConfiguration('javascript', null);\r\n        const tsConfig = vscode.workspace.getConfiguration('typescript', null);\r\n        this._validateJavaScript = jsConfig.get('validate.enable', true);\r\n        this._validateTypeScript = tsConfig.get('validate.enable', true);\r\n    }\r\n    shouldValidate(buffer) {\r\n        switch (buffer.kind) {\r\n            case 2 /* JavaScript */:\r\n                return this._validateJavaScript;\r\n            case 1 /* TypeScript */:\r\n            default:\r\n                return this._validateTypeScript;\r\n        }\r\n    }\r\n}\r\nexports.default = BufferSyncSupport;\r\n//# sourceMappingURL=bufferSyncSupport.js.map","/typescript-language-features/out/utils/async.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Delayer {\r\n    constructor(defaultDelay) {\r\n        this.defaultDelay = defaultDelay;\r\n        this.timeout = null;\r\n        this.completionPromise = null;\r\n        this.onSuccess = null;\r\n        this.task = null;\r\n    }\r\n    trigger(task, delay = this.defaultDelay) {\r\n        this.task = task;\r\n        if (delay >= 0) {\r\n            this.cancelTimeout();\r\n        }\r\n        if (!this.completionPromise) {\r\n            this.completionPromise = new Promise((resolve) => {\r\n                this.onSuccess = resolve;\r\n            }).then(() => {\r\n                this.completionPromise = null;\r\n                this.onSuccess = null;\r\n                const result = this.task && this.task();\r\n                this.task = null;\r\n                return result;\r\n            });\r\n        }\r\n        if (delay >= 0 || this.timeout === null) {\r\n            this.timeout = setTimeout(() => {\r\n                this.timeout = null;\r\n                if (this.onSuccess) {\r\n                    this.onSuccess(undefined);\r\n                }\r\n            }, delay >= 0 ? delay : this.defaultDelay);\r\n        }\r\n        return this.completionPromise;\r\n    }\r\n    cancelTimeout() {\r\n        if (this.timeout !== null) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n}\r\nexports.Delayer = Delayer;\r\n//# sourceMappingURL=async.js.map","/typescript-language-features/out/utils/typeConverters.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Helpers for converting FROM vscode types TO ts types\r\n */\r\nconst vscode = require(\"vscode\");\r\nvar Range;\r\n(function (Range) {\r\n    Range.fromTextSpan = (span) => Range.fromLocations(span.start, span.end);\r\n    Range.fromLocations = (start, end) => new vscode.Range(Math.max(0, start.line - 1), Math.max(start.offset - 1, 0), Math.max(0, end.line - 1), Math.max(0, end.offset - 1));\r\n    Range.toFileRangeRequestArgs = (file, range) => ({\r\n        file,\r\n        startLine: range.start.line + 1,\r\n        startOffset: range.start.character + 1,\r\n        endLine: range.end.line + 1,\r\n        endOffset: range.end.character + 1\r\n    });\r\n    Range.toFormattingRequestArgs = (file, range) => ({\r\n        file,\r\n        line: range.start.line + 1,\r\n        offset: range.start.character + 1,\r\n        endLine: range.end.line + 1,\r\n        endOffset: range.end.character + 1\r\n    });\r\n})(Range = exports.Range || (exports.Range = {}));\r\nvar Position;\r\n(function (Position) {\r\n    Position.fromLocation = (tslocation) => new vscode.Position(tslocation.line - 1, tslocation.offset - 1);\r\n    Position.toLocation = (vsPosition) => ({\r\n        line: vsPosition.line + 1,\r\n        offset: vsPosition.character + 1,\r\n    });\r\n    Position.toFileLocationRequestArgs = (file, position) => ({\r\n        file,\r\n        line: position.line + 1,\r\n        offset: position.character + 1,\r\n    });\r\n})(Position = exports.Position || (exports.Position = {}));\r\nvar Location;\r\n(function (Location) {\r\n    Location.fromTextSpan = (resource, tsTextSpan) => new vscode.Location(resource, Range.fromTextSpan(tsTextSpan));\r\n})(Location = exports.Location || (exports.Location = {}));\r\nvar TextEdit;\r\n(function (TextEdit) {\r\n    TextEdit.fromCodeEdit = (edit) => new vscode.TextEdit(Range.fromTextSpan(edit), edit.newText);\r\n})(TextEdit = exports.TextEdit || (exports.TextEdit = {}));\r\nvar WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function fromFileCodeEdits(client, edits) {\r\n        return withFileCodeEdits(new vscode.WorkspaceEdit(), client, edits);\r\n    }\r\n    WorkspaceEdit.fromFileCodeEdits = fromFileCodeEdits;\r\n    function withFileCodeEdits(workspaceEdit, client, edits) {\r\n        for (const edit of edits) {\r\n            const resource = client.toResource(edit.fileName);\r\n            for (const textChange of edit.textChanges) {\r\n                workspaceEdit.replace(resource, Range.fromTextSpan(textChange), textChange.newText);\r\n            }\r\n        }\r\n        return workspaceEdit;\r\n    }\r\n    WorkspaceEdit.withFileCodeEdits = withFileCodeEdits;\r\n})(WorkspaceEdit = exports.WorkspaceEdit || (exports.WorkspaceEdit = {}));\r\n//# sourceMappingURL=typeConverters.js.map","/typescript-language-features/out/features/diagnostics.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst resourceMap_1 = require(\"../utils/resourceMap\");\r\nconst arrays = require(\"../utils/arrays\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nfunction diagnosticsEquals(a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    return a.code === b.code\r\n        && a.message === b.message\r\n        && a.severity === b.severity\r\n        && a.source === b.source\r\n        && a.range.isEqual(b.range)\r\n        && arrays.equals(a.relatedInformation || arrays.empty, b.relatedInformation || arrays.empty, (a, b) => {\r\n            return a.message === b.message\r\n                && a.location.range.isEqual(b.location.range)\r\n                && a.location.uri.fsPath === b.location.uri.fsPath;\r\n        })\r\n        && arrays.equals(a.tags || arrays.empty, b.tags || arrays.empty);\r\n}\r\nclass FileDiagnostics {\r\n    constructor(file, language) {\r\n        this.file = file;\r\n        this.language = language;\r\n        this._diagnostics = new Map();\r\n    }\r\n    updateDiagnostics(language, kind, diagnostics) {\r\n        if (language !== this.language) {\r\n            this._diagnostics.clear();\r\n            this.language = language;\r\n        }\r\n        const existing = this._diagnostics.get(kind);\r\n        if (arrays.equals(existing || arrays.empty, diagnostics, diagnosticsEquals)) {\r\n            // No need to update\r\n            return false;\r\n        }\r\n        this._diagnostics.set(kind, diagnostics);\r\n        return true;\r\n    }\r\n    getDiagnostics(settings) {\r\n        if (!settings.getValidate(this.language)) {\r\n            return [];\r\n        }\r\n        return [\r\n            ...this.get(0 /* Syntax */),\r\n            ...this.get(1 /* Semantic */),\r\n            ...this.getSuggestionDiagnostics(settings),\r\n        ];\r\n    }\r\n    getSuggestionDiagnostics(settings) {\r\n        const enableSuggestions = settings.getEnableSuggestions(this.language);\r\n        return this.get(2 /* Suggestion */).filter(x => {\r\n            if (!enableSuggestions) {\r\n                // Still show unused\r\n                return x.tags && x.tags.includes(vscode.DiagnosticTag.Unnecessary);\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    get(kind) {\r\n        return this._diagnostics.get(kind) || [];\r\n    }\r\n}\r\nfunction areLanguageDiagnosticSettingsEqual(currentSettings, newSettings) {\r\n    return currentSettings.validate === newSettings.validate\r\n        && currentSettings.enableSuggestions && currentSettings.enableSuggestions;\r\n}\r\nclass DiagnosticSettings {\r\n    constructor() {\r\n        this._languageSettings = new Map();\r\n    }\r\n    getValidate(language) {\r\n        return this.get(language).validate;\r\n    }\r\n    setValidate(language, value) {\r\n        return this.update(language, settings => ({\r\n            validate: value,\r\n            enableSuggestions: settings.enableSuggestions,\r\n        }));\r\n    }\r\n    getEnableSuggestions(language) {\r\n        return this.get(language).enableSuggestions;\r\n    }\r\n    setEnableSuggestions(language, value) {\r\n        return this.update(language, settings => ({\r\n            validate: settings.validate,\r\n            enableSuggestions: value\r\n        }));\r\n    }\r\n    get(language) {\r\n        return this._languageSettings.get(language) || DiagnosticSettings.defaultSettings;\r\n    }\r\n    update(language, f) {\r\n        const currentSettings = this.get(language);\r\n        const newSettings = f(currentSettings);\r\n        this._languageSettings.set(language, newSettings);\r\n        return areLanguageDiagnosticSettingsEqual(currentSettings, newSettings);\r\n    }\r\n}\r\nDiagnosticSettings.defaultSettings = {\r\n    validate: true,\r\n    enableSuggestions: true\r\n};\r\nclass DiagnosticsManager extends dispose_1.Disposable {\r\n    constructor(owner) {\r\n        super();\r\n        this._diagnostics = new resourceMap_1.ResourceMap();\r\n        this._settings = new DiagnosticSettings();\r\n        this._pendingUpdates = new resourceMap_1.ResourceMap();\r\n        this._updateDelay = 50;\r\n        this._currentDiagnostics = this._register(vscode.languages.createDiagnosticCollection(owner));\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        for (const value of this._pendingUpdates.values) {\r\n            clearTimeout(value);\r\n        }\r\n        this._pendingUpdates.clear();\r\n    }\r\n    reInitialize() {\r\n        this._currentDiagnostics.clear();\r\n        this._diagnostics.clear();\r\n    }\r\n    setValidate(language, value) {\r\n        const didUpdate = this._settings.setValidate(language, value);\r\n        if (didUpdate) {\r\n            this.rebuild();\r\n        }\r\n    }\r\n    setEnableSuggestions(language, value) {\r\n        const didUpdate = this._settings.setEnableSuggestions(language, value);\r\n        if (didUpdate) {\r\n            this.rebuild();\r\n        }\r\n    }\r\n    updateDiagnostics(file, language, kind, diagnostics) {\r\n        let didUpdate = false;\r\n        const entry = this._diagnostics.get(file);\r\n        if (entry) {\r\n            didUpdate = entry.updateDiagnostics(language, kind, diagnostics);\r\n        }\r\n        else if (diagnostics.length) {\r\n            const fileDiagnostics = new FileDiagnostics(file, language);\r\n            fileDiagnostics.updateDiagnostics(language, kind, diagnostics);\r\n            this._diagnostics.set(file, fileDiagnostics);\r\n            didUpdate = true;\r\n        }\r\n        if (didUpdate) {\r\n            this.scheduleDiagnosticsUpdate(file);\r\n        }\r\n    }\r\n    configFileDiagnosticsReceived(file, diagnostics) {\r\n        this._currentDiagnostics.set(file, diagnostics);\r\n    }\r\n    delete(resource) {\r\n        this._currentDiagnostics.delete(resource);\r\n        this._diagnostics.delete(resource);\r\n    }\r\n    getDiagnostics(file) {\r\n        return this._currentDiagnostics.get(file) || [];\r\n    }\r\n    scheduleDiagnosticsUpdate(file) {\r\n        if (!this._pendingUpdates.has(file)) {\r\n            this._pendingUpdates.set(file, setTimeout(() => this.updateCurrentDiagnostics(file), this._updateDelay));\r\n        }\r\n    }\r\n    updateCurrentDiagnostics(file) {\r\n        if (this._pendingUpdates.has(file)) {\r\n            clearTimeout(this._pendingUpdates.get(file));\r\n            this._pendingUpdates.delete(file);\r\n        }\r\n        const fileDiagnostics = this._diagnostics.get(file);\r\n        this._currentDiagnostics.set(file, fileDiagnostics ? fileDiagnostics.getDiagnostics(this._settings) : []);\r\n    }\r\n    rebuild() {\r\n        this._currentDiagnostics.clear();\r\n        for (const fileDiagnostic of this._diagnostics.values) {\r\n            this._currentDiagnostics.set(fileDiagnostic.file, fileDiagnostic.getDiagnostics(this._settings));\r\n        }\r\n    }\r\n}\r\nexports.DiagnosticsManager = DiagnosticsManager;\r\n//# sourceMappingURL=diagnostics.js.map","/typescript-language-features/out/utils/arrays.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.empty = Object.freeze([]);\r\nfunction equals(a, b, itemEquals = (a, b) => a === b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a.length !== b.length) {\r\n        return false;\r\n    }\r\n    return a.every((x, i) => itemEquals(x, b[i]));\r\n}\r\nexports.equals = equals;\r\nfunction flatten(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nexports.flatten = flatten;\r\n//# sourceMappingURL=arrays.js.map","/typescript-language-features/out/utils/configuration.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst vscode = require(\"vscode\");\r\nconst arrays = require(\"./arrays\");\r\nconst os = require(\"os\");\r\nconst path = require(\"path\");\r\nvar TsServerLogLevel;\r\n(function (TsServerLogLevel) {\r\n    TsServerLogLevel[TsServerLogLevel[\"Off\"] = 0] = \"Off\";\r\n    TsServerLogLevel[TsServerLogLevel[\"Normal\"] = 1] = \"Normal\";\r\n    TsServerLogLevel[TsServerLogLevel[\"Terse\"] = 2] = \"Terse\";\r\n    TsServerLogLevel[TsServerLogLevel[\"Verbose\"] = 3] = \"Verbose\";\r\n})(TsServerLogLevel = exports.TsServerLogLevel || (exports.TsServerLogLevel = {}));\r\n(function (TsServerLogLevel) {\r\n    function fromString(value) {\r\n        switch (value && value.toLowerCase()) {\r\n            case 'normal':\r\n                return TsServerLogLevel.Normal;\r\n            case 'terse':\r\n                return TsServerLogLevel.Terse;\r\n            case 'verbose':\r\n                return TsServerLogLevel.Verbose;\r\n            case 'off':\r\n            default:\r\n                return TsServerLogLevel.Off;\r\n        }\r\n    }\r\n    TsServerLogLevel.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case TsServerLogLevel.Normal:\r\n                return 'normal';\r\n            case TsServerLogLevel.Terse:\r\n                return 'terse';\r\n            case TsServerLogLevel.Verbose:\r\n                return 'verbose';\r\n            case TsServerLogLevel.Off:\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    TsServerLogLevel.toString = toString;\r\n})(TsServerLogLevel = exports.TsServerLogLevel || (exports.TsServerLogLevel = {}));\r\nclass TypeScriptServiceConfiguration {\r\n    constructor() {\r\n        this.tsServerLogLevel = TsServerLogLevel.Off;\r\n        const configuration = vscode.workspace.getConfiguration();\r\n        this.locale = TypeScriptServiceConfiguration.extractLocale(configuration);\r\n        this.globalTsdk = TypeScriptServiceConfiguration.extractGlobalTsdk(configuration);\r\n        this.localTsdk = TypeScriptServiceConfiguration.extractLocalTsdk(configuration);\r\n        this.npmLocation = TypeScriptServiceConfiguration.readNpmLocation(configuration);\r\n        this.tsServerLogLevel = TypeScriptServiceConfiguration.readTsServerLogLevel(configuration);\r\n        this.tsServerPluginPaths = TypeScriptServiceConfiguration.readTsServerPluginPaths(configuration);\r\n        this.checkJs = TypeScriptServiceConfiguration.readCheckJs(configuration);\r\n        this.experimentalDecorators = TypeScriptServiceConfiguration.readExperimentalDecorators(configuration);\r\n        this.disableAutomaticTypeAcquisition = TypeScriptServiceConfiguration.readDisableAutomaticTypeAcquisition(configuration);\r\n        this.useSeparateSyntaxServer = TypeScriptServiceConfiguration.readUseSeparateSyntaxServer(configuration);\r\n    }\r\n    static loadFromWorkspace() {\r\n        return new TypeScriptServiceConfiguration();\r\n    }\r\n    isEqualTo(other) {\r\n        return this.locale === other.locale\r\n            && this.globalTsdk === other.globalTsdk\r\n            && this.localTsdk === other.localTsdk\r\n            && this.npmLocation === other.npmLocation\r\n            && this.tsServerLogLevel === other.tsServerLogLevel\r\n            && this.checkJs === other.checkJs\r\n            && this.experimentalDecorators === other.experimentalDecorators\r\n            && this.disableAutomaticTypeAcquisition === other.disableAutomaticTypeAcquisition\r\n            && arrays.equals(this.tsServerPluginPaths, other.tsServerPluginPaths)\r\n            && this.useSeparateSyntaxServer === other.useSeparateSyntaxServer;\r\n    }\r\n    static fixPathPrefixes(inspectValue) {\r\n        const pathPrefixes = ['~' + path.sep];\r\n        for (const pathPrefix of pathPrefixes) {\r\n            if (inspectValue.startsWith(pathPrefix)) {\r\n                return path.join(os.homedir(), inspectValue.slice(pathPrefix.length));\r\n            }\r\n        }\r\n        return inspectValue;\r\n    }\r\n    static extractGlobalTsdk(configuration) {\r\n        const inspect = configuration.inspect('typescript.tsdk');\r\n        if (inspect && typeof inspect.globalValue === 'string') {\r\n            return this.fixPathPrefixes(inspect.globalValue);\r\n        }\r\n        return null;\r\n    }\r\n    static extractLocalTsdk(configuration) {\r\n        const inspect = configuration.inspect('typescript.tsdk');\r\n        if (inspect && typeof inspect.workspaceValue === 'string') {\r\n            return this.fixPathPrefixes(inspect.workspaceValue);\r\n        }\r\n        return null;\r\n    }\r\n    static readTsServerLogLevel(configuration) {\r\n        const setting = configuration.get('typescript.tsserver.log', 'off');\r\n        return TsServerLogLevel.fromString(setting);\r\n    }\r\n    static readTsServerPluginPaths(configuration) {\r\n        return configuration.get('typescript.tsserver.pluginPaths', []);\r\n    }\r\n    static readCheckJs(configuration) {\r\n        return configuration.get('javascript.implicitProjectConfig.checkJs', false);\r\n    }\r\n    static readExperimentalDecorators(configuration) {\r\n        return configuration.get('javascript.implicitProjectConfig.experimentalDecorators', false);\r\n    }\r\n    static readNpmLocation(configuration) {\r\n        return configuration.get('typescript.npm', null);\r\n    }\r\n    static readDisableAutomaticTypeAcquisition(configuration) {\r\n        return configuration.get('typescript.disableAutomaticTypeAcquisition', false);\r\n    }\r\n    static extractLocale(configuration) {\r\n        return configuration.get('typescript.locale', null);\r\n    }\r\n    static readUseSeparateSyntaxServer(configuration) {\r\n        return configuration.get('typescript.tsserver.useSeparateSyntaxServer', true);\r\n    }\r\n}\r\nexports.TypeScriptServiceConfiguration = TypeScriptServiceConfiguration;\r\n//# sourceMappingURL=configuration.js.map","/typescript-language-features/out/utils/logger.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst memoize_1 = require(\"./memoize\");\r\nconst localize = nls.loadMessageBundle();\r\nclass Logger {\r\n    get output() {\r\n        return vscode.window.createOutputChannel(localize('channelName', 'TypeScript'));\r\n    }\r\n    data2String(data) {\r\n        if (data instanceof Error) {\r\n            return data.stack || data.message;\r\n        }\r\n        if (data.success === false && data.message) {\r\n            return data.message;\r\n        }\r\n        return data.toString();\r\n    }\r\n    info(message, data) {\r\n        this.logLevel('Info', message, data);\r\n    }\r\n    error(message, data) {\r\n        // See https://github.com/Microsoft/TypeScript/issues/10496\r\n        if (data && data.message === 'No content available.') {\r\n            return;\r\n        }\r\n        this.logLevel('Error', message, data);\r\n    }\r\n    logLevel(level, message, data) {\r\n        this.output.appendLine(`[${level}  - ${(new Date().toLocaleTimeString())}] ${message}`);\r\n        if (data) {\r\n            this.output.appendLine(this.data2String(data));\r\n        }\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], Logger.prototype, \"output\", null);\r\nexports.default = Logger;\r\n//# sourceMappingURL=logger.js.map","/typescript-language-features/out/utils/pluginPathsProvider.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst relativePathResolver_1 = require(\"./relativePathResolver\");\r\nclass TypeScriptPluginPathsProvider {\r\n    constructor(configuration) {\r\n        this.configuration = configuration;\r\n    }\r\n    updateConfiguration(configuration) {\r\n        this.configuration = configuration;\r\n    }\r\n    getPluginPaths() {\r\n        const pluginPaths = [];\r\n        for (const pluginPath of this.configuration.tsServerPluginPaths) {\r\n            pluginPaths.push(...this.resolvePluginPath(pluginPath));\r\n        }\r\n        return pluginPaths;\r\n    }\r\n    resolvePluginPath(pluginPath) {\r\n        if (path.isAbsolute(pluginPath)) {\r\n            return [pluginPath];\r\n        }\r\n        const workspacePath = relativePathResolver_1.RelativeWorkspacePathResolver.asAbsoluteWorkspacePath(pluginPath);\r\n        if (workspacePath !== undefined) {\r\n            return [workspacePath];\r\n        }\r\n        return (vscode.workspace.workspaceFolders || [])\r\n            .map(workspaceFolder => path.join(workspaceFolder.uri.fsPath, pluginPath));\r\n    }\r\n}\r\nexports.TypeScriptPluginPathsProvider = TypeScriptPluginPathsProvider;\r\n//# sourceMappingURL=pluginPathsProvider.js.map","/typescript-language-features/out/utils/relativePathResolver.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nclass RelativeWorkspacePathResolver {\r\n    static asAbsoluteWorkspacePath(relativePath) {\r\n        for (const root of vscode.workspace.workspaceFolders || []) {\r\n            const rootPrefixes = [`./${root.name}/`, `${root.name}/`, `.\\\\${root.name}\\\\`, `${root.name}\\\\`];\r\n            for (const rootPrefix of rootPrefixes) {\r\n                if (relativePath.startsWith(rootPrefix)) {\r\n                    return path.join(root.uri.fsPath, relativePath.replace(rootPrefix, ''));\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nexports.RelativeWorkspacePathResolver = RelativeWorkspacePathResolver;\r\n//# sourceMappingURL=relativePathResolver.js.map","/typescript-language-features/out/utils/telemetry.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst vscode_extension_telemetry_1 = require(\"vscode-extension-telemetry\");\r\nconst memoize_1 = require(\"./memoize\");\r\nclass VSCodeTelemetryReporter {\r\n    constructor(clientVersionDelegate) {\r\n        this.clientVersionDelegate = clientVersionDelegate;\r\n        this._reporter = null;\r\n    }\r\n    logTelemetry(eventName, properties) {\r\n        const reporter = this.reporter;\r\n        if (reporter) {\r\n            if (!properties) {\r\n                properties = {};\r\n            }\r\n            /* __GDPR__FRAGMENT__\r\n                \"TypeScriptCommonProperties\" : {\r\n                    \"version\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\r\n                }\r\n            */\r\n            properties['version'] = this.clientVersionDelegate();\r\n            reporter.sendTelemetryEvent(eventName, properties);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._reporter) {\r\n            this._reporter.dispose();\r\n            this._reporter = null;\r\n        }\r\n    }\r\n    get reporter() {\r\n        if (this.packageInfo && this.packageInfo.aiKey) {\r\n            this._reporter = new vscode_extension_telemetry_1.default(this.packageInfo.name, this.packageInfo.version, this.packageInfo.aiKey);\r\n            return this._reporter;\r\n        }\r\n        return null;\r\n    }\r\n    get packageInfo() {\r\n        const { packageJSON } = vscode.extensions.getExtension('vscode.typescript-language-features');\r\n        if (packageJSON) {\r\n            return {\r\n                name: packageJSON.name,\r\n                version: packageJSON.version,\r\n                aiKey: packageJSON.aiKey\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], VSCodeTelemetryReporter.prototype, \"reporter\", null);\r\n__decorate([\r\n    memoize_1.memoize\r\n], VSCodeTelemetryReporter.prototype, \"packageInfo\", null);\r\nexports.VSCodeTelemetryReporter = VSCodeTelemetryReporter;\r\n//# sourceMappingURL=telemetry.js.map","/typescript-language-features/out/utils/tracer.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Verbose\"] = 2] = \"Verbose\";\r\n})(Trace || (Trace = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n})(Trace || (Trace = {}));\r\nclass Tracer {\r\n    constructor(logger) {\r\n        this.logger = logger;\r\n        this.updateConfiguration();\r\n    }\r\n    updateConfiguration() {\r\n        this.trace = Tracer.readTrace();\r\n    }\r\n    static readTrace() {\r\n        let result = Trace.fromString(vscode.workspace.getConfiguration().get('typescript.tsserver.trace', 'off'));\r\n        if (result === Trace.Off && !!process.env.TSS_TRACE) {\r\n            result = Trace.Messages;\r\n        }\r\n        return result;\r\n    }\r\n    traceRequest(serverId, request, responseExpected, queueLength) {\r\n        if (this.trace === Trace.Off) {\r\n            return;\r\n        }\r\n        let data = undefined;\r\n        if (this.trace === Trace.Verbose && request.arguments) {\r\n            data = `Arguments: ${JSON.stringify(request.arguments, null, 4)}`;\r\n        }\r\n        this.logTrace(serverId, `Sending request: ${request.command} (${request.seq}). Response expected: ${responseExpected ? 'yes' : 'no'}. Current queue length: ${queueLength}`, data);\r\n    }\r\n    traceResponse(serverId, response, startTime) {\r\n        if (this.trace === Trace.Off) {\r\n            return;\r\n        }\r\n        let data = undefined;\r\n        if (this.trace === Trace.Verbose && response.body) {\r\n            data = `Result: ${JSON.stringify(response.body, null, 4)}`;\r\n        }\r\n        this.logTrace(serverId, `Response received: ${response.command} (${response.request_seq}). Request took ${Date.now() - startTime} ms. Success: ${response.success} ${!response.success ? '. Message: ' + response.message : ''}`, data);\r\n    }\r\n    traceRequestCompleted(serverId, command, request_seq, startTime) {\r\n        if (this.trace === Trace.Off) {\r\n            return;\r\n        }\r\n        this.logTrace(serverId, `Async response received: ${command} (${request_seq}). Request took ${Date.now() - startTime} ms.`);\r\n    }\r\n    traceEvent(serverId, event) {\r\n        if (this.trace === Trace.Off) {\r\n            return;\r\n        }\r\n        let data = undefined;\r\n        if (this.trace === Trace.Verbose && event.body) {\r\n            data = `Data: ${JSON.stringify(event.body, null, 4)}`;\r\n        }\r\n        this.logTrace(serverId, `Event received: ${event.event} (${event.seq}).`, data);\r\n    }\r\n    logTrace(serverId, message, data) {\r\n        if (this.trace !== Trace.Off) {\r\n            this.logger.logLevel('Trace', `<${serverId}> ${message}`, data);\r\n        }\r\n    }\r\n}\r\nexports.default = Tracer;\r\n//# sourceMappingURL=tracer.js.map","/typescript-language-features/out/utils/versionPicker.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst localize = nls.loadMessageBundle();\r\nconst useWorkspaceTsdkStorageKey = 'typescript.useWorkspaceTsdk';\r\nvar MessageAction;\r\n(function (MessageAction) {\r\n    MessageAction[MessageAction[\"useLocal\"] = 0] = \"useLocal\";\r\n    MessageAction[MessageAction[\"useBundled\"] = 1] = \"useBundled\";\r\n    MessageAction[MessageAction[\"learnMore\"] = 2] = \"learnMore\";\r\n})(MessageAction || (MessageAction = {}));\r\nclass TypeScriptVersionPicker {\r\n    constructor(versionProvider, workspaceState) {\r\n        this.versionProvider = versionProvider;\r\n        this.workspaceState = workspaceState;\r\n        this._currentVersion = this.versionProvider.defaultVersion;\r\n        if (this.useWorkspaceTsdkSetting) {\r\n            const localVersion = this.versionProvider.localVersion;\r\n            if (localVersion) {\r\n                this._currentVersion = localVersion;\r\n            }\r\n        }\r\n    }\r\n    get useWorkspaceTsdkSetting() {\r\n        return this.workspaceState.get(useWorkspaceTsdkStorageKey, false);\r\n    }\r\n    get currentVersion() {\r\n        return this._currentVersion;\r\n    }\r\n    useBundledVersion() {\r\n        this._currentVersion = this.versionProvider.bundledVersion;\r\n    }\r\n    async show(firstRun) {\r\n        const pickOptions = [];\r\n        const shippedVersion = this.versionProvider.defaultVersion;\r\n        pickOptions.push({\r\n            label: (!this.useWorkspaceTsdkSetting\r\n                ? ' '\r\n                : '') + localize('useVSCodeVersionOption', 'Use VS Code\\'s Version'),\r\n            description: shippedVersion.versionString,\r\n            detail: shippedVersion.pathLabel,\r\n            id: MessageAction.useBundled,\r\n        });\r\n        for (const version of this.versionProvider.localVersions) {\r\n            pickOptions.push({\r\n                label: (this.useWorkspaceTsdkSetting && this.currentVersion.path === version.path\r\n                    ? ' '\r\n                    : '') + localize('useWorkspaceVersionOption', 'Use Workspace Version'),\r\n                description: version.versionString,\r\n                detail: version.pathLabel,\r\n                id: MessageAction.useLocal,\r\n                version\r\n            });\r\n        }\r\n        pickOptions.push({\r\n            label: localize('learnMore', 'Learn More'),\r\n            description: '',\r\n            id: MessageAction.learnMore\r\n        });\r\n        const selected = await vscode.window.showQuickPick(pickOptions, {\r\n            placeHolder: localize('selectTsVersion', 'Select the TypeScript version used for JavaScript and TypeScript language features'),\r\n            ignoreFocusOut: firstRun,\r\n        });\r\n        if (!selected) {\r\n            return { oldVersion: this.currentVersion };\r\n        }\r\n        switch (selected.id) {\r\n            case MessageAction.useLocal:\r\n                await this.workspaceState.update(useWorkspaceTsdkStorageKey, true);\r\n                if (selected.version) {\r\n                    const tsConfig = vscode.workspace.getConfiguration('typescript');\r\n                    await tsConfig.update('tsdk', selected.version.pathLabel, false);\r\n                    const previousVersion = this.currentVersion;\r\n                    this._currentVersion = selected.version;\r\n                    return { oldVersion: previousVersion, newVersion: selected.version };\r\n                }\r\n                return { oldVersion: this.currentVersion };\r\n            case MessageAction.useBundled:\r\n                await this.workspaceState.update(useWorkspaceTsdkStorageKey, false);\r\n                const previousVersion = this.currentVersion;\r\n                this._currentVersion = shippedVersion;\r\n                return { oldVersion: previousVersion, newVersion: shippedVersion };\r\n            case MessageAction.learnMore:\r\n                vscode.env.openExternal(vscode.Uri.parse('https://go.microsoft.com/fwlink/?linkid=839919'));\r\n                return { oldVersion: this.currentVersion };\r\n            default:\r\n                return { oldVersion: this.currentVersion };\r\n        }\r\n    }\r\n}\r\nexports.TypeScriptVersionPicker = TypeScriptVersionPicker;\r\n//# sourceMappingURL=versionPicker.js.map","/typescript-language-features/out/utils/versionProvider.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"./api\");\r\nconst relativePathResolver_1 = require(\"./relativePathResolver\");\r\nconst localize = nls.loadMessageBundle();\r\nclass TypeScriptVersion {\r\n    constructor(path, _pathLabel) {\r\n        this.path = path;\r\n        this._pathLabel = _pathLabel;\r\n    }\r\n    get tsServerPath() {\r\n        return path.join(this.path, 'tsserver.js');\r\n    }\r\n    get pathLabel() {\r\n        return typeof this._pathLabel === 'undefined' ? this.path : this._pathLabel;\r\n    }\r\n    get isValid() {\r\n        return this.apiVersion !== undefined;\r\n    }\r\n    get apiVersion() {\r\n        const version = this.getTypeScriptVersion(this.tsServerPath);\r\n        if (version) {\r\n            return version;\r\n        }\r\n        // Allow TS developers to provide custom version\r\n        const tsdkVersion = vscode.workspace.getConfiguration().get('typescript.tsdk_version', undefined);\r\n        if (tsdkVersion) {\r\n            return api_1.default.fromVersionString(tsdkVersion);\r\n        }\r\n        return undefined;\r\n    }\r\n    get versionString() {\r\n        const version = this.apiVersion;\r\n        return version ? version.versionString : localize('couldNotLoadTsVersion', 'Could not load the TypeScript version at this path');\r\n    }\r\n    getTypeScriptVersion(serverPath) {\r\n        if (!fs.existsSync(serverPath)) {\r\n            return undefined;\r\n        }\r\n        const p = serverPath.split(path.sep);\r\n        if (p.length <= 2) {\r\n            return undefined;\r\n        }\r\n        const p2 = p.slice(0, -2);\r\n        const modulePath = p2.join(path.sep);\r\n        let fileName = path.join(modulePath, 'package.json');\r\n        if (!fs.existsSync(fileName)) {\r\n            // Special case for ts dev versions\r\n            if (path.basename(modulePath) === 'built') {\r\n                fileName = path.join(modulePath, '..', 'package.json');\r\n            }\r\n        }\r\n        if (!fs.existsSync(fileName)) {\r\n            return undefined;\r\n        }\r\n        const contents = fs.readFileSync(fileName).toString();\r\n        let desc = null;\r\n        try {\r\n            desc = JSON.parse(contents);\r\n        }\r\n        catch (err) {\r\n            return undefined;\r\n        }\r\n        if (!desc || !desc.version) {\r\n            return undefined;\r\n        }\r\n        return desc.version ? api_1.default.fromVersionString(desc.version) : undefined;\r\n    }\r\n}\r\nexports.TypeScriptVersion = TypeScriptVersion;\r\nclass TypeScriptVersionProvider {\r\n    constructor(configuration) {\r\n        this.configuration = configuration;\r\n    }\r\n    updateConfiguration(configuration) {\r\n        this.configuration = configuration;\r\n    }\r\n    get defaultVersion() {\r\n        return this.globalVersion || this.bundledVersion;\r\n    }\r\n    get globalVersion() {\r\n        if (this.configuration.globalTsdk) {\r\n            const globals = this.loadVersionsFromSetting(this.configuration.globalTsdk);\r\n            if (globals && globals.length) {\r\n                return globals[0];\r\n            }\r\n        }\r\n        return this.contributedTsNextVersion;\r\n    }\r\n    get localVersion() {\r\n        const tsdkVersions = this.localTsdkVersions;\r\n        if (tsdkVersions && tsdkVersions.length) {\r\n            return tsdkVersions[0];\r\n        }\r\n        const nodeVersions = this.localNodeModulesVersions;\r\n        if (nodeVersions && nodeVersions.length === 1) {\r\n            return nodeVersions[0];\r\n        }\r\n        return undefined;\r\n    }\r\n    get localVersions() {\r\n        const allVersions = this.localTsdkVersions.concat(this.localNodeModulesVersions);\r\n        const paths = new Set();\r\n        return allVersions.filter(x => {\r\n            if (paths.has(x.path)) {\r\n                return false;\r\n            }\r\n            paths.add(x.path);\r\n            return true;\r\n        });\r\n    }\r\n    get bundledVersion() {\r\n        const version = this.getContributedVersion('vscode.typescript-language-features', ['..', 'node_modules']);\r\n        if (version) {\r\n            return version;\r\n        }\r\n        vscode.window.showErrorMessage(localize('noBundledServerFound', 'VS Code\\'s tsserver was deleted by another application such as a misbehaving virus detection tool. Please reinstall VS Code.'));\r\n        throw new Error('Could not find bundled tsserver.js');\r\n    }\r\n    get contributedTsNextVersion() {\r\n        return this.getContributedVersion('ms-vscode.vscode-typescript-next', ['node_modules']);\r\n    }\r\n    getContributedVersion(extensionId, pathToTs) {\r\n        try {\r\n            const extension = vscode.extensions.getExtension(extensionId);\r\n            if (extension) {\r\n                const typescriptPath = path.join(extension.extensionPath, ...pathToTs, 'typescript', 'lib');\r\n                const bundledVersion = new TypeScriptVersion(typescriptPath, '');\r\n                if (bundledVersion.isValid) {\r\n                    return bundledVersion;\r\n                }\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // noop\r\n        }\r\n        return undefined;\r\n    }\r\n    get localTsdkVersions() {\r\n        const localTsdk = this.configuration.localTsdk;\r\n        return localTsdk ? this.loadVersionsFromSetting(localTsdk) : [];\r\n    }\r\n    loadVersionsFromSetting(tsdkPathSetting) {\r\n        if (path.isAbsolute(tsdkPathSetting)) {\r\n            return [new TypeScriptVersion(tsdkPathSetting)];\r\n        }\r\n        const workspacePath = relativePathResolver_1.RelativeWorkspacePathResolver.asAbsoluteWorkspacePath(tsdkPathSetting);\r\n        if (workspacePath !== undefined) {\r\n            return [new TypeScriptVersion(workspacePath, tsdkPathSetting)];\r\n        }\r\n        return this.loadTypeScriptVersionsFromPath(tsdkPathSetting);\r\n    }\r\n    get localNodeModulesVersions() {\r\n        return this.loadTypeScriptVersionsFromPath(path.join('node_modules', 'typescript', 'lib'))\r\n            .filter(x => x.isValid);\r\n    }\r\n    loadTypeScriptVersionsFromPath(relativePath) {\r\n        if (!vscode.workspace.workspaceFolders) {\r\n            return [];\r\n        }\r\n        const versions = [];\r\n        for (const root of vscode.workspace.workspaceFolders) {\r\n            let label = relativePath;\r\n            if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 1) {\r\n                label = path.join(root.name, relativePath);\r\n            }\r\n            versions.push(new TypeScriptVersion(path.join(root.uri.fsPath, relativePath), label));\r\n        }\r\n        return versions;\r\n    }\r\n}\r\nexports.TypeScriptVersionProvider = TypeScriptVersionProvider;\r\n//# sourceMappingURL=versionProvider.js.map","/typescript-language-features/out/tsServer/spawner.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst configuration_1 = require(\"../utils/configuration\");\r\nconst electron = require(\"../utils/electron\");\r\nconst server_1 = require(\"./server\");\r\nclass TypeScriptServerSpawner {\r\n    constructor(_versionProvider, _logDirectoryProvider, _pluginPathsProvider, _logger, _telemetryReporter, _tracer) {\r\n        this._versionProvider = _versionProvider;\r\n        this._logDirectoryProvider = _logDirectoryProvider;\r\n        this._pluginPathsProvider = _pluginPathsProvider;\r\n        this._logger = _logger;\r\n        this._telemetryReporter = _telemetryReporter;\r\n        this._tracer = _tracer;\r\n    }\r\n    spawn(version, configuration, pluginManager) {\r\n        if (this.shouldUseSeparateSyntaxServer(version, configuration)) {\r\n            const syntaxServer = this.spawnTsServer('syntax', version, configuration, pluginManager);\r\n            const semanticServer = this.spawnTsServer('semantic', version, configuration, pluginManager);\r\n            return new server_1.SyntaxRoutingTsServer(syntaxServer, semanticServer);\r\n        }\r\n        return this.spawnTsServer('main', version, configuration, pluginManager);\r\n    }\r\n    shouldUseSeparateSyntaxServer(version, configuration) {\r\n        return configuration.useSeparateSyntaxServer && !!version.apiVersion && version.apiVersion.gte(api_1.default.v340);\r\n    }\r\n    spawnTsServer(kind, version, configuration, pluginManager) {\r\n        const apiVersion = version.apiVersion || api_1.default.defaultVersion;\r\n        const { args, cancellationPipeName, tsServerLogFile } = this.getTsServerArgs(kind, configuration, version, apiVersion, pluginManager);\r\n        if (TypeScriptServerSpawner.isLoggingEnabled(apiVersion, configuration)) {\r\n            if (tsServerLogFile) {\r\n                this._logger.info(`<${kind}>  Log file: ${tsServerLogFile}`);\r\n            }\r\n            else {\r\n                this._logger.error(`<${kind}> Could not create log directory`);\r\n            }\r\n        }\r\n        this._logger.info(`<${kind}> Forking...`);\r\n        const childProcess = electron.fork(version.tsServerPath, args, this.getForkOptions(kind));\r\n        this._logger.info(`<${kind}> Starting...`);\r\n        return new server_1.ProcessBasedTsServer(kind, new ChildServerProcess(childProcess), tsServerLogFile, new server_1.PipeRequestCanceller(kind, cancellationPipeName, this._tracer), version, this._telemetryReporter, this._tracer);\r\n    }\r\n    getForkOptions(kind) {\r\n        const debugPort = TypeScriptServerSpawner.getDebugPort(kind);\r\n        const tsServerForkOptions = {\r\n            execArgv: debugPort ? [`--inspect=${debugPort}`] : [],\r\n        };\r\n        return tsServerForkOptions;\r\n    }\r\n    getTsServerArgs(kind, configuration, currentVersion, apiVersion, pluginManager) {\r\n        const args = [];\r\n        let cancellationPipeName;\r\n        let tsServerLogFile;\r\n        if (kind === 'syntax') {\r\n            args.push('--syntaxOnly');\r\n        }\r\n        if (apiVersion.gte(api_1.default.v206)) {\r\n            if (apiVersion.gte(api_1.default.v250)) {\r\n                args.push('--useInferredProjectPerProjectRoot');\r\n            }\r\n            else {\r\n                args.push('--useSingleInferredProject');\r\n            }\r\n            if (configuration.disableAutomaticTypeAcquisition || kind === 'syntax') {\r\n                args.push('--disableAutomaticTypingAcquisition');\r\n            }\r\n        }\r\n        if (apiVersion.gte(api_1.default.v208) && kind !== 'syntax') {\r\n            args.push('--enableTelemetry');\r\n        }\r\n        if (apiVersion.gte(api_1.default.v222)) {\r\n            cancellationPipeName = electron.getTempFile('tscancellation');\r\n            args.push('--cancellationPipeName', cancellationPipeName + '*');\r\n        }\r\n        if (TypeScriptServerSpawner.isLoggingEnabled(apiVersion, configuration)) {\r\n            const logDir = this._logDirectoryProvider.getNewLogDirectory();\r\n            if (logDir) {\r\n                tsServerLogFile = path.join(logDir, `tsserver.log`);\r\n                args.push('--logVerbosity', configuration_1.TsServerLogLevel.toString(configuration.tsServerLogLevel));\r\n                args.push('--logFile', tsServerLogFile);\r\n            }\r\n        }\r\n        if (apiVersion.gte(api_1.default.v230)) {\r\n            const pluginPaths = this._pluginPathsProvider.getPluginPaths();\r\n            if (pluginManager.plugins.length) {\r\n                args.push('--globalPlugins', pluginManager.plugins.map(x => x.name).join(','));\r\n                const isUsingBundledTypeScriptVersion = currentVersion.path === this._versionProvider.defaultVersion.path;\r\n                for (const plugin of pluginManager.plugins) {\r\n                    if (isUsingBundledTypeScriptVersion || plugin.enableForWorkspaceTypeScriptVersions) {\r\n                        pluginPaths.push(plugin.path);\r\n                    }\r\n                }\r\n            }\r\n            if (pluginPaths.length !== 0) {\r\n                args.push('--pluginProbeLocations', pluginPaths.join(','));\r\n            }\r\n        }\r\n        if (apiVersion.gte(api_1.default.v234)) {\r\n            if (configuration.npmLocation) {\r\n                args.push('--npmLocation', `\"${configuration.npmLocation}\"`);\r\n            }\r\n        }\r\n        if (apiVersion.gte(api_1.default.v260)) {\r\n            args.push('--locale', TypeScriptServerSpawner.getTsLocale(configuration));\r\n        }\r\n        if (apiVersion.gte(api_1.default.v291)) {\r\n            args.push('--noGetErrOnBackgroundUpdate');\r\n        }\r\n        if (apiVersion.gte(api_1.default.v345)) {\r\n            args.push('--validateDefaultNpmLocation');\r\n        }\r\n        return { args, cancellationPipeName, tsServerLogFile };\r\n    }\r\n    static getDebugPort(kind) {\r\n        if (kind === 'syntax') {\r\n            // We typically only want to debug the main semantic server\r\n            return undefined;\r\n        }\r\n        const value = process.env['TSS_DEBUG'];\r\n        if (value) {\r\n            const port = parseInt(value);\r\n            if (!isNaN(port)) {\r\n                return port;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    static isLoggingEnabled(apiVersion, configuration) {\r\n        return apiVersion.gte(api_1.default.v222) &&\r\n            configuration.tsServerLogLevel !== configuration_1.TsServerLogLevel.Off;\r\n    }\r\n    static getTsLocale(configuration) {\r\n        return configuration.locale\r\n            ? configuration.locale\r\n            : vscode.env.language;\r\n    }\r\n}\r\nexports.TypeScriptServerSpawner = TypeScriptServerSpawner;\r\nclass ChildServerProcess {\r\n    constructor(_process) {\r\n        this._process = _process;\r\n    }\r\n    get stdout() { return this._process.stdout; }\r\n    write(serverRequest) {\r\n        this._process.stdin.write(JSON.stringify(serverRequest) + '\\r\\n', 'utf8');\r\n    }\r\n    on(name, handler) {\r\n        this._process.on(name, handler);\r\n    }\r\n    kill() {\r\n        this._process.kill();\r\n    }\r\n}\r\n//# sourceMappingURL=spawner.js.map","/typescript-language-features/out/utils/electron.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst temp = require(\"./temp\");\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\nconst cp = require(\"child_process\");\r\nconst process = require(\"process\");\r\nconst getRootTempDir = (() => {\r\n    let dir;\r\n    return () => {\r\n        if (!dir) {\r\n            dir = temp.getTempFile(`vscode-typescript${process.platform !== 'win32' && process.getuid ? process.getuid() : ''}`);\r\n        }\r\n        if (!fs.existsSync(dir)) {\r\n            fs.mkdirSync(dir);\r\n        }\r\n        return dir;\r\n    };\r\n})();\r\nexports.getInstanceDir = (() => {\r\n    let dir;\r\n    return () => {\r\n        if (!dir) {\r\n            dir = path.join(getRootTempDir(), temp.makeRandomHexString(20));\r\n        }\r\n        if (!fs.existsSync(dir)) {\r\n            fs.mkdirSync(dir);\r\n        }\r\n        return dir;\r\n    };\r\n})();\r\nfunction getTempFile(prefix) {\r\n    return path.join(exports.getInstanceDir(), `${prefix}-${temp.makeRandomHexString(20)}.tmp`);\r\n}\r\nexports.getTempFile = getTempFile;\r\nfunction generatePatchedEnv(env, modulePath) {\r\n    const newEnv = Object.assign({}, env);\r\n    newEnv['ELECTRON_RUN_AS_NODE'] = '1';\r\n    newEnv['NODE_PATH'] = path.join(modulePath, '..', '..', '..');\r\n    // Ensure we always have a PATH set\r\n    newEnv['PATH'] = newEnv['PATH'] || process.env.PATH;\r\n    return newEnv;\r\n}\r\nfunction fork(modulePath, args, options) {\r\n    const newEnv = generatePatchedEnv(process.env, modulePath);\r\n    return cp.fork(modulePath, args, {\r\n        silent: true,\r\n        cwd: options.cwd,\r\n        env: newEnv,\r\n        execArgv: options.execArgv\r\n    });\r\n}\r\nexports.fork = fork;\r\n//# sourceMappingURL=electron.js.map","/typescript-language-features/out/tsServer/server.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst vscode = require(\"vscode\");\r\nconst typescriptService_1 = require(\"../typescriptService\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nconst wireProtocol_1 = require(\"../utils/wireProtocol\");\r\nconst callbackMap_1 = require(\"./callbackMap\");\r\nconst requestQueue_1 = require(\"./requestQueue\");\r\nconst serverError_1 = require(\"./serverError\");\r\nclass PipeRequestCanceller {\r\n    constructor(_serverId, _cancellationPipeName, _tracer) {\r\n        this._serverId = _serverId;\r\n        this._cancellationPipeName = _cancellationPipeName;\r\n        this._tracer = _tracer;\r\n    }\r\n    tryCancelOngoingRequest(seq) {\r\n        if (!this._cancellationPipeName) {\r\n            return false;\r\n        }\r\n        this._tracer.logTrace(this._serverId, `TypeScript Server: trying to cancel ongoing request with sequence number ${seq}`);\r\n        try {\r\n            fs.writeFileSync(this._cancellationPipeName + seq, '');\r\n        }\r\n        catch (_a) {\r\n            // noop\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.PipeRequestCanceller = PipeRequestCanceller;\r\nclass ProcessBasedTsServer extends dispose_1.Disposable {\r\n    constructor(_serverId, _process, _tsServerLogFile, _requestCanceller, _version, _telemetryReporter, _tracer) {\r\n        super();\r\n        this._serverId = _serverId;\r\n        this._process = _process;\r\n        this._tsServerLogFile = _tsServerLogFile;\r\n        this._requestCanceller = _requestCanceller;\r\n        this._version = _version;\r\n        this._telemetryReporter = _telemetryReporter;\r\n        this._tracer = _tracer;\r\n        this._requestQueue = new requestQueue_1.RequestQueue();\r\n        this._callbacks = new callbackMap_1.CallbackMap();\r\n        this._pendingResponses = new Set();\r\n        this._onEvent = this._register(new vscode.EventEmitter());\r\n        this.onEvent = this._onEvent.event;\r\n        this._onExit = this._register(new vscode.EventEmitter());\r\n        this.onExit = this._onExit.event;\r\n        this._onError = this._register(new vscode.EventEmitter());\r\n        this.onError = this._onError.event;\r\n        this._reader = this._register(new wireProtocol_1.Reader(this._process.stdout));\r\n        this._reader.onData(msg => this.dispatchMessage(msg));\r\n        this._process.on('exit', code => {\r\n            this._onExit.fire(code);\r\n            this._callbacks.destroy('server exited');\r\n        });\r\n        this._process.on('error', error => {\r\n            this._onError.fire(error);\r\n            this._callbacks.destroy('server errored');\r\n        });\r\n    }\r\n    get onReaderError() { return this._reader.onError; }\r\n    get tsServerLogFile() { return this._tsServerLogFile; }\r\n    write(serverRequest) {\r\n        this._process.write(serverRequest);\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._callbacks.destroy('server disposed');\r\n        this._pendingResponses.clear();\r\n    }\r\n    kill() {\r\n        this._process.kill();\r\n    }\r\n    dispatchMessage(message) {\r\n        try {\r\n            switch (message.type) {\r\n                case 'response':\r\n                    this.dispatchResponse(message);\r\n                    break;\r\n                case 'event':\r\n                    const event = message;\r\n                    if (event.event === 'requestCompleted') {\r\n                        const seq = event.body.request_seq;\r\n                        const p = this._callbacks.fetch(seq);\r\n                        if (p) {\r\n                            this._tracer.traceRequestCompleted(this._serverId, 'requestCompleted', seq, p.startTime);\r\n                            p.onSuccess(undefined);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this._tracer.traceEvent(this._serverId, event);\r\n                        this._onEvent.fire(event);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unknown message type ${message.type} received`);\r\n            }\r\n        }\r\n        finally {\r\n            this.sendNextRequests();\r\n        }\r\n    }\r\n    tryCancelRequest(seq, command) {\r\n        try {\r\n            if (this._requestQueue.tryDeletePendingRequest(seq)) {\r\n                this.logTrace(`Canceled request with sequence number ${seq}`);\r\n                return true;\r\n            }\r\n            if (this._requestCanceller.tryCancelOngoingRequest(seq)) {\r\n                return true;\r\n            }\r\n            this.logTrace(`Tried to cancel request with sequence number ${seq}. But request got already delivered.`);\r\n            return false;\r\n        }\r\n        finally {\r\n            const callback = this.fetchCallback(seq);\r\n            if (callback) {\r\n                callback.onSuccess(new typescriptService_1.ServerResponse.Cancelled(`Cancelled request ${seq} - ${command}`));\r\n            }\r\n        }\r\n    }\r\n    dispatchResponse(response) {\r\n        const callback = this.fetchCallback(response.request_seq);\r\n        if (!callback) {\r\n            return;\r\n        }\r\n        this._tracer.traceResponse(this._serverId, response, callback.startTime);\r\n        if (response.success) {\r\n            callback.onSuccess(response);\r\n        }\r\n        else if (response.message === 'No content available.') {\r\n            // Special case where response itself is successful but there is not any data to return.\r\n            callback.onSuccess(typescriptService_1.ServerResponse.NoContent);\r\n        }\r\n        else {\r\n            callback.onError(serverError_1.TypeScriptServerError.create(this._serverId, this._version, response));\r\n        }\r\n    }\r\n    executeImpl(command, args, executeInfo) {\r\n        const request = this._requestQueue.createRequest(command, args);\r\n        const requestInfo = {\r\n            request,\r\n            expectsResponse: executeInfo.expectsResult,\r\n            isAsync: executeInfo.isAsync,\r\n            queueingType: ProcessBasedTsServer.getQueueingType(command, executeInfo.lowPriority)\r\n        };\r\n        let result;\r\n        if (executeInfo.expectsResult) {\r\n            result = new Promise((resolve, reject) => {\r\n                this._callbacks.add(request.seq, { onSuccess: resolve, onError: reject, startTime: Date.now(), isAsync: executeInfo.isAsync }, executeInfo.isAsync);\r\n                if (executeInfo.token) {\r\n                    executeInfo.token.onCancellationRequested(() => {\r\n                        this.tryCancelRequest(request.seq, command);\r\n                    });\r\n                }\r\n            }).catch((err) => {\r\n                if (err instanceof serverError_1.TypeScriptServerError) {\r\n                    if (!executeInfo.token || !executeInfo.token.isCancellationRequested) {\r\n                        /* __GDPR__\r\n                            \"languageServiceErrorResponse\" : {\r\n                                \"command\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\r\n                                \"message\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\r\n                                \"stack\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\r\n                                \"errortext\" : { \"classification\": \"CallstackOrException\", \"purpose\": \"PerformanceAndHealth\" },\r\n                                \"${include}\": [\r\n                                    \"${TypeScriptCommonProperties}\"\r\n                                ]\r\n                            }\r\n                        */\r\n                        this._telemetryReporter.logTelemetry('languageServiceErrorResponse', {\r\n                            command: err.serverCommand,\r\n                            message: err.serverMessage || '',\r\n                            stack: err.serverStack || '',\r\n                            errortext: err.serverErrorText || '',\r\n                        });\r\n                    }\r\n                }\r\n                throw err;\r\n            });\r\n        }\r\n        this._requestQueue.enqueue(requestInfo);\r\n        this.sendNextRequests();\r\n        return result;\r\n    }\r\n    sendNextRequests() {\r\n        while (this._pendingResponses.size === 0 && this._requestQueue.length > 0) {\r\n            const item = this._requestQueue.dequeue();\r\n            if (item) {\r\n                this.sendRequest(item);\r\n            }\r\n        }\r\n    }\r\n    sendRequest(requestItem) {\r\n        const serverRequest = requestItem.request;\r\n        this._tracer.traceRequest(this._serverId, serverRequest, requestItem.expectsResponse, this._requestQueue.length);\r\n        if (requestItem.expectsResponse && !requestItem.isAsync) {\r\n            this._pendingResponses.add(requestItem.request.seq);\r\n        }\r\n        try {\r\n            this.write(serverRequest);\r\n        }\r\n        catch (err) {\r\n            const callback = this.fetchCallback(serverRequest.seq);\r\n            if (callback) {\r\n                callback.onError(err);\r\n            }\r\n        }\r\n    }\r\n    fetchCallback(seq) {\r\n        const callback = this._callbacks.fetch(seq);\r\n        if (!callback) {\r\n            return undefined;\r\n        }\r\n        this._pendingResponses.delete(seq);\r\n        return callback;\r\n    }\r\n    logTrace(message) {\r\n        this._tracer.logTrace(this._serverId, message);\r\n    }\r\n    static getQueueingType(command, lowPriority) {\r\n        if (ProcessBasedTsServer.fenceCommands.has(command)) {\r\n            return requestQueue_1.RequestQueueingType.Fence;\r\n        }\r\n        return lowPriority ? requestQueue_1.RequestQueueingType.LowPriority : requestQueue_1.RequestQueueingType.Normal;\r\n    }\r\n}\r\nProcessBasedTsServer.fenceCommands = new Set(['change', 'close', 'open', 'updateOpen']);\r\nexports.ProcessBasedTsServer = ProcessBasedTsServer;\r\nclass SyntaxRoutingTsServer extends dispose_1.Disposable {\r\n    constructor(syntaxServer, semanticServer) {\r\n        super();\r\n        this.syntaxServer = syntaxServer;\r\n        this.semanticServer = semanticServer;\r\n        this._onEvent = this._register(new vscode.EventEmitter());\r\n        this.onEvent = this._onEvent.event;\r\n        this._onExit = this._register(new vscode.EventEmitter());\r\n        this.onExit = this._onExit.event;\r\n        this._onError = this._register(new vscode.EventEmitter());\r\n        this.onError = this._onError.event;\r\n        this._register(syntaxServer.onEvent(e => this._onEvent.fire(e)));\r\n        this._register(semanticServer.onEvent(e => this._onEvent.fire(e)));\r\n        this._register(semanticServer.onExit(e => {\r\n            this._onExit.fire(e);\r\n            this.syntaxServer.kill();\r\n        }));\r\n        this._register(semanticServer.onError(e => this._onError.fire(e)));\r\n    }\r\n    get onReaderError() { return this.semanticServer.onReaderError; }\r\n    get tsServerLogFile() { return this.semanticServer.tsServerLogFile; }\r\n    kill() {\r\n        this.syntaxServer.kill();\r\n        this.semanticServer.kill();\r\n    }\r\n    executeImpl(command, args, executeInfo) {\r\n        if (SyntaxRoutingTsServer.syntaxCommands.has(command)) {\r\n            return this.syntaxServer.executeImpl(command, args, executeInfo);\r\n        }\r\n        else if (SyntaxRoutingTsServer.sharedCommands.has(command)) {\r\n            // Dispatch to both server but only return from syntax one\r\n            // Also make sure we never cancel requests to just one server\r\n            let hasCompletedSyntax = false;\r\n            let hasCompletedSemantic = false;\r\n            let token = undefined;\r\n            if (executeInfo.token) {\r\n                const source = new vscode.CancellationTokenSource();\r\n                executeInfo.token.onCancellationRequested(() => {\r\n                    if (hasCompletedSyntax && !hasCompletedSemantic || hasCompletedSemantic && !hasCompletedSyntax) {\r\n                        // Don't cancel.\r\n                        // One of the servers completed this request so we don't want to leave the other\r\n                        // in a different state\r\n                        return;\r\n                    }\r\n                    source.cancel();\r\n                });\r\n                token = source.token;\r\n            }\r\n            const semanticRequest = this.semanticServer.executeImpl(command, args, { ...executeInfo, token });\r\n            if (semanticRequest) {\r\n                semanticRequest.finally(() => { hasCompletedSemantic = true; });\r\n            }\r\n            const syntaxRequest = this.syntaxServer.executeImpl(command, args, { ...executeInfo, token });\r\n            if (syntaxRequest) {\r\n                syntaxRequest.finally(() => { hasCompletedSyntax = true; });\r\n            }\r\n            return syntaxRequest;\r\n        }\r\n        else {\r\n            return this.semanticServer.executeImpl(command, args, executeInfo);\r\n        }\r\n    }\r\n}\r\nSyntaxRoutingTsServer.syntaxCommands = new Set([\r\n    'navtree',\r\n    'getOutliningSpans',\r\n    'jsxClosingTag',\r\n    'selectionRange',\r\n    'format',\r\n    'formatonkey',\r\n    'docCommentTemplate',\r\n]);\r\nSyntaxRoutingTsServer.sharedCommands = new Set([\r\n    'change',\r\n    'close',\r\n    'open',\r\n    'updateOpen',\r\n    'configure',\r\n    'configurePlugin',\r\n]);\r\nexports.SyntaxRoutingTsServer = SyntaxRoutingTsServer;\r\n//# sourceMappingURL=server.js.map","/typescript-language-features/out/typescriptService.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar ServerResponse;\r\n(function (ServerResponse) {\r\n    class Cancelled {\r\n        constructor(reason) {\r\n            this.reason = reason;\r\n            this.type = 'cancelled';\r\n        }\r\n    }\r\n    ServerResponse.Cancelled = Cancelled;\r\n    ServerResponse.NoContent = new class {\r\n        constructor() {\r\n            this.type = 'noContent';\r\n        }\r\n    };\r\n})(ServerResponse = exports.ServerResponse || (exports.ServerResponse = {}));\r\n//# sourceMappingURL=typescriptService.js.map","/typescript-language-features/out/utils/wireProtocol.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst dispose_1 = require(\"./dispose\");\r\nconst defaultSize = 8192;\r\nconst contentLength = 'Content-Length: ';\r\nconst contentLengthSize = Buffer.byteLength(contentLength, 'utf8');\r\nconst blank = Buffer.from(' ', 'utf8')[0];\r\nconst backslashR = Buffer.from('\\r', 'utf8')[0];\r\nconst backslashN = Buffer.from('\\n', 'utf8')[0];\r\nclass ProtocolBuffer {\r\n    constructor() {\r\n        this.index = 0;\r\n        this.buffer = Buffer.allocUnsafe(defaultSize);\r\n    }\r\n    append(data) {\r\n        let toAppend = null;\r\n        if (Buffer.isBuffer(data)) {\r\n            toAppend = data;\r\n        }\r\n        else {\r\n            toAppend = Buffer.from(data, 'utf8');\r\n        }\r\n        if (this.buffer.length - this.index >= toAppend.length) {\r\n            toAppend.copy(this.buffer, this.index, 0, toAppend.length);\r\n        }\r\n        else {\r\n            let newSize = (Math.ceil((this.index + toAppend.length) / defaultSize) + 1) * defaultSize;\r\n            if (this.index === 0) {\r\n                this.buffer = Buffer.allocUnsafe(newSize);\r\n                toAppend.copy(this.buffer, 0, 0, toAppend.length);\r\n            }\r\n            else {\r\n                this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);\r\n            }\r\n        }\r\n        this.index += toAppend.length;\r\n    }\r\n    tryReadContentLength() {\r\n        let result = -1;\r\n        let current = 0;\r\n        // we are utf8 encoding...\r\n        while (current < this.index && (this.buffer[current] === blank || this.buffer[current] === backslashR || this.buffer[current] === backslashN)) {\r\n            current++;\r\n        }\r\n        if (this.index < current + contentLengthSize) {\r\n            return result;\r\n        }\r\n        current += contentLengthSize;\r\n        let start = current;\r\n        while (current < this.index && this.buffer[current] !== backslashR) {\r\n            current++;\r\n        }\r\n        if (current + 3 >= this.index || this.buffer[current + 1] !== backslashN || this.buffer[current + 2] !== backslashR || this.buffer[current + 3] !== backslashN) {\r\n            return result;\r\n        }\r\n        let data = this.buffer.toString('utf8', start, current);\r\n        result = parseInt(data);\r\n        this.buffer = this.buffer.slice(current + 4);\r\n        this.index = this.index - (current + 4);\r\n        return result;\r\n    }\r\n    tryReadContent(length) {\r\n        if (this.index < length) {\r\n            return null;\r\n        }\r\n        let result = this.buffer.toString('utf8', 0, length);\r\n        let sourceStart = length;\r\n        while (sourceStart < this.index && (this.buffer[sourceStart] === backslashR || this.buffer[sourceStart] === backslashN)) {\r\n            sourceStart++;\r\n        }\r\n        this.buffer.copy(this.buffer, 0, sourceStart);\r\n        this.index = this.index - sourceStart;\r\n        return result;\r\n    }\r\n}\r\nclass Reader extends dispose_1.Disposable {\r\n    constructor(readable) {\r\n        super();\r\n        this.buffer = new ProtocolBuffer();\r\n        this.nextMessageLength = -1;\r\n        this._onError = this._register(new vscode.EventEmitter());\r\n        this.onError = this._onError.event;\r\n        this._onData = this._register(new vscode.EventEmitter());\r\n        this.onData = this._onData.event;\r\n        readable.on('data', data => this.onLengthData(data));\r\n    }\r\n    onLengthData(data) {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n        try {\r\n            this.buffer.append(data);\r\n            while (true) {\r\n                if (this.nextMessageLength === -1) {\r\n                    this.nextMessageLength = this.buffer.tryReadContentLength();\r\n                    if (this.nextMessageLength === -1) {\r\n                        return;\r\n                    }\r\n                }\r\n                const msg = this.buffer.tryReadContent(this.nextMessageLength);\r\n                if (msg === null) {\r\n                    return;\r\n                }\r\n                this.nextMessageLength = -1;\r\n                const json = JSON.parse(msg);\r\n                this._onData.fire(json);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._onError.fire(e);\r\n        }\r\n    }\r\n}\r\nexports.Reader = Reader;\r\n//# sourceMappingURL=wireProtocol.js.map","/typescript-language-features/out/tsServer/callbackMap.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typescriptService_1 = require(\"../typescriptService\");\r\nclass CallbackMap {\r\n    constructor() {\r\n        this._callbacks = new Map();\r\n        this._asyncCallbacks = new Map();\r\n    }\r\n    destroy(cause) {\r\n        const cancellation = new typescriptService_1.ServerResponse.Cancelled(cause);\r\n        for (const callback of this._callbacks.values()) {\r\n            callback.onSuccess(cancellation);\r\n        }\r\n        this._callbacks.clear();\r\n        for (const callback of this._asyncCallbacks.values()) {\r\n            callback.onSuccess(cancellation);\r\n        }\r\n        this._asyncCallbacks.clear();\r\n    }\r\n    add(seq, callback, isAsync) {\r\n        if (isAsync) {\r\n            this._asyncCallbacks.set(seq, callback);\r\n        }\r\n        else {\r\n            this._callbacks.set(seq, callback);\r\n        }\r\n    }\r\n    fetch(seq) {\r\n        const callback = this._callbacks.get(seq) || this._asyncCallbacks.get(seq);\r\n        this.delete(seq);\r\n        return callback;\r\n    }\r\n    delete(seq) {\r\n        if (!this._callbacks.delete(seq)) {\r\n            this._asyncCallbacks.delete(seq);\r\n        }\r\n    }\r\n}\r\nexports.CallbackMap = CallbackMap;\r\n//# sourceMappingURL=callbackMap.js.map","/typescript-language-features/out/tsServer/requestQueue.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar RequestQueueingType;\r\n(function (RequestQueueingType) {\r\n    /**\r\n     * Normal request that is executed in order.\r\n     */\r\n    RequestQueueingType[RequestQueueingType[\"Normal\"] = 1] = \"Normal\";\r\n    /**\r\n     * Request that normal requests jump in front of in the queue.\r\n     */\r\n    RequestQueueingType[RequestQueueingType[\"LowPriority\"] = 2] = \"LowPriority\";\r\n    /**\r\n     * A fence that blocks request reordering.\r\n     *\r\n     * Fences are not reordered. Unlike a normal request, a fence will never jump in front of a low priority request\r\n     * in the request queue.\r\n     */\r\n    RequestQueueingType[RequestQueueingType[\"Fence\"] = 3] = \"Fence\";\r\n})(RequestQueueingType = exports.RequestQueueingType || (exports.RequestQueueingType = {}));\r\nclass RequestQueue {\r\n    constructor() {\r\n        this.queue = [];\r\n        this.sequenceNumber = 0;\r\n    }\r\n    get length() {\r\n        return this.queue.length;\r\n    }\r\n    enqueue(item) {\r\n        if (item.queueingType === RequestQueueingType.Normal) {\r\n            let index = this.queue.length - 1;\r\n            while (index >= 0) {\r\n                if (this.queue[index].queueingType !== RequestQueueingType.LowPriority) {\r\n                    break;\r\n                }\r\n                --index;\r\n            }\r\n            this.queue.splice(index + 1, 0, item);\r\n        }\r\n        else {\r\n            // Only normal priority requests can be reordered. All other requests just go to the end.\r\n            this.queue.push(item);\r\n        }\r\n    }\r\n    dequeue() {\r\n        return this.queue.shift();\r\n    }\r\n    tryDeletePendingRequest(seq) {\r\n        for (let i = 0; i < this.queue.length; i++) {\r\n            if (this.queue[i].request.seq === seq) {\r\n                this.queue.splice(i, 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    createRequest(command, args) {\r\n        return {\r\n            seq: this.sequenceNumber++,\r\n            type: 'request',\r\n            command: command,\r\n            arguments: args\r\n        };\r\n    }\r\n}\r\nexports.RequestQueue = RequestQueue;\r\n//# sourceMappingURL=requestQueue.js.map","/typescript-language-features/out/tsServer/serverError.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst regexp_1 = require(\"../utils/regexp\");\r\nclass TypeScriptServerError extends Error {\r\n    constructor(serverId, version, response, serverMessage, serverStack) {\r\n        super(`<${serverId}> TypeScript Server Error (${version.versionString})\\n${serverMessage}\\n${serverStack}`);\r\n        this.response = response;\r\n        this.serverMessage = serverMessage;\r\n        this.serverStack = serverStack;\r\n    }\r\n    static create(serverId, version, response) {\r\n        const parsedResult = TypeScriptServerError.parseErrorText(version, response);\r\n        return new TypeScriptServerError(serverId, version, response, parsedResult ? parsedResult.message : undefined, parsedResult ? parsedResult.stack : undefined);\r\n    }\r\n    get serverErrorText() { return this.response.message; }\r\n    get serverCommand() { return this.response.command; }\r\n    /**\r\n     * Given a `errorText` from a tsserver request indicating failure in handling a request,\r\n     * prepares a payload for telemetry-logging.\r\n     */\r\n    static parseErrorText(version, response) {\r\n        const errorText = response.message;\r\n        if (errorText) {\r\n            const errorPrefix = 'Error processing request. ';\r\n            if (errorText.startsWith(errorPrefix)) {\r\n                let prefixFreeErrorText = errorText.substr(errorPrefix.length);\r\n                // Prior to https://github.com/microsoft/TypeScript/pull/32785, this error\r\n                // returned and excessively long and detailed list of paths.  Since server-side\r\n                // filtering doesn't have sufficient granularity to drop these specific\r\n                // messages, we sanitize them here.\r\n                if (prefixFreeErrorText.indexOf('Could not find sourceFile') >= 0) {\r\n                    prefixFreeErrorText = prefixFreeErrorText.replace(/ in \\[[^\\]]*\\]/g, '');\r\n                }\r\n                const newlineIndex = prefixFreeErrorText.indexOf('\\n');\r\n                if (newlineIndex >= 0) {\r\n                    // Newline expected between message and stack.\r\n                    return {\r\n                        message: prefixFreeErrorText.substring(0, newlineIndex),\r\n                        stack: TypeScriptServerError.normalizeMessageStack(version, prefixFreeErrorText.substring(newlineIndex + 1))\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * Try to replace full TS Server paths with 'tsserver.js' so that we don't have to post process the data as much\r\n     */\r\n    static normalizeMessageStack(version, message) {\r\n        if (!message) {\r\n            return '';\r\n        }\r\n        return message.replace(new RegExp(`${regexp_1.escapeRegExp(version.path)}[/\\\\\\\\]tsserver.js:`, 'gi'), 'tsserver.js:');\r\n    }\r\n}\r\nexports.TypeScriptServerError = TypeScriptServerError;\r\n//# sourceMappingURL=serverError.js.map","/typescript-language-features/out/utils/regexp.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction escapeRegExp(text) {\r\n    return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\r\n}\r\nexports.escapeRegExp = escapeRegExp;\r\n//# sourceMappingURL=regexp.js.map","/typescript-language-features/out/utils/typingsStatus.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst vscode_nls_1 = require(\"vscode-nls\");\r\nconst dispose_1 = require(\"./dispose\");\r\nconst localize = vscode_nls_1.loadMessageBundle();\r\nconst typingsInstallTimeout = 30 * 1000;\r\nclass TypingsStatus extends dispose_1.Disposable {\r\n    constructor(client) {\r\n        super();\r\n        this._acquiringTypings = Object.create({});\r\n        this._subscriptions = [];\r\n        this._client = client;\r\n        this._subscriptions.push(this._client.onDidBeginInstallTypings(event => this.onBeginInstallTypings(event.eventId)));\r\n        this._subscriptions.push(this._client.onDidEndInstallTypings(event => this.onEndInstallTypings(event.eventId)));\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._subscriptions.forEach(x => x.dispose());\r\n        for (const eventId of Object.keys(this._acquiringTypings)) {\r\n            clearTimeout(this._acquiringTypings[eventId]);\r\n        }\r\n    }\r\n    get isAcquiringTypings() {\r\n        return Object.keys(this._acquiringTypings).length > 0;\r\n    }\r\n    onBeginInstallTypings(eventId) {\r\n        if (this._acquiringTypings[eventId]) {\r\n            return;\r\n        }\r\n        this._acquiringTypings[eventId] = setTimeout(() => {\r\n            this.onEndInstallTypings(eventId);\r\n        }, typingsInstallTimeout);\r\n    }\r\n    onEndInstallTypings(eventId) {\r\n        const timer = this._acquiringTypings[eventId];\r\n        if (timer) {\r\n            clearTimeout(timer);\r\n        }\r\n        delete this._acquiringTypings[eventId];\r\n    }\r\n}\r\nexports.default = TypingsStatus;\r\nclass AtaProgressReporter {\r\n    constructor(client) {\r\n        this._promises = new Map();\r\n        this._disposable = vscode.Disposable.from(client.onDidBeginInstallTypings(e => this._onBegin(e.eventId)), client.onDidEndInstallTypings(e => this._onEndOrTimeout(e.eventId)), client.onTypesInstallerInitializationFailed(_ => this.onTypesInstallerInitializationFailed()));\r\n    }\r\n    dispose() {\r\n        this._disposable.dispose();\r\n        this._promises.forEach(value => value());\r\n    }\r\n    _onBegin(eventId) {\r\n        const handle = setTimeout(() => this._onEndOrTimeout(eventId), typingsInstallTimeout);\r\n        const promise = new Promise(resolve => {\r\n            this._promises.set(eventId, () => {\r\n                clearTimeout(handle);\r\n                resolve();\r\n            });\r\n        });\r\n        vscode.window.withProgress({\r\n            location: vscode.ProgressLocation.Window,\r\n            title: localize('installingPackages', \"Fetching data for better TypeScript IntelliSense\")\r\n        }, () => promise);\r\n    }\r\n    _onEndOrTimeout(eventId) {\r\n        const resolve = this._promises.get(eventId);\r\n        if (resolve) {\r\n            this._promises.delete(eventId);\r\n            resolve();\r\n        }\r\n    }\r\n    onTypesInstallerInitializationFailed() {\r\n        if (vscode.workspace.getConfiguration('typescript').get('check.npmIsInstalled', true)) {\r\n            vscode.window.showWarningMessage(localize('typesInstallerInitializationFailed.title', \"Could not install typings files for JavaScript language features. Please ensure that NPM is installed or configure 'typescript.npm' in your user settings. Click [here]({0}) to learn more.\", 'https://go.microsoft.com/fwlink/?linkid=847635'), {\r\n                title: localize('typesInstallerInitializationFailed.doNotCheckAgain', \"Don't Show Again\"),\r\n                id: 1\r\n            }).then(selected => {\r\n                if (!selected) {\r\n                    return;\r\n                }\r\n                switch (selected.id) {\r\n                    case 1:\r\n                        const tsConfig = vscode.workspace.getConfiguration('typescript');\r\n                        tsConfig.update('check.npmIsInstalled', false, true);\r\n                        break;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nexports.AtaProgressReporter = AtaProgressReporter;\r\n//# sourceMappingURL=typingsStatus.js.map","/typescript-language-features/out/utils/versionStatus.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst languageModeIds = require(\"./languageModeIds\");\r\nconst dispose_1 = require(\"./dispose\");\r\nconst nls = require(\"vscode-nls\");\r\nconst localize = nls.loadMessageBundle();\r\nclass VersionStatus extends dispose_1.Disposable {\r\n    constructor(_normalizePath) {\r\n        super();\r\n        this._normalizePath = _normalizePath;\r\n        this._versionBarEntry = this._register(vscode.window.createStatusBarItem({\r\n            id: 'status.typescript.version',\r\n            name: localize('typescriptVersion', \"TypeScript: Version\"),\r\n            alignment: vscode.StatusBarAlignment.Right,\r\n            priority: 99 /* to the right of editor status (100) */\r\n        }));\r\n        vscode.window.onDidChangeActiveTextEditor(this.showHideStatus, this, this._disposables);\r\n    }\r\n    onDidChangeTypeScriptVersion(version) {\r\n        this.showHideStatus();\r\n        this._versionBarEntry.text = version.versionString;\r\n        this._versionBarEntry.tooltip = version.path;\r\n        this._versionBarEntry.command = 'typescript.selectTypeScriptVersion';\r\n    }\r\n    showHideStatus() {\r\n        if (!vscode.window.activeTextEditor) {\r\n            this._versionBarEntry.hide();\r\n            return;\r\n        }\r\n        const doc = vscode.window.activeTextEditor.document;\r\n        if (vscode.languages.match([languageModeIds.typescript, languageModeIds.typescriptreact], doc)) {\r\n            if (this._normalizePath(doc.uri)) {\r\n                this._versionBarEntry.show();\r\n            }\r\n            else {\r\n                this._versionBarEntry.hide();\r\n            }\r\n            return;\r\n        }\r\n        if (!vscode.window.activeTextEditor.viewColumn) {\r\n            // viewColumn is undefined for the debug/output panel, but we still want\r\n            // to show the version info in the existing editor\r\n            return;\r\n        }\r\n        this._versionBarEntry.hide();\r\n    }\r\n}\r\nexports.default = VersionStatus;\r\n//# sourceMappingURL=versionStatus.js.map","/typescript-language-features/node_modules/rimraf/package.json":"{\n  \"name\": \"rimraf\",\n  \"version\": \"2.6.3\",\n  \"main\": \"rimraf.js\",\n  \"description\": \"A deep deletion module for node (like `rm -rf`)\",\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"license\": \"ISC\",\n  \"repository\": \"git://github.com/isaacs/rimraf.git\",\n  \"scripts\": {\n    \"preversion\": \"npm test\",\n    \"postversion\": \"npm publish\",\n    \"postpublish\": \"git push origin --all; git push origin --tags\",\n    \"test\": \"tap test/*.js\"\n  },\n  \"bin\": \"./bin.js\",\n  \"dependencies\": {\n    \"glob\": \"^7.1.3\"\n  },\n  \"files\": [\n    \"LICENSE\",\n    \"README.md\",\n    \"bin.js\",\n    \"rimraf.js\"\n  ],\n  \"devDependencies\": {\n    \"mkdirp\": \"^0.5.1\",\n    \"tap\": \"^12.1.1\"\n  }\n}\n","/typescript-language-features/node_modules/rimraf/rimraf.js":"module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = require(\"assert\")\nvar path = require(\"path\")\nvar fs = require(\"fs\")\nvar glob = require(\"glob\")\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n","/typescript-language-features/node_modules/rimraf/node_modules/glob/package.json":"{\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"name\": \"glob\",\n  \"description\": \"a little globber\",\n  \"version\": \"7.1.4\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/node-glob.git\"\n  },\n  \"main\": \"glob.js\",\n  \"files\": [\n    \"glob.js\",\n    \"sync.js\",\n    \"common.js\"\n  ],\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"dependencies\": {\n    \"fs.realpath\": \"^1.0.0\",\n    \"inflight\": \"^1.0.4\",\n    \"inherits\": \"2\",\n    \"minimatch\": \"^3.0.4\",\n    \"once\": \"^1.3.0\",\n    \"path-is-absolute\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"mkdirp\": \"0\",\n    \"rimraf\": \"^2.2.8\",\n    \"tap\": \"^12.0.1\",\n    \"tick\": \"0.0.6\"\n  },\n  \"scripts\": {\n    \"prepublish\": \"npm run benchclean\",\n    \"profclean\": \"rm -f v8.log profile.txt\",\n    \"test\": \"tap test/*.js --cov\",\n    \"test-regen\": \"npm run profclean && TEST_REGEN=1 node test/00-setup.js\",\n    \"bench\": \"bash benchmark.sh\",\n    \"prof\": \"bash prof.sh && cat profile.txt\",\n    \"benchclean\": \"node benchclean.js\"\n  },\n  \"license\": \"ISC\"\n}\n","/typescript-language-features/node_modules/rimraf/node_modules/glob/glob.js":"// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar inherits = require('inherits')\nvar EE = require('events').EventEmitter\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar globSync = require('./sync.js')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = require('inflight')\nvar util = require('util')\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = require('once')\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n","/typescript-language-features/node_modules/fs.realpath/package.json":"{\n  \"name\": \"fs.realpath\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Use node's fs.realpath, but fall back to the JS implementation if the native one fails\",\n  \"main\": \"index.js\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"tap test/*.js --cov\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/isaacs/fs.realpath.git\"\n  },\n  \"keywords\": [\n    \"realpath\",\n    \"fs\",\n    \"polyfill\"\n  ],\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"license\": \"ISC\",\n  \"files\": [\n    \"old.js\",\n    \"index.js\"\n  ]\n}\n","/typescript-language-features/node_modules/fs.realpath/index.js":"module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = require('fs')\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = require('./old.js')\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n","/typescript-language-features/node_modules/fs.realpath/old.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = require('path');\nvar isWindows = process.platform === 'win32';\nvar fs = require('fs');\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n","/typescript-language-features/node_modules/minimatch/package.json":"{\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me)\",\n  \"name\": \"minimatch\",\n  \"description\": \"a glob matcher in javascript\",\n  \"version\": \"3.0.4\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/minimatch.git\"\n  },\n  \"main\": \"minimatch.js\",\n  \"scripts\": {\n    \"test\": \"tap test/*.js --cov\",\n    \"preversion\": \"npm test\",\n    \"postversion\": \"npm publish\",\n    \"postpublish\": \"git push origin --all; git push origin --tags\"\n  },\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"dependencies\": {\n    \"brace-expansion\": \"^1.1.7\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^10.3.2\"\n  },\n  \"license\": \"ISC\",\n  \"files\": [\n    \"minimatch.js\"\n  ]\n}\n","/typescript-language-features/node_modules/minimatch/minimatch.js":"module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n","/typescript-language-features/node_modules/brace-expansion/package.json":"{\n  \"name\": \"brace-expansion\",\n  \"description\": \"Brace expansion as known from sh/bash\",\n  \"version\": \"1.1.11\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/juliangruber/brace-expansion.git\"\n  },\n  \"homepage\": \"https://github.com/juliangruber/brace-expansion\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"tape test/*.js\",\n    \"gentest\": \"bash test/generate.sh\",\n    \"bench\": \"matcha test/perf/bench.js\"\n  },\n  \"dependencies\": {\n    \"balanced-match\": \"^1.0.0\",\n    \"concat-map\": \"0.0.1\"\n  },\n  \"devDependencies\": {\n    \"matcha\": \"^0.7.0\",\n    \"tape\": \"^4.6.0\"\n  },\n  \"keywords\": [],\n  \"author\": {\n    \"name\": \"Julian Gruber\",\n    \"email\": \"mail@juliangruber.com\",\n    \"url\": \"http://juliangruber.com\"\n  },\n  \"license\": \"MIT\",\n  \"testling\": {\n    \"files\": \"test/*.js\",\n    \"browsers\": [\n      \"ie/8..latest\",\n      \"firefox/20..latest\",\n      \"firefox/nightly\",\n      \"chrome/25..latest\",\n      \"chrome/canary\",\n      \"opera/12..latest\",\n      \"opera/next\",\n      \"safari/5.1..latest\",\n      \"ipad/6.0..latest\",\n      \"iphone/6.0..latest\",\n      \"android-browser/4.2..latest\"\n    ]\n  }\n}\n","/typescript-language-features/node_modules/brace-expansion/index.js":"var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n","/typescript-language-features/node_modules/concat-map/package.json":"{\n    \"name\" : \"concat-map\",\n    \"description\" : \"concatenative mapdashery\",\n    \"version\" : \"0.0.1\",\n    \"repository\" : {\n        \"type\" : \"git\",\n        \"url\" : \"git://github.com/substack/node-concat-map.git\"\n    },\n    \"main\" : \"index.js\",\n    \"keywords\" : [\n        \"concat\",\n        \"concatMap\",\n        \"map\",\n        \"functional\",\n        \"higher-order\"\n    ],\n    \"directories\" : {\n        \"example\" : \"example\",\n        \"test\" : \"test\"\n    },\n    \"scripts\" : {\n        \"test\" : \"tape test/*.js\"\n    },\n    \"devDependencies\" : {\n        \"tape\" : \"~2.4.0\"\n    },\n    \"license\" : \"MIT\",\n    \"author\" : {\n        \"name\" : \"James Halliday\",\n        \"email\" : \"mail@substack.net\",\n        \"url\" : \"http://substack.net\"\n    },\n    \"testling\" : {\n        \"files\" : \"test/*.js\",\n        \"browsers\" : {\n            \"ie\" : [ 6, 7, 8, 9 ],\n            \"ff\" : [ 3.5, 10, 15.0 ],\n            \"chrome\" : [ 10, 22 ],\n            \"safari\" : [ 5.1 ],\n            \"opera\" : [ 12 ]\n        }\n    }\n}\n","/typescript-language-features/node_modules/concat-map/index.js":"module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","/typescript-language-features/node_modules/balanced-match/package.json":"{\n  \"name\": \"balanced-match\",\n  \"description\": \"Match balanced character pairs, like \\\"{\\\" and \\\"}\\\"\",\n  \"version\": \"1.0.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/juliangruber/balanced-match.git\"\n  },\n  \"homepage\": \"https://github.com/juliangruber/balanced-match\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"make test\",\n    \"bench\": \"make bench\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"matcha\": \"^0.7.0\",\n    \"tape\": \"^4.6.0\"\n  },\n  \"keywords\": [\n    \"match\",\n    \"regexp\",\n    \"test\",\n    \"balanced\",\n    \"parse\"\n  ],\n  \"author\": {\n    \"name\": \"Julian Gruber\",\n    \"email\": \"mail@juliangruber.com\",\n    \"url\": \"http://juliangruber.com\"\n  },\n  \"license\": \"MIT\",\n  \"testling\": {\n    \"files\": \"test/*.js\",\n    \"browsers\": [\n      \"ie/8..latest\",\n      \"firefox/20..latest\",\n      \"firefox/nightly\",\n      \"chrome/25..latest\",\n      \"chrome/canary\",\n      \"opera/12..latest\",\n      \"opera/next\",\n      \"safari/5.1..latest\",\n      \"ipad/6.0..latest\",\n      \"iphone/6.0..latest\",\n      \"android-browser/4.2..latest\"\n    ]\n  }\n}\n","/typescript-language-features/node_modules/balanced-match/index.js":"'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","/typescript-language-features/node_modules/inherits/package.json":"{\n  \"name\": \"inherits\",\n  \"description\": \"Browser-friendly inheritance fully compatible with standard node.js inherits()\",\n  \"version\": \"2.0.3\",\n  \"keywords\": [\n    \"inheritance\",\n    \"class\",\n    \"klass\",\n    \"oop\",\n    \"object-oriented\",\n    \"inherits\",\n    \"browser\",\n    \"browserify\"\n  ],\n  \"main\": \"./inherits.js\",\n  \"browser\": \"./inherits_browser.js\",\n  \"repository\": \"git://github.com/isaacs/inherits\",\n  \"license\": \"ISC\",\n  \"scripts\": {\n    \"test\": \"node test\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^7.1.0\"\n  },\n  \"files\": [\n    \"inherits.js\",\n    \"inherits_browser.js\"\n  ]\n}\n","/typescript-language-features/node_modules/inherits/inherits.js":"try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","/typescript-language-features/node_modules/path-is-absolute/package.json":"{\n  \"name\": \"path-is-absolute\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Node.js 0.12 path.isAbsolute() ponyfill\",\n  \"license\": \"MIT\",\n  \"repository\": \"sindresorhus/path-is-absolute\",\n  \"author\": {\n    \"name\": \"Sindre Sorhus\",\n    \"email\": \"sindresorhus@gmail.com\",\n    \"url\": \"sindresorhus.com\"\n  },\n  \"engines\": {\n    \"node\": \">=0.10.0\"\n  },\n  \"scripts\": {\n    \"test\": \"xo && node test.js\"\n  },\n  \"files\": [\n    \"index.js\"\n  ],\n  \"keywords\": [\n    \"path\",\n    \"paths\",\n    \"file\",\n    \"dir\",\n    \"absolute\",\n    \"isabsolute\",\n    \"is-absolute\",\n    \"built-in\",\n    \"util\",\n    \"utils\",\n    \"core\",\n    \"ponyfill\",\n    \"polyfill\",\n    \"shim\",\n    \"is\",\n    \"detect\",\n    \"check\"\n  ],\n  \"devDependencies\": {\n    \"xo\": \"^0.16.0\"\n  }\n}\n","/typescript-language-features/node_modules/path-is-absolute/index.js":"'use strict';\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n","/typescript-language-features/node_modules/rimraf/node_modules/glob/sync.js":"module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar fs = require('fs')\nvar rp = require('fs.realpath')\nvar minimatch = require('minimatch')\nvar Minimatch = minimatch.Minimatch\nvar Glob = require('./glob.js').Glob\nvar util = require('util')\nvar path = require('path')\nvar assert = require('assert')\nvar isAbsolute = require('path-is-absolute')\nvar common = require('./common.js')\nvar alphasort = common.alphasort\nvar alphasorti = common.alphasorti\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n","/typescript-language-features/node_modules/rimraf/node_modules/glob/common.js":"exports.alphasort = alphasort\nexports.alphasorti = alphasorti\nexports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar path = require(\"path\")\nvar minimatch = require(\"minimatch\")\nvar isAbsolute = require(\"path-is-absolute\")\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasorti (a, b) {\n  return a.toLowerCase().localeCompare(b.toLowerCase())\n}\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b)\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(self.nocase ? alphasorti : alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n","/typescript-language-features/node_modules/inflight/package.json":"{\n  \"name\": \"inflight\",\n  \"version\": \"1.0.6\",\n  \"description\": \"Add callbacks to requests in flight to avoid async duplication\",\n  \"main\": \"inflight.js\",\n  \"files\": [\n    \"inflight.js\"\n  ],\n  \"dependencies\": {\n    \"once\": \"^1.3.0\",\n    \"wrappy\": \"1\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^7.1.2\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test.js --100\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/npm/inflight.git\"\n  },\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"bugs\": {\n    \"url\": \"https://github.com/isaacs/inflight/issues\"\n  },\n  \"homepage\": \"https://github.com/isaacs/inflight\",\n  \"license\": \"ISC\"\n}\n","/typescript-language-features/node_modules/inflight/inflight.js":"var wrappy = require('wrappy')\nvar reqs = Object.create(null)\nvar once = require('once')\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n","/typescript-language-features/node_modules/wrappy/package.json":"{\n  \"name\": \"wrappy\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Callback wrapping utility\",\n  \"main\": \"wrappy.js\",\n  \"files\": [\n    \"wrappy.js\"\n  ],\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"tap\": \"^2.3.1\"\n  },\n  \"scripts\": {\n    \"test\": \"tap --coverage test/*.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/npm/wrappy\"\n  },\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/npm/wrappy/issues\"\n  },\n  \"homepage\": \"https://github.com/npm/wrappy\"\n}\n","/typescript-language-features/node_modules/wrappy/wrappy.js":"// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","/typescript-language-features/node_modules/once/package.json":"{\n  \"name\": \"once\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Run a function exactly one time\",\n  \"main\": \"once.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"dependencies\": {\n    \"wrappy\": \"1\"\n  },\n  \"devDependencies\": {\n    \"tap\": \"^7.0.1\"\n  },\n  \"scripts\": {\n    \"test\": \"tap test/*.js\"\n  },\n  \"files\": [\n    \"once.js\"\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/isaacs/once\"\n  },\n  \"keywords\": [\n    \"once\",\n    \"function\",\n    \"one\",\n    \"single\"\n  ],\n  \"author\": \"Isaac Z. Schlueter <i@izs.me> (http://blog.izs.me/)\",\n  \"license\": \"ISC\"\n}\n","/typescript-language-features/node_modules/once/once.js":"var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/typescript-language-features/out/utils/commandManager.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nclass CommandManager {\r\n    constructor() {\r\n        this.commands = new Map();\r\n    }\r\n    dispose() {\r\n        for (const registration of this.commands.values()) {\r\n            registration.dispose();\r\n        }\r\n        this.commands.clear();\r\n    }\r\n    register(command) {\r\n        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {\r\n            this.registerCommand(id, command.execute, command);\r\n        }\r\n        return command;\r\n    }\r\n    registerCommand(id, impl, thisArg) {\r\n        if (this.commands.has(id)) {\r\n            return;\r\n        }\r\n        this.commands.set(id, vscode.commands.registerCommand(id, impl, thisArg));\r\n    }\r\n}\r\nexports.CommandManager = CommandManager;\r\n//# sourceMappingURL=commandManager.js.map","/typescript-language-features/out/utils/languageDescription.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path_1 = require(\"path\");\r\nconst languageModeIds = require(\"./languageModeIds\");\r\nexports.allDiagnosticLanguages = [0 /* JavaScript */, 1 /* TypeScript */];\r\nexports.standardLanguageDescriptions = [\r\n    {\r\n        id: 'typescript',\r\n        diagnosticOwner: 'typescript',\r\n        diagnosticSource: 'ts',\r\n        diagnosticLanguage: 1 /* TypeScript */,\r\n        modeIds: [languageModeIds.typescript, languageModeIds.typescriptreact],\r\n        configFilePattern: /^tsconfig(\\..*)?\\.json$/gi\r\n    }, {\r\n        id: 'javascript',\r\n        diagnosticOwner: 'typescript',\r\n        diagnosticSource: 'ts',\r\n        diagnosticLanguage: 0 /* JavaScript */,\r\n        modeIds: [languageModeIds.javascript, languageModeIds.javascriptreact],\r\n        configFilePattern: /^jsconfig(\\..*)?\\.json$/gi\r\n    }\r\n];\r\nfunction isTsConfigFileName(fileName) {\r\n    return /^tsconfig\\.(.+\\.)?json$/i.test(path_1.basename(fileName));\r\n}\r\nexports.isTsConfigFileName = isTsConfigFileName;\r\nfunction isJsConfigOrTsConfigFileName(fileName) {\r\n    return /^[jt]sconfig\\.(.+\\.)?json$/i.test(path_1.basename(fileName));\r\n}\r\nexports.isJsConfigOrTsConfigFileName = isJsConfigOrTsConfigFileName;\r\n//# sourceMappingURL=languageDescription.js.map","/typescript-language-features/out/utils/lazy.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass LazyValue {\r\n    constructor(_getValue) {\r\n        this._getValue = _getValue;\r\n        this._hasValue = false;\r\n    }\r\n    get value() {\r\n        if (!this._hasValue) {\r\n            this._hasValue = true;\r\n            this._value = this._getValue();\r\n        }\r\n        return this._value;\r\n    }\r\n    get hasValue() {\r\n        return this._hasValue;\r\n    }\r\n    map(f) {\r\n        return new LazyValue(() => f(this.value));\r\n    }\r\n}\r\nfunction lazy(getValue) {\r\n    return new LazyValue(getValue);\r\n}\r\nexports.lazy = lazy;\r\n//# sourceMappingURL=lazy.js.map","/typescript-language-features/out/utils/logDirectoryProvider.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst memoize_1 = require(\"./memoize\");\r\nclass LogDirectoryProvider {\r\n    constructor(context) {\r\n        this.context = context;\r\n    }\r\n    getNewLogDirectory() {\r\n        const root = this.logDirectory();\r\n        if (root) {\r\n            try {\r\n                return fs.mkdtempSync(path.join(root, `tsserver-log-`));\r\n            }\r\n            catch (e) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    logDirectory() {\r\n        try {\r\n            const path = this.context.logPath;\r\n            if (!fs.existsSync(path)) {\r\n                fs.mkdirSync(path);\r\n            }\r\n            return this.context.logPath;\r\n        }\r\n        catch (_a) {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], LogDirectoryProvider.prototype, \"logDirectory\", null);\r\nexports.default = LogDirectoryProvider;\r\n//# sourceMappingURL=logDirectoryProvider.js.map","/typescript-language-features/out/utils/managedFileContext.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst dispose_1 = require(\"./dispose\");\r\nconst languageDescription_1 = require(\"./languageDescription\");\r\nconst languageModeIds_1 = require(\"./languageModeIds\");\r\n/**\r\n * When clause context set when the current file is managed by vscode's built-in typescript extension.\r\n */\r\nclass ManagedFileContextManager extends dispose_1.Disposable {\r\n    constructor(normalizePath) {\r\n        super();\r\n        this.normalizePath = normalizePath;\r\n        this.isInManagedFileContext = false;\r\n        vscode.window.onDidChangeActiveTextEditor(this.onDidChangeActiveTextEditor, this, this._disposables);\r\n        this.onDidChangeActiveTextEditor(vscode.window.activeTextEditor);\r\n    }\r\n    onDidChangeActiveTextEditor(editor) {\r\n        if (editor) {\r\n            this.updateContext(this.isManagedFile(editor));\r\n        }\r\n    }\r\n    updateContext(newValue) {\r\n        if (newValue === this.isInManagedFileContext) {\r\n            return;\r\n        }\r\n        vscode.commands.executeCommand('setContext', ManagedFileContextManager.contextName, newValue);\r\n        this.isInManagedFileContext = newValue;\r\n    }\r\n    isManagedFile(editor) {\r\n        return this.isManagedScriptFile(editor) || this.isManagedConfigFile(editor);\r\n    }\r\n    isManagedScriptFile(editor) {\r\n        return languageModeIds_1.isSupportedLanguageMode(editor.document) && this.normalizePath(editor.document.uri) !== null;\r\n    }\r\n    isManagedConfigFile(editor) {\r\n        return languageDescription_1.isJsConfigOrTsConfigFileName(editor.document.fileName);\r\n    }\r\n}\r\nManagedFileContextManager.contextName = 'typescript.isManagedFile';\r\nexports.default = ManagedFileContextManager;\r\n//# sourceMappingURL=managedFileContext.js.map","/typescript-language-features/out/utils/plugins.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst arrays = require(\"./arrays\");\r\nconst dispose_1 = require(\"./dispose\");\r\nvar TypeScriptServerPlugin;\r\n(function (TypeScriptServerPlugin) {\r\n    function equals(a, b) {\r\n        return a.path === b.path\r\n            && a.name === b.name\r\n            && a.enableForWorkspaceTypeScriptVersions === b.enableForWorkspaceTypeScriptVersions\r\n            && arrays.equals(a.languages, b.languages);\r\n    }\r\n    TypeScriptServerPlugin.equals = equals;\r\n})(TypeScriptServerPlugin || (TypeScriptServerPlugin = {}));\r\nclass PluginManager extends dispose_1.Disposable {\r\n    constructor() {\r\n        super();\r\n        this._pluginConfigurations = new Map();\r\n        this._onDidUpdatePlugins = this._register(new vscode.EventEmitter());\r\n        this.onDidChangePlugins = this._onDidUpdatePlugins.event;\r\n        this._onDidUpdateConfig = this._register(new vscode.EventEmitter());\r\n        this.onDidUpdateConfig = this._onDidUpdateConfig.event;\r\n        vscode.extensions.onDidChange(() => {\r\n            if (!this._plugins) {\r\n                return;\r\n            }\r\n            const newPlugins = this.readPlugins();\r\n            if (!arrays.equals(arrays.flatten(Array.from(this._plugins.values())), arrays.flatten(Array.from(newPlugins.values())), TypeScriptServerPlugin.equals)) {\r\n                this._plugins = newPlugins;\r\n                this._onDidUpdatePlugins.fire(this);\r\n            }\r\n        }, undefined, this._disposables);\r\n    }\r\n    get plugins() {\r\n        if (!this._plugins) {\r\n            this._plugins = this.readPlugins();\r\n        }\r\n        return arrays.flatten(Array.from(this._plugins.values()));\r\n    }\r\n    setConfiguration(pluginId, config) {\r\n        this._pluginConfigurations.set(pluginId, config);\r\n        this._onDidUpdateConfig.fire({ pluginId, config });\r\n    }\r\n    configurations() {\r\n        return this._pluginConfigurations.entries();\r\n    }\r\n    readPlugins() {\r\n        const pluginMap = new Map();\r\n        for (const extension of vscode.extensions.all) {\r\n            const pack = extension.packageJSON;\r\n            if (pack.contributes && Array.isArray(pack.contributes.typescriptServerPlugins)) {\r\n                const plugins = [];\r\n                for (const plugin of pack.contributes.typescriptServerPlugins) {\r\n                    plugins.push({\r\n                        name: plugin.name,\r\n                        enableForWorkspaceTypeScriptVersions: !!plugin.enableForWorkspaceTypeScriptVersions,\r\n                        path: extension.extensionPath,\r\n                        languages: Array.isArray(plugin.languages) ? plugin.languages : [],\r\n                    });\r\n                }\r\n                if (plugins.length) {\r\n                    pluginMap.set(extension.id, plugins);\r\n                }\r\n            }\r\n        }\r\n        return pluginMap;\r\n    }\r\n}\r\nexports.PluginManager = PluginManager;\r\n//# sourceMappingURL=plugins.js.map","/typescript-language-features/out/utils/projectStatus.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst vscode_nls_1 = require(\"vscode-nls\");\r\nconst tsconfig_1 = require(\"./tsconfig\");\r\nconst localize = vscode_nls_1.loadMessageBundle();\r\nclass ExcludeHintItem {\r\n    constructor(telemetryReporter) {\r\n        this.telemetryReporter = telemetryReporter;\r\n        this._item = vscode.window.createStatusBarItem({\r\n            id: 'status.typescript.exclude',\r\n            name: localize('statusExclude', \"TypeScript: Configure Excludes\"),\r\n            alignment: vscode.StatusBarAlignment.Right,\r\n            priority: 98 /* to the right of typescript version status (99) */\r\n        });\r\n        this._item.command = 'js.projectStatus.command';\r\n    }\r\n    getCurrentHint() {\r\n        return this._currentHint;\r\n    }\r\n    hide() {\r\n        this._item.hide();\r\n    }\r\n    show(largeRoots) {\r\n        this._currentHint = {\r\n            message: largeRoots\r\n                ? localize('hintExclude', \"To enable project-wide JavaScript/TypeScript language features, exclude folders with many files, like: {0}\", largeRoots)\r\n                : localize('hintExclude.generic', \"To enable project-wide JavaScript/TypeScript language features, exclude large folders with source files that you do not work on.\")\r\n        };\r\n        this._item.tooltip = this._currentHint.message;\r\n        this._item.text = localize('large.label', \"Configure Excludes\");\r\n        this._item.tooltip = localize('hintExclude.tooltip', \"To enable project-wide JavaScript/TypeScript language features, exclude large folders with source files that you do not work on.\");\r\n        this._item.color = '#A5DF3B';\r\n        this._item.show();\r\n        /* __GDPR__\r\n            \"js.hintProjectExcludes\" : {\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        this.telemetryReporter.logTelemetry('js.hintProjectExcludes');\r\n    }\r\n}\r\nfunction createLargeProjectMonitorFromTypeScript(item, client) {\r\n    return client.onProjectLanguageServiceStateChanged(body => {\r\n        if (body.languageServiceEnabled) {\r\n            item.hide();\r\n        }\r\n        else {\r\n            item.show();\r\n            const configFileName = body.projectName;\r\n            if (configFileName) {\r\n                item.configFileName = configFileName;\r\n                vscode.window.showWarningMessage(item.getCurrentHint().message, {\r\n                    title: localize('large.label', \"Configure Excludes\"),\r\n                    index: 0\r\n                }).then(selected => {\r\n                    if (selected && selected.index === 0) {\r\n                        onConfigureExcludesSelected(client, configFileName);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction onConfigureExcludesSelected(client, configFileName) {\r\n    if (!tsconfig_1.isImplicitProjectConfigFile(configFileName)) {\r\n        vscode.workspace.openTextDocument(configFileName)\r\n            .then(vscode.window.showTextDocument);\r\n    }\r\n    else {\r\n        const root = client.getWorkspaceRootForResource(vscode.Uri.file(configFileName));\r\n        if (root) {\r\n            tsconfig_1.openOrCreateConfigFile(configFileName.match(/tsconfig\\.?.*\\.json/) !== null, root, client.configuration);\r\n        }\r\n    }\r\n}\r\nfunction create(client, telemetryReporter) {\r\n    const toDispose = [];\r\n    const item = new ExcludeHintItem(telemetryReporter);\r\n    toDispose.push(vscode.commands.registerCommand('js.projectStatus.command', () => {\r\n        if (item.configFileName) {\r\n            onConfigureExcludesSelected(client, item.configFileName);\r\n        }\r\n        let { message } = item.getCurrentHint();\r\n        return vscode.window.showInformationMessage(message);\r\n    }));\r\n    toDispose.push(createLargeProjectMonitorFromTypeScript(item, client));\r\n    return vscode.Disposable.from(...toDispose);\r\n}\r\nexports.create = create;\r\n//# sourceMappingURL=projectStatus.js.map","/typescript-language-features/out/utils/surveyor.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst dispose_1 = require(\"./dispose\");\r\nconst memoize_1 = require(\"./memoize\");\r\nconst localize = nls.loadMessageBundle();\r\nconst allSurveys = [\r\n    {\r\n        id: 'checkJs',\r\n        prompt: localize('survey.checkJs.prompt', \"Help improve VS Code's support for [checkJs](https://code.visualstudio.com/Docs/languages/javascript#_type-checking) in JavaScript! Since you have been using this feature, would you consider taking a short survey about your experience?\"),\r\n        globalTriggerThreshold: 10,\r\n        url: vscode.Uri.parse('https://www.surveymonkey.com/r/FH8PZQ3'),\r\n        remindLaterDelayInMilliseconds: 3 * 24 * 60 * 60 * 1000 // 3 days\r\n    }\r\n];\r\nclass Survey {\r\n    constructor(data, memento) {\r\n        this.data = data;\r\n        this.memento = memento;\r\n        this._hasShownInThisSession = false;\r\n    }\r\n    get id() { return this.data.id; }\r\n    get prompt() { return this.data.prompt; }\r\n    get isActive() {\r\n        return !this._hasShownInThisSession && !this.memento.get(this.isCompletedMementoKey);\r\n    }\r\n    open() {\r\n        this.markComplete();\r\n        vscode.commands.executeCommand('vscode.open', this.data.url);\r\n    }\r\n    remindLater() {\r\n        // Make sure we don't show again in this session (but don't persist as completed)\r\n        this._hasShownInThisSession = true;\r\n        // And save off prompt time.\r\n        this.memento.update(this.lastPromptTimeMementoKey, Date.now());\r\n    }\r\n    trigger() {\r\n        const triggerCount = this.triggerCount + 1;\r\n        this.memento.update(this.triggerCountMementoKey, triggerCount);\r\n        if (triggerCount >= this.data.globalTriggerThreshold) {\r\n            const lastPromptTime = this.memento.get(this.lastPromptTimeMementoKey);\r\n            if (!lastPromptTime || isNaN(+lastPromptTime)) {\r\n                return true;\r\n            }\r\n            return (lastPromptTime + this.data.remindLaterDelayInMilliseconds < Date.now());\r\n        }\r\n        return false;\r\n    }\r\n    willShow() {\r\n        this._hasShownInThisSession = true;\r\n    }\r\n    markComplete() {\r\n        this._hasShownInThisSession = true;\r\n        this.memento.update(this.isCompletedMementoKey, true);\r\n    }\r\n    get triggerCount() {\r\n        const count = this.memento.get(this.triggerCountMementoKey);\r\n        return !count || isNaN(+count) ? 0 : +count;\r\n    }\r\n    getMementoKey(part) {\r\n        return `survey.v0.${this.id}.${part}`;\r\n    }\r\n    get isCompletedMementoKey() {\r\n        return this.getMementoKey('isComplete');\r\n    }\r\n    get lastPromptTimeMementoKey() {\r\n        return this.getMementoKey('lastPromptTime');\r\n    }\r\n    get triggerCountMementoKey() {\r\n        return this.getMementoKey('globalTriggerCount');\r\n    }\r\n}\r\nclass Surveyor extends dispose_1.Disposable {\r\n    constructor(memento, serviceClient) {\r\n        super();\r\n        this.memento = memento;\r\n        this._register(serviceClient.onSurveyReady(e => this.surveyReady(e.surveyId)));\r\n    }\r\n    get surveys() {\r\n        return new Map(allSurveys.map(data => [data.id, new Survey(data, this.memento)]));\r\n    }\r\n    surveyReady(surveyId) {\r\n        const survey = this.tryGetActiveSurvey(surveyId);\r\n        if (survey && survey.trigger()) {\r\n            survey.willShow();\r\n            this.showSurveyToUser(survey);\r\n        }\r\n    }\r\n    async showSurveyToUser(survey) {\r\n        let Choice;\r\n        (function (Choice) {\r\n            Choice[Choice[\"GoToSurvey\"] = 1] = \"GoToSurvey\";\r\n            Choice[Choice[\"RemindLater\"] = 2] = \"RemindLater\";\r\n            Choice[Choice[\"NeverAgain\"] = 3] = \"NeverAgain\";\r\n        })(Choice || (Choice = {}));\r\n        const response = await vscode.window.showInformationMessage(survey.prompt, {\r\n            title: localize('takeShortSurvey', \"Take Short Survey\"),\r\n            choice: Choice.GoToSurvey\r\n        }, {\r\n            title: localize('remindLater', \"Remind Me Later\"),\r\n            choice: Choice.RemindLater\r\n        }, {\r\n            title: localize('neverAgain', \"Disable JS/TS Surveys\"),\r\n            choice: Choice.NeverAgain\r\n        });\r\n        switch (response && response.choice) {\r\n            case Choice.GoToSurvey:\r\n                survey.open();\r\n                break;\r\n            case Choice.NeverAgain:\r\n                survey.markComplete();\r\n                this.disableSurveys();\r\n                break;\r\n            case Choice.RemindLater:\r\n            default: // If user just closes the notification, treat this as a remind later.\r\n                survey.remindLater();\r\n                break;\r\n        }\r\n    }\r\n    tryGetActiveSurvey(surveyId) {\r\n        const survey = this.surveys.get(surveyId);\r\n        if (!survey) {\r\n            return undefined;\r\n        }\r\n        if (this.areSurveysEnabled() && survey.isActive) {\r\n            return survey;\r\n        }\r\n        return undefined;\r\n    }\r\n    areSurveysEnabled() {\r\n        const config = vscode.workspace.getConfiguration('typescript');\r\n        return config.get('surveys.enabled', true);\r\n    }\r\n    disableSurveys() {\r\n        const config = vscode.workspace.getConfiguration('typescript');\r\n        config.update('surveys.enabled', false);\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], Surveyor.prototype, \"surveys\", null);\r\nexports.Surveyor = Surveyor;\r\n//# sourceMappingURL=surveyor.js.map","/typescript-language-features/out/features/task.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst jsonc = require(\"jsonc-parser\");\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst languageDescription_1 = require(\"../utils/languageDescription\");\r\nconst tsconfig_1 = require(\"../utils/tsconfig\");\r\nconst tsconfigProvider_1 = require(\"../utils/tsconfigProvider\");\r\nconst localize = nls.loadMessageBundle();\r\nconst exists = (file) => new Promise((resolve, _reject) => {\r\n    fs.exists(file, (value) => {\r\n        resolve(value);\r\n    });\r\n});\r\n/**\r\n * Provides tasks for building `tsconfig.json` files in a project.\r\n */\r\nclass TscTaskProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n        this.autoDetect = 'on';\r\n        this.disposables = [];\r\n        this.tsconfigProvider = new tsconfigProvider_1.default();\r\n        vscode.workspace.onDidChangeConfiguration(this.onConfigurationChanged, this, this.disposables);\r\n        this.onConfigurationChanged();\r\n    }\r\n    dispose() {\r\n        this.disposables.forEach(x => x.dispose());\r\n    }\r\n    async provideTasks(token) {\r\n        const folders = vscode.workspace.workspaceFolders;\r\n        if ((this.autoDetect === 'off') || !folders || !folders.length) {\r\n            return [];\r\n        }\r\n        const configPaths = new Set();\r\n        const tasks = [];\r\n        for (const project of await this.getAllTsConfigs(token)) {\r\n            if (!configPaths.has(project.path)) {\r\n                configPaths.add(project.path);\r\n                tasks.push(...(await this.getTasksForProject(project)));\r\n            }\r\n        }\r\n        return tasks;\r\n    }\r\n    async resolveTask(_task) {\r\n        const definition = _task.definition;\r\n        const badTsconfig = /\\\\tsconfig.*\\.json/;\r\n        if (badTsconfig.exec(definition.tsconfig) !== null) {\r\n            // Warn that the task has the wrong slash type\r\n            vscode.window.showWarningMessage(localize('badTsConfig', \"Typescript Task in tasks.json contains \\\"\\\\\\\\\\\". Typescript tasks tsconfig must use \\\"/\\\"\"));\r\n            return undefined;\r\n        }\r\n        const typescriptTask = _task.definition.tsconfig;\r\n        if (typescriptTask) {\r\n            if (_task.scope === undefined || _task.scope === vscode.TaskScope.Global || _task.scope === vscode.TaskScope.Workspace) {\r\n                // scope is required to be a WorkspaceFolder for resolveTask\r\n                return undefined;\r\n            }\r\n            const kind = _task.definition;\r\n            const tsconfigUri = _task.scope.uri.with({ path: _task.scope.uri.path + '/' + kind.tsconfig });\r\n            const tsconfig = {\r\n                path: tsconfigUri.fsPath,\r\n                posixPath: tsconfigUri.path,\r\n                workspaceFolder: _task.scope\r\n            };\r\n            return this.getTasksForProjectAndDefinition(tsconfig, kind);\r\n        }\r\n        return undefined;\r\n    }\r\n    async getAllTsConfigs(token) {\r\n        const out = new Set();\r\n        const configs = [\r\n            ...await this.getTsConfigForActiveFile(token),\r\n            ...await this.getTsConfigsInWorkspace()\r\n        ];\r\n        for (const config of configs) {\r\n            if (await exists(config.path)) {\r\n                out.add(config);\r\n            }\r\n        }\r\n        return Array.from(out);\r\n    }\r\n    async getTsConfigForActiveFile(token) {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor) {\r\n            if (languageDescription_1.isTsConfigFileName(editor.document.fileName)) {\r\n                const uri = editor.document.uri;\r\n                return [{\r\n                        path: uri.fsPath,\r\n                        posixPath: uri.path,\r\n                        workspaceFolder: vscode.workspace.getWorkspaceFolder(uri)\r\n                    }];\r\n            }\r\n        }\r\n        const file = this.getActiveTypeScriptFile();\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        const response = await this.client.value.execute('projectInfo', { file, needFileNameList: false }, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return [];\r\n        }\r\n        const { configFileName } = response.body;\r\n        if (configFileName && !tsconfig_1.isImplicitProjectConfigFile(configFileName)) {\r\n            const normalizedConfigPath = path.normalize(configFileName);\r\n            const uri = vscode.Uri.file(normalizedConfigPath);\r\n            const folder = vscode.workspace.getWorkspaceFolder(uri);\r\n            return [{\r\n                    path: normalizedConfigPath,\r\n                    posixPath: uri.path,\r\n                    workspaceFolder: folder\r\n                }];\r\n        }\r\n        return [];\r\n    }\r\n    async getTsConfigsInWorkspace() {\r\n        return Array.from(await this.tsconfigProvider.getConfigsForWorkspace());\r\n    }\r\n    static async getCommand(project) {\r\n        if (project.workspaceFolder) {\r\n            const localTsc = await TscTaskProvider.getLocalTscAtPath(path.dirname(project.path));\r\n            if (localTsc) {\r\n                return localTsc;\r\n            }\r\n            const workspaceTsc = await TscTaskProvider.getLocalTscAtPath(project.workspaceFolder.uri.fsPath);\r\n            if (workspaceTsc) {\r\n                return workspaceTsc;\r\n            }\r\n        }\r\n        // Use global tsc version\r\n        return 'tsc';\r\n    }\r\n    static async getLocalTscAtPath(folderPath) {\r\n        const platform = process.platform;\r\n        const bin = path.join(folderPath, 'node_modules', '.bin');\r\n        if (platform === 'win32' && await exists(path.join(bin, 'tsc.cmd'))) {\r\n            return path.join(bin, 'tsc.cmd');\r\n        }\r\n        else if ((platform === 'linux' || platform === 'darwin') && await exists(path.join(bin, 'tsc'))) {\r\n            return path.join(bin, 'tsc');\r\n        }\r\n        return undefined;\r\n    }\r\n    getActiveTypeScriptFile() {\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor) {\r\n            const document = editor.document;\r\n            if (document && (document.languageId === 'typescript' || document.languageId === 'typescriptreact')) {\r\n                return this.client.value.toPath(document.uri);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    getBuildTask(workspaceFolder, label, command, args, buildTaskidentifier) {\r\n        const buildTask = new vscode.Task(buildTaskidentifier, workspaceFolder || vscode.TaskScope.Workspace, localize('buildTscLabel', 'build - {0}', label), 'tsc', new vscode.ShellExecution(command, args), '$tsc');\r\n        buildTask.group = vscode.TaskGroup.Build;\r\n        buildTask.isBackground = false;\r\n        return buildTask;\r\n    }\r\n    getWatchTask(workspaceFolder, label, command, args, watchTaskidentifier) {\r\n        const watchTask = new vscode.Task(watchTaskidentifier, workspaceFolder || vscode.TaskScope.Workspace, localize('buildAndWatchTscLabel', 'watch - {0}', label), 'tsc', new vscode.ShellExecution(command, [...args, '--watch']), '$tsc-watch');\r\n        watchTask.group = vscode.TaskGroup.Build;\r\n        watchTask.isBackground = true;\r\n        return watchTask;\r\n    }\r\n    async getTasksForProject(project) {\r\n        const command = await TscTaskProvider.getCommand(project);\r\n        const args = await this.getBuildShellArgs(project);\r\n        const label = this.getLabelForTasks(project);\r\n        const tasks = [];\r\n        if (this.autoDetect === 'build' || this.autoDetect === 'on') {\r\n            tasks.push(this.getBuildTask(project.workspaceFolder, label, command, args, { type: 'typescript', tsconfig: label }));\r\n        }\r\n        if (this.autoDetect === 'watch' || this.autoDetect === 'on') {\r\n            tasks.push(this.getWatchTask(project.workspaceFolder, label, command, args, { type: 'typescript', tsconfig: label, option: 'watch' }));\r\n        }\r\n        return tasks;\r\n    }\r\n    async getTasksForProjectAndDefinition(project, definition) {\r\n        const command = await TscTaskProvider.getCommand(project);\r\n        const args = await this.getBuildShellArgs(project);\r\n        const label = this.getLabelForTasks(project);\r\n        let task;\r\n        if (definition.option === undefined) {\r\n            task = this.getBuildTask(project.workspaceFolder, label, command, args, definition);\r\n        }\r\n        else if (definition.option === 'watch') {\r\n            task = this.getWatchTask(project.workspaceFolder, label, command, args, definition);\r\n        }\r\n        return task;\r\n    }\r\n    getBuildShellArgs(project) {\r\n        const defaultArgs = ['-p', project.path];\r\n        return new Promise((resolve) => {\r\n            fs.readFile(project.path, (error, result) => {\r\n                if (error) {\r\n                    return resolve(defaultArgs);\r\n                }\r\n                try {\r\n                    const tsconfig = jsonc.parse(result.toString());\r\n                    if (tsconfig.references) {\r\n                        return resolve(['-b', project.path]);\r\n                    }\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n                return resolve(defaultArgs);\r\n            });\r\n        });\r\n    }\r\n    getLabelForTasks(project) {\r\n        if (project.workspaceFolder) {\r\n            const workspaceNormalizedUri = vscode.Uri.file(path.normalize(project.workspaceFolder.uri.fsPath)); // Make sure the drive letter is lowercase\r\n            return path.posix.relative(workspaceNormalizedUri.path, project.posixPath);\r\n        }\r\n        return project.posixPath;\r\n    }\r\n    onConfigurationChanged() {\r\n        const type = vscode.workspace.getConfiguration('typescript.tsc').get('autoDetect');\r\n        this.autoDetect = typeof type === 'undefined' ? 'on' : type;\r\n    }\r\n}\r\nexports.default = TscTaskProvider;\r\n//# sourceMappingURL=task.js.map","/typescript-language-features/node_modules/jsonc-parser/package.json":"{\n  \"name\": \"jsonc-parser\",\n  \"version\": \"2.1.1\",\n  \"description\": \"Scanner and parser for JSON with comments.\",\n  \"main\": \"./lib/umd/main.js\",\n  \"typings\": \"./lib/umd/main\",\n  \"module\": \"./lib/esm/main.js\",\n  \"author\": \"Microsoft Corporation\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/Microsoft/node-jsonc-parser\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/Microsoft/node-jsonc-parser/issues\"\n  },\n  \"devDependencies\": {\n    \"mocha\": \"^6.2.0\",\n    \"typescript\": \"^3.5.3\",\n    \"@types/node\": \"^10.12.12\",\n    \"@types/mocha\": \"^5.2.7\",\n    \"tslint\": \"^5.19.0\",\n    \"rimraf\": \"^3.0.0\"\n  },\n  \"scripts\": {\n    \"prepublishOnly\": \"npm run clean && npm run compile-esm && npm run test\",\n    \"postpublish\": \"node ./build/post-publish.js\",\n    \"compile\": \"tsc -p ./src\",\n    \"compile-esm\": \"tsc -p ./src/tsconfig.esm.json\",\n    \"clean\": \"rimraf lib\",\n    \"watch\": \"tsc -w -p ./src\",\n    \"test\": \"npm run compile && mocha\",\n    \"preversion\": \"npm test\",\n    \"postversion\": \"git push && git push --tags\"\n  }\n}\n","/typescript-language-features/node_modules/jsonc-parser/lib/umd/main.js":"(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./impl/format\", \"./impl/edit\", \"./impl/scanner\", \"./impl/parser\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var formatter = require(\"./impl/format\");\n    var edit = require(\"./impl/edit\");\n    var scanner = require(\"./impl/scanner\");\n    var parser = require(\"./impl/parser\");\n    /**\n     * Creates a JSON scanner on the given text.\n     * If ignoreTrivia is set, whitespaces or comments are ignored.\n     */\n    exports.createScanner = scanner.createScanner;\n    /**\n     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n     */\n    exports.getLocation = parser.getLocation;\n    /**\n     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     * Therefore, always check the errors list to find out if the input was valid.\n     */\n    exports.parse = parser.parse;\n    /**\n     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     */\n    exports.parseTree = parser.parseTree;\n    /**\n     * Finds the node at the given path in a JSON DOM.\n     */\n    exports.findNodeAtLocation = parser.findNodeAtLocation;\n    /**\n     * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n     */\n    exports.findNodeAtOffset = parser.findNodeAtOffset;\n    /**\n     * Gets the JSON path of the given JSON DOM node\n     */\n    exports.getNodePath = parser.getNodePath;\n    /**\n     * Evaluates the JavaScript object of the given JSON DOM node\n     */\n    exports.getNodeValue = parser.getNodeValue;\n    /**\n     * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n     */\n    exports.visit = parser.visit;\n    /**\n     * Takes JSON with JavaScript-style comments and remove\n     * them. Optionally replaces every none-newline character\n     * of comments with a replaceCharacter\n     */\n    exports.stripComments = parser.stripComments;\n    function printParseErrorCode(code) {\n        switch (code) {\n            case 1 /* InvalidSymbol */: return 'InvalidSymbol';\n            case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';\n            case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';\n            case 4 /* ValueExpected */: return 'ValueExpected';\n            case 5 /* ColonExpected */: return 'ColonExpected';\n            case 6 /* CommaExpected */: return 'CommaExpected';\n            case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';\n            case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';\n            case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';\n            case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';\n            case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n            case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n            case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n            case 14 /* InvalidUnicode */: return 'InvalidUnicode';\n            case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n            case 16 /* InvalidCharacter */: return 'InvalidCharacter';\n        }\n        return '<unknown ParseErrorCode>';\n    }\n    exports.printParseErrorCode = printParseErrorCode;\n    /**\n     * Computes the edits needed to format a JSON document.\n     *\n     * @param documentText The input text\n     * @param range The range to format or `undefined` to format the full content\n     * @param options The formatting options\n     * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n     * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n     * text in the original document. However, multiple edits can have\n     * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n     * To apply edits to an input, you can use `applyEdits`.\n     */\n    function format(documentText, range, options) {\n        return formatter.format(documentText, range, options);\n    }\n    exports.format = format;\n    /**\n     * Computes the edits needed to modify a value in the JSON document.\n     *\n     * @param documentText The input text\n     * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n     * If the path points to an non-existing property or item, it will be created.\n     * @param value The new value for the specified property or item. If the value is undefined,\n     * the property or item will be removed.\n     * @param options Options\n     * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n     * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n     * text in the original document. However, multiple edits can have\n     * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n     * To apply edits to an input, you can use `applyEdits`.\n     */\n    function modify(text, path, value, options) {\n        return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n    }\n    exports.modify = modify;\n    /**\n     * Applies edits to a input string.\n     */\n    function applyEdits(text, edits) {\n        for (var i = edits.length - 1; i >= 0; i--) {\n            text = edit.applyEdit(text, edits[i]);\n        }\n        return text;\n    }\n    exports.applyEdits = applyEdits;\n});\n//# sourceMappingURL=main.js.map","/typescript-language-features/node_modules/jsonc-parser/lib/umd/impl/format.js":"(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./scanner\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var scanner_1 = require(\"./scanner\");\n    function format(documentText, range, options) {\n        var initialIndentLevel;\n        var formatText;\n        var formatTextStart;\n        var rangeStart;\n        var rangeEnd;\n        if (range) {\n            rangeStart = range.offset;\n            rangeEnd = rangeStart + range.length;\n            formatTextStart = rangeStart;\n            while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n                formatTextStart--;\n            }\n            var endOffset = rangeEnd;\n            while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n                endOffset++;\n            }\n            formatText = documentText.substring(formatTextStart, endOffset);\n            initialIndentLevel = computeIndentLevel(formatText, options);\n        }\n        else {\n            formatText = documentText;\n            initialIndentLevel = 0;\n            formatTextStart = 0;\n            rangeStart = 0;\n            rangeEnd = documentText.length;\n        }\n        var eol = getEOL(options, documentText);\n        var lineBreak = false;\n        var indentLevel = 0;\n        var indentValue;\n        if (options.insertSpaces) {\n            indentValue = repeat(' ', options.tabSize || 4);\n        }\n        else {\n            indentValue = '\\t';\n        }\n        var scanner = scanner_1.createScanner(formatText, false);\n        var hasError = false;\n        function newLineAndIndent() {\n            return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n        function scanNext() {\n            var token = scanner.scan();\n            lineBreak = false;\n            while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {\n                lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);\n                token = scanner.scan();\n            }\n            hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;\n            return token;\n        }\n        var editOperations = [];\n        function addEdit(text, startOffset, endOffset) {\n            if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n                editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n            }\n        }\n        var firstToken = scanNext();\n        if (firstToken !== 17 /* EOF */) {\n            var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n            var initialIndent = repeat(indentValue, initialIndentLevel);\n            addEdit(initialIndent, formatTextStart, firstTokenStart);\n        }\n        while (firstToken !== 17 /* EOF */) {\n            var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            var secondToken = scanNext();\n            var replaceContent = '';\n            while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                // comments on the same line: keep them on the same line, but ignore them otherwise\n                var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n                addEdit(' ', firstTokenEnd, commentTokenStart);\n                firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n                replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';\n                secondToken = scanNext();\n            }\n            if (secondToken === 2 /* CloseBraceToken */) {\n                if (firstToken !== 1 /* OpenBraceToken */) {\n                    indentLevel--;\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            else if (secondToken === 4 /* CloseBracketToken */) {\n                if (firstToken !== 3 /* OpenBracketToken */) {\n                    indentLevel--;\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            else {\n                switch (firstToken) {\n                    case 3 /* OpenBracketToken */:\n                    case 1 /* OpenBraceToken */:\n                        indentLevel++;\n                        replaceContent = newLineAndIndent();\n                        break;\n                    case 5 /* CommaToken */:\n                    case 12 /* LineCommentTrivia */:\n                        replaceContent = newLineAndIndent();\n                        break;\n                    case 13 /* BlockCommentTrivia */:\n                        if (lineBreak) {\n                            replaceContent = newLineAndIndent();\n                        }\n                        else {\n                            // symbol following comment on the same line: keep on same line, separate with ' '\n                            replaceContent = ' ';\n                        }\n                        break;\n                    case 6 /* ColonToken */:\n                        replaceContent = ' ';\n                        break;\n                    case 10 /* StringLiteral */:\n                        if (secondToken === 6 /* ColonToken */) {\n                            replaceContent = '';\n                            break;\n                        }\n                    // fall through\n                    case 7 /* NullKeyword */:\n                    case 8 /* TrueKeyword */:\n                    case 9 /* FalseKeyword */:\n                    case 11 /* NumericLiteral */:\n                    case 2 /* CloseBraceToken */:\n                    case 4 /* CloseBracketToken */:\n                        if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {\n                            replaceContent = ' ';\n                        }\n                        else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {\n                            hasError = true;\n                        }\n                        break;\n                    case 16 /* Unknown */:\n                        hasError = true;\n                        break;\n                }\n                if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n            firstToken = secondToken;\n        }\n        return editOperations;\n    }\n    exports.format = format;\n    function repeat(s, count) {\n        var result = '';\n        for (var i = 0; i < count; i++) {\n            result += s;\n        }\n        return result;\n    }\n    function computeIndentLevel(content, options) {\n        var i = 0;\n        var nChars = 0;\n        var tabSize = options.tabSize || 4;\n        while (i < content.length) {\n            var ch = content.charAt(i);\n            if (ch === ' ') {\n                nChars++;\n            }\n            else if (ch === '\\t') {\n                nChars += tabSize;\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        return Math.floor(nChars / tabSize);\n    }\n    function getEOL(options, text) {\n        for (var i = 0; i < text.length; i++) {\n            var ch = text.charAt(i);\n            if (ch === '\\r') {\n                if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    return '\\r\\n';\n                }\n                return '\\r';\n            }\n            else if (ch === '\\n') {\n                return '\\n';\n            }\n        }\n        return (options && options.eol) || '\\n';\n    }\n    function isEOL(text, offset) {\n        return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n    }\n    exports.isEOL = isEOL;\n});\n//# sourceMappingURL=format.js.map","/typescript-language-features/node_modules/jsonc-parser/lib/umd/impl/scanner.js":"(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Creates a JSON scanner on the given text.\n     * If ignoreTrivia is set, whitespaces or comments are ignored.\n     */\n    function createScanner(text, ignoreTrivia) {\n        if (ignoreTrivia === void 0) { ignoreTrivia = false; }\n        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;\n        function scanHexDigits(count, exact) {\n            var digits = 0;\n            var value = 0;\n            while (digits < count || !exact) {\n                var ch = text.charCodeAt(pos);\n                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {\n                    value = value * 16 + ch - 48 /* _0 */;\n                }\n                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {\n                    value = value * 16 + ch - 65 /* A */ + 10;\n                }\n                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {\n                    value = value * 16 + ch - 97 /* a */ + 10;\n                }\n                else {\n                    break;\n                }\n                pos++;\n                digits++;\n            }\n            if (digits < count) {\n                value = -1;\n            }\n            return value;\n        }\n        function setPosition(newPosition) {\n            pos = newPosition;\n            value = '';\n            tokenOffset = 0;\n            token = 16 /* Unknown */;\n            scanError = 0 /* None */;\n        }\n        function scanNumber() {\n            var start = pos;\n            if (text.charCodeAt(pos) === 48 /* _0 */) {\n                pos++;\n            }\n            else {\n                pos++;\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                }\n            }\n            if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {\n                pos++;\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                }\n                else {\n                    scanError = 3 /* UnexpectedEndOfNumber */;\n                    return text.substring(start, pos);\n                }\n            }\n            var end = pos;\n            if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {\n                pos++;\n                if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {\n                    pos++;\n                }\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                    pos++;\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n                        pos++;\n                    }\n                    end = pos;\n                }\n                else {\n                    scanError = 3 /* UnexpectedEndOfNumber */;\n                }\n            }\n            return text.substring(start, end);\n        }\n        function scanString() {\n            var result = '', start = pos;\n            while (true) {\n                if (pos >= len) {\n                    result += text.substring(start, pos);\n                    scanError = 2 /* UnexpectedEndOfString */;\n                    break;\n                }\n                var ch = text.charCodeAt(pos);\n                if (ch === 34 /* doubleQuote */) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    break;\n                }\n                if (ch === 92 /* backslash */) {\n                    result += text.substring(start, pos);\n                    pos++;\n                    if (pos >= len) {\n                        scanError = 2 /* UnexpectedEndOfString */;\n                        break;\n                    }\n                    ch = text.charCodeAt(pos++);\n                    switch (ch) {\n                        case 34 /* doubleQuote */:\n                            result += '\\\"';\n                            break;\n                        case 92 /* backslash */:\n                            result += '\\\\';\n                            break;\n                        case 47 /* slash */:\n                            result += '/';\n                            break;\n                        case 98 /* b */:\n                            result += '\\b';\n                            break;\n                        case 102 /* f */:\n                            result += '\\f';\n                            break;\n                        case 110 /* n */:\n                            result += '\\n';\n                            break;\n                        case 114 /* r */:\n                            result += '\\r';\n                            break;\n                        case 116 /* t */:\n                            result += '\\t';\n                            break;\n                        case 117 /* u */:\n                            var ch_1 = scanHexDigits(4, true);\n                            if (ch_1 >= 0) {\n                                result += String.fromCharCode(ch_1);\n                            }\n                            else {\n                                scanError = 4 /* InvalidUnicode */;\n                            }\n                            break;\n                        default:\n                            scanError = 5 /* InvalidEscapeCharacter */;\n                    }\n                    start = pos;\n                    continue;\n                }\n                if (ch >= 0 && ch <= 0x1f) {\n                    if (isLineBreak(ch)) {\n                        result += text.substring(start, pos);\n                        scanError = 2 /* UnexpectedEndOfString */;\n                        break;\n                    }\n                    else {\n                        scanError = 6 /* InvalidCharacter */;\n                        // mark as error but continue with string\n                    }\n                }\n                pos++;\n            }\n            return result;\n        }\n        function scanNext() {\n            value = '';\n            scanError = 0 /* None */;\n            tokenOffset = pos;\n            lineStartOffset = lineNumber;\n            prevTokenLineStartOffset = tokenLineStartOffset;\n            if (pos >= len) {\n                // at the end\n                tokenOffset = len;\n                return token = 17 /* EOF */;\n            }\n            var code = text.charCodeAt(pos);\n            // trivia: whitespace\n            if (isWhiteSpace(code)) {\n                do {\n                    pos++;\n                    value += String.fromCharCode(code);\n                    code = text.charCodeAt(pos);\n                } while (isWhiteSpace(code));\n                return token = 15 /* Trivia */;\n            }\n            // trivia: newlines\n            if (isLineBreak(code)) {\n                pos++;\n                value += String.fromCharCode(code);\n                if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                    pos++;\n                    value += '\\n';\n                }\n                lineNumber++;\n                tokenLineStartOffset = pos;\n                return token = 14 /* LineBreakTrivia */;\n            }\n            switch (code) {\n                // tokens: []{}:,\n                case 123 /* openBrace */:\n                    pos++;\n                    return token = 1 /* OpenBraceToken */;\n                case 125 /* closeBrace */:\n                    pos++;\n                    return token = 2 /* CloseBraceToken */;\n                case 91 /* openBracket */:\n                    pos++;\n                    return token = 3 /* OpenBracketToken */;\n                case 93 /* closeBracket */:\n                    pos++;\n                    return token = 4 /* CloseBracketToken */;\n                case 58 /* colon */:\n                    pos++;\n                    return token = 6 /* ColonToken */;\n                case 44 /* comma */:\n                    pos++;\n                    return token = 5 /* CommaToken */;\n                // strings\n                case 34 /* doubleQuote */:\n                    pos++;\n                    value = scanString();\n                    return token = 10 /* StringLiteral */;\n                // comments\n                case 47 /* slash */:\n                    var start = pos - 1;\n                    // Single-line comment\n                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {\n                        pos += 2;\n                        while (pos < len) {\n                            if (isLineBreak(text.charCodeAt(pos))) {\n                                break;\n                            }\n                            pos++;\n                        }\n                        value = text.substring(start, pos);\n                        return token = 12 /* LineCommentTrivia */;\n                    }\n                    // Multi-line comment\n                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {\n                        pos += 2;\n                        var safeLength = len - 1; // For lookahead.\n                        var commentClosed = false;\n                        while (pos < safeLength) {\n                            var ch = text.charCodeAt(pos);\n                            if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {\n                                pos += 2;\n                                commentClosed = true;\n                                break;\n                            }\n                            pos++;\n                            if (isLineBreak(ch)) {\n                                if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {\n                                    pos++;\n                                }\n                                lineNumber++;\n                                tokenLineStartOffset = pos;\n                            }\n                        }\n                        if (!commentClosed) {\n                            pos++;\n                            scanError = 1 /* UnexpectedEndOfComment */;\n                        }\n                        value = text.substring(start, pos);\n                        return token = 13 /* BlockCommentTrivia */;\n                    }\n                    // just a single slash\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = 16 /* Unknown */;\n                // numbers\n                case 45 /* minus */:\n                    value += String.fromCharCode(code);\n                    pos++;\n                    if (pos === len || !isDigit(text.charCodeAt(pos))) {\n                        return token = 16 /* Unknown */;\n                    }\n                // found a minus, followed by a number so\n                // we fall through to proceed with scanning\n                // numbers\n                case 48 /* _0 */:\n                case 49 /* _1 */:\n                case 50 /* _2 */:\n                case 51 /* _3 */:\n                case 52 /* _4 */:\n                case 53 /* _5 */:\n                case 54 /* _6 */:\n                case 55 /* _7 */:\n                case 56 /* _8 */:\n                case 57 /* _9 */:\n                    value += scanNumber();\n                    return token = 11 /* NumericLiteral */;\n                // literals and unknown symbols\n                default:\n                    // is a literal? Read the full word.\n                    while (pos < len && isUnknownContentCharacter(code)) {\n                        pos++;\n                        code = text.charCodeAt(pos);\n                    }\n                    if (tokenOffset !== pos) {\n                        value = text.substring(tokenOffset, pos);\n                        // keywords: true, false, null\n                        switch (value) {\n                            case 'true': return token = 8 /* TrueKeyword */;\n                            case 'false': return token = 9 /* FalseKeyword */;\n                            case 'null': return token = 7 /* NullKeyword */;\n                        }\n                        return token = 16 /* Unknown */;\n                    }\n                    // some\n                    value += String.fromCharCode(code);\n                    pos++;\n                    return token = 16 /* Unknown */;\n            }\n        }\n        function isUnknownContentCharacter(code) {\n            if (isWhiteSpace(code) || isLineBreak(code)) {\n                return false;\n            }\n            switch (code) {\n                case 125 /* closeBrace */:\n                case 93 /* closeBracket */:\n                case 123 /* openBrace */:\n                case 91 /* openBracket */:\n                case 34 /* doubleQuote */:\n                case 58 /* colon */:\n                case 44 /* comma */:\n                case 47 /* slash */:\n                    return false;\n            }\n            return true;\n        }\n        function scanNextNonTrivia() {\n            var result;\n            do {\n                result = scanNext();\n            } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);\n            return result;\n        }\n        return {\n            setPosition: setPosition,\n            getPosition: function () { return pos; },\n            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n            getToken: function () { return token; },\n            getTokenValue: function () { return value; },\n            getTokenOffset: function () { return tokenOffset; },\n            getTokenLength: function () { return pos - tokenOffset; },\n            getTokenStartLine: function () { return lineStartOffset; },\n            getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },\n            getTokenError: function () { return scanError; },\n        };\n    }\n    exports.createScanner = createScanner;\n    function isWhiteSpace(ch) {\n        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||\n            ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||\n            ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;\n    }\n    function isLineBreak(ch) {\n        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;\n    }\n    function isDigit(ch) {\n        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;\n    }\n});\n//# sourceMappingURL=scanner.js.map","/typescript-language-features/node_modules/jsonc-parser/lib/umd/impl/edit.js":"(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./format\", \"./parser\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var format_1 = require(\"./format\");\n    var parser_1 = require(\"./parser\");\n    function removeProperty(text, path, formattingOptions) {\n        return setProperty(text, path, void 0, formattingOptions);\n    }\n    exports.removeProperty = removeProperty;\n    function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n        var _a;\n        var path = originalPath.slice();\n        var errors = [];\n        var root = parser_1.parseTree(text, errors);\n        var parent = void 0;\n        var lastSegment = void 0;\n        while (path.length > 0) {\n            lastSegment = path.pop();\n            parent = parser_1.findNodeAtLocation(root, path);\n            if (parent === void 0 && value !== void 0) {\n                if (typeof lastSegment === 'string') {\n                    value = (_a = {}, _a[lastSegment] = value, _a);\n                }\n                else {\n                    value = [value];\n                }\n            }\n            else {\n                break;\n            }\n        }\n        if (!parent) {\n            // empty document\n            if (value === void 0) { // delete\n                throw new Error('Can not delete in empty document');\n            }\n            return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);\n        }\n        else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n            var existing = parser_1.findNodeAtLocation(parent, [lastSegment]);\n            if (existing !== void 0) {\n                if (value === void 0) { // delete\n                    if (!existing.parent) {\n                        throw new Error('Malformed AST');\n                    }\n                    var propertyIndex = parent.children.indexOf(existing.parent);\n                    var removeBegin = void 0;\n                    var removeEnd = existing.parent.offset + existing.parent.length;\n                    if (propertyIndex > 0) {\n                        // remove the comma of the previous node\n                        var previous = parent.children[propertyIndex - 1];\n                        removeBegin = previous.offset + previous.length;\n                    }\n                    else {\n                        removeBegin = parent.offset + 1;\n                        if (parent.children.length > 1) {\n                            // remove the comma of the next node\n                            var next = parent.children[1];\n                            removeEnd = next.offset;\n                        }\n                    }\n                    return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);\n                }\n                else {\n                    // set value of existing property\n                    return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);\n                }\n            }\n            else {\n                if (value === void 0) { // delete\n                    return []; // property does not exist, nothing to do\n                }\n                var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n                var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;\n                var edit = void 0;\n                if (index > 0) {\n                    var previous = parent.children[index - 1];\n                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n                }\n                else if (parent.children.length === 0) {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n                }\n                else {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n        }\n        else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n            var insertIndex = lastSegment;\n            if (insertIndex === -1) {\n                // Insert\n                var newProperty = \"\" + JSON.stringify(value);\n                var edit = void 0;\n                if (parent.children.length === 0) {\n                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n                }\n                else {\n                    var previous = parent.children[parent.children.length - 1];\n                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n                }\n                return withFormatting(text, edit, formattingOptions);\n            }\n            else {\n                if (value === void 0 && parent.children.length >= 0) {\n                    //Removal\n                    var removalIndex = lastSegment;\n                    var toRemove = parent.children[removalIndex];\n                    var edit = void 0;\n                    if (parent.children.length === 1) {\n                        // only item\n                        edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n                    }\n                    else if (parent.children.length - 1 === removalIndex) {\n                        // last item\n                        var previous = parent.children[removalIndex - 1];\n                        var offset = previous.offset + previous.length;\n                        var parentEndOffset = parent.offset + parent.length;\n                        edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };\n                    }\n                    else {\n                        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n                    }\n                    return withFormatting(text, edit, formattingOptions);\n                }\n                else {\n                    throw new Error('Array modification not supported yet');\n                }\n            }\n        }\n        else {\n            throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n        }\n    }\n    exports.setProperty = setProperty;\n    function withFormatting(text, edit, formattingOptions) {\n        // apply the edit\n        var newText = applyEdit(text, edit);\n        // format the new text\n        var begin = edit.offset;\n        var end = edit.offset + edit.content.length;\n        if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n            while (begin > 0 && !format_1.isEOL(newText, begin - 1)) {\n                begin--;\n            }\n            while (end < newText.length && !format_1.isEOL(newText, end)) {\n                end++;\n            }\n        }\n        var edits = format_1.format(newText, { offset: begin, length: end - begin }, formattingOptions);\n        // apply the formatting edits and track the begin and end offsets of the changes\n        for (var i = edits.length - 1; i >= 0; i--) {\n            var edit_1 = edits[i];\n            newText = applyEdit(newText, edit_1);\n            begin = Math.min(begin, edit_1.offset);\n            end = Math.max(end, edit_1.offset + edit_1.length);\n            end += edit_1.content.length - edit_1.length;\n        }\n        // create a single edit with all changes\n        var editLength = text.length - (newText.length - end) - begin;\n        return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n    }\n    function applyEdit(text, edit) {\n        return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n    }\n    exports.applyEdit = applyEdit;\n    function isWS(text, offset) {\n        return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n    }\n    exports.isWS = isWS;\n});\n//# sourceMappingURL=edit.js.map","/typescript-language-features/node_modules/jsonc-parser/lib/umd/impl/parser.js":"(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./scanner\"], factory);\n    }\n})(function (require, exports) {\n    /*---------------------------------------------------------------------------------------------\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\n     *--------------------------------------------------------------------------------------------*/\n    'use strict';\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var scanner_1 = require(\"./scanner\");\n    var ParseOptions;\n    (function (ParseOptions) {\n        ParseOptions.DEFAULT = {\n            allowTrailingComma: false\n        };\n    })(ParseOptions || (ParseOptions = {}));\n    /**\n     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n     */\n    function getLocation(text, position) {\n        var segments = []; // strings or numbers\n        var earlyReturnException = new Object();\n        var previousNode = void 0;\n        var previousNodeInst = {\n            value: {},\n            offset: 0,\n            length: 0,\n            type: 'object',\n            parent: void 0\n        };\n        var isAtPropertyKey = false;\n        function setPreviousNode(value, offset, length, type) {\n            previousNodeInst.value = value;\n            previousNodeInst.offset = offset;\n            previousNodeInst.length = length;\n            previousNodeInst.type = type;\n            previousNodeInst.colonOffset = void 0;\n            previousNode = previousNodeInst;\n        }\n        try {\n            visit(text, {\n                onObjectBegin: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    isAtPropertyKey = position > offset;\n                    segments.push(''); // push a placeholder (will be replaced)\n                },\n                onObjectProperty: function (name, offset, length) {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(name, offset, length, 'property');\n                    segments[segments.length - 1] = name;\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onObjectEnd: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.pop();\n                },\n                onArrayBegin: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.push(0);\n                },\n                onArrayEnd: function (offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    previousNode = void 0;\n                    segments.pop();\n                },\n                onLiteralValue: function (value, offset, length) {\n                    if (position < offset) {\n                        throw earlyReturnException;\n                    }\n                    setPreviousNode(value, offset, length, getLiteralNodeType(value));\n                    if (position <= offset + length) {\n                        throw earlyReturnException;\n                    }\n                },\n                onSeparator: function (sep, offset, length) {\n                    if (position <= offset) {\n                        throw earlyReturnException;\n                    }\n                    if (sep === ':' && previousNode && previousNode.type === 'property') {\n                        previousNode.colonOffset = offset;\n                        isAtPropertyKey = false;\n                        previousNode = void 0;\n                    }\n                    else if (sep === ',') {\n                        var last = segments[segments.length - 1];\n                        if (typeof last === 'number') {\n                            segments[segments.length - 1] = last + 1;\n                        }\n                        else {\n                            isAtPropertyKey = true;\n                            segments[segments.length - 1] = '';\n                        }\n                        previousNode = void 0;\n                    }\n                }\n            });\n        }\n        catch (e) {\n            if (e !== earlyReturnException) {\n                throw e;\n            }\n        }\n        return {\n            path: segments,\n            previousNode: previousNode,\n            isAtPropertyKey: isAtPropertyKey,\n            matches: function (pattern) {\n                var k = 0;\n                for (var i = 0; k < pattern.length && i < segments.length; i++) {\n                    if (pattern[k] === segments[i] || pattern[k] === '*') {\n                        k++;\n                    }\n                    else if (pattern[k] !== '**') {\n                        return false;\n                    }\n                }\n                return k === pattern.length;\n            }\n        };\n    }\n    exports.getLocation = getLocation;\n    /**\n     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     * Therefore always check the errors list to find out if the input was valid.\n     */\n    function parse(text, errors, options) {\n        if (errors === void 0) { errors = []; }\n        if (options === void 0) { options = ParseOptions.DEFAULT; }\n        var currentProperty = null;\n        var currentParent = [];\n        var previousParents = [];\n        function onValue(value) {\n            if (Array.isArray(currentParent)) {\n                currentParent.push(value);\n            }\n            else if (currentProperty) {\n                currentParent[currentProperty] = value;\n            }\n        }\n        var visitor = {\n            onObjectBegin: function () {\n                var object = {};\n                onValue(object);\n                previousParents.push(currentParent);\n                currentParent = object;\n                currentProperty = null;\n            },\n            onObjectProperty: function (name) {\n                currentProperty = name;\n            },\n            onObjectEnd: function () {\n                currentParent = previousParents.pop();\n            },\n            onArrayBegin: function () {\n                var array = [];\n                onValue(array);\n                previousParents.push(currentParent);\n                currentParent = array;\n                currentProperty = null;\n            },\n            onArrayEnd: function () {\n                currentParent = previousParents.pop();\n            },\n            onLiteralValue: onValue,\n            onError: function (error, offset, length) {\n                errors.push({ error: error, offset: offset, length: length });\n            }\n        };\n        visit(text, visitor, options);\n        return currentParent[0];\n    }\n    exports.parse = parse;\n    /**\n     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n     */\n    function parseTree(text, errors, options) {\n        if (errors === void 0) { errors = []; }\n        if (options === void 0) { options = ParseOptions.DEFAULT; }\n        var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: void 0 }; // artificial root\n        function ensurePropertyComplete(endOffset) {\n            if (currentParent.type === 'property') {\n                currentParent.length = endOffset - currentParent.offset;\n                currentParent = currentParent.parent;\n            }\n        }\n        function onValue(valueNode) {\n            currentParent.children.push(valueNode);\n            return valueNode;\n        }\n        var visitor = {\n            onObjectBegin: function (offset) {\n                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\n            },\n            onObjectProperty: function (name, offset, length) {\n                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\n                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\n            },\n            onObjectEnd: function (offset, length) {\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n                ensurePropertyComplete(offset + length);\n            },\n            onArrayBegin: function (offset, length) {\n                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\n            },\n            onArrayEnd: function (offset, length) {\n                currentParent.length = offset + length - currentParent.offset;\n                currentParent = currentParent.parent;\n                ensurePropertyComplete(offset + length);\n            },\n            onLiteralValue: function (value, offset, length) {\n                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\n                ensurePropertyComplete(offset + length);\n            },\n            onSeparator: function (sep, offset, length) {\n                if (currentParent.type === 'property') {\n                    if (sep === ':') {\n                        currentParent.colonOffset = offset;\n                    }\n                    else if (sep === ',') {\n                        ensurePropertyComplete(offset);\n                    }\n                }\n            },\n            onError: function (error, offset, length) {\n                errors.push({ error: error, offset: offset, length: length });\n            }\n        };\n        visit(text, visitor, options);\n        var result = currentParent.children[0];\n        if (result) {\n            delete result.parent;\n        }\n        return result;\n    }\n    exports.parseTree = parseTree;\n    /**\n     * Finds the node at the given path in a JSON DOM.\n     */\n    function findNodeAtLocation(root, path) {\n        if (!root) {\n            return void 0;\n        }\n        var node = root;\n        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n            var segment = path_1[_i];\n            if (typeof segment === 'string') {\n                if (node.type !== 'object' || !Array.isArray(node.children)) {\n                    return void 0;\n                }\n                var found = false;\n                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n                    var propertyNode = _b[_a];\n                    if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n                        node = propertyNode.children[1];\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return void 0;\n                }\n            }\n            else {\n                var index = segment;\n                if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                    return void 0;\n                }\n                node = node.children[index];\n            }\n        }\n        return node;\n    }\n    exports.findNodeAtLocation = findNodeAtLocation;\n    /**\n     * Gets the JSON path of the given JSON DOM node\n     */\n    function getNodePath(node) {\n        if (!node.parent || !node.parent.children) {\n            return [];\n        }\n        var path = getNodePath(node.parent);\n        if (node.parent.type === 'property') {\n            var key = node.parent.children[0].value;\n            path.push(key);\n        }\n        else if (node.parent.type === 'array') {\n            var index = node.parent.children.indexOf(node);\n            if (index !== -1) {\n                path.push(index);\n            }\n        }\n        return path;\n    }\n    exports.getNodePath = getNodePath;\n    /**\n     * Evaluates the JavaScript object of the given JSON DOM node\n     */\n    function getNodeValue(node) {\n        switch (node.type) {\n            case 'array':\n                return node.children.map(getNodeValue);\n            case 'object':\n                var obj = Object.create(null);\n                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    var valueNode = prop.children[1];\n                    if (valueNode) {\n                        obj[prop.children[0].value] = getNodeValue(valueNode);\n                    }\n                }\n                return obj;\n            case 'null':\n            case 'string':\n            case 'number':\n            case 'boolean':\n                return node.value;\n            default:\n                return void 0;\n        }\n    }\n    exports.getNodeValue = getNodeValue;\n    function contains(node, offset, includeRightBound) {\n        if (includeRightBound === void 0) { includeRightBound = false; }\n        return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n    }\n    exports.contains = contains;\n    /**\n     * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n     */\n    function findNodeAtOffset(node, offset, includeRightBound) {\n        if (includeRightBound === void 0) { includeRightBound = false; }\n        if (contains(node, offset, includeRightBound)) {\n            var children = node.children;\n            if (Array.isArray(children)) {\n                for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n                    var item = findNodeAtOffset(children[i], offset, includeRightBound);\n                    if (item) {\n                        return item;\n                    }\n                }\n            }\n            return node;\n        }\n        return void 0;\n    }\n    exports.findNodeAtOffset = findNodeAtOffset;\n    /**\n     * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n     */\n    function visit(text, visitor, options) {\n        if (options === void 0) { options = ParseOptions.DEFAULT; }\n        var _scanner = scanner_1.createScanner(text, false);\n        function toNoArgVisit(visitFunction) {\n            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n        }\n        function toOneArgVisit(visitFunction) {\n            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };\n        }\n        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n        var disallowComments = options && options.disallowComments;\n        var allowTrailingComma = options && options.allowTrailingComma;\n        function scanNext() {\n            while (true) {\n                var token = _scanner.scan();\n                switch (_scanner.getTokenError()) {\n                    case 4 /* InvalidUnicode */:\n                        handleError(14 /* InvalidUnicode */);\n                        break;\n                    case 5 /* InvalidEscapeCharacter */:\n                        handleError(15 /* InvalidEscapeCharacter */);\n                        break;\n                    case 3 /* UnexpectedEndOfNumber */:\n                        handleError(13 /* UnexpectedEndOfNumber */);\n                        break;\n                    case 1 /* UnexpectedEndOfComment */:\n                        if (!disallowComments) {\n                            handleError(11 /* UnexpectedEndOfComment */);\n                        }\n                        break;\n                    case 2 /* UnexpectedEndOfString */:\n                        handleError(12 /* UnexpectedEndOfString */);\n                        break;\n                    case 6 /* InvalidCharacter */:\n                        handleError(16 /* InvalidCharacter */);\n                        break;\n                }\n                switch (token) {\n                    case 12 /* LineCommentTrivia */:\n                    case 13 /* BlockCommentTrivia */:\n                        if (disallowComments) {\n                            handleError(10 /* InvalidCommentToken */);\n                        }\n                        else {\n                            onComment();\n                        }\n                        break;\n                    case 16 /* Unknown */:\n                        handleError(1 /* InvalidSymbol */);\n                        break;\n                    case 15 /* Trivia */:\n                    case 14 /* LineBreakTrivia */:\n                        break;\n                    default:\n                        return token;\n                }\n            }\n        }\n        function handleError(error, skipUntilAfter, skipUntil) {\n            if (skipUntilAfter === void 0) { skipUntilAfter = []; }\n            if (skipUntil === void 0) { skipUntil = []; }\n            onError(error);\n            if (skipUntilAfter.length + skipUntil.length > 0) {\n                var token = _scanner.getToken();\n                while (token !== 17 /* EOF */) {\n                    if (skipUntilAfter.indexOf(token) !== -1) {\n                        scanNext();\n                        break;\n                    }\n                    else if (skipUntil.indexOf(token) !== -1) {\n                        break;\n                    }\n                    token = scanNext();\n                }\n            }\n        }\n        function parseString(isValue) {\n            var value = _scanner.getTokenValue();\n            if (isValue) {\n                onLiteralValue(value);\n            }\n            else {\n                onObjectProperty(value);\n            }\n            scanNext();\n            return true;\n        }\n        function parseLiteral() {\n            switch (_scanner.getToken()) {\n                case 11 /* NumericLiteral */:\n                    var value = 0;\n                    try {\n                        value = JSON.parse(_scanner.getTokenValue());\n                        if (typeof value !== 'number') {\n                            handleError(2 /* InvalidNumberFormat */);\n                            value = 0;\n                        }\n                    }\n                    catch (e) {\n                        handleError(2 /* InvalidNumberFormat */);\n                    }\n                    onLiteralValue(value);\n                    break;\n                case 7 /* NullKeyword */:\n                    onLiteralValue(null);\n                    break;\n                case 8 /* TrueKeyword */:\n                    onLiteralValue(true);\n                    break;\n                case 9 /* FalseKeyword */:\n                    onLiteralValue(false);\n                    break;\n                default:\n                    return false;\n            }\n            scanNext();\n            return true;\n        }\n        function parseProperty() {\n            if (_scanner.getToken() !== 10 /* StringLiteral */) {\n                handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n                return false;\n            }\n            parseString(false);\n            if (_scanner.getToken() === 6 /* ColonToken */) {\n                onSeparator(':');\n                scanNext(); // consume colon\n                if (!parseValue()) {\n                    handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n                }\n            }\n            else {\n                handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n            }\n            return true;\n        }\n        function parseObject() {\n            onObjectBegin();\n            scanNext(); // consume open brace\n            var needsComma = false;\n            while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {\n                if (_scanner.getToken() === 5 /* CommaToken */) {\n                    if (!needsComma) {\n                        handleError(4 /* ValueExpected */, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                    if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {\n                        break;\n                    }\n                }\n                else if (needsComma) {\n                    handleError(6 /* CommaExpected */, [], []);\n                }\n                if (!parseProperty()) {\n                    handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);\n                }\n                needsComma = true;\n            }\n            onObjectEnd();\n            if (_scanner.getToken() !== 2 /* CloseBraceToken */) {\n                handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);\n            }\n            else {\n                scanNext(); // consume close brace\n            }\n            return true;\n        }\n        function parseArray() {\n            onArrayBegin();\n            scanNext(); // consume open bracket\n            var needsComma = false;\n            while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {\n                if (_scanner.getToken() === 5 /* CommaToken */) {\n                    if (!needsComma) {\n                        handleError(4 /* ValueExpected */, [], []);\n                    }\n                    onSeparator(',');\n                    scanNext(); // consume comma\n                    if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {\n                        break;\n                    }\n                }\n                else if (needsComma) {\n                    handleError(6 /* CommaExpected */, [], []);\n                }\n                if (!parseValue()) {\n                    handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);\n                }\n                needsComma = true;\n            }\n            onArrayEnd();\n            if (_scanner.getToken() !== 4 /* CloseBracketToken */) {\n                handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);\n            }\n            else {\n                scanNext(); // consume close bracket\n            }\n            return true;\n        }\n        function parseValue() {\n            switch (_scanner.getToken()) {\n                case 3 /* OpenBracketToken */:\n                    return parseArray();\n                case 1 /* OpenBraceToken */:\n                    return parseObject();\n                case 10 /* StringLiteral */:\n                    return parseString(true);\n                default:\n                    return parseLiteral();\n            }\n        }\n        scanNext();\n        if (_scanner.getToken() === 17 /* EOF */) {\n            return true;\n        }\n        if (!parseValue()) {\n            handleError(4 /* ValueExpected */, [], []);\n            return false;\n        }\n        if (_scanner.getToken() !== 17 /* EOF */) {\n            handleError(9 /* EndOfFileExpected */, [], []);\n        }\n        return true;\n    }\n    exports.visit = visit;\n    /**\n     * Takes JSON with JavaScript-style comments and remove\n     * them. Optionally replaces every none-newline character\n     * of comments with a replaceCharacter\n     */\n    function stripComments(text, replaceCh) {\n        var _scanner = scanner_1.createScanner(text), parts = [], kind, offset = 0, pos;\n        do {\n            pos = _scanner.getPosition();\n            kind = _scanner.scan();\n            switch (kind) {\n                case 12 /* LineCommentTrivia */:\n                case 13 /* BlockCommentTrivia */:\n                case 17 /* EOF */:\n                    if (offset !== pos) {\n                        parts.push(text.substring(offset, pos));\n                    }\n                    if (replaceCh !== void 0) {\n                        parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                    }\n                    offset = _scanner.getPosition();\n                    break;\n            }\n        } while (kind !== 17 /* EOF */);\n        return parts.join('');\n    }\n    exports.stripComments = stripComments;\n    function getLiteralNodeType(value) {\n        switch (typeof value) {\n            case 'boolean': return 'boolean';\n            case 'number': return 'number';\n            case 'string': return 'string';\n            default: return 'null';\n        }\n    }\n});\n//# sourceMappingURL=parser.js.map","/typescript-language-features/out/utils/tsconfigProvider.js":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst vscode = require(\"vscode\");\r\nclass TsConfigProvider {\r\n    async getConfigsForWorkspace() {\r\n        if (!vscode.workspace.workspaceFolders) {\r\n            return [];\r\n        }\r\n        const configs = new Map();\r\n        for (const config of await vscode.workspace.findFiles('**/tsconfig*.json', '**/node_modules/**')) {\r\n            const root = vscode.workspace.getWorkspaceFolder(config);\r\n            if (root) {\r\n                configs.set(config.fsPath, {\r\n                    path: config.fsPath,\r\n                    posixPath: config.path,\r\n                    workspaceFolder: root\r\n                });\r\n            }\r\n        }\r\n        return configs.values();\r\n    }\r\n}\r\nexports.default = TsConfigProvider;\r\n//# sourceMappingURL=tsconfigProvider.js.map","/node_modules/typescript/lib/tsserver.js":7964906,"/node_modules/typescript/package.json":"{\n    \"name\": \"typescript\",\n    \"author\": \"Microsoft Corp.\",\n    \"homepage\": \"https://www.typescriptlang.org/\",\n    \"version\": \"3.6.2\",\n    \"license\": \"Apache-2.0\",\n    \"description\": \"TypeScript is a language for application scale JavaScript development\",\n    \"keywords\": [\n        \"TypeScript\",\n        \"Microsoft\",\n        \"compiler\",\n        \"language\",\n        \"javascript\"\n    ],\n    \"bugs\": {\n        \"url\": \"https://github.com/Microsoft/TypeScript/issues\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/Microsoft/TypeScript.git\"\n    },\n    \"main\": \"./lib/typescript.js\",\n    \"typings\": \"./lib/typescript.d.ts\",\n    \"bin\": {\n        \"tsc\": \"./bin/tsc\",\n        \"tsserver\": \"./bin/tsserver\"\n    },\n    \"engines\": {\n        \"node\": \">=4.2.0\"\n    },\n    \"devDependencies\": {\n        \"@octokit/rest\": \"latest\",\n        \"@types/browserify\": \"latest\",\n        \"@types/chai\": \"latest\",\n        \"@types/convert-source-map\": \"latest\",\n        \"@types/del\": \"latest\",\n        \"@types/glob\": \"latest\",\n        \"@types/gulp\": \"^4.0.5\",\n        \"@types/gulp-concat\": \"latest\",\n        \"@types/gulp-newer\": \"latest\",\n        \"@types/gulp-rename\": \"0.0.33\",\n        \"@types/gulp-sourcemaps\": \"0.0.32\",\n        \"@types/jake\": \"latest\",\n        \"@types/merge2\": \"latest\",\n        \"@types/microsoft__typescript-etw\": \"latest\",\n        \"@types/minimatch\": \"latest\",\n        \"@types/minimist\": \"latest\",\n        \"@types/mkdirp\": \"latest\",\n        \"@types/mocha\": \"latest\",\n        \"@types/ms\": \"latest\",\n        \"@types/node\": \"latest\",\n        \"@types/node-fetch\": \"^2.3.4\",\n        \"@types/q\": \"latest\",\n        \"@types/source-map-support\": \"latest\",\n        \"@types/through2\": \"latest\",\n        \"@types/travis-fold\": \"latest\",\n        \"@types/xml2js\": \"^0.4.0\",\n        \"azure-devops-node-api\": \"^8.0.0\",\n        \"browser-resolve\": \"^1.11.2\",\n        \"browserify\": \"latest\",\n        \"chai\": \"latest\",\n        \"chalk\": \"latest\",\n        \"convert-source-map\": \"latest\",\n        \"del\": \"latest\",\n        \"fancy-log\": \"latest\",\n        \"fs-extra\": \"^6.0.1\",\n        \"gulp\": \"^4.0.0\",\n        \"gulp-concat\": \"latest\",\n        \"gulp-insert\": \"latest\",\n        \"gulp-newer\": \"latest\",\n        \"gulp-rename\": \"latest\",\n        \"gulp-sourcemaps\": \"latest\",\n        \"istanbul\": \"latest\",\n        \"merge2\": \"latest\",\n        \"minimist\": \"latest\",\n        \"mkdirp\": \"latest\",\n        \"mocha\": \"latest\",\n        \"mocha-fivemat-progress-reporter\": \"latest\",\n        \"ms\": \"latest\",\n        \"node-fetch\": \"^2.6.0\",\n        \"plugin-error\": \"latest\",\n        \"pretty-hrtime\": \"^1.0.3\",\n        \"prex\": \"^0.4.3\",\n        \"q\": \"latest\",\n        \"remove-internal\": \"^2.9.2\",\n        \"simple-git\": \"^1.113.0\",\n        \"source-map-support\": \"latest\",\n        \"through2\": \"latest\",\n        \"travis-fold\": \"latest\",\n        \"tslint\": \"latest\",\n        \"typescript\": \"next\",\n        \"vinyl\": \"latest\",\n        \"vinyl-sourcemaps-apply\": \"latest\",\n        \"xml2js\": \"^0.4.19\"\n    },\n    \"scripts\": {\n        \"pretest\": \"gulp tests\",\n        \"test\": \"gulp runtests-parallel --light=false\",\n        \"build\": \"npm run build:compiler && npm run build:tests\",\n        \"build:compiler\": \"gulp local\",\n        \"build:tests\": \"gulp tests\",\n        \"start\": \"node lib/tsc\",\n        \"clean\": \"gulp clean\",\n        \"gulp\": \"gulp\",\n        \"jake\": \"gulp\",\n        \"lint\": \"gulp lint\",\n        \"setup-hooks\": \"node scripts/link-hooks.js\",\n        \"update-costly-tests\": \"node scripts/costly-tests.js\"\n    },\n    \"browser\": {\n        \"fs\": false,\n        \"os\": false,\n        \"path\": false,\n        \"@microsoft/typescript-etw\": false\n    },\n    \"dependencies\": {}\n}\n","/typescript-language-features/out/features/tsconfig.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst jsonc = require(\"jsonc-parser\");\r\nconst path_1 = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst arrays_1 = require(\"../utils/arrays\");\r\nfunction mapChildren(node, f) {\r\n    return node && node.type === 'array' && node.children\r\n        ? node.children.map(f)\r\n        : [];\r\n}\r\nclass TsconfigLinkProvider {\r\n    provideDocumentLinks(document, _token) {\r\n        const root = jsonc.parseTree(document.getText());\r\n        if (!root) {\r\n            return null;\r\n        }\r\n        return [\r\n            this.getExtendsLink(document, root),\r\n            ...this.getFilesLinks(document, root),\r\n            ...this.getReferencesLinks(document, root)\r\n        ].filter(x => !!x);\r\n    }\r\n    getExtendsLink(document, root) {\r\n        const extendsNode = jsonc.findNodeAtLocation(root, ['extends']);\r\n        if (!this.isPathValue(extendsNode)) {\r\n            return undefined;\r\n        }\r\n        if (extendsNode.value.startsWith('.')) {\r\n            return new vscode.DocumentLink(this.getRange(document, extendsNode), vscode.Uri.file(path_1.join(path_1.dirname(document.uri.fsPath), extendsNode.value + (extendsNode.value.endsWith('.json') ? '' : '.json'))));\r\n        }\r\n        const workspaceFolderPath = vscode.workspace.getWorkspaceFolder(document.uri).uri.fsPath;\r\n        return new vscode.DocumentLink(this.getRange(document, extendsNode), vscode.Uri.file(path_1.join(workspaceFolderPath, 'node_modules', extendsNode.value + (extendsNode.value.endsWith('.json') ? '' : '.json'))));\r\n    }\r\n    getFilesLinks(document, root) {\r\n        return mapChildren(jsonc.findNodeAtLocation(root, ['files']), child => this.pathNodeToLink(document, child));\r\n    }\r\n    getReferencesLinks(document, root) {\r\n        return mapChildren(jsonc.findNodeAtLocation(root, ['references']), child => {\r\n            const pathNode = jsonc.findNodeAtLocation(child, ['path']);\r\n            if (!this.isPathValue(pathNode)) {\r\n                return undefined;\r\n            }\r\n            return new vscode.DocumentLink(this.getRange(document, pathNode), path_1.basename(pathNode.value).match('.json$')\r\n                ? this.getFileTarget(document, pathNode)\r\n                : this.getFolderTarget(document, pathNode));\r\n        });\r\n    }\r\n    pathNodeToLink(document, node) {\r\n        return this.isPathValue(node)\r\n            ? new vscode.DocumentLink(this.getRange(document, node), this.getFileTarget(document, node))\r\n            : undefined;\r\n    }\r\n    isPathValue(extendsNode) {\r\n        return extendsNode\r\n            && extendsNode.type === 'string'\r\n            && extendsNode.value\r\n            && !extendsNode.value.includes('*'); // don't treat globs as links.\r\n    }\r\n    getFileTarget(document, node) {\r\n        return vscode.Uri.file(path_1.join(path_1.dirname(document.uri.fsPath), node.value));\r\n    }\r\n    getFolderTarget(document, node) {\r\n        return vscode.Uri.file(path_1.join(path_1.dirname(document.uri.fsPath), node.value, 'tsconfig.json'));\r\n    }\r\n    getRange(document, node) {\r\n        const offset = node.offset;\r\n        const start = document.positionAt(offset + 1);\r\n        const end = document.positionAt(offset + (node.length - 1));\r\n        return new vscode.Range(start, end);\r\n    }\r\n}\r\nfunction register() {\r\n    const patterns = [\r\n        '**/[jt]sconfig.json',\r\n        '**/[jt]sconfig.*.json',\r\n    ];\r\n    const languages = ['json', 'jsonc'];\r\n    const selector = arrays_1.flatten(languages.map(language => patterns.map((pattern) => ({ language, pattern }))));\r\n    return vscode.languages.registerDocumentLinkProvider(selector, new TsconfigLinkProvider());\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=tsconfig.js.map","/typescript-language-features/out/features/updatePathsOnRename.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nconst fileSchemes = require(\"../utils/fileSchemes\");\r\nconst languageModeIds_1 = require(\"../utils/languageModeIds\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nconst updateImportsOnFileMoveName = 'updateImportsOnFileMove.enabled';\r\nfunction isDirectory(path) {\r\n    return new Promise((resolve, reject) => {\r\n        fs.stat(path, (err, stat) => {\r\n            if (err) {\r\n                return reject(err);\r\n            }\r\n            return resolve(stat.isDirectory());\r\n        });\r\n    });\r\n}\r\nclass UpdateImportsOnFileRenameHandler extends dispose_1.Disposable {\r\n    constructor(client, fileConfigurationManager, _handles) {\r\n        super();\r\n        this.client = client;\r\n        this.fileConfigurationManager = fileConfigurationManager;\r\n        this._handles = _handles;\r\n        this._register(vscode.workspace.onDidRenameFile(e => {\r\n            vscode.window.withProgress({\r\n                location: vscode.ProgressLocation.Window,\r\n                title: localize('renameProgress.title', \"Checking for update of JS/TS imports\")\r\n            }, () => {\r\n                return this.doRename(e.oldUri, e.newUri);\r\n            });\r\n        }));\r\n    }\r\n    async doRename(oldResource, newResource) {\r\n        // Try to get a js/ts file that is being moved\r\n        // For directory moves, this returns a js/ts file under the directory.\r\n        const jsTsFileThatIsBeingMoved = await this.getJsTsFileBeingMoved(newResource);\r\n        if (!jsTsFileThatIsBeingMoved || !this.client.toPath(jsTsFileThatIsBeingMoved)) {\r\n            return;\r\n        }\r\n        const newFile = this.client.toPath(newResource);\r\n        if (!newFile) {\r\n            return;\r\n        }\r\n        const oldFile = this.client.toPath(oldResource);\r\n        if (!oldFile) {\r\n            return;\r\n        }\r\n        const document = await vscode.workspace.openTextDocument(jsTsFileThatIsBeingMoved);\r\n        const config = this.getConfiguration(document);\r\n        const setting = config.get(updateImportsOnFileMoveName);\r\n        if (setting === \"never\" /* Never */) {\r\n            return;\r\n        }\r\n        // Make sure TS knows about file\r\n        this.client.bufferSyncSupport.closeResource(oldResource);\r\n        this.client.bufferSyncSupport.openTextDocument(document);\r\n        const edits = await this.getEditsForFileRename(document, oldFile, newFile);\r\n        if (!edits || !edits.size) {\r\n            return;\r\n        }\r\n        if (await this.confirmActionWithUser(newResource, document)) {\r\n            await vscode.workspace.applyEdit(edits);\r\n        }\r\n    }\r\n    async confirmActionWithUser(newResource, newDocument) {\r\n        const config = this.getConfiguration(newDocument);\r\n        const setting = config.get(updateImportsOnFileMoveName);\r\n        switch (setting) {\r\n            case \"always\" /* Always */:\r\n                return true;\r\n            case \"never\" /* Never */:\r\n                return false;\r\n            case \"prompt\" /* Prompt */:\r\n            default:\r\n                return this.promptUser(newResource, newDocument);\r\n        }\r\n    }\r\n    getConfiguration(newDocument) {\r\n        return vscode.workspace.getConfiguration(languageModeIds_1.isTypeScriptDocument(newDocument) ? 'typescript' : 'javascript', newDocument.uri);\r\n    }\r\n    async promptUser(newResource, newDocument) {\r\n        const response = await vscode.window.showInformationMessage(localize('prompt', \"Update imports for moved file: '{0}'?\", path.basename(newResource.fsPath)), {\r\n            modal: true,\r\n        }, {\r\n            title: localize('reject.title', \"No\"),\r\n            choice: 2 /* Reject */,\r\n            isCloseAffordance: true,\r\n        }, {\r\n            title: localize('accept.title', \"Yes\"),\r\n            choice: 1 /* Accept */,\r\n        }, {\r\n            title: localize('always.title', \"Always automatically update imports\"),\r\n            choice: 3 /* Always */,\r\n        }, {\r\n            title: localize('never.title', \"Never automatically update imports\"),\r\n            choice: 4 /* Never */,\r\n        });\r\n        if (!response) {\r\n            return false;\r\n        }\r\n        switch (response.choice) {\r\n            case 1 /* Accept */:\r\n                {\r\n                    return true;\r\n                }\r\n            case 2 /* Reject */:\r\n                {\r\n                    return false;\r\n                }\r\n            case 3 /* Always */:\r\n                {\r\n                    const config = this.getConfiguration(newDocument);\r\n                    config.update(updateImportsOnFileMoveName, \"always\" /* Always */, vscode.ConfigurationTarget.Global);\r\n                    return true;\r\n                }\r\n            case 4 /* Never */:\r\n                {\r\n                    const config = this.getConfiguration(newDocument);\r\n                    config.update(updateImportsOnFileMoveName, \"never\" /* Never */, vscode.ConfigurationTarget.Global);\r\n                    return false;\r\n                }\r\n        }\r\n        return false;\r\n    }\r\n    async getJsTsFileBeingMoved(resource) {\r\n        if (resource.scheme !== fileSchemes.file) {\r\n            return undefined;\r\n        }\r\n        if (await isDirectory(resource.fsPath)) {\r\n            const files = await vscode.workspace.findFiles({\r\n                base: resource.fsPath,\r\n                pattern: '**/*.{ts,tsx,js,jsx}',\r\n            }, '**/node_modules/**', 1);\r\n            return files[0];\r\n        }\r\n        return (await this._handles(resource)) ? resource : undefined;\r\n    }\r\n    async getEditsForFileRename(document, oldFile, newFile) {\r\n        const response = await this.client.interruptGetErr(() => {\r\n            this.fileConfigurationManager.setGlobalConfigurationFromDocument(document, cancellation_1.nulToken);\r\n            const args = {\r\n                oldFilePath: oldFile,\r\n                newFilePath: newFile,\r\n            };\r\n            return this.client.execute('getEditsForFileRename', args, cancellation_1.nulToken);\r\n        });\r\n        if (response.type !== 'response' || !response.body) {\r\n            return;\r\n        }\r\n        return typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, response.body);\r\n    }\r\n}\r\nUpdateImportsOnFileRenameHandler.minVersion = api_1.default.v300;\r\nfunction register(client, fileConfigurationManager, handles) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, UpdateImportsOnFileRenameHandler.minVersion, () => new UpdateImportsOnFileRenameHandler(client, fileConfigurationManager, handles));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=updatePathsOnRename.js.map","/typescript-language-features/out/utils/dependentRegistration.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst dispose_1 = require(\"./dispose\");\r\nclass ConditionalRegistration {\r\n    constructor(_doRegister) {\r\n        this._doRegister = _doRegister;\r\n        this.registration = undefined;\r\n    }\r\n    dispose() {\r\n        if (this.registration) {\r\n            this.registration.dispose();\r\n            this.registration = undefined;\r\n        }\r\n    }\r\n    update(enabled) {\r\n        if (enabled) {\r\n            if (!this.registration) {\r\n                this.registration = this._doRegister();\r\n            }\r\n        }\r\n        else {\r\n            if (this.registration) {\r\n                this.registration.dispose();\r\n                this.registration = undefined;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.ConditionalRegistration = ConditionalRegistration;\r\nclass VersionDependentRegistration extends dispose_1.Disposable {\r\n    constructor(client, minVersion, register) {\r\n        super();\r\n        this.client = client;\r\n        this.minVersion = minVersion;\r\n        this._registration = new ConditionalRegistration(register);\r\n        this.update(client.apiVersion);\r\n        this.client.onTsServerStarted(() => {\r\n            this.update(this.client.apiVersion);\r\n        }, null, this._disposables);\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._registration.dispose();\r\n    }\r\n    update(api) {\r\n        this._registration.update(api.gte(this.minVersion));\r\n    }\r\n}\r\nexports.VersionDependentRegistration = VersionDependentRegistration;\r\nclass ConfigurationDependentRegistration extends dispose_1.Disposable {\r\n    constructor(language, configValue, register) {\r\n        super();\r\n        this.language = language;\r\n        this.configValue = configValue;\r\n        this._registration = new ConditionalRegistration(register);\r\n        this.update();\r\n        vscode.workspace.onDidChangeConfiguration(this.update, this, this._disposables);\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._registration.dispose();\r\n    }\r\n    update() {\r\n        const config = vscode.workspace.getConfiguration(this.language, null);\r\n        this._registration.update(!!config.get(this.configValue));\r\n    }\r\n}\r\nexports.ConfigurationDependentRegistration = ConfigurationDependentRegistration;\r\n//# sourceMappingURL=dependentRegistration.js.map","/typescript-language-features/out/features/workspaceSymbols.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nfunction getSymbolKind(item) {\r\n    switch (item.kind) {\r\n        case 'method': return vscode.SymbolKind.Method;\r\n        case 'enum': return vscode.SymbolKind.Enum;\r\n        case 'function': return vscode.SymbolKind.Function;\r\n        case 'class': return vscode.SymbolKind.Class;\r\n        case 'interface': return vscode.SymbolKind.Interface;\r\n        case 'var': return vscode.SymbolKind.Variable;\r\n        default: return vscode.SymbolKind.Variable;\r\n    }\r\n}\r\nclass TypeScriptWorkspaceSymbolProvider {\r\n    constructor(client, modeIds) {\r\n        this.client = client;\r\n        this.modeIds = modeIds;\r\n    }\r\n    async provideWorkspaceSymbols(search, token) {\r\n        const document = this.getDocument();\r\n        if (!document) {\r\n            return [];\r\n        }\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return [];\r\n        }\r\n        const args = {\r\n            file: filepath,\r\n            searchValue: search\r\n        };\r\n        const response = await this.client.execute('navto', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return [];\r\n        }\r\n        const result = [];\r\n        for (const item of response.body) {\r\n            if (!item.containerName && item.kind === 'alias') {\r\n                continue;\r\n            }\r\n            const label = TypeScriptWorkspaceSymbolProvider.getLabel(item);\r\n            result.push(new vscode.SymbolInformation(label, getSymbolKind(item), item.containerName || '', typeConverters.Location.fromTextSpan(this.client.toResource(item.file), item)));\r\n        }\r\n        return result;\r\n    }\r\n    static getLabel(item) {\r\n        let label = item.name;\r\n        if (item.kind === 'method' || item.kind === 'function') {\r\n            label += '()';\r\n        }\r\n        return label;\r\n    }\r\n    getDocument() {\r\n        // typescript wants to have a resource even when asking\r\n        // general questions so we check the active editor. If this\r\n        // doesn't match we take the first TS document.\r\n        const editor = vscode.window.activeTextEditor;\r\n        if (editor) {\r\n            const document = editor.document;\r\n            if (document && this.modeIds.indexOf(document.languageId) >= 0) {\r\n                return document;\r\n            }\r\n        }\r\n        const documents = vscode.workspace.textDocuments;\r\n        for (const document of documents) {\r\n            if (this.modeIds.indexOf(document.languageId) >= 0) {\r\n                return document;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nfunction register(client, modeIds) {\r\n    return vscode.languages.registerWorkspaceSymbolProvider(new TypeScriptWorkspaceSymbolProvider(client, modeIds));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=workspaceSymbols.js.map","/typescript-language-features/out/features/completions.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst PConst = require(\"../protocol.const\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst codeAction_1 = require(\"../utils/codeAction\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst memoize_1 = require(\"../utils/memoize\");\r\nconst Previewer = require(\"../utils/previewer\");\r\nconst snippetForFunctionCall_1 = require(\"../utils/snippetForFunctionCall\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nclass MyCompletionItem extends vscode.CompletionItem {\r\n    constructor(position, document, line, tsEntry, useCodeSnippetsOnMethodSuggest, completionContext, metadata) {\r\n        super(tsEntry.name, MyCompletionItem.convertKind(tsEntry.kind));\r\n        this.position = position;\r\n        this.document = document;\r\n        this.tsEntry = tsEntry;\r\n        this.completionContext = completionContext;\r\n        this.metadata = metadata;\r\n        if (tsEntry.source) {\r\n            // De-prioritze auto-imports\r\n            // https://github.com/Microsoft/vscode/issues/40311\r\n            this.sortText = '\\uffff' + tsEntry.sortText;\r\n        }\r\n        else {\r\n            this.sortText = tsEntry.sortText;\r\n        }\r\n        if (tsEntry.isRecommended) {\r\n            this.preselect = true;\r\n        }\r\n        this.position = position;\r\n        this.useCodeSnippet = useCodeSnippetsOnMethodSuggest && (this.kind === vscode.CompletionItemKind.Function || this.kind === vscode.CompletionItemKind.Method);\r\n        if (tsEntry.replacementSpan) {\r\n            this.range = typeConverters.Range.fromTextSpan(tsEntry.replacementSpan);\r\n            // Make sure we only replace a single line at most\r\n            if (!this.range.isSingleLine) {\r\n                this.range = new vscode.Range(this.range.start.line, this.range.start.character, this.range.start.line, line.length);\r\n            }\r\n        }\r\n        this.insertText = tsEntry.insertText;\r\n        // Set filterText for intelliCode and bracket accessors , but not for `this.` completions since it results in\r\n        // them being overly prioritized. #74164\r\n        this.filterText = tsEntry.insertText && !/^this\\./.test(tsEntry.insertText) ? tsEntry.insertText : undefined;\r\n        if (completionContext.isMemberCompletion && completionContext.dotAccessorContext) {\r\n            this.filterText = completionContext.dotAccessorContext.text + (this.insertText || this.label);\r\n            if (!this.range) {\r\n                this.range = completionContext.dotAccessorContext.range;\r\n                this.insertText = this.filterText;\r\n            }\r\n        }\r\n        if (tsEntry.kindModifiers) {\r\n            const kindModifiers = new Set(tsEntry.kindModifiers.split(/\\s+/g));\r\n            if (kindModifiers.has(PConst.KindModifiers.optional)) {\r\n                if (!this.insertText) {\r\n                    this.insertText = this.label;\r\n                }\r\n                if (!this.filterText) {\r\n                    this.filterText = this.label;\r\n                }\r\n                this.label += '?';\r\n            }\r\n            if (kindModifiers.has(PConst.KindModifiers.color)) {\r\n                this.kind = vscode.CompletionItemKind.Color;\r\n            }\r\n            if (tsEntry.kind === PConst.Kind.script) {\r\n                for (const extModifier of PConst.KindModifiers.fileExtensionKindModifiers) {\r\n                    if (kindModifiers.has(extModifier)) {\r\n                        if (tsEntry.name.toLowerCase().endsWith(extModifier)) {\r\n                            this.detail = tsEntry.name;\r\n                        }\r\n                        else {\r\n                            this.detail = tsEntry.name + extModifier;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.resolveRange(line);\r\n    }\r\n    resolveRange(line) {\r\n        if (this.range) {\r\n            return;\r\n        }\r\n        const wordRange = this.document.getWordRangeAtPosition(this.position);\r\n        if (wordRange) {\r\n            // TODO: Reverted next line due to https://github.com/Microsoft/vscode/issues/66187\r\n            // this.range = wordRange;\r\n        }\r\n        // Try getting longer, prefix based range for completions that span words\r\n        const text = line.slice(Math.max(0, this.position.character - this.label.length), this.position.character).toLowerCase();\r\n        const entryName = this.label.toLowerCase();\r\n        for (let i = entryName.length; i >= 0; --i) {\r\n            if (text.endsWith(entryName.substr(0, i)) && (!wordRange || wordRange.start.character > this.position.character - i)) {\r\n                this.range = new vscode.Range(new vscode.Position(this.position.line, Math.max(0, this.position.character - i)), this.position);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    static convertKind(kind) {\r\n        switch (kind) {\r\n            case PConst.Kind.primitiveType:\r\n            case PConst.Kind.keyword:\r\n                return vscode.CompletionItemKind.Keyword;\r\n            case PConst.Kind.const:\r\n                return vscode.CompletionItemKind.Constant;\r\n            case PConst.Kind.let:\r\n            case PConst.Kind.variable:\r\n            case PConst.Kind.localVariable:\r\n            case PConst.Kind.alias:\r\n                return vscode.CompletionItemKind.Variable;\r\n            case PConst.Kind.memberVariable:\r\n            case PConst.Kind.memberGetAccessor:\r\n            case PConst.Kind.memberSetAccessor:\r\n                return vscode.CompletionItemKind.Field;\r\n            case PConst.Kind.function:\r\n                return vscode.CompletionItemKind.Function;\r\n            case PConst.Kind.memberFunction:\r\n            case PConst.Kind.constructSignature:\r\n            case PConst.Kind.callSignature:\r\n            case PConst.Kind.indexSignature:\r\n                return vscode.CompletionItemKind.Method;\r\n            case PConst.Kind.enum:\r\n                return vscode.CompletionItemKind.Enum;\r\n            case PConst.Kind.module:\r\n            case PConst.Kind.externalModuleName:\r\n                return vscode.CompletionItemKind.Module;\r\n            case PConst.Kind.class:\r\n            case PConst.Kind.type:\r\n                return vscode.CompletionItemKind.Class;\r\n            case PConst.Kind.interface:\r\n                return vscode.CompletionItemKind.Interface;\r\n            case PConst.Kind.warning:\r\n                return vscode.CompletionItemKind.Text;\r\n            case PConst.Kind.script:\r\n                return vscode.CompletionItemKind.File;\r\n            case PConst.Kind.directory:\r\n                return vscode.CompletionItemKind.Folder;\r\n            case PConst.Kind.string:\r\n                return vscode.CompletionItemKind.Constant;\r\n        }\r\n        return vscode.CompletionItemKind.Property;\r\n    }\r\n    get commitCharacters() {\r\n        if (this.completionContext.isNewIdentifierLocation || !this.completionContext.isInValidCommitCharacterContext) {\r\n            return undefined;\r\n        }\r\n        const commitCharacters = [];\r\n        switch (this.tsEntry.kind) {\r\n            case PConst.Kind.memberGetAccessor:\r\n            case PConst.Kind.memberSetAccessor:\r\n            case PConst.Kind.constructSignature:\r\n            case PConst.Kind.callSignature:\r\n            case PConst.Kind.indexSignature:\r\n            case PConst.Kind.enum:\r\n            case PConst.Kind.interface:\r\n                commitCharacters.push('.', ';');\r\n                break;\r\n            case PConst.Kind.module:\r\n            case PConst.Kind.alias:\r\n            case PConst.Kind.const:\r\n            case PConst.Kind.let:\r\n            case PConst.Kind.variable:\r\n            case PConst.Kind.localVariable:\r\n            case PConst.Kind.memberVariable:\r\n            case PConst.Kind.class:\r\n            case PConst.Kind.function:\r\n            case PConst.Kind.memberFunction:\r\n            case PConst.Kind.keyword:\r\n            case PConst.Kind.parameter:\r\n                commitCharacters.push('.', ',', ';');\r\n                if (this.completionContext.enableCallCompletions) {\r\n                    commitCharacters.push('(');\r\n                }\r\n                break;\r\n        }\r\n        return commitCharacters.length === 0 ? undefined : commitCharacters;\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], MyCompletionItem.prototype, \"commitCharacters\", null);\r\nclass CompositeCommand {\r\n    constructor() {\r\n        this.id = CompositeCommand.ID;\r\n    }\r\n    execute(...commands) {\r\n        for (const command of commands) {\r\n            vscode.commands.executeCommand(command.command, ...(command.arguments || []));\r\n        }\r\n    }\r\n}\r\nCompositeCommand.ID = '_typescript.composite';\r\nclass CompletionAcceptedCommand {\r\n    constructor(onCompletionAccepted) {\r\n        this.onCompletionAccepted = onCompletionAccepted;\r\n        this.id = CompletionAcceptedCommand.ID;\r\n    }\r\n    execute(item) {\r\n        this.onCompletionAccepted(item);\r\n    }\r\n}\r\nCompletionAcceptedCommand.ID = '_typescript.onCompletionAccepted';\r\nclass ApplyCompletionCodeActionCommand {\r\n    constructor(client) {\r\n        this.client = client;\r\n        this.id = ApplyCompletionCodeActionCommand.ID;\r\n    }\r\n    async execute(_file, codeActions) {\r\n        if (codeActions.length === 0) {\r\n            return true;\r\n        }\r\n        if (codeActions.length === 1) {\r\n            return codeAction_1.applyCodeAction(this.client, codeActions[0], cancellation_1.nulToken);\r\n        }\r\n        const selection = await vscode.window.showQuickPick(codeActions.map((action, i) => ({\r\n            label: action.description,\r\n            description: '',\r\n            index: i\r\n        })), {\r\n            placeHolder: localize('selectCodeAction', 'Select code action to apply')\r\n        });\r\n        if (!selection) {\r\n            return false;\r\n        }\r\n        const action = codeActions[selection.index];\r\n        if (!action) {\r\n            return false;\r\n        }\r\n        return codeAction_1.applyCodeAction(this.client, action, cancellation_1.nulToken);\r\n    }\r\n}\r\nApplyCompletionCodeActionCommand.ID = '_typescript.applyCompletionCodeAction';\r\nvar CompletionConfiguration;\r\n(function (CompletionConfiguration) {\r\n    CompletionConfiguration.useCodeSnippetsOnMethodSuggest = 'suggest.completeFunctionCalls';\r\n    CompletionConfiguration.nameSuggestions = 'suggest.names';\r\n    CompletionConfiguration.pathSuggestions = 'suggest.paths';\r\n    CompletionConfiguration.autoImportSuggestions = 'suggest.autoImports';\r\n    function getConfigurationForResource(modeId, resource) {\r\n        const config = vscode.workspace.getConfiguration(modeId, resource);\r\n        return {\r\n            useCodeSnippetsOnMethodSuggest: config.get(CompletionConfiguration.useCodeSnippetsOnMethodSuggest, false),\r\n            pathSuggestions: config.get(CompletionConfiguration.pathSuggestions, true),\r\n            autoImportSuggestions: config.get(CompletionConfiguration.autoImportSuggestions, true),\r\n            nameSuggestions: config.get(CompletionConfiguration.nameSuggestions, true)\r\n        };\r\n    }\r\n    CompletionConfiguration.getConfigurationForResource = getConfigurationForResource;\r\n})(CompletionConfiguration || (CompletionConfiguration = {}));\r\nclass TypeScriptCompletionItemProvider {\r\n    constructor(client, modeId, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted) {\r\n        this.client = client;\r\n        this.modeId = modeId;\r\n        this.typingsStatus = typingsStatus;\r\n        this.fileConfigurationManager = fileConfigurationManager;\r\n        this.telemetryReporter = telemetryReporter;\r\n        commandManager.register(new ApplyCompletionCodeActionCommand(this.client));\r\n        commandManager.register(new CompositeCommand());\r\n        commandManager.register(new CompletionAcceptedCommand(onCompletionAccepted));\r\n    }\r\n    async provideCompletionItems(document, position, token, context) {\r\n        if (this.typingsStatus.isAcquiringTypings) {\r\n            return Promise.reject({\r\n                label: localize({ key: 'acquiringTypingsLabel', comment: ['Typings refers to the *.d.ts typings files that power our IntelliSense. It should not be localized'] }, 'Acquiring typings...'),\r\n                detail: localize({ key: 'acquiringTypingsDetail', comment: ['Typings refers to the *.d.ts typings files that power our IntelliSense. It should not be localized'] }, 'Acquiring typings definitions for IntelliSense.')\r\n            });\r\n        }\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return null;\r\n        }\r\n        const line = document.lineAt(position.line);\r\n        const completionConfiguration = CompletionConfiguration.getConfigurationForResource(this.modeId, document.uri);\r\n        if (!this.shouldTrigger(context, line, position)) {\r\n            return null;\r\n        }\r\n        await this.client.interruptGetErr(() => this.fileConfigurationManager.ensureConfigurationForDocument(document, token));\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(file, position),\r\n            includeExternalModuleExports: completionConfiguration.autoImportSuggestions,\r\n            includeInsertTextCompletions: true,\r\n            triggerCharacter: this.getTsTriggerCharacter(context),\r\n        };\r\n        let isNewIdentifierLocation = true;\r\n        let isIncomplete = false;\r\n        let isMemberCompletion = false;\r\n        let dotAccessorContext;\r\n        let entries;\r\n        let metadata;\r\n        if (this.client.apiVersion.gte(api_1.default.v300)) {\r\n            const startTime = Date.now();\r\n            let response;\r\n            try {\r\n                response = await this.client.interruptGetErr(() => this.client.execute('completionInfo', args, token));\r\n            }\r\n            finally {\r\n                const duration = Date.now() - startTime;\r\n                /* __GDPR__\r\n                    \"completions.execute\" : {\r\n                        \"duration\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                        \"type\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                        \"count\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                        \"${include}\": [\r\n                            \"${TypeScriptCommonProperties}\"\r\n                        ]\r\n                    }\r\n                */\r\n                this.telemetryReporter.logTelemetry('completions.execute', {\r\n                    duration: duration + '',\r\n                    type: response ? response.type : 'unknown',\r\n                    count: (response && response.type === 'response' && response.body ? response.body.entries.length : 0) + ''\r\n                });\r\n            }\r\n            if (response.type !== 'response' || !response.body) {\r\n                return null;\r\n            }\r\n            isNewIdentifierLocation = response.body.isNewIdentifierLocation;\r\n            isMemberCompletion = response.body.isMemberCompletion;\r\n            if (isMemberCompletion) {\r\n                const dotMatch = line.text.slice(0, position.character).match(/\\.\\s*$/) || undefined;\r\n                if (dotMatch) {\r\n                    const range = new vscode.Range(position.translate({ characterDelta: -dotMatch[0].length }), position);\r\n                    const text = document.getText(range);\r\n                    dotAccessorContext = { range, text };\r\n                }\r\n            }\r\n            isIncomplete = response.metadata && response.metadata.isIncomplete;\r\n            entries = response.body.entries;\r\n            metadata = response.metadata;\r\n        }\r\n        else {\r\n            const response = await this.client.interruptGetErr(() => this.client.execute('completions', args, token));\r\n            if (response.type !== 'response' || !response.body) {\r\n                return null;\r\n            }\r\n            entries = response.body;\r\n            metadata = response.metadata;\r\n        }\r\n        const isInValidCommitCharacterContext = this.isInValidCommitCharacterContext(document, position);\r\n        const items = entries\r\n            .filter(entry => !shouldExcludeCompletionEntry(entry, completionConfiguration))\r\n            .map(entry => new MyCompletionItem(position, document, line.text, entry, completionConfiguration.useCodeSnippetsOnMethodSuggest, {\r\n            isNewIdentifierLocation,\r\n            isMemberCompletion,\r\n            dotAccessorContext,\r\n            isInValidCommitCharacterContext,\r\n            enableCallCompletions: !completionConfiguration.useCodeSnippetsOnMethodSuggest\r\n        }, metadata));\r\n        return new vscode.CompletionList(items, isIncomplete);\r\n    }\r\n    getTsTriggerCharacter(context) {\r\n        // Workaround for https://github.com/Microsoft/TypeScript/issues/27321\r\n        if (context.triggerCharacter === '@'\r\n            && this.client.apiVersion.gte(api_1.default.v310) && this.client.apiVersion.lt(api_1.default.v320)) {\r\n            return undefined;\r\n        }\r\n        return context.triggerCharacter;\r\n    }\r\n    async resolveCompletionItem(item, token) {\r\n        if (!(item instanceof MyCompletionItem)) {\r\n            return undefined;\r\n        }\r\n        const filepath = this.client.toOpenedFilePath(item.document);\r\n        if (!filepath) {\r\n            return undefined;\r\n        }\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(filepath, item.position),\r\n            entryNames: [\r\n                item.tsEntry.source ? { name: item.tsEntry.name, source: item.tsEntry.source } : item.tsEntry.name\r\n            ]\r\n        };\r\n        const response = await this.client.interruptGetErr(() => this.client.execute('completionEntryDetails', args, token));\r\n        if (response.type !== 'response' || !response.body || !response.body.length) {\r\n            return item;\r\n        }\r\n        const detail = response.body[0];\r\n        if (!item.detail && detail.displayParts.length) {\r\n            item.detail = Previewer.plain(detail.displayParts);\r\n        }\r\n        item.documentation = this.getDocumentation(detail, item);\r\n        const codeAction = this.getCodeActions(detail, filepath);\r\n        const commands = [{\r\n                command: CompletionAcceptedCommand.ID,\r\n                title: '',\r\n                arguments: [item]\r\n            }];\r\n        if (codeAction.command) {\r\n            commands.push(codeAction.command);\r\n        }\r\n        item.additionalTextEdits = codeAction.additionalTextEdits;\r\n        if (detail && item.useCodeSnippet) {\r\n            const shouldCompleteFunction = await this.isValidFunctionCompletionContext(filepath, item.position, item.document, token);\r\n            if (shouldCompleteFunction) {\r\n                const { snippet, parameterCount } = snippetForFunctionCall_1.snippetForFunctionCall(item, detail.displayParts);\r\n                item.insertText = snippet;\r\n                if (parameterCount > 0) {\r\n                    commands.push({ title: 'triggerParameterHints', command: 'editor.action.triggerParameterHints' });\r\n                }\r\n            }\r\n        }\r\n        if (commands.length) {\r\n            if (commands.length === 1) {\r\n                item.command = commands[0];\r\n            }\r\n            else {\r\n                item.command = {\r\n                    command: CompositeCommand.ID,\r\n                    title: '',\r\n                    arguments: commands\r\n                };\r\n            }\r\n        }\r\n        return item;\r\n    }\r\n    getCodeActions(detail, filepath) {\r\n        if (!detail.codeActions || !detail.codeActions.length) {\r\n            return {};\r\n        }\r\n        // Try to extract out the additionalTextEdits for the current file.\r\n        // Also check if we still have to apply other workspace edits and commands\r\n        // using a vscode command\r\n        const additionalTextEdits = [];\r\n        let hasReaminingCommandsOrEdits = false;\r\n        for (const tsAction of detail.codeActions) {\r\n            if (tsAction.commands) {\r\n                hasReaminingCommandsOrEdits = true;\r\n            }\r\n            // Apply all edits in the current file using `additionalTextEdits`\r\n            if (tsAction.changes) {\r\n                for (const change of tsAction.changes) {\r\n                    if (change.fileName === filepath) {\r\n                        additionalTextEdits.push(...change.textChanges.map(typeConverters.TextEdit.fromCodeEdit));\r\n                    }\r\n                    else {\r\n                        hasReaminingCommandsOrEdits = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let command = undefined;\r\n        if (hasReaminingCommandsOrEdits) {\r\n            // Create command that applies all edits not in the current file.\r\n            command = {\r\n                title: '',\r\n                command: ApplyCompletionCodeActionCommand.ID,\r\n                arguments: [filepath, detail.codeActions.map((x) => ({\r\n                        commands: x.commands,\r\n                        description: x.description,\r\n                        changes: x.changes.filter(x => x.fileName !== filepath)\r\n                    }))]\r\n            };\r\n        }\r\n        return {\r\n            command,\r\n            additionalTextEdits: additionalTextEdits.length ? additionalTextEdits : undefined\r\n        };\r\n    }\r\n    isInValidCommitCharacterContext(document, position) {\r\n        if (this.client.apiVersion.lt(api_1.default.v320)) {\r\n            // Workaround for https://github.com/Microsoft/TypeScript/issues/27742\r\n            // Only enable dot completions when previous character not a dot preceeded by whitespace.\r\n            // Prevents incorrectly completing while typing spread operators.\r\n            if (position.character > 1) {\r\n                const preText = document.getText(new vscode.Range(position.line, 0, position.line, position.character));\r\n                return preText.match(/(\\s|^)\\.$/ig) === null;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    shouldTrigger(context, line, position) {\r\n        if (context.triggerCharacter && this.client.apiVersion.lt(api_1.default.v290)) {\r\n            if ((context.triggerCharacter === '\"' || context.triggerCharacter === '\\'')) {\r\n                // make sure we are in something that looks like the start of an import\r\n                const pre = line.text.slice(0, position.character);\r\n                if (!pre.match(/\\b(from|import)\\s*[\"']$/) && !pre.match(/\\b(import|require)\\(['\"]$/)) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (context.triggerCharacter === '/') {\r\n                // make sure we are in something that looks like an import path\r\n                const pre = line.text.slice(0, position.character);\r\n                if (!pre.match(/\\b(from|import)\\s*[\"'][^'\"]*$/) && !pre.match(/\\b(import|require)\\(['\"][^'\"]*$/)) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (context.triggerCharacter === '@') {\r\n                // make sure we are in something that looks like the start of a jsdoc comment\r\n                const pre = line.text.slice(0, position.character);\r\n                if (!pre.match(/^\\s*\\*[ ]?@/) && !pre.match(/\\/\\*\\*+[ ]?@/)) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (context.triggerCharacter === '<') {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getDocumentation(detail, item) {\r\n        const documentation = new vscode.MarkdownString();\r\n        if (detail.source) {\r\n            const importPath = `'${Previewer.plain(detail.source)}'`;\r\n            const autoImportLabel = localize('autoImportLabel', 'Auto import from {0}', importPath);\r\n            item.detail = `${autoImportLabel}\\n${item.detail}`;\r\n        }\r\n        Previewer.addMarkdownDocumentation(documentation, detail.documentation, detail.tags);\r\n        return documentation.value.length ? documentation : undefined;\r\n    }\r\n    async isValidFunctionCompletionContext(filepath, position, document, token) {\r\n        // Workaround for https://github.com/Microsoft/TypeScript/issues/12677\r\n        // Don't complete function calls inside of destructive assignments or imports\r\n        try {\r\n            const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);\r\n            const response = await this.client.execute('quickinfo', args, token);\r\n            if (response.type === 'response' && response.body) {\r\n                switch (response.body.kind) {\r\n                    case 'var':\r\n                    case 'let':\r\n                    case 'const':\r\n                    case 'alias':\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n        catch (_a) {\r\n            // Noop\r\n        }\r\n        // Don't complete function call if there is already something that looks like a function call\r\n        // https://github.com/Microsoft/vscode/issues/18131\r\n        const after = document.lineAt(position.line).text.slice(position.character);\r\n        return after.match(/^[a-z_$0-9]*\\s*\\(/gi) === null;\r\n    }\r\n}\r\nTypeScriptCompletionItemProvider.triggerCharacters = ['.', '\"', '\\'', '/', '@', '<'];\r\nfunction shouldExcludeCompletionEntry(element, completionConfiguration) {\r\n    return ((!completionConfiguration.nameSuggestions && element.kind === PConst.Kind.warning)\r\n        || (!completionConfiguration.pathSuggestions &&\r\n            (element.kind === PConst.Kind.directory || element.kind === PConst.Kind.script || element.kind === PConst.Kind.externalModuleName))\r\n        || (!completionConfiguration.autoImportSuggestions && element.hasAction));\r\n}\r\nfunction register(selector, modeId, client, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted) {\r\n    return new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'suggest.enabled', () => vscode.languages.registerCompletionItemProvider(selector, new TypeScriptCompletionItemProvider(client, modeId, typingsStatus, fileConfigurationManager, commandManager, telemetryReporter, onCompletionAccepted), ...TypeScriptCompletionItemProvider.triggerCharacters));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=completions.js.map","/typescript-language-features/out/utils/codeAction.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst typeConverters = require(\"./typeConverters\");\r\nfunction getEditForCodeAction(client, action) {\r\n    return action.changes && action.changes.length\r\n        ? typeConverters.WorkspaceEdit.fromFileCodeEdits(client, action.changes)\r\n        : undefined;\r\n}\r\nexports.getEditForCodeAction = getEditForCodeAction;\r\nasync function applyCodeAction(client, action, token) {\r\n    const workspaceEdit = getEditForCodeAction(client, action);\r\n    if (workspaceEdit) {\r\n        if (!(await vscode.workspace.applyEdit(workspaceEdit))) {\r\n            return false;\r\n        }\r\n    }\r\n    return applyCodeActionCommands(client, action.commands, token);\r\n}\r\nexports.applyCodeAction = applyCodeAction;\r\nasync function applyCodeActionCommands(client, commands, token) {\r\n    if (commands && commands.length) {\r\n        for (const command of commands) {\r\n            await client.execute('applyCodeActionCommand', { command }, token);\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.applyCodeActionCommands = applyCodeActionCommands;\r\n//# sourceMappingURL=codeAction.js.map","/typescript-language-features/out/utils/previewer.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nfunction getTagBodyText(tag) {\r\n    if (!tag.text) {\r\n        return undefined;\r\n    }\r\n    // Convert to markdown code block if it is not already one\r\n    function makeCodeblock(text) {\r\n        if (text.match(/^\\s*[~`]{3}/g)) {\r\n            return text;\r\n        }\r\n        return '```\\n' + text + '\\n```';\r\n    }\r\n    switch (tag.name) {\r\n        case 'example':\r\n            // check for caption tags, fix for #79704\r\n            const captionTagMatches = tag.text.match(/<caption>(.*?)<\\/caption>\\s*(\\r\\n|\\n)/);\r\n            if (captionTagMatches && captionTagMatches.index === 0) {\r\n                return captionTagMatches[1] + '\\n\\n' + makeCodeblock(tag.text.substr(captionTagMatches[0].length));\r\n            }\r\n            else {\r\n                return makeCodeblock(tag.text);\r\n            }\r\n        case 'default':\r\n            return makeCodeblock(tag.text);\r\n    }\r\n    return tag.text;\r\n}\r\nfunction getTagDocumentation(tag) {\r\n    switch (tag.name) {\r\n        case 'param':\r\n            const body = (tag.text || '').split(/^([\\w\\.]+)\\s*-?\\s*/);\r\n            if (body && body.length === 3) {\r\n                const param = body[1];\r\n                const doc = body[2];\r\n                const label = `*@${tag.name}* \\`${param}\\``;\r\n                if (!doc) {\r\n                    return label;\r\n                }\r\n                return label + (doc.match(/\\r\\n|\\n/g) ? '  \\n' + doc : `  ${doc}`);\r\n            }\r\n    }\r\n    // Generic tag\r\n    const label = `*@${tag.name}*`;\r\n    const text = getTagBodyText(tag);\r\n    if (!text) {\r\n        return label;\r\n    }\r\n    return label + (text.match(/\\r\\n|\\n/g) ? '  \\n' + text : `  ${text}`);\r\n}\r\nfunction plain(parts) {\r\n    if (!parts) {\r\n        return '';\r\n    }\r\n    return parts.map(part => part.text).join('');\r\n}\r\nexports.plain = plain;\r\nfunction tagsMarkdownPreview(tags) {\r\n    return (tags || [])\r\n        .map(getTagDocumentation)\r\n        .join('  \\n\\n');\r\n}\r\nexports.tagsMarkdownPreview = tagsMarkdownPreview;\r\nfunction markdownDocumentation(documentation, tags) {\r\n    const out = new vscode.MarkdownString();\r\n    addMarkdownDocumentation(out, documentation, tags);\r\n    return out;\r\n}\r\nexports.markdownDocumentation = markdownDocumentation;\r\nfunction addMarkdownDocumentation(out, documentation, tags) {\r\n    if (documentation) {\r\n        out.appendMarkdown(plain(documentation));\r\n    }\r\n    if (tags) {\r\n        const tagsPreview = tagsMarkdownPreview(tags);\r\n        if (tagsPreview) {\r\n            out.appendMarkdown('\\n\\n' + tagsPreview);\r\n        }\r\n    }\r\n    return out;\r\n}\r\nexports.addMarkdownDocumentation = addMarkdownDocumentation;\r\n//# sourceMappingURL=previewer.js.map","/typescript-language-features/out/utils/snippetForFunctionCall.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst PConst = require(\"../protocol.const\");\r\nfunction snippetForFunctionCall(item, displayParts) {\r\n    if (item.insertText && typeof item.insertText !== 'string') {\r\n        return { snippet: item.insertText, parameterCount: 0 };\r\n    }\r\n    const parameterListParts = getParameterListParts(displayParts);\r\n    const snippet = new vscode.SnippetString();\r\n    snippet.appendText(`${item.insertText || item.label}(`);\r\n    appendJoinedPlaceholders(snippet, parameterListParts.parts, ', ');\r\n    if (parameterListParts.hasOptionalParameters) {\r\n        snippet.appendTabstop();\r\n    }\r\n    snippet.appendText(')');\r\n    snippet.appendTabstop(0);\r\n    return { snippet, parameterCount: parameterListParts.parts.length + (parameterListParts.hasOptionalParameters ? 1 : 0) };\r\n}\r\nexports.snippetForFunctionCall = snippetForFunctionCall;\r\nfunction appendJoinedPlaceholders(snippet, parts, joiner) {\r\n    for (let i = 0; i < parts.length; ++i) {\r\n        const paramterPart = parts[i];\r\n        snippet.appendPlaceholder(paramterPart.text);\r\n        if (i !== parts.length - 1) {\r\n            snippet.appendText(joiner);\r\n        }\r\n    }\r\n}\r\nfunction getParameterListParts(displayParts) {\r\n    const parts = [];\r\n    let isInMethod = false;\r\n    let hasOptionalParameters = false;\r\n    let parenCount = 0;\r\n    let braceCount = 0;\r\n    outer: for (let i = 0; i < displayParts.length; ++i) {\r\n        const part = displayParts[i];\r\n        switch (part.kind) {\r\n            case PConst.DisplayPartKind.methodName:\r\n            case PConst.DisplayPartKind.functionName:\r\n            case PConst.DisplayPartKind.text:\r\n            case PConst.DisplayPartKind.propertyName:\r\n                if (parenCount === 0 && braceCount === 0) {\r\n                    isInMethod = true;\r\n                }\r\n                break;\r\n            case PConst.DisplayPartKind.parameterName:\r\n                if (parenCount === 1 && braceCount === 0 && isInMethod) {\r\n                    // Only take top level paren names\r\n                    const next = displayParts[i + 1];\r\n                    // Skip optional parameters\r\n                    const nameIsFollowedByOptionalIndicator = next && next.text === '?';\r\n                    if (!nameIsFollowedByOptionalIndicator) {\r\n                        parts.push(part);\r\n                    }\r\n                    hasOptionalParameters = hasOptionalParameters || nameIsFollowedByOptionalIndicator;\r\n                }\r\n                break;\r\n            case PConst.DisplayPartKind.punctuation:\r\n                if (part.text === '(') {\r\n                    ++parenCount;\r\n                }\r\n                else if (part.text === ')') {\r\n                    --parenCount;\r\n                    if (parenCount <= 0 && isInMethod) {\r\n                        break outer;\r\n                    }\r\n                }\r\n                else if (part.text === '...' && parenCount === 1) {\r\n                    // Found rest parmeter. Do not fill in any further arguments\r\n                    hasOptionalParameters = true;\r\n                    break outer;\r\n                }\r\n                else if (part.text === '{') {\r\n                    ++braceCount;\r\n                }\r\n                else if (part.text === '}') {\r\n                    --braceCount;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return { hasOptionalParameters, parts };\r\n}\r\n//# sourceMappingURL=snippetForFunctionCall.js.map","/typescript-language-features/out/features/definitions.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst definitionProviderBase_1 = require(\"./definitionProviderBase\");\r\nclass TypeScriptDefinitionProvider extends definitionProviderBase_1.default {\r\n    constructor(client) {\r\n        super(client);\r\n    }\r\n    async provideDefinition(document, position, token) {\r\n        if (this.client.apiVersion.gte(api_1.default.v270)) {\r\n            const filepath = this.client.toOpenedFilePath(document);\r\n            if (!filepath) {\r\n                return undefined;\r\n            }\r\n            const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);\r\n            const response = await this.client.execute('definitionAndBoundSpan', args, token);\r\n            if (response.type !== 'response' || !response.body) {\r\n                return undefined;\r\n            }\r\n            const span = response.body.textSpan ? typeConverters.Range.fromTextSpan(response.body.textSpan) : undefined;\r\n            return response.body.definitions\r\n                .map((location) => {\r\n                const target = typeConverters.Location.fromTextSpan(this.client.toResource(location.file), location);\r\n                if (location.contextStart) {\r\n                    return {\r\n                        originSelectionRange: span,\r\n                        targetRange: typeConverters.Range.fromLocations(location.contextStart, location.contextEnd),\r\n                        targetUri: target.uri,\r\n                        targetSelectionRange: target.range,\r\n                    };\r\n                }\r\n                return {\r\n                    originSelectionRange: span,\r\n                    targetRange: target.range,\r\n                    targetUri: target.uri\r\n                };\r\n            });\r\n        }\r\n        return this.getSymbolLocations('definition', document, position, token);\r\n    }\r\n}\r\nexports.default = TypeScriptDefinitionProvider;\r\nfunction register(selector, client) {\r\n    return vscode.languages.registerDefinitionProvider(selector, new TypeScriptDefinitionProvider(client));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=definitions.js.map","/typescript-language-features/out/features/definitionProviderBase.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptDefinitionProviderBase {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async getSymbolLocations(definitionType, document, position, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(file, position);\r\n        const response = await this.client.execute(definitionType, args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        return response.body.map(location => typeConverters.Location.fromTextSpan(this.client.toResource(location.file), location));\r\n    }\r\n}\r\nexports.default = TypeScriptDefinitionProviderBase;\r\n//# sourceMappingURL=definitionProviderBase.js.map","/typescript-language-features/out/features/directiveCommentCompletions.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst localize = nls.loadMessageBundle();\r\nconst directives = [\r\n    {\r\n        value: '@ts-check',\r\n        description: localize('ts-check', \"Enables semantic checking in a JavaScript file. Must be at the top of a file.\")\r\n    }, {\r\n        value: '@ts-nocheck',\r\n        description: localize('ts-nocheck', \"Disables semantic checking in a JavaScript file. Must be at the top of a file.\")\r\n    }, {\r\n        value: '@ts-ignore',\r\n        description: localize('ts-ignore', \"Suppresses @ts-check errors on the next line of a file.\")\r\n    }\r\n];\r\nclass DirectiveCommentCompletionProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    provideCompletionItems(document, position, _token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        const line = document.lineAt(position.line).text;\r\n        const prefix = line.slice(0, position.character);\r\n        const match = prefix.match(/^\\s*\\/\\/+\\s?(@[a-zA-Z\\-]*)?$/);\r\n        if (match) {\r\n            return directives.map(directive => {\r\n                const item = new vscode.CompletionItem(directive.value, vscode.CompletionItemKind.Snippet);\r\n                item.detail = directive.description;\r\n                item.range = new vscode.Range(position.line, Math.max(0, position.character - (match[1] ? match[1].length : 0)), position.line, position.character);\r\n                return item;\r\n            });\r\n        }\r\n        return [];\r\n    }\r\n}\r\nDirectiveCommentCompletionProvider.minVersion = api_1.default.v230;\r\nfunction register(selector, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, DirectiveCommentCompletionProvider.minVersion, () => {\r\n        return vscode.languages.registerCompletionItemProvider(selector, new DirectiveCommentCompletionProvider(client), '@');\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=directiveCommentCompletions.js.map","/typescript-language-features/out/features/documentHighlight.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst arrays_1 = require(\"../utils/arrays\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptDocumentHighlightProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideDocumentHighlights(document, position, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(file, position),\r\n            filesToSearch: [file]\r\n        };\r\n        const response = await this.client.execute('documentHighlights', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return [];\r\n        }\r\n        return arrays_1.flatten(response.body\r\n            .filter(highlight => highlight.file === file)\r\n            .map(convertDocumentHighlight));\r\n    }\r\n}\r\nfunction convertDocumentHighlight(highlight) {\r\n    return highlight.highlightSpans.map(span => new vscode.DocumentHighlight(typeConverters.Range.fromTextSpan(span), span.kind === 'writtenReference' ? vscode.DocumentHighlightKind.Write : vscode.DocumentHighlightKind.Read));\r\n}\r\nfunction register(selector, client) {\r\n    return vscode.languages.registerDocumentHighlightProvider(selector, new TypeScriptDocumentHighlightProvider(client));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=documentHighlight.js.map","/typescript-language-features/out/features/documentSymbol.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst PConst = require(\"../protocol.const\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst getSymbolKind = (kind) => {\r\n    switch (kind) {\r\n        case PConst.Kind.module: return vscode.SymbolKind.Module;\r\n        case PConst.Kind.class: return vscode.SymbolKind.Class;\r\n        case PConst.Kind.enum: return vscode.SymbolKind.Enum;\r\n        case PConst.Kind.interface: return vscode.SymbolKind.Interface;\r\n        case PConst.Kind.memberFunction: return vscode.SymbolKind.Method;\r\n        case PConst.Kind.memberVariable: return vscode.SymbolKind.Property;\r\n        case PConst.Kind.memberGetAccessor: return vscode.SymbolKind.Property;\r\n        case PConst.Kind.memberSetAccessor: return vscode.SymbolKind.Property;\r\n        case PConst.Kind.variable: return vscode.SymbolKind.Variable;\r\n        case PConst.Kind.const: return vscode.SymbolKind.Variable;\r\n        case PConst.Kind.localVariable: return vscode.SymbolKind.Variable;\r\n        case PConst.Kind.function: return vscode.SymbolKind.Function;\r\n        case PConst.Kind.localFunction: return vscode.SymbolKind.Function;\r\n    }\r\n    return vscode.SymbolKind.Variable;\r\n};\r\nclass TypeScriptDocumentSymbolProvider {\r\n    constructor(client, cachedResponse) {\r\n        this.client = client;\r\n        this.cachedResponse = cachedResponse;\r\n    }\r\n    async provideDocumentSymbols(document, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const args = { file };\r\n        const response = await this.cachedResponse.execute(document, () => this.client.execute('navtree', args, token));\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        let tree = response.body;\r\n        if (tree && tree.childItems) {\r\n            // The root represents the file. Ignore this when showing in the UI\r\n            const result = [];\r\n            tree.childItems.forEach(item => TypeScriptDocumentSymbolProvider.convertNavTree(document.uri, result, item));\r\n            return result;\r\n        }\r\n        return undefined;\r\n    }\r\n    static convertNavTree(resource, bucket, item) {\r\n        let shouldInclude = TypeScriptDocumentSymbolProvider.shouldInclueEntry(item);\r\n        const children = new Set(item.childItems || []);\r\n        for (const span of item.spans) {\r\n            const range = typeConverters.Range.fromTextSpan(span);\r\n            const symbolInfo = new vscode.DocumentSymbol(item.text, '', getSymbolKind(item.kind), range, range);\r\n            for (const child of children) {\r\n                if (child.spans.some(span => !!range.intersection(typeConverters.Range.fromTextSpan(span)))) {\r\n                    const includedChild = TypeScriptDocumentSymbolProvider.convertNavTree(resource, symbolInfo.children, child);\r\n                    shouldInclude = shouldInclude || includedChild;\r\n                    children.delete(child);\r\n                }\r\n            }\r\n            if (shouldInclude) {\r\n                bucket.push(symbolInfo);\r\n            }\r\n        }\r\n        return shouldInclude;\r\n    }\r\n    static shouldInclueEntry(item) {\r\n        if (item.kind === PConst.Kind.alias) {\r\n            return false;\r\n        }\r\n        return !!(item.text && item.text !== '<function>' && item.text !== '<class>');\r\n    }\r\n}\r\nfunction register(selector, client, cachedResponse) {\r\n    return vscode.languages.registerDocumentSymbolProvider(selector, new TypeScriptDocumentSymbolProvider(client, cachedResponse), { label: 'TypeScript' });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=documentSymbol.js.map","/typescript-language-features/out/features/folding.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptFoldingProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideFoldingRanges(document, _context, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return;\r\n        }\r\n        const args = { file };\r\n        const response = await this.client.execute('getOutliningSpans', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return;\r\n        }\r\n        return response.body\r\n            .map(span => this.convertOutliningSpan(span, document))\r\n            .filter(foldingRange => !!foldingRange);\r\n    }\r\n    convertOutliningSpan(span, document) {\r\n        const range = typeConverters.Range.fromTextSpan(span.textSpan);\r\n        const kind = TypeScriptFoldingProvider.getFoldingRangeKind(span);\r\n        // Workaround for #49904\r\n        if (span.kind === 'comment') {\r\n            const line = document.lineAt(range.start.line).text;\r\n            if (line.match(/\\/\\/\\s*#endregion/gi)) {\r\n                return undefined;\r\n            }\r\n        }\r\n        const start = range.start.line;\r\n        // workaround for #47240\r\n        const end = (range.end.character > 0 && new Set(['}', ']']).has(document.getText(new vscode.Range(range.end.translate(0, -1), range.end))))\r\n            ? Math.max(range.end.line - 1, range.start.line)\r\n            : range.end.line;\r\n        return new vscode.FoldingRange(start, end, kind);\r\n    }\r\n    static getFoldingRangeKind(span) {\r\n        switch (span.kind) {\r\n            case 'comment': return vscode.FoldingRangeKind.Comment;\r\n            case 'region': return vscode.FoldingRangeKind.Region;\r\n            case 'imports': return vscode.FoldingRangeKind.Imports;\r\n            case 'code':\r\n            default: return undefined;\r\n        }\r\n    }\r\n}\r\nTypeScriptFoldingProvider.minVersion = api_1.default.v280;\r\nfunction register(selector, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptFoldingProvider.minVersion, () => {\r\n        return vscode.languages.registerFoldingRangeProvider(selector, new TypeScriptFoldingProvider(client));\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=folding.js.map","/typescript-language-features/out/features/formatting.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptFormattingProvider {\r\n    constructor(client, formattingOptionsManager) {\r\n        this.client = client;\r\n        this.formattingOptionsManager = formattingOptionsManager;\r\n    }\r\n    async provideDocumentRangeFormattingEdits(document, range, options, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        await this.formattingOptionsManager.ensureConfigurationOptions(document, options, token);\r\n        const args = typeConverters.Range.toFormattingRequestArgs(file, range);\r\n        const response = await this.client.execute('format', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        return response.body.map(typeConverters.TextEdit.fromCodeEdit);\r\n    }\r\n    async provideOnTypeFormattingEdits(document, position, ch, options, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        await this.formattingOptionsManager.ensureConfigurationOptions(document, options, token);\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(file, position),\r\n            key: ch\r\n        };\r\n        const response = await this.client.execute('formatonkey', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return [];\r\n        }\r\n        const edits = response.body;\r\n        const result = [];\r\n        if (!edits) {\r\n            return result;\r\n        }\r\n        for (const edit of edits) {\r\n            const textEdit = typeConverters.TextEdit.fromCodeEdit(edit);\r\n            const range = textEdit.range;\r\n            // Work around for https://github.com/Microsoft/TypeScript/issues/6700.\r\n            // Check if we have an edit at the beginning of the line which only removes white spaces and leaves\r\n            // an empty line. Drop those edits\r\n            if (range.start.character === 0 && range.start.line === range.end.line && textEdit.newText === '') {\r\n                const lText = document.lineAt(range.start.line).text;\r\n                // If the edit leaves something on the line keep the edit (note that the end character is exclusive).\r\n                // Keep it also if it removes something else than whitespace\r\n                if (lText.trim().length > 0 || lText.length > range.end.character) {\r\n                    result.push(textEdit);\r\n                }\r\n            }\r\n            else {\r\n                result.push(textEdit);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction register(selector, modeId, client, fileConfigurationManager) {\r\n    return new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'format.enable', () => {\r\n        const formattingProvider = new TypeScriptFormattingProvider(client, fileConfigurationManager);\r\n        return vscode.Disposable.from(vscode.languages.registerOnTypeFormattingEditProvider(selector, formattingProvider, ';', '}', '\\n'), vscode.languages.registerDocumentRangeFormattingEditProvider(selector, formattingProvider));\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=formatting.js.map","/typescript-language-features/out/features/hover.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst previewer_1 = require(\"../utils/previewer\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptHoverProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideHover(document, position, token) {\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return undefined;\r\n        }\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);\r\n        const response = await this.client.interruptGetErr(() => this.client.execute('quickinfo', args, token));\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        return new vscode.Hover(TypeScriptHoverProvider.getContents(response.body), typeConverters.Range.fromTextSpan(response.body));\r\n    }\r\n    static getContents(data) {\r\n        const parts = [];\r\n        if (data.displayString) {\r\n            parts.push({ language: 'typescript', value: data.displayString });\r\n        }\r\n        const tags = previewer_1.tagsMarkdownPreview(data.tags);\r\n        parts.push(data.documentation + (tags ? '\\n\\n' + tags : ''));\r\n        return parts;\r\n    }\r\n}\r\nfunction register(selector, client) {\r\n    return vscode.languages.registerHoverProvider(selector, new TypeScriptHoverProvider(client));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=hover.js.map","/typescript-language-features/out/features/implementations.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst definitionProviderBase_1 = require(\"./definitionProviderBase\");\r\nclass TypeScriptImplementationProvider extends definitionProviderBase_1.default {\r\n    provideImplementation(document, position, token) {\r\n        return this.getSymbolLocations('implementation', document, position, token);\r\n    }\r\n}\r\nTypeScriptImplementationProvider.minVersion = api_1.default.v220;\r\nfunction register(selector, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptImplementationProvider.minVersion, () => {\r\n        return vscode.languages.registerImplementationProvider(selector, new TypeScriptImplementationProvider(client));\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=implementations.js.map","/typescript-language-features/out/features/implementationsCodeLens.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst PConst = require(\"../protocol.const\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst baseCodeLensProvider_1 = require(\"./baseCodeLensProvider\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nclass TypeScriptImplementationsCodeLensProvider extends baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider {\r\n    async resolveCodeLens(inputCodeLens, token) {\r\n        const codeLens = inputCodeLens;\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(codeLens.file, codeLens.range.start);\r\n        const response = await this.client.execute('implementation', args, token, { lowPriority: true });\r\n        if (response.type !== 'response' || !response.body) {\r\n            codeLens.command = response.type === 'cancelled'\r\n                ? baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider.cancelledCommand\r\n                : baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider.errorCommand;\r\n            return codeLens;\r\n        }\r\n        const locations = response.body\r\n            .map(reference => \r\n        // Only take first line on implementation: https://github.com/Microsoft/vscode/issues/23924\r\n        new vscode.Location(this.client.toResource(reference.file), reference.start.line === reference.end.line\r\n            ? typeConverters.Range.fromTextSpan(reference)\r\n            : new vscode.Range(typeConverters.Position.fromLocation(reference.start), new vscode.Position(reference.start.line, 0))))\r\n            // Exclude original from implementations\r\n            .filter(location => !(location.uri.toString() === codeLens.document.toString() &&\r\n            location.range.start.line === codeLens.range.start.line &&\r\n            location.range.start.character === codeLens.range.start.character));\r\n        codeLens.command = this.getCommand(locations, codeLens);\r\n        return codeLens;\r\n    }\r\n    getCommand(locations, codeLens) {\r\n        return {\r\n            title: this.getTitle(locations),\r\n            command: locations.length ? 'editor.action.showReferences' : '',\r\n            arguments: [codeLens.document, codeLens.range.start, locations]\r\n        };\r\n    }\r\n    getTitle(locations) {\r\n        return locations.length === 1\r\n            ? localize('oneImplementationLabel', '1 implementation')\r\n            : localize('manyImplementationLabel', '{0} implementations', locations.length);\r\n    }\r\n    extractSymbol(document, item, _parent) {\r\n        switch (item.kind) {\r\n            case PConst.Kind.interface:\r\n                return baseCodeLensProvider_1.getSymbolRange(document, item);\r\n            case PConst.Kind.class:\r\n            case PConst.Kind.memberFunction:\r\n            case PConst.Kind.memberVariable:\r\n            case PConst.Kind.memberGetAccessor:\r\n            case PConst.Kind.memberSetAccessor:\r\n                if (item.kindModifiers.match(/\\babstract\\b/g)) {\r\n                    return baseCodeLensProvider_1.getSymbolRange(document, item);\r\n                }\r\n                break;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nTypeScriptImplementationsCodeLensProvider.minVersion = api_1.default.v220;\r\nexports.default = TypeScriptImplementationsCodeLensProvider;\r\nfunction register(selector, modeId, client, cachedResponse) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptImplementationsCodeLensProvider.minVersion, () => new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'implementationsCodeLens.enabled', () => {\r\n        return vscode.languages.registerCodeLensProvider(selector, new TypeScriptImplementationsCodeLensProvider(client, cachedResponse));\r\n    }));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=implementationsCodeLens.js.map","/typescript-language-features/out/features/baseCodeLensProvider.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst regexp_1 = require(\"../utils/regexp\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nclass ReferencesCodeLens extends vscode.CodeLens {\r\n    constructor(document, file, range) {\r\n        super(range);\r\n        this.document = document;\r\n        this.file = file;\r\n    }\r\n}\r\nexports.ReferencesCodeLens = ReferencesCodeLens;\r\nclass TypeScriptBaseCodeLensProvider {\r\n    constructor(client, cachedResponse) {\r\n        this.client = client;\r\n        this.cachedResponse = cachedResponse;\r\n        this.onDidChangeCodeLensesEmitter = new vscode.EventEmitter();\r\n    }\r\n    get onDidChangeCodeLenses() {\r\n        return this.onDidChangeCodeLensesEmitter.event;\r\n    }\r\n    async provideCodeLenses(document, token) {\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return [];\r\n        }\r\n        const response = await this.cachedResponse.execute(document, () => this.client.execute('navtree', { file: filepath }, token));\r\n        if (response.type !== 'response') {\r\n            return [];\r\n        }\r\n        const tree = response.body;\r\n        const referenceableSpans = [];\r\n        if (tree && tree.childItems) {\r\n            tree.childItems.forEach(item => this.walkNavTree(document, item, null, referenceableSpans));\r\n        }\r\n        return referenceableSpans.map(span => new ReferencesCodeLens(document.uri, filepath, span));\r\n    }\r\n    walkNavTree(document, item, parent, results) {\r\n        if (!item) {\r\n            return;\r\n        }\r\n        const range = this.extractSymbol(document, item, parent);\r\n        if (range) {\r\n            results.push(range);\r\n        }\r\n        (item.childItems || []).forEach(child => this.walkNavTree(document, child, item, results));\r\n    }\r\n}\r\nTypeScriptBaseCodeLensProvider.cancelledCommand = {\r\n    // Cancellation is not an error. Just show nothing until we can properly re-compute the code lens\r\n    title: '',\r\n    command: ''\r\n};\r\nTypeScriptBaseCodeLensProvider.errorCommand = {\r\n    title: localize('referenceErrorLabel', 'Could not determine references'),\r\n    command: ''\r\n};\r\nexports.TypeScriptBaseCodeLensProvider = TypeScriptBaseCodeLensProvider;\r\nfunction getSymbolRange(document, item) {\r\n    // TS 3.0+ provides a span for just the symbol\r\n    if (item.nameSpan) {\r\n        return typeConverters.Range.fromTextSpan(item.nameSpan);\r\n    }\r\n    // In older versions, we have to calculate this manually. See #23924\r\n    const span = item.spans && item.spans[0];\r\n    if (!span) {\r\n        return null;\r\n    }\r\n    const range = typeConverters.Range.fromTextSpan(span);\r\n    const text = document.getText(range);\r\n    const identifierMatch = new RegExp(`^(.*?(\\\\b|\\\\W))${regexp_1.escapeRegExp(item.text || '')}(\\\\b|\\\\W)`, 'gm');\r\n    const match = identifierMatch.exec(text);\r\n    const prefixLength = match ? match.index + match[1].length : 0;\r\n    const startOffset = document.offsetAt(new vscode.Position(range.start.line, range.start.character)) + prefixLength;\r\n    return new vscode.Range(document.positionAt(startOffset), document.positionAt(startOffset + item.text.length));\r\n}\r\nexports.getSymbolRange = getSymbolRange;\r\n//# sourceMappingURL=baseCodeLensProvider.js.map","/typescript-language-features/out/features/jsDocCompletions.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nconst defaultJsDoc = new vscode.SnippetString(`/**\\n * $0\\n */`);\r\nclass JsDocCompletionItem extends vscode.CompletionItem {\r\n    constructor(document, position) {\r\n        super('/** */', vscode.CompletionItemKind.Snippet);\r\n        this.document = document;\r\n        this.position = position;\r\n        this.detail = localize('typescript.jsDocCompletionItem.documentation', 'JSDoc comment');\r\n        this.sortText = '\\0';\r\n        const line = document.lineAt(position.line).text;\r\n        const prefix = line.slice(0, position.character).match(/\\/\\**\\s*$/);\r\n        const suffix = line.slice(position.character).match(/^\\s*\\**\\//);\r\n        const start = position.translate(0, prefix ? -prefix[0].length : 0);\r\n        this.range = new vscode.Range(start, position.translate(0, suffix ? suffix[0].length : 0));\r\n    }\r\n}\r\nclass JsDocCompletionProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideCompletionItems(document, position, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        if (!this.isPotentiallyValidDocCompletionPosition(document, position)) {\r\n            return undefined;\r\n        }\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(file, position);\r\n        const response = await this.client.execute('docCommentTemplate', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        const item = new JsDocCompletionItem(document, position);\r\n        // Workaround for #43619\r\n        // docCommentTemplate previously returned undefined for empty jsdoc templates.\r\n        // TS 2.7 now returns a single line doc comment, which breaks indentation.\r\n        if (response.body.newText === '/** */') {\r\n            item.insertText = defaultJsDoc;\r\n        }\r\n        else {\r\n            item.insertText = templateToSnippet(response.body.newText);\r\n        }\r\n        return [item];\r\n    }\r\n    isPotentiallyValidDocCompletionPosition(document, position) {\r\n        // Only show the JSdoc completion when the everything before the cursor is whitespace\r\n        // or could be the opening of a comment\r\n        const line = document.lineAt(position.line).text;\r\n        const prefix = line.slice(0, position.character);\r\n        if (prefix.match(/^\\s*$|\\/\\*\\*\\s*$|^\\s*\\/\\*\\*+\\s*$/) === null) {\r\n            return false;\r\n        }\r\n        // And everything after is possibly a closing comment or more whitespace\r\n        const suffix = line.slice(position.character);\r\n        return suffix.match(/^\\s*\\*+\\//) !== null;\r\n    }\r\n}\r\nfunction templateToSnippet(template) {\r\n    // TODO: use append placeholder\r\n    let snippetIndex = 1;\r\n    template = template.replace(/\\$/g, '\\\\$');\r\n    template = template.replace(/^\\s*(?=(\\/|[ ]\\*))/gm, '');\r\n    template = template.replace(/^(\\/\\*\\*\\s*\\*[ ]*)$/m, (x) => x + `\\$0`);\r\n    template = template.replace(/\\* @param([ ]\\{\\S+\\})?\\s+(\\S+)\\s*$/gm, (_param, type, post) => {\r\n        let out = '* @param ';\r\n        if (type === ' {any}' || type === ' {*}') {\r\n            out += `{\\$\\{${snippetIndex++}:*\\}} `;\r\n        }\r\n        else if (type) {\r\n            out += type + ' ';\r\n        }\r\n        out += post + ` \\${${snippetIndex++}}`;\r\n        return out;\r\n    });\r\n    return new vscode.SnippetString(template);\r\n}\r\nexports.templateToSnippet = templateToSnippet;\r\nfunction register(selector, modeId, client) {\r\n    return new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'suggest.completeJSDocs', () => {\r\n        return vscode.languages.registerCompletionItemProvider(selector, new JsDocCompletionProvider(client), '*');\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=jsDocCompletions.js.map","/typescript-language-features/out/features/organizeImports.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeconverts = require(\"../utils/typeConverters\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst localize = nls.loadMessageBundle();\r\nclass OrganizeImportsCommand {\r\n    constructor(client, telemetryReporter) {\r\n        this.client = client;\r\n        this.telemetryReporter = telemetryReporter;\r\n        this.id = OrganizeImportsCommand.Id;\r\n    }\r\n    async execute(file) {\r\n        /* __GDPR__\r\n            \"organizeImports.execute\" : {\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        this.telemetryReporter.logTelemetry('organizeImports.execute', {});\r\n        const args = {\r\n            scope: {\r\n                type: 'file',\r\n                args: {\r\n                    file\r\n                }\r\n            }\r\n        };\r\n        const response = await this.client.interruptGetErr(() => this.client.execute('organizeImports', args, cancellation_1.nulToken));\r\n        if (response.type !== 'response' || !response.body) {\r\n            return false;\r\n        }\r\n        const edits = typeconverts.WorkspaceEdit.fromFileCodeEdits(this.client, response.body);\r\n        return vscode.workspace.applyEdit(edits);\r\n    }\r\n}\r\nOrganizeImportsCommand.Id = '_typescript.organizeImports';\r\nclass OrganizeImportsCodeActionProvider {\r\n    constructor(client, commandManager, fileConfigManager, telemetryReporter) {\r\n        this.client = client;\r\n        this.fileConfigManager = fileConfigManager;\r\n        this.metadata = {\r\n            providedCodeActionKinds: [vscode.CodeActionKind.SourceOrganizeImports]\r\n        };\r\n        commandManager.register(new OrganizeImportsCommand(client, telemetryReporter));\r\n    }\r\n    provideCodeActions(document, _range, context, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        if (!context.only || !context.only.contains(vscode.CodeActionKind.SourceOrganizeImports)) {\r\n            return [];\r\n        }\r\n        this.fileConfigManager.ensureConfigurationForDocument(document, token);\r\n        const action = new vscode.CodeAction(localize('organizeImportsAction.title', \"Organize Imports\"), vscode.CodeActionKind.SourceOrganizeImports);\r\n        action.command = { title: '', command: OrganizeImportsCommand.Id, arguments: [file] };\r\n        return [action];\r\n    }\r\n}\r\nOrganizeImportsCodeActionProvider.minVersion = api_1.default.v280;\r\nexports.OrganizeImportsCodeActionProvider = OrganizeImportsCodeActionProvider;\r\nfunction register(selector, client, commandManager, fileConfigurationManager, telemetryReporter) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, OrganizeImportsCodeActionProvider.minVersion, () => {\r\n        const organizeImportsProvider = new OrganizeImportsCodeActionProvider(client, commandManager, fileConfigurationManager, telemetryReporter);\r\n        return vscode.languages.registerCodeActionsProvider(selector, organizeImportsProvider, organizeImportsProvider.metadata);\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=organizeImports.js.map","/typescript-language-features/out/features/quickFix.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst codeAction_1 = require(\"../utils/codeAction\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst memoize_1 = require(\"../utils/memoize\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nclass ApplyCodeActionCommand {\r\n    constructor(client, telemetryReporter) {\r\n        this.client = client;\r\n        this.telemetryReporter = telemetryReporter;\r\n        this.id = ApplyCodeActionCommand.ID;\r\n    }\r\n    async execute(action) {\r\n        /* __GDPR__\r\n            \"quickFix.execute\" : {\r\n                \"fixName\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        this.telemetryReporter.logTelemetry('quickFix.execute', {\r\n            fixName: action.fixName\r\n        });\r\n        return codeAction_1.applyCodeActionCommands(this.client, action.commands, cancellation_1.nulToken);\r\n    }\r\n}\r\nApplyCodeActionCommand.ID = '_typescript.applyCodeActionCommand';\r\nclass ApplyFixAllCodeAction {\r\n    constructor(client, telemetryReporter) {\r\n        this.client = client;\r\n        this.telemetryReporter = telemetryReporter;\r\n        this.id = ApplyFixAllCodeAction.ID;\r\n    }\r\n    async execute(file, tsAction) {\r\n        if (!tsAction.fixId) {\r\n            return;\r\n        }\r\n        /* __GDPR__\r\n            \"quickFixAll.execute\" : {\r\n                \"fixName\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        this.telemetryReporter.logTelemetry('quickFixAll.execute', {\r\n            fixName: tsAction.fixName\r\n        });\r\n        const args = {\r\n            scope: {\r\n                type: 'file',\r\n                args: { file }\r\n            },\r\n            fixId: tsAction.fixId,\r\n        };\r\n        const response = await this.client.execute('getCombinedCodeFix', args, cancellation_1.nulToken);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        const edit = typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, response.body.changes);\r\n        await vscode.workspace.applyEdit(edit);\r\n        await codeAction_1.applyCodeActionCommands(this.client, response.body.commands, cancellation_1.nulToken);\r\n    }\r\n}\r\nApplyFixAllCodeAction.ID = '_typescript.applyFixAllCodeAction';\r\n/**\r\n * Unique set of diagnostics keyed on diagnostic range and error code.\r\n */\r\nclass DiagnosticsSet {\r\n    constructor(_values) {\r\n        this._values = _values;\r\n    }\r\n    static from(diagnostics) {\r\n        const values = new Map();\r\n        for (const diagnostic of diagnostics) {\r\n            values.set(DiagnosticsSet.key(diagnostic), diagnostic);\r\n        }\r\n        return new DiagnosticsSet(values);\r\n    }\r\n    static key(diagnostic) {\r\n        const { start, end } = diagnostic.range;\r\n        return `${diagnostic.code}-${start.line},${start.character}-${end.line},${end.character}`;\r\n    }\r\n    get values() {\r\n        return this._values.values();\r\n    }\r\n    get size() {\r\n        return this._values.size;\r\n    }\r\n}\r\nclass CodeActionSet {\r\n    constructor() {\r\n        this._actions = new Set();\r\n        this._fixAllActions = new Map();\r\n    }\r\n    get values() {\r\n        return this._actions;\r\n    }\r\n    addAction(action) {\r\n        this._actions.add(action);\r\n    }\r\n    addFixAllAction(fixId, action) {\r\n        const existing = this._fixAllActions.get(fixId);\r\n        if (existing) {\r\n            // reinsert action at back of actions list\r\n            this._actions.delete(existing);\r\n        }\r\n        this.addAction(action);\r\n        this._fixAllActions.set(fixId, action);\r\n    }\r\n    hasFixAllAction(fixId) {\r\n        return this._fixAllActions.has(fixId);\r\n    }\r\n}\r\nclass SupportedCodeActionProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async getFixableDiagnosticsForContext(context) {\r\n        const fixableCodes = await this.fixableDiagnosticCodes;\r\n        return DiagnosticsSet.from(context.diagnostics.filter(diagnostic => typeof diagnostic.code !== 'undefined' && fixableCodes.has(diagnostic.code + '')));\r\n    }\r\n    get fixableDiagnosticCodes() {\r\n        return this.client.execute('getSupportedCodeFixes', null, cancellation_1.nulToken)\r\n            .then(response => response.type === 'response' ? response.body || [] : [])\r\n            .then(codes => new Set(codes));\r\n    }\r\n}\r\n__decorate([\r\n    memoize_1.memoize\r\n], SupportedCodeActionProvider.prototype, \"fixableDiagnosticCodes\", null);\r\nclass TypeScriptQuickFixProvider {\r\n    constructor(client, formattingConfigurationManager, commandManager, diagnosticsManager, telemetryReporter) {\r\n        this.client = client;\r\n        this.formattingConfigurationManager = formattingConfigurationManager;\r\n        this.diagnosticsManager = diagnosticsManager;\r\n        commandManager.register(new ApplyCodeActionCommand(client, telemetryReporter));\r\n        commandManager.register(new ApplyFixAllCodeAction(client, telemetryReporter));\r\n        this.supportedCodeActionProvider = new SupportedCodeActionProvider(client);\r\n    }\r\n    async provideCodeActions(document, _range, context, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return [];\r\n        }\r\n        const fixableDiagnostics = await this.supportedCodeActionProvider.getFixableDiagnosticsForContext(context);\r\n        if (!fixableDiagnostics.size) {\r\n            return [];\r\n        }\r\n        if (this.client.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {\r\n            return [];\r\n        }\r\n        await this.formattingConfigurationManager.ensureConfigurationForDocument(document, token);\r\n        const results = new CodeActionSet();\r\n        for (const diagnostic of fixableDiagnostics.values) {\r\n            await this.getFixesForDiagnostic(document, file, diagnostic, results, token);\r\n        }\r\n        return Array.from(results.values);\r\n    }\r\n    async getFixesForDiagnostic(document, file, diagnostic, results, token) {\r\n        const args = {\r\n            ...typeConverters.Range.toFileRangeRequestArgs(file, diagnostic.range),\r\n            errorCodes: [+(diagnostic.code)]\r\n        };\r\n        const response = await this.client.execute('getCodeFixes', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return results;\r\n        }\r\n        for (const tsCodeFix of response.body) {\r\n            this.addAllFixesForTsCodeAction(results, document, file, diagnostic, tsCodeFix);\r\n        }\r\n        return results;\r\n    }\r\n    addAllFixesForTsCodeAction(results, document, file, diagnostic, tsAction) {\r\n        results.addAction(this.getSingleFixForTsCodeAction(diagnostic, tsAction));\r\n        this.addFixAllForTsCodeAction(results, document, file, diagnostic, tsAction);\r\n        return results;\r\n    }\r\n    getSingleFixForTsCodeAction(diagnostic, tsAction) {\r\n        const codeAction = new vscode.CodeAction(tsAction.description, vscode.CodeActionKind.QuickFix);\r\n        codeAction.edit = codeAction_1.getEditForCodeAction(this.client, tsAction);\r\n        codeAction.diagnostics = [diagnostic];\r\n        codeAction.command = {\r\n            command: ApplyCodeActionCommand.ID,\r\n            arguments: [tsAction],\r\n            title: ''\r\n        };\r\n        codeAction.isPreferred = isPreferredFix(tsAction);\r\n        return codeAction;\r\n    }\r\n    addFixAllForTsCodeAction(results, document, file, diagnostic, tsAction) {\r\n        if (!tsAction.fixId || this.client.apiVersion.lt(api_1.default.v270) || results.hasFixAllAction(tsAction.fixId)) {\r\n            return results;\r\n        }\r\n        // Make sure there are multiple diagnostics of the same type in the file\r\n        if (!this.diagnosticsManager.getDiagnostics(document.uri).some(x => {\r\n            if (x === diagnostic) {\r\n                return false;\r\n            }\r\n            return x.code === diagnostic.code\r\n                || (fixAllErrorCodes.has(x.code) && fixAllErrorCodes.get(x.code) === fixAllErrorCodes.get(diagnostic.code));\r\n        })) {\r\n            return results;\r\n        }\r\n        const action = new vscode.CodeAction(tsAction.fixAllDescription || localize('fixAllInFileLabel', '{0} (Fix all in file)', tsAction.description), vscode.CodeActionKind.QuickFix);\r\n        action.diagnostics = [diagnostic];\r\n        action.command = {\r\n            command: ApplyFixAllCodeAction.ID,\r\n            arguments: [file, tsAction],\r\n            title: ''\r\n        };\r\n        results.addFixAllAction(tsAction.fixId, action);\r\n        return results;\r\n    }\r\n}\r\nTypeScriptQuickFixProvider.minVersion = api_1.default.v213;\r\nTypeScriptQuickFixProvider.metadata = {\r\n    providedCodeActionKinds: [vscode.CodeActionKind.QuickFix]\r\n};\r\n// Some fix all actions can actually fix multiple differnt diagnostics. Make sure we still show the fix all action\r\n// in such cases\r\nconst fixAllErrorCodes = new Map([\r\n    // Missing async\r\n    [2339, 2339],\r\n    [2345, 2339],\r\n]);\r\nconst preferredFixes = new Set([\r\n    'annotateWithTypeFromJSDoc',\r\n    'constructorForDerivedNeedSuperCall',\r\n    'extendsInterfaceBecomesImplements',\r\n    'fixAwaitInSyncFunction',\r\n    'fixClassIncorrectlyImplementsInterface',\r\n    'fixUnreachableCode',\r\n    'forgottenThisPropertyAccess',\r\n    'spelling',\r\n    'unusedIdentifier',\r\n    'addMissingAwait',\r\n]);\r\nfunction isPreferredFix(tsAction) {\r\n    return preferredFixes.has(tsAction.fixName);\r\n}\r\nfunction register(selector, client, fileConfigurationManager, commandManager, diagnosticsManager, telemetryReporter) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptQuickFixProvider.minVersion, () => vscode.languages.registerCodeActionsProvider(selector, new TypeScriptQuickFixProvider(client, fileConfigurationManager, commandManager, diagnosticsManager, telemetryReporter), TypeScriptQuickFixProvider.metadata));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=quickFix.js.map","/typescript-language-features/out/features/fixAll.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nconst autoFixableDiagnosticCodes = new Set([\r\n    2420,\r\n    2552,\r\n]);\r\nclass TypeScriptAutoFixProvider {\r\n    constructor(client, fileConfigurationManager, diagnosticsManager) {\r\n        this.client = client;\r\n        this.fileConfigurationManager = fileConfigurationManager;\r\n        this.diagnosticsManager = diagnosticsManager;\r\n    }\r\n    async provideCodeActions(document, _range, context, token) {\r\n        if (!context.only || !vscode.CodeActionKind.SourceFixAll.intersects(context.only)) {\r\n            return undefined;\r\n        }\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const autoFixableDiagnostics = this.getAutoFixableDiagnostics(document);\r\n        if (!autoFixableDiagnostics.length) {\r\n            return undefined;\r\n        }\r\n        const fixAllAction = await this.getFixAllCodeAction(document, file, autoFixableDiagnostics, token);\r\n        return fixAllAction ? [fixAllAction] : undefined;\r\n    }\r\n    getAutoFixableDiagnostics(document) {\r\n        if (this.client.bufferSyncSupport.hasPendingDiagnostics(document.uri)) {\r\n            return [];\r\n        }\r\n        return this.diagnosticsManager.getDiagnostics(document.uri)\r\n            .filter(x => autoFixableDiagnosticCodes.has(x.code));\r\n    }\r\n    async getFixAllCodeAction(document, file, diagnostics, token) {\r\n        await this.fileConfigurationManager.ensureConfigurationForDocument(document, token);\r\n        const autoFixResponse = await this.getAutoFixEdit(file, diagnostics, token);\r\n        if (!autoFixResponse) {\r\n            return undefined;\r\n        }\r\n        const { edit, fixedDiagnostics } = autoFixResponse;\r\n        const codeAction = new vscode.CodeAction(localize('autoFix.label', 'Auto fix'), vscode.CodeActionKind.SourceFixAll);\r\n        codeAction.edit = edit;\r\n        codeAction.diagnostics = fixedDiagnostics;\r\n        return codeAction;\r\n    }\r\n    async getAutoFixEdit(file, diagnostics, token) {\r\n        const edit = new vscode.WorkspaceEdit();\r\n        const fixedDiagnostics = [];\r\n        for (const diagnostic of diagnostics) {\r\n            const args = {\r\n                ...typeConverters.Range.toFileRangeRequestArgs(file, diagnostic.range),\r\n                errorCodes: [+(diagnostic.code)]\r\n            };\r\n            const response = await this.client.execute('getCodeFixes', args, token);\r\n            if (response.type !== 'response' || !response.body || response.body.length > 1) {\r\n                return undefined;\r\n            }\r\n            const fix = response.body[0];\r\n            if (new Set(['fixClassIncorrectlyImplementsInterface', 'spelling']).has(fix.fixName)) {\r\n                typeConverters.WorkspaceEdit.withFileCodeEdits(edit, this.client, fix.changes);\r\n                fixedDiagnostics.push(diagnostic);\r\n            }\r\n        }\r\n        if (!fixedDiagnostics.length) {\r\n            return undefined;\r\n        }\r\n        return { edit, fixedDiagnostics };\r\n    }\r\n}\r\nTypeScriptAutoFixProvider.metadata = {\r\n    providedCodeActionKinds: [vscode.CodeActionKind.SourceFixAll]\r\n};\r\nfunction register(selector, client, fileConfigurationManager, diagnosticsManager) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, api_1.default.v300, () => new dependentRegistration_1.ConfigurationDependentRegistration('typescript', 'experimental.autoFix.enabled', () => vscode.languages.registerCodeActionsProvider(selector, new TypeScriptAutoFixProvider(client, fileConfigurationManager, diagnosticsManager), TypeScriptAutoFixProvider.metadata)));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=fixAll.js.map","/typescript-language-features/out/features/refactor.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst cancellation_1 = require(\"../utils/cancellation\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst fileSchemes = require(\"../utils/fileSchemes\");\r\nconst localize = nls.loadMessageBundle();\r\nclass ApplyRefactoringCommand {\r\n    constructor(client, telemetryReporter) {\r\n        this.client = client;\r\n        this.telemetryReporter = telemetryReporter;\r\n        this.id = ApplyRefactoringCommand.ID;\r\n    }\r\n    async execute(document, refactor, action, range) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return false;\r\n        }\r\n        /* __GDPR__\r\n            \"refactor.execute\" : {\r\n                \"action\" : { \"classification\": \"PublicNonPersonalData\", \"purpose\": \"FeatureInsight\" },\r\n                \"${include}\": [\r\n                    \"${TypeScriptCommonProperties}\"\r\n                ]\r\n            }\r\n        */\r\n        this.telemetryReporter.logTelemetry('refactor.execute', {\r\n            action: action,\r\n        });\r\n        const args = {\r\n            ...typeConverters.Range.toFileRangeRequestArgs(file, range),\r\n            refactor,\r\n            action,\r\n        };\r\n        const response = await this.client.execute('getEditsForRefactor', args, cancellation_1.nulToken);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return false;\r\n        }\r\n        if (!response.body.edits.length) {\r\n            vscode.window.showErrorMessage(localize('refactoringFailed', \"Could not apply refactoring\"));\r\n            return false;\r\n        }\r\n        const workspaceEdit = await this.toWorkspaceEdit(response.body);\r\n        if (!(await vscode.workspace.applyEdit(workspaceEdit))) {\r\n            return false;\r\n        }\r\n        const renameLocation = response.body.renameLocation;\r\n        if (renameLocation) {\r\n            await vscode.commands.executeCommand('editor.action.rename', [\r\n                document.uri,\r\n                typeConverters.Position.fromLocation(renameLocation)\r\n            ]);\r\n        }\r\n        return true;\r\n    }\r\n    async toWorkspaceEdit(body) {\r\n        const workspaceEdit = new vscode.WorkspaceEdit();\r\n        for (const edit of body.edits) {\r\n            const resource = this.client.toResource(edit.fileName);\r\n            if (resource.scheme === fileSchemes.file) {\r\n                workspaceEdit.createFile(resource, { ignoreIfExists: true });\r\n            }\r\n        }\r\n        typeConverters.WorkspaceEdit.withFileCodeEdits(workspaceEdit, this.client, body.edits);\r\n        return workspaceEdit;\r\n    }\r\n}\r\nApplyRefactoringCommand.ID = '_typescript.applyRefactoring';\r\nclass SelectRefactorCommand {\r\n    constructor(client, doRefactoring) {\r\n        this.client = client;\r\n        this.doRefactoring = doRefactoring;\r\n        this.id = SelectRefactorCommand.ID;\r\n    }\r\n    async execute(document, info, range) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return false;\r\n        }\r\n        const selected = await vscode.window.showQuickPick(info.actions.map((action) => ({\r\n            label: action.name,\r\n            description: action.description,\r\n        })));\r\n        if (!selected) {\r\n            return false;\r\n        }\r\n        return this.doRefactoring.execute(document, info.name, selected.label, range);\r\n    }\r\n}\r\nSelectRefactorCommand.ID = '_typescript.selectRefactoring';\r\nclass TypeScriptRefactorProvider {\r\n    constructor(client, formattingOptionsManager, commandManager, telemetryReporter) {\r\n        this.client = client;\r\n        this.formattingOptionsManager = formattingOptionsManager;\r\n        const doRefactoringCommand = commandManager.register(new ApplyRefactoringCommand(this.client, telemetryReporter));\r\n        commandManager.register(new SelectRefactorCommand(this.client, doRefactoringCommand));\r\n    }\r\n    async provideCodeActions(document, rangeOrSelection, context, token) {\r\n        if (!this.shouldTrigger(rangeOrSelection, context)) {\r\n            return undefined;\r\n        }\r\n        if (!this.client.toOpenedFilePath(document)) {\r\n            return undefined;\r\n        }\r\n        const response = await this.client.interruptGetErr(() => {\r\n            const file = this.client.toOpenedFilePath(document);\r\n            if (!file) {\r\n                return undefined;\r\n            }\r\n            this.formattingOptionsManager.ensureConfigurationForDocument(document, token);\r\n            const args = typeConverters.Range.toFileRangeRequestArgs(file, rangeOrSelection);\r\n            return this.client.execute('getApplicableRefactors', args, token);\r\n        });\r\n        if (!response || response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        return this.convertApplicableRefactors(response.body, document, rangeOrSelection);\r\n    }\r\n    convertApplicableRefactors(body, document, rangeOrSelection) {\r\n        const actions = [];\r\n        for (const info of body) {\r\n            if (info.inlineable === false) {\r\n                const codeAction = new vscode.CodeAction(info.description, vscode.CodeActionKind.Refactor);\r\n                codeAction.command = {\r\n                    title: info.description,\r\n                    command: SelectRefactorCommand.ID,\r\n                    arguments: [document, info, rangeOrSelection]\r\n                };\r\n                actions.push(codeAction);\r\n            }\r\n            else {\r\n                for (const action of info.actions) {\r\n                    actions.push(this.refactorActionToCodeAction(action, document, info, rangeOrSelection));\r\n                }\r\n            }\r\n        }\r\n        return actions;\r\n    }\r\n    refactorActionToCodeAction(action, document, info, rangeOrSelection) {\r\n        const codeAction = new vscode.CodeAction(action.description, TypeScriptRefactorProvider.getKind(action));\r\n        codeAction.command = {\r\n            title: action.description,\r\n            command: ApplyRefactoringCommand.ID,\r\n            arguments: [document, info.name, action.name, rangeOrSelection],\r\n        };\r\n        codeAction.isPreferred = TypeScriptRefactorProvider.isPreferred(action);\r\n        return codeAction;\r\n    }\r\n    shouldTrigger(rangeOrSelection, context) {\r\n        if (context.only && !vscode.CodeActionKind.Refactor.contains(context.only)) {\r\n            return false;\r\n        }\r\n        return rangeOrSelection instanceof vscode.Selection;\r\n    }\r\n    static getKind(refactor) {\r\n        if (refactor.name.startsWith('function_')) {\r\n            return TypeScriptRefactorProvider.extractFunctionKind;\r\n        }\r\n        else if (refactor.name.startsWith('constant_')) {\r\n            return TypeScriptRefactorProvider.extractConstantKind;\r\n        }\r\n        else if (refactor.name.startsWith('Move')) {\r\n            return TypeScriptRefactorProvider.moveKind;\r\n        }\r\n        else if (refactor.name.includes('Extract to type alias')) {\r\n            return TypeScriptRefactorProvider.extractTypeKind;\r\n        }\r\n        return vscode.CodeActionKind.Refactor;\r\n    }\r\n    static isPreferred(action) {\r\n        if (action.name.startsWith('constant_')) {\r\n            return action.name.endsWith('scope_0');\r\n        }\r\n        if (action.name.includes('Extract to type alias')) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nTypeScriptRefactorProvider.minVersion = api_1.default.v240;\r\nTypeScriptRefactorProvider.extractFunctionKind = vscode.CodeActionKind.RefactorExtract.append('function');\r\nTypeScriptRefactorProvider.extractConstantKind = vscode.CodeActionKind.RefactorExtract.append('constant');\r\nTypeScriptRefactorProvider.extractTypeKind = vscode.CodeActionKind.RefactorExtract.append('type');\r\nTypeScriptRefactorProvider.moveKind = vscode.CodeActionKind.Refactor.append('move');\r\nTypeScriptRefactorProvider.metadata = {\r\n    providedCodeActionKinds: [vscode.CodeActionKind.Refactor],\r\n};\r\nfunction register(selector, client, formattingOptionsManager, commandManager, telemetryReporter) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptRefactorProvider.minVersion, () => {\r\n        return vscode.languages.registerCodeActionsProvider(selector, new TypeScriptRefactorProvider(client, formattingOptionsManager, commandManager, telemetryReporter), TypeScriptRefactorProvider.metadata);\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=refactor.js.map","/typescript-language-features/out/features/references.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptReferenceSupport {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideReferences(document, position, options, token) {\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return [];\r\n        }\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);\r\n        const response = await this.client.execute('references', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return [];\r\n        }\r\n        const result = [];\r\n        const has203Features = this.client.apiVersion.gte(api_1.default.v203);\r\n        for (const ref of response.body.refs) {\r\n            if (!options.includeDeclaration && has203Features && ref.isDefinition) {\r\n                continue;\r\n            }\r\n            const url = this.client.toResource(ref.file);\r\n            const location = typeConverters.Location.fromTextSpan(url, ref);\r\n            result.push(location);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction register(selector, client) {\r\n    return vscode.languages.registerReferenceProvider(selector, new TypeScriptReferenceSupport(client));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=references.js.map","/typescript-language-features/out/features/referencesCodeLens.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst PConst = require(\"../protocol.const\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst baseCodeLensProvider_1 = require(\"./baseCodeLensProvider\");\r\nconst localize = nls.loadMessageBundle();\r\nclass TypeScriptReferencesCodeLensProvider extends baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider {\r\n    async resolveCodeLens(inputCodeLens, token) {\r\n        const codeLens = inputCodeLens;\r\n        const args = typeConverters.Position.toFileLocationRequestArgs(codeLens.file, codeLens.range.start);\r\n        const response = await this.client.execute('references', args, token, { lowPriority: true });\r\n        if (response.type !== 'response' || !response.body) {\r\n            codeLens.command = response.type === 'cancelled'\r\n                ? baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider.cancelledCommand\r\n                : baseCodeLensProvider_1.TypeScriptBaseCodeLensProvider.errorCommand;\r\n            return codeLens;\r\n        }\r\n        const locations = response.body.refs\r\n            .map(reference => typeConverters.Location.fromTextSpan(this.client.toResource(reference.file), reference))\r\n            .filter(location => \r\n        // Exclude original definition from references\r\n        !(location.uri.toString() === codeLens.document.toString() &&\r\n            location.range.start.isEqual(codeLens.range.start)));\r\n        codeLens.command = {\r\n            title: this.getCodeLensLabel(locations),\r\n            command: locations.length ? 'editor.action.showReferences' : '',\r\n            arguments: [codeLens.document, codeLens.range.start, locations]\r\n        };\r\n        return codeLens;\r\n    }\r\n    getCodeLensLabel(locations) {\r\n        return locations.length === 1\r\n            ? localize('oneReferenceLabel', '1 reference')\r\n            : localize('manyReferenceLabel', '{0} references', locations.length);\r\n    }\r\n    extractSymbol(document, item, parent) {\r\n        if (parent && parent.kind === PConst.Kind.enum) {\r\n            return baseCodeLensProvider_1.getSymbolRange(document, item);\r\n        }\r\n        switch (item.kind) {\r\n            case PConst.Kind.const:\r\n            case PConst.Kind.let:\r\n            case PConst.Kind.variable:\r\n            case PConst.Kind.function:\r\n                // Only show references for exported variables\r\n                if (!item.kindModifiers.match(/\\bexport\\b/)) {\r\n                    break;\r\n                }\r\n            // fallthrough\r\n            case PConst.Kind.class:\r\n                if (item.text === '<class>') {\r\n                    break;\r\n                }\r\n            // fallthrough\r\n            case PConst.Kind.memberFunction:\r\n            case PConst.Kind.memberVariable:\r\n            case PConst.Kind.memberGetAccessor:\r\n            case PConst.Kind.memberSetAccessor:\r\n            case PConst.Kind.constructorImplementation:\r\n            case PConst.Kind.interface:\r\n            case PConst.Kind.type:\r\n            case PConst.Kind.enum:\r\n                return baseCodeLensProvider_1.getSymbolRange(document, item);\r\n        }\r\n        return null;\r\n    }\r\n}\r\nTypeScriptReferencesCodeLensProvider.minVersion = api_1.default.v206;\r\nfunction register(selector, modeId, client, cachedResponse) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptReferencesCodeLensProvider.minVersion, () => new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'referencesCodeLens.enabled', () => {\r\n        return vscode.languages.registerCodeLensProvider(selector, new TypeScriptReferencesCodeLensProvider(client, cachedResponse));\r\n    }));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=referencesCodeLens.js.map","/typescript-language-features/out/features/rename.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst path = require(\"path\");\r\nconst vscode = require(\"vscode\");\r\nconst nls = require(\"vscode-nls\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nconst localize = nls.loadMessageBundle();\r\nclass TypeScriptRenameProvider {\r\n    constructor(client, fileConfigurationManager) {\r\n        this.client = client;\r\n        this.fileConfigurationManager = fileConfigurationManager;\r\n    }\r\n    async prepareRename(document, position, token) {\r\n        const response = await this.execRename(document, position, token);\r\n        if (!response || response.type !== 'response' || !response.body) {\r\n            return null;\r\n        }\r\n        const renameInfo = response.body.info;\r\n        if (!renameInfo.canRename) {\r\n            return Promise.reject(renameInfo.localizedErrorMessage);\r\n        }\r\n        if (this.client.apiVersion.gte(api_1.default.v310)) {\r\n            const triggerSpan = renameInfo.triggerSpan;\r\n            if (triggerSpan) {\r\n                return typeConverters.Range.fromTextSpan(triggerSpan);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    async provideRenameEdits(document, position, newName, token) {\r\n        const response = await this.execRename(document, position, token);\r\n        if (!response || response.type !== 'response' || !response.body) {\r\n            return null;\r\n        }\r\n        const renameInfo = response.body.info;\r\n        if (!renameInfo.canRename) {\r\n            return Promise.reject(renameInfo.localizedErrorMessage);\r\n        }\r\n        if (this.client.apiVersion.gte(api_1.default.v310)) {\r\n            if (renameInfo.fileToRename) {\r\n                const edits = await this.renameFile(renameInfo.fileToRename, newName, token);\r\n                if (edits) {\r\n                    return edits;\r\n                }\r\n                else {\r\n                    return Promise.reject(localize('fileRenameFail', \"An error occurred while renaming file\"));\r\n                }\r\n            }\r\n        }\r\n        return this.updateLocs(response.body.locs, newName);\r\n    }\r\n    async execRename(document, position, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(file, position),\r\n            findInStrings: false,\r\n            findInComments: false\r\n        };\r\n        return this.client.interruptGetErr(() => {\r\n            this.fileConfigurationManager.ensureConfigurationForDocument(document, token);\r\n            return this.client.execute('rename', args, token);\r\n        });\r\n    }\r\n    updateLocs(locations, newName) {\r\n        const edit = new vscode.WorkspaceEdit();\r\n        for (const spanGroup of locations) {\r\n            const resource = this.client.toResource(spanGroup.file);\r\n            if (resource) {\r\n                for (const textSpan of spanGroup.locs) {\r\n                    edit.replace(resource, typeConverters.Range.fromTextSpan(textSpan), (textSpan.prefixText || '') + newName + (textSpan.suffixText || ''));\r\n                }\r\n            }\r\n        }\r\n        return edit;\r\n    }\r\n    async renameFile(fileToRename, newName, token) {\r\n        // Make sure we preserve file extension if none provided\r\n        if (!path.extname(newName)) {\r\n            newName += path.extname(fileToRename);\r\n        }\r\n        const dirname = path.dirname(fileToRename);\r\n        const newFilePath = path.join(dirname, newName);\r\n        const args = {\r\n            file: fileToRename,\r\n            oldFilePath: fileToRename,\r\n            newFilePath: newFilePath,\r\n        };\r\n        const response = await this.client.execute('getEditsForFileRename', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        const edits = typeConverters.WorkspaceEdit.fromFileCodeEdits(this.client, response.body);\r\n        edits.renameFile(vscode.Uri.file(fileToRename), vscode.Uri.file(newFilePath));\r\n        return edits;\r\n    }\r\n}\r\nfunction register(selector, client, fileConfigurationManager) {\r\n    return vscode.languages.registerRenameProvider(selector, new TypeScriptRenameProvider(client, fileConfigurationManager));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=rename.js.map","/typescript-language-features/out/features/smartSelect.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass SmartSelection {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideSelectionRanges(document, positions, token) {\r\n        const file = this.client.toOpenedFilePath(document);\r\n        if (!file) {\r\n            return undefined;\r\n        }\r\n        const args = {\r\n            file,\r\n            locations: positions.map(typeConverters.Position.toLocation)\r\n        };\r\n        const response = await this.client.execute('selectionRange', args, token);\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        return response.body.map(SmartSelection.convertSelectionRange);\r\n    }\r\n    static convertSelectionRange(selectionRange) {\r\n        return new vscode.SelectionRange(typeConverters.Range.fromTextSpan(selectionRange.textSpan), selectionRange.parent ? SmartSelection.convertSelectionRange(selectionRange.parent) : undefined);\r\n    }\r\n}\r\nSmartSelection.minVersion = api_1.default.v350;\r\nfunction register(selector, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, SmartSelection.minVersion, () => vscode.languages.registerSelectionRangeProvider(selector, new SmartSelection(client)));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=smartSelect.js.map","/typescript-language-features/out/features/signatureHelp.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst Previewer = require(\"../utils/previewer\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TypeScriptSignatureHelpProvider {\r\n    constructor(client) {\r\n        this.client = client;\r\n    }\r\n    async provideSignatureHelp(document, position, token, context) {\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return undefined;\r\n        }\r\n        const args = {\r\n            ...typeConverters.Position.toFileLocationRequestArgs(filepath, position),\r\n            triggerReason: toTsTriggerReason(context)\r\n        };\r\n        const response = await this.client.interruptGetErr(() => this.client.execute('signatureHelp', args, token));\r\n        if (response.type !== 'response' || !response.body) {\r\n            return undefined;\r\n        }\r\n        const info = response.body;\r\n        const result = new vscode.SignatureHelp();\r\n        result.activeSignature = info.selectedItemIndex;\r\n        result.activeParameter = this.getActiveParmeter(info);\r\n        result.signatures = info.items.map(signature => this.convertSignature(signature));\r\n        return result;\r\n    }\r\n    getActiveParmeter(info) {\r\n        const activeSignature = info.items[info.selectedItemIndex];\r\n        if (activeSignature && activeSignature.isVariadic) {\r\n            return Math.min(info.argumentIndex, activeSignature.parameters.length - 1);\r\n        }\r\n        return info.argumentIndex;\r\n    }\r\n    convertSignature(item) {\r\n        const signature = new vscode.SignatureInformation(Previewer.plain(item.prefixDisplayParts), Previewer.markdownDocumentation(item.documentation, item.tags.filter(x => x.name !== 'param')));\r\n        let textIndex = signature.label.length;\r\n        const separatorLabel = Previewer.plain(item.separatorDisplayParts);\r\n        for (let i = 0; i < item.parameters.length; ++i) {\r\n            const parameter = item.parameters[i];\r\n            const label = Previewer.plain(parameter.displayParts);\r\n            signature.parameters.push(new vscode.ParameterInformation([textIndex, textIndex + label.length], Previewer.markdownDocumentation(parameter.documentation, [])));\r\n            textIndex += label.length;\r\n            signature.label += label;\r\n            if (i !== item.parameters.length - 1) {\r\n                signature.label += separatorLabel;\r\n                textIndex += separatorLabel.length;\r\n            }\r\n        }\r\n        signature.label += Previewer.plain(item.suffixDisplayParts);\r\n        return signature;\r\n    }\r\n}\r\nTypeScriptSignatureHelpProvider.triggerCharacters = ['(', ',', '<'];\r\nTypeScriptSignatureHelpProvider.retriggerCharacters = [')'];\r\nfunction toTsTriggerReason(context) {\r\n    switch (context.triggerKind) {\r\n        case vscode.SignatureHelpTriggerKind.TriggerCharacter:\r\n            if (context.triggerCharacter) {\r\n                if (context.isRetrigger) {\r\n                    return { kind: 'retrigger', triggerCharacter: context.triggerCharacter };\r\n                }\r\n                else {\r\n                    return { kind: 'characterTyped', triggerCharacter: context.triggerCharacter };\r\n                }\r\n            }\r\n            else {\r\n                return { kind: 'invoked' };\r\n            }\r\n        case vscode.SignatureHelpTriggerKind.ContentChange:\r\n            return context.isRetrigger ? { kind: 'retrigger' } : { kind: 'invoked' };\r\n        case vscode.SignatureHelpTriggerKind.Invoke:\r\n        default:\r\n            return { kind: 'invoked' };\r\n    }\r\n}\r\nfunction register(selector, client) {\r\n    return vscode.languages.registerSignatureHelpProvider(selector, new TypeScriptSignatureHelpProvider(client), {\r\n        triggerCharacters: TypeScriptSignatureHelpProvider.triggerCharacters,\r\n        retriggerCharacters: TypeScriptSignatureHelpProvider.retriggerCharacters\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=signatureHelp.js.map","/typescript-language-features/out/features/tagClosing.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst dispose_1 = require(\"../utils/dispose\");\r\nconst typeConverters = require(\"../utils/typeConverters\");\r\nclass TagClosing extends dispose_1.Disposable {\r\n    constructor(client) {\r\n        super();\r\n        this.client = client;\r\n        this._disposed = false;\r\n        this._timeout = undefined;\r\n        this._cancel = undefined;\r\n        vscode.workspace.onDidChangeTextDocument(event => this.onDidChangeTextDocument(event.document, event.contentChanges), null, this._disposables);\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._disposed = true;\r\n        if (this._timeout) {\r\n            clearTimeout(this._timeout);\r\n            this._timeout = undefined;\r\n        }\r\n        if (this._cancel) {\r\n            this._cancel.cancel();\r\n            this._cancel.dispose();\r\n            this._cancel = undefined;\r\n        }\r\n    }\r\n    onDidChangeTextDocument(document, changes) {\r\n        const activeDocument = vscode.window.activeTextEditor && vscode.window.activeTextEditor.document;\r\n        if (document !== activeDocument || changes.length === 0) {\r\n            return;\r\n        }\r\n        const filepath = this.client.toOpenedFilePath(document);\r\n        if (!filepath) {\r\n            return;\r\n        }\r\n        if (typeof this._timeout !== 'undefined') {\r\n            clearTimeout(this._timeout);\r\n        }\r\n        if (this._cancel) {\r\n            this._cancel.cancel();\r\n            this._cancel.dispose();\r\n            this._cancel = undefined;\r\n        }\r\n        const lastChange = changes[changes.length - 1];\r\n        const lastCharacter = lastChange.text[lastChange.text.length - 1];\r\n        if (lastChange.rangeLength > 0 || lastCharacter !== '>' && lastCharacter !== '/') {\r\n            return;\r\n        }\r\n        const priorCharacter = lastChange.range.start.character > 0\r\n            ? document.getText(new vscode.Range(lastChange.range.start.translate({ characterDelta: -1 }), lastChange.range.start))\r\n            : '';\r\n        if (priorCharacter === '>') {\r\n            return;\r\n        }\r\n        const version = document.version;\r\n        this._timeout = setTimeout(async () => {\r\n            this._timeout = undefined;\r\n            if (this._disposed) {\r\n                return;\r\n            }\r\n            const addedLines = lastChange.text.split(/\\r\\n|\\n/g);\r\n            const position = addedLines.length <= 1\r\n                ? lastChange.range.start.translate({ characterDelta: lastChange.text.length })\r\n                : new vscode.Position(lastChange.range.start.line + addedLines.length - 1, addedLines[addedLines.length - 1].length);\r\n            const args = typeConverters.Position.toFileLocationRequestArgs(filepath, position);\r\n            this._cancel = new vscode.CancellationTokenSource();\r\n            const response = await this.client.execute('jsxClosingTag', args, this._cancel.token);\r\n            if (response.type !== 'response' || !response.body) {\r\n                return;\r\n            }\r\n            if (this._disposed) {\r\n                return;\r\n            }\r\n            const activeEditor = vscode.window.activeTextEditor;\r\n            if (!activeEditor) {\r\n                return;\r\n            }\r\n            const insertion = response.body;\r\n            const activeDocument = activeEditor.document;\r\n            if (document === activeDocument && activeDocument.version === version) {\r\n                activeEditor.insertSnippet(this.getTagSnippet(insertion), this.getInsertionPositions(activeEditor, position));\r\n            }\r\n        }, 100);\r\n    }\r\n    getTagSnippet(closingTag) {\r\n        const snippet = new vscode.SnippetString();\r\n        snippet.appendPlaceholder('', 0);\r\n        snippet.appendText(closingTag.newText);\r\n        return snippet;\r\n    }\r\n    getInsertionPositions(editor, position) {\r\n        const activeSelectionPositions = editor.selections.map(s => s.active);\r\n        return activeSelectionPositions.some(p => p.isEqual(position))\r\n            ? activeSelectionPositions\r\n            : position;\r\n    }\r\n}\r\nTagClosing.minVersion = api_1.default.v300;\r\nclass ActiveDocumentDependentRegistration extends dispose_1.Disposable {\r\n    constructor(selector, register) {\r\n        super();\r\n        this.selector = selector;\r\n        this._registration = this._register(new dependentRegistration_1.ConditionalRegistration(register));\r\n        vscode.window.onDidChangeActiveTextEditor(this.update, this, this._disposables);\r\n        vscode.workspace.onDidOpenTextDocument(this.onDidOpenDocument, this, this._disposables);\r\n        this.update();\r\n    }\r\n    update() {\r\n        const editor = vscode.window.activeTextEditor;\r\n        const enabled = !!(editor && vscode.languages.match(this.selector, editor.document));\r\n        this._registration.update(enabled);\r\n    }\r\n    onDidOpenDocument(openedDocument) {\r\n        if (vscode.window.activeTextEditor && vscode.window.activeTextEditor.document === openedDocument) {\r\n            // The active document's language may have changed\r\n            this.update();\r\n        }\r\n    }\r\n}\r\nexports.ActiveDocumentDependentRegistration = ActiveDocumentDependentRegistration;\r\nfunction register(selector, modeId, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TagClosing.minVersion, () => new dependentRegistration_1.ConfigurationDependentRegistration(modeId, 'autoClosingTags', () => new ActiveDocumentDependentRegistration(selector, () => new TagClosing(client))));\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=tagClosing.js.map","/typescript-language-features/out/features/typeDefinitions.js":"\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst vscode = require(\"vscode\");\r\nconst api_1 = require(\"../utils/api\");\r\nconst dependentRegistration_1 = require(\"../utils/dependentRegistration\");\r\nconst definitionProviderBase_1 = require(\"./definitionProviderBase\");\r\nclass TypeScriptTypeDefinitionProvider extends definitionProviderBase_1.default {\r\n    provideTypeDefinition(document, position, token) {\r\n        return this.getSymbolLocations('typeDefinition', document, position, token);\r\n    }\r\n}\r\nTypeScriptTypeDefinitionProvider.minVersion = api_1.default.v213;\r\nexports.default = TypeScriptTypeDefinitionProvider;\r\nfunction register(selector, client) {\r\n    return new dependentRegistration_1.VersionDependentRegistration(client, TypeScriptTypeDefinitionProvider.minVersion, () => {\r\n        return vscode.languages.registerTypeDefinitionProvider(selector, new TypeScriptTypeDefinitionProvider(client));\r\n    });\r\n}\r\nexports.register = register;\r\n//# sourceMappingURL=typeDefinitions.js.map"}