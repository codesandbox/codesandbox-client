/*!-----------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.14.3(acd2c388963f44d9dfc7a367b2a772b993a888b9)
 * Released under the MIT license
 * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt
 *-----------------------------------------------------------*/

(function() {
var __m = ["require","exports","vs/nls","vs/platform/instantiation/common/instantiation","vs/base/common/lifecycle","vs/base/common/winjs.base","vs/base/common/event","vs/platform/configuration/common/configuration","vs/base/browser/dom","vs/platform/registry/common/platform","vs/platform/contextkey/common/contextkey","vs/workbench/services/editor/common/editorService","vs/base/common/uri","vs/workbench/common/editor","vs/platform/theme/common/themeService","vs/base/common/actions","vs/platform/files/common/files","vs/base/common/async","vs/base/common/platform","vs/base/common/arrays","vs/platform/workspace/common/workspace","vs/css!vs/editor/codesandbox.editor.main","vs/base/common/strings","vs/platform/actions/common/actions","vs/base/common/paths","vs/base/common/errors","vs/base/common/network","vs/workbench/services/textfile/common/textfiles","vs/platform/notification/common/notification","vs/base/common/types","vs/platform/theme/common/colorRegistry","vs/platform/keybinding/common/keybinding","vs/platform/telemetry/common/telemetry","vs/workbench/services/group/common/editorGroupsService","vs/platform/contextview/browser/contextView","vs/base/common/resources","vs/editor/common/services/modelService","vs/platform/commands/common/commands","vs/base/common/objects","vs/base/common/map","vs/platform/theme/common/styler","vs/editor/common/services/modeService","vs/platform/windows/common/windows","vs/platform/environment/common/environment","vs/platform/storage/common/storage","vs/editor/browser/editorBrowser","vs/platform/quickOpen/common/quickOpen","vs/workbench/common/actions","vs/editor/common/core/range","vs/workbench/services/part/common/partService","vs/base/browser/ui/actionbar/actionbar","vs/platform/list/browser/listService","vs/workbench/services/untitled/common/untitledEditorService","vs/workbench/browser/quickopen","vs/workbench/services/viewlet/browser/viewlet","vs/base/common/cancellation","vs/editor/browser/editorExtensions","vs/workbench/parts/files/common/files","vs/workbench/common/theme","vs/platform/label/common/label","vs/workbench/browser/labels","vs/workbench/services/preferences/common/preferences","vs/platform/quickinput/common/quickInput","vs/platform/lifecycle/common/lifecycle","vs/platform/keybinding/common/keybindingsRegistry","vs/base/common/keyCodes","vs/editor/common/services/resolverService","vs/base/parts/quickopen/browser/quickOpenModel","vs/base/browser/keyboardEvent","vs/base/common/filters","vs/workbench/services/extensions/common/extensions","vs/platform/search/common/search","vs/editor/common/model","vs/editor/common/model/textModel","vs/workbench/browser/parts/editor/baseEditor","vs/base/common/color","vs/workbench/browser/viewlet","vs/base/common/json","path","vs/platform/clipboard/common/clipboardService","vs/platform/instantiation/common/extensions","vs/workbench/services/panel/common/panelService","vs/workbench/common/resources","vs/base/common/labels","vs/workbench/browser/dnd","vs/editor/common/modes","vs/platform/log/common/log","vs/workbench/browser/parts/editor/editor","vs/editor/common/services/resourceConfiguration","vs/editor/common/core/editOperation","vs/platform/configuration/common/configurationRegistry","vs/workbench/parts/files/common/explorerModel","vs/platform/dialogs/common/dialogs","vs/workbench/common/editor/resourceEditorInput","vs/workbench/services/hash/common/hashService","vs/base/browser/ui/widget","vs/editor/browser/services/codeEditorService","vs/codesandbox/services/codesandbox/common/codesandbox","vs/base/common/errorMessage","vs/platform/progress/common/progress","vs/editor/common/core/selection","vs/base/browser/ui/splitview/splitview","vs/workbench/browser/parts/quickopen/quickopen","vs/workbench/browser/parts/editor/breadcrumbs","vs/workbench/browser/parts/editor/editorCommands","vs/workbench/browser/editor","vs/workbench/parts/search/common/searchModel","vs/workbench/common/contributions","vs/workbench/common/views","vs/workbench/parts/preferences/common/preferences","vs/workbench/common/editor/diffEditorInput","vs/base/browser/browser","vs/workbench/browser/actions","vs/workbench/services/backup/common/backup","vs/editor/common/editorContextKeys","vs/platform/actions/browser/menuItemActionItem","vs/workbench/common/editor/textEditorModel","vs/workbench/parts/snippets/electron-browser/snippets.contribution","vs/base/common/collections","vs/workbench/parts/search/common/replace","vs/platform/instantiation/common/descriptors","vs/base/browser/ui/button/button","vs/platform/extensionManagement/common/extensionManagement","vs/workbench/services/textfile/common/textFileEditorModel","vs/workbench/services/history/common/history","vs/workbench/parts/files/common/editors/fileEditorInput","vs/editor/contrib/documentSymbols/outlineModel","vs/workbench/common/editor/binaryEditorModel","vs/workbench/common/editor/untitledEditorInput","vs/css!vs/workbench/browser/parts/quickinput/quickInput","vs/base/common/scanCode","vs/base/common/mime","vs/base/parts/quickopen/common/quickOpenScorer","vs/base/browser/ui/toolbar/toolbar","vs/base/common/scrollable","vs/editor/common/core/position","vs/editor/contrib/snippet/snippetController2","vs/base/browser/mouseEvent","vs/platform/opener/common/opener","vs/base/browser/ui/inputbox/inputBox","vs/base/browser/touch","vs/workbench/parts/search/browser/searchActions","vs/base/common/glob","vs/workbench/parts/search/common/search","vs/workbench/parts/preferences/browser/preferencesWidgets","vs/workbench/services/workspace/common/workspaceEditing","vs/base/common/decorators","vs/workbench/common/component","vs/workbench/parts/search/common/constants","vs/workbench/browser/parts/editor/textEditor","vs/workbench/parts/files/electron-browser/fileCommands","vs/workbench/parts/preferences/browser/settingsWidgets","vs/editor/common/modes/modesRegistry","vs/workbench/services/configuration/common/configuration","vs/workbench/services/configuration/common/jsonEditing","vs/workbench/services/decorations/browser/decorations","vs/workbench/parts/files/electron-browser/fileActions","vs/workbench/browser/parts/editor/binaryEditor","vs/workbench/browser/parts/editor/sideBySideEditor","vs/workbench/services/activity/common/activity","vs/platform/workspaces/common/workspaces","vs/workbench/parts/preferences/browser/settingsTreeModels","vs/workbench/services/preferences/common/preferencesModels","vs/base/common/idGenerator","vs/workbench/browser/parts/editor/editorActions","vs/base/browser/dnd","vs/base/common/comparers","vs/workbench/browser/parts/views/panelViewlet","vs/base/common/keybindingParser","vs/workbench/parts/preferences/browser/keybindingWidgets","vs/base/common/htmlContent","vs/workbench/parts/codeEditor/electron-browser/selectionClipboard","vs/workbench/parts/codeEditor/browser/menuPreventer","vs/workbench/parts/output/common/output","vs/workbench/browser/parts/editor/binaryDiffEditor","vs/workbench/electron-browser/resources","vs/base/parts/tree/browser/treeImpl","vs/editor/common/view/editorColorRegistry","vs/workbench/parts/files/browser/files","vs/workbench/parts/search/browser/openSymbolHandler","vs/workbench/browser/panel","vs/workbench/browser/actions/workspaceActions","vs/workbench/browser/composite","vs/workbench/services/extensions/common/extensionsRegistry","vs/workbench/browser/actions/workspaceCommands","vs/workbench/common/editor/dataUriEditorInput","vs/workbench/common/editor/resourceEditorModel","vs/workbench/common/editor/textDiffEditorModel","vs/workbench/common/editor/editorGroup","vs/platform/telemetry/common/telemetryUtils","vs/workbench/common/editor/diffEditorModel","vs/workbench/browser/parts/statusbar/statusbar","vs/workbench/parts/snippets/electron-browser/snippetsService","vs/workbench/parts/preferences/browser/settingsLayout","vs/base/browser/ui/iconLabel/iconLabel","vs/workbench/browser/parts/quickinput/quickInputUtils","vs/base/common/severity","vs/workbench/browser/parts/quickinput/quickInput","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/workbench/services/preferences/common/keybindingsEditorModel","vs/workbench/browser/parts/editor/editorWidgets","vs/editor/common/config/editorOptions","vs/workbench/parts/preferences/browser/settingsTree","vs/base/parts/tree/browser/treeDefaults","vs/workbench/browser/parts/editor/breadcrumbsModel","vs/workbench/services/preferences/common/preferencesEditorInput","vs/workbench/parts/snippets/electron-browser/snippetsFile","vs/workbench/services/progress/common/progress","vs/base/browser/ui/highlightedlabel/highlightedLabel","vs/platform/statusbar/common/statusbar","vs/workbench/browser/parts/editor/textDiffEditor","vs/editor/contrib/suggest/suggest","vs/editor/browser/widget/codeEditorWidget","vs/css!vs/workbench/browser/parts/editor/media/breadcrumbscontrol","vs/css!vs/editor/contrib/documentSymbols/media/symbol-icons","vs/base/browser/ui/splitview/panelview","vs/workbench/parts/preferences/browser/preferencesEditor","vs/workbench/parts/search/browser/searchWidget","vs/workbench/services/keybinding/common/keybindingEditing","vs/base/browser/ui/grid/gridview","vs/base/browser/event","vs/workbench/browser/parts/views/viewsViewlet","vs/workbench/services/themes/common/workbenchThemeService","vs/base/browser/ui/scrollbar/scrollableElement","vs/css!vs/base/browser/ui/grid/gridview","vs/base/browser/ui/checkbox/checkbox","vs/codesandbox/services/codesandbox/browser/codesandboxService","vs/workbench/browser/parts/editor/breadcrumbsControl","vs/workbench/parts/files/electron-browser/views/explorerViewer","vs/workbench/browser/parts/editor/editorPicker","vs/workbench/parts/preferences/electron-browser/preferencesSearch","vs/workbench/parts/search/common/queryBuilder","vs/workbench/browser/parts/editor/titleControl","vs/workbench/browser/parts/quickopen/quickOpenController","vs/base/common/jsonEdit","vs/workbench/services/editor/browser/editorService","vs/base/browser/ui/keybindingLabel/keybindingLabel","vs/base/common/performance","vs/platform/storage/common/storageService","vs/editor/contrib/indentation/indentation","vs/base/browser/ui/list/listWidget","vs/workbench/parts/files/electron-browser/views/explorerDecorationsProvider","vs/css!vs/workbench/browser/parts/editor/media/resourceviewer","vs/css!vs/workbench/browser/parts/editor/media/tabstitlecontrol","vs/css!vs/workbench/browser/parts/editor/media/titlecontrol","vs/css!vs/base/browser/ui/breadcrumbs/breadcrumbsWidget","vs/css!vs/workbench/browser/parts/quickopen/media/quickopen","vs/css!vs/workbench/browser/parts/views/media/panelviewlet","vs/workbench/parts/search/browser/searchView","vs/workbench/parts/preferences/electron-browser/preferences.contribution","vs/workbench/parts/preferences/browser/preferencesActions","vs/workbench/parts/preferences/common/smartSnippetInserter","vs/workbench/parts/search/browser/patternInputWidget","vs/css!vs/workbench/browser/parts/views/media/views","vs/platform/widget/browser/contextScopedHistoryWidget","vs/platform/windows/electron-browser/windowService","vs/editor/contrib/documentSymbols/outlineTree","vs/css!vs/workbench/parts/codeEditor/electron-browser/media/suggestEnabledInput","vs/css!vs/workbench/parts/files/electron-browser/media/explorerviewlet","vs/css!vs/workbench/parts/files/electron-browser/media/fileactions","vs/workbench/parts/files/electron-browser/files.contribution","vs/css!vs/workbench/parts/preferences/browser/media/keybindings","vs/css!vs/workbench/parts/preferences/browser/media/keybindingsEditor","vs/workbench/parts/snippets/electron-browser/configureSnippets","vs/platform/extensionManagement/common/extensionEnablementService","vs/css!vs/workbench/parts/preferences/browser/media/preferences","vs/editor/contrib/snippet/snippetParser","vs/workbench/parts/files/electron-browser/views/emptyView","vs/workbench/parts/snippets/electron-browser/insertSnippet","vs/workbench/parts/terminal/common/terminal","vs/css!vs/workbench/parts/preferences/browser/media/settingsWidgets","vs/workbench/api/electron-browser/extHostCustomers","vs/workbench/common/editor/untitledEditorModel","vs/css!vs/workbench/parts/preferences/electron-browser/media/settingsEditor2","vs/css!vs/workbench/parts/search/browser/media/searchview","vs/css!vs/workbench/parts/search/electron-browser/media/search.contribution","vs/workbench/parts/files/electron-browser/saveErrorHandler","vs/css!vs/workbench/services/progress/browser/media/progressService2","vs/base/browser/ui/dropdown/dropdown","vs/workbench/services/decorations/browser/decorationsService","vs/base/common/jsonFormatter","vs/css!vs/base/browser/ui/button/button","vs/codesandbox/services/codesandbox/browser/codesandboxEditorConnectorService","vs/workbench/browser/parts/editor/rangeDecorations","vs/editor/common/controller/cursorEvents","vs/workbench/browser/parts/editor/resourceViewer","vs/base/browser/contextmenu","vs/workbench/parts/search/electron-browser/search.contribution","vs/codesandbox/backupFileService","vs/base/common/octicon","vs/workbench/browser/parts/quickinput/quickInputBox","vs/workbench/parts/quickopen/browser/gotoLineHandler","vs/codesandbox/broadcastService","vs/workbench/parts/quickopen/browser/gotoSymbolHandler","vs/platform/extensionManagement/common/extensionManagementUtil","vs/workbench/parts/quickopen/browser/helpHandler","vs/base/parts/tree/browser/treeUtils","vs/workbench/browser/parts/quickinput/quickInputList","vs/workbench/services/codeEditor/browser/codeEditorService","vs/codesandbox/clipboardService","vs/codesandbox/environmentService","vs/workbench/parts/quickopen/browser/commandsHandler","vs/css!vs/base/browser/ui/dropdown/dropdown","vs/workbench/services/extensions/node/proxyIdentifier","vs/workbench/api/node/extHost.protocol","vs/workbench/api/electron-browser/mainThreadHeapService","vs/codesandbox/services/codesandbox/common/codesandboxEditorConnector","vs/workbench/services/files/node/watcher/common","vs/codesandbox/fileService","vs/codesandbox/workbench","vs/editor/codesandbox.editor.api","vs/codesandbox/extensionGalleryService","vs/workbench/browser/actions/toggleEditorLayout","vs/base/browser/ui/breadcrumbs/breadcrumbsWidget","vs/codesandbox/services/codesandbox/codesandbox.contribution","vs/workbench/browser/actions/toggleTabsVisibility","vs/codesandbox/extensionManagementService","vs/codesandbox/extensionService","vs/workbench/services/keybinding/common/keybindingIO","vs/workbench/services/keybinding/common/macLinuxFallbackKeyboardMapper","vs/platform/keybinding/common/usLayoutResolvedKeybinding","vs/codesandbox/keybindingService","vs/editor/standalone/browser/codesandbox.standaloneEditor","vs/platform/keybinding/common/keybindingResolver","vs/platform/keybinding/common/resolvedKeybindingItem","vs/codesandbox/codesandbox.services","vs/workbench/services/keybinding/common/windowsKeyboardMapper","vs/base/common/keybindingLabels","vs/workbench/parts/preferences/browser/keybindingsEditorContribution","vs/workbench/services/mode/common/workbenchModeService","vs/workbench/services/viewlet/browser/viewletService","vs/codesandbox/hashService","vs/css!vs/base/browser/ui/splitview/panelview","vs/workbench/parts/snippets/electron-browser/tabCompletion","vs/css!vs/base/browser/ui/splitview/splitview","vs/codesandbox/commandService","vs/workbench/browser/actions/toggleSidebarPosition","vs/workbench/browser/actions/toggleSidebarVisibility","vs/workbench/browser/actions/toggleZenMode","vs/workbench/browser/parts/editor/editorControl","vs/codesandbox/outputService","vs/codesandbox/panelService","vs/base/browser/ui/countBadge/countBadge","vs/base/browser/ui/progressbar/progressbar","vs/base/common/numbers","vs/workbench/browser/parts/quickinput/quickInput.contribution","vs/workbench/services/history/electron-browser/history","vs/codesandbox/codesandbox.all","vs/workbench/common/memento","vs/platform/broadcast/electron-browser/broadcastService","electron","vs/workbench/services/progress/browser/progressService2","vs/base/browser/ui/aria/aria","vs/workbench/browser/parts/editor/editorPart","vs/codesandbox/requestService","vs/base/browser/ui/centered/centeredViewLayout","vs/workbench/parts/preferences/browser/tocTree","vs/workbench/parts/preferences/common/preferencesContribution","vs/codesandbox/activityService","vs/base/browser/ui/grid/grid","vs/workbench/parts/preferences/browser/preferencesRenderers","vs/workbench/services/preferences/browser/preferencesService","vs/codesandbox/statusbarService","vs/workbench/services/search/node/searchHistoryService","vs/workbench/browser/part","vs/css!vs/base/browser/ui/toolbar/toolbar","vs/css!vs/editor/contrib/documentSymbols/media/outlineTree","vs/editor/browser/widget/diffNavigator","vs/platform/instantiation/common/serviceCollection","vs/codesandbox/windowsService","vs/css!vs/workbench/browser/actions/media/actions","vs/codesandbox/fileDialogService","vs/workbench/browser/parts/editor/textResourceEditor","vs/css!vs/workbench/browser/media/part","vs/workbench/browser/parts/editor/editorGroupView","vs/codesandbox/services/codesandbox/codesandboxActions","vs/workbench/parts/files/browser/editors/binaryFileEditor","vs/workbench/parts/files/browser/editors/fileEditorTracker","vs/codesandbox/configuration.contribution","vs/workbench/services/progress/browser/progressService","vs/editor/contrib/find/findController","vs/editor/contrib/find/findModel","vs/workbench/parts/codeEditor/browser/simpleEditorOptions","vs/workbench/parts/search/browser/searchViewLocationUpdater","vs/workbench/parts/preferences/electron-browser/settingsEditor2","vs/workbench/parts/search/browser/replaceService","vs/editor/browser/services/bulkEditService","vs/workbench/parts/search/browser/replaceContributions","vs/workbench/services/configuration/node/jsonEditingService","vs/workbench/parts/search/browser/searchResultsView","vs/workbench/parts/codeEditor/electron-browser/largeFileOptimizations","vs/workbench/parts/preferences/browser/keybindingsEditor","vs/codesandbox/workspacesService","vs/codesandbox/services/codesandbox/saveParticipant","vs/css!vs/workbench/browser/parts/editor/media/editordroptarget","vs/workbench/parts/quickopen/browser/quickopen.contribution","vs/workbench/parts/quickopen/browser/viewPickerHandler","vs/editor/common/services/editorWorkerService","vs/workbench/parts/files/browser/editors/textFileEditor","vs/workbench/parts/codeEditor/electron-browser/suggestEnabledInput","vs/workbench/browser/parts/views/views","vs/workbench/services/textfile/common/textFileEditorModelManager","vs/workbench/services/textfile/common/textFileService","vs/platform/search/common/replace","vs/css!vs/workbench/browser/parts/editor/media/editorgroupview","vs/codesandbox/searchService","vs/workbench/parts/files/electron-browser/explorerViewlet","vs/css!vs/workbench/browser/parts/editor/media/editorpicker","vs/workbench/parts/files/electron-browser/views/openEditorsView","vs/workbench/browser/parts/editor/breadcrumbsPicker","vs/workbench/parts/codeEditor/electron-browser/toggleMinimap","vs/workbench/parts/codeEditor/electron-browser/toggleMultiCursorModifier","vs/workbench/browser/parts/editor/editorDropTarget","vs/workbench/parts/codeEditor/electron-browser/toggleRenderControlCharacter","vs/workbench/browser/parts/editor/editorStatus","vs/workbench/parts/codeEditor/electron-browser/toggleRenderWhitespace","vs/workbench/parts/codeEditor/electron-browser/toggleWordWrap","vs/workbench/browser/parts/editor/editor.contribution","vs/css!vs/workbench/browser/parts/editor/media/editorstatus","vs/workbench/browser/parts/editor/noTabsTitleControl","vs/workbench/browser/parts/editor/tabsTitleControl","vs/codesandbox/lifecycleService","vs/css!vs/workbench/browser/parts/editor/media/notabstitlecontrol","vs/workbench/browser/parts/quickopen/quickopen.contribution","vs/workbench/parts/files/common/dirtyFilesTracker","vs/workbench/parts/search/browser/openFileHandler","vs/workbench/parts/search/browser/openAnythingHandler","vs/workbench/parts/codeEditor/electron-browser/workbenchReferenceSearch","vs/workbench/services/textfile/electron-browser/textFileService","vs/workbench/parts/files/electron-browser/views/explorerView","vs/workbench/services/textmodelResolver/common/textModelResolverService","vs/editor/common/config/fontInfo","vs/base/parts/quickopen/browser/quickOpenWidget","vs/editor/contrib/linesOperations/linesOperations","vs/editor/contrib/codeAction/codeAction","vs/editor/contrib/codeAction/codeActionCommands","vs/editor/contrib/codeAction/codeActionTrigger","vs/editor/contrib/format/formattingEdit","vs/editor/contrib/format/format","vs/editor/common/commands/trimTrailingWhitespaceCommand","vs/base/node/encoding","vs/editor/contrib/multicursor/multicursor","vs/editor/contrib/message/messageController","vs/editor/contrib/folding/folding","vs/base/common/iterator","vs/platform/workbench/common/contextkeys","vs/editor/browser/widget/diffEditorWidget","vs/base/browser/ui/selectBox/selectBox","vs/base/browser/htmlContentRenderer","vs/editor/common/services/modeServiceImpl","vs/base/node/config","vs/platform/request/node/request","vs/platform/keybinding/common/abstractKeybindingService","vs/editor/common/editorCommon","vs/editor/standalone/browser/standaloneCodeEditor","vs/editor/standalone/browser/standaloneServices","vs/editor/browser/services/openerService","vs/editor/standalone/browser/colorizer","vs/editor/standalone/browser/simpleServices","vs/editor/common/services/webWorker","vs/editor/common/modes/nullMode","vs/editor/standalone/common/standaloneThemeService","vs/editor/common/config/commonEditorConfig","vs/css!vs/editor/standalone/browser/standalone-tokens","vs/base/node/extfs","vs/editor/common/standalone/standaloneBase","vs/editor/standalone/browser/standaloneLanguages","vs/base/common/winjs.polyfill.promise","fs","util","vs/editor/browser/services/codeEditorServiceImpl","vs/editor/contrib/quickOpen/quickOpen","vs/base/common/linkedList","vs/base/node/request","vs/editor/contrib/snippet/snippetVariables","vs/base/browser/fastDomNode","vs/base/common/functional","vs/base/parts/tree/browser/tree","vs/base/parts/tree/browser/treeDnd","vs/editor/contrib/referenceSearch/referencesController","vs/editor/contrib/suggest/suggestController","vs/editor/contrib/contextmenu/contextmenu","vs/platform/markers/common/markers","vs/editor/contrib/indentation/indentUtils","vs/editor/common/commands/shiftCommand","vs/editor/common/modes/languageConfigurationRegistry","vs/base/browser/ui/menu/menu","vs/base/browser/ui/sash/sash","vs/editor/codesandbox.editor.main","vs/editor/editor.all","vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp","vs/editor/standalone/browser/inspectTokens/inspectTokens","vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
define(__m[280/*vs/base/common/jsonFormatter*/], __M([0/*require*/,1/*exports*/,77/*vs/base/common/json*/]), function (require, exports, Json) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function applyEdit(text, edit) {
        return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
    }
    exports.applyEdit = applyEdit;
    function applyEdits(text, edits) {
        for (var i = edits.length - 1; i >= 0; i--) {
            text = applyEdit(text, edits[i]);
        }
        return text;
    }
    exports.applyEdits = applyEdits;
    function format(documentText, range, options) {
        var initialIndentLevel;
        var value;
        var rangeStart;
        var rangeEnd;
        if (range) {
            rangeStart = range.offset;
            rangeEnd = rangeStart + range.length;
            while (rangeStart > 0 && !isEOL(documentText, rangeStart - 1)) {
                rangeStart--;
            }
            var scanner_1 = Json.createScanner(documentText, true);
            scanner_1.setPosition(rangeEnd);
            scanner_1.scan();
            rangeEnd = scanner_1.getPosition();
            value = documentText.substring(rangeStart, rangeEnd);
            initialIndentLevel = computeIndentLevel(value, 0, options);
        }
        else {
            value = documentText;
            rangeStart = 0;
            rangeEnd = documentText.length;
            initialIndentLevel = 0;
        }
        var eol = getEOL(options, documentText);
        var lineBreak = false;
        var indentLevel = 0;
        var indentValue;
        if (options.insertSpaces) {
            indentValue = repeat(' ', options.tabSize);
        }
        else {
            indentValue = '\t';
        }
        var scanner = Json.createScanner(value, false);
        function newLineAndIndent() {
            return eol + repeat(indentValue, initialIndentLevel + indentLevel);
        }
        function scanNext() {
            var token = scanner.scan();
            lineBreak = false;
            while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
                lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
                token = scanner.scan();
            }
            return token;
        }
        var editOperations = [];
        function addEdit(text, startOffset, endOffset) {
            if (documentText.substring(startOffset, endOffset) !== text) {
                editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
            }
        }
        var firstToken = scanNext();
        if (firstToken !== 16 /* EOF */) {
            var firstTokenStart = scanner.getTokenOffset() + rangeStart;
            var initialIndent = repeat(indentValue, initialIndentLevel);
            addEdit(initialIndent, rangeStart, firstTokenStart);
        }
        while (firstToken !== 16 /* EOF */) {
            var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + rangeStart;
            var secondToken = scanNext();
            var replaceContent = '';
            while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                // comments on the same line: keep them on the same line, but ignore them otherwise
                var commentTokenStart = scanner.getTokenOffset() + rangeStart;
                addEdit(' ', firstTokenEnd, commentTokenStart);
                firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + rangeStart;
                replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
                secondToken = scanNext();
            }
            if (secondToken === 2 /* CloseBraceToken */) {
                if (firstToken !== 1 /* OpenBraceToken */) {
                    indentLevel--;
                    replaceContent = newLineAndIndent();
                }
            }
            else if (secondToken === 4 /* CloseBracketToken */) {
                if (firstToken !== 3 /* OpenBracketToken */) {
                    indentLevel--;
                    replaceContent = newLineAndIndent();
                }
            }
            else if (secondToken !== 16 /* EOF */) {
                switch (firstToken) {
                    case 3 /* OpenBracketToken */:
                    case 1 /* OpenBraceToken */:
                        indentLevel++;
                        replaceContent = newLineAndIndent();
                        break;
                    case 5 /* CommaToken */:
                    case 12 /* LineCommentTrivia */:
                        replaceContent = newLineAndIndent();
                        break;
                    case 13 /* BlockCommentTrivia */:
                        if (lineBreak) {
                            replaceContent = newLineAndIndent();
                        }
                        else {
                            // symbol following comment on the same line: keep on same line, separate with ' '
                            replaceContent = ' ';
                        }
                        break;
                    case 6 /* ColonToken */:
                        replaceContent = ' ';
                        break;
                    case 7 /* NullKeyword */:
                    case 8 /* TrueKeyword */:
                    case 9 /* FalseKeyword */:
                    case 11 /* NumericLiteral */:
                        if (secondToken === 7 /* NullKeyword */ || secondToken === 9 /* FalseKeyword */ || secondToken === 11 /* NumericLiteral */) {
                            replaceContent = ' ';
                        }
                        break;
                }
                if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                    replaceContent = newLineAndIndent();
                }
            }
            var secondTokenStart = scanner.getTokenOffset() + rangeStart;
            addEdit(replaceContent, firstTokenEnd, secondTokenStart);
            firstToken = secondToken;
        }
        return editOperations;
    }
    exports.format = format;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    function computeIndentLevel(content, offset, options) {
        var i = 0;
        var nChars = 0;
        var tabSize = options.tabSize || 4;
        while (i < content.length) {
            var ch = content.charAt(i);
            if (ch === ' ') {
                nChars++;
            }
            else if (ch === '\t') {
                nChars += tabSize;
            }
            else {
                break;
            }
            i++;
        }
        return Math.floor(nChars / tabSize);
    }
    function getEOL(options, text) {
        for (var i = 0; i < text.length; i++) {
            var ch = text.charAt(i);
            if (ch === '\r') {
                if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    return '\r\n';
                }
                return '\r';
            }
            else if (ch === '\n') {
                return '\n';
            }
        }
        return (options && options.eol) || '\n';
    }
    function isEOL(text, offset) {
        return '\r\n'.indexOf(text.charAt(offset)) !== -1;
    }
});

define(__m[234/*vs/base/common/jsonEdit*/], __M([0/*require*/,1/*exports*/,77/*vs/base/common/json*/,280/*vs/base/common/jsonFormatter*/]), function (require, exports, json_1, jsonFormatter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeProperty(text, path, formattingOptions) {
        return setProperty(text, path, void 0, formattingOptions);
    }
    exports.removeProperty = removeProperty;
    function setProperty(text, path, value, formattingOptions, getInsertionIndex) {
        var _a;
        var errors = [];
        var root = json_1.parseTree(text, errors);
        var parent = void 0;
        var lastSegment = void 0;
        while (path.length > 0) {
            lastSegment = path.pop();
            parent = json_1.findNodeAtLocation(root, path);
            if (parent === void 0 && value !== void 0) {
                if (typeof lastSegment === 'string') {
                    value = (_a = {}, _a[lastSegment] = value, _a);
                }
                else {
                    value = [value];
                }
            }
            else {
                break;
            }
        }
        if (!parent) {
            // empty document
            if (value === void 0) { // delete
                throw new Error('Can not delete in empty document');
            }
            return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);
        }
        else if (parent.type === 'object' && typeof lastSegment === 'string') {
            var existing = json_1.findNodeAtLocation(parent, [lastSegment]);
            if (existing !== void 0) {
                if (value === void 0) { // delete
                    var propertyIndex = parent.children.indexOf(existing.parent);
                    var removeBegin = void 0;
                    var removeEnd = existing.parent.offset + existing.parent.length;
                    if (propertyIndex > 0) {
                        // remove the comma of the previous node
                        var previous = parent.children[propertyIndex - 1];
                        removeBegin = previous.offset + previous.length;
                    }
                    else {
                        removeBegin = parent.offset + 1;
                        if (parent.children.length > 1) {
                            // remove the comma of the next node
                            var next = parent.children[1];
                            removeEnd = next.offset;
                        }
                    }
                    return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);
                }
                else {
                    // set value of existing property
                    return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);
                }
            }
            else {
                if (value === void 0) { // delete
                    return []; // property does not exist, nothing to do
                }
                var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
                var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
                var edit = void 0;
                if (index > 0) {
                    var previous = parent.children[index - 1];
                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
                }
                else if (parent.children.length === 0) {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };
                }
                else {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
                }
                return withFormatting(text, edit, formattingOptions);
            }
        }
        else if (parent.type === 'array' && typeof lastSegment === 'number') {
            var insertIndex = lastSegment;
            if (insertIndex === -1) {
                // Insert
                var newProperty = "" + JSON.stringify(value);
                var edit = void 0;
                if (parent.children.length === 0) {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };
                }
                else {
                    var previous = parent.children[parent.children.length - 1];
                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
                }
                return withFormatting(text, edit, formattingOptions);
            }
            else {
                if (value === void 0 && parent.children.length >= 0) {
                    //Removal
                    var removalIndex = lastSegment;
                    var toRemove = parent.children[removalIndex];
                    var edit = void 0;
                    if (parent.children.length === 1) {
                        // only item
                        edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
                    }
                    else if (parent.children.length - 1 === removalIndex) {
                        // last item
                        var previous = parent.children[removalIndex - 1];
                        var offset = previous.offset + previous.length;
                        var parentEndOffset = parent.offset + parent.length;
                        edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
                    }
                    else {
                        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
                    }
                    return withFormatting(text, edit, formattingOptions);
                }
                else {
                    throw new Error('Array modification not supported yet');
                }
            }
        }
        else {
            throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
        }
    }
    exports.setProperty = setProperty;
    function withFormatting(text, edit, formattingOptions) {
        // apply the edit
        var newText = jsonFormatter_1.applyEdit(text, edit);
        // format the new text
        var begin = edit.offset;
        var end = edit.offset + edit.content.length;
        var edits = jsonFormatter_1.format(newText, { offset: begin, length: end - begin }, formattingOptions);
        // apply the formatting edits and track the begin and end offsets of the changes
        for (var i = edits.length - 1; i >= 0; i--) {
            var edit_1 = edits[i];
            newText = jsonFormatter_1.applyEdit(newText, edit_1);
            begin = Math.min(begin, edit_1.offset);
            end = Math.max(end, edit_1.offset + edit_1.length);
            end += edit_1.content.length - edit_1.length;
        }
        // create a single edit with all changes
        var editLength = text.length - (newText.length - end) - begin;
        return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

'use strict';

/*global define*/

// This module can be loaded in an amd and commonjs-context.
// Because we want both instances to use the same perf-data
// we store them globally
// stores data as 'type','name','startTime','duration'

if (typeof define !== "function" && typeof module === "object" && typeof module.exports === "object") {
	// this is commonjs, fake amd
	global.define = function (dep, callback) {
		module.exports = callback();
		global.define = undefined;
	};
}

define("vs/base/common/performance", [], function () {

	var _global = this;
	if (typeof global !== 'undefined') {
		_global = global;
	}
	_global._performanceEntries = _global._performanceEntries || [];

	// const _now = global.performance && performance.now ? performance.now : Date.now
	const _now = Date.now;

	function importEntries(entries) {
		global._performanceEntries.splice(0, 0, ...entries);
	}

	function exportEntries() {
		return global._performanceEntries.slice(0);
	}

	function getEntries(type, name) {
		const result = [];
		const entries = global._performanceEntries;
		for (let i = 0; i < entries.length; i += 5) {
			if (entries[i] === type && (name === void 0 || entries[i + 1] === name)) {
				result.push({
					type: entries[i],
					name: entries[i + 1],
					startTime: entries[i + 2],
					duration: entries[i + 3],
					seq: entries[i + 4],
				});
			}
		}

		return result.sort((a, b) => {
			return a.startTime - b.startTime || a.seq - b.seq;
		});
	}

	function getEntry(type, name) {
		const entries = global._performanceEntries;
		for (let i = 0; i < entries.length; i += 5) {
			if (entries[i] === type && entries[i + 1] === name) {
				return {
					type: entries[i],
					name: entries[i + 1],
					startTime: entries[i + 2],
					duration: entries[i + 3],
					seq: entries[i + 4],
				};
			}
		}
	}

	function getDuration(from, to) {
		const entries = global._performanceEntries;
		let target = to;
		let endTime = 0;
		for (let i = entries.length - 1; i >= 0; i -= 5) {
			if (entries[i - 3] === target) {
				if (target === to) {
					// found `to` (end of interval)
					endTime = entries[i - 2];
					target = from;
				} else {
					return endTime - entries[i - 2];
				}
			}
		}
		return 0;
	}

	let seq = 0;

	function mark(name) {
		global._performanceEntries.push('mark', name, _now(), 0, seq++);
		if (typeof console.timeStamp === 'function') {
			console.timeStamp(name);
		}
	}

	function measure(name, from, to) {

		let startTime;
		let duration;
		let now = _now();

		if (!from) {
			startTime = now;
		} else {
			startTime = _getLastStartTime(from);
		}

		if (!to) {
			duration = now - startTime;
		} else {
			duration = _getLastStartTime(to) - startTime;
		}

		global._performanceEntries.push('measure', name, startTime, duration);
	}

	function _getLastStartTime(name) {
		const entries = global._performanceEntries;
		for (let i = entries.length - 1; i >= 0; i -= 5) {
			if (entries[i - 3] === name) {
				return entries[i - 2];
			}
		}

		throw new Error(name + ' not found');
	}

	var exports = {
		mark: mark,
		measure: measure,
		getEntries: getEntries,
		getEntry: getEntry,
		getDuration: getDuration,
		importEntries: importEntries,
		exportEntries: exportEntries
	};

	return exports;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[130/*vs/base/common/scanCode*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var scanCodeIntToStr = [];
    var scanCodeStrToInt = Object.create(null);
    var scanCodeLowerCaseStrToInt = Object.create(null);
    exports.ScanCodeUtils = {
        lowerCaseToEnum: function (scanCode) { return scanCodeLowerCaseStrToInt[scanCode] || 0 /* None */; },
        toEnum: function (scanCode) { return scanCodeStrToInt[scanCode] || 0 /* None */; },
        toString: function (scanCode) { return scanCodeIntToStr[scanCode] || 'None'; }
    };
    /**
     * -1 if a ScanCode => KeyCode mapping depends on kb layout.
     */
    exports.IMMUTABLE_CODE_TO_KEY_CODE = [];
    /**
     * -1 if a KeyCode => ScanCode mapping depends on kb layout.
     */
    exports.IMMUTABLE_KEY_CODE_TO_CODE = [];
    var ScanCodeBinding = /** @class */ (function () {
        function ScanCodeBinding(ctrlKey, shiftKey, altKey, metaKey, scanCode) {
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
            this.metaKey = metaKey;
            this.scanCode = scanCode;
        }
        ScanCodeBinding.prototype.equals = function (other) {
            return (this.ctrlKey === other.ctrlKey
                && this.shiftKey === other.shiftKey
                && this.altKey === other.altKey
                && this.metaKey === other.metaKey
                && this.scanCode === other.scanCode);
        };
        /**
         * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
         */
        ScanCodeBinding.prototype.isDuplicateModifierCase = function () {
            return ((this.ctrlKey && (this.scanCode === 157 /* ControlLeft */ || this.scanCode === 161 /* ControlRight */))
                || (this.shiftKey && (this.scanCode === 158 /* ShiftLeft */ || this.scanCode === 162 /* ShiftRight */))
                || (this.altKey && (this.scanCode === 159 /* AltLeft */ || this.scanCode === 163 /* AltRight */))
                || (this.metaKey && (this.scanCode === 160 /* MetaLeft */ || this.scanCode === 164 /* MetaRight */)));
        };
        return ScanCodeBinding;
    }());
    exports.ScanCodeBinding = ScanCodeBinding;
    (function () {
        function d(intScanCode, strScanCode) {
            scanCodeIntToStr[intScanCode] = strScanCode;
            scanCodeStrToInt[strScanCode] = intScanCode;
            scanCodeLowerCaseStrToInt[strScanCode.toLowerCase()] = intScanCode;
        }
        d(0 /* None */, 'None');
        d(1 /* Hyper */, 'Hyper');
        d(2 /* Super */, 'Super');
        d(3 /* Fn */, 'Fn');
        d(4 /* FnLock */, 'FnLock');
        d(5 /* Suspend */, 'Suspend');
        d(6 /* Resume */, 'Resume');
        d(7 /* Turbo */, 'Turbo');
        d(8 /* Sleep */, 'Sleep');
        d(9 /* WakeUp */, 'WakeUp');
        d(10 /* KeyA */, 'KeyA');
        d(11 /* KeyB */, 'KeyB');
        d(12 /* KeyC */, 'KeyC');
        d(13 /* KeyD */, 'KeyD');
        d(14 /* KeyE */, 'KeyE');
        d(15 /* KeyF */, 'KeyF');
        d(16 /* KeyG */, 'KeyG');
        d(17 /* KeyH */, 'KeyH');
        d(18 /* KeyI */, 'KeyI');
        d(19 /* KeyJ */, 'KeyJ');
        d(20 /* KeyK */, 'KeyK');
        d(21 /* KeyL */, 'KeyL');
        d(22 /* KeyM */, 'KeyM');
        d(23 /* KeyN */, 'KeyN');
        d(24 /* KeyO */, 'KeyO');
        d(25 /* KeyP */, 'KeyP');
        d(26 /* KeyQ */, 'KeyQ');
        d(27 /* KeyR */, 'KeyR');
        d(28 /* KeyS */, 'KeyS');
        d(29 /* KeyT */, 'KeyT');
        d(30 /* KeyU */, 'KeyU');
        d(31 /* KeyV */, 'KeyV');
        d(32 /* KeyW */, 'KeyW');
        d(33 /* KeyX */, 'KeyX');
        d(34 /* KeyY */, 'KeyY');
        d(35 /* KeyZ */, 'KeyZ');
        d(36 /* Digit1 */, 'Digit1');
        d(37 /* Digit2 */, 'Digit2');
        d(38 /* Digit3 */, 'Digit3');
        d(39 /* Digit4 */, 'Digit4');
        d(40 /* Digit5 */, 'Digit5');
        d(41 /* Digit6 */, 'Digit6');
        d(42 /* Digit7 */, 'Digit7');
        d(43 /* Digit8 */, 'Digit8');
        d(44 /* Digit9 */, 'Digit9');
        d(45 /* Digit0 */, 'Digit0');
        d(46 /* Enter */, 'Enter');
        d(47 /* Escape */, 'Escape');
        d(48 /* Backspace */, 'Backspace');
        d(49 /* Tab */, 'Tab');
        d(50 /* Space */, 'Space');
        d(51 /* Minus */, 'Minus');
        d(52 /* Equal */, 'Equal');
        d(53 /* BracketLeft */, 'BracketLeft');
        d(54 /* BracketRight */, 'BracketRight');
        d(55 /* Backslash */, 'Backslash');
        d(56 /* IntlHash */, 'IntlHash');
        d(57 /* Semicolon */, 'Semicolon');
        d(58 /* Quote */, 'Quote');
        d(59 /* Backquote */, 'Backquote');
        d(60 /* Comma */, 'Comma');
        d(61 /* Period */, 'Period');
        d(62 /* Slash */, 'Slash');
        d(63 /* CapsLock */, 'CapsLock');
        d(64 /* F1 */, 'F1');
        d(65 /* F2 */, 'F2');
        d(66 /* F3 */, 'F3');
        d(67 /* F4 */, 'F4');
        d(68 /* F5 */, 'F5');
        d(69 /* F6 */, 'F6');
        d(70 /* F7 */, 'F7');
        d(71 /* F8 */, 'F8');
        d(72 /* F9 */, 'F9');
        d(73 /* F10 */, 'F10');
        d(74 /* F11 */, 'F11');
        d(75 /* F12 */, 'F12');
        d(76 /* PrintScreen */, 'PrintScreen');
        d(77 /* ScrollLock */, 'ScrollLock');
        d(78 /* Pause */, 'Pause');
        d(79 /* Insert */, 'Insert');
        d(80 /* Home */, 'Home');
        d(81 /* PageUp */, 'PageUp');
        d(82 /* Delete */, 'Delete');
        d(83 /* End */, 'End');
        d(84 /* PageDown */, 'PageDown');
        d(85 /* ArrowRight */, 'ArrowRight');
        d(86 /* ArrowLeft */, 'ArrowLeft');
        d(87 /* ArrowDown */, 'ArrowDown');
        d(88 /* ArrowUp */, 'ArrowUp');
        d(89 /* NumLock */, 'NumLock');
        d(90 /* NumpadDivide */, 'NumpadDivide');
        d(91 /* NumpadMultiply */, 'NumpadMultiply');
        d(92 /* NumpadSubtract */, 'NumpadSubtract');
        d(93 /* NumpadAdd */, 'NumpadAdd');
        d(94 /* NumpadEnter */, 'NumpadEnter');
        d(95 /* Numpad1 */, 'Numpad1');
        d(96 /* Numpad2 */, 'Numpad2');
        d(97 /* Numpad3 */, 'Numpad3');
        d(98 /* Numpad4 */, 'Numpad4');
        d(99 /* Numpad5 */, 'Numpad5');
        d(100 /* Numpad6 */, 'Numpad6');
        d(101 /* Numpad7 */, 'Numpad7');
        d(102 /* Numpad8 */, 'Numpad8');
        d(103 /* Numpad9 */, 'Numpad9');
        d(104 /* Numpad0 */, 'Numpad0');
        d(105 /* NumpadDecimal */, 'NumpadDecimal');
        d(106 /* IntlBackslash */, 'IntlBackslash');
        d(107 /* ContextMenu */, 'ContextMenu');
        d(108 /* Power */, 'Power');
        d(109 /* NumpadEqual */, 'NumpadEqual');
        d(110 /* F13 */, 'F13');
        d(111 /* F14 */, 'F14');
        d(112 /* F15 */, 'F15');
        d(113 /* F16 */, 'F16');
        d(114 /* F17 */, 'F17');
        d(115 /* F18 */, 'F18');
        d(116 /* F19 */, 'F19');
        d(117 /* F20 */, 'F20');
        d(118 /* F21 */, 'F21');
        d(119 /* F22 */, 'F22');
        d(120 /* F23 */, 'F23');
        d(121 /* F24 */, 'F24');
        d(122 /* Open */, 'Open');
        d(123 /* Help */, 'Help');
        d(124 /* Select */, 'Select');
        d(125 /* Again */, 'Again');
        d(126 /* Undo */, 'Undo');
        d(127 /* Cut */, 'Cut');
        d(128 /* Copy */, 'Copy');
        d(129 /* Paste */, 'Paste');
        d(130 /* Find */, 'Find');
        d(131 /* AudioVolumeMute */, 'AudioVolumeMute');
        d(132 /* AudioVolumeUp */, 'AudioVolumeUp');
        d(133 /* AudioVolumeDown */, 'AudioVolumeDown');
        d(134 /* NumpadComma */, 'NumpadComma');
        d(135 /* IntlRo */, 'IntlRo');
        d(136 /* KanaMode */, 'KanaMode');
        d(137 /* IntlYen */, 'IntlYen');
        d(138 /* Convert */, 'Convert');
        d(139 /* NonConvert */, 'NonConvert');
        d(140 /* Lang1 */, 'Lang1');
        d(141 /* Lang2 */, 'Lang2');
        d(142 /* Lang3 */, 'Lang3');
        d(143 /* Lang4 */, 'Lang4');
        d(144 /* Lang5 */, 'Lang5');
        d(145 /* Abort */, 'Abort');
        d(146 /* Props */, 'Props');
        d(147 /* NumpadParenLeft */, 'NumpadParenLeft');
        d(148 /* NumpadParenRight */, 'NumpadParenRight');
        d(149 /* NumpadBackspace */, 'NumpadBackspace');
        d(150 /* NumpadMemoryStore */, 'NumpadMemoryStore');
        d(151 /* NumpadMemoryRecall */, 'NumpadMemoryRecall');
        d(152 /* NumpadMemoryClear */, 'NumpadMemoryClear');
        d(153 /* NumpadMemoryAdd */, 'NumpadMemoryAdd');
        d(154 /* NumpadMemorySubtract */, 'NumpadMemorySubtract');
        d(155 /* NumpadClear */, 'NumpadClear');
        d(156 /* NumpadClearEntry */, 'NumpadClearEntry');
        d(157 /* ControlLeft */, 'ControlLeft');
        d(158 /* ShiftLeft */, 'ShiftLeft');
        d(159 /* AltLeft */, 'AltLeft');
        d(160 /* MetaLeft */, 'MetaLeft');
        d(161 /* ControlRight */, 'ControlRight');
        d(162 /* ShiftRight */, 'ShiftRight');
        d(163 /* AltRight */, 'AltRight');
        d(164 /* MetaRight */, 'MetaRight');
        d(165 /* BrightnessUp */, 'BrightnessUp');
        d(166 /* BrightnessDown */, 'BrightnessDown');
        d(167 /* MediaPlay */, 'MediaPlay');
        d(168 /* MediaRecord */, 'MediaRecord');
        d(169 /* MediaFastForward */, 'MediaFastForward');
        d(170 /* MediaRewind */, 'MediaRewind');
        d(171 /* MediaTrackNext */, 'MediaTrackNext');
        d(172 /* MediaTrackPrevious */, 'MediaTrackPrevious');
        d(173 /* MediaStop */, 'MediaStop');
        d(174 /* Eject */, 'Eject');
        d(175 /* MediaPlayPause */, 'MediaPlayPause');
        d(176 /* MediaSelect */, 'MediaSelect');
        d(177 /* LaunchMail */, 'LaunchMail');
        d(178 /* LaunchApp2 */, 'LaunchApp2');
        d(179 /* LaunchApp1 */, 'LaunchApp1');
        d(180 /* SelectTask */, 'SelectTask');
        d(181 /* LaunchScreenSaver */, 'LaunchScreenSaver');
        d(182 /* BrowserSearch */, 'BrowserSearch');
        d(183 /* BrowserHome */, 'BrowserHome');
        d(184 /* BrowserBack */, 'BrowserBack');
        d(185 /* BrowserForward */, 'BrowserForward');
        d(186 /* BrowserStop */, 'BrowserStop');
        d(187 /* BrowserRefresh */, 'BrowserRefresh');
        d(188 /* BrowserFavorites */, 'BrowserFavorites');
        d(189 /* ZoomToggle */, 'ZoomToggle');
        d(190 /* MailReply */, 'MailReply');
        d(191 /* MailForward */, 'MailForward');
        d(192 /* MailSend */, 'MailSend');
    })();
    (function () {
        for (var i = 0; i <= 193 /* MAX_VALUE */; i++) {
            exports.IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
        }
        for (var i = 0; i <= 112 /* MAX_VALUE */; i++) {
            exports.IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
        }
        function define(code, keyCode) {
            exports.IMMUTABLE_CODE_TO_KEY_CODE[code] = keyCode;
            if ((keyCode !== 0 /* Unknown */)
                && (keyCode !== 3 /* Enter */)
                && (keyCode !== 5 /* Ctrl */)
                && (keyCode !== 4 /* Shift */)
                && (keyCode !== 6 /* Alt */)
                && (keyCode !== 57 /* Meta */)) {
                exports.IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = code;
            }
        }
        // Manually added due to the exclusion above (due to duplication with NumpadEnter)
        exports.IMMUTABLE_KEY_CODE_TO_CODE[3 /* Enter */] = 46 /* Enter */;
        define(0 /* None */, 0 /* Unknown */);
        define(1 /* Hyper */, 0 /* Unknown */);
        define(2 /* Super */, 0 /* Unknown */);
        define(3 /* Fn */, 0 /* Unknown */);
        define(4 /* FnLock */, 0 /* Unknown */);
        define(5 /* Suspend */, 0 /* Unknown */);
        define(6 /* Resume */, 0 /* Unknown */);
        define(7 /* Turbo */, 0 /* Unknown */);
        define(8 /* Sleep */, 0 /* Unknown */);
        define(9 /* WakeUp */, 0 /* Unknown */);
        // define(ScanCode.KeyA, KeyCode.Unknown);
        // define(ScanCode.KeyB, KeyCode.Unknown);
        // define(ScanCode.KeyC, KeyCode.Unknown);
        // define(ScanCode.KeyD, KeyCode.Unknown);
        // define(ScanCode.KeyE, KeyCode.Unknown);
        // define(ScanCode.KeyF, KeyCode.Unknown);
        // define(ScanCode.KeyG, KeyCode.Unknown);
        // define(ScanCode.KeyH, KeyCode.Unknown);
        // define(ScanCode.KeyI, KeyCode.Unknown);
        // define(ScanCode.KeyJ, KeyCode.Unknown);
        // define(ScanCode.KeyK, KeyCode.Unknown);
        // define(ScanCode.KeyL, KeyCode.Unknown);
        // define(ScanCode.KeyM, KeyCode.Unknown);
        // define(ScanCode.KeyN, KeyCode.Unknown);
        // define(ScanCode.KeyO, KeyCode.Unknown);
        // define(ScanCode.KeyP, KeyCode.Unknown);
        // define(ScanCode.KeyQ, KeyCode.Unknown);
        // define(ScanCode.KeyR, KeyCode.Unknown);
        // define(ScanCode.KeyS, KeyCode.Unknown);
        // define(ScanCode.KeyT, KeyCode.Unknown);
        // define(ScanCode.KeyU, KeyCode.Unknown);
        // define(ScanCode.KeyV, KeyCode.Unknown);
        // define(ScanCode.KeyW, KeyCode.Unknown);
        // define(ScanCode.KeyX, KeyCode.Unknown);
        // define(ScanCode.KeyY, KeyCode.Unknown);
        // define(ScanCode.KeyZ, KeyCode.Unknown);
        // define(ScanCode.Digit1, KeyCode.Unknown);
        // define(ScanCode.Digit2, KeyCode.Unknown);
        // define(ScanCode.Digit3, KeyCode.Unknown);
        // define(ScanCode.Digit4, KeyCode.Unknown);
        // define(ScanCode.Digit5, KeyCode.Unknown);
        // define(ScanCode.Digit6, KeyCode.Unknown);
        // define(ScanCode.Digit7, KeyCode.Unknown);
        // define(ScanCode.Digit8, KeyCode.Unknown);
        // define(ScanCode.Digit9, KeyCode.Unknown);
        // define(ScanCode.Digit0, KeyCode.Unknown);
        define(46 /* Enter */, 3 /* Enter */);
        define(47 /* Escape */, 9 /* Escape */);
        define(48 /* Backspace */, 1 /* Backspace */);
        define(49 /* Tab */, 2 /* Tab */);
        define(50 /* Space */, 10 /* Space */);
        // define(ScanCode.Minus, KeyCode.Unknown);
        // define(ScanCode.Equal, KeyCode.Unknown);
        // define(ScanCode.BracketLeft, KeyCode.Unknown);
        // define(ScanCode.BracketRight, KeyCode.Unknown);
        // define(ScanCode.Backslash, KeyCode.Unknown);
        // define(ScanCode.IntlHash, KeyCode.Unknown);
        // define(ScanCode.Semicolon, KeyCode.Unknown);
        // define(ScanCode.Quote, KeyCode.Unknown);
        // define(ScanCode.Backquote, KeyCode.Unknown);
        // define(ScanCode.Comma, KeyCode.Unknown);
        // define(ScanCode.Period, KeyCode.Unknown);
        // define(ScanCode.Slash, KeyCode.Unknown);
        define(63 /* CapsLock */, 8 /* CapsLock */);
        define(64 /* F1 */, 59 /* F1 */);
        define(65 /* F2 */, 60 /* F2 */);
        define(66 /* F3 */, 61 /* F3 */);
        define(67 /* F4 */, 62 /* F4 */);
        define(68 /* F5 */, 63 /* F5 */);
        define(69 /* F6 */, 64 /* F6 */);
        define(70 /* F7 */, 65 /* F7 */);
        define(71 /* F8 */, 66 /* F8 */);
        define(72 /* F9 */, 67 /* F9 */);
        define(73 /* F10 */, 68 /* F10 */);
        define(74 /* F11 */, 69 /* F11 */);
        define(75 /* F12 */, 70 /* F12 */);
        define(76 /* PrintScreen */, 0 /* Unknown */);
        define(77 /* ScrollLock */, 79 /* ScrollLock */);
        define(78 /* Pause */, 7 /* PauseBreak */);
        define(79 /* Insert */, 19 /* Insert */);
        define(80 /* Home */, 14 /* Home */);
        define(81 /* PageUp */, 11 /* PageUp */);
        define(82 /* Delete */, 20 /* Delete */);
        define(83 /* End */, 13 /* End */);
        define(84 /* PageDown */, 12 /* PageDown */);
        define(85 /* ArrowRight */, 17 /* RightArrow */);
        define(86 /* ArrowLeft */, 15 /* LeftArrow */);
        define(87 /* ArrowDown */, 18 /* DownArrow */);
        define(88 /* ArrowUp */, 16 /* UpArrow */);
        define(89 /* NumLock */, 78 /* NumLock */);
        define(90 /* NumpadDivide */, 108 /* NUMPAD_DIVIDE */);
        define(91 /* NumpadMultiply */, 103 /* NUMPAD_MULTIPLY */);
        define(92 /* NumpadSubtract */, 106 /* NUMPAD_SUBTRACT */);
        define(93 /* NumpadAdd */, 104 /* NUMPAD_ADD */);
        define(94 /* NumpadEnter */, 3 /* Enter */); // Duplicate
        define(95 /* Numpad1 */, 94 /* NUMPAD_1 */);
        define(96 /* Numpad2 */, 95 /* NUMPAD_2 */);
        define(97 /* Numpad3 */, 96 /* NUMPAD_3 */);
        define(98 /* Numpad4 */, 97 /* NUMPAD_4 */);
        define(99 /* Numpad5 */, 98 /* NUMPAD_5 */);
        define(100 /* Numpad6 */, 99 /* NUMPAD_6 */);
        define(101 /* Numpad7 */, 100 /* NUMPAD_7 */);
        define(102 /* Numpad8 */, 101 /* NUMPAD_8 */);
        define(103 /* Numpad9 */, 102 /* NUMPAD_9 */);
        define(104 /* Numpad0 */, 93 /* NUMPAD_0 */);
        define(105 /* NumpadDecimal */, 107 /* NUMPAD_DECIMAL */);
        // define(ScanCode.IntlBackslash, KeyCode.Unknown);
        define(107 /* ContextMenu */, 58 /* ContextMenu */);
        define(108 /* Power */, 0 /* Unknown */);
        define(109 /* NumpadEqual */, 0 /* Unknown */);
        define(110 /* F13 */, 71 /* F13 */);
        define(111 /* F14 */, 72 /* F14 */);
        define(112 /* F15 */, 73 /* F15 */);
        define(113 /* F16 */, 74 /* F16 */);
        define(114 /* F17 */, 75 /* F17 */);
        define(115 /* F18 */, 76 /* F18 */);
        define(116 /* F19 */, 77 /* F19 */);
        define(117 /* F20 */, 0 /* Unknown */);
        define(118 /* F21 */, 0 /* Unknown */);
        define(119 /* F22 */, 0 /* Unknown */);
        define(120 /* F23 */, 0 /* Unknown */);
        define(121 /* F24 */, 0 /* Unknown */);
        define(122 /* Open */, 0 /* Unknown */);
        define(123 /* Help */, 0 /* Unknown */);
        define(124 /* Select */, 0 /* Unknown */);
        define(125 /* Again */, 0 /* Unknown */);
        define(126 /* Undo */, 0 /* Unknown */);
        define(127 /* Cut */, 0 /* Unknown */);
        define(128 /* Copy */, 0 /* Unknown */);
        define(129 /* Paste */, 0 /* Unknown */);
        define(130 /* Find */, 0 /* Unknown */);
        define(131 /* AudioVolumeMute */, 0 /* Unknown */);
        define(132 /* AudioVolumeUp */, 0 /* Unknown */);
        define(133 /* AudioVolumeDown */, 0 /* Unknown */);
        define(134 /* NumpadComma */, 105 /* NUMPAD_SEPARATOR */);
        // define(ScanCode.IntlRo, KeyCode.Unknown);
        define(136 /* KanaMode */, 0 /* Unknown */);
        // define(ScanCode.IntlYen, KeyCode.Unknown);
        define(138 /* Convert */, 0 /* Unknown */);
        define(139 /* NonConvert */, 0 /* Unknown */);
        define(140 /* Lang1 */, 0 /* Unknown */);
        define(141 /* Lang2 */, 0 /* Unknown */);
        define(142 /* Lang3 */, 0 /* Unknown */);
        define(143 /* Lang4 */, 0 /* Unknown */);
        define(144 /* Lang5 */, 0 /* Unknown */);
        define(145 /* Abort */, 0 /* Unknown */);
        define(146 /* Props */, 0 /* Unknown */);
        define(147 /* NumpadParenLeft */, 0 /* Unknown */);
        define(148 /* NumpadParenRight */, 0 /* Unknown */);
        define(149 /* NumpadBackspace */, 0 /* Unknown */);
        define(150 /* NumpadMemoryStore */, 0 /* Unknown */);
        define(151 /* NumpadMemoryRecall */, 0 /* Unknown */);
        define(152 /* NumpadMemoryClear */, 0 /* Unknown */);
        define(153 /* NumpadMemoryAdd */, 0 /* Unknown */);
        define(154 /* NumpadMemorySubtract */, 0 /* Unknown */);
        define(155 /* NumpadClear */, 0 /* Unknown */);
        define(156 /* NumpadClearEntry */, 0 /* Unknown */);
        define(157 /* ControlLeft */, 5 /* Ctrl */); // Duplicate
        define(158 /* ShiftLeft */, 4 /* Shift */); // Duplicate
        define(159 /* AltLeft */, 6 /* Alt */); // Duplicate
        define(160 /* MetaLeft */, 57 /* Meta */); // Duplicate
        define(161 /* ControlRight */, 5 /* Ctrl */); // Duplicate
        define(162 /* ShiftRight */, 4 /* Shift */); // Duplicate
        define(163 /* AltRight */, 6 /* Alt */); // Duplicate
        define(164 /* MetaRight */, 57 /* Meta */); // Duplicate
        define(165 /* BrightnessUp */, 0 /* Unknown */);
        define(166 /* BrightnessDown */, 0 /* Unknown */);
        define(167 /* MediaPlay */, 0 /* Unknown */);
        define(168 /* MediaRecord */, 0 /* Unknown */);
        define(169 /* MediaFastForward */, 0 /* Unknown */);
        define(170 /* MediaRewind */, 0 /* Unknown */);
        define(171 /* MediaTrackNext */, 0 /* Unknown */);
        define(172 /* MediaTrackPrevious */, 0 /* Unknown */);
        define(173 /* MediaStop */, 0 /* Unknown */);
        define(174 /* Eject */, 0 /* Unknown */);
        define(175 /* MediaPlayPause */, 0 /* Unknown */);
        define(176 /* MediaSelect */, 0 /* Unknown */);
        define(177 /* LaunchMail */, 0 /* Unknown */);
        define(178 /* LaunchApp2 */, 0 /* Unknown */);
        define(179 /* LaunchApp1 */, 0 /* Unknown */);
        define(180 /* SelectTask */, 0 /* Unknown */);
        define(181 /* LaunchScreenSaver */, 0 /* Unknown */);
        define(182 /* BrowserSearch */, 0 /* Unknown */);
        define(183 /* BrowserHome */, 0 /* Unknown */);
        define(184 /* BrowserBack */, 0 /* Unknown */);
        define(185 /* BrowserForward */, 0 /* Unknown */);
        define(186 /* BrowserStop */, 0 /* Unknown */);
        define(187 /* BrowserRefresh */, 0 /* Unknown */);
        define(188 /* BrowserFavorites */, 0 /* Unknown */);
        define(189 /* ZoomToggle */, 0 /* Unknown */);
        define(190 /* MailReply */, 0 /* Unknown */);
        define(191 /* MailForward */, 0 /* Unknown */);
        define(192 /* MailSend */, 0 /* Unknown */);
    })();
});

define(__m[168/*vs/base/common/keybindingParser*/], __M([0/*require*/,1/*exports*/,65/*vs/base/common/keyCodes*/,130/*vs/base/common/scanCode*/]), function (require, exports, keyCodes_1, scanCode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingParser = /** @class */ (function () {
        function KeybindingParser() {
        }
        KeybindingParser._readModifiers = function (input) {
            input = input.toLowerCase().trim();
            var ctrl = false;
            var shift = false;
            var alt = false;
            var meta = false;
            var matchedModifier;
            do {
                matchedModifier = false;
                if (/^ctrl(\+|\-)/.test(input)) {
                    ctrl = true;
                    input = input.substr('ctrl-'.length);
                    matchedModifier = true;
                }
                if (/^shift(\+|\-)/.test(input)) {
                    shift = true;
                    input = input.substr('shift-'.length);
                    matchedModifier = true;
                }
                if (/^alt(\+|\-)/.test(input)) {
                    alt = true;
                    input = input.substr('alt-'.length);
                    matchedModifier = true;
                }
                if (/^meta(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('meta-'.length);
                    matchedModifier = true;
                }
                if (/^win(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('win-'.length);
                    matchedModifier = true;
                }
                if (/^cmd(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('cmd-'.length);
                    matchedModifier = true;
                }
            } while (matchedModifier);
            var key;
            var firstSpaceIdx = input.indexOf(' ');
            if (firstSpaceIdx > 0) {
                key = input.substring(0, firstSpaceIdx);
                input = input.substring(firstSpaceIdx);
            }
            else {
                key = input;
                input = '';
            }
            return {
                remains: input,
                ctrl: ctrl,
                shift: shift,
                alt: alt,
                meta: meta,
                key: key
            };
        };
        KeybindingParser.parseSimpleKeybinding = function (input) {
            var mods = this._readModifiers(input);
            var keyCode = keyCodes_1.KeyCodeUtils.fromUserSettings(mods.key);
            return [new keyCodes_1.SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode), mods.remains];
        };
        KeybindingParser.parseKeybinding = function (input, OS) {
            if (!input) {
                return null;
            }
            var _a = this.parseSimpleKeybinding(input), firstPart = _a[0], remains = _a[1];
            var chordPart = null;
            if (remains.length > 0) {
                chordPart = this.parseSimpleKeybinding(remains)[0];
            }
            if (chordPart) {
                return new keyCodes_1.ChordKeybinding(firstPart, chordPart);
            }
            return firstPart;
        };
        KeybindingParser.parseSimpleUserBinding = function (input) {
            var mods = this._readModifiers(input);
            var scanCodeMatch = mods.key.match(/^\[([^\]]+)\]$/);
            if (scanCodeMatch) {
                var strScanCode = scanCodeMatch[1];
                var scanCode = scanCode_1.ScanCodeUtils.lowerCaseToEnum(strScanCode);
                return [new scanCode_1.ScanCodeBinding(mods.ctrl, mods.shift, mods.alt, mods.meta, scanCode), mods.remains];
            }
            var keyCode = keyCodes_1.KeyCodeUtils.fromUserSettings(mods.key);
            return [new keyCodes_1.SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode), mods.remains];
        };
        KeybindingParser.parseUserBinding = function (input) {
            if (!input) {
                return [null, null];
            }
            var _a = this.parseSimpleUserBinding(input), firstPart = _a[0], remains = _a[1];
            var chordPart = null;
            if (remains.length > 0) {
                chordPart = this.parseSimpleUserBinding(remains)[0];
            }
            return [firstPart, chordPart];
        };
        return KeybindingParser;
    }());
    exports.KeybindingParser = KeybindingParser;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[289/*vs/base/common/octicon*/], __M([0/*require*/,1/*exports*/,69/*vs/base/common/filters*/,22/*vs/base/common/strings*/]), function (require, exports, filters_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var octiconStartMarker = '$(';
    function parseOcticons(text) {
        var firstOcticonIndex = text.indexOf(octiconStartMarker);
        if (firstOcticonIndex === -1) {
            return { text: text }; // return early if the word does not include an octicon
        }
        return doParseOcticons(text, firstOcticonIndex);
    }
    exports.parseOcticons = parseOcticons;
    function doParseOcticons(text, firstOcticonIndex) {
        var octiconOffsets = [];
        var textWithoutOcticons = '';
        function appendChars(chars) {
            if (chars) {
                textWithoutOcticons += chars;
                for (var i = 0; i < chars.length; i++) {
                    octiconOffsets.push(octiconsOffset); // make sure to fill in octicon offsets
                }
            }
        }
        var currentOcticonStart = -1;
        var currentOcticonValue = '';
        var octiconsOffset = 0;
        var char;
        var nextChar;
        var offset = firstOcticonIndex;
        var length = text.length;
        // Append all characters until the first octicon
        appendChars(text.substr(0, firstOcticonIndex));
        // example: $(file-symlink-file) my cool $(other-octicon) entry
        while (offset < length) {
            char = text[offset];
            nextChar = text[offset + 1];
            // beginning of octicon: some value $( <--
            if (char === octiconStartMarker[0] && nextChar === octiconStartMarker[1]) {
                currentOcticonStart = offset;
                // if we had a previous potential octicon value without
                // the closing ')', it was actually not an octicon and
                // so we have to add it to the actual value
                appendChars(currentOcticonValue);
                currentOcticonValue = octiconStartMarker;
                offset++; // jump over '('
            }
            // end of octicon: some value $(some-octicon) <--
            else if (char === ')' && currentOcticonStart !== -1) {
                var currentOcticonLength = offset - currentOcticonStart + 1; // +1 to include the closing ')'
                octiconsOffset += currentOcticonLength;
                currentOcticonStart = -1;
                currentOcticonValue = '';
            }
            // within octicon
            else if (currentOcticonStart !== -1) {
                currentOcticonValue += char;
            }
            // any value outside of octicons
            else {
                appendChars(char);
            }
            offset++;
        }
        // if we had a previous potential octicon value without
        // the closing ')', it was actually not an octicon and
        // so we have to add it to the actual value
        appendChars(currentOcticonValue);
        return { text: textWithoutOcticons, octiconOffsets: octiconOffsets };
    }
    function matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        var text = target.text, octiconOffsets = target.octiconOffsets;
        // Return early if there are no octicon markers in the word to match against
        if (!octiconOffsets || octiconOffsets.length === 0) {
            return filters_1.matchesFuzzy(query, text, enableSeparateSubstringMatching);
        }
        // Trim the word to match against because it could have leading
        // whitespace now if the word started with an octicon
        var wordToMatchAgainstWithoutOcticonsTrimmed = strings_1.ltrim(text, ' ');
        var leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;
        // match on value without octicons
        var matches = filters_1.matchesFuzzy(query, wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);
        // Map matches back to offsets with octicons and trimming
        if (matches) {
            for (var i = 0; i < matches.length; i++) {
                var octiconOffset = octiconOffsets[matches[i].start + leadingWhitespaceOffset] /* octicon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;
                matches[i].start += octiconOffset;
                matches[i].end += octiconOffset;
            }
        }
        return matches;
    }
    exports.matchesFuzzyOcticonAware = matchesFuzzyOcticonAware;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[132/*vs/base/parts/quickopen/common/quickOpenScorer*/], __M([0/*require*/,1/*exports*/,166/*vs/base/common/comparers*/,69/*vs/base/common/filters*/,24/*vs/base/common/paths*/,18/*vs/base/common/platform*/,22/*vs/base/common/strings*/]), function (require, exports, comparers_1, filters_1, paths_1, platform_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var NO_MATCH = 0;
    var NO_SCORE = [NO_MATCH, []];
    // const DEBUG = false;
    // const DEBUG_MATRIX = false;
    function score(target, query, queryLower, fuzzy) {
        if (!target || !query) {
            return NO_SCORE; // return early if target or query are undefined
        }
        var targetLength = target.length;
        var queryLength = query.length;
        if (targetLength < queryLength) {
            return NO_SCORE; // impossible for query to be contained in target
        }
        // if (DEBUG) {
        // 	console.group(`Target: ${target}, Query: ${query}`);
        // }
        var targetLower = target.toLowerCase();
        // When not searching fuzzy, we require the query to be contained fully
        // in the target string contiguously.
        if (!fuzzy) {
            var indexOfQueryInTarget = targetLower.indexOf(queryLower);
            if (indexOfQueryInTarget === -1) {
                // if (DEBUG) {
                // 	console.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);
                // }
                return NO_SCORE;
            }
        }
        var res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);
        // if (DEBUG) {
        // 	console.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');
        // 	console.groupEnd();
        // }
        return res;
    }
    exports.score = score;
    function doScore(query, queryLower, queryLength, target, targetLower, targetLength) {
        var scores = [];
        var matches = [];
        //
        // Build Scorer Matrix:
        //
        // The matrix is composed of query q and target t. For each index we score
        // q[i] with t[i] and compare that with the previous score. If the score is
        // equal or larger, we keep the match. In addition to the score, we also keep
        // the length of the consecutive matches to use as boost for the score.
        //
        //      t   a   r   g   e   t
        //  q
        //  u
        //  e
        //  r
        //  y
        //
        for (var queryIndex_1 = 0; queryIndex_1 < queryLength; queryIndex_1++) {
            for (var targetIndex_1 = 0; targetIndex_1 < targetLength; targetIndex_1++) {
                var currentIndex = queryIndex_1 * targetLength + targetIndex_1;
                var leftIndex = currentIndex - 1;
                var diagIndex = (queryIndex_1 - 1) * targetLength + targetIndex_1 - 1;
                var leftScore = targetIndex_1 > 0 ? scores[leftIndex] : 0;
                var diagScore = queryIndex_1 > 0 && targetIndex_1 > 0 ? scores[diagIndex] : 0;
                var matchesSequenceLength = queryIndex_1 > 0 && targetIndex_1 > 0 ? matches[diagIndex] : 0;
                // If we are not matching on the first query character any more, we only produce a
                // score if we had a score previously for the last query index (by looking at the diagScore).
                // This makes sure that the query always matches in sequence on the target. For example
                // given a target of "ede" and a query of "de", we would otherwise produce a wrong high score
                // for query[1] ("e") matching on target[0] ("e") because of the "beginning of word" boost.
                var score_1 = void 0;
                if (!diagScore && queryIndex_1 > 0) {
                    score_1 = 0;
                }
                else {
                    score_1 = computeCharScore(query, queryLower, queryIndex_1, target, targetLower, targetIndex_1, matchesSequenceLength);
                }
                // We have a score and its equal or larger than the left score
                // Match: sequence continues growing from previous diag value
                // Score: increases by diag score value
                if (score_1 && diagScore + score_1 >= leftScore) {
                    matches[currentIndex] = matchesSequenceLength + 1;
                    scores[currentIndex] = diagScore + score_1;
                }
                // We either have no score or the score is lower than the left score
                // Match: reset to 0
                // Score: pick up from left hand side
                else {
                    matches[currentIndex] = NO_MATCH;
                    scores[currentIndex] = leftScore;
                }
            }
        }
        // Restore Positions (starting from bottom right of matrix)
        var positions = [];
        var queryIndex = queryLength - 1;
        var targetIndex = targetLength - 1;
        while (queryIndex >= 0 && targetIndex >= 0) {
            var currentIndex = queryIndex * targetLength + targetIndex;
            var match = matches[currentIndex];
            if (match === NO_MATCH) {
                targetIndex--; // go left
            }
            else {
                positions.push(targetIndex);
                // go up and left
                queryIndex--;
                targetIndex--;
            }
        }
        // Print matrix
        // if (DEBUG_MATRIX) {
        // printMatrix(query, target, matches, scores);
        // }
        return [scores[queryLength * targetLength - 1], positions.reverse()];
    }
    function computeCharScore(query, queryLower, queryIndex, target, targetLower, targetIndex, matchesSequenceLength) {
        var score = 0;
        if (queryLower[queryIndex] !== targetLower[targetIndex]) {
            return score; // no match of characters
        }
        // Character match bonus
        score += 1;
        // if (DEBUG) {
        // 	console.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');
        // }
        // Consecutive match bonus
        if (matchesSequenceLength > 0) {
            score += (matchesSequenceLength * 5);
            // if (DEBUG) {
            // 	console.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));
            // }
        }
        // Same case bonus
        if (query[queryIndex] === target[targetIndex]) {
            score += 1;
            // if (DEBUG) {
            // 	console.log('Same case bonus: +1');
            // }
        }
        // Start of word bonus
        if (targetIndex === 0) {
            score += 8;
            // if (DEBUG) {
            // 	console.log('Start of word bonus: +8');
            // }
        }
        else {
            // After separator bonus
            var separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
            if (separatorBonus) {
                score += separatorBonus;
                // if (DEBUG) {
                // 	console.log('After separtor bonus: +4');
                // }
            }
            // Inside word upper case bonus (camel case)
            else if (filters_1.isUpper(target.charCodeAt(targetIndex))) {
                score += 1;
                // if (DEBUG) {
                // 	console.log('Inside word upper case bonus: +1');
                // }
            }
        }
        // if (DEBUG) {
        // 	console.groupEnd();
        // }
        return score;
    }
    function scoreSeparatorAtPos(charCode) {
        switch (charCode) {
            case 47 /* Slash */:
            case 92 /* Backslash */:
                return 5; // prefer path separators...
            case 95 /* Underline */:
            case 45 /* Dash */:
            case 46 /* Period */:
            case 32 /* Space */:
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
            case 58 /* Colon */:
                return 4; // ...over other separators
            default:
                return 0;
        }
    }
    var NO_ITEM_SCORE = Object.freeze({ score: 0 });
    var PATH_IDENTITY_SCORE = 1 << 18;
    var LABEL_PREFIX_SCORE = 1 << 17;
    var LABEL_CAMELCASE_SCORE = 1 << 16;
    var LABEL_SCORE_THRESHOLD = 1 << 15;
    /**
     * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.
     */
    function prepareQuery(original) {
        var lowercase;
        var containsPathSeparator;
        var value;
        if (original) {
            value = strings_1.stripWildcards(original).replace(/\s/g, ''); // get rid of all wildcards and whitespace
            if (platform_1.isWindows) {
                value = value.replace(/\//g, paths_1.nativeSep); // Help Windows users to search for paths when using slash
            }
            lowercase = value.toLowerCase();
            containsPathSeparator = value.indexOf(paths_1.nativeSep) >= 0;
        }
        return { original: original, value: value, lowercase: lowercase, containsPathSeparator: containsPathSeparator };
    }
    exports.prepareQuery = prepareQuery;
    function scoreItem(item, query, fuzzy, accessor, cache) {
        if (!item || !query.value) {
            return NO_ITEM_SCORE; // we need an item and query to score on at least
        }
        var label = accessor.getItemLabel(item);
        if (!label) {
            return NO_ITEM_SCORE; // we need a label at least
        }
        var description = accessor.getItemDescription(item);
        var cacheHash;
        if (description) {
            cacheHash = "" + label + description + query.value + fuzzy;
        }
        else {
            cacheHash = "" + label + query.value + fuzzy;
        }
        var cached = cache[cacheHash];
        if (cached) {
            return cached;
        }
        var itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);
        cache[cacheHash] = itemScore;
        return itemScore;
    }
    exports.scoreItem = scoreItem;
    function doScoreItem(label, description, path, query, fuzzy) {
        // 1.) treat identity matches on full path highest
        if (path && platform_1.isLinux ? query.original === path : strings_1.equalsIgnoreCase(query.original, path)) {
            return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : void 0 };
        }
        // We only consider label matches if the query is not including file path separators
        var preferLabelMatches = !path || !query.containsPathSeparator;
        if (preferLabelMatches) {
            // 2.) treat prefix matches on the label second highest
            var prefixLabelMatch = filters_1.matchesPrefix(query.value, label);
            if (prefixLabelMatch) {
                return { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };
            }
            // 3.) treat camelcase matches on the label third highest
            var camelcaseLabelMatch = filters_1.matchesCamelCase(query.value, label);
            if (camelcaseLabelMatch) {
                return { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };
            }
            // 4.) prefer scores on the label if any
            var _a = score(label, query.value, query.lowercase, fuzzy), labelScore = _a[0], labelPositions = _a[1];
            if (labelScore) {
                return { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: filters_1.createMatches(labelPositions) };
            }
        }
        // 5.) finally compute description + label scores if we have a description
        if (description) {
            var descriptionPrefix = description;
            if (!!path) {
                descriptionPrefix = "" + description + paths_1.nativeSep; // assume this is a file path
            }
            var descriptionPrefixLength_1 = descriptionPrefix.length;
            var descriptionAndLabel = "" + descriptionPrefix + label;
            var _b = score(descriptionAndLabel, query.value, query.lowercase, fuzzy), labelDescriptionScore = _b[0], labelDescriptionPositions = _b[1];
            if (labelDescriptionScore) {
                var labelDescriptionMatches = filters_1.createMatches(labelDescriptionPositions);
                var labelMatch_1 = [];
                var descriptionMatch_1 = [];
                // We have to split the matches back onto the label and description portions
                labelDescriptionMatches.forEach(function (h) {
                    // Match overlaps label and description part, we need to split it up
                    if (h.start < descriptionPrefixLength_1 && h.end > descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: 0, end: h.end - descriptionPrefixLength_1 });
                        descriptionMatch_1.push({ start: h.start, end: descriptionPrefixLength_1 });
                    }
                    // Match on label part
                    else if (h.start >= descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: h.start - descriptionPrefixLength_1, end: h.end - descriptionPrefixLength_1 });
                    }
                    // Match on description part
                    else {
                        descriptionMatch_1.push(h);
                    }
                });
                return { score: labelDescriptionScore, labelMatch: labelMatch_1, descriptionMatch: descriptionMatch_1 };
            }
        }
        return NO_ITEM_SCORE;
    }
    function compareItemsByScore(itemA, itemB, query, fuzzy, accessor, cache, fallbackComparer) {
        if (fallbackComparer === void 0) { fallbackComparer = fallbackCompare; }
        var itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);
        var itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);
        var scoreA = itemScoreA.score;
        var scoreB = itemScoreB.score;
        // 1.) prefer identity matches
        if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
            }
        }
        // 2.) prefer label prefix matches
        if (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_PREFIX_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer shorter names when both match on label prefix
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 3.) prefer camelcase matches
        if (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer more compact camel case matches over longer
            var comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
            if (comparedByMatchLength !== 0) {
                return comparedByMatchLength;
            }
            // prefer shorter names when both match on label camelcase
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 4.) prefer label scores
        if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
            if (scoreB < LABEL_SCORE_THRESHOLD) {
                return -1;
            }
            if (scoreA < LABEL_SCORE_THRESHOLD) {
                return 1;
            }
        }
        // 5.) compare by score
        if (scoreA !== scoreB) {
            return scoreA > scoreB ? -1 : 1;
        }
        // 6.) scores are identical, prefer more compact matches (label and description)
        var itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
        var itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
        if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
            return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
        }
        // 7.) at this point, scores are identical and match compactness as well
        // for both items so we start to use the fallback compare
        return fallbackComparer(itemA, itemB, query, accessor);
    }
    exports.compareItemsByScore = compareItemsByScore;
    function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
        var hasLabelMatches = (score.labelMatch && score.labelMatch.length);
        var hasDescriptionMatches = (score.descriptionMatch && score.descriptionMatch.length);
        var matchStart = -1;
        var matchEnd = -1;
        // If we have description matches, the start is first of description match
        if (hasDescriptionMatches) {
            matchStart = score.descriptionMatch[0].start;
        }
        // Otherwise, the start is the first label match
        else if (hasLabelMatches) {
            matchStart = score.labelMatch[0].start;
        }
        // If we have label match, the end is the last label match
        // If we had a description match, we add the length of the description
        // as offset to the end to indicate this.
        if (hasLabelMatches) {
            matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
            if (hasDescriptionMatches) {
                var itemDescription = accessor.getItemDescription(item);
                if (itemDescription) {
                    matchEnd += itemDescription.length;
                }
            }
        }
        // If we have just a description match, the end is the last description match
        else if (hasDescriptionMatches) {
            matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
        }
        return matchEnd - matchStart;
    }
    function compareByMatchLength(matchesA, matchesB) {
        if ((!matchesA && !matchesB) || (!matchesA.length && !matchesB.length)) {
            return 0; // make sure to not cause bad comparing when matches are not provided
        }
        if (!matchesB || !matchesB.length) {
            return -1;
        }
        if (!matchesA || !matchesA.length) {
            return 1;
        }
        // Compute match length of A (first to last match)
        var matchStartA = matchesA[0].start;
        var matchEndA = matchesA[matchesA.length - 1].end;
        var matchLengthA = matchEndA - matchStartA;
        // Compute match length of B (first to last match)
        var matchStartB = matchesB[0].start;
        var matchEndB = matchesB[matchesB.length - 1].end;
        var matchLengthB = matchEndB - matchStartB;
        // Prefer shorter match length
        return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
    }
    function fallbackCompare(itemA, itemB, query, accessor) {
        // check for label + description length and prefer shorter
        var labelA = accessor.getItemLabel(itemA);
        var labelB = accessor.getItemLabel(itemB);
        var descriptionA = accessor.getItemDescription(itemA);
        var descriptionB = accessor.getItemDescription(itemB);
        var labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
        var labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
        if (labelDescriptionALength !== labelDescriptionBLength) {
            return labelDescriptionALength - labelDescriptionBLength;
        }
        // check for path length and prefer shorter
        var pathA = accessor.getItemPath(itemA);
        var pathB = accessor.getItemPath(itemB);
        if (pathA && pathB && pathA.length !== pathB.length) {
            return pathA.length - pathB.length;
        }
        // 7.) finally we have equal scores and equal length, we fallback to comparer
        // compare by label
        if (labelA !== labelB) {
            return comparers_1.compareAnything(labelA, labelB, query.value);
        }
        // compare by description
        if (descriptionA && descriptionB && descriptionA !== descriptionB) {
            return comparers_1.compareAnything(descriptionA, descriptionB, query.value);
        }
        // compare by path
        if (pathA && pathB && pathA !== pathB) {
            return comparers_1.compareAnything(pathA, pathB, query.value);
        }
        // equal
        return 0;
    }
    exports.fallbackCompare = fallbackCompare;
});

define(__m[296/*vs/base/parts/tree/browser/treeUtils*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function collapseAll(tree, except) {
        var nav = tree.getNavigator();
        var cur;
        while (cur = nav.next()) {
            if (!except || !isEqualOrParent(tree, except, cur)) {
                tree.collapse(cur);
            }
        }
    }
    exports.collapseAll = collapseAll;
    function isEqualOrParent(tree, element, candidateParent) {
        var nav = tree.getNavigator(element);
        do {
            if (element === candidateParent) {
                return true;
            }
        } while (element = nav.parent());
        return false;
    }
    exports.isEqualOrParent = isEqualOrParent;
    function expandAll(tree) {
        var nav = tree.getNavigator();
        var cur;
        while (cur = nav.next()) {
            tree.expand(cur);
        }
    }
    exports.expandAll = expandAll;
});

define(__m[358/*vs/codesandbox/activityService*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/]), function (require, exports, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxActivityService = /** @class */ (function () {
        function CodeSandboxActivityService() {
        }
        CodeSandboxActivityService.prototype.showActivity = function (compositeOrActionId, badge, clazz, priority) {
            console.log('activityService', compositeOrActionId, badge, clazz, priority);
            return lifecycle_1.toDisposable(function () { return true; });
        };
        CodeSandboxActivityService.prototype.getPinnedViewletIds = function () {
            console.log('getPinnedViewletIds called');
            return [];
        };
        return CodeSandboxActivityService;
    }());
    exports.CodeSandboxActivityService = CodeSandboxActivityService;
});

define(__m[288/*vs/codesandbox/backupFileService*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A service that handles any I/O and state associated with the backup system.
     */
    var CodeSandboxBackupService = /** @class */ (function () {
        function CodeSandboxBackupService() {
        }
        /**
           * Finds out if there are any backups stored.
           */
        CodeSandboxBackupService.prototype.hasBackups = function () {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(false); });
        };
        /**
           * Loads the backup resource for a particular resource within the current workspace.
           *
           * @param resource The resource that is backed up.
           * @return The backup resource if any.
           */
        CodeSandboxBackupService.prototype.loadBackupResource = function (resource) {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        /**
           * Given a resource, returns the associated backup resource.
           *
           * @param resource The resource to get the backup resource for.
           * @return The backup resource.
           */
        CodeSandboxBackupService.prototype.toBackupResource = function (resource) {
            return resource;
        };
        /**
           * Backs up a resource.
           *
           * @param resource The resource to back up.
           * @param content The content of the resource as snapshot.
           * @param versionId The version id of the resource to backup.
           */
        CodeSandboxBackupService.prototype.backupResource = function (resource, content, versionId) {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        /**
           * Gets a list of file backups for the current workspace.
           *
           * @return The list of backups.
           */
        CodeSandboxBackupService.prototype.getWorkspaceFileBackups = function () {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        /**
           * Resolves the backup for the given resource.
           *
           * @param value The contents from a backup resource as stream.
           * @return The backup file's backed up content as text buffer factory.
           */
        CodeSandboxBackupService.prototype.resolveBackupContent = function (backup) {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        /**
           * Discards the backup associated with a resource if it exists..
           *
           * @param resource The resource whose backup is being discarded discard to back up.
           */
        CodeSandboxBackupService.prototype.discardResourceBackup = function (resource) {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        /**
           * Discards all backups associated with the current workspace and prevents further backups from
           * being made.
           */
        CodeSandboxBackupService.prototype.discardAllWorkspaceBackups = function () {
            return new winjs_base_1.TPromise(function (resolve) { return resolve(null); });
        };
        return CodeSandboxBackupService;
    }());
    exports.CodeSandboxBackupService = CodeSandboxBackupService;
});

define(__m[292/*vs/codesandbox/broadcastService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/]), function (require, exports, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxBroadcastService = /** @class */ (function () {
        function CodeSandboxBroadcastService(windowId) {
            this.windowId = windowId;
            this._onBroadcast = new event_1.Emitter();
            this.registerListeners();
        }
        CodeSandboxBroadcastService.prototype.registerListeners = function () {
            var _this = this;
            (window || self).addEventListener('message', function (e) {
                var data = e.data;
                if (data.$type === 'broadcast' && data.$windowId !== _this.windowId) {
                    var b = data.b;
                    _this._onBroadcast.fire(b);
                }
            });
        };
        Object.defineProperty(CodeSandboxBroadcastService.prototype, "onBroadcast", {
            get: function () {
                return this._onBroadcast.event;
            },
            enumerable: true,
            configurable: true
        });
        CodeSandboxBroadcastService.prototype.broadcast = function (b) {
            console.log('Sending broadcast', b);
            (window.parent || window).postMessage({
                $type: 'broadcast',
                $windowId: this.windowId,
                b: b,
            }, '*');
        };
        return CodeSandboxBroadcastService;
    }());
    exports.CodeSandboxBroadcastService = CodeSandboxBroadcastService;
});

define(__m[299/*vs/codesandbox/clipboardService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function copyFromClipboard() {
        var inputEl = document.createElement('input');
        document.body.appendChild(inputEl);
        inputEl.focus();
        document.execCommand('paste');
        var pasteString = inputEl.value;
        document.body.removeChild(inputEl);
        return pasteString;
    }
    var CodeSandboxClipboardService = /** @class */ (function () {
        function CodeSandboxClipboardService() {
        }
        CodeSandboxClipboardService.prototype.writeText = function (text) {
            // @ts-ignore
            navigator.clipboard.writeText(text);
        };
        CodeSandboxClipboardService.prototype.readText = function () {
            return copyFromClipboard() || '';
        };
        CodeSandboxClipboardService.prototype.readFindText = function () {
            return '';
        };
        CodeSandboxClipboardService.prototype.writeFindText = function (text) { };
        CodeSandboxClipboardService.prototype.writeResources = function (resources) { };
        CodeSandboxClipboardService.prototype.readResources = function () {
            return [];
        };
        CodeSandboxClipboardService.prototype.hasResources = function () {
            return false;
        };
        return CodeSandboxClipboardService;
    }());
    exports.CodeSandboxClipboardService = CodeSandboxClipboardService;
});

define(__m[300/*vs/codesandbox/environmentService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxEnvironmentService = /** @class */ (function () {
        function CodeSandboxEnvironmentService() {
            this.args = {
                _: [],
            };
            this.appRoot = '/vscode';
            this.userHome = '/home/codesandbox';
            this.userDataPath = '/vscode/userdata';
            this.appNameLong = 'CodeSandbox';
            this.appQuality = 'Very Good';
            this.appSettingsHome = '/vscode';
            this.appSettingsPath = '/vscode/settings.json';
            this.appKeybindingsPath = '/vscode/keybindings.json';
            this.isExtensionDevelopment = false;
            this.extensionsPath = '/vscode/extensions';
            this.debugExtensionHost = {
                debugId: '',
                port: null,
                break: false,
            };
        }
        return CodeSandboxEnvironmentService;
    }());
    exports.CodeSandboxEnvironmentService = CodeSandboxEnvironmentService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[311/*vs/codesandbox/extensionGalleryService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxExtensionGalleryService = /** @class */ (function () {
        function CodeSandboxExtensionGalleryService() {
        }
        CodeSandboxExtensionGalleryService.prototype.getExtension = function (id, version) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxExtensionGalleryService.prototype.isEnabled = function () {
            return false;
        };
        CodeSandboxExtensionGalleryService.prototype.reportStatistic = function (publisher, name, version, type) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxExtensionGalleryService.prototype.query = function (options) {
            throw new Error('query not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.download = function (extension, operation) {
            throw new Error('	download not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.getReadme = function (extension) {
            throw new Error('	getReadme not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.getManifest = function (extension) {
            throw new Error('	getManifest not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.getChangelog = function (extension) {
            throw new Error('	getChangelog not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.getCoreTranslation = function (extension, languageId) {
            throw new Error('getCoreTranslation not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.loadCompatibleVersion = function (extension) {
            throw new Error('loadCompatibleVersion not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.loadAllDependencies = function (dependencies) {
            throw new Error('loadAllDependencies not implemented');
        };
        CodeSandboxExtensionGalleryService.prototype.getExtensionsReport = function () {
            throw new Error('getExtensionsReport not implemented');
        };
        return CodeSandboxExtensionGalleryService;
    }());
    exports.CodeSandboxExtensionGalleryService = CodeSandboxExtensionGalleryService;
});

define(__m[316/*vs/codesandbox/extensionManagementService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/]), function (require, exports, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxExtensionManagementService = /** @class */ (function () {
        function CodeSandboxExtensionManagementService() {
            this._onInstallExtension = new event_1.Emitter();
            this.onInstallExtension = this
                ._onInstallExtension.event;
            this._onDidInstallExtension = new event_1.Emitter();
            this.onDidInstallExtension = this
                ._onDidInstallExtension.event;
            this._onUninstallExtension = new event_1.Emitter();
            this.onUninstallExtension = this
                ._onUninstallExtension.event;
            this._onDidUninstallExtension = new event_1.Emitter();
            this.onDidUninstallExtension = this
                ._onDidUninstallExtension.event;
        }
        CodeSandboxExtensionManagementService.prototype.zip = function (extension) {
            throw new Error('zip not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.unzip = function (zipLocation, type) {
            throw new Error('unzip not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.install = function (vsix) {
            throw new Error('install not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.installFromGallery = function (extension) {
            throw new Error('installFromGallery not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.uninstall = function (extension, force) {
            throw new Error('uninstall not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.reinstallFromGallery = function (extension) {
            throw new Error('reinstallFromGallery not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.getInstalled = function (type) {
            return new Promise(function () { return []; });
        };
        CodeSandboxExtensionManagementService.prototype.getExtensionsReport = function () {
            throw new Error('getExtensionsReport not implemented');
        };
        CodeSandboxExtensionManagementService.prototype.updateMetadata = function (local, metadata) {
            throw new Error('updateMetadata not implemented');
        };
        return CodeSandboxExtensionManagementService;
    }());
    exports.CodeSandboxExtensionManagementService = CodeSandboxExtensionManagementService;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define(__m[317/*vs/codesandbox/extensionService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,5/*vs/base/common/winjs.base*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, winjs_base_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxExtensionService = /** @class */ (function (_super) {
        __extends(CodeSandboxExtensionService, _super);
        function CodeSandboxExtensionService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onDidRegisterExtensions = _this._register(new event_1.Emitter());
            _this.onDidRegisterExtensions = _this
                ._onDidRegisterExtensions.event;
            _this._onDidChangeExtensionsStatus = _this._register(new event_1.Emitter());
            _this.onDidChangeExtensionsStatus = _this
                ._onDidChangeExtensionsStatus.event;
            return _this;
        }
        CodeSandboxExtensionService.prototype.getInspectPort = function () {
            throw new Error('Method not implemented.');
        };
        /**
           * Send an activation event and activate interested extensions.
           */
        CodeSandboxExtensionService.prototype.activateByEvent = function (activationEvent) {
            return new winjs_base_1.TPromise(function (r) { return r(null); });
        };
        /**
           * An promise that resolves when the installed extensions are registered after
           * their extension points got handled.
           */
        CodeSandboxExtensionService.prototype.whenInstalledExtensionsRegistered = function () {
            return new winjs_base_1.TPromise(function (r) { return r(true); });
        };
        /**
           * Return all registered extensions
           */
        CodeSandboxExtensionService.prototype.getExtensions = function () {
            return new winjs_base_1.TPromise(function (r) { return r([]); });
        };
        /**
           * Read all contributions to an extension point.
           */
        CodeSandboxExtensionService.prototype.readExtensionPointContributions = function (extPoint) {
            return new winjs_base_1.TPromise(function (r) { return r([]); });
        };
        /**
           * Get information about extensions status.
           */
        CodeSandboxExtensionService.prototype.getExtensionsStatus = function () {
            return {};
        };
        /**
           * Check if the extension host can be profiled.
           */
        CodeSandboxExtensionService.prototype.canProfileExtensionHost = function () {
            return false;
        };
        /**
           * Begin an extension host process profile session.
           */
        CodeSandboxExtensionService.prototype.startExtensionHostProfile = function () {
            return new winjs_base_1.TPromise(function (r) { return r(null); });
        };
        /**
           * Restarts the extension host.
           */
        CodeSandboxExtensionService.prototype.restartExtensionHost = function () { };
        /**
           * Starts the extension host.
           */
        CodeSandboxExtensionService.prototype.startExtensionHost = function () { };
        /**
           * Stops the extension host.
           */
        CodeSandboxExtensionService.prototype.stopExtensionHost = function () { };
        return CodeSandboxExtensionService;
    }(lifecycle_1.Disposable));
    exports.CodeSandboxExtensionService = CodeSandboxExtensionService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[331/*vs/codesandbox/hashService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxHashService = /** @class */ (function () {
        function CodeSandboxHashService() {
        }
        CodeSandboxHashService.prototype.createSHA1 = function (content) {
            // TODO: Implement native node module after moving to ESM build
            return content;
        };
        return CodeSandboxHashService;
    }());
    exports.CodeSandboxHashService = CodeSandboxHashService;
});

define(__m[340/*vs/codesandbox/outputService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxOutputService = /** @class */ (function () {
        function CodeSandboxOutputService() {
        }
        CodeSandboxOutputService.prototype.getChannelDescriptors = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxOutputService.prototype.getChannel = function (id) {
            throw new Error('getChannel not implemented.');
        };
        CodeSandboxOutputService.prototype.getActiveChannel = function () {
            throw new Error('getActiveChannel not implemented.');
        };
        CodeSandboxOutputService.prototype.showChannel = function (id, preserveFocus) {
            throw new Error('showChannel not implemented.');
        };
        return CodeSandboxOutputService;
    }());
    exports.CodeSandboxOutputService = CodeSandboxOutputService;
});

define(__m[341/*vs/codesandbox/panelService*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DefaultPanel = /** @class */ (function () {
        function DefaultPanel() {
        }
        DefaultPanel.prototype.getId = function () {
            return 'panel';
        };
        DefaultPanel.prototype.getTitle = function () {
            return 'codesandboxPanel';
        };
        DefaultPanel.prototype.getActions = function () {
            console.log('getActions');
            return [];
        };
        DefaultPanel.prototype.getSecondaryActions = function () {
            console.log('getSecondaryActions');
            return [];
        };
        DefaultPanel.prototype.getContextMenuActions = function () {
            console.log('getContextMenuActions');
            return [];
        };
        DefaultPanel.prototype.getActionItem = function (action) {
            throw new Error('getActionItem');
        };
        DefaultPanel.prototype.getControl = function () {
            throw new Error('getControl');
        };
        DefaultPanel.prototype.focus = function () {
            console.log('focus');
        };
        return DefaultPanel;
    }());
    var panel = new DefaultPanel();
    var CodeSandboxPanelService = /** @class */ (function () {
        function CodeSandboxPanelService() {
        }
        CodeSandboxPanelService.prototype.openPanel = function (id, focus) {
            console.log('openPanel', id, focus);
            return new winjs_base_1.TPromise(function (r) { return r(panel); });
        };
        CodeSandboxPanelService.prototype.getActivePanel = function () {
            return panel;
        };
        CodeSandboxPanelService.prototype.getPanels = function () {
            return [
                {
                    id: 'codesandboxPanel',
                    name: 'CodeSandbox Panel',
                    cssClass: 'csb',
                },
            ];
        };
        CodeSandboxPanelService.prototype.setPanelEnablement = function (id, enabled) {
            console.log('setPanelEnablement', id, enabled);
        };
        return CodeSandboxPanelService;
    }());
    exports.CodeSandboxPanelService = CodeSandboxPanelService;
});

define(__m[354/*vs/codesandbox/requestService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxRequestService = /** @class */ (function () {
        function CodeSandboxRequestService() {
        }
        CodeSandboxRequestService.prototype.request = function (options, token) {
            var request = {
                url: options.url,
                headers: options.headers,
                cache: 'only-if-cached',
                credentials: 'same-origin',
                destination: 'document',
                integrity: undefined,
                isHistoryNavigation: false,
                isReloadNavigation: false,
                keepalive: true,
                method: 'GET',
                mode: 'same-origin',
                redirect: 'error',
                referrer: document.location.origin,
                referrerPolicy: 'origin-only',
            };
            return window.fetch(request).then(function (x) {
                var headers = {};
                x.headers.forEach(function (val, key) {
                    headers[key] = val;
                });
                return {
                    res: {
                        headers: headers,
                        statusCode: x.status,
                    },
                    stream: x.body.getReader(),
                };
            });
        };
        return CodeSandboxRequestService;
    }());
    exports.CodeSandboxRequestService = CodeSandboxRequestService;
});

define(__m[226/*vs/codesandbox/services/codesandbox/browser/codesandboxService*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A service that enables to search for files or with in files.
     */
    var CodeSandboxService = /** @class */ (function () {
        function CodeSandboxService(controller) {
            this.controller = controller;
        }
        CodeSandboxService.prototype.getController = function () {
            return this.controller;
        };
        CodeSandboxService.prototype.runSignal = function (signal, payload) {
            return this.controller.getSignal(signal)(payload);
        };
        CodeSandboxService.prototype.getThemes = function () {
            return this.controller.getState('editor.themes');
        };
        CodeSandboxService.prototype.getCurrentTheme = function () {
            return this.controller.getState('preferences.settings.editorTheme');
        };
        CodeSandboxService.prototype.getFilesByPath = function () {
            var files = {};
            var csbFiles = this.controller.getState('editor.modulesByPath');
            Object.keys(csbFiles).forEach(function (path) {
                files["/sandbox" + path] = csbFiles[path];
            });
            return files;
        };
        CodeSandboxService.prototype.openPreviewExternally = function () {
            // @ts-ignore
            if (typeof window.openNewWindow === 'function') {
                // @ts-ignore
                window.openNewWindow();
            }
        };
        return CodeSandboxService;
    }());
    exports.CodeSandboxService = CodeSandboxService;
});

define(__m[362/*vs/codesandbox/statusbarService*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/]), function (require, exports, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxStatusbarService = /** @class */ (function () {
        function CodeSandboxStatusbarService() {
        }
        CodeSandboxStatusbarService.prototype.addEntry = function (entry, alignment, priority) {
            console.log('Adding statusbar entry', entry, alignment, priority);
            return lifecycle_1.toDisposable(function () { });
        };
        CodeSandboxStatusbarService.prototype.setStatusMessage = function (message, autoDisposeAfter, delayBy) {
            console.log('Setting status message', message);
            return lifecycle_1.toDisposable(function () { });
        };
        return CodeSandboxStatusbarService;
    }());
    exports.CodeSandboxStatusbarService = CodeSandboxStatusbarService;
});

define(__m[369/*vs/codesandbox/windowsService*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,6/*vs/base/common/event*/]), function (require, exports, winjs_base_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxWindowsService = /** @class */ (function () {
        function CodeSandboxWindowsService() {
            var _this = this;
            this._onWindowOpen = new event_1.Emitter();
            this._onWindowFocus = new event_1.Emitter();
            this._onWindowBlur = new event_1.Emitter();
            this._onWindowMaximize = new event_1.Emitter();
            this._onWindowUnmaximize = new event_1.Emitter();
            this.onWindowOpen = this._onWindowOpen.event;
            this.onWindowFocus = this._onWindowFocus.event;
            this.onWindowBlur = this._onWindowBlur.event;
            this.onWindowMaximize = this._onWindowMaximize
                .event;
            this.onWindowUnmaximize = this._onWindowUnmaximize
                .event;
            this.listenForFocus = function () {
                _this._onWindowFocus.fire(0);
            };
            this.listenForBlur = function () {
                _this._onWindowBlur.fire(0);
            };
            window.addEventListener('focus', this.listenForFocus);
            window.addEventListener('blur', this.listenForBlur);
        }
        CodeSandboxWindowsService.prototype.dispose = function () {
            window.removeEventListener('focus', this.listenForFocus);
            window.removeEventListener('blur', this.listenForBlur);
        };
        CodeSandboxWindowsService.prototype.pickFileFolderAndOpen = function (options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.pickFileAndOpen = function (options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.pickFolderAndOpen = function (options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.pickWorkspaceAndOpen = function (options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showMessageBox = function (windowId, options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showSaveDialog = function (windowId, options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showOpenDialog = function (windowId, options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.reloadWindow = function (windowId, args) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openDevTools = function (windowId, options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.toggleDevTools = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.closeWorkspace = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.enterWorkspace = function (windowId, path) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.createAndEnterWorkspace = function (windowId, folders, path) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.saveAndEnterWorkspace = function (windowId, path) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.toggleFullScreen = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.setRepresentedFilename = function (windowId, fileName) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.addRecentlyOpened = function (files) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.newWindowTab = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.removeFromRecentlyOpened = function (paths) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.clearRecentlyOpened = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.getRecentlyOpened = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.focusWindow = function (windowId) {
            return new winjs_base_1.TPromise(function (r) {
                window.focus();
                r(undefined);
            });
        };
        CodeSandboxWindowsService.prototype.closeWindow = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.isFocused = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.isMaximized = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.maximizeWindow = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.unmaximizeWindow = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.minimizeWindow = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.onWindowTitleDoubleClick = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.setDocumentEdited = function (windowId, flag) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.quit = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.relaunch = function (options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showPreviousWindowTab = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showNextWindowTab = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.moveWindowTabToNewWindow = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.mergeAllWindowTabs = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.toggleWindowTabsBar = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.updateTouchBar = function (windowId, items) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.whenSharedProcessReady = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.toggleSharedProcess = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openWindow = function (windowId, paths, options) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openNewWindow = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showWindow = function (windowId) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.getWindows = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.getWindowCount = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.log = function (severity) {
            var messages = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                messages[_i - 1] = arguments[_i];
            }
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.showItemInFolder = function (path) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.getActiveWindowId = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openExternal = function (url) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.startCrashReporter = function (config) {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openAccessibilityOptions = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        CodeSandboxWindowsService.prototype.openAboutDialog = function () {
            console.log('WindowService Called');
            throw new Error('Method not implemented.');
        };
        return CodeSandboxWindowsService;
    }());
    exports.CodeSandboxWindowsService = CodeSandboxWindowsService;
});

define(__m[392/*vs/codesandbox/workspacesService*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxWorkspacesService = /** @class */ (function () {
        function CodeSandboxWorkspacesService() {
        }
        CodeSandboxWorkspacesService.prototype.createWorkspace = function (folders) {
            return new winjs_base_1.TPromise(function (r) {
                return r({
                    id: 'codesandbox-workspace',
                    configPath: '/codesandbox/config.json',
                });
            });
        };
        return CodeSandboxWorkspacesService;
    }());
    exports.CodeSandboxWorkspacesService = CodeSandboxWorkspacesService;
});

define(__m[245/*vs/css!vs/base/browser/ui/breadcrumbs/breadcrumbsWidget*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[281/*vs/css!vs/base/browser/ui/button/button*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[121/*vs/base/browser/ui/button/button*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,68/*vs/base/browser/keyboardEvent*/,75/*vs/base/common/color*/,38/*vs/base/common/objects*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,140/*vs/base/browser/touch*/,281/*vs/css!vs/base/browser/ui/button/button*/]), function (require, exports, DOM, keyboardEvent_1, color_1, objects_1, event_1, lifecycle_1, touch_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultOptions = {
        buttonBackground: color_1.Color.fromHex('#0E639C'),
        buttonHoverBackground: color_1.Color.fromHex('#006BB3'),
        buttonForeground: color_1.Color.white
    };
    var Button = /** @class */ (function (_super) {
        __extends(Button, _super);
        function Button(container, options) {
            var _this = _super.call(this) || this;
            _this._onDidClick = _this._register(new event_1.Emitter());
            _this.options = options || Object.create(null);
            objects_1.mixin(_this.options, defaultOptions, false);
            _this.buttonBackground = _this.options.buttonBackground;
            _this.buttonHoverBackground = _this.options.buttonHoverBackground;
            _this.buttonForeground = _this.options.buttonForeground;
            _this.buttonBorder = _this.options.buttonBorder;
            _this._element = document.createElement('a');
            DOM.addClass(_this._element, 'monaco-button');
            _this._element.tabIndex = 0;
            _this._element.setAttribute('role', 'button');
            container.appendChild(_this._element);
            touch_1.Gesture.addTarget(_this._element);
            _this._register(DOM.addDisposableListener(_this._element, DOM.EventType.CLICK, function (e) {
                if (!_this.enabled) {
                    DOM.EventHelper.stop(e);
                    return;
                }
                _this._onDidClick.fire(e);
            }));
            _this._register(DOM.addDisposableListener(_this._element, DOM.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                var eventHandled = false;
                if (_this.enabled && event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                    _this._onDidClick.fire(e);
                    eventHandled = true;
                }
                else if (event.equals(9 /* Escape */)) {
                    _this._element.blur();
                    eventHandled = true;
                }
                if (eventHandled) {
                    DOM.EventHelper.stop(event, true);
                }
            }));
            _this._register(DOM.addDisposableListener(_this._element, DOM.EventType.MOUSE_OVER, function (e) {
                if (!DOM.hasClass(_this._element, 'disabled')) {
                    _this.setHoverBackground();
                }
            }));
            _this._register(DOM.addDisposableListener(_this._element, DOM.EventType.MOUSE_OUT, function (e) {
                _this.applyStyles(); // restore standard styles
            }));
            // Also set hover background when button is focused for feedback
            _this.focusTracker = _this._register(DOM.trackFocus(_this._element));
            _this._register(_this.focusTracker.onDidFocus(function () { return _this.setHoverBackground(); }));
            _this._register(_this.focusTracker.onDidBlur(function () { return _this.applyStyles(); })); // restore standard styles
            _this.applyStyles();
            return _this;
        }
        Object.defineProperty(Button.prototype, "onDidClick", {
            get: function () { return this._onDidClick.event; },
            enumerable: true,
            configurable: true
        });
        Button.prototype.setHoverBackground = function () {
            var hoverBackground = this.buttonHoverBackground ? this.buttonHoverBackground.toString() : null;
            if (hoverBackground) {
                this._element.style.backgroundColor = hoverBackground;
            }
        };
        Button.prototype.style = function (styles) {
            this.buttonForeground = styles.buttonForeground;
            this.buttonBackground = styles.buttonBackground;
            this.buttonHoverBackground = styles.buttonHoverBackground;
            this.buttonBorder = styles.buttonBorder;
            this.applyStyles();
        };
        Button.prototype.applyStyles = function () {
            if (this._element) {
                var background = this.buttonBackground ? this.buttonBackground.toString() : null;
                var foreground = this.buttonForeground ? this.buttonForeground.toString() : null;
                var border = this.buttonBorder ? this.buttonBorder.toString() : null;
                this._element.style.color = foreground;
                this._element.style.backgroundColor = background;
                this._element.style.borderWidth = border ? '1px' : null;
                this._element.style.borderStyle = border ? 'solid' : null;
                this._element.style.borderColor = border;
            }
        };
        Object.defineProperty(Button.prototype, "element", {
            get: function () {
                return this._element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Button.prototype, "label", {
            set: function (value) {
                if (!DOM.hasClass(this._element, 'monaco-text-button')) {
                    DOM.addClass(this._element, 'monaco-text-button');
                }
                this._element.textContent = value;
                if (this.options.title) {
                    this._element.title = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Button.prototype, "icon", {
            set: function (iconClassName) {
                DOM.addClass(this._element, iconClassName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Button.prototype, "enabled", {
            get: function () {
                return !DOM.hasClass(this._element, 'disabled');
            },
            set: function (value) {
                if (value) {
                    DOM.removeClass(this._element, 'disabled');
                    this._element.setAttribute('aria-disabled', String(false));
                    this._element.tabIndex = 0;
                }
                else {
                    DOM.addClass(this._element, 'disabled');
                    this._element.setAttribute('aria-disabled', String(true));
                    DOM.removeTabIndexAndUpdateFocus(this._element);
                }
            },
            enumerable: true,
            configurable: true
        });
        Button.prototype.focus = function () {
            this._element.focus();
        };
        return Button;
    }(lifecycle_1.Disposable));
    exports.Button = Button;
    var ButtonGroup = /** @class */ (function (_super) {
        __extends(ButtonGroup, _super);
        function ButtonGroup(container, count, options) {
            var _this = _super.call(this) || this;
            _this._buttons = [];
            _this.create(container, count, options);
            return _this;
        }
        Object.defineProperty(ButtonGroup.prototype, "buttons", {
            get: function () {
                return this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        ButtonGroup.prototype.create = function (container, count, options) {
            var _this = this;
            var _loop_1 = function (index) {
                var button = this_1._register(new Button(container, options));
                this_1._buttons.push(button);
                // Implement keyboard access in buttons if there are multiple
                if (count > 1) {
                    this_1._register(DOM.addDisposableListener(button.element, DOM.EventType.KEY_DOWN, function (e) {
                        var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                        var eventHandled = true;
                        // Next / Previous Button
                        var buttonIndexToFocus;
                        if (event.equals(15 /* LeftArrow */)) {
                            buttonIndexToFocus = index > 0 ? index - 1 : _this._buttons.length - 1;
                        }
                        else if (event.equals(17 /* RightArrow */)) {
                            buttonIndexToFocus = index === _this._buttons.length - 1 ? 0 : index + 1;
                        }
                        else {
                            eventHandled = false;
                        }
                        if (eventHandled) {
                            _this._buttons[buttonIndexToFocus].focus();
                            DOM.EventHelper.stop(e, true);
                        }
                    }));
                }
            };
            var this_1 = this;
            for (var index = 0; index < count; index++) {
                _loop_1(index);
            }
        };
        return ButtonGroup;
    }(lifecycle_1.Disposable));
    exports.ButtonGroup = ButtonGroup;
});

define(__m[302/*vs/css!vs/base/browser/ui/dropdown/dropdown*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[224/*vs/css!vs/base/browser/ui/grid/gridview*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[313/*vs/base/browser/ui/breadcrumbs/breadcrumbsWidget*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,223/*vs/base/browser/ui/scrollbar/scrollableElement*/,19/*vs/base/common/arrays*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,134/*vs/base/common/scrollable*/,245/*vs/css!vs/base/browser/ui/breadcrumbs/breadcrumbsWidget*/]), function (require, exports, dom, scrollableElement_1, arrays_1, event_1, lifecycle_1, scrollable_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var BreadcrumbsItem = /** @class */ (function () {
        function BreadcrumbsItem() {
        }
        BreadcrumbsItem.prototype.dispose = function () { };
        return BreadcrumbsItem;
    }());
    exports.BreadcrumbsItem = BreadcrumbsItem;
    var SimpleBreadcrumbsItem = /** @class */ (function (_super) {
        __extends(SimpleBreadcrumbsItem, _super);
        function SimpleBreadcrumbsItem(text, title) {
            if (title === void 0) { title = text; }
            var _this = _super.call(this) || this;
            _this.text = text;
            _this.title = title;
            return _this;
        }
        SimpleBreadcrumbsItem.prototype.equals = function (other) {
            return other === this || other instanceof SimpleBreadcrumbsItem && other.text === this.text && other.title === this.title;
        };
        SimpleBreadcrumbsItem.prototype.render = function (container) {
            var node = document.createElement('div');
            node.title = this.title;
            node.innerText = this.text;
            container.appendChild(node);
        };
        return SimpleBreadcrumbsItem;
    }(BreadcrumbsItem));
    exports.SimpleBreadcrumbsItem = SimpleBreadcrumbsItem;
    var BreadcrumbsWidget = /** @class */ (function () {
        function BreadcrumbsWidget(container) {
            var _this = this;
            this._disposables = new Array();
            this._onDidSelectItem = new event_1.Emitter();
            this._onDidFocusItem = new event_1.Emitter();
            this._onDidChangeFocus = new event_1.Emitter();
            this.onDidSelectItem = this._onDidSelectItem.event;
            this.onDidFocusItem = this._onDidFocusItem.event;
            this.onDidChangeFocus = this._onDidChangeFocus.event;
            this._items = new Array();
            this._nodes = new Array();
            this._freeNodes = new Array();
            this._focusedItemIdx = -1;
            this._selectedItemIdx = -1;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-breadcrumbs';
            this._domNode.tabIndex = 0;
            this._domNode.setAttribute('role', 'list');
            this._scrollable = new scrollableElement_1.DomScrollableElement(this._domNode, {
                vertical: scrollable_1.ScrollbarVisibility.Hidden,
                horizontal: scrollable_1.ScrollbarVisibility.Auto,
                horizontalScrollbarSize: 3,
                useShadows: false,
                scrollYToX: true
            });
            this._disposables.push(this._scrollable);
            this._disposables.push(dom.addStandardDisposableListener(this._domNode, 'click', function (e) { return _this._onClick(e); }));
            container.appendChild(this._scrollable.getDomNode());
            this._styleElement = dom.createStyleSheet(this._domNode);
            var focusTracker = dom.trackFocus(this._domNode);
            this._disposables.push(focusTracker);
            this._disposables.push(focusTracker.onDidBlur(function (_) { return _this._onDidChangeFocus.fire(false); }));
            this._disposables.push(focusTracker.onDidFocus(function (_) { return _this._onDidChangeFocus.fire(true); }));
        }
        BreadcrumbsWidget.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
            this._onDidSelectItem.dispose();
            this._onDidFocusItem.dispose();
            this._onDidChangeFocus.dispose();
            this._domNode.remove();
            this._disposables.length = 0;
            this._nodes.length = 0;
            this._freeNodes.length = 0;
        };
        BreadcrumbsWidget.prototype.layout = function (dim) {
            if (dim) {
                this._domNode.style.width = dim.width + "px";
                this._domNode.style.height = dim.height + "px";
            }
            this._scrollable.setRevealOnScroll(false);
            this._scrollable.scanDomNode();
            this._scrollable.setRevealOnScroll(true);
        };
        BreadcrumbsWidget.prototype.style = function (style) {
            var content = '';
            if (style.breadcrumbsBackground) {
                content += ".monaco-breadcrumbs { background-color: " + style.breadcrumbsBackground + "}";
            }
            if (style.breadcrumbsForeground) {
                content += ".monaco-breadcrumbs .monaco-breadcrumb-item { color: " + style.breadcrumbsForeground + "}\n";
            }
            if (style.breadcrumbsFocusForeground) {
                content += ".monaco-breadcrumbs .monaco-breadcrumb-item.focused { color: " + style.breadcrumbsFocusForeground + "}\n";
            }
            if (style.breadcrumbsFocusAndSelectionForeground) {
                content += ".monaco-breadcrumbs .monaco-breadcrumb-item.focused.selected { color: " + style.breadcrumbsFocusAndSelectionForeground + "}\n";
            }
            if (style.breadcrumbsHoverForeground) {
                content += ".monaco-breadcrumbs .monaco-breadcrumb-item:hover:not(.focused):not(.selected) { color: " + style.breadcrumbsHoverForeground + "}\n";
            }
            if (this._styleElement.innerHTML !== content) {
                this._styleElement.innerHTML = content;
            }
        };
        BreadcrumbsWidget.prototype.domFocus = function () {
            var idx = this._focusedItemIdx >= 0 ? this._focusedItemIdx : this._items.length - 1;
            if (idx >= 0 && idx < this._items.length) {
                this._focus(idx, undefined);
            }
            else {
                this._domNode.focus();
            }
        };
        BreadcrumbsWidget.prototype.isDOMFocused = function () {
            var candidate = document.activeElement;
            while (candidate) {
                if (this._domNode === candidate) {
                    return true;
                }
                candidate = candidate.parentElement;
            }
            return false;
        };
        BreadcrumbsWidget.prototype.getFocused = function () {
            return this._items[this._focusedItemIdx];
        };
        BreadcrumbsWidget.prototype.setFocused = function (item, payload) {
            this._focus(this._items.indexOf(item), payload);
        };
        BreadcrumbsWidget.prototype.focusPrev = function (payload) {
            if (this._focusedItemIdx > 0) {
                this._focus(this._focusedItemIdx - 1, payload);
            }
        };
        BreadcrumbsWidget.prototype.focusNext = function (payload) {
            if (this._focusedItemIdx + 1 < this._nodes.length) {
                this._focus(this._focusedItemIdx + 1, payload);
            }
        };
        BreadcrumbsWidget.prototype._focus = function (nth, payload) {
            this._focusedItemIdx = -1;
            for (var i = 0; i < this._nodes.length; i++) {
                var node = this._nodes[i];
                if (i !== nth) {
                    dom.removeClass(node, 'focused');
                }
                else {
                    this._focusedItemIdx = i;
                    dom.addClass(node, 'focused');
                    node.focus();
                }
            }
            this._reveal(this._focusedItemIdx, true);
            this._onDidFocusItem.fire({ type: 'focus', item: this._items[this._focusedItemIdx], node: this._nodes[this._focusedItemIdx], payload: payload });
        };
        BreadcrumbsWidget.prototype.reveal = function (item) {
            var idx = this._items.indexOf(item);
            if (idx >= 0) {
                this._reveal(idx, false);
            }
        };
        BreadcrumbsWidget.prototype._reveal = function (nth, minimal) {
            var node = this._nodes[nth];
            if (node) {
                var width = this._scrollable.getScrollDimensions().width;
                var scrollLeft = this._scrollable.getScrollPosition().scrollLeft;
                if (!minimal || node.offsetLeft > scrollLeft + width || node.offsetLeft < scrollLeft) {
                    this._scrollable.setRevealOnScroll(false);
                    this._scrollable.setScrollPosition({ scrollLeft: node.offsetLeft });
                    this._scrollable.setRevealOnScroll(true);
                }
            }
        };
        BreadcrumbsWidget.prototype.getSelection = function () {
            return this._items[this._selectedItemIdx];
        };
        BreadcrumbsWidget.prototype.setSelection = function (item, payload) {
            this._select(this._items.indexOf(item), payload);
        };
        BreadcrumbsWidget.prototype._select = function (nth, payload) {
            this._selectedItemIdx = -1;
            for (var i = 0; i < this._nodes.length; i++) {
                var node = this._nodes[i];
                if (i !== nth) {
                    dom.removeClass(node, 'selected');
                }
                else {
                    this._selectedItemIdx = i;
                    dom.addClass(node, 'selected');
                }
            }
            this._onDidSelectItem.fire({ type: 'select', item: this._items[this._selectedItemIdx], node: this._nodes[this._selectedItemIdx], payload: payload });
        };
        BreadcrumbsWidget.prototype.getItems = function () {
            return this._items;
        };
        BreadcrumbsWidget.prototype.setItems = function (items) {
            var _a;
            var prefix;
            var removed;
            try {
                prefix = arrays_1.commonPrefixLength(this._items, items, function (a, b) { return a.equals(b); });
                removed = (_a = this._items).splice.apply(_a, [prefix, this._items.length - prefix].concat(items.slice(prefix)));
                this._render(prefix);
                lifecycle_1.dispose(removed);
                this._focus(-1, undefined);
            }
            catch (e) {
                var newError = new Error("BreadcrumbsItem#setItems: newItems: " + items.length + ", prefix: " + prefix + ", removed: " + removed.length);
                newError.name = e.name;
                newError.stack = e.stack;
                throw newError;
            }
        };
        BreadcrumbsWidget.prototype._render = function (start) {
            for (; start < this._items.length && start < this._nodes.length; start++) {
                var item = this._items[start];
                var node = this._nodes[start];
                this._renderItem(item, node);
            }
            // case a: more nodes -> remove them
            while (start < this._nodes.length) {
                var free = this._nodes.pop();
                this._freeNodes.push(free);
                free.remove();
            }
            // case b: more items -> render them
            for (; start < this._items.length; start++) {
                var item = this._items[start];
                var node = this._freeNodes.length > 0 ? this._freeNodes.pop() : document.createElement('div');
                this._renderItem(item, node);
                this._domNode.appendChild(node);
                this._nodes.push(node);
            }
            this.layout(undefined);
        };
        BreadcrumbsWidget.prototype._renderItem = function (item, container) {
            dom.clearNode(container);
            container.className = '';
            item.render(container);
            container.tabIndex = -1;
            container.setAttribute('role', 'listitem');
            dom.addClass(container, 'monaco-breadcrumb-item');
        };
        BreadcrumbsWidget.prototype._onClick = function (event) {
            for (var el = event.target; el; el = el.parentElement) {
                var idx = this._nodes.indexOf(el);
                if (idx >= 0) {
                    this._focus(idx, event);
                    this._select(idx, event);
                    break;
                }
            }
        };
        return BreadcrumbsWidget;
    }());
    exports.BreadcrumbsWidget = BreadcrumbsWidget;
});

define(__m[332/*vs/css!vs/base/browser/ui/splitview/panelview*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[334/*vs/css!vs/base/browser/ui/splitview/splitview*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[101/*vs/base/browser/ui/splitview/splitview*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,29/*vs/base/common/types*/,8/*vs/base/browser/dom*/,344/*vs/base/common/numbers*/,19/*vs/base/common/arrays*/,487/*vs/base/browser/ui/sash/sash*/,75/*vs/base/common/color*/,220/*vs/base/browser/event*/,334/*vs/css!vs/base/browser/ui/splitview/splitview*/]), function (require, exports, lifecycle_1, event_1, types, dom, numbers_1, arrays_1, sash_1, color_1, event_2) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultStyles = {
        separatorBorder: color_1.Color.transparent
    };
    var State;
    (function (State) {
        State[State["Idle"] = 0] = "Idle";
        State[State["Busy"] = 1] = "Busy";
    })(State || (State = {}));
    var Sizing;
    (function (Sizing) {
        Sizing.Distribute = { type: 'distribute' };
        function Split(index) { return { type: 'split', index: index }; }
        Sizing.Split = Split;
    })(Sizing = exports.Sizing || (exports.Sizing = {}));
    var SplitView = /** @class */ (function (_super) {
        __extends(SplitView, _super);
        function SplitView(container, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.size = 0;
            _this.contentSize = 0;
            _this.proportions = undefined;
            _this.viewItems = [];
            _this.sashItems = [];
            _this.state = State.Idle;
            _this._onDidSashChange = _this._register(new event_1.Emitter());
            _this.onDidSashChange = _this._onDidSashChange.event;
            _this._onDidSashReset = _this._register(new event_1.Emitter());
            _this.onDidSashReset = _this._onDidSashReset.event;
            _this.orientation = types.isUndefined(options.orientation) ? 0 /* VERTICAL */ : options.orientation;
            _this.inverseAltBehavior = !!options.inverseAltBehavior;
            _this.el = document.createElement('div');
            dom.addClass(_this.el, 'monaco-split-view2');
            dom.addClass(_this.el, _this.orientation === 0 /* VERTICAL */ ? 'vertical' : 'horizontal');
            container.appendChild(_this.el);
            _this.sashContainer = dom.append(_this.el, dom.$('.sash-container'));
            _this.viewContainer = dom.append(_this.el, dom.$('.split-view-container'));
            _this.style(options.styles || defaultStyles);
            return _this;
        }
        Object.defineProperty(SplitView.prototype, "length", {
            get: function () {
                return this.viewItems.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitView.prototype, "minimumSize", {
            get: function () {
                return this.viewItems.reduce(function (r, item) { return r + item.view.minimumSize; }, 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitView.prototype, "maximumSize", {
            get: function () {
                return this.length === 0 ? Number.POSITIVE_INFINITY : this.viewItems.reduce(function (r, item) { return r + item.view.maximumSize; }, 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitView.prototype, "orthogonalStartSash", {
            get: function () { return this._orthogonalStartSash; },
            set: function (sash) {
                for (var _i = 0, _a = this.sashItems; _i < _a.length; _i++) {
                    var sashItem = _a[_i];
                    sashItem.sash.orthogonalStartSash = sash;
                }
                this._orthogonalStartSash = sash;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitView.prototype, "orthogonalEndSash", {
            get: function () { return this._orthogonalEndSash; },
            set: function (sash) {
                for (var _i = 0, _a = this.sashItems; _i < _a.length; _i++) {
                    var sashItem = _a[_i];
                    sashItem.sash.orthogonalEndSash = sash;
                }
                this._orthogonalEndSash = sash;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SplitView.prototype, "sashes", {
            get: function () {
                return this.sashItems.map(function (s) { return s.sash; });
            },
            enumerable: true,
            configurable: true
        });
        SplitView.prototype.style = function (styles) {
            if (styles.separatorBorder.isTransparent()) {
                dom.removeClass(this.el, 'separator-border');
                this.el.style.removeProperty('--separator-border');
            }
            else {
                dom.addClass(this.el, 'separator-border');
                this.el.style.setProperty('--separator-border', styles.separatorBorder.toString());
            }
        };
        SplitView.prototype.addView = function (view, size, index) {
            var _this = this;
            if (index === void 0) { index = this.viewItems.length; }
            if (this.state !== State.Idle) {
                throw new Error('Cant modify splitview');
            }
            this.state = State.Busy;
            // Add view
            var container = dom.$('.split-view-view');
            if (index === this.viewItems.length) {
                this.viewContainer.appendChild(container);
            }
            else {
                this.viewContainer.insertBefore(container, this.viewContainer.children.item(index));
            }
            var onChangeDisposable = view.onDidChange(function (size) { return _this.onViewChange(item, size); });
            var containerDisposable = lifecycle_1.toDisposable(function () { return _this.viewContainer.removeChild(container); });
            var disposable = lifecycle_1.combinedDisposable([onChangeDisposable, containerDisposable]);
            var layoutContainer = this.orientation === 0 /* VERTICAL */
                ? function () { return item.container.style.height = item.size + "px"; }
                : function () { return item.container.style.width = item.size + "px"; };
            var layout = function () {
                layoutContainer();
                item.view.layout(item.size, _this.orientation);
            };
            var viewSize;
            if (typeof size === 'number') {
                viewSize = size;
            }
            else if (size.type === 'split') {
                viewSize = this.getViewSize(size.index) / 2;
            }
            else {
                viewSize = view.minimumSize;
            }
            var item = { view: view, container: container, size: viewSize, layout: layout, disposable: disposable };
            this.viewItems.splice(index, 0, item);
            // Add sash
            if (this.viewItems.length > 1) {
                var orientation_1 = this.orientation === 0 /* VERTICAL */ ? 1 /* HORIZONTAL */ : 0 /* VERTICAL */;
                var layoutProvider = this.orientation === 0 /* VERTICAL */ ? { getHorizontalSashTop: function (sash) { return _this.getSashPosition(sash); } } : { getVerticalSashLeft: function (sash) { return _this.getSashPosition(sash); } };
                var sash_2 = new sash_1.Sash(this.sashContainer, layoutProvider, {
                    orientation: orientation_1,
                    orthogonalStartSash: this.orthogonalStartSash,
                    orthogonalEndSash: this.orthogonalEndSash
                });
                var sashEventMapper = this.orientation === 0 /* VERTICAL */
                    ? function (e) { return ({ sash: sash_2, start: e.startY, current: e.currentY, alt: e.altKey }); }
                    : function (e) { return ({ sash: sash_2, start: e.startX, current: e.currentX, alt: e.altKey }); };
                var onStart = event_1.mapEvent(sash_2.onDidStart, sashEventMapper);
                var onStartDisposable = onStart(this.onSashStart, this);
                var onChange = event_1.mapEvent(sash_2.onDidChange, sashEventMapper);
                var onChangeDisposable_1 = onChange(this.onSashChange, this);
                var onEnd = event_1.mapEvent(sash_2.onDidEnd, function () { return arrays_1.firstIndex(_this.sashItems, function (item) { return item.sash === sash_2; }); });
                var onEndDisposable = onEnd(this.onSashEnd, this);
                var onDidResetDisposable = sash_2.onDidReset(function () { return _this._onDidSashReset.fire(arrays_1.firstIndex(_this.sashItems, function (item) { return item.sash === sash_2; })); });
                var disposable_1 = lifecycle_1.combinedDisposable([onStartDisposable, onChangeDisposable_1, onEndDisposable, onDidResetDisposable, sash_2]);
                var sashItem = { sash: sash_2, disposable: disposable_1 };
                this.sashItems.splice(index - 1, 0, sashItem);
            }
            container.appendChild(view.element);
            var highPriorityIndex;
            if (typeof size !== 'number' && size.type === 'split') {
                highPriorityIndex = size.index;
            }
            this.relayout(index, highPriorityIndex);
            this.state = State.Idle;
            if (typeof size !== 'number' && size.type === 'distribute') {
                this.distributeViewSizes();
            }
        };
        SplitView.prototype.removeView = function (index, sizing) {
            if (this.state !== State.Idle) {
                throw new Error('Cant modify splitview');
            }
            this.state = State.Busy;
            if (index < 0 || index >= this.viewItems.length) {
                throw new Error('Index out of bounds');
            }
            // Remove view
            var viewItem = this.viewItems.splice(index, 1)[0];
            viewItem.disposable.dispose();
            // Remove sash
            if (this.viewItems.length >= 1) {
                var sashIndex = Math.max(index - 1, 0);
                var sashItem = this.sashItems.splice(sashIndex, 1)[0];
                sashItem.disposable.dispose();
            }
            this.relayout();
            this.state = State.Idle;
            if (sizing && sizing.type === 'distribute') {
                this.distributeViewSizes();
            }
            return viewItem.view;
        };
        SplitView.prototype.moveView = function (from, to) {
            if (this.state !== State.Idle) {
                throw new Error('Cant modify splitview');
            }
            var size = this.getViewSize(from);
            var view = this.removeView(from);
            this.addView(view, size, to);
        };
        SplitView.prototype.swapViews = function (from, to) {
            if (this.state !== State.Idle) {
                throw new Error('Cant modify splitview');
            }
            if (from > to) {
                return this.swapViews(to, from);
            }
            var fromSize = this.getViewSize(from);
            var toSize = this.getViewSize(to);
            var toView = this.removeView(to);
            var fromView = this.removeView(from);
            this.addView(toView, fromSize, from);
            this.addView(fromView, toSize, to);
        };
        SplitView.prototype.relayout = function (lowPriorityIndex, highPriorityIndex) {
            var contentSize = this.viewItems.reduce(function (r, i) { return r + i.size; }, 0);
            this.resize(this.viewItems.length - 1, this.size - contentSize, undefined, lowPriorityIndex, highPriorityIndex);
            this.distributeEmptySpace();
            this.layoutViews();
            this.saveProportions();
        };
        SplitView.prototype.layout = function (size) {
            var previousSize = Math.max(this.size, this.contentSize);
            this.size = size;
            if (!this.proportions) {
                this.resize(this.viewItems.length - 1, size - previousSize);
            }
            else {
                for (var i = 0; i < this.viewItems.length; i++) {
                    var item = this.viewItems[i];
                    item.size = numbers_1.clamp(Math.round(this.proportions[i] * size), item.view.minimumSize, item.view.maximumSize);
                }
            }
            this.distributeEmptySpace();
            this.layoutViews();
        };
        SplitView.prototype.saveProportions = function () {
            var _this = this;
            if (this.contentSize > 0) {
                this.proportions = this.viewItems.map(function (i) { return i.size / _this.contentSize; });
            }
        };
        SplitView.prototype.onSashStart = function (_a) {
            var _this = this;
            var sash = _a.sash, start = _a.start, alt = _a.alt;
            var index = arrays_1.firstIndex(this.sashItems, function (item) { return item.sash === sash; });
            // This way, we can press Alt while we resize a sash, macOS style!
            var disposable = lifecycle_1.combinedDisposable([
                event_2.domEvent(document.body, 'keydown')(function (e) { return resetSashDragState(_this.sashDragState.current, e.altKey); }),
                event_2.domEvent(document.body, 'keyup')(function () { return resetSashDragState(_this.sashDragState.current, false); })
            ]);
            var resetSashDragState = function (start, alt) {
                var sizes = _this.viewItems.map(function (i) { return i.size; });
                var minDelta = Number.NEGATIVE_INFINITY;
                var maxDelta = Number.POSITIVE_INFINITY;
                if (_this.inverseAltBehavior) {
                    alt = !alt;
                }
                if (alt) {
                    // When we're using the last sash with Alt, we're resizing
                    // the view to the left/up, instead of right/down as usual
                    // Thus, we must do the inverse of the usual
                    var isLastSash = index === _this.sashItems.length - 1;
                    if (isLastSash) {
                        var viewItem = _this.viewItems[index];
                        minDelta = (viewItem.view.minimumSize - viewItem.size) / 2;
                        maxDelta = (viewItem.view.maximumSize - viewItem.size) / 2;
                    }
                    else {
                        var viewItem = _this.viewItems[index + 1];
                        minDelta = (viewItem.size - viewItem.view.maximumSize) / 2;
                        maxDelta = (viewItem.size - viewItem.view.minimumSize) / 2;
                    }
                }
                _this.sashDragState = { start: start, current: start, index: index, sizes: sizes, minDelta: minDelta, maxDelta: maxDelta, alt: alt, disposable: disposable };
            };
            resetSashDragState(start, alt);
        };
        SplitView.prototype.onSashChange = function (_a) {
            var current = _a.current;
            var _b = this.sashDragState, index = _b.index, start = _b.start, sizes = _b.sizes, alt = _b.alt, minDelta = _b.minDelta, maxDelta = _b.maxDelta;
            this.sashDragState.current = current;
            var delta = current - start;
            var newDelta = this.resize(index, delta, sizes, undefined, undefined, minDelta, maxDelta);
            if (alt) {
                var isLastSash = index === this.sashItems.length - 1;
                var newSizes = this.viewItems.map(function (i) { return i.size; });
                var viewItemIndex = isLastSash ? index : index + 1;
                var viewItem = this.viewItems[viewItemIndex];
                var newMinDelta = viewItem.size - viewItem.view.maximumSize;
                var newMaxDelta = viewItem.size - viewItem.view.minimumSize;
                var resizeIndex = isLastSash ? index - 1 : index + 1;
                this.resize(resizeIndex, -newDelta, newSizes, undefined, undefined, newMinDelta, newMaxDelta);
            }
            this.distributeEmptySpace();
            this.layoutViews();
        };
        SplitView.prototype.onSashEnd = function (index) {
            this._onDidSashChange.fire(index);
            this.sashDragState.disposable.dispose();
            this.saveProportions();
        };
        SplitView.prototype.onViewChange = function (item, size) {
            var index = this.viewItems.indexOf(item);
            if (index < 0 || index >= this.viewItems.length) {
                return;
            }
            size = typeof size === 'number' ? size : item.size;
            size = numbers_1.clamp(size, item.view.minimumSize, item.view.maximumSize);
            if (this.inverseAltBehavior && index > 0) {
                // In this case, we want the view to grow or shrink both sides equally
                // so we just resize the "left" side by half and let `resize` do the clamping magic
                this.resize(index - 1, Math.floor((item.size - size) / 2));
                this.distributeEmptySpace();
                this.layoutViews();
            }
            else {
                item.size = size;
                this.relayout(index, undefined);
            }
        };
        SplitView.prototype.resizeView = function (index, size) {
            var _this = this;
            if (this.state !== State.Idle) {
                throw new Error('Cant modify splitview');
            }
            this.state = State.Busy;
            if (index < 0 || index >= this.viewItems.length) {
                return;
            }
            var item = this.viewItems[index];
            size = Math.round(size);
            size = numbers_1.clamp(size, item.view.minimumSize, item.view.maximumSize);
            var delta = size - item.size;
            if (delta !== 0 && index < this.viewItems.length - 1) {
                var downIndexes = arrays_1.range(index + 1, this.viewItems.length);
                var collapseDown = downIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].size - _this.viewItems[i].view.minimumSize); }, 0);
                var expandDown = downIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].view.maximumSize - _this.viewItems[i].size); }, 0);
                var deltaDown = numbers_1.clamp(delta, -expandDown, collapseDown);
                this.resize(index, deltaDown);
                delta -= deltaDown;
            }
            if (delta !== 0 && index > 0) {
                var upIndexes = arrays_1.range(index - 1, -1);
                var collapseUp = upIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].size - _this.viewItems[i].view.minimumSize); }, 0);
                var expandUp = upIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].view.maximumSize - _this.viewItems[i].size); }, 0);
                var deltaUp = numbers_1.clamp(-delta, -collapseUp, expandUp);
                this.resize(index - 1, deltaUp);
            }
            this.distributeEmptySpace();
            this.layoutViews();
            this.saveProportions();
            this.state = State.Idle;
        };
        SplitView.prototype.distributeViewSizes = function () {
            var size = Math.floor(this.size / this.viewItems.length);
            for (var i = 0; i < this.viewItems.length - 1; i++) {
                this.resizeView(i, size);
            }
        };
        SplitView.prototype.getViewSize = function (index) {
            if (index < 0 || index >= this.viewItems.length) {
                return -1;
            }
            return this.viewItems[index].size;
        };
        SplitView.prototype.resize = function (index, delta, sizes, lowPriorityIndex, highPriorityIndex, overloadMinDelta, overloadMaxDelta) {
            var _this = this;
            if (sizes === void 0) { sizes = this.viewItems.map(function (i) { return i.size; }); }
            if (overloadMinDelta === void 0) { overloadMinDelta = Number.NEGATIVE_INFINITY; }
            if (overloadMaxDelta === void 0) { overloadMaxDelta = Number.POSITIVE_INFINITY; }
            if (index < 0 || index >= this.viewItems.length) {
                return 0;
            }
            var upIndexes = arrays_1.range(index, -1);
            var downIndexes = arrays_1.range(index + 1, this.viewItems.length);
            if (typeof highPriorityIndex === 'number') {
                arrays_1.pushToStart(upIndexes, highPriorityIndex);
                arrays_1.pushToStart(downIndexes, highPriorityIndex);
            }
            if (typeof lowPriorityIndex === 'number') {
                arrays_1.pushToEnd(upIndexes, lowPriorityIndex);
                arrays_1.pushToEnd(downIndexes, lowPriorityIndex);
            }
            var upItems = upIndexes.map(function (i) { return _this.viewItems[i]; });
            var upSizes = upIndexes.map(function (i) { return sizes[i]; });
            var downItems = downIndexes.map(function (i) { return _this.viewItems[i]; });
            var downSizes = downIndexes.map(function (i) { return sizes[i]; });
            var minDeltaUp = upIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].view.minimumSize - sizes[i]); }, 0);
            var maxDeltaUp = upIndexes.reduce(function (r, i) { return r + (_this.viewItems[i].view.maximumSize - sizes[i]); }, 0);
            var maxDeltaDown = downIndexes.length === 0 ? Number.POSITIVE_INFINITY : downIndexes.reduce(function (r, i) { return r + (sizes[i] - _this.viewItems[i].view.minimumSize); }, 0);
            var minDeltaDown = downIndexes.length === 0 ? Number.NEGATIVE_INFINITY : downIndexes.reduce(function (r, i) { return r + (sizes[i] - _this.viewItems[i].view.maximumSize); }, 0);
            var minDelta = Math.max(minDeltaUp, minDeltaDown, overloadMinDelta);
            var maxDelta = Math.min(maxDeltaDown, maxDeltaUp, overloadMaxDelta);
            delta = numbers_1.clamp(delta, minDelta, maxDelta);
            for (var i = 0, deltaUp = delta; i < upItems.length; i++) {
                var item = upItems[i];
                var size = numbers_1.clamp(upSizes[i] + deltaUp, item.view.minimumSize, item.view.maximumSize);
                var viewDelta = size - upSizes[i];
                deltaUp -= viewDelta;
                item.size = size;
            }
            for (var i = 0, deltaDown = delta; i < downItems.length; i++) {
                var item = downItems[i];
                var size = numbers_1.clamp(downSizes[i] - deltaDown, item.view.minimumSize, item.view.maximumSize);
                var viewDelta = size - downSizes[i];
                deltaDown += viewDelta;
                item.size = size;
            }
            return delta;
        };
        SplitView.prototype.distributeEmptySpace = function () {
            var contentSize = this.viewItems.reduce(function (r, i) { return r + i.size; }, 0);
            var emptyDelta = this.size - contentSize;
            for (var i = this.viewItems.length - 1; emptyDelta !== 0 && i >= 0; i--) {
                var item = this.viewItems[i];
                var size = numbers_1.clamp(item.size + emptyDelta, item.view.minimumSize, item.view.maximumSize);
                var viewDelta = size - item.size;
                emptyDelta -= viewDelta;
                item.size = size;
            }
        };
        SplitView.prototype.layoutViews = function () {
            // Save new content size
            this.contentSize = this.viewItems.reduce(function (r, i) { return r + i.size; }, 0);
            // Layout views
            this.viewItems.forEach(function (item) { return item.layout(); });
            // Layout sashes
            this.sashItems.forEach(function (item) { return item.sash.layout(); });
            // Update sashes enablement
            var previous = false;
            var collapsesDown = this.viewItems.map(function (i) { return previous = (i.size - i.view.minimumSize > 0) || previous; });
            previous = false;
            var expandsDown = this.viewItems.map(function (i) { return previous = (i.view.maximumSize - i.size > 0) || previous; });
            var reverseViews = this.viewItems.slice().reverse();
            previous = false;
            var collapsesUp = reverseViews.map(function (i) { return previous = (i.size - i.view.minimumSize > 0) || previous; }).reverse();
            previous = false;
            var expandsUp = reverseViews.map(function (i) { return previous = (i.view.maximumSize - i.size > 0) || previous; }).reverse();
            this.sashItems.forEach(function (s, i) {
                var min = !(collapsesDown[i] && expandsUp[i + 1]);
                var max = !(expandsDown[i] && collapsesUp[i + 1]);
                if (min && max) {
                    s.sash.state = 0 /* Disabled */;
                }
                else if (min && !max) {
                    s.sash.state = 1 /* Minimum */;
                }
                else if (!min && max) {
                    s.sash.state = 2 /* Maximum */;
                }
                else {
                    s.sash.state = 3 /* Enabled */;
                }
            });
        };
        SplitView.prototype.getSashPosition = function (sash) {
            var position = 0;
            for (var i = 0; i < this.sashItems.length; i++) {
                position += this.viewItems[i].size;
                if (this.sashItems[i].sash === sash) {
                    return position;
                }
            }
            return 0;
        };
        SplitView.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.viewItems.forEach(function (i) { return i.disposable.dispose(); });
            this.viewItems = [];
            this.sashItems.forEach(function (i) { return i.disposable.dispose(); });
            this.sashItems = [];
        };
        return SplitView;
    }(lifecycle_1.Disposable));
    exports.SplitView = SplitView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[355/*vs/base/browser/ui/centered/centeredViewLayout*/], __M([0/*require*/,1/*exports*/,101/*vs/base/browser/ui/splitview/splitview*/,8/*vs/base/browser/dom*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/]), function (require, exports, splitview_1, dom_1, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GOLDEN_RATIO = {
        leftMarginRatio: 0.1909,
        rightMarginRatio: 0.1909
    };
    function createEmptyView(background) {
        var element = dom_1.$('.centered-layout-margin');
        element.style.height = '100%';
        element.style.backgroundColor = background.toString();
        return {
            element: element,
            layout: function () { return undefined; },
            minimumSize: 60,
            maximumSize: Number.POSITIVE_INFINITY,
            onDidChange: event_1.Event.None
        };
    }
    function toSplitViewView(view, getHeight) {
        return {
            element: view.element,
            get maximumSize() { return view.maximumWidth; },
            get minimumSize() { return view.minimumWidth; },
            onDidChange: event_1.mapEvent(view.onDidChange, function (e) { return e && e.width; }),
            layout: function (size) { return view.layout(size, getHeight()); }
        };
    }
    var CenteredViewLayout = /** @class */ (function () {
        function CenteredViewLayout(container, view, state) {
            if (state === void 0) { state = GOLDEN_RATIO; }
            this.container = container;
            this.view = view;
            this.state = state;
            this.width = 0;
            this.height = 0;
            this.didLayout = false;
            this.splitViewDisposables = [];
            this.container.appendChild(this.view.element);
            // Make sure to hide the split view overflow like sashes #52892
            this.container.style.overflow = 'hidden';
        }
        Object.defineProperty(CenteredViewLayout.prototype, "minimumWidth", {
            get: function () { return this.splitView ? this.splitView.minimumSize : this.view.minimumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CenteredViewLayout.prototype, "maximumWidth", {
            get: function () { return this.splitView ? this.splitView.maximumSize : this.view.maximumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CenteredViewLayout.prototype, "minimumHeight", {
            get: function () { return this.view.minimumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CenteredViewLayout.prototype, "maximumHeight", {
            get: function () { return this.view.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        CenteredViewLayout.prototype.layout = function (width, height) {
            this.width = width;
            this.height = height;
            if (this.splitView) {
                this.splitView.layout(width);
                if (!this.didLayout) {
                    this.resizeMargins();
                }
            }
            else {
                this.view.layout(width, height);
            }
            this.didLayout = true;
        };
        CenteredViewLayout.prototype.resizeMargins = function () {
            this.splitView.resizeView(0, this.state.leftMarginRatio * this.width);
            this.splitView.resizeView(2, this.state.rightMarginRatio * this.width);
        };
        CenteredViewLayout.prototype.isActive = function () {
            return !!this.splitView;
        };
        CenteredViewLayout.prototype.styles = function (style) {
            this.style = style;
            if (this.splitView) {
                this.splitView.style(this.style);
                this.emptyViews[0].element.style.backgroundColor = this.style.background.toString();
                this.emptyViews[1].element.style.backgroundColor = this.style.background.toString();
            }
        };
        CenteredViewLayout.prototype.activate = function (active) {
            var _this = this;
            if (active === this.isActive()) {
                return;
            }
            if (active) {
                this.container.removeChild(this.view.element);
                this.splitView = new splitview_1.SplitView(this.container, {
                    inverseAltBehavior: true,
                    orientation: 1 /* HORIZONTAL */,
                    styles: this.style
                });
                this.splitViewDisposables.push(this.splitView.onDidSashChange(function () {
                    _this.state.leftMarginRatio = _this.splitView.getViewSize(0) / _this.width;
                    _this.state.rightMarginRatio = _this.splitView.getViewSize(2) / _this.width;
                }));
                this.splitViewDisposables.push(this.splitView.onDidSashReset(function () {
                    _this.state.leftMarginRatio = GOLDEN_RATIO.leftMarginRatio;
                    _this.state.rightMarginRatio = GOLDEN_RATIO.rightMarginRatio;
                    _this.resizeMargins();
                }));
                this.splitView.layout(this.width);
                this.splitView.addView(toSplitViewView(this.view, function () { return _this.height; }), 0);
                this.emptyViews = [createEmptyView(this.style.background), createEmptyView(this.style.background)];
                this.splitView.addView(this.emptyViews[0], this.state.leftMarginRatio * this.width, 0);
                this.splitView.addView(this.emptyViews[1], this.state.rightMarginRatio * this.width, 2);
            }
            else {
                this.container.removeChild(this.splitView.el);
                this.splitViewDisposables = lifecycle_1.dispose(this.splitViewDisposables);
                this.splitView.dispose();
                this.splitView = undefined;
                this.emptyViews = undefined;
                this.container.appendChild(this.view.element);
            }
        };
        CenteredViewLayout.prototype.dispose = function () {
            this.splitViewDisposables = lifecycle_1.dispose(this.splitViewDisposables);
            if (this.splitView) {
                this.splitView.dispose();
                this.splitView = undefined;
            }
        };
        return CenteredViewLayout;
    }());
    exports.CenteredViewLayout = CenteredViewLayout;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[219/*vs/base/browser/ui/grid/gridview*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,101/*vs/base/browser/ui/splitview/splitview*/,4/*vs/base/common/lifecycle*/,8/*vs/base/browser/dom*/,19/*vs/base/common/arrays*/,75/*vs/base/common/color*/,101/*vs/base/browser/ui/splitview/splitview*/,224/*vs/css!vs/base/browser/ui/grid/gridview*/]), function (require, exports, event_1, splitview_1, lifecycle_1, dom_1, arrays_1, color_1, splitview_2) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sizing = splitview_2.Sizing;
    function orthogonal(orientation) {
        return orientation === 0 /* VERTICAL */ ? 1 /* HORIZONTAL */ : 0 /* VERTICAL */;
    }
    exports.orthogonal = orthogonal;
    function isGridBranchNode(node) {
        return !!node.children;
    }
    exports.isGridBranchNode = isGridBranchNode;
    var defaultStyles = {
        separatorBorder: color_1.Color.transparent
    };
    var BranchNode = /** @class */ (function () {
        function BranchNode(orientation, styles, size, orthogonalSize) {
            if (size === void 0) { size = 0; }
            if (orthogonalSize === void 0) { orthogonalSize = 0; }
            this.orientation = orientation;
            this.children = [];
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this.childrenChangeDisposable = lifecycle_1.Disposable.None;
            this._onDidSashReset = new event_1.Emitter();
            this.onDidSashReset = this._onDidSashReset.event;
            this.splitviewSashResetDisposable = lifecycle_1.Disposable.None;
            this.childrenSashResetDisposable = lifecycle_1.Disposable.None;
            this._styles = styles;
            this._size = size;
            this._orthogonalSize = orthogonalSize;
            this.element = dom_1.$('.monaco-grid-branch-node');
            this.splitview = new splitview_1.SplitView(this.element, { orientation: orientation, styles: styles });
            this.splitview.layout(size);
            var onDidSashReset = event_1.mapEvent(this.splitview.onDidSashReset, function (i) { return [i]; });
            this.splitviewSashResetDisposable = onDidSashReset(this._onDidSashReset.fire, this._onDidSashReset);
        }
        Object.defineProperty(BranchNode.prototype, "size", {
            get: function () { return this._size; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "orthogonalSize", {
            get: function () { return this._orthogonalSize; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "styles", {
            get: function () { return this._styles; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "width", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.size : this.orthogonalSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "height", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.orthogonalSize : this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "minimumSize", {
            get: function () {
                return this.children.length === 0 ? 0 : Math.max.apply(Math, this.children.map(function (c) { return c.minimumOrthogonalSize; }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "maximumSize", {
            get: function () {
                return Math.min.apply(Math, this.children.map(function (c) { return c.maximumOrthogonalSize; }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "minimumOrthogonalSize", {
            get: function () {
                return this.splitview.minimumSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "maximumOrthogonalSize", {
            get: function () {
                return this.splitview.maximumSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "minimumWidth", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.minimumOrthogonalSize : this.minimumSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "minimumHeight", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.minimumSize : this.minimumOrthogonalSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "maximumWidth", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.maximumOrthogonalSize : this.maximumSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "maximumHeight", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.maximumSize : this.maximumOrthogonalSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "orthogonalStartSash", {
            get: function () { return this.splitview.orthogonalStartSash; },
            set: function (sash) { this.splitview.orthogonalStartSash = sash; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BranchNode.prototype, "orthogonalEndSash", {
            get: function () { return this.splitview.orthogonalEndSash; },
            set: function (sash) { this.splitview.orthogonalEndSash = sash; },
            enumerable: true,
            configurable: true
        });
        BranchNode.prototype.style = function (styles) {
            this._styles = styles;
            this.splitview.style(styles);
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child instanceof BranchNode) {
                    child.style(styles);
                }
            }
        };
        BranchNode.prototype.layout = function (size) {
            this._orthogonalSize = size;
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.orthogonalLayout(size);
            }
        };
        BranchNode.prototype.orthogonalLayout = function (size) {
            this._size = size;
            this.splitview.layout(size);
        };
        BranchNode.prototype.addChild = function (node, size, index) {
            if (index < 0 || index > this.children.length) {
                throw new Error('Invalid index');
            }
            this.splitview.addView(node, size, index);
            this._addChild(node, index);
            this.onDidChildrenChange();
        };
        BranchNode.prototype._addChild = function (node, index) {
            var first = index === 0;
            var last = index === this.children.length;
            this.children.splice(index, 0, node);
            node.orthogonalStartSash = this.splitview.sashes[index - 1];
            node.orthogonalEndSash = this.splitview.sashes[index];
            if (!first) {
                this.children[index - 1].orthogonalEndSash = this.splitview.sashes[index - 1];
            }
            if (!last) {
                this.children[index + 1].orthogonalStartSash = this.splitview.sashes[index];
            }
        };
        BranchNode.prototype.removeChild = function (index, sizing) {
            if (index < 0 || index >= this.children.length) {
                throw new Error('Invalid index');
            }
            this.splitview.removeView(index, sizing);
            this._removeChild(index);
            this.onDidChildrenChange();
        };
        BranchNode.prototype._removeChild = function (index) {
            var first = index === 0;
            var last = index === this.children.length - 1;
            var child = this.children.splice(index, 1)[0];
            if (!first) {
                this.children[index - 1].orthogonalEndSash = this.splitview.sashes[index - 1];
            }
            if (!last) { // [0,1,2,3] (2) => [0,1,3]
                this.children[index].orthogonalStartSash = this.splitview.sashes[Math.max(index - 1, 0)];
            }
            return child;
        };
        BranchNode.prototype.moveChild = function (from, to) {
            if (from === to) {
                return;
            }
            if (from < 0 || from >= this.children.length) {
                throw new Error('Invalid from index');
            }
            if (to < 0 || to > this.children.length) {
                throw new Error('Invalid to index');
            }
            if (from < to) {
                to--;
            }
            this.splitview.moveView(from, to);
            var child = this._removeChild(from);
            this._addChild(child, to);
        };
        BranchNode.prototype.swapChildren = function (from, to) {
            var _a, _b;
            if (from === to) {
                return;
            }
            if (from < 0 || from >= this.children.length) {
                throw new Error('Invalid from index');
            }
            if (to < 0 || to >= this.children.length) {
                throw new Error('Invalid to index');
            }
            this.splitview.swapViews(from, to);
            _a = [this.children[to].orthogonalStartSash, this.children[to].orthogonalEndSash, this.children[from].orthogonalStartSash, this.children[from].orthogonalEndSash], this.children[from].orthogonalStartSash = _a[0], this.children[from].orthogonalEndSash = _a[1], this.children[to].orthogonalStartSash = _a[2], this.children[to].orthogonalEndSash = _a[3];
            _b = [this.children[to], this.children[from]], this.children[from] = _b[0], this.children[to] = _b[1];
        };
        BranchNode.prototype.resizeChild = function (index, size) {
            if (index < 0 || index >= this.children.length) {
                throw new Error('Invalid index');
            }
            this.splitview.resizeView(index, size);
        };
        BranchNode.prototype.distributeViewSizes = function (recursive) {
            if (recursive === void 0) { recursive = false; }
            this.splitview.distributeViewSizes();
            if (recursive) {
                for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (child instanceof BranchNode) {
                        child.distributeViewSizes(true);
                    }
                }
            }
        };
        BranchNode.prototype.getChildSize = function (index) {
            if (index < 0 || index >= this.children.length) {
                throw new Error('Invalid index');
            }
            return this.splitview.getViewSize(index);
        };
        BranchNode.prototype.onDidChildrenChange = function () {
            var onDidChildrenChange = event_1.anyEvent.apply(void 0, this.children.map(function (c) { return c.onDidChange; }));
            this.childrenChangeDisposable.dispose();
            this.childrenChangeDisposable = onDidChildrenChange(this._onDidChange.fire, this._onDidChange);
            var onDidChildrenSashReset = event_1.anyEvent.apply(void 0, this.children.map(function (c, i) { return event_1.mapEvent(c.onDidSashReset, function (location) { return [i].concat(location); }); }));
            this.childrenSashResetDisposable.dispose();
            this.childrenSashResetDisposable = onDidChildrenSashReset(this._onDidSashReset.fire, this._onDidSashReset);
            this._onDidChange.fire();
        };
        BranchNode.prototype.trySet2x2 = function (other) {
            if (this.children.length !== 2 || other.children.length !== 2) {
                return lifecycle_1.Disposable.None;
            }
            if (this.getChildSize(0) !== other.getChildSize(0)) {
                return lifecycle_1.Disposable.None;
            }
            var _a = this.children, firstChild = _a[0], secondChild = _a[1];
            var _b = other.children, otherFirstChild = _b[0], otherSecondChild = _b[1];
            if (!(firstChild instanceof LeafNode) || !(secondChild instanceof LeafNode)) {
                return lifecycle_1.Disposable.None;
            }
            if (!(otherFirstChild instanceof LeafNode) || !(otherSecondChild instanceof LeafNode)) {
                return lifecycle_1.Disposable.None;
            }
            if (this.orientation === 0 /* VERTICAL */) {
                secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = firstChild;
                firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = secondChild;
                otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = otherFirstChild;
                otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = otherSecondChild;
            }
            else {
                otherFirstChild.linkedWidthNode = secondChild.linkedHeightNode = firstChild;
                otherSecondChild.linkedWidthNode = firstChild.linkedHeightNode = secondChild;
                firstChild.linkedWidthNode = otherSecondChild.linkedHeightNode = otherFirstChild;
                secondChild.linkedWidthNode = otherFirstChild.linkedHeightNode = otherSecondChild;
            }
            var mySash = this.splitview.sashes[0];
            var otherSash = other.splitview.sashes[0];
            mySash.linkedSash = otherSash;
            otherSash.linkedSash = mySash;
            this._onDidChange.fire();
            other._onDidChange.fire();
            return lifecycle_1.toDisposable(function () {
                mySash.linkedSash = otherSash.linkedSash = undefined;
                firstChild.linkedHeightNode = firstChild.linkedWidthNode = undefined;
                secondChild.linkedHeightNode = secondChild.linkedWidthNode = undefined;
                otherFirstChild.linkedHeightNode = otherFirstChild.linkedWidthNode = undefined;
                otherSecondChild.linkedHeightNode = otherSecondChild.linkedWidthNode = undefined;
            });
        };
        BranchNode.prototype.dispose = function () {
            for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.dispose();
            }
            this._onDidChange.dispose();
            this._onDidSashReset.dispose();
            this.splitviewSashResetDisposable.dispose();
            this.childrenSashResetDisposable.dispose();
            this.childrenChangeDisposable.dispose();
            this.splitview.dispose();
        };
        return BranchNode;
    }());
    var LeafNode = /** @class */ (function () {
        function LeafNode(view, orientation, orthogonalSize) {
            if (orthogonalSize === void 0) { orthogonalSize = 0; }
            this.view = view;
            this.orientation = orientation;
            this._size = 0;
            this.onDidSashReset = event_1.Event.None;
            this._onDidLinkedWidthNodeChange = new event_1.Relay();
            this._linkedWidthNode = undefined;
            this._onDidLinkedHeightNodeChange = new event_1.Relay();
            this._linkedHeightNode = undefined;
            this._onDidSetLinkedNode = new event_1.Emitter();
            this._orthogonalSize = orthogonalSize;
            this._onDidViewChange = event_1.mapEvent(this.view.onDidChange, this.orientation === 1 /* HORIZONTAL */ ? function (e) { return e && e.width; } : function (e) { return e && e.height; });
            this.onDidChange = event_1.anyEvent(this._onDidViewChange, this._onDidSetLinkedNode.event, this._onDidLinkedWidthNodeChange.event, this._onDidLinkedHeightNodeChange.event);
        }
        Object.defineProperty(LeafNode.prototype, "size", {
            get: function () { return this._size; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "orthogonalSize", {
            get: function () { return this._orthogonalSize; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "linkedWidthNode", {
            get: function () { return this._linkedWidthNode; },
            set: function (node) {
                this._onDidLinkedWidthNodeChange.input = node ? node._onDidViewChange : event_1.Event.None;
                this._linkedWidthNode = node;
                this._onDidSetLinkedNode.fire();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "linkedHeightNode", {
            get: function () { return this._linkedHeightNode; },
            set: function (node) {
                this._onDidLinkedHeightNodeChange.input = node ? node._onDidViewChange : event_1.Event.None;
                this._linkedHeightNode = node;
                this._onDidSetLinkedNode.fire();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "width", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.orthogonalSize : this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "height", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.size : this.orthogonalSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "element", {
            get: function () {
                return this.view.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "minimumWidth", {
            get: function () {
                return this.linkedWidthNode ? Math.max(this.linkedWidthNode.view.minimumWidth, this.view.minimumWidth) : this.view.minimumWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "maximumWidth", {
            get: function () {
                return this.linkedWidthNode ? Math.min(this.linkedWidthNode.view.maximumWidth, this.view.maximumWidth) : this.view.maximumWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "minimumHeight", {
            get: function () {
                return this.linkedHeightNode ? Math.max(this.linkedHeightNode.view.minimumHeight, this.view.minimumHeight) : this.view.minimumHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "maximumHeight", {
            get: function () {
                return this.linkedHeightNode ? Math.min(this.linkedHeightNode.view.maximumHeight, this.view.maximumHeight) : this.view.maximumHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "minimumSize", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.minimumHeight : this.minimumWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "maximumSize", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.maximumHeight : this.maximumWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "minimumOrthogonalSize", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.minimumWidth : this.minimumHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "maximumOrthogonalSize", {
            get: function () {
                return this.orientation === 1 /* HORIZONTAL */ ? this.maximumWidth : this.maximumHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "orthogonalStartSash", {
            set: function (sash) {
                // noop
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LeafNode.prototype, "orthogonalEndSash", {
            set: function (sash) {
                // noop
            },
            enumerable: true,
            configurable: true
        });
        LeafNode.prototype.layout = function (size) {
            this._size = size;
            return this.view.layout(this.width, this.height);
        };
        LeafNode.prototype.orthogonalLayout = function (size) {
            this._orthogonalSize = size;
            return this.view.layout(this.width, this.height);
        };
        LeafNode.prototype.dispose = function () { };
        return LeafNode;
    }());
    function flipNode(node, size, orthogonalSize) {
        if (node instanceof BranchNode) {
            var result = new BranchNode(orthogonal(node.orientation), node.styles, size, orthogonalSize);
            var totalSize = 0;
            for (var i = node.children.length - 1; i >= 0; i--) {
                var child = node.children[i];
                var childSize = child instanceof BranchNode ? child.orthogonalSize : child.size;
                var newSize = node.size === 0 ? 0 : Math.round((size * childSize) / node.size);
                totalSize += newSize;
                // The last view to add should adjust to rounding errors
                if (i === 0) {
                    newSize += size - totalSize;
                }
                result.addChild(flipNode(child, orthogonalSize, newSize), newSize, 0);
            }
            return result;
        }
        else {
            return new LeafNode(node.view, orthogonal(node.orientation), orthogonalSize);
        }
    }
    var GridView = /** @class */ (function () {
        function GridView(options) {
            if (options === void 0) { options = {}; }
            this.onDidSashResetRelay = new event_1.Relay();
            this.onDidSashReset = this.onDidSashResetRelay.event;
            this.disposable2x2 = lifecycle_1.Disposable.None;
            this._onDidChange = new event_1.Relay();
            this.onDidChange = this._onDidChange.event;
            this.element = dom_1.$('.monaco-grid-view');
            this.styles = options.styles || defaultStyles;
            this.root = new BranchNode(0 /* VERTICAL */, this.styles);
        }
        Object.defineProperty(GridView.prototype, "root", {
            get: function () {
                return this._root;
            },
            set: function (root) {
                var oldRoot = this._root;
                if (oldRoot) {
                    this.element.removeChild(oldRoot.element);
                    oldRoot.dispose();
                }
                this._root = root;
                this.element.appendChild(root.element);
                this.onDidSashResetRelay.input = root.onDidSashReset;
                this._onDidChange.input = event_1.mapEvent(root.onDidChange, function () { return undefined; }); // TODO
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "orientation", {
            get: function () {
                return this._root.orientation;
            },
            set: function (orientation) {
                if (this._root.orientation === orientation) {
                    return;
                }
                var _a = this._root, size = _a.size, orthogonalSize = _a.orthogonalSize;
                this.root = flipNode(this._root, orthogonalSize, size);
                this.root.layout(size);
                this.root.orthogonalLayout(orthogonalSize);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "width", {
            get: function () { return this.root.width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "height", {
            get: function () { return this.root.height; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "minimumWidth", {
            get: function () { return this.root.minimumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "minimumHeight", {
            get: function () { return this.root.minimumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "maximumWidth", {
            get: function () { return this.root.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridView.prototype, "maximumHeight", {
            get: function () { return this.root.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        GridView.prototype.style = function (styles) {
            this.styles = styles;
            this.root.style(styles);
        };
        GridView.prototype.layout = function (width, height) {
            var _a = this.root.orientation === 1 /* HORIZONTAL */ ? [height, width] : [width, height], size = _a[0], orthogonalSize = _a[1];
            this.root.layout(size);
            this.root.orthogonalLayout(orthogonalSize);
        };
        GridView.prototype.addView = function (view, size, location) {
            this.disposable2x2.dispose();
            this.disposable2x2 = lifecycle_1.Disposable.None;
            var _a = arrays_1.tail2(location), rest = _a[0], index = _a[1];
            var _b = this.getNode(rest), pathToParent = _b[0], parent = _b[1];
            if (parent instanceof BranchNode) {
                var node = new LeafNode(view, orthogonal(parent.orientation), parent.orthogonalSize);
                parent.addChild(node, size, index);
            }
            else {
                var _c = arrays_1.tail2(pathToParent), grandParent = _c[1];
                var _d = arrays_1.tail2(rest), parentIndex = _d[1];
                grandParent.removeChild(parentIndex);
                var newParent = new BranchNode(parent.orientation, this.styles, parent.size, parent.orthogonalSize);
                grandParent.addChild(newParent, parent.size, parentIndex);
                newParent.orthogonalLayout(parent.orthogonalSize);
                var newSibling = new LeafNode(parent.view, grandParent.orientation, parent.size);
                newParent.addChild(newSibling, 0, 0);
                if (typeof size !== 'number' && size.type === 'split') {
                    size = splitview_1.Sizing.Split(0);
                }
                var node = new LeafNode(view, grandParent.orientation, parent.size);
                newParent.addChild(node, size, index);
            }
        };
        GridView.prototype.removeView = function (location, sizing) {
            this.disposable2x2.dispose();
            this.disposable2x2 = lifecycle_1.Disposable.None;
            var _a = arrays_1.tail2(location), rest = _a[0], index = _a[1];
            var _b = this.getNode(rest), pathToParent = _b[0], parent = _b[1];
            if (!(parent instanceof BranchNode)) {
                throw new Error('Invalid location');
            }
            var node = parent.children[index];
            if (!(node instanceof LeafNode)) {
                throw new Error('Invalid location');
            }
            parent.removeChild(index, sizing);
            if (parent.children.length === 0) {
                throw new Error('Invalid grid state');
            }
            if (parent.children.length > 1) {
                return node.view;
            }
            if (pathToParent.length === 0) { // parent is root
                var sibling_1 = parent.children[0];
                if (sibling_1 instanceof LeafNode) {
                    return node.view;
                }
                // we must promote sibling to be the new root
                parent.removeChild(0);
                this.root = sibling_1;
                return node.view;
            }
            var _c = arrays_1.tail2(pathToParent), grandParent = _c[1];
            var _d = arrays_1.tail2(rest), parentIndex = _d[1];
            var sibling = parent.children[0];
            parent.removeChild(0);
            var sizes = grandParent.children.map(function (_, i) { return grandParent.getChildSize(i); });
            grandParent.removeChild(parentIndex, sizing);
            if (sibling instanceof BranchNode) {
                sizes.splice.apply(sizes, [parentIndex, 1].concat(sibling.children.map(function (c) { return c.size; })));
                for (var i = 0; i < sibling.children.length; i++) {
                    var child = sibling.children[i];
                    grandParent.addChild(child, child.size, parentIndex + i);
                }
            }
            else {
                var newSibling = new LeafNode(sibling.view, orthogonal(sibling.orientation), sibling.size);
                grandParent.addChild(newSibling, sibling.orthogonalSize, parentIndex);
            }
            for (var i = 0; i < sizes.length; i++) {
                grandParent.resizeChild(i, sizes[i]);
            }
            return node.view;
        };
        GridView.prototype.moveView = function (parentLocation, from, to) {
            var _a = this.getNode(parentLocation), parent = _a[1];
            if (!(parent instanceof BranchNode)) {
                throw new Error('Invalid location');
            }
            parent.moveChild(from, to);
        };
        GridView.prototype.swapViews = function (from, to) {
            var _a = arrays_1.tail2(from), fromRest = _a[0], fromIndex = _a[1];
            var _b = this.getNode(fromRest), fromParent = _b[1];
            if (!(fromParent instanceof BranchNode)) {
                throw new Error('Invalid from location');
            }
            var fromSize = fromParent.getChildSize(fromIndex);
            var fromNode = fromParent.children[fromIndex];
            if (!(fromNode instanceof LeafNode)) {
                throw new Error('Invalid from location');
            }
            var _c = arrays_1.tail2(to), toRest = _c[0], toIndex = _c[1];
            var _d = this.getNode(toRest), toParent = _d[1];
            if (!(toParent instanceof BranchNode)) {
                throw new Error('Invalid to location');
            }
            var toSize = toParent.getChildSize(toIndex);
            var toNode = toParent.children[toIndex];
            if (!(toNode instanceof LeafNode)) {
                throw new Error('Invalid to location');
            }
            if (fromParent === toParent) {
                fromParent.swapChildren(fromIndex, toIndex);
            }
            else {
                fromParent.removeChild(fromIndex);
                toParent.removeChild(toIndex);
                fromParent.addChild(toNode, fromSize, fromIndex);
                toParent.addChild(fromNode, toSize, toIndex);
                fromParent.layout(fromParent.orthogonalSize);
                toParent.layout(toParent.orthogonalSize);
            }
        };
        GridView.prototype.resizeView = function (location, size) {
            var _a = arrays_1.tail2(location), rest = _a[0], index = _a[1];
            var _b = this.getNode(rest), parent = _b[1];
            if (!(parent instanceof BranchNode)) {
                throw new Error('Invalid location');
            }
            parent.resizeChild(index, size);
        };
        GridView.prototype.getViewSize = function (location) {
            var _a = this.getNode(location), node = _a[1];
            return { width: node.width, height: node.height };
        };
        GridView.prototype.maximizeViewSize = function (location) {
            var _a = this.getNode(location), ancestors = _a[0], node = _a[1];
            if (!(node instanceof LeafNode)) {
                throw new Error('Invalid location');
            }
            for (var i = 0; i < ancestors.length; i++) {
                ancestors[i].resizeChild(location[i], Number.POSITIVE_INFINITY);
            }
        };
        GridView.prototype.distributeViewSizes = function (location) {
            if (!location) {
                this.root.distributeViewSizes(true);
                return;
            }
            var _a = this.getNode(location), node = _a[1];
            if (!(node instanceof BranchNode)) {
                throw new Error('Invalid location');
            }
            node.distributeViewSizes();
        };
        GridView.prototype.getViews = function () {
            return this._getViews(this.root, this.orientation, { top: 0, left: 0, width: this.width, height: this.height });
        };
        GridView.prototype._getViews = function (node, orientation, box) {
            if (node instanceof LeafNode) {
                return { view: node.view, box: box };
            }
            var children = [];
            var offset = 0;
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var childOrientation = orthogonal(orientation);
                var childBox = orientation === 1 /* HORIZONTAL */
                    ? { top: box.top, left: box.left + offset, width: child.width, height: box.height }
                    : { top: box.top + offset, left: box.left, width: box.width, height: child.height };
                children.push(this._getViews(child, childOrientation, childBox));
                offset += orientation === 1 /* HORIZONTAL */ ? child.width : child.height;
            }
            return { children: children, box: box };
        };
        GridView.prototype.getNode = function (location, node, path) {
            if (node === void 0) { node = this.root; }
            if (path === void 0) { path = []; }
            if (location.length === 0) {
                return [path, node];
            }
            if (!(node instanceof BranchNode)) {
                throw new Error('Invalid location');
            }
            var index = location[0], rest = location.slice(1);
            if (index < 0 || index >= node.children.length) {
                throw new Error('Invalid location');
            }
            var child = node.children[index];
            path.push(node);
            return this.getNode(rest, child, path);
        };
        GridView.prototype.trySet2x2 = function () {
            this.disposable2x2.dispose();
            this.disposable2x2 = lifecycle_1.Disposable.None;
            if (this.root.children.length !== 2) {
                return;
            }
            var _a = this.root.children, first = _a[0], second = _a[1];
            if (!(first instanceof BranchNode) || !(second instanceof BranchNode)) {
                return;
            }
            this.disposable2x2 = first.trySet2x2(second);
        };
        GridView.prototype.dispose = function () {
            this.onDidSashResetRelay.dispose();
            this.root.dispose();
            if (this.element && this.element.parentElement) {
                this.element.parentElement.removeChild(this.element);
            }
        };
        return GridView;
    }());
    exports.GridView = GridView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[359/*vs/base/browser/ui/grid/grid*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,19/*vs/base/common/arrays*/,219/*vs/base/browser/ui/grid/gridview*/,224/*vs/css!vs/base/browser/ui/grid/gridview*/]), function (require, exports, lifecycle_1, arrays_1, gridview_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function oppositeDirection(direction) {
        switch (direction) {
            case 0 /* Up */: return 1 /* Down */;
            case 1 /* Down */: return 0 /* Up */;
            case 2 /* Left */: return 3 /* Right */;
            case 3 /* Right */: return 2 /* Left */;
        }
    }
    function isGridBranchNode(node) {
        return !!node.children;
    }
    exports.isGridBranchNode = isGridBranchNode;
    function getGridNode(node, location) {
        if (location.length === 0) {
            return node;
        }
        if (!isGridBranchNode(node)) {
            throw new Error('Invalid location');
        }
        var index = location[0], rest = location.slice(1);
        return getGridNode(node.children[index], rest);
    }
    function intersects(one, other) {
        return !(one.start >= other.end || other.start >= one.end);
    }
    function getBoxBoundary(box, direction) {
        var orientation = getDirectionOrientation(direction);
        var offset = direction === 0 /* Up */ ? box.top :
            direction === 3 /* Right */ ? box.left + box.width :
                direction === 1 /* Down */ ? box.top + box.height :
                    box.left;
        var range = {
            start: orientation === 1 /* HORIZONTAL */ ? box.top : box.left,
            end: orientation === 1 /* HORIZONTAL */ ? box.top + box.height : box.left + box.width
        };
        return { offset: offset, range: range };
    }
    function findAdjacentBoxLeafNodes(boxNode, direction, boundary) {
        var result = [];
        function _(boxNode, direction, boundary) {
            if (isGridBranchNode(boxNode)) {
                for (var _i = 0, _a = boxNode.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    _(child, direction, boundary);
                }
            }
            else {
                var _b = getBoxBoundary(boxNode.box, direction), offset = _b.offset, range = _b.range;
                if (offset === boundary.offset && intersects(range, boundary.range)) {
                    result.push(boxNode);
                }
            }
        }
        _(boxNode, direction, boundary);
        return result;
    }
    function getLocationOrientation(rootOrientation, location) {
        return location.length % 2 === 0 ? gridview_1.orthogonal(rootOrientation) : rootOrientation;
    }
    function getDirectionOrientation(direction) {
        return direction === 0 /* Up */ || direction === 1 /* Down */ ? 0 /* VERTICAL */ : 1 /* HORIZONTAL */;
    }
    function getSize(dimensions, orientation) {
        return orientation === 1 /* HORIZONTAL */ ? dimensions.width : dimensions.height;
    }
    function getRelativeLocation(rootOrientation, location, direction) {
        var orientation = getLocationOrientation(rootOrientation, location);
        var directionOrientation = getDirectionOrientation(direction);
        if (orientation === directionOrientation) {
            var _a = arrays_1.tail2(location), rest = _a[0], index = _a[1];
            if (direction === 3 /* Right */ || direction === 1 /* Down */) {
                index += 1;
            }
            return rest.concat([index]);
        }
        else {
            var index = (direction === 3 /* Right */ || direction === 1 /* Down */) ? 1 : 0;
            return location.concat([index]);
        }
    }
    exports.getRelativeLocation = getRelativeLocation;
    function indexInParent(element) {
        var parentElement = element.parentElement;
        var el = parentElement.firstElementChild;
        var index = 0;
        while (el !== element && el !== parentElement.lastElementChild) {
            el = el.nextElementSibling;
            index++;
        }
        return index;
    }
    /**
     * Find the grid location of a specific DOM element by traversing the parent
     * chain and finding each child index on the way.
     *
     * This will break as soon as DOM structures of the Splitview or Gridview change.
     */
    function getGridLocation(element) {
        if (/\bmonaco-grid-view\b/.test(element.parentElement.className)) {
            return [];
        }
        var index = indexInParent(element.parentElement);
        var ancestor = element.parentElement.parentElement.parentElement.parentElement;
        return getGridLocation(ancestor).concat([index]);
    }
    var Grid = /** @class */ (function () {
        function Grid(view, options) {
            if (options === void 0) { options = {}; }
            this.views = new Map();
            this.disposables = [];
            this.sashResetSizing = "distribute" /* Distribute */;
            this.gridview = new gridview_1.GridView(options);
            this.disposables.push(this.gridview);
            this.gridview.onDidSashReset(this.doResetViewSize, this, this.disposables);
            this._addView(view, 0, [0]);
        }
        Object.defineProperty(Grid.prototype, "orientation", {
            get: function () { return this.gridview.orientation; },
            set: function (orientation) { this.gridview.orientation = orientation; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "width", {
            get: function () { return this.gridview.width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "height", {
            get: function () { return this.gridview.height; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "minimumWidth", {
            get: function () { return this.gridview.minimumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "minimumHeight", {
            get: function () { return this.gridview.minimumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "maximumWidth", {
            get: function () { return this.gridview.maximumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "maximumHeight", {
            get: function () { return this.gridview.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "onDidChange", {
            get: function () { return this.gridview.onDidChange; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Grid.prototype, "element", {
            get: function () { return this.gridview.element; },
            enumerable: true,
            configurable: true
        });
        Grid.prototype.style = function (styles) {
            this.gridview.style(styles);
        };
        Grid.prototype.layout = function (width, height) {
            this.gridview.layout(width, height);
        };
        Grid.prototype.addView = function (newView, size, referenceView, direction) {
            if (this.views.has(newView)) {
                throw new Error('Can\'t add same view twice');
            }
            var orientation = getDirectionOrientation(direction);
            if (this.views.size === 1 && this.orientation !== orientation) {
                this.orientation = orientation;
            }
            var referenceLocation = this.getViewLocation(referenceView);
            var location = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
            var viewSize;
            if (size === "split" /* Split */) {
                var _a = arrays_1.tail2(referenceLocation), index = _a[1];
                viewSize = gridview_1.Sizing.Split(index);
            }
            else if (size === "distribute" /* Distribute */) {
                viewSize = gridview_1.Sizing.Distribute;
            }
            else {
                viewSize = size;
            }
            this._addView(newView, viewSize, location);
        };
        Grid.prototype._addView = function (newView, size, location) {
            this.views.set(newView, newView.element);
            this.gridview.addView(newView, size, location);
        };
        Grid.prototype.removeView = function (view, sizing) {
            if (this.views.size === 1) {
                throw new Error('Can\'t remove last view');
            }
            var location = this.getViewLocation(view);
            this.gridview.removeView(location, sizing === "distribute" /* Distribute */ ? gridview_1.Sizing.Distribute : undefined);
            this.views.delete(view);
        };
        Grid.prototype.moveView = function (view, sizing, referenceView, direction) {
            var sourceLocation = this.getViewLocation(view);
            var _a = arrays_1.tail2(sourceLocation), sourceParentLocation = _a[0], from = _a[1];
            var referenceLocation = this.getViewLocation(referenceView);
            var targetLocation = getRelativeLocation(this.gridview.orientation, referenceLocation, direction);
            var _b = arrays_1.tail2(targetLocation), targetParentLocation = _b[0], to = _b[1];
            if (arrays_1.equals(sourceParentLocation, targetParentLocation)) {
                this.gridview.moveView(sourceParentLocation, from, to);
            }
            else {
                this.removeView(view, typeof sizing === 'number' ? undefined : sizing);
                this.addView(view, sizing, referenceView, direction);
            }
        };
        Grid.prototype.swapViews = function (from, to) {
            var fromLocation = this.getViewLocation(from);
            var toLocation = this.getViewLocation(to);
            return this.gridview.swapViews(fromLocation, toLocation);
        };
        Grid.prototype.resizeView = function (view, size) {
            var location = this.getViewLocation(view);
            return this.gridview.resizeView(location, size);
        };
        Grid.prototype.getViewSize = function (view) {
            var location = this.getViewLocation(view);
            var viewSize = this.gridview.getViewSize(location);
            return getLocationOrientation(this.orientation, location) === 1 /* HORIZONTAL */ ? viewSize.width : viewSize.height;
        };
        // TODO@joao cleanup
        Grid.prototype.getViewSize2 = function (view) {
            var location = this.getViewLocation(view);
            return this.gridview.getViewSize(location);
        };
        Grid.prototype.maximizeViewSize = function (view) {
            var location = this.getViewLocation(view);
            this.gridview.maximizeViewSize(location);
        };
        Grid.prototype.distributeViewSizes = function () {
            this.gridview.distributeViewSizes();
        };
        Grid.prototype.getViews = function () {
            return this.gridview.getViews();
        };
        Grid.prototype.getNeighborViews = function (view, direction, wrap) {
            if (wrap === void 0) { wrap = false; }
            var location = this.getViewLocation(view);
            var root = this.getViews();
            var node = getGridNode(root, location);
            var boundary = getBoxBoundary(node.box, direction);
            if (wrap) {
                if (direction === 0 /* Up */ && node.box.top === 0) {
                    boundary = { offset: root.box.top + root.box.height, range: boundary.range };
                }
                else if (direction === 3 /* Right */ && node.box.left + node.box.width === root.box.width) {
                    boundary = { offset: 0, range: boundary.range };
                }
                else if (direction === 1 /* Down */ && node.box.top + node.box.height === root.box.height) {
                    boundary = { offset: 0, range: boundary.range };
                }
                else if (direction === 2 /* Left */ && node.box.left === 0) {
                    boundary = { offset: root.box.left + root.box.width, range: boundary.range };
                }
            }
            return findAdjacentBoxLeafNodes(root, oppositeDirection(direction), boundary)
                .map(function (node) { return node.view; });
        };
        Grid.prototype.getViewLocation = function (view) {
            var element = this.views.get(view);
            if (!element) {
                throw new Error('View not found');
            }
            return getGridLocation(element);
        };
        Grid.prototype.doResetViewSize = function (location) {
            if (this.sashResetSizing === "split" /* Split */) {
                var orientation_1 = getLocationOrientation(this.orientation, location);
                var firstViewSize = getSize(this.gridview.getViewSize(location), orientation_1);
                var _a = arrays_1.tail2(location), parentLocation = _a[0], index = _a[1];
                var secondViewSize = getSize(this.gridview.getViewSize(parentLocation.concat([index + 1])), orientation_1);
                var totalSize = firstViewSize + secondViewSize;
                this.gridview.resizeView(location, Math.floor(totalSize / 2));
            }
            else {
                var parentLocation = arrays_1.tail2(location)[0];
                this.gridview.distributeViewSizes(parentLocation);
            }
        };
        Grid.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return Grid;
    }());
    exports.Grid = Grid;
    var SerializableGrid = /** @class */ (function (_super) {
        __extends(SerializableGrid, _super);
        function SerializableGrid() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SerializableGrid.serializeNode = function (node, orientation) {
            var size = orientation === 0 /* VERTICAL */ ? node.box.width : node.box.height;
            if (!isGridBranchNode(node)) {
                return { type: 'leaf', data: node.view.toJSON(), size: size };
            }
            return { type: 'branch', data: node.children.map(function (c) { return SerializableGrid.serializeNode(c, gridview_1.orthogonal(orientation)); }), size: size };
        };
        SerializableGrid.deserializeNode = function (json, orientation, box, deserializer) {
            if (!json || typeof json !== 'object') {
                throw new Error('Invalid JSON');
            }
            var type = json.type;
            var data = json.data;
            if (type === 'branch') {
                if (!Array.isArray(data)) {
                    throw new Error('Invalid JSON: \'data\' property of branch must be an array.');
                }
                var children = [];
                var offset = 0;
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var child = data_1[_i];
                    if (typeof child.size !== 'number') {
                        throw new Error('Invalid JSON: \'size\' property of node must be a number.');
                    }
                    var childBox = orientation === 1 /* HORIZONTAL */
                        ? { top: box.top, left: box.left + offset, width: child.size, height: box.height }
                        : { top: box.top + offset, left: box.left, width: box.width, height: child.size };
                    children.push(SerializableGrid.deserializeNode(child, gridview_1.orthogonal(orientation), childBox, deserializer));
                    offset += child.size;
                }
                return { children: children, box: box };
            }
            else if (type === 'leaf') {
                var view = deserializer.fromJSON(data);
                return { view: view, box: box };
            }
            throw new Error('Invalid JSON: \'type\' property must be either \'branch\' or \'leaf\'.');
        };
        SerializableGrid.getFirstLeaf = function (node) {
            if (!isGridBranchNode(node)) {
                return node;
            }
            return SerializableGrid.getFirstLeaf(node.children[0]);
        };
        SerializableGrid.deserialize = function (json, deserializer, options) {
            if (options === void 0) { options = {}; }
            if (typeof json.orientation !== 'number') {
                throw new Error('Invalid JSON: \'orientation\' property must be a number.');
            }
            else if (typeof json.width !== 'number') {
                throw new Error('Invalid JSON: \'width\' property must be a number.');
            }
            else if (typeof json.height !== 'number') {
                throw new Error('Invalid JSON: \'height\' property must be a number.');
            }
            var orientation = json.orientation;
            var width = json.width;
            var height = json.height;
            var box = { top: 0, left: 0, width: width, height: height };
            var root = SerializableGrid.deserializeNode(json.root, orientation, box, deserializer);
            var firstLeaf = SerializableGrid.getFirstLeaf(root);
            if (!firstLeaf) {
                throw new Error('Invalid serialized state, first leaf not found');
            }
            var result = new SerializableGrid(firstLeaf.view, options);
            result.orientation = orientation;
            result.restoreViews(firstLeaf.view, orientation, root);
            result.initialLayoutContext = { width: width, height: height, root: root };
            return result;
        };
        SerializableGrid.prototype.serialize = function () {
            return {
                root: SerializableGrid.serializeNode(this.getViews(), this.orientation),
                orientation: this.orientation,
                width: this.width,
                height: this.height
            };
        };
        SerializableGrid.prototype.layout = function (width, height) {
            _super.prototype.layout.call(this, width, height);
            if (this.initialLayoutContext) {
                var widthScale = width / this.initialLayoutContext.width;
                var heightScale = height / this.initialLayoutContext.height;
                this.restoreViewsSize([], this.initialLayoutContext.root, this.orientation, widthScale, heightScale);
                this.initialLayoutContext = undefined;
                this.gridview.trySet2x2();
            }
        };
        /**
         * Recursively restores views which were just deserialized.
         */
        SerializableGrid.prototype.restoreViews = function (referenceView, orientation, node) {
            if (!isGridBranchNode(node)) {
                return;
            }
            var direction = orientation === 0 /* VERTICAL */ ? 1 /* Down */ : 3 /* Right */;
            var firstLeaves = node.children.map(function (c) { return SerializableGrid.getFirstLeaf(c); });
            for (var i = 1; i < firstLeaves.length; i++) {
                var size = orientation === 0 /* VERTICAL */ ? firstLeaves[i].box.height : firstLeaves[i].box.width;
                this.addView(firstLeaves[i].view, size, referenceView, direction);
                referenceView = firstLeaves[i].view;
            }
            for (var i = 0; i < node.children.length; i++) {
                this.restoreViews(firstLeaves[i].view, gridview_1.orthogonal(orientation), node.children[i]);
            }
        };
        /**
         * Recursively restores view sizes.
         * This should be called only after the very first layout call.
         */
        SerializableGrid.prototype.restoreViewsSize = function (location, node, orientation, widthScale, heightScale) {
            if (!isGridBranchNode(node)) {
                return;
            }
            var scale = orientation === 0 /* VERTICAL */ ? heightScale : widthScale;
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var childLocation = location.concat([i]);
                if (i < node.children.length - 1) {
                    var size = orientation === 0 /* VERTICAL */ ? child.box.height : child.box.width;
                    this.gridview.resizeView(childLocation, Math.floor(size * scale));
                }
                this.restoreViewsSize(childLocation, child, gridview_1.orthogonal(orientation), widthScale, heightScale);
            }
        };
        return SerializableGrid;
    }(Grid));
    exports.SerializableGrid = SerializableGrid;
    function sanitizeGridNodeDescriptor(nodeDescriptor) {
        if (nodeDescriptor.groups && nodeDescriptor.groups.length === 0) {
            nodeDescriptor.groups = undefined;
        }
        if (!nodeDescriptor.groups) {
            return;
        }
        var totalDefinedSize = 0;
        var totalDefinedSizeCount = 0;
        for (var _i = 0, _a = nodeDescriptor.groups; _i < _a.length; _i++) {
            var child = _a[_i];
            sanitizeGridNodeDescriptor(child);
            if (child.size) {
                totalDefinedSize += child.size;
                totalDefinedSizeCount++;
            }
        }
        var totalUndefinedSize = totalDefinedSizeCount > 0 ? totalDefinedSize : 1;
        var totalUndefinedSizeCount = nodeDescriptor.groups.length - totalDefinedSizeCount;
        var eachUndefinedSize = totalUndefinedSize / totalUndefinedSizeCount;
        for (var _b = 0, _c = nodeDescriptor.groups; _b < _c.length; _b++) {
            var child = _c[_b];
            if (!child.size) {
                child.size = eachUndefinedSize;
            }
        }
    }
    exports.sanitizeGridNodeDescriptor = sanitizeGridNodeDescriptor;
    function createSerializedNode(nodeDescriptor) {
        if (nodeDescriptor.groups) {
            return { type: 'branch', data: nodeDescriptor.groups.map(function (c) { return createSerializedNode(c); }), size: nodeDescriptor.size };
        }
        else {
            return { type: 'leaf', data: null, size: nodeDescriptor.size };
        }
    }
    function getDimensions(node, orientation) {
        if (node.type === 'branch') {
            var childrenDimensions = node.data.map(function (c) { return getDimensions(c, gridview_1.orthogonal(orientation)); });
            if (orientation === 0 /* VERTICAL */) {
                var width = node.size || (childrenDimensions.length === 0 ? undefined : Math.max.apply(Math, childrenDimensions.map(function (d) { return d.width || 0; })));
                var height = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce(function (r, d) { return r + d.height; }, 0);
                return { width: width, height: height };
            }
            else {
                var width = childrenDimensions.length === 0 ? undefined : childrenDimensions.reduce(function (r, d) { return r + d.width; }, 0);
                var height = node.size || (childrenDimensions.length === 0 ? undefined : Math.max.apply(Math, childrenDimensions.map(function (d) { return d.height || 0; })));
                return { width: width, height: height };
            }
        }
        else {
            var width = orientation === 0 /* VERTICAL */ ? node.size : undefined;
            var height = orientation === 0 /* VERTICAL */ ? undefined : node.size;
            return { width: width, height: height };
        }
    }
    function createSerializedGrid(gridDescriptor) {
        sanitizeGridNodeDescriptor(gridDescriptor);
        var root = createSerializedNode(gridDescriptor);
        var _a = getDimensions(root, gridDescriptor.orientation), width = _a.width, height = _a.height;
        return {
            root: root,
            orientation: gridDescriptor.orientation,
            width: width || 1,
            height: height || 1
        };
    }
    exports.createSerializedGrid = createSerializedGrid;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[215/*vs/base/browser/ui/splitview/panelview*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,220/*vs/base/browser/event*/,68/*vs/base/browser/keyboardEvent*/,8/*vs/base/browser/dom*/,19/*vs/base/common/arrays*/,75/*vs/base/common/color*/,101/*vs/base/browser/ui/splitview/splitview*/,332/*vs/css!vs/base/browser/ui/splitview/panelview*/]), function (require, exports, lifecycle_1, event_1, event_2, keyboardEvent_1, dom_1, arrays_1, color_1, splitview_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A Panel is a structured SplitView view.
     *
     * WARNING: You must call `render()` after you contruct it.
     * It can't be done automatically at the end of the ctor
     * because of the order of property initialization in TypeScript.
     * Subclasses wouldn't be able to set own properties
     * before the `render()` call, thus forbiding their use.
     */
    var Panel = /** @class */ (function () {
        function Panel(options) {
            if (options === void 0) { options = {}; }
            this.disposables = [];
            this.expandedSize = undefined;
            this._headerVisible = true;
            this.styles = {};
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._expanded = typeof options.expanded === 'undefined' ? true : !!options.expanded;
            this.ariaHeaderLabel = options.ariaHeaderLabel || '';
            this._minimumBodySize = typeof options.minimumBodySize === 'number' ? options.minimumBodySize : 120;
            this._maximumBodySize = typeof options.maximumBodySize === 'number' ? options.maximumBodySize : Number.POSITIVE_INFINITY;
            this.element = dom_1.$('.panel');
        }
        Object.defineProperty(Panel.prototype, "draggableElement", {
            get: function () {
                return this.header;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "dropTargetElement", {
            get: function () {
                return this.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "dropBackground", {
            get: function () {
                return this._dropBackground;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "minimumBodySize", {
            get: function () {
                return this._minimumBodySize;
            },
            set: function (size) {
                this._minimumBodySize = size;
                this._onDidChange.fire();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "maximumBodySize", {
            get: function () {
                return this._maximumBodySize;
            },
            set: function (size) {
                this._maximumBodySize = size;
                this._onDidChange.fire();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "headerSize", {
            get: function () {
                return this.headerVisible ? Panel.HEADER_SIZE : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "minimumSize", {
            get: function () {
                var headerSize = this.headerSize;
                var expanded = !this.headerVisible || this.isExpanded();
                var minimumBodySize = expanded ? this._minimumBodySize : 0;
                return headerSize + minimumBodySize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Panel.prototype, "maximumSize", {
            get: function () {
                var headerSize = this.headerSize;
                var expanded = !this.headerVisible || this.isExpanded();
                var maximumBodySize = expanded ? this._maximumBodySize : 0;
                return headerSize + maximumBodySize;
            },
            enumerable: true,
            configurable: true
        });
        Panel.prototype.isExpanded = function () {
            return this._expanded;
        };
        Panel.prototype.setExpanded = function (expanded) {
            if (this._expanded === !!expanded) {
                return;
            }
            this._expanded = !!expanded;
            this.updateHeader();
            this._onDidChange.fire(expanded ? this.expandedSize : undefined);
        };
        Object.defineProperty(Panel.prototype, "headerVisible", {
            get: function () {
                return this._headerVisible;
            },
            set: function (visible) {
                if (this._headerVisible === !!visible) {
                    return;
                }
                this._headerVisible = !!visible;
                this.updateHeader();
                this._onDidChange.fire();
            },
            enumerable: true,
            configurable: true
        });
        Panel.prototype.render = function () {
            var _this = this;
            this.header = dom_1.$('.panel-header');
            dom_1.append(this.element, this.header);
            this.header.setAttribute('tabindex', '0');
            this.header.setAttribute('role', 'toolbar');
            this.header.setAttribute('aria-label', this.ariaHeaderLabel);
            this.renderHeader(this.header);
            var focusTracker = dom_1.trackFocus(this.header);
            focusTracker.onDidFocus(function () { return dom_1.addClass(_this.header, 'focused'); });
            focusTracker.onDidBlur(function () { return dom_1.removeClass(_this.header, 'focused'); });
            this.updateHeader();
            var onHeaderKeyDown = event_1.chain(event_2.domEvent(this.header, 'keydown'))
                .map(function (e) { return new keyboardEvent_1.StandardKeyboardEvent(e); });
            onHeaderKeyDown.filter(function (e) { return e.keyCode === 3 /* Enter */ || e.keyCode === 10 /* Space */; })
                .event(function () { return _this.setExpanded(!_this.isExpanded()); }, null, this.disposables);
            onHeaderKeyDown.filter(function (e) { return e.keyCode === 15 /* LeftArrow */; })
                .event(function () { return _this.setExpanded(false); }, null, this.disposables);
            onHeaderKeyDown.filter(function (e) { return e.keyCode === 17 /* RightArrow */; })
                .event(function () { return _this.setExpanded(true); }, null, this.disposables);
            event_2.domEvent(this.header, 'click')(function () { return _this.setExpanded(!_this.isExpanded()); }, null, this.disposables);
            // TODO@Joao move this down to panelview
            // onHeaderKeyDown.filter(e => e.keyCode === KeyCode.UpArrow)
            // 	.event(focusPrevious, this, this.disposables);
            // onHeaderKeyDown.filter(e => e.keyCode === KeyCode.DownArrow)
            // 	.event(focusNext, this, this.disposables);
            var body = dom_1.append(this.element, dom_1.$('.panel-body'));
            this.renderBody(body);
        };
        Panel.prototype.layout = function (size) {
            var headerSize = this.headerVisible ? Panel.HEADER_SIZE : 0;
            this.layoutBody(size - headerSize);
            if (this.isExpanded()) {
                this.expandedSize = size;
            }
        };
        Panel.prototype.style = function (styles) {
            this.styles = styles;
            if (!this.header) {
                return;
            }
            this.updateHeader();
        };
        Panel.prototype.updateHeader = function () {
            var expanded = !this.headerVisible || this.isExpanded();
            this.header.style.height = this.headerSize + "px";
            this.header.style.lineHeight = this.headerSize + "px";
            dom_1.toggleClass(this.header, 'hidden', !this.headerVisible);
            dom_1.toggleClass(this.header, 'expanded', expanded);
            this.header.setAttribute('aria-expanded', String(expanded));
            this.header.style.color = this.styles.headerForeground ? this.styles.headerForeground.toString() : null;
            this.header.style.backgroundColor = this.styles.headerBackground ? this.styles.headerBackground.toString() : null;
            this.header.style.borderTop = this.styles.headerBorder ? "1px solid " + this.styles.headerBorder : null;
            this._dropBackground = this.styles.dropBackground;
        };
        Panel.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            this._onDidChange.dispose();
        };
        Panel.HEADER_SIZE = 22;
        return Panel;
    }());
    exports.Panel = Panel;
    var PanelDraggable = /** @class */ (function (_super) {
        __extends(PanelDraggable, _super);
        function PanelDraggable(panel, dnd, context) {
            var _this = _super.call(this) || this;
            _this.panel = panel;
            _this.dnd = dnd;
            _this.context = context;
            _this.dragOverCounter = 0; // see https://github.com/Microsoft/vscode/issues/14470
            _this._onDidDrop = _this._register(new event_1.Emitter());
            _this.onDidDrop = _this._onDidDrop.event;
            panel.draggableElement.draggable = true;
            _this._register(event_2.domEvent(panel.draggableElement, 'dragstart')(_this.onDragStart, _this));
            _this._register(event_2.domEvent(panel.dropTargetElement, 'dragenter')(_this.onDragEnter, _this));
            _this._register(event_2.domEvent(panel.dropTargetElement, 'dragleave')(_this.onDragLeave, _this));
            _this._register(event_2.domEvent(panel.dropTargetElement, 'dragend')(_this.onDragEnd, _this));
            _this._register(event_2.domEvent(panel.dropTargetElement, 'drop')(_this.onDrop, _this));
            return _this;
        }
        PanelDraggable.prototype.onDragStart = function (e) {
            if (!this.dnd.canDrag(this.panel)) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            e.dataTransfer.effectAllowed = 'move';
            var dragImage = dom_1.append(document.body, dom_1.$('.monaco-panel-drag-image', {}, this.panel.draggableElement.textContent));
            e.dataTransfer.setDragImage(dragImage, -10, -10);
            setTimeout(function () { return document.body.removeChild(dragImage); }, 0);
            this.context.draggable = this;
        };
        PanelDraggable.prototype.onDragEnter = function (e) {
            if (!this.context.draggable || this.context.draggable === this) {
                return;
            }
            if (!this.dnd.canDrop(this.context.draggable.panel, this.panel)) {
                return;
            }
            this.dragOverCounter++;
            this.render();
        };
        PanelDraggable.prototype.onDragLeave = function (e) {
            if (!this.context.draggable || this.context.draggable === this) {
                return;
            }
            if (!this.dnd.canDrop(this.context.draggable.panel, this.panel)) {
                return;
            }
            this.dragOverCounter--;
            if (this.dragOverCounter === 0) {
                this.render();
            }
        };
        PanelDraggable.prototype.onDragEnd = function (e) {
            if (!this.context.draggable) {
                return;
            }
            this.dragOverCounter = 0;
            this.render();
            this.context.draggable = null;
        };
        PanelDraggable.prototype.onDrop = function (e) {
            if (!this.context.draggable) {
                return;
            }
            this.dragOverCounter = 0;
            this.render();
            if (this.dnd.canDrop(this.context.draggable.panel, this.panel) && this.context.draggable !== this) {
                this._onDidDrop.fire({ from: this.context.draggable.panel, to: this.panel });
            }
            this.context.draggable = null;
        };
        PanelDraggable.prototype.render = function () {
            var backgroundColor = null;
            if (this.dragOverCounter > 0) {
                backgroundColor = (this.panel.dropBackground || PanelDraggable.DefaultDragOverBackgroundColor).toString();
            }
            this.panel.dropTargetElement.style.backgroundColor = backgroundColor;
        };
        PanelDraggable.DefaultDragOverBackgroundColor = new color_1.Color(new color_1.RGBA(128, 128, 128, 0.5));
        return PanelDraggable;
    }(lifecycle_1.Disposable));
    var DefaultPanelDndController = /** @class */ (function () {
        function DefaultPanelDndController() {
        }
        DefaultPanelDndController.prototype.canDrag = function (panel) {
            return true;
        };
        DefaultPanelDndController.prototype.canDrop = function (panel, overPanel) {
            return true;
        };
        return DefaultPanelDndController;
    }());
    exports.DefaultPanelDndController = DefaultPanelDndController;
    var PanelView = /** @class */ (function (_super) {
        __extends(PanelView, _super);
        function PanelView(container, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.dndContext = { draggable: null };
            _this.panelItems = [];
            _this.animationTimer = null;
            _this._onDidDrop = _this._register(new event_1.Emitter());
            _this.onDidDrop = _this._onDidDrop.event;
            _this.dnd = options.dnd;
            _this.el = dom_1.append(container, dom_1.$('.monaco-panel-view'));
            _this.splitview = _this._register(new splitview_1.SplitView(_this.el));
            _this.onDidSashChange = _this.splitview.onDidSashChange;
            return _this;
        }
        PanelView.prototype.addPanel = function (panel, size, index) {
            var _this = this;
            if (index === void 0) { index = this.splitview.length; }
            var disposables = [];
            disposables.push(
            // fix https://github.com/Microsoft/vscode/issues/37129 by delaying the listener
            // for changes to animate them. lots of views cause a onDidChange during their
            // initial creation and this causes the view to animate even though it shows
            // for the first time. animation should only be used to indicate new elements
            // are added or existing ones removed in a view that is already showing
            dom_1.scheduleAtNextAnimationFrame(function () { return panel.onDidChange(_this.setupAnimation, _this, disposables); }));
            var panelItem = { panel: panel, disposable: lifecycle_1.combinedDisposable(disposables) };
            this.panelItems.splice(index, 0, panelItem);
            this.splitview.addView(panel, size, index);
            if (this.dnd) {
                var draggable = new PanelDraggable(panel, this.dnd, this.dndContext);
                disposables.push(draggable);
                draggable.onDidDrop(this._onDidDrop.fire, this._onDidDrop, disposables);
            }
        };
        PanelView.prototype.removePanel = function (panel) {
            var index = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === panel; });
            if (index === -1) {
                return;
            }
            this.splitview.removeView(index);
            var panelItem = this.panelItems.splice(index, 1)[0];
            panelItem.disposable.dispose();
        };
        PanelView.prototype.movePanel = function (from, to) {
            var fromIndex = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === from; });
            var toIndex = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === to; });
            if (fromIndex === -1 || toIndex === -1) {
                return;
            }
            var panelItem = this.panelItems.splice(fromIndex, 1)[0];
            this.panelItems.splice(toIndex, 0, panelItem);
            this.splitview.moveView(fromIndex, toIndex);
        };
        PanelView.prototype.resizePanel = function (panel, size) {
            var index = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === panel; });
            if (index === -1) {
                return;
            }
            this.splitview.resizeView(index, size);
        };
        PanelView.prototype.getPanelSize = function (panel) {
            var index = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === panel; });
            if (index === -1) {
                return -1;
            }
            return this.splitview.getViewSize(index);
        };
        PanelView.prototype.layout = function (size) {
            this.splitview.layout(size);
        };
        PanelView.prototype.setupAnimation = function () {
            var _this = this;
            if (typeof this.animationTimer === 'number') {
                window.clearTimeout(this.animationTimer);
            }
            dom_1.addClass(this.el, 'animated');
            this.animationTimer = window.setTimeout(function () {
                _this.animationTimer = null;
                dom_1.removeClass(_this.el, 'animated');
            }, 200);
        };
        PanelView.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.panelItems.forEach(function (i) { return i.disposable.dispose(); });
        };
        return PanelView;
    }(lifecycle_1.Disposable));
    exports.PanelView = PanelView;
});

define(__m[365/*vs/css!vs/base/browser/ui/toolbar/toolbar*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[366/*vs/css!vs/editor/contrib/documentSymbols/media/outlineTree*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[214/*vs/css!vs/editor/contrib/documentSymbols/media/symbol-icons*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[370/*vs/css!vs/workbench/browser/actions/media/actions*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[373/*vs/css!vs/workbench/browser/media/part*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[213/*vs/css!vs/workbench/browser/parts/editor/media/breadcrumbscontrol*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[394/*vs/css!vs/workbench/browser/parts/editor/media/editordroptarget*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[404/*vs/css!vs/workbench/browser/parts/editor/media/editorgroupview*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[407/*vs/css!vs/workbench/browser/parts/editor/media/editorpicker*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[418/*vs/css!vs/workbench/browser/parts/editor/media/editorstatus*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[422/*vs/css!vs/workbench/browser/parts/editor/media/notabstitlecontrol*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[242/*vs/css!vs/workbench/browser/parts/editor/media/resourceviewer*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[243/*vs/css!vs/workbench/browser/parts/editor/media/tabstitlecontrol*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[244/*vs/css!vs/workbench/browser/parts/editor/media/titlecontrol*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[129/*vs/css!vs/workbench/browser/parts/quickinput/quickInput*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[246/*vs/css!vs/workbench/browser/parts/quickopen/media/quickopen*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[247/*vs/css!vs/workbench/browser/parts/views/media/panelviewlet*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[253/*vs/css!vs/workbench/browser/parts/views/media/views*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[257/*vs/css!vs/workbench/parts/codeEditor/electron-browser/media/suggestEnabledInput*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[258/*vs/css!vs/workbench/parts/files/electron-browser/media/explorerviewlet*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[259/*vs/css!vs/workbench/parts/files/electron-browser/media/fileactions*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[261/*vs/css!vs/workbench/parts/preferences/browser/media/keybindings*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[262/*vs/css!vs/workbench/parts/preferences/browser/media/keybindingsEditor*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[265/*vs/css!vs/workbench/parts/preferences/browser/media/preferences*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[270/*vs/css!vs/workbench/parts/preferences/browser/media/settingsWidgets*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[273/*vs/css!vs/workbench/parts/preferences/electron-browser/media/settingsEditor2*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[274/*vs/css!vs/workbench/parts/search/browser/media/searchview*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[275/*vs/css!vs/workbench/parts/search/electron-browser/media/search.contribution*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
define(__m[277/*vs/css!vs/workbench/services/progress/browser/media/progressService2*/], __M([21/*vs/css!vs/editor/codesandbox.editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[278/*vs/base/browser/ui/dropdown/dropdown*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,140/*vs/base/browser/touch*/,15/*vs/base/common/actions*/,50/*vs/base/browser/ui/actionbar/actionbar*/,8/*vs/base/browser/dom*/,68/*vs/base/browser/keyboardEvent*/,302/*vs/css!vs/base/browser/ui/dropdown/dropdown*/]), function (require, exports, winjs_base_1, touch_1, actions_1, actionbar_1, dom_1, keyboardEvent_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseDropdown = /** @class */ (function (_super) {
        __extends(BaseDropdown, _super);
        function BaseDropdown(container, options) {
            var _this = _super.call(this) || this;
            _this._element = dom_1.append(container, dom_1.$('.monaco-dropdown'));
            _this._label = dom_1.append(_this._element, dom_1.$('.dropdown-label'));
            var labelRenderer = options.labelRenderer;
            if (!labelRenderer) {
                labelRenderer = function (container) {
                    container.textContent = options.label || '';
                    return null;
                };
            }
            [dom_1.EventType.CLICK, dom_1.EventType.MOUSE_DOWN, touch_1.EventType.Tap].forEach(function (event) {
                _this._register(dom_1.addDisposableListener(_this._label, event, function (e) { return dom_1.EventHelper.stop(e, true); })); // prevent default click behaviour to trigger
            });
            [dom_1.EventType.MOUSE_DOWN, touch_1.EventType.Tap].forEach(function (event) {
                _this._register(dom_1.addDisposableListener(_this._label, event, function (e) {
                    if (e instanceof MouseEvent && e.detail > 1) {
                        return; // prevent multiple clicks to open multiple context menus (https://github.com/Microsoft/vscode/issues/41363)
                    }
                    if (_this.visible) {
                        _this.hide();
                    }
                    else {
                        _this.show();
                    }
                }));
            });
            _this._register(dom_1.addDisposableListener(_this._label, dom_1.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                    dom_1.EventHelper.stop(e, true); // https://github.com/Microsoft/vscode/issues/57997
                    if (_this.visible) {
                        _this.hide();
                    }
                    else {
                        _this.show();
                    }
                }
            }));
            var cleanupFn = labelRenderer(_this._label);
            if (cleanupFn) {
                _this._register(cleanupFn);
            }
            touch_1.Gesture.addTarget(_this._label);
            return _this;
        }
        Object.defineProperty(BaseDropdown.prototype, "element", {
            get: function () {
                return this._element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseDropdown.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseDropdown.prototype, "tooltip", {
            set: function (tooltip) {
                this._label.title = tooltip;
            },
            enumerable: true,
            configurable: true
        });
        BaseDropdown.prototype.show = function () {
            this.visible = true;
        };
        BaseDropdown.prototype.hide = function () {
            this.visible = false;
        };
        BaseDropdown.prototype.onEvent = function (e, activeElement) {
            this.hide();
        };
        BaseDropdown.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.hide();
            if (this.boxContainer) {
                this.boxContainer.remove();
                this.boxContainer = null;
            }
            if (this.contents) {
                this.contents.remove();
                this.contents = null;
            }
            if (this._label) {
                this._label.remove();
                this._label = null;
            }
        };
        return BaseDropdown;
    }(actions_1.ActionRunner));
    exports.BaseDropdown = BaseDropdown;
    var Dropdown = /** @class */ (function (_super) {
        __extends(Dropdown, _super);
        function Dropdown(container, options) {
            var _this = _super.call(this, container, options) || this;
            _this.contextViewProvider = options.contextViewProvider;
            return _this;
        }
        Dropdown.prototype.show = function () {
            var _this = this;
            _super.prototype.show.call(this);
            dom_1.addClass(this.element, 'active');
            this.contextViewProvider.showContextView({
                getAnchor: function () { return _this.getAnchor(); },
                render: function (container) {
                    return _this.renderContents(container);
                },
                onDOMEvent: function (e, activeElement) {
                    _this.onEvent(e, activeElement);
                },
                onHide: function () { return _this.onHide(); }
            });
        };
        Dropdown.prototype.getAnchor = function () {
            return this.element;
        };
        Dropdown.prototype.onHide = function () {
            dom_1.removeClass(this.element, 'active');
        };
        Dropdown.prototype.hide = function () {
            _super.prototype.hide.call(this);
            if (this.contextViewProvider) {
                this.contextViewProvider.hideContextView();
            }
        };
        Dropdown.prototype.renderContents = function (container) {
            return null;
        };
        return Dropdown;
    }(BaseDropdown));
    exports.Dropdown = Dropdown;
    var DropdownMenu = /** @class */ (function (_super) {
        __extends(DropdownMenu, _super);
        function DropdownMenu(container, options) {
            var _this = _super.call(this, container, options) || this;
            _this._contextMenuProvider = options.contextMenuProvider;
            _this.actions = options.actions || [];
            _this.actionProvider = options.actionProvider;
            _this.menuClassName = options.menuClassName || '';
            return _this;
        }
        Object.defineProperty(DropdownMenu.prototype, "menuOptions", {
            get: function () {
                return this._menuOptions;
            },
            set: function (options) {
                this._menuOptions = options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DropdownMenu.prototype, "actions", {
            get: function () {
                if (this.actionProvider) {
                    return this.actionProvider.getActions();
                }
                return this._actions;
            },
            set: function (actions) {
                this._actions = actions;
            },
            enumerable: true,
            configurable: true
        });
        DropdownMenu.prototype.show = function () {
            var _this = this;
            _super.prototype.show.call(this);
            dom_1.addClass(this.element, 'active');
            this._contextMenuProvider.showContextMenu({
                getAnchor: function () { return _this.element; },
                getActions: function () { return winjs_base_1.TPromise.as(_this.actions); },
                getActionsContext: function () { return _this.menuOptions ? _this.menuOptions.context : null; },
                getActionItem: function (action) { return _this.menuOptions && _this.menuOptions.actionItemProvider ? _this.menuOptions.actionItemProvider(action) : null; },
                getKeyBinding: function (action) { return _this.menuOptions && _this.menuOptions.getKeyBinding ? _this.menuOptions.getKeyBinding(action) : null; },
                getMenuClassName: function () { return _this.menuClassName; },
                onHide: function () { return _this.onHide(); },
                actionRunner: this.menuOptions ? this.menuOptions.actionRunner : null
            });
        };
        DropdownMenu.prototype.hide = function () {
            _super.prototype.hide.call(this);
        };
        DropdownMenu.prototype.onHide = function () {
            this.hide();
            dom_1.removeClass(this.element, 'active');
        };
        return DropdownMenu;
    }(BaseDropdown));
    exports.DropdownMenu = DropdownMenu;
    var DropdownMenuActionItem = /** @class */ (function (_super) {
        __extends(DropdownMenuActionItem, _super);
        function DropdownMenuActionItem(action, menuActionsOrProvider, contextMenuProvider, actionItemProvider, actionRunner, keybindings, clazz) {
            var _this = _super.call(this, null, action) || this;
            _this.menuActionsOrProvider = menuActionsOrProvider;
            _this.contextMenuProvider = contextMenuProvider;
            _this.actionItemProvider = actionItemProvider;
            _this.actionRunner = actionRunner;
            _this.keybindings = keybindings;
            _this.clazz = clazz;
            return _this;
        }
        DropdownMenuActionItem.prototype.render = function (container) {
            var _this = this;
            var labelRenderer = function (el) {
                _this.element = dom_1.append(el, dom_1.$('a.action-label.icon'));
                dom_1.addClasses(_this.element, _this.clazz);
                _this.element.tabIndex = 0;
                _this.element.setAttribute('role', 'button');
                _this.element.setAttribute('aria-haspopup', 'true');
                _this.element.title = _this._action.label || '';
                return null;
            };
            var options = {
                contextMenuProvider: this.contextMenuProvider,
                labelRenderer: labelRenderer
            };
            // Render the DropdownMenu around a simple action to toggle it
            if (Array.isArray(this.menuActionsOrProvider)) {
                options.actions = this.menuActionsOrProvider;
            }
            else {
                options.actionProvider = this.menuActionsOrProvider;
            }
            this.dropdownMenu = this._register(new DropdownMenu(container, options));
            this.dropdownMenu.menuOptions = {
                actionItemProvider: this.actionItemProvider,
                actionRunner: this.actionRunner,
                getKeyBinding: this.keybindings,
                context: this._context
            };
        };
        DropdownMenuActionItem.prototype.setActionContext = function (newContext) {
            _super.prototype.setActionContext.call(this, newContext);
            if (this.dropdownMenu) {
                this.dropdownMenu.menuOptions.context = newContext;
            }
        };
        DropdownMenuActionItem.prototype.show = function () {
            if (this.dropdownMenu) {
                this.dropdownMenu.show();
            }
        };
        return DropdownMenuActionItem;
    }(actionbar_1.BaseActionItem));
    exports.DropdownMenuActionItem = DropdownMenuActionItem;
});














define(__m[286/*vs/base/browser/contextmenu*/], __M([0/*require*/,1/*exports*/,486/*vs/base/browser/ui/menu/menu*/]), function (require, exports, menu_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContextSubMenu = /** @class */ (function (_super) {
        __extends(ContextSubMenu, _super);
        function ContextSubMenu(label, entries) {
            var _this = _super.call(this, label, entries, 'contextsubmenu') || this;
            _this.entries = entries;
            return _this;
        }
        return ContextSubMenu;
    }(menu_1.SubmenuAction));
    exports.ContextSubMenu = ContextSubMenu;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[133/*vs/base/browser/ui/toolbar/toolbar*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,15/*vs/base/common/actions*/,50/*vs/base/browser/ui/actionbar/actionbar*/,278/*vs/base/browser/ui/dropdown/dropdown*/,4/*vs/base/common/lifecycle*/,365/*vs/css!vs/base/browser/ui/toolbar/toolbar*/]), function (require, exports, nls, winjs_base_1, actions_1, actionbar_1, dropdown_1, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CONTEXT = 'context.toolbar';
    /**
     * A widget that combines an action bar for primary actions and a dropdown for secondary actions.
     */
    var ToolBar = /** @class */ (function (_super) {
        __extends(ToolBar, _super);
        function ToolBar(container, contextMenuProvider, options) {
            if (options === void 0) { options = { orientation: 0 /* HORIZONTAL */ }; }
            var _this = _super.call(this) || this;
            _this.options = options;
            _this.lookupKeybindings = typeof _this.options.getKeyBinding === 'function';
            _this.toggleMenuAction = _this._register(new ToggleMenuAction(function () { return _this.toggleMenuActionItem && _this.toggleMenuActionItem.show(); }, options.toggleMenuTitle));
            var element = document.createElement('div');
            element.className = 'monaco-toolbar';
            container.appendChild(element);
            _this.actionBar = _this._register(new actionbar_1.ActionBar(element, {
                orientation: options.orientation,
                ariaLabel: options.ariaLabel,
                actionRunner: options.actionRunner,
                actionItemProvider: function (action) {
                    // Return special action item for the toggle menu action
                    if (action.id === ToggleMenuAction.ID) {
                        // Dispose old
                        if (_this.toggleMenuActionItem) {
                            _this.toggleMenuActionItem.dispose();
                        }
                        // Create new
                        _this.toggleMenuActionItem = new dropdown_1.DropdownMenuActionItem(action, action.menuActions, contextMenuProvider, _this.options.actionItemProvider, _this.actionRunner, _this.options.getKeyBinding, 'toolbar-toggle-more');
                        _this.toggleMenuActionItem.setActionContext(_this.actionBar.context);
                        return _this.toggleMenuActionItem;
                    }
                    return options.actionItemProvider ? options.actionItemProvider(action) : null;
                }
            }));
            return _this;
        }
        Object.defineProperty(ToolBar.prototype, "actionRunner", {
            get: function () {
                return this.actionBar.actionRunner;
            },
            set: function (actionRunner) {
                this.actionBar.actionRunner = actionRunner;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolBar.prototype, "context", {
            set: function (context) {
                this.actionBar.context = context;
                if (this.toggleMenuActionItem) {
                    this.toggleMenuActionItem.setActionContext(context);
                }
            },
            enumerable: true,
            configurable: true
        });
        ToolBar.prototype.getContainer = function () {
            return this.actionBar.getContainer();
        };
        ToolBar.prototype.getItemsWidth = function () {
            var itemsWidth = 0;
            for (var i = 0; i < this.actionBar.length(); i++) {
                itemsWidth += this.actionBar.getWidth(i);
            }
            return itemsWidth;
        };
        ToolBar.prototype.setAriaLabel = function (label) {
            this.actionBar.setAriaLabel(label);
        };
        ToolBar.prototype.setActions = function (primaryActions, secondaryActions) {
            var _this = this;
            return function () {
                var primaryActionsToSet = primaryActions ? primaryActions.slice(0) : [];
                // Inject additional action to open secondary actions if present
                _this.hasSecondaryActions = secondaryActions && secondaryActions.length > 0;
                if (_this.hasSecondaryActions) {
                    _this.toggleMenuAction.menuActions = secondaryActions.slice(0);
                    primaryActionsToSet.push(_this.toggleMenuAction);
                }
                _this.actionBar.clear();
                primaryActionsToSet.forEach(function (action) {
                    _this.actionBar.push(action, { icon: true, label: false, keybinding: _this.getKeybindingLabel(action) });
                });
            };
        };
        ToolBar.prototype.getKeybindingLabel = function (action) {
            var key = this.lookupKeybindings ? this.options.getKeyBinding(action) : void 0;
            return key ? key.getLabel() : void 0;
        };
        ToolBar.prototype.addPrimaryAction = function (primaryAction) {
            var _this = this;
            return function () {
                // Add after the "..." action if we have secondary actions
                if (_this.hasSecondaryActions) {
                    var itemCount = _this.actionBar.length();
                    _this.actionBar.push(primaryAction, { icon: true, label: false, index: itemCount, keybinding: _this.getKeybindingLabel(primaryAction) });
                }
                // Otherwise just add to the end
                else {
                    _this.actionBar.push(primaryAction, { icon: true, label: false, keybinding: _this.getKeybindingLabel(primaryAction) });
                }
            };
        };
        ToolBar.prototype.dispose = function () {
            if (this.toggleMenuActionItem) {
                this.toggleMenuActionItem.dispose();
                this.toggleMenuActionItem = void 0;
            }
            _super.prototype.dispose.call(this);
        };
        return ToolBar;
    }(lifecycle_1.Disposable));
    exports.ToolBar = ToolBar;
    var ToggleMenuAction = /** @class */ (function (_super) {
        __extends(ToggleMenuAction, _super);
        function ToggleMenuAction(toggleDropdownMenu, title) {
            var _this = this;
            title = title || nls.localize('moreActions', "More Actions...");
            _this = _super.call(this, ToggleMenuAction.ID, title, null, true) || this;
            _this.toggleDropdownMenu = toggleDropdownMenu;
            return _this;
        }
        ToggleMenuAction.prototype.run = function () {
            this.toggleDropdownMenu();
            return winjs_base_1.TPromise.as(true);
        };
        Object.defineProperty(ToggleMenuAction.prototype, "menuActions", {
            get: function () {
                return this._menuActions;
            },
            set: function (actions) {
                this._menuActions = actions;
            },
            enumerable: true,
            configurable: true
        });
        ToggleMenuAction.ID = 'toolbar.toggle.more';
        return ToggleMenuAction;
    }(actions_1.Action));
});

define(__m[98/*vs/base/common/errorMessage*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,29/*vs/base/common/types*/,19/*vs/base/common/arrays*/]), function (require, exports, nls, types, arrays) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function exceptionToErrorMessage(exception, verbose) {
        if (exception.message) {
            if (verbose && (exception.stack || exception.stacktrace)) {
                return nls.localize('stackTrace.format', "{0}: {1}", detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);
            }
            return detectSystemErrorMessage(exception);
        }
        return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
    }
    function detectSystemErrorMessage(exception) {
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize('nodeExceptionMessage', "A system error occurred ({0})", exception.message);
        }
        return exception.message;
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     *
     * @returns A string containing the error message.
     */
    function toErrorMessage(error, verbose) {
        if (error === void 0) { error = null; }
        if (verbose === void 0) { verbose = false; }
        if (!error) {
            return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
        }
        if (Array.isArray(error)) {
            var errors = arrays.coalesce(error);
            var msg = toErrorMessage(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize('error.moreErrors', "{0} ({1} errors in total)", msg, errors.length);
            }
            return msg;
        }
        if (types.isString(error)) {
            return error;
        }
        if (error.detail) {
            var detail = error.detail;
            if (detail.error) {
                return exceptionToErrorMessage(detail.error, verbose);
            }
            if (detail.exception) {
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize('error.defaultMessage', "An unknown error occurred. Please consult the log for more details.");
    }
    exports.toErrorMessage = toErrorMessage;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
define(__m[294/*vs/platform/extensionManagement/common/extensionManagementUtil*/], __M([0/*require*/,1/*exports*/,22/*vs/base/common/strings*/]), function (require, exports, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function areSameExtensions(a, b) {
        if (a.uuid && b.uuid) {
            return a.uuid === b.uuid;
        }
        if (a.id === b.id) {
            return true;
        }
        return strings_1.compareIgnoreCase(a.id, b.id) === 0;
    }
    exports.areSameExtensions = areSameExtensions;
    function adoptToGalleryExtensionId(id) {
        return id.toLocaleLowerCase();
    }
    exports.adoptToGalleryExtensionId = adoptToGalleryExtensionId;
    function getGalleryExtensionId(publisher, name) {
        return publisher.toLocaleLowerCase() + "." + name.toLocaleLowerCase();
    }
    exports.getGalleryExtensionId = getGalleryExtensionId;
    function getGalleryExtensionIdFromLocal(local) {
        return local.manifest ? getGalleryExtensionId(local.manifest.publisher, local.manifest.name) : local.identifier.id;
    }
    exports.getGalleryExtensionIdFromLocal = getGalleryExtensionIdFromLocal;
    exports.LOCAL_EXTENSION_ID_REGEX = /^([^.]+\..+)-(\d+\.\d+\.\d+(-.*)?)$/;
    function getIdFromLocalExtensionId(localExtensionId) {
        var matches = exports.LOCAL_EXTENSION_ID_REGEX.exec(localExtensionId);
        if (matches && matches[1]) {
            return adoptToGalleryExtensionId(matches[1]);
        }
        return adoptToGalleryExtensionId(localExtensionId);
    }
    exports.getIdFromLocalExtensionId = getIdFromLocalExtensionId;
    function getLocalExtensionId(id, version) {
        return id + "-" + version;
    }
    exports.getLocalExtensionId = getLocalExtensionId;
    function groupByExtension(extensions, getExtensionIdentifier) {
        var byExtension = [];
        var findGroup = function (extension) {
            for (var _i = 0, byExtension_1 = byExtension; _i < byExtension_1.length; _i++) {
                var group = byExtension_1[_i];
                if (group.some(function (e) { return areSameExtensions(getExtensionIdentifier(e), getExtensionIdentifier(extension)); })) {
                    return group;
                }
            }
            return null;
        };
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var extension = extensions_1[_i];
            var group = findGroup(extension);
            if (group) {
                group.push(extension);
            }
            else {
                byExtension.push([extension]);
            }
        }
        return byExtension;
    }
    exports.groupByExtension = groupByExtension;
    function getLocalExtensionTelemetryData(extension) {
        return {
            id: getGalleryExtensionIdFromLocal(extension),
            name: extension.manifest.name,
            galleryId: null,
            publisherId: extension.metadata ? extension.metadata.publisherId : null,
            publisherName: extension.manifest.publisher,
            publisherDisplayName: extension.metadata ? extension.metadata.publisherDisplayName : null,
            dependencies: extension.manifest.extensionDependencies && extension.manifest.extensionDependencies.length > 0
        };
    }
    exports.getLocalExtensionTelemetryData = getLocalExtensionTelemetryData;
    /* __GDPR__FRAGMENT__
        "GalleryExtensionTelemetryData" : {
            "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "name": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "galleryId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherDisplayName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "dependencies": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
            "${include}": [
                "${GalleryExtensionTelemetryData2}"
            ]
        }
    */
    function getGalleryExtensionTelemetryData(extension) {
        return __assign({ id: extension.identifier.id, name: extension.name, galleryId: extension.identifier.uuid, publisherId: extension.publisherId, publisherName: extension.publisher, publisherDisplayName: extension.publisherDisplayName, dependencies: extension.properties.dependencies.length > 0 }, extension.telemetryData);
    }
    exports.getGalleryExtensionTelemetryData = getGalleryExtensionTelemetryData;
    exports.BetterMergeDisabledNowKey = 'extensions/bettermergedisablednow';
    exports.BetterMergeId = 'pprice.better-merge';
    function getMaliciousExtensionsSet(report) {
        var result = new Set();
        for (var _i = 0, report_1 = report; _i < report_1.length; _i++) {
            var extension = report_1[_i];
            if (extension.malicious) {
                result.add(extension.id.id);
            }
        }
        return result;
    }
    exports.getMaliciousExtensionsSet = getMaliciousExtensionsSet;
    var nonWorkspaceExtensions = new Set();
    function isWorkspaceExtension(manifest, configurationService) {
        var extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
        var configuredWorkspaceExtensions = configurationService.getValue('_workbench.workspaceExtensions') || [];
        if (configuredWorkspaceExtensions.length) {
            if (configuredWorkspaceExtensions.indexOf(extensionId) !== -1) {
                return true;
            }
            if (configuredWorkspaceExtensions.indexOf("-" + extensionId) !== -1) {
                return false;
            }
        }
        if (manifest.main) {
            if ((manifest.categories || []).indexOf('Workspace Extension') !== -1) {
                return true;
            }
            return !nonWorkspaceExtensions.has(extensionId);
        }
        return false;
    }
    exports.isWorkspaceExtension = isWorkspaceExtension;
});

define(__m[80/*vs/platform/instantiation/common/extensions*/], __M([0/*require*/,1/*exports*/,120/*vs/platform/instantiation/common/descriptors*/]), function (require, exports, descriptors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _registry = [];
    function registerSingleton(id, ctor) {
        _registry.push({ id: id, descriptor: new descriptors_1.SyncDescriptor(ctor) });
    }
    exports.registerSingleton = registerSingleton;
    function getServices() {
        return _registry;
    }
    exports.getServices = getServices;
});

define(__m[97/*vs/codesandbox/services/codesandbox/common/codesandbox*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICodeSandboxService = instantiation_1.createDecorator('codesandboxService');
});

define(__m[306/*vs/codesandbox/services/codesandbox/common/codesandboxEditorConnector*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICodeSandboxEditorConnectorService = instantiation_1.createDecorator('codesandboxEditorConnectorService');
});














var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[309/*vs/codesandbox/workbench*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/]), function (require, exports, event_1, lifecycle_1, codesandbox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxWorkbench = /** @class */ (function (_super) {
        __extends(CodeSandboxWorkbench, _super);
        function CodeSandboxWorkbench(codeSandboxService) {
            var _this = _super.call(this) || this;
            _this.codeSandboxService = codeSandboxService;
            //#region IPartService
            _this._onTitleBarVisibilityChange = _this._register(new event_1.Emitter());
            _this._onMenubarVisibilityChange = _this._register(new event_1.Emitter());
            return _this;
        }
        CodeSandboxWorkbench.prototype.getMenubarVisibility = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getWorkbenchElement = function () {
            return document.getElementById('workbench.main.container');
        };
        Object.defineProperty(CodeSandboxWorkbench.prototype, "onTitleBarVisibilityChange", {
            get: function () {
                return this._onTitleBarVisibilityChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxWorkbench.prototype, "onMenubarVisibilityChange", {
            get: function () {
                return this._onMenubarVisibilityChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxWorkbench.prototype, "onEditorLayout", {
            // get onEditorLayout(): Event<IDimension> { return this.editorPart.onDidLayout; }
            // private _onDidLayout: Emitter<IDimension> = this._register(new Emitter<IDimension>());
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        //#endregion
        CodeSandboxWorkbench.prototype.layout = function (options) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.isCreated = function () {
            return true;
        };
        CodeSandboxWorkbench.prototype.hasFocus = function (part) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getContainer = function (part) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.isVisible = function (part) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.setActivityBarHidden = function (hidden) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getTitleBarOffset = function () {
            return 0;
        };
        CodeSandboxWorkbench.prototype.setSideBarHidden = function (hidden) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.setPanelHidden = function (hidden) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.toggleMaximizedPanel = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.isPanelMaximized = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getSideBarPosition = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getPanelPosition = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.setPanelPosition = function (position) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.getWorkbenchElementId = function () {
            return 'workbench.main.container';
        };
        CodeSandboxWorkbench.prototype.toggleZenMode = function () {
            this.codeSandboxService.runSignal('preferences.zenModeToggled', {});
        };
        CodeSandboxWorkbench.prototype.isEditorLayoutCentered = function () {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.centerEditorLayout = function (active) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.resizePart = function (part, sizeChange) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxWorkbench.prototype.initServices = function () { };
        CodeSandboxWorkbench = __decorate([
            __param(0, codesandbox_1.ICodeSandboxService)
        ], CodeSandboxWorkbench);
        return CodeSandboxWorkbench;
    }(lifecycle_1.Disposable));
    exports.CodeSandboxWorkbench = CodeSandboxWorkbench;
});














define(__m[126/*vs/editor/contrib/documentSymbols/outlineModel*/], __M([0/*require*/,1/*exports*/,19/*vs/base/common/arrays*/,55/*vs/base/common/cancellation*/,118/*vs/base/common/collections*/,25/*vs/base/common/errors*/,69/*vs/base/common/filters*/,39/*vs/base/common/map*/,22/*vs/base/common/strings*/,48/*vs/editor/common/core/range*/,85/*vs/editor/common/modes*/]), function (require, exports, arrays_1, cancellation_1, collections_1, errors_1, filters_1, map_1, strings_1, range_1, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TreeElement = /** @class */ (function () {
        function TreeElement() {
        }
        TreeElement.prototype.remove = function () {
            delete this.parent.children[this.id];
        };
        TreeElement.findId = function (candidate, container) {
            // complex id-computation which contains the origin/extension,
            // the parent path, and some dedupe logic when names collide
            var candidateId;
            if (typeof candidate === 'string') {
                candidateId = container.id + "/" + candidate;
            }
            else {
                candidateId = container.id + "/" + candidate.name;
                if (container.children[candidateId] !== void 0) {
                    candidateId = container.id + "/" + candidate.name + "_" + candidate.range.startLineNumber + "_" + candidate.range.startColumn;
                }
            }
            var id = candidateId;
            for (var i = 0; container.children[id] !== void 0; i++) {
                id = candidateId + "_" + i;
            }
            return id;
        };
        TreeElement.getElementById = function (id, element) {
            if (!id) {
                return undefined;
            }
            var len = strings_1.commonPrefixLength(id, element.id);
            if (len === id.length) {
                return element;
            }
            if (len < element.id.length) {
                return undefined;
            }
            for (var key in element.children) {
                var candidate = TreeElement.getElementById(id, element.children[key]);
                if (candidate) {
                    return candidate;
                }
            }
            return undefined;
        };
        TreeElement.size = function (element) {
            var res = 1;
            for (var key in element.children) {
                res += TreeElement.size(element.children[key]);
            }
            return res;
        };
        TreeElement.empty = function (element) {
            for (var _key in element.children) {
                return false;
            }
            return true;
        };
        return TreeElement;
    }());
    exports.TreeElement = TreeElement;
    var OutlineElement = /** @class */ (function (_super) {
        __extends(OutlineElement, _super);
        function OutlineElement(id, parent, symbol) {
            var _this = _super.call(this) || this;
            _this.id = id;
            _this.parent = parent;
            _this.symbol = symbol;
            _this.children = Object.create(null);
            _this.score = [0, []];
            return _this;
        }
        OutlineElement.prototype.adopt = function (parent) {
            var res = new OutlineElement(this.id, parent, this.symbol);
            collections_1.forEach(this.children, function (entry) { return res.children[entry.key] = entry.value.adopt(res); });
            return res;
        };
        return OutlineElement;
    }(TreeElement));
    exports.OutlineElement = OutlineElement;
    var OutlineGroup = /** @class */ (function (_super) {
        __extends(OutlineGroup, _super);
        function OutlineGroup(id, parent, provider, providerIndex) {
            var _this = _super.call(this) || this;
            _this.id = id;
            _this.parent = parent;
            _this.provider = provider;
            _this.providerIndex = providerIndex;
            _this.children = Object.create(null);
            return _this;
        }
        OutlineGroup.prototype.adopt = function (parent) {
            var res = new OutlineGroup(this.id, parent, this.provider, this.providerIndex);
            collections_1.forEach(this.children, function (entry) { return res.children[entry.key] = entry.value.adopt(res); });
            return res;
        };
        OutlineGroup.prototype.updateMatches = function (pattern, topMatch) {
            for (var key in this.children) {
                topMatch = this._updateMatches(pattern, this.children[key], topMatch);
            }
            return topMatch;
        };
        OutlineGroup.prototype._updateMatches = function (pattern, item, topMatch) {
            item.score = filters_1.fuzzyScore(pattern, item.symbol.name, undefined, true);
            if (item.score && (!topMatch || item.score[0] > topMatch.score[0])) {
                topMatch = item;
            }
            for (var key in item.children) {
                var child = item.children[key];
                topMatch = this._updateMatches(pattern, child, topMatch);
                if (!item.score && child.score) {
                    // don't filter parents with unfiltered children
                    item.score = [0, []];
                }
            }
            return topMatch;
        };
        OutlineGroup.prototype.getItemEnclosingPosition = function (position) {
            return position ? this._getItemEnclosingPosition(position, this.children) : undefined;
        };
        OutlineGroup.prototype._getItemEnclosingPosition = function (position, children) {
            for (var key in children) {
                var item = children[key];
                if (!item.symbol.range || !range_1.Range.containsPosition(item.symbol.range, position)) {
                    continue;
                }
                return this._getItemEnclosingPosition(position, item.children) || item;
            }
            return undefined;
        };
        OutlineGroup.prototype.updateMarker = function (marker) {
            for (var key in this.children) {
                this._updateMarker(marker, this.children[key]);
            }
        };
        OutlineGroup.prototype._updateMarker = function (markers, item) {
            item.marker = undefined;
            // find the proper start index to check for item/marker overlap.
            var idx = arrays_1.binarySearch(markers, item.symbol.range, range_1.Range.compareRangesUsingStarts);
            var start;
            if (idx < 0) {
                start = ~idx;
                if (start > 0 && range_1.Range.areIntersecting(markers[start - 1], item.symbol.range)) {
                    start -= 1;
                }
            }
            else {
                start = idx;
            }
            var myMarkers = [];
            var myTopSev;
            for (; start < markers.length && range_1.Range.areIntersecting(item.symbol.range, markers[start]); start++) {
                // remove markers intersecting with this outline element
                // and store them in a 'private' array.
                var marker = markers[start];
                myMarkers.push(marker);
                markers[start] = undefined;
                if (!myTopSev || marker.severity > myTopSev) {
                    myTopSev = marker.severity;
                }
            }
            // Recurse into children and let them match markers that have matched
            // this outline element. This might remove markers from this element and
            // therefore we remember that we have had markers. That allows us to render
            // the dot, saying 'this element has children with markers'
            for (var key in item.children) {
                this._updateMarker(myMarkers, item.children[key]);
            }
            if (myTopSev) {
                item.marker = {
                    count: myMarkers.length,
                    topSev: myTopSev
                };
            }
            arrays_1.coalesce(markers, true);
        };
        return OutlineGroup;
    }(TreeElement));
    exports.OutlineGroup = OutlineGroup;
    var OutlineModel = /** @class */ (function (_super) {
        __extends(OutlineModel, _super);
        function OutlineModel(textModel) {
            var _this = _super.call(this) || this;
            _this.textModel = textModel;
            _this.id = 'root';
            _this.parent = undefined;
            _this._groups = Object.create(null);
            _this.children = Object.create(null);
            return _this;
        }
        OutlineModel.create = function (textModel, token) {
            var key = this._keys.for(textModel);
            var data = OutlineModel._requests.get(key);
            if (!data) {
                var source = new cancellation_1.CancellationTokenSource();
                data = {
                    promiseCnt: 0,
                    source: source,
                    promise: OutlineModel._create(textModel, source.token),
                    model: undefined,
                };
                OutlineModel._requests.set(key, data);
            }
            if (data.model) {
                // resolved -> return data
                return Promise.resolve(data.model);
            }
            // increase usage counter
            data.promiseCnt += 1;
            token.onCancellationRequested(function () {
                // last -> cancel provider request, remove cached promise
                if (--data.promiseCnt === 0) {
                    data.source.cancel();
                    OutlineModel._requests.delete(key);
                }
            });
            return new Promise(function (resolve, reject) {
                data.promise.then(function (model) {
                    data.model = model;
                    resolve(model);
                }, function (err) {
                    OutlineModel._requests.delete(key);
                    reject(err);
                });
            });
        };
        OutlineModel._create = function (textModel, token) {
            var result = new OutlineModel(textModel);
            var promises = modes_1.DocumentSymbolProviderRegistry.ordered(textModel).map(function (provider, index) {
                var id = TreeElement.findId("provider_" + index, result);
                var group = new OutlineGroup(id, result, provider, index);
                return Promise.resolve(provider.provideDocumentSymbols(result.textModel, token)).then(function (result) {
                    if (!arrays_1.isFalsyOrEmpty(result)) {
                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                            var info = result_1[_i];
                            OutlineModel._makeOutlineElement(info, group);
                        }
                    }
                    return group;
                }, function (err) {
                    errors_1.onUnexpectedExternalError(err);
                    return group;
                }).then(function (group) {
                    if (!TreeElement.empty(group)) {
                        result._groups[id] = group;
                    }
                    else {
                        group.remove();
                    }
                });
            });
            return Promise.all(promises).then(function () { return result._compact(); });
        };
        OutlineModel._makeOutlineElement = function (info, container) {
            var id = TreeElement.findId(info, container);
            var res = new OutlineElement(id, container, info);
            if (info.children) {
                for (var _i = 0, _a = info.children; _i < _a.length; _i++) {
                    var childInfo = _a[_i];
                    OutlineModel._makeOutlineElement(childInfo, res);
                }
            }
            container.children[res.id] = res;
        };
        OutlineModel.get = function (element) {
            while (element) {
                if (element instanceof OutlineModel) {
                    return element;
                }
                element = element.parent;
            }
            return undefined;
        };
        OutlineModel.prototype.adopt = function () {
            var res = new OutlineModel(this.textModel);
            collections_1.forEach(this._groups, function (entry) { return res._groups[entry.key] = entry.value.adopt(res); });
            return res._compact();
        };
        OutlineModel.prototype._compact = function () {
            var count = 0;
            for (var key in this._groups) {
                var group = this._groups[key];
                if (collections_1.first(group.children) === undefined) { // empty
                    delete this._groups[key];
                }
                else {
                    count += 1;
                }
            }
            if (count !== 1) {
                //
                this.children = this._groups;
            }
            else {
                // adopt all elements of the first group
                var group = collections_1.first(this._groups);
                for (var key in group.children) {
                    var child = group.children[key];
                    child.parent = this;
                    this.children[child.id] = child;
                }
            }
            return this;
        };
        OutlineModel.prototype.merge = function (other) {
            if (this.textModel.uri.toString() !== other.textModel.uri.toString()) {
                return false;
            }
            if (collections_1.size(this._groups) !== collections_1.size(other._groups)) {
                return false;
            }
            this._groups = other._groups;
            this.children = other.children;
            return true;
        };
        OutlineModel.prototype.updateMatches = function (pattern) {
            if (this._matches && this._matches[0] === pattern) {
                return this._matches[1];
            }
            var topMatch;
            for (var key in this._groups) {
                topMatch = this._groups[key].updateMatches(pattern, topMatch);
            }
            this._matches = [pattern, topMatch];
            return topMatch;
        };
        OutlineModel.prototype.getItemEnclosingPosition = function (position, context) {
            var preferredGroup;
            if (context) {
                var candidate = context.parent;
                while (candidate && !preferredGroup) {
                    if (candidate instanceof OutlineGroup) {
                        preferredGroup = candidate;
                    }
                    candidate = candidate.parent;
                }
            }
            var result = undefined;
            for (var key in this._groups) {
                var group = this._groups[key];
                result = group.getItemEnclosingPosition(position);
                if (result && (!preferredGroup || preferredGroup === group)) {
                    break;
                }
            }
            return result;
        };
        OutlineModel.prototype.getItemById = function (id) {
            return TreeElement.getElementById(id, this);
        };
        OutlineModel.prototype.updateMarker = function (marker) {
            // sort markers by start range so that we can use
            // outline element starts for quicker look up
            marker.sort(range_1.Range.compareRangesUsingStarts);
            for (var key in this._groups) {
                this._groups[key].updateMarker(marker.slice(0));
            }
        };
        OutlineModel._requests = new map_1.LRUCache(9, .75);
        OutlineModel._keys = new /** @class */ (function () {
            function class_1() {
                this._counter = 1;
                this._data = new WeakMap();
            }
            class_1.prototype.for = function (textModel) {
                return textModel.id + "/" + textModel.getVersionId() + "/" + this._hash(modes_1.DocumentSymbolProviderRegistry.all(textModel));
            };
            class_1.prototype._hash = function (providers) {
                var result = '';
                for (var _i = 0, providers_1 = providers; _i < providers_1.length; _i++) {
                    var provider = providers_1[_i];
                    var n = this._data.get(provider);
                    if (typeof n === 'undefined') {
                        n = this._counter++;
                        this._data.set(provider, n);
                    }
                    result += n;
                }
                return result;
            };
            return class_1;
        }());
        return OutlineModel;
    }(TreeElement));
    exports.OutlineModel = OutlineModel;
});










define(__m[335/*vs/codesandbox/commandService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,37/*vs/platform/commands/common/commands*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, commands_1, instantiation_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxCommandService = /** @class */ (function () {
        function CodeSandboxCommandService(_instantiationService) {
            this._instantiationService = _instantiationService;
            this._onWillExecuteCommand = new event_1.Emitter();
            this.onWillExecuteCommand = this
                ._onWillExecuteCommand.event;
            this._dynamicCommands = Object.create(null);
        }
        CodeSandboxCommandService.prototype.addCommand = function (command) {
            var _this = this;
            var id = command.id;
            this._dynamicCommands[id] = command;
            return lifecycle_1.toDisposable(function () {
                delete _this._dynamicCommands[id];
            });
        };
        CodeSandboxCommandService.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var command = commands_1.CommandsRegistry.getCommand(id) || this._dynamicCommands[id];
            if (!command) {
                return Promise.reject(new Error("command '" + id + "' not found"));
            }
            try {
                this._onWillExecuteCommand.fire({ commandId: id });
                var result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler].concat(args));
                return Promise.resolve(result);
            }
            catch (err) {
                return Promise.reject(err);
            }
        };
        CodeSandboxCommandService = __decorate([
            __param(0, instantiation_1.IInstantiationService)
        ], CodeSandboxCommandService);
        return CodeSandboxCommandService;
    }());
    exports.CodeSandboxCommandService = CodeSandboxCommandService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[122/*vs/platform/extensionManagement/common/extensionManagement*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, nls_1, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EXTENSION_IDENTIFIER_PATTERN = '^([a-z0-9A-Z][a-z0-9\-A-Z]*)\\.([a-z0-9A-Z][a-z0-9\-A-Z]*)$';
    exports.EXTENSION_IDENTIFIER_REGEX = new RegExp(exports.EXTENSION_IDENTIFIER_PATTERN);
    function isIExtensionIdentifier(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.id === 'string'
            && (!thing.uuid || typeof thing.uuid === 'string');
    }
    exports.isIExtensionIdentifier = isIExtensionIdentifier;
    exports.IExtensionManagementService = instantiation_1.createDecorator('extensionManagementService');
    exports.IExtensionGalleryService = instantiation_1.createDecorator('extensionGalleryService');
    exports.IExtensionManagementServerService = instantiation_1.createDecorator('extensionManagementServerService');
    exports.IExtensionEnablementService = instantiation_1.createDecorator('extensionEnablementService');
    exports.IExtensionTipsService = instantiation_1.createDecorator('extensionTipsService');
    exports.ExtensionsLabel = nls_1.localize('extensions', "Extensions");
    exports.ExtensionsChannelId = 'extensions';
    exports.PreferencesLabel = nls_1.localize('preferences', "Preferences");
});

define(__m[63/*vs/platform/lifecycle/common/lifecycle*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,6/*vs/base/common/event*/,3/*vs/platform/instantiation/common/instantiation*/,17/*vs/base/common/async*/]), function (require, exports, winjs_base_1, event_1, instantiation_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');
    function StartupKindToString(startupKind) {
        switch (startupKind) {
            case 1 /* NewWindow */: return 'NewWindow';
            case 3 /* ReloadedWindow */: return 'ReloadedWindow';
            case 4 /* ReopenedWindow */: return 'ReopenedWindow';
        }
    }
    exports.StartupKindToString = StartupKindToString;
    function LifecyclePhaseToString(phase) {
        switch (phase) {
            case 1 /* Starting */: return 'Starting';
            case 2 /* Restoring */: return 'Restoring';
            case 3 /* Running */: return 'Running';
            case 4 /* Eventually */: return 'Eventually';
        }
    }
    exports.LifecyclePhaseToString = LifecyclePhaseToString;
    exports.NullLifecycleService = {
        _serviceBrand: null,
        phase: 3 /* Running */,
        when: function () { return Promise.resolve(); },
        startupKind: 1 /* NewWindow */,
        onWillShutdown: event_1.Event.None,
        onShutdown: event_1.Event.None
    };
    // Shared veto handling across main and renderer
    function handleVetos(vetos, onError) {
        if (vetos.length === 0) {
            return winjs_base_1.TPromise.as(false);
        }
        var promises = [];
        var lazyValue = false;
        for (var _i = 0, vetos_1 = vetos; _i < vetos_1.length; _i++) {
            var valueOrPromise = vetos_1[_i];
            // veto, done
            if (valueOrPromise === true) {
                return winjs_base_1.TPromise.as(true);
            }
            if (async_1.isThenable(valueOrPromise)) {
                promises.push(valueOrPromise.then(function (value) {
                    if (value) {
                        lazyValue = true; // veto, done
                    }
                }, function (err) {
                    onError(err); // error, treated like a veto, done
                    lazyValue = true;
                }));
            }
        }
        return winjs_base_1.TPromise.join(promises).then(function () { return lazyValue; });
    }
    exports.handleVetos = handleVetos;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[349/*vs/platform/broadcast/electron-browser/broadcastService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,6/*vs/base/common/event*/,350/*electron*/,86/*vs/platform/log/common/log*/]), function (require, exports, instantiation_1, event_1, electron_1, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBroadcastService = instantiation_1.createDecorator('broadcastService');
    var BroadcastService = /** @class */ (function () {
        function BroadcastService(windowId, logService) {
            this.windowId = windowId;
            this.logService = logService;
            this._onBroadcast = new event_1.Emitter();
            this.registerListeners();
        }
        BroadcastService.prototype.registerListeners = function () {
            var _this = this;
            electron_1.ipcRenderer.on('vscode:broadcast', function (event, b) {
                _this.logService.trace("Received broadcast from main in window " + _this.windowId + ": ", b);
                _this._onBroadcast.fire(b);
            });
        };
        Object.defineProperty(BroadcastService.prototype, "onBroadcast", {
            get: function () {
                return this._onBroadcast.event;
            },
            enumerable: true,
            configurable: true
        });
        BroadcastService.prototype.broadcast = function (b) {
            this.logService.trace("Sending broadcast to main from window " + this.windowId + ": ", b);
            electron_1.ipcRenderer.send('vscode:broadcast', this.windowId, {
                channel: b.channel,
                payload: b.payload
            });
        };
        BroadcastService = __decorate([
            __param(1, log_1.ILogService)
        ], BroadcastService);
        return BroadcastService;
    }());
    exports.BroadcastService = BroadcastService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[115/*vs/platform/actions/browser/menuItemActionItem*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,220/*vs/base/browser/event*/,50/*vs/base/browser/ui/actionbar/actionbar*/,6/*vs/base/common/event*/,163/*vs/base/common/idGenerator*/,4/*vs/base/common/lifecycle*/,18/*vs/base/common/platform*/,2/*vs/nls*/,23/*vs/platform/actions/common/actions*/,34/*vs/platform/contextview/browser/contextView*/,31/*vs/platform/keybinding/common/keybinding*/,28/*vs/platform/notification/common/notification*/]), function (require, exports, dom_1, event_1, actionbar_1, event_2, idGenerator_1, lifecycle_1, platform_1, nls_1, actions_1, contextView_1, keybinding_1, notification_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // The alternative key on all platforms is alt. On windows we also support shift as an alternative key #44136
    var AlternativeKeyEmitter = /** @class */ (function (_super) {
        __extends(AlternativeKeyEmitter, _super);
        function AlternativeKeyEmitter(contextMenuService) {
            var _this = _super.call(this) || this;
            _this._subscriptions = [];
            _this._suppressAltKeyUp = false;
            _this._subscriptions.push(event_1.domEvent(document.body, 'keydown')(function (e) {
                _this.isPressed = e.altKey || ((platform_1.isWindows || platform_1.isLinux) && e.shiftKey);
            }));
            _this._subscriptions.push(event_1.domEvent(document.body, 'keyup')(function (e) {
                if (_this.isPressed) {
                    if (_this._suppressAltKeyUp) {
                        e.preventDefault();
                    }
                }
                _this._suppressAltKeyUp = false;
                _this.isPressed = false;
            }));
            _this._subscriptions.push(event_1.domEvent(document.body, 'mouseleave')(function (e) { return _this.isPressed = false; }));
            _this._subscriptions.push(event_1.domEvent(document.body, 'blur')(function (e) { return _this.isPressed = false; }));
            // Workaround since we do not get any events while a context menu is shown
            _this._subscriptions.push(contextMenuService.onDidContextMenu(function () { return _this.isPressed = false; }));
            return _this;
        }
        Object.defineProperty(AlternativeKeyEmitter.prototype, "isPressed", {
            get: function () {
                return this._isPressed;
            },
            set: function (value) {
                this._isPressed = value;
                this.fire(this._isPressed);
            },
            enumerable: true,
            configurable: true
        });
        AlternativeKeyEmitter.prototype.suppressAltKeyUp = function () {
            // Sometimes the native alt behavior needs to be suppresed since the alt was already used as an alternative key
            // Example: windows behavior to toggle tha top level menu #44396
            this._suppressAltKeyUp = true;
        };
        AlternativeKeyEmitter.getInstance = function (contextMenuService) {
            if (!AlternativeKeyEmitter.instance) {
                AlternativeKeyEmitter.instance = new AlternativeKeyEmitter(contextMenuService);
            }
            return AlternativeKeyEmitter.instance;
        };
        AlternativeKeyEmitter.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._subscriptions = lifecycle_1.dispose(this._subscriptions);
        };
        return AlternativeKeyEmitter;
    }(event_2.Emitter));
    function fillInContextMenuActions(menu, options, target, contextMenuService, isPrimaryGroup) {
        var groups = menu.getActions(options);
        var getAlternativeActions = AlternativeKeyEmitter.getInstance(contextMenuService).isPressed;
        fillInActions(groups, target, getAlternativeActions, isPrimaryGroup);
    }
    exports.fillInContextMenuActions = fillInContextMenuActions;
    function fillInActionBarActions(menu, options, target, isPrimaryGroup) {
        var groups = menu.getActions(options);
        // Action bars handle alternative actions on their own so the alternative actions should be ignored
        fillInActions(groups, target, false, isPrimaryGroup);
    }
    exports.fillInActionBarActions = fillInActionBarActions;
    function fillInActions(groups, target, getAlternativeActions, isPrimaryGroup) {
        if (isPrimaryGroup === void 0) { isPrimaryGroup = function (group) { return group === 'navigation'; }; }
        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
            var tuple = groups_1[_i];
            var group = tuple[0], actions = tuple[1];
            if (getAlternativeActions) {
                actions = actions.map(function (a) { return (a instanceof actions_1.MenuItemAction) && !!a.alt ? a.alt : a; });
            }
            if (isPrimaryGroup(group)) {
                var to = Array.isArray(target) ? target : target.primary;
                to.unshift.apply(to, actions);
            }
            else {
                var to = Array.isArray(target) ? target : target.secondary;
                if (to.length > 0) {
                    to.push(new actionbar_1.Separator());
                }
                to.push.apply(to, actions);
            }
        }
    }
    function createActionItem(action, keybindingService, notificationService, contextMenuService) {
        if (action instanceof actions_1.MenuItemAction) {
            return new MenuItemActionItem(action, keybindingService, notificationService, contextMenuService);
        }
        return undefined;
    }
    exports.createActionItem = createActionItem;
    var ids = new idGenerator_1.IdGenerator('menu-item-action-item-icon-');
    var MenuItemActionItem = /** @class */ (function (_super) {
        __extends(MenuItemActionItem, _super);
        function MenuItemActionItem(_action, _keybindingService, _notificationService, _contextMenuService) {
            var _this = _super.call(this, undefined, _action, { icon: !!(_action.class || _action.item.iconLocation), label: !_action.class && !_action.item.iconLocation }) || this;
            _this._action = _action;
            _this._keybindingService = _keybindingService;
            _this._notificationService = _notificationService;
            _this._contextMenuService = _contextMenuService;
            return _this;
        }
        Object.defineProperty(MenuItemActionItem.prototype, "_commandAction", {
            get: function () {
                return this._wantsAltCommand && this._action.alt || this._action;
            },
            enumerable: true,
            configurable: true
        });
        MenuItemActionItem.prototype.onClick = function (event) {
            var _this = this;
            event.preventDefault();
            event.stopPropagation();
            var altKey = AlternativeKeyEmitter.getInstance(this._contextMenuService);
            if (altKey.isPressed) {
                altKey.suppressAltKeyUp();
            }
            this.actionRunner.run(this._commandAction)
                .then(undefined, function (err) { return _this._notificationService.error(err); });
        };
        MenuItemActionItem.prototype.render = function (container) {
            var _this = this;
            _super.prototype.render.call(this, container);
            this._updateItemClass(this._action.item);
            var mouseOver = false;
            var alternativeKeyEmitter = AlternativeKeyEmitter.getInstance(this._contextMenuService);
            var alternativeKeyDown = alternativeKeyEmitter.isPressed;
            var updateAltState = function () {
                var wantsAltCommand = mouseOver && alternativeKeyDown;
                if (wantsAltCommand !== _this._wantsAltCommand) {
                    _this._wantsAltCommand = wantsAltCommand;
                    _this.updateLabel();
                    _this.updateTooltip();
                    _this.updateClass();
                }
            };
            this._register(alternativeKeyEmitter.event(function (value) {
                alternativeKeyDown = value;
                updateAltState();
            }));
            this._register(event_1.domEvent(container, 'mouseleave')(function (_) {
                mouseOver = false;
                updateAltState();
            }));
            this._register(event_1.domEvent(container, 'mouseenter')(function (e) {
                mouseOver = true;
                updateAltState();
            }));
        };
        MenuItemActionItem.prototype.updateLabel = function () {
            if (this.options.label) {
                this.label.textContent = this._commandAction.label;
            }
        };
        MenuItemActionItem.prototype.updateTooltip = function () {
            var element = this.label;
            var keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id);
            var keybindingLabel = keybinding && keybinding.getLabel();
            element.title = keybindingLabel
                ? nls_1.localize('titleAndKb', "{0} ({1})", this._commandAction.label, keybindingLabel)
                : this._commandAction.label;
        };
        MenuItemActionItem.prototype.updateClass = function () {
            if (this.options.icon) {
                if (this._commandAction !== this._action) {
                    this._updateItemClass(this._action.alt.item);
                }
                else if (this._action.alt) {
                    this._updateItemClass(this._action.item);
                }
            }
        };
        MenuItemActionItem.prototype._updateItemClass = function (item) {
            var _this = this;
            lifecycle_1.dispose(this._itemClassDispose);
            this._itemClassDispose = undefined;
            if (item.iconLocation) {
                var iconClass_1;
                var iconPathMapKey = item.iconLocation.dark.toString();
                if (MenuItemActionItem.ICON_PATH_TO_CSS_RULES.has(iconPathMapKey)) {
                    iconClass_1 = MenuItemActionItem.ICON_PATH_TO_CSS_RULES.get(iconPathMapKey);
                }
                else {
                    iconClass_1 = ids.nextId();
                    dom_1.createCSSRule(".icon." + iconClass_1, "background-image: url(\"" + (item.iconLocation.light || item.iconLocation.dark).toString() + "\")");
                    dom_1.createCSSRule(".vs-dark .icon." + iconClass_1 + ", .hc-black .icon." + iconClass_1, "background-image: url(\"" + item.iconLocation.dark.toString() + "\")");
                    MenuItemActionItem.ICON_PATH_TO_CSS_RULES.set(iconPathMapKey, iconClass_1);
                }
                dom_1.addClasses(this.label, 'icon', iconClass_1);
                this._itemClassDispose = lifecycle_1.toDisposable(function () { return dom_1.removeClasses(_this.label, 'icon', iconClass_1); });
            }
        };
        MenuItemActionItem.prototype.dispose = function () {
            if (this._itemClassDispose) {
                lifecycle_1.dispose(this._itemClassDispose);
                this._itemClassDispose = undefined;
            }
            _super.prototype.dispose.call(this);
        };
        MenuItemActionItem.ICON_PATH_TO_CSS_RULES = new Map();
        MenuItemActionItem = __decorate([
            __param(1, keybinding_1.IKeybindingService),
            __param(2, notification_1.INotificationService),
            __param(3, contextView_1.IContextMenuService)
        ], MenuItemActionItem);
        return MenuItemActionItem;
    }(actionbar_1.ActionItem));
    exports.MenuItemActionItem = MenuItemActionItem;
    // Need to subclass MenuItemActionItem in order to respect
    // the action context coming from any action bar, without breaking
    // existing users
    var ContextAwareMenuItemActionItem = /** @class */ (function (_super) {
        __extends(ContextAwareMenuItemActionItem, _super);
        function ContextAwareMenuItemActionItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ContextAwareMenuItemActionItem.prototype.onClick = function (event) {
            var _this = this;
            event.preventDefault();
            event.stopPropagation();
            this.actionRunner.run(this._commandAction, this._context)
                .then(undefined, function (err) { return _this._notificationService.error(err); });
        };
        return ContextAwareMenuItemActionItem;
    }(MenuItemActionItem));
    exports.ContextAwareMenuItemActionItem = ContextAwareMenuItemActionItem;
});

define(__m[46/*vs/platform/quickOpen/common/quickOpen*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IQuickOpenService = instantiation_1.createDecorator('quickOpenService');
});

define(__m[62/*vs/platform/quickinput/common/quickInput*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IQuickInputService = instantiation_1.createDecorator('quickInputService');
});










define(__m[371/*vs/codesandbox/fileDialogService*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,62/*vs/platform/quickinput/common/quickInput*/]), function (require, exports, uri_1, winjs_base_1, quickInput_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxFileDialogService = /** @class */ (function () {
        function CodeSandboxFileDialogService(quickInput) {
            this.quickInput = quickInput;
        }
        CodeSandboxFileDialogService.prototype.defaultFilePath = function (schemeFilter) {
            throw new Error('Called defaultFilePath');
        };
        CodeSandboxFileDialogService.prototype.defaultFolderPath = function (schemeFilter) {
            throw new Error('Called defaultFolderPath');
        };
        CodeSandboxFileDialogService.prototype.defaultWorkspacePath = function (schemeFilter) {
            throw new Error('Called defaultWorkspacePath');
        };
        CodeSandboxFileDialogService.prototype.toNativeOpenDialogOptions = function (options) {
            throw new Error('Called toNativeOpenDialogOptions');
        };
        CodeSandboxFileDialogService.prototype.pickFileFolderAndOpen = function (options) {
            throw new Error('Called pickFileFolderAndOpen');
        };
        CodeSandboxFileDialogService.prototype.pickFileAndOpen = function (options) {
            throw new Error('called pickFileAndOpen');
        };
        CodeSandboxFileDialogService.prototype.pickFolderAndOpen = function (options) {
            throw new Error('called pickFolderAndOpen');
        };
        CodeSandboxFileDialogService.prototype.pickWorkspaceAndOpen = function (options) {
            throw new Error('called pickWorkspaceAndOpen');
        };
        CodeSandboxFileDialogService.prototype.toNativeSaveDialogOptions = function (options) {
            throw new Error('Called toNativeSaveDialogOptions');
        };
        CodeSandboxFileDialogService.prototype.showSaveDialog = function (options) {
            var _this = this;
            var pathParts = options.defaultUri.fsPath.split('/');
            var filename = pathParts.pop();
            // pop last opened file, for some reason vscode suggests this: "/sandbox/src/index.js/Untitled-1.css"
            pathParts.pop();
            var defaultPath = pathParts.join('/') + '/' + filename;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                _this.quickInput
                    .input({
                    placeHolder: 'Where should we save the file?',
                    value: defaultPath.replace(/^\/sandbox/, ''),
                })
                    .then(function (val) {
                    if (!val) {
                        return resolve(undefined);
                    }
                    resolve(uri_1.URI.file('/sandbox' + val));
                });
            });
        };
        CodeSandboxFileDialogService.prototype.showOpenDialog = function (options) {
            throw new Error('Called showOpenDialog');
        };
        CodeSandboxFileDialogService = __decorate([
            __param(0, quickInput_1.IQuickInputService)
        ], CodeSandboxFileDialogService);
        return CodeSandboxFileDialogService;
    }());
    exports.CodeSandboxFileDialogService = CodeSandboxFileDialogService;
});























define(__m[375/*vs/codesandbox/services/codesandbox/codesandboxActions*/], __M([0/*require*/,1/*exports*/,15/*vs/base/common/actions*/,5/*vs/base/common/winjs.base*/,62/*vs/platform/quickinput/common/quickInput*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/]), function (require, exports, actions_1, winjs_base_1, quickInput_1, codesandbox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxTogglePreviewAction = /** @class */ (function (_super) {
        __extends(CodeSandboxTogglePreviewAction, _super);
        function CodeSandboxTogglePreviewAction(id, label, codeSandboxService) {
            var _this = _super.call(this, id, label) || this;
            _this.codeSandboxService = codeSandboxService;
            return _this;
        }
        CodeSandboxTogglePreviewAction.prototype.run = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (r) {
                _this.codeSandboxService.runSignal('editor.togglePreviewContent', {});
                r(null);
            });
        };
        CodeSandboxTogglePreviewAction.ID = 'codesandbox.preview.toggle';
        CodeSandboxTogglePreviewAction.LABEL = 'Toggle Preview';
        CodeSandboxTogglePreviewAction = __decorate([
            __param(2, codesandbox_1.ICodeSandboxService)
        ], CodeSandboxTogglePreviewAction);
        return CodeSandboxTogglePreviewAction;
    }(actions_1.Action));
    exports.CodeSandboxTogglePreviewAction = CodeSandboxTogglePreviewAction;
    var CodeSandboxOpenPreviewExternalAction = /** @class */ (function (_super) {
        __extends(CodeSandboxOpenPreviewExternalAction, _super);
        function CodeSandboxOpenPreviewExternalAction(id, label, codeSandboxService) {
            var _this = _super.call(this, id, label) || this;
            _this.codeSandboxService = codeSandboxService;
            return _this;
        }
        CodeSandboxOpenPreviewExternalAction.prototype.run = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (r) {
                _this.codeSandboxService.openPreviewExternally();
                r(null);
            });
        };
        CodeSandboxOpenPreviewExternalAction.ID = 'codesandbox.preview.external';
        CodeSandboxOpenPreviewExternalAction.LABEL = 'Open Preview In New Window';
        CodeSandboxOpenPreviewExternalAction = __decorate([
            __param(2, codesandbox_1.ICodeSandboxService)
        ], CodeSandboxOpenPreviewExternalAction);
        return CodeSandboxOpenPreviewExternalAction;
    }(actions_1.Action));
    exports.CodeSandboxOpenPreviewExternalAction = CodeSandboxOpenPreviewExternalAction;
    var CodeSandboxAddDependencyAction = /** @class */ (function (_super) {
        __extends(CodeSandboxAddDependencyAction, _super);
        function CodeSandboxAddDependencyAction(id, label, codeSandboxService) {
            var _this = _super.call(this, id, label) || this;
            _this.codeSandboxService = codeSandboxService;
            return _this;
        }
        CodeSandboxAddDependencyAction.prototype.run = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (r) {
                _this.codeSandboxService.runSignal('modalOpened', {
                    modal: 'searchDependencies',
                });
                r(null);
            });
        };
        CodeSandboxAddDependencyAction.ID = 'codesandbox.dependencies.add';
        CodeSandboxAddDependencyAction.LABEL = 'Add NPM Dependency';
        CodeSandboxAddDependencyAction = __decorate([
            __param(2, codesandbox_1.ICodeSandboxService)
        ], CodeSandboxAddDependencyAction);
        return CodeSandboxAddDependencyAction;
    }(actions_1.Action));
    exports.CodeSandboxAddDependencyAction = CodeSandboxAddDependencyAction;
    var CodeSandboxSetThemeAction = /** @class */ (function (_super) {
        __extends(CodeSandboxSetThemeAction, _super);
        function CodeSandboxSetThemeAction(id, label, codeSandboxService, quickInputService) {
            var _this = _super.call(this, id, label) || this;
            _this.codeSandboxService = codeSandboxService;
            _this.quickInputService = quickInputService;
            return _this;
        }
        CodeSandboxSetThemeAction.prototype.run = function () {
            var _this = this;
            var picks = this.codeSandboxService
                .getThemes()
                .map(function (theme) { return ({
                id: theme.id,
                label: theme.name,
            }); });
            var currentTheme = this.codeSandboxService.getCurrentTheme();
            var currentPick = picks.filter(function (p) { return p.label === currentTheme; })[0];
            var pickTheme = function (label) {
                _this.codeSandboxService.runSignal('preferences.settingChanged', {
                    name: 'editorTheme',
                    value: label,
                });
            };
            var pickOptions = {
                activeItem: currentPick,
                onDidFocus: function (theme) {
                    requestAnimationFrame(function () {
                        pickTheme(theme.label);
                    });
                },
            };
            return this.quickInputService
                .pick(winjs_base_1.TPromise.as(picks), pickOptions)
                .then(function (pick) {
                if (!pick) {
                    pickTheme(currentTheme);
                }
                else {
                    pickTheme(pick.label);
                }
            });
        };
        CodeSandboxSetThemeAction.ID = 'codesandbox.theme.set';
        CodeSandboxSetThemeAction.LABEL = 'Color Theme';
        CodeSandboxSetThemeAction = __decorate([
            __param(2, codesandbox_1.ICodeSandboxService),
            __param(3, quickInput_1.IQuickInputService)
        ], CodeSandboxSetThemeAction);
        return CodeSandboxSetThemeAction;
    }(actions_1.Action));
    exports.CodeSandboxSetThemeAction = CodeSandboxSetThemeAction;
});

define(__m[378/*vs/codesandbox/configuration.contribution*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,2/*vs/nls*/,90/*vs/platform/configuration/common/configurationRegistry*/,18/*vs/base/common/platform*/]), function (require, exports, platform_1, nls, configurationRegistry_1, platform_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Configuration: Workbench
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    configurationRegistry.registerConfiguration({
        id: 'workbench',
        order: 7,
        title: nls.localize('workbenchConfigurationTitle', 'Workbench'),
        type: 'object',
        properties: {
            'workbench.editor.showTabs': {
                type: 'boolean',
                description: nls.localize('showEditorTabs', 'Controls if opened editors should show in tabs or not.'),
                default: true,
            },
            'workbench.editor.labelFormat': {
                type: 'string',
                enum: ['default', 'short', 'medium', 'long'],
                enumDescriptions: [
                    nls.localize('workbench.editor.labelFormat.default', "Show the name of the file. When tabs are enabled and two files have the same name in one group the distinguinshing sections of each file's path are added. When tabs are disabled, the path relative to the workspace folder is shown if the editor is active."),
                    nls.localize('workbench.editor.labelFormat.short', "Show the name of the file followed by it's directory name."),
                    nls.localize('workbench.editor.labelFormat.medium', "Show the name of the file followed by it's path relative to the workspace folder."),
                    nls.localize('workbench.editor.labelFormat.long', "Show the name of the file followed by it's absolute path."),
                ],
                default: 'default',
                description: nls.localize({
                    comment: [
                        'This is the description for a setting. Values surrounded by parenthesis are not to be translated.',
                    ],
                    key: 'tabDescription',
                }, "Controls the format of the label for an editor. Changing this setting can for example make it easier to understand the location of a file:\n- short:   'parent'\n- medium:  'workspace/src/parent'\n- long:    '/home/user/workspace/src/parent'\n- default: '.../parent', when another tab shares the same title, or the relative workspace path if tabs are disabled"),
            },
            'workbench.editor.tabCloseButton': {
                type: 'string',
                enum: ['left', 'right', 'off'],
                default: 'right',
                description: nls.localize({
                    comment: [
                        'This is the description for a setting. Values surrounded by single quotes are not to be translated.',
                    ],
                    key: 'editorTabCloseButton',
                }, "Controls the position of the editor's tabs close buttons or disables them when set to 'off'."),
            },
            'workbench.editor.tabSizing': {
                type: 'string',
                enum: ['fit', 'shrink'],
                default: 'fit',
                description: nls.localize({
                    comment: [
                        'This is the description for a setting. Values surrounded by single quotes are not to be translated.',
                    ],
                    key: 'tabSizing',
                }, "Controls the sizing of editor tabs. Set to 'fit' to keep tabs always large enough to show the full editor label. Set to 'shrink' to allow tabs to get smaller when the available space is not enough to show all tabs at once."),
            },
            'workbench.editor.showIcons': {
                type: 'boolean',
                description: nls.localize('showIcons', 'Controls if opened editors should show with an icon or not. This requires an icon theme to be enabled as well.'),
                default: true,
            },
            'workbench.editor.enablePreview': {
                type: 'boolean',
                description: nls.localize('enablePreview', 'Controls if opened editors show as preview. Preview editors are reused until they are kept (e.g. via double click or editing) and show up with an italic font style.'),
                default: true,
            },
            'workbench.editor.enablePreviewFromQuickOpen': {
                type: 'boolean',
                description: nls.localize('enablePreviewFromQuickOpen', 'Controls if opened editors from Quick Open show as preview. Preview editors are reused until they are kept (e.g. via double click or editing).'),
                default: true,
            },
            'workbench.editor.closeOnFileDelete': {
                type: 'boolean',
                description: nls.localize('closeOnFileDelete', 'Controls if editors showing a file should close automatically when the file is deleted or renamed by some other process. Disabling this will keep the editor open as dirty on such an event. Note that deleting from within the application will always close the editor and that dirty files will never close to preserve your data.'),
                default: true,
            },
            'workbench.editor.openPositioning': {
                type: 'string',
                enum: ['left', 'right', 'first', 'last'],
                default: 'right',
                description: nls.localize({
                    comment: [
                        'This is the description for a setting. Values surrounded by single quotes are not to be translated.',
                    ],
                    key: 'editorOpenPositioning',
                }, "Controls where editors open. Select 'left' or 'right' to open editors to the left or right of the currently active one. Select 'first' or 'last' to open editors independently from the currently active one."),
            },
            'workbench.editor.openSideBySideDirection': {
                type: 'string',
                enum: ['right', 'down'],
                default: 'right',
                description: nls.localize('sideBySideDirection', 'Controls the default direction of editors that are opened side by side (e.g. from the explorer). By default, editors will open on the right hand side of the currently active one. If changed to open down, the editors will open below the currently active one.'),
            },
            'workbench.editor.closeEmptyGroups': {
                type: 'boolean',
                description: nls.localize('closeEmptyGroups', 'Controls the behavior of empty editor groups when the last tab in the group is closed. When enabled, empty groups will automatically close. When disabled, empty groups will remain part of the grid.'),
                default: true,
            },
            'workbench.editor.revealIfOpen': {
                type: 'boolean',
                description: nls.localize('revealIfOpen', 'Controls if an editor is revealed in any of the visible groups if opened. If disabled, an editor will prefer to open in the currently active editor group. If enabled, an already opened editor will be revealed instead of opened again in the currently active editor group. Note that there are some cases where this setting is ignored, e.g. when forcing an editor to open in a specific group or to the side of the currently active group.'),
                default: false,
            },
            'workbench.editor.swipeToNavigate': {
                type: 'boolean',
                description: nls.localize('swipeToNavigate', 'Navigate between open files using three-finger swipe horizontally.'),
                default: false,
                included: platform_2.isMacintosh,
            },
            'workbench.commandPalette.history': {
                type: 'number',
                description: nls.localize('commandHistory', 'Controls the number of recently used commands to keep in history for the command palette. Set to 0 to disable command history.'),
                default: 50,
            },
            'workbench.commandPalette.preserveInput': {
                type: 'boolean',
                description: nls.localize('preserveInput', 'Controls if the last typed input to the command palette should be restored when opening it the next time.'),
                default: false,
            },
            'workbench.quickOpen.closeOnFocusLost': {
                type: 'boolean',
                description: nls.localize('closeOnFocusLost', 'Controls if Quick Open should close automatically once it loses focus.'),
                default: true,
            },
            'workbench.settings.openDefaultSettings': {
                type: 'boolean',
                description: nls.localize('openDefaultSettings', 'Controls if opening settings also opens an editor showing all default settings.'),
                default: true,
            },
            'workbench.settings.openDefaultKeybindings': {
                type: 'boolean',
                description: nls.localize('openDefaultKeybindings', 'Controls if opening keybinding settings also opens an editor showing all default keybindings.'),
                default: true,
            },
            'workbench.sideBar.location': {
                type: 'string',
                enum: ['left', 'right'],
                default: 'left',
                description: nls.localize('sideBarLocation', 'Controls the location of the sidebar. It can either show on the left or right of the workbench.'),
            },
            'workbench.panel.defaultLocation': {
                type: 'string',
                enum: ['bottom', 'right'],
                default: 'bottom',
                description: nls.localize('panelDefaultLocation', 'Controls the default location of the panel (terminal, debug console, output, problems). It can either show at the bottom or on the right of the workbench.'),
            },
            'workbench.statusBar.visible': {
                type: 'boolean',
                default: true,
                description: nls.localize('statusBarVisibility', 'Controls the visibility of the status bar at the bottom of the workbench.'),
            },
            'workbench.activityBar.visible': {
                type: 'boolean',
                default: true,
                description: nls.localize('activityBarVisibility', 'Controls the visibility of the activity bar in the workbench.'),
            },
            'workbench.view.alwaysShowHeaderActions': {
                type: 'boolean',
                default: false,
                description: nls.localize('viewVisibility', 'Controls the visibility of view header actions. View header actions may either be always visible, or only visible when that view is focused or hovered over.'),
            },
            'workbench.fontAliasing': {
                type: 'string',
                enum: ['default', 'antialiased', 'none', 'auto'],
                default: 'default',
                description: nls.localize('fontAliasing', 'Controls font aliasing method in the workbench.\n- default: Sub-pixel font smoothing. On most non-retina displays this will give the sharpest text\n- antialiased: Smooth the font on the level of the pixel, as opposed to the subpixel. Can make the font appear lighter overall\n- none: Disables font smoothing. Text will show with jagged sharp edges\n- auto: Applies `default` or `antialiased` automatically based on the DPI of displays.'),
                enumDescriptions: [
                    nls.localize('workbench.fontAliasing.default', 'Sub-pixel font smoothing. On most non-retina displays this will give the sharpest text.'),
                    nls.localize('workbench.fontAliasing.antialiased', 'Smooth the font on the level of the pixel, as opposed to the subpixel. Can make the font appear lighter overall.'),
                    nls.localize('workbench.fontAliasing.none', 'Disables font smoothing. Text will show with jagged sharp edges.'),
                    nls.localize('workbench.fontAliasing.auto', 'Applies `default` or `antialiased` automatically based on the DPI of displays.'),
                ],
                included: platform_2.isMacintosh,
            },
            'workbench.settings.enableNaturalLanguageSearch': {
                type: 'boolean',
                description: nls.localize('enableNaturalLanguageSettingsSearch', 'Controls whether to enable the natural language search mode for settings.'),
                default: true,
                scope: 2 /* WINDOW */,
            },
            'workbench.settings.settingsSearchTocBehavior': {
                type: 'string',
                enum: ['hide', 'filter', 'show'],
                description: nls.localize('settingsSearchTocBehavior', 'Controls the behavior of the settings editor Table of Contents while searching.'),
                default: 'hide',
                scope: 2 /* WINDOW */,
            },
            'workbench.settings.tocVisible': {
                type: 'boolean',
                description: nls.localize('settingsTocVisible', 'Controls whether the settings editor Table of Contents is visible.'),
                default: true,
                scope: 2 /* WINDOW */,
            },
        },
    });
    // Configuration: Window
    configurationRegistry.registerConfiguration({
        id: 'window',
        order: 8,
        title: nls.localize('windowConfigurationTitle', 'Window'),
        type: 'object',
        properties: {
            'window.openFilesInNewWindow': {
                type: 'string',
                enum: ['on', 'off', 'default'],
                enumDescriptions: [
                    nls.localize('window.openFilesInNewWindow.on', 'Files will open in a new window'),
                    nls.localize('window.openFilesInNewWindow.off', "Files will open in the window with the files' folder open or the last active window"),
                    platform_2.isMacintosh
                        ? nls.localize('window.openFilesInNewWindow.defaultMac', "Files will open in the window with the files' folder open or the last active window unless opened via the Dock or from Finder")
                        : nls.localize('window.openFilesInNewWindow.default', 'Files will open in a new window unless picked from within the application (e.g. via the File menu)'),
                ],
                default: 'off',
                scope: 1 /* APPLICATION */,
                description: platform_2.isMacintosh
                    ? nls.localize('openFilesInNewWindowMac', "Controls if files should open in a new window.\n- default: files will open in the window with the files' folder open or the last active window unless opened via the Dock or from Finder\n- on: files will open in a new window\n- off: files will open in the window with the files' folder open or the last active window\nNote that there can still be cases where this setting is ignored (e.g. when using the -new-window or -reuse-window command line option).")
                    : nls.localize('openFilesInNewWindow', "Controls if files should open in a new window.\n- default: files will open in a new window unless picked from within the application (e.g. via the File menu)\n- on: files will open in a new window\n- off: files will open in the window with the files' folder open or the last active window\nNote that there can still be cases where this setting is ignored (e.g. when using the -new-window or -reuse-window command line option)."),
            },
            'window.openFoldersInNewWindow': {
                type: 'string',
                enum: ['on', 'off', 'default'],
                enumDescriptions: [
                    nls.localize('window.openFoldersInNewWindow.on', 'Folders will open in a new window'),
                    nls.localize('window.openFoldersInNewWindow.off', 'Folders will replace the last active window'),
                    nls.localize('window.openFoldersInNewWindow.default', 'Folders will open in a new window unless a folder is picked from within the application (e.g. via the File menu)'),
                ],
                default: 'default',
                scope: 1 /* APPLICATION */,
                description: nls.localize('openFoldersInNewWindow', 'Controls if folders should open in a new window or replace the last active window.\n- default: folders will open in a new window unless a folder is picked from within the application (e.g. via the File menu)\n- on: folders will open in a new window\n- off: folders will replace the last active window\nNote that there can still be cases where this setting is ignored (e.g. when using the -new-window or -reuse-window command line option).'),
            },
            'window.openWithoutArgumentsInNewWindow': {
                type: 'string',
                enum: ['on', 'off'],
                enumDescriptions: [
                    nls.localize('window.openWithoutArgumentsInNewWindow.on', 'Open a new empty window'),
                    nls.localize('window.openWithoutArgumentsInNewWindow.off', 'Focus the last active running instance'),
                ],
                default: platform_2.isMacintosh ? 'off' : 'on',
                scope: 1 /* APPLICATION */,
                description: nls.localize('openWithoutArgumentsInNewWindow', 'Controls if a new empty window should open when starting a second instance without arguments or if the last running instance should get focus.\n- on: open a new empty window\n- off: the last active running instance will get focus\nNote that there can still be cases where this setting is ignored (e.g. when using the -new-window or -reuse-window command line option).'),
            },
            'window.restoreWindows': {
                type: 'string',
                enum: ['all', 'folders', 'one', 'none'],
                enumDescriptions: [
                    nls.localize('window.reopenFolders.all', 'Reopen all windows.'),
                    nls.localize('window.reopenFolders.folders', 'Reopen all folders. Empty workspaces will not be restored.'),
                    nls.localize('window.reopenFolders.one', 'Reopen the last active window.'),
                    nls.localize('window.reopenFolders.none', 'Never reopen a window. Always start with an empty one.'),
                ],
                default: 'one',
                scope: 1 /* APPLICATION */,
                description: nls.localize('restoreWindows', "Controls how windows are being reopened after a restart. Select 'none' to always start with an empty workspace, 'one' to reopen the last window you worked on, 'folders' to reopen all windows that had folders opened or 'all' to reopen all windows of your last session."),
            },
            'window.restoreFullscreen': {
                type: 'boolean',
                default: false,
                scope: 1 /* APPLICATION */,
                description: nls.localize('restoreFullscreen', 'Controls if a window should restore to full screen mode if it was exited in full screen mode.'),
            },
            'window.zoomLevel': {
                type: 'number',
                default: 0,
                description: nls.localize('zoomLevel', 'Adjust the zoom level of the window. The original size is 0 and each increment above (e.g. 1) or below (e.g. -1) represents zooming 20% larger or smaller. You can also enter decimals to adjust the zoom level with a finer granularity.'),
            },
            'window.title': {
                type: 'string',
                default: platform_2.isMacintosh
                    ? '${activeEditorShort}${separator}${rootName}'
                    : '${dirty}${activeEditorShort}${separator}${rootName}${separator}${appName}',
                description: nls.localize({
                    comment: [
                        'This is the description for a setting. Values surrounded by parenthesis are not to be translated.',
                    ],
                    key: 'title',
                }, 'Controls the window title based on the active editor. Variables are substituted based on the context:\n${activeEditorShort}: the file name (e.g. myFile.txt)\n${activeEditorMedium}: the path of the file relative to the workspace folder (e.g. myFolder/myFile.txt)\n${activeEditorLong}: the full path of the file (e.g. /Users/Development/myProject/myFolder/myFile.txt)\n${folderName}: name of the workspace folder the file is contained in (e.g. myFolder)\n${folderPath}: file path of the workspace folder the file is contained in (e.g. /Users/Development/myFolder)\n${rootName}: name of the workspace (e.g. myFolder or myWorkspace)\n${rootPath}: file path of the workspace (e.g. /Users/Development/myWorkspace)\n${appName}: e.g. VS Code\n${dirty}: a dirty indicator if the active editor is dirty\n${separator}: a conditional separator (" - ") that only shows when surrounded by variables with values or static text'),
            },
            'window.newWindowDimensions': {
                type: 'string',
                enum: ['default', 'inherit', 'maximized', 'fullscreen'],
                enumDescriptions: [
                    nls.localize('window.newWindowDimensions.default', 'Open new windows in the center of the screen.'),
                    nls.localize('window.newWindowDimensions.inherit', 'Open new windows with same dimension as last active one.'),
                    nls.localize('window.newWindowDimensions.maximized', 'Open new windows maximized.'),
                    nls.localize('window.newWindowDimensions.fullscreen', 'Open new windows in full screen mode.'),
                ],
                default: 'default',
                scope: 1 /* APPLICATION */,
                description: nls.localize('newWindowDimensions', "Controls the dimensions of opening a new window when at least one window is already opened. By default, a new window will open in the center of the screen with small dimensions. When set to 'inherit', the window will get the same dimensions as the last window that was active. When set to 'maximized', the window will open maximized and fullscreen if configured to 'fullscreen'. Note that this setting does not have an impact on the first window that is opened. The first window will always restore the size and location as you left it before closing."),
            },
            'window.closeWhenEmpty': {
                type: 'boolean',
                default: false,
                description: nls.localize('closeWhenEmpty', 'Controls if closing the last editor should also close the window. This setting only applies for windows that do not show folders.'),
            },
            'window.menuBarVisibility': {
                type: 'string',
                enum: ['default', 'visible', 'toggle', 'hidden'],
                enumDescriptions: [
                    nls.localize('window.menuBarVisibility.default', 'Menu is only hidden in full screen mode.'),
                    nls.localize('window.menuBarVisibility.visible', 'Menu is always visible even in full screen mode.'),
                    nls.localize('window.menuBarVisibility.toggle', 'Menu is hidden but can be displayed via Alt key.'),
                    nls.localize('window.menuBarVisibility.hidden', 'Menu is always hidden.'),
                ],
                default: 'default',
                scope: 1 /* APPLICATION */,
                description: nls.localize('menuBarVisibility', "Control the visibility of the menu bar. A setting of 'toggle' means that the menu bar is hidden and a single press of the Alt key will show it. By default, the menu bar will be visible, unless the window is full screen."),
                included: platform_2.isWindows || platform_2.isLinux,
            },
            'window.enableMenuBarMnemonics': {
                type: 'boolean',
                default: true,
                scope: 1 /* APPLICATION */,
                description: nls.localize('enableMenuBarMnemonics', 'If enabled, the main menus can be opened via Alt-key shortcuts. Disabling mnemonics allows to bind these Alt-key shortcuts to editor commands instead.'),
                included: platform_2.isWindows || platform_2.isLinux,
            },
            'window.autoDetectHighContrast': {
                type: 'boolean',
                default: true,
                description: nls.localize('autoDetectHighContrast', 'If enabled, will automatically change to high contrast theme if Windows is using a high contrast theme, and to dark theme when switching away from a Windows high contrast theme.'),
                included: platform_2.isWindows,
            },
            'window.titleBarStyle': {
                type: 'string',
                enum: ['native', 'custom'],
                default: platform_2.isMacintosh ? 'custom' : 'native',
                scope: 1 /* APPLICATION */,
                description: nls.localize('titleBarStyle', 'Adjust the appearance of the window title bar. Changes require a full restart to apply.'),
            },
            'window.nativeTabs': {
                type: 'boolean',
                default: false,
                scope: 1 /* APPLICATION */,
                description: nls.localize('window.nativeTabs', 'Enables macOS Sierra window tabs. Note that changes require a full restart to apply and that native tabs will disable a custom title bar style if configured.'),
                included: false,
            },
            'window.smoothScrollingWorkaround': {
                type: 'boolean',
                default: false,
                scope: 1 /* APPLICATION */,
                description: nls.localize('window.smoothScrollingWorkaround', "Enable this workaround if scrolling is no longer smooth after restoring a minimized VS Code window. This is a workaround for an issue (https://github.com/Microsoft/vscode/issues/13612) where scrolling starts to lag on devices with precision trackpads like the Surface devices from Microsoft. Enabling this workaround can result in a little bit of layout flickering after restoring the window from minimized state but is otherwise harmless. Note: in order for this workaround to function, make sure to also set 'window.titleBarStyle: native'."),
                included: platform_2.isWindows,
            },
            'window.clickThroughInactive': {
                type: 'boolean',
                default: true,
                scope: 1 /* APPLICATION */,
                description: nls.localize('window.clickThroughInactive', 'If enabled, clicking on an inactive window will both activate the window and trigger the element under the mouse if it is clickable. If disabled, clicking anywhere on an inactive window will activate it only and a second click is required on the element.'),
                included: platform_2.isMacintosh,
            },
        },
    });
    // Configuration: Zen Mode
    configurationRegistry.registerConfiguration({
        id: 'zenMode',
        order: 9,
        title: nls.localize('zenModeConfigurationTitle', 'Zen Mode'),
        type: 'object',
        properties: {
            'zenMode.fullScreen': {
                type: 'boolean',
                default: true,
                description: nls.localize('zenMode.fullScreen', 'Controls if turning on Zen Mode also puts the workbench into full screen mode.'),
            },
            'zenMode.centerLayout': {
                type: 'boolean',
                default: true,
                description: nls.localize('zenMode.centerLayout', 'Controls if turning on Zen Mode also centers the layout.'),
            },
            'zenMode.hideTabs': {
                type: 'boolean',
                default: true,
                description: nls.localize('zenMode.hideTabs', 'Controls if turning on Zen Mode also hides workbench tabs.'),
            },
            'zenMode.hideStatusBar': {
                type: 'boolean',
                default: true,
                description: nls.localize('zenMode.hideStatusBar', 'Controls if turning on Zen Mode also hides the status bar at the bottom of the workbench.'),
            },
            'zenMode.hideActivityBar': {
                type: 'boolean',
                default: true,
                description: nls.localize('zenMode.hideActivityBar', 'Controls if turning on Zen Mode also hides the activity bar at the left of the workbench.'),
            },
            'zenMode.restore': {
                type: 'boolean',
                default: false,
                description: nls.localize('zenMode.restore', 'Controls if a window should restore to zen mode if it was exited in zen mode.'),
            },
        },
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[403/*vs/platform/search/common/replace*/], __M([0/*require*/,1/*exports*/,22/*vs/base/common/strings*/]), function (require, exports, strings) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReplacePattern = /** @class */ (function () {
        function ReplacePattern(replaceString, arg2, arg3) {
            this._hasParameters = false;
            this._replacePattern = replaceString;
            var searchPatternInfo;
            var parseParameters;
            if (typeof arg2 === 'boolean') {
                parseParameters = arg2;
            }
            else {
                searchPatternInfo = arg2;
                parseParameters = searchPatternInfo.isRegExp;
            }
            if (parseParameters) {
                this.parseReplaceString(replaceString);
            }
            this._regExp = arg3 ? arg3 : strings.createRegExp(searchPatternInfo.pattern, searchPatternInfo.isRegExp, { matchCase: searchPatternInfo.isCaseSensitive, wholeWord: searchPatternInfo.isWordMatch, multiline: searchPatternInfo.isMultiline, global: false });
            if (this._regExp.global) {
                this._regExp = strings.createRegExp(this._regExp.source, true, { matchCase: !this._regExp.ignoreCase, wholeWord: false, multiline: this._regExp.multiline, global: false });
            }
        }
        Object.defineProperty(ReplacePattern.prototype, "hasParameters", {
            get: function () {
                return this._hasParameters;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReplacePattern.prototype, "pattern", {
            get: function () {
                return this._replacePattern;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReplacePattern.prototype, "regExp", {
            get: function () {
                return this._regExp;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Returns the replace string for the first match in the given text.
        * If text has no matches then returns null.
        */
        ReplacePattern.prototype.getReplaceString = function (text) {
            this._regExp.lastIndex = 0;
            var match = this._regExp.exec(text);
            if (match) {
                if (this.hasParameters) {
                    if (match[0] === text) {
                        return text.replace(this._regExp, this.pattern);
                    }
                    var replaceString = text.replace(this._regExp, this.pattern);
                    return replaceString.substr(match.index, match[0].length - (text.length - replaceString.length));
                }
                return this.pattern;
            }
            return null;
        };
        /**
         * \n => LF
         * \t => TAB
         * \\ => \
         * $0 => $& (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)
         * everything else stays untouched
         */
        ReplacePattern.prototype.parseReplaceString = function (replaceString) {
            if (!replaceString || replaceString.length === 0) {
                return;
            }
            var substrFrom = 0, result = '';
            for (var i = 0, len = replaceString.length; i < len; i++) {
                var chCode = replaceString.charCodeAt(i);
                if (chCode === 92 /* Backslash */) {
                    // move to next char
                    i++;
                    if (i >= len) {
                        // string ends with a \
                        break;
                    }
                    var nextChCode = replaceString.charCodeAt(i);
                    var replaceWithCharacter = null;
                    switch (nextChCode) {
                        case 92 /* Backslash */:
                            // \\ => \
                            replaceWithCharacter = '\\';
                            break;
                        case 110 /* n */:
                            // \n => LF
                            replaceWithCharacter = '\n';
                            break;
                        case 116 /* t */:
                            // \t => TAB
                            replaceWithCharacter = '\t';
                            break;
                    }
                    if (replaceWithCharacter) {
                        result += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;
                        substrFrom = i + 1;
                    }
                }
                if (chCode === 36 /* DollarSign */) {
                    // move to next char
                    i++;
                    if (i >= len) {
                        // string ends with a $
                        break;
                    }
                    var nextChCode = replaceString.charCodeAt(i);
                    var replaceWithCharacter = null;
                    switch (nextChCode) {
                        case 48 /* Digit0 */:
                            // $0 => $&
                            replaceWithCharacter = '$&';
                            this._hasParameters = true;
                            break;
                        case 96 /* BackTick */:
                        case 39 /* SingleQuote */:
                            this._hasParameters = true;
                            break;
                        default:
                            // check if it is a valid string parameter $n (0 <= n <= 99). $0 is already handled by now.
                            if (!this.between(nextChCode, 49 /* Digit1 */, 57 /* Digit9 */)) {
                                break;
                            }
                            if (i === replaceString.length - 1) {
                                this._hasParameters = true;
                                break;
                            }
                            var charCode = replaceString.charCodeAt(++i);
                            if (!this.between(charCode, 48 /* Digit0 */, 57 /* Digit9 */)) {
                                this._hasParameters = true;
                                --i;
                                break;
                            }
                            if (i === replaceString.length - 1) {
                                this._hasParameters = true;
                                break;
                            }
                            charCode = replaceString.charCodeAt(++i);
                            if (!this.between(charCode, 48 /* Digit0 */, 57 /* Digit9 */)) {
                                this._hasParameters = true;
                                --i;
                                break;
                            }
                            break;
                    }
                    if (replaceWithCharacter) {
                        result += replaceString.substring(substrFrom, i - 1) + replaceWithCharacter;
                        substrFrom = i + 1;
                    }
                }
            }
            if (substrFrom === 0) {
                // no replacement occurred
                return;
            }
            this._replacePattern = result + replaceString.substring(substrFrom);
        };
        ReplacePattern.prototype.between = function (value, from, to) {
            return from <= value && value <= to;
        };
        return ReplacePattern;
    }());
    exports.ReplacePattern = ReplacePattern;
});

define(__m[71/*vs/platform/search/common/search*/], __M([0/*require*/,1/*exports*/,142/*vs/base/common/glob*/,38/*vs/base/common/objects*/,24/*vs/base/common/paths*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, glob, objects, paths, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VIEW_ID = 'workbench.view.search';
    exports.ISearchHistoryService = instantiation_1.createDecorator('searchHistoryService');
    exports.ISearchService = instantiation_1.createDecorator('searchService');
    var FileMatch = /** @class */ (function () {
        function FileMatch(resource) {
            this.resource = resource;
            this.matches = [];
            // empty
        }
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var TextSearchResult = /** @class */ (function () {
        function TextSearchResult(fullLine, range, previewOptions) {
            this.range = range;
            if (previewOptions) {
                var leadingChars = Math.floor(previewOptions.charsPerLine / 5);
                var previewStart = Math.max(range.startColumn - leadingChars, 0);
                var previewEnd = previewOptions.charsPerLine + previewStart;
                var endOfMatchRangeInPreview = Math.min(previewEnd, range.endColumn - previewStart);
                this.preview = {
                    text: fullLine.substring(previewStart, previewEnd),
                    match: new OneLineRange(0, range.startColumn - previewStart, endOfMatchRangeInPreview)
                };
            }
            else {
                this.preview = {
                    text: fullLine,
                    match: new OneLineRange(0, range.startColumn, range.endColumn)
                };
            }
        }
        return TextSearchResult;
    }());
    exports.TextSearchResult = TextSearchResult;
    var OneLineRange = /** @class */ (function () {
        function OneLineRange(lineNumber, startColumn, endColumn) {
            this.startLineNumber = lineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = lineNumber;
            this.endColumn = endColumn;
        }
        return OneLineRange;
    }());
    exports.OneLineRange = OneLineRange;
    function getExcludes(configuration) {
        var fileExcludes = configuration && configuration.files && configuration.files.exclude;
        var searchExcludes = configuration && configuration.search && configuration.search.exclude;
        if (!fileExcludes && !searchExcludes) {
            return undefined;
        }
        if (!fileExcludes || !searchExcludes) {
            return fileExcludes || searchExcludes;
        }
        var allExcludes = Object.create(null);
        // clone the config as it could be frozen
        allExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));
        allExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);
        return allExcludes;
    }
    exports.getExcludes = getExcludes;
    function pathIncludedInQuery(query, fsPath) {
        if (query.excludePattern && glob.match(query.excludePattern, fsPath)) {
            return false;
        }
        if (query.includePattern && !glob.match(query.includePattern, fsPath)) {
            return false;
        }
        // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present
        if (query.usingSearchPaths) {
            return query.folderQueries.every(function (fq) {
                var searchPath = fq.folder.fsPath;
                if (paths.isEqualOrParent(fsPath, searchPath)) {
                    return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);
                }
                else {
                    return false;
                }
            });
        }
        return true;
    }
    exports.pathIncludedInQuery = pathIncludedInQuery;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[209/*vs/platform/statusbar/common/statusbar*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStatusbarService = instantiation_1.createDecorator('statusbarService');
});










define(__m[421/*vs/codesandbox/lifecycleService*/], __M([0/*require*/,1/*exports*/,63/*vs/platform/lifecycle/common/lifecycle*/,44/*vs/platform/storage/common/storage*/,6/*vs/base/common/event*/,237/*vs/base/common/performance*/,17/*vs/base/common/async*/,86/*vs/platform/log/common/log*/]), function (require, exports, lifecycle_1, storage_1, event_1, performance_1, async_1, log_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxLifecycleService = /** @class */ (function () {
        function CodeSandboxLifecycleService(_storageService, _logService) {
            this._storageService = _storageService;
            this._logService = _logService;
            this._onWillShutdown = new event_1.Emitter();
            this._onShutdown = new event_1.Emitter();
            this._phase = 1 /* Starting */;
            this._phaseWhen = new Map();
            var lastShutdownReason = this._storageService.getInteger(CodeSandboxLifecycleService._lastShutdownReasonKey, 1 /* WORKSPACE */);
            this._storageService.remove(CodeSandboxLifecycleService._lastShutdownReasonKey, 1 /* WORKSPACE */);
            if (lastShutdownReason === 3 /* RELOAD */) {
                this._startupKind = 3 /* ReloadedWindow */;
            }
            else if (lastShutdownReason === 4 /* LOAD */) {
                this._startupKind = 4 /* ReopenedWindow */;
            }
            else {
                this._startupKind = 1 /* NewWindow */;
            }
            this._logService.trace("lifecycle: starting up (startup kind: " + this._startupKind + ")");
            this._registerListeners();
        }
        CodeSandboxLifecycleService.prototype._registerListeners = function () {
            // const windowId = this._windowService.getCurrentWindowId();
            // // Main side indicates that window is about to unload, check for vetos
            // ipc.on('vscode:onBeforeUnload', (event, reply: { okChannel: string, cancelChannel: string, reason: ShutdownReason }) => {
            // 	this._logService.trace(`lifecycle: onBeforeUnload (reason: ${reply.reason})`);
            // 	// store shutdown reason to retrieve next startup
            // 	this._storageService.store(CodeSandboxLifecycleService._lastShutdownReasonKey, JSON.stringify(reply.reason), StorageScope.WORKSPACE);
            // 	// trigger onWillShutdown events and veto collecting
            // 	this.onBeforeUnload(reply.reason).then(veto => {
            // 		if (veto) {
            // 			this._logService.trace('lifecycle: onBeforeUnload prevented via veto');
            // 			this._storageService.remove(CodeSandboxLifecycleService._lastShutdownReasonKey, StorageScope.WORKSPACE);
            // 			ipc.send(reply.cancelChannel, windowId);
            // 		} else {
            // 			this._logService.trace('lifecycle: onBeforeUnload continues without veto');
            // 			ipc.send(reply.okChannel, windowId);
            // 		}
            // 	});
            // });
            // // Main side indicates that we will indeed shutdown
            // ipc.on('vscode:onWillUnload', (event, reply: { replyChannel: string, reason: ShutdownReason }) => {
            // 	this._logService.trace(`lifecycle: onWillUnload (reason: ${reply.reason})`);
            // 	this._onShutdown.fire(reply.reason);
            // 	ipc.send(reply.replyChannel, windowId);
            // });
        };
        Object.defineProperty(CodeSandboxLifecycleService.prototype, "phase", {
            // private onBeforeUnload(reason: ShutdownReason): TPromise<boolean> {
            // 	const vetos: (boolean | Thenable<boolean>)[] = [];
            // 	this._onWillShutdown.fire({
            // 		veto(value) {
            // 			vetos.push(value);
            // 		},
            // 		reason
            // 	});
            // 	return handleVetos(vetos, err => this._notificationService.error(toErrorMessage(err)));
            // }
            get: function () {
                return this._phase;
            },
            set: function (value) {
                if (value < this.phase) {
                    throw new Error('Lifecycle cannot go backwards');
                }
                if (this._phase === value) {
                    return;
                }
                this._logService.trace("lifecycle: phase changed (value: " + value + ")");
                this._phase = value;
                performance_1.mark("LifecyclePhase/" + lifecycle_1.LifecyclePhaseToString(value));
                if (this._phaseWhen.has(this._phase)) {
                    this._phaseWhen.get(this._phase).open();
                    this._phaseWhen.delete(this._phase);
                }
            },
            enumerable: true,
            configurable: true
        });
        CodeSandboxLifecycleService.prototype.when = function (phase) {
            if (phase <= this._phase) {
                return Promise.resolve();
            }
            var barrier = this._phaseWhen.get(phase);
            if (!barrier) {
                barrier = new async_1.Barrier();
                this._phaseWhen.set(phase, barrier);
            }
            return barrier.wait();
        };
        Object.defineProperty(CodeSandboxLifecycleService.prototype, "startupKind", {
            get: function () {
                return this._startupKind;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxLifecycleService.prototype, "onWillShutdown", {
            get: function () {
                return this._onWillShutdown.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxLifecycleService.prototype, "onShutdown", {
            get: function () {
                return this._onShutdown.event;
            },
            enumerable: true,
            configurable: true
        });
        CodeSandboxLifecycleService._lastShutdownReasonKey = 'lifecyle.lastShutdownReason';
        CodeSandboxLifecycleService = __decorate([
            __param(0, storage_1.IStorageService),
            __param(1, log_1.ILogService)
        ], CodeSandboxLifecycleService);
        return CodeSandboxLifecycleService;
    }());
    exports.CodeSandboxLifecycleService = CodeSandboxLifecycleService;
});

define(__m[238/*vs/platform/storage/common/storageService*/], __M([0/*require*/,1/*exports*/,29/*vs/base/common/types*/,25/*vs/base/common/errors*/,22/*vs/base/common/strings*/,237/*vs/base/common/performance*/]), function (require, exports, types, errors, strings, perf) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var StorageService = /** @class */ (function () {
        function StorageService(globalStorage, workspaceStorage, workspaceId, legacyWorkspaceId) {
            this._globalStorage = globalStorage;
            this._workspaceStorage = workspaceStorage || globalStorage;
            this.setWorkspaceId(workspaceId, legacyWorkspaceId);
        }
        Object.defineProperty(StorageService.prototype, "workspaceId", {
            get: function () {
                return this._workspaceId;
            },
            enumerable: true,
            configurable: true
        });
        StorageService.prototype.setWorkspaceId = function (workspaceId, legacyWorkspaceId) {
            this._workspaceId = workspaceId;
            // Calculate workspace storage key
            this.workspaceKey = this.getWorkspaceKey(workspaceId);
            // Make sure to delete all workspace storage if the workspace has been recreated meanwhile
            // which is only possible if a id property is provided that we can check on
            if (types.isNumber(legacyWorkspaceId)) {
                this.cleanupWorkspaceScope(legacyWorkspaceId);
            }
        };
        Object.defineProperty(StorageService.prototype, "globalStorage", {
            get: function () {
                return this._globalStorage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StorageService.prototype, "workspaceStorage", {
            get: function () {
                return this._workspaceStorage;
            },
            enumerable: true,
            configurable: true
        });
        StorageService.prototype.getWorkspaceKey = function (id) {
            if (!id) {
                return StorageService.NO_WORKSPACE_IDENTIFIER;
            }
            // Special case file:// URIs: strip protocol from key to produce shorter key
            var fileProtocol = 'file:///';
            if (id.indexOf(fileProtocol) === 0) {
                id = id.substr(fileProtocol.length);
            }
            // Always end with "/"
            return strings.rtrim(id, '/') + "/";
        };
        StorageService.prototype.cleanupWorkspaceScope = function (workspaceUid) {
            var _this = this;
            // Get stored identifier from storage
            perf.mark('willReadWorkspaceIdentifier');
            var id = this.getInteger(StorageService.WORKSPACE_IDENTIFIER, 1 /* WORKSPACE */);
            perf.mark('didReadWorkspaceIdentifier');
            // If identifier differs, assume the workspace got recreated and thus clean all storage for this workspace
            if (types.isNumber(id) && workspaceUid !== id) {
                var keyPrefix = this.toStorageKey('', 1 /* WORKSPACE */);
                var toDelete = [];
                var length_1 = this._workspaceStorage.length;
                for (var i = 0; i < length_1; i++) {
                    var key = this._workspaceStorage.key(i);
                    if (key.indexOf(StorageService.WORKSPACE_PREFIX) < 0) {
                        continue; // ignore stored things that don't belong to storage service or are defined globally
                    }
                    // Check for match on prefix
                    if (key.indexOf(keyPrefix) === 0) {
                        toDelete.push(key);
                    }
                }
                // Run the delete
                toDelete.forEach(function (keyToDelete) {
                    _this._workspaceStorage.removeItem(keyToDelete);
                });
            }
            // Store workspace identifier now
            if (workspaceUid !== id) {
                this.store(StorageService.WORKSPACE_IDENTIFIER, workspaceUid, 1 /* WORKSPACE */);
            }
        };
        StorageService.prototype.store = function (key, value, scope) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            var storage = (scope === 0 /* GLOBAL */) ? this._globalStorage : this._workspaceStorage;
            if (types.isUndefinedOrNull(value)) {
                this.remove(key, scope); // we cannot store null or undefined, in that case we remove the key
                return;
            }
            var storageKey = this.toStorageKey(key, scope);
            // Store
            try {
                storage.setItem(storageKey, value);
            }
            catch (error) {
                errors.onUnexpectedError(error);
            }
        };
        StorageService.prototype.get = function (key, scope, defaultValue) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            var storage = (scope === 0 /* GLOBAL */) ? this._globalStorage : this._workspaceStorage;
            var value = storage.getItem(this.toStorageKey(key, scope));
            if (types.isUndefinedOrNull(value)) {
                return defaultValue;
            }
            return value;
        };
        StorageService.prototype.getInteger = function (key, scope, defaultValue) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            var value = this.get(key, scope, defaultValue);
            if (types.isUndefinedOrNull(value)) {
                return defaultValue;
            }
            return parseInt(value, 10);
        };
        StorageService.prototype.getBoolean = function (key, scope, defaultValue) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            var value = this.get(key, scope, defaultValue);
            if (types.isUndefinedOrNull(value)) {
                return defaultValue;
            }
            if (types.isString(value)) {
                return value.toLowerCase() === 'true' ? true : false;
            }
            return value ? true : false;
        };
        StorageService.prototype.remove = function (key, scope) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            var storage = (scope === 0 /* GLOBAL */) ? this._globalStorage : this._workspaceStorage;
            var storageKey = this.toStorageKey(key, scope);
            // Remove
            storage.removeItem(storageKey);
        };
        StorageService.prototype.toStorageKey = function (key, scope) {
            if (scope === 0 /* GLOBAL */) {
                return StorageService.GLOBAL_PREFIX + key.toLowerCase();
            }
            return StorageService.WORKSPACE_PREFIX + this.workspaceKey + key.toLowerCase();
        };
        StorageService.COMMON_PREFIX = 'storage://';
        StorageService.GLOBAL_PREFIX = StorageService.COMMON_PREFIX + "global/";
        StorageService.WORKSPACE_PREFIX = StorageService.COMMON_PREFIX + "workspace/";
        StorageService.WORKSPACE_IDENTIFIER = 'workspaceidentifier';
        StorageService.NO_WORKSPACE_IDENTIFIER = '__$noWorkspace__';
        return StorageService;
    }());
    exports.StorageService = StorageService;
    var InMemoryLocalStorage = /** @class */ (function () {
        function InMemoryLocalStorage() {
            this.store = {};
        }
        Object.defineProperty(InMemoryLocalStorage.prototype, "length", {
            get: function () {
                return Object.keys(this.store).length;
            },
            enumerable: true,
            configurable: true
        });
        InMemoryLocalStorage.prototype.key = function (index) {
            var keys = Object.keys(this.store);
            if (keys.length > index) {
                return keys[index];
            }
            return null;
        };
        InMemoryLocalStorage.prototype.setItem = function (key, value) {
            this.store[key] = value.toString();
        };
        InMemoryLocalStorage.prototype.getItem = function (key) {
            var item = this.store[key];
            if (!types.isUndefinedOrNull(item)) {
                return item;
            }
            return null;
        };
        InMemoryLocalStorage.prototype.removeItem = function (key) {
            delete this.store[key];
        };
        return InMemoryLocalStorage;
    }());
    exports.InMemoryLocalStorage = InMemoryLocalStorage;
    exports.inMemoryLocalStorageInstance = new InMemoryLocalStorage();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[239/*vs/editor/contrib/indentation/indentation*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,4/*vs/base/common/lifecycle*/,22/*vs/base/common/strings*/,114/*vs/editor/common/editorContextKeys*/,56/*vs/editor/browser/editorExtensions*/,36/*vs/editor/common/services/modelService*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,89/*vs/editor/common/core/editOperation*/,73/*vs/editor/common/model/textModel*/,485/*vs/editor/common/modes/languageConfigurationRegistry*/,484/*vs/editor/common/commands/shiftCommand*/,483/*vs/editor/contrib/indentation/indentUtils*/,62/*vs/platform/quickinput/common/quickInput*/]), function (require, exports, nls, lifecycle_1, strings, editorContextKeys_1, editorExtensions_1, modelService_1, range_1, selection_1, editOperation_1, textModel_1, languageConfigurationRegistry_1, shiftCommand_1, IndentUtil, quickInput_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function shiftIndent(tabSize, indentation, count) {
        count = count || 1;
        var desiredIndentCount = shiftCommand_1.ShiftCommand.shiftIndentCount(indentation, indentation.length + count, tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    }
    exports.shiftIndent = shiftIndent;
    function unshiftIndent(tabSize, indentation, count) {
        count = count || 1;
        var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + count, tabSize);
        var newIndentation = '';
        for (var i = 0; i < desiredIndentCount; i++) {
            newIndentation += '\t';
        }
        return newIndentation;
    }
    exports.unshiftIndent = unshiftIndent;
    function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {
        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
            // Model is empty
            return undefined;
        }
        var indentationRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);
        if (!indentationRules) {
            return undefined;
        }
        endLineNumber = Math.min(endLineNumber, model.getLineCount());
        // Skip `unIndentedLinePattern` lines
        while (startLineNumber <= endLineNumber) {
            if (!indentationRules.unIndentedLinePattern) {
                break;
            }
            var text = model.getLineContent(startLineNumber);
            if (!indentationRules.unIndentedLinePattern.test(text)) {
                break;
            }
            startLineNumber++;
        }
        if (startLineNumber > endLineNumber - 1) {
            return undefined;
        }
        var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
        var indentEdits = [];
        // indentation being passed to lines below
        var globalIndent;
        // Calculate indentation for the first line
        // If there is no passed-in indentation, we use the indentation of the first line as base.
        var currentLineText = model.getLineContent(startLineNumber);
        var adjustedLineContent = currentLineText;
        if (inheritedIndent !== undefined && inheritedIndent !== null) {
            globalIndent = inheritedIndent;
            var oldIndentation = strings.getLeadingWhitespace(currentLineText);
            adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
            if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
                globalIndent = unshiftIndent(tabSize, globalIndent);
                adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
            }
            if (currentLineText !== adjustedLineContent) {
                indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(globalIndent, tabSize, insertSpaces)));
            }
        }
        else {
            globalIndent = strings.getLeadingWhitespace(currentLineText);
        }
        // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.
        var idealIndentForNextLine = globalIndent;
        if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
            idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
            globalIndent = shiftIndent(tabSize, globalIndent);
        }
        else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
            idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
        }
        startLineNumber++;
        // Calculate indentation adjustment for all following lines
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            var text = model.getLineContent(lineNumber);
            var oldIndentation = strings.getLeadingWhitespace(text);
            var adjustedLineContent_1 = idealIndentForNextLine + text.substring(oldIndentation.length);
            if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent_1)) {
                idealIndentForNextLine = unshiftIndent(tabSize, idealIndentForNextLine);
                globalIndent = unshiftIndent(tabSize, globalIndent);
            }
            if (oldIndentation !== idealIndentForNextLine) {
                indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(idealIndentForNextLine, tabSize, insertSpaces)));
            }
            // calculate idealIndentForNextLine
            if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
                // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines
                // but don't change globalIndent and idealIndentForNextLine.
                continue;
            }
            else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent_1)) {
                globalIndent = shiftIndent(tabSize, globalIndent);
                idealIndentForNextLine = globalIndent;
            }
            else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent_1)) {
                idealIndentForNextLine = shiftIndent(tabSize, idealIndentForNextLine);
            }
            else {
                idealIndentForNextLine = globalIndent;
            }
        }
        return indentEdits;
    }
    exports.getReindentEditOperations = getReindentEditOperations;
    var IndentationToSpacesAction = /** @class */ (function (_super) {
        __extends(IndentationToSpacesAction, _super);
        function IndentationToSpacesAction() {
            return _super.call(this, {
                id: IndentationToSpacesAction.ID,
                label: nls.localize('indentationToSpaces', "Convert Indentation to Spaces"),
                alias: 'Convert Indentation to Spaces',
                precondition: editorContextKeys_1.EditorContextKeys.writable
            }) || this;
        }
        IndentationToSpacesAction.prototype.run = function (accessor, editor) {
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var modelOpts = model.getOptions();
            var command = new IndentationToSpacesCommand(editor.getSelection(), modelOpts.tabSize);
            editor.pushUndoStop();
            editor.executeCommands(this.id, [command]);
            editor.pushUndoStop();
            model.updateOptions({
                insertSpaces: true
            });
        };
        IndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';
        return IndentationToSpacesAction;
    }(editorExtensions_1.EditorAction));
    exports.IndentationToSpacesAction = IndentationToSpacesAction;
    var IndentationToTabsAction = /** @class */ (function (_super) {
        __extends(IndentationToTabsAction, _super);
        function IndentationToTabsAction() {
            return _super.call(this, {
                id: IndentationToTabsAction.ID,
                label: nls.localize('indentationToTabs', "Convert Indentation to Tabs"),
                alias: 'Convert Indentation to Tabs',
                precondition: editorContextKeys_1.EditorContextKeys.writable
            }) || this;
        }
        IndentationToTabsAction.prototype.run = function (accessor, editor) {
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var modelOpts = model.getOptions();
            var command = new IndentationToTabsCommand(editor.getSelection(), modelOpts.tabSize);
            editor.pushUndoStop();
            editor.executeCommands(this.id, [command]);
            editor.pushUndoStop();
            model.updateOptions({
                insertSpaces: false
            });
        };
        IndentationToTabsAction.ID = 'editor.action.indentationToTabs';
        return IndentationToTabsAction;
    }(editorExtensions_1.EditorAction));
    exports.IndentationToTabsAction = IndentationToTabsAction;
    var ChangeIndentationSizeAction = /** @class */ (function (_super) {
        __extends(ChangeIndentationSizeAction, _super);
        function ChangeIndentationSizeAction(insertSpaces, opts) {
            var _this = _super.call(this, opts) || this;
            _this.insertSpaces = insertSpaces;
            return _this;
        }
        ChangeIndentationSizeAction.prototype.run = function (accessor, editor) {
            var _this = this;
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            var modelService = accessor.get(modelService_1.IModelService);
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
            var picks = [1, 2, 3, 4, 5, 6, 7, 8].map(function (n) { return ({
                id: n.toString(),
                label: n.toString(),
                // add description for tabSize value set in the configuration
                description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', "Configured Tab Size") : null
            }); });
            // auto focus the tabSize set for the current editor
            var autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
            setTimeout(function () {
                quickInputService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then(function (pick) {
                    if (pick) {
                        model.updateOptions({
                            tabSize: parseInt(pick.label, 10),
                            insertSpaces: _this.insertSpaces
                        });
                    }
                });
            }, 50 /* quick open is sensitive to being opened so soon after another */);
        };
        return ChangeIndentationSizeAction;
    }(editorExtensions_1.EditorAction));
    exports.ChangeIndentationSizeAction = ChangeIndentationSizeAction;
    var IndentUsingTabs = /** @class */ (function (_super) {
        __extends(IndentUsingTabs, _super);
        function IndentUsingTabs() {
            return _super.call(this, false, {
                id: IndentUsingTabs.ID,
                label: nls.localize('indentUsingTabs', "Indent Using Tabs"),
                alias: 'Indent Using Tabs',
                precondition: null
            }) || this;
        }
        IndentUsingTabs.ID = 'editor.action.indentUsingTabs';
        return IndentUsingTabs;
    }(ChangeIndentationSizeAction));
    exports.IndentUsingTabs = IndentUsingTabs;
    var IndentUsingSpaces = /** @class */ (function (_super) {
        __extends(IndentUsingSpaces, _super);
        function IndentUsingSpaces() {
            return _super.call(this, true, {
                id: IndentUsingSpaces.ID,
                label: nls.localize('indentUsingSpaces', "Indent Using Spaces"),
                alias: 'Indent Using Spaces',
                precondition: null
            }) || this;
        }
        IndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';
        return IndentUsingSpaces;
    }(ChangeIndentationSizeAction));
    exports.IndentUsingSpaces = IndentUsingSpaces;
    var DetectIndentation = /** @class */ (function (_super) {
        __extends(DetectIndentation, _super);
        function DetectIndentation() {
            return _super.call(this, {
                id: DetectIndentation.ID,
                label: nls.localize('detectIndentation', "Detect Indentation from Content"),
                alias: 'Detect Indentation from Content',
                precondition: null
            }) || this;
        }
        DetectIndentation.prototype.run = function (accessor, editor) {
            var modelService = accessor.get(modelService_1.IModelService);
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
            model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
        };
        DetectIndentation.ID = 'editor.action.detectIndentation';
        return DetectIndentation;
    }(editorExtensions_1.EditorAction));
    exports.DetectIndentation = DetectIndentation;
    var ReindentLinesAction = /** @class */ (function (_super) {
        __extends(ReindentLinesAction, _super);
        function ReindentLinesAction() {
            return _super.call(this, {
                id: 'editor.action.reindentlines',
                label: nls.localize('editor.reindentlines', "Reindent Lines"),
                alias: 'Reindent Lines',
                precondition: editorContextKeys_1.EditorContextKeys.writable
            }) || this;
        }
        ReindentLinesAction.prototype.run = function (accessor, editor) {
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var edits = getReindentEditOperations(model, 1, model.getLineCount());
            if (edits) {
                editor.pushUndoStop();
                editor.executeEdits(this.id, edits);
                editor.pushUndoStop();
            }
        };
        return ReindentLinesAction;
    }(editorExtensions_1.EditorAction));
    exports.ReindentLinesAction = ReindentLinesAction;
    var ReindentSelectedLinesAction = /** @class */ (function (_super) {
        __extends(ReindentSelectedLinesAction, _super);
        function ReindentSelectedLinesAction() {
            return _super.call(this, {
                id: 'editor.action.reindentselectedlines',
                label: nls.localize('editor.reindentselectedlines', "Reindent Selected Lines"),
                alias: 'Reindent Selected Lines',
                precondition: editorContextKeys_1.EditorContextKeys.writable
            }) || this;
        }
        ReindentSelectedLinesAction.prototype.run = function (accessor, editor) {
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var edits = [];
            for (var _i = 0, _a = editor.getSelections(); _i < _a.length; _i++) {
                var selection = _a[_i];
                var startLineNumber = selection.startLineNumber;
                var endLineNumber = selection.endLineNumber;
                if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
                    endLineNumber--;
                }
                if (startLineNumber === 1) {
                    if (startLineNumber === endLineNumber) {
                        continue;
                    }
                }
                else {
                    startLineNumber--;
                }
                var editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber) || [];
                edits.push.apply(edits, editOperations);
            }
            if (edits.length > 0) {
                editor.pushUndoStop();
                editor.executeEdits(this.id, edits);
                editor.pushUndoStop();
            }
        };
        return ReindentSelectedLinesAction;
    }(editorExtensions_1.EditorAction));
    exports.ReindentSelectedLinesAction = ReindentSelectedLinesAction;
    var AutoIndentOnPasteCommand = /** @class */ (function () {
        function AutoIndentOnPasteCommand(edits, initialSelection) {
            this._initialSelection = initialSelection;
            this._edits = [];
            for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                var edit = edits_1[_i];
                if (edit.range && typeof edit.text === 'string') {
                    this._edits.push(edit);
                }
            }
        }
        AutoIndentOnPasteCommand.prototype.getEditOperations = function (model, builder) {
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                builder.addEditOperation(range_1.Range.lift(edit.range), edit.text);
            }
            var selectionIsSet = false;
            if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
                if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&
                    this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, true);
                }
                else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&
                    this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, false);
                }
            }
            if (!selectionIsSet) {
                this._selectionId = builder.trackSelection(this._initialSelection);
            }
        };
        AutoIndentOnPasteCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._selectionId);
        };
        return AutoIndentOnPasteCommand;
    }());
    exports.AutoIndentOnPasteCommand = AutoIndentOnPasteCommand;
    var AutoIndentOnPaste = /** @class */ (function () {
        function AutoIndentOnPaste(editor) {
            var _this = this;
            this.editor = editor;
            this.callOnDispose = [];
            this.callOnModel = [];
            this.callOnDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModelLanguage(function () { return _this.update(); }));
        }
        AutoIndentOnPaste.prototype.update = function () {
            var _this = this;
            // clean up
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
            // we are disabled
            if (!this.editor.getConfiguration().autoIndent || this.editor.getConfiguration().contribInfo.formatOnPaste) {
                return;
            }
            // no model
            if (!this.editor.getModel()) {
                return;
            }
            this.callOnModel.push(this.editor.onDidPaste(function (range) {
                _this.trigger(range);
            }));
        };
        AutoIndentOnPaste.prototype.trigger = function (range) {
            if (this.editor.getSelections().length > 1) {
                return;
            }
            var model = this.editor.getModel();
            if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {
                return;
            }
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            this.editor.pushUndoStop();
            var textEdits = [];
            var indentConverter = {
                shiftIndent: function (indentation) {
                    var desiredIndentCount = shiftCommand_1.ShiftCommand.shiftIndentCount(indentation, indentation.length + 1, tabSize);
                    var newIndentation = '';
                    for (var i = 0; i < desiredIndentCount; i++) {
                        newIndentation += '\t';
                    }
                    return newIndentation;
                },
                unshiftIndent: function (indentation) {
                    var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + 1, tabSize);
                    var newIndentation = '';
                    for (var i = 0; i < desiredIndentCount; i++) {
                        newIndentation += '\t';
                    }
                    return newIndentation;
                }
            };
            var startLineNumber = range.startLineNumber;
            while (startLineNumber <= range.endLineNumber) {
                if (this.shouldIgnoreLine(model, startLineNumber)) {
                    startLineNumber++;
                    continue;
                }
                break;
            }
            if (startLineNumber > range.endLineNumber) {
                return;
            }
            var firstLineText = model.getLineContent(startLineNumber);
            if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
                var indentOfFirstLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);
                if (indentOfFirstLine !== null) {
                    var oldIndentation = strings.getLeadingWhitespace(firstLineText);
                    var newSpaceCnt = IndentUtil.getSpaceCnt(indentOfFirstLine, tabSize);
                    var oldSpaceCnt = IndentUtil.getSpaceCnt(oldIndentation, tabSize);
                    if (newSpaceCnt !== oldSpaceCnt) {
                        var newIndent = IndentUtil.generateIndent(newSpaceCnt, tabSize, insertSpaces);
                        textEdits.push({
                            range: new range_1.Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
                            text: newIndent
                        });
                        firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
                    }
                    else {
                        var indentMetadata = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);
                        if (indentMetadata === 0 || indentMetadata === 8 /* UNINDENT_MASK */) {
                            // we paste content into a line where only contains whitespaces
                            // after pasting, the indentation of the first line is already correct
                            // the first line doesn't match any indentation rule
                            // then no-op.
                            return;
                        }
                    }
                }
            }
            var firstLineNumber = startLineNumber;
            // ignore empty or ignored lines
            while (startLineNumber < range.endLineNumber) {
                if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
                    startLineNumber++;
                    continue;
                }
                break;
            }
            if (startLineNumber !== range.endLineNumber) {
                var virtualModel = {
                    getLineTokens: function (lineNumber) {
                        return model.getLineTokens(lineNumber);
                    },
                    getLanguageIdentifier: function () {
                        return model.getLanguageIdentifier();
                    },
                    getLanguageIdAtPosition: function (lineNumber, column) {
                        return model.getLanguageIdAtPosition(lineNumber, column);
                    },
                    getLineContent: function (lineNumber) {
                        if (lineNumber === firstLineNumber) {
                            return firstLineText;
                        }
                        else {
                            return model.getLineContent(lineNumber);
                        }
                    }
                };
                var indentOfSecondLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);
                if (indentOfSecondLine !== null) {
                    var newSpaceCntOfSecondLine = IndentUtil.getSpaceCnt(indentOfSecondLine, tabSize);
                    var oldSpaceCntOfSecondLine = IndentUtil.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
                    if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
                        var spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
                        for (var i = startLineNumber + 1; i <= range.endLineNumber; i++) {
                            var lineContent = model.getLineContent(i);
                            var originalIndent = strings.getLeadingWhitespace(lineContent);
                            var originalSpacesCnt = IndentUtil.getSpaceCnt(originalIndent, tabSize);
                            var newSpacesCnt = originalSpacesCnt + spaceCntOffset;
                            var newIndent = IndentUtil.generateIndent(newSpacesCnt, tabSize, insertSpaces);
                            if (newIndent !== originalIndent) {
                                textEdits.push({
                                    range: new range_1.Range(i, 1, i, originalIndent.length + 1),
                                    text: newIndent
                                });
                            }
                        }
                    }
                }
            }
            var cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
            this.editor.executeCommand('autoIndentOnPaste', cmd);
            this.editor.pushUndoStop();
        };
        AutoIndentOnPaste.prototype.shouldIgnoreLine = function (model, lineNumber) {
            model.forceTokenization(lineNumber);
            var nonWhiteSpaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
            if (nonWhiteSpaceColumn === 0) {
                return true;
            }
            var tokens = model.getLineTokens(lineNumber);
            if (tokens.getCount() > 0) {
                var firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhiteSpaceColumn);
                if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1 /* Comment */) {
                    return true;
                }
            }
            return false;
        };
        AutoIndentOnPaste.prototype.getId = function () {
            return AutoIndentOnPaste.ID;
        };
        AutoIndentOnPaste.prototype.dispose = function () {
            this.callOnDispose = lifecycle_1.dispose(this.callOnDispose);
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
        };
        AutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';
        return AutoIndentOnPaste;
    }());
    exports.AutoIndentOnPaste = AutoIndentOnPaste;
    function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
            // Model is empty
            return;
        }
        var spaces = '';
        for (var i = 0; i < tabSize; i++) {
            spaces += ' ';
        }
        var spacesRegExp = new RegExp(spaces, 'gi');
        for (var lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
            if (lastIndentationColumn === 0) {
                lastIndentationColumn = model.getLineMaxColumn(lineNumber);
            }
            if (lastIndentationColumn === 1) {
                continue;
            }
            var originalIndentationRange = new range_1.Range(lineNumber, 1, lineNumber, lastIndentationColumn);
            var originalIndentation = model.getValueInRange(originalIndentationRange);
            var newIndentation = (tabsToSpaces
                ? originalIndentation.replace(/\t/ig, spaces)
                : originalIndentation.replace(spacesRegExp, '\t'));
            builder.addEditOperation(originalIndentationRange, newIndentation);
        }
    }
    var IndentationToSpacesCommand = /** @class */ (function () {
        function IndentationToSpacesCommand(selection, tabSize) {
            this.selection = selection;
            this.tabSize = tabSize;
        }
        IndentationToSpacesCommand.prototype.getEditOperations = function (model, builder) {
            this.selectionId = builder.trackSelection(this.selection);
            getIndentationEditOperations(model, builder, this.tabSize, true);
        };
        IndentationToSpacesCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return IndentationToSpacesCommand;
    }());
    exports.IndentationToSpacesCommand = IndentationToSpacesCommand;
    var IndentationToTabsCommand = /** @class */ (function () {
        function IndentationToTabsCommand(selection, tabSize) {
            this.selection = selection;
            this.tabSize = tabSize;
        }
        IndentationToTabsCommand.prototype.getEditOperations = function (model, builder) {
            this.selectionId = builder.trackSelection(this.selection);
            getIndentationEditOperations(model, builder, this.tabSize, false);
        };
        IndentationToTabsCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return IndentationToTabsCommand;
    }());
    exports.IndentationToTabsCommand = IndentationToTabsCommand;
    editorExtensions_1.registerEditorContribution(AutoIndentOnPaste);
    editorExtensions_1.registerEditorAction(IndentationToSpacesAction);
    editorExtensions_1.registerEditorAction(IndentationToTabsAction);
    editorExtensions_1.registerEditorAction(IndentUsingTabs);
    editorExtensions_1.registerEditorAction(IndentUsingSpaces);
    editorExtensions_1.registerEditorAction(DetectIndentation);
    editorExtensions_1.registerEditorAction(ReindentLinesAction);
    editorExtensions_1.registerEditorAction(ReindentSelectedLinesAction);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[42/*vs/platform/windows/common/windows*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,3/*vs/platform/instantiation/common/instantiation*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/]), function (require, exports, winjs_base_1, instantiation_1, event_1, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWindowsService = instantiation_1.createDecorator('windowsService');
    exports.IWindowService = instantiation_1.createDecorator('windowService');
    var ActiveWindowManager = /** @class */ (function () {
        function ActiveWindowManager(windowsService) {
            var _this = this;
            this.disposables = [];
            var onActiveWindowChange = event_1.latch(event_1.anyEvent(windowsService.onWindowOpen, windowsService.onWindowFocus));
            onActiveWindowChange(this.setActiveWindow, this, this.disposables);
            this.firstActiveWindowIdPromise = windowsService.getActiveWindowId()
                .then(function (id) { return (typeof _this._activeWindowId === 'undefined') && _this.setActiveWindow(id); });
        }
        ActiveWindowManager.prototype.setActiveWindow = function (windowId) {
            if (this.firstActiveWindowIdPromise) {
                this.firstActiveWindowIdPromise = null;
            }
            this._activeWindowId = windowId;
        };
        ActiveWindowManager.prototype.getActiveClientId = function () {
            if (this.firstActiveWindowIdPromise) {
                return this.firstActiveWindowIdPromise;
            }
            return winjs_base_1.TPromise.as("window:" + this._activeWindowId);
        };
        ActiveWindowManager.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        ActiveWindowManager = __decorate([
            __param(0, exports.IWindowsService)
        ], ActiveWindowManager);
        return ActiveWindowManager;
    }());
    exports.ActiveWindowManager = ActiveWindowManager;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[255/*vs/platform/windows/electron-browser/windowService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,42/*vs/platform/windows/common/windows*/]), function (require, exports, event_1, windows_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowService = /** @class */ (function () {
        function WindowService(windowId, configuration, windowsService) {
            this.windowId = windowId;
            this.configuration = configuration;
            this.windowsService = windowsService;
            var onThisWindowFocus = event_1.mapEvent(event_1.filterEvent(windowsService.onWindowFocus, function (id) { return id === windowId; }), function (_) { return true; });
            var onThisWindowBlur = event_1.mapEvent(event_1.filterEvent(windowsService.onWindowBlur, function (id) { return id === windowId; }), function (_) { return false; });
            var onThisWindowMaximize = event_1.mapEvent(event_1.filterEvent(windowsService.onWindowMaximize, function (id) { return id === windowId; }), function (_) { return true; });
            var onThisWindowUnmaximize = event_1.mapEvent(event_1.filterEvent(windowsService.onWindowUnmaximize, function (id) { return id === windowId; }), function (_) { return false; });
            this.onDidChangeFocus = event_1.anyEvent(onThisWindowFocus, onThisWindowBlur);
            this.onDidChangeMaximize = event_1.anyEvent(onThisWindowMaximize, onThisWindowUnmaximize);
        }
        WindowService.prototype.getCurrentWindowId = function () {
            return this.windowId;
        };
        WindowService.prototype.getConfiguration = function () {
            return this.configuration;
        };
        WindowService.prototype.pickFileFolderAndOpen = function (options) {
            options.windowId = this.windowId;
            return this.windowsService.pickFileFolderAndOpen(options);
        };
        WindowService.prototype.pickFileAndOpen = function (options) {
            options.windowId = this.windowId;
            return this.windowsService.pickFileAndOpen(options);
        };
        WindowService.prototype.pickFolderAndOpen = function (options) {
            options.windowId = this.windowId;
            return this.windowsService.pickFolderAndOpen(options);
        };
        WindowService.prototype.pickWorkspaceAndOpen = function (options) {
            options.windowId = this.windowId;
            return this.windowsService.pickWorkspaceAndOpen(options);
        };
        WindowService.prototype.reloadWindow = function (args) {
            return this.windowsService.reloadWindow(this.windowId, args);
        };
        WindowService.prototype.openDevTools = function (options) {
            return this.windowsService.openDevTools(this.windowId, options);
        };
        WindowService.prototype.toggleDevTools = function () {
            return this.windowsService.toggleDevTools(this.windowId);
        };
        WindowService.prototype.closeWorkspace = function () {
            return this.windowsService.closeWorkspace(this.windowId);
        };
        WindowService.prototype.enterWorkspace = function (path) {
            return this.windowsService.enterWorkspace(this.windowId, path);
        };
        WindowService.prototype.createAndEnterWorkspace = function (folders, path) {
            return this.windowsService.createAndEnterWorkspace(this.windowId, folders, path);
        };
        WindowService.prototype.saveAndEnterWorkspace = function (path) {
            return this.windowsService.saveAndEnterWorkspace(this.windowId, path);
        };
        WindowService.prototype.openWindow = function (paths, options) {
            return this.windowsService.openWindow(this.windowId, paths, options);
        };
        WindowService.prototype.closeWindow = function () {
            return this.windowsService.closeWindow(this.windowId);
        };
        WindowService.prototype.toggleFullScreen = function () {
            return this.windowsService.toggleFullScreen(this.windowId);
        };
        WindowService.prototype.setRepresentedFilename = function (fileName) {
            return this.windowsService.setRepresentedFilename(this.windowId, fileName);
        };
        WindowService.prototype.getRecentlyOpened = function () {
            return this.windowsService.getRecentlyOpened(this.windowId);
        };
        WindowService.prototype.focusWindow = function () {
            return this.windowsService.focusWindow(this.windowId);
        };
        WindowService.prototype.isFocused = function () {
            return this.windowsService.isFocused(this.windowId);
        };
        WindowService.prototype.isMaximized = function () {
            return this.windowsService.isMaximized(this.windowId);
        };
        WindowService.prototype.maximizeWindow = function () {
            return this.windowsService.maximizeWindow(this.windowId);
        };
        WindowService.prototype.unmaximizeWindow = function () {
            return this.windowsService.unmaximizeWindow(this.windowId);
        };
        WindowService.prototype.minimizeWindow = function () {
            return this.windowsService.minimizeWindow(this.windowId);
        };
        WindowService.prototype.onWindowTitleDoubleClick = function () {
            return this.windowsService.onWindowTitleDoubleClick(this.windowId);
        };
        WindowService.prototype.setDocumentEdited = function (flag) {
            return this.windowsService.setDocumentEdited(this.windowId, flag);
        };
        WindowService.prototype.show = function () {
            return this.windowsService.showWindow(this.windowId);
        };
        WindowService.prototype.showMessageBox = function (options) {
            return this.windowsService.showMessageBox(this.windowId, options);
        };
        WindowService.prototype.showSaveDialog = function (options) {
            return this.windowsService.showSaveDialog(this.windowId, options);
        };
        WindowService.prototype.showOpenDialog = function (options) {
            return this.windowsService.showOpenDialog(this.windowId, options);
        };
        WindowService.prototype.updateTouchBar = function (items) {
            return this.windowsService.updateTouchBar(this.windowId, items);
        };
        WindowService = __decorate([
            __param(2, windows_1.IWindowsService)
        ], WindowService);
        return WindowService;
    }());
    exports.WindowService = WindowService;
});























var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[256/*vs/editor/contrib/documentSymbols/outlineTree*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,208/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,118/*vs/base/common/collections*/,69/*vs/base/common/filters*/,5/*vs/base/common/winjs.base*/,48/*vs/editor/common/core/range*/,85/*vs/editor/common/modes*/,126/*vs/editor/contrib/documentSymbols/outlineModel*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,51/*vs/platform/list/browser/listService*/,482/*vs/platform/markers/common/markers*/,30/*vs/platform/theme/common/colorRegistry*/,14/*vs/platform/theme/common/themeService*/,366/*vs/css!vs/editor/contrib/documentSymbols/media/outlineTree*/,214/*vs/css!vs/editor/contrib/documentSymbols/media/symbol-icons*/]), function (require, exports, dom, highlightedLabel_1, collections_1, filters_1, winjs_base_1, range_1, modes_1, outlineModel_1, nls_1, configuration_1, listService_1, markers_1, colorRegistry_1, themeService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a;
    var OutlineItemComparator = /** @class */ (function () {
        function OutlineItemComparator(type) {
            if (type === void 0) { type = 0 /* ByPosition */; }
            this.type = type;
        }
        OutlineItemComparator.prototype.compare = function (tree, a, b) {
            if (a instanceof outlineModel_1.OutlineGroup && b instanceof outlineModel_1.OutlineGroup) {
                return a.providerIndex - b.providerIndex;
            }
            if (a instanceof outlineModel_1.OutlineElement && b instanceof outlineModel_1.OutlineElement) {
                switch (this.type) {
                    case 2 /* ByKind */:
                        return a.symbol.kind - b.symbol.kind;
                    case 1 /* ByName */:
                        return a.symbol.name.localeCompare(b.symbol.name);
                    case 0 /* ByPosition */:
                    default:
                        return range_1.Range.compareRangesUsingStarts(a.symbol.range, b.symbol.range);
                }
            }
            return 0;
        };
        return OutlineItemComparator;
    }());
    exports.OutlineItemComparator = OutlineItemComparator;
    var OutlineItemFilter = /** @class */ (function () {
        function OutlineItemFilter() {
            this.enabled = true;
        }
        OutlineItemFilter.prototype.isVisible = function (tree, element) {
            if (!this.enabled) {
                return true;
            }
            return !(element instanceof outlineModel_1.OutlineElement) || Boolean(element.score);
        };
        return OutlineItemFilter;
    }());
    exports.OutlineItemFilter = OutlineItemFilter;
    var OutlineDataSource = /** @class */ (function () {
        function OutlineDataSource() {
            // this is a workaround for the tree showing twisties for items
            // with only filtered children
            this.filterOnScore = true;
        }
        OutlineDataSource.prototype.getId = function (tree, element) {
            return element ? element.id : 'empty';
        };
        OutlineDataSource.prototype.hasChildren = function (tree, element) {
            if (!element) {
                return false;
            }
            if (element instanceof outlineModel_1.OutlineModel) {
                return true;
            }
            if (element instanceof outlineModel_1.OutlineElement && (this.filterOnScore && !element.score)) {
                return false;
            }
            for (var id in element.children) {
                if (!this.filterOnScore || element.children[id].score) {
                    return true;
                }
            }
            return false;
        };
        OutlineDataSource.prototype.getChildren = function (tree, element) {
            var res = collections_1.values(element.children);
            // console.log(element.id + ' with children ' + res.length);
            return winjs_base_1.TPromise.wrap(res);
        };
        OutlineDataSource.prototype.getParent = function (tree, element) {
            return winjs_base_1.TPromise.wrap(element && element.parent);
        };
        OutlineDataSource.prototype.shouldAutoexpand = function (tree, element) {
            return element && (element instanceof outlineModel_1.OutlineModel || element.parent instanceof outlineModel_1.OutlineModel || element instanceof outlineModel_1.OutlineGroup || element.parent instanceof outlineModel_1.OutlineGroup);
        };
        return OutlineDataSource;
    }());
    exports.OutlineDataSource = OutlineDataSource;
    var OutlineRenderer = /** @class */ (function () {
        function OutlineRenderer(_themeService, _configurationService) {
            this._themeService = _themeService;
            this._configurationService = _configurationService;
            this.renderProblemColors = true;
            this.renderProblemBadges = true;
            //
        }
        OutlineRenderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        OutlineRenderer.prototype.getTemplateId = function (tree, element) {
            return element instanceof outlineModel_1.OutlineGroup ? 'outline-group' : 'outline-element';
        };
        OutlineRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            if (templateId === 'outline-element') {
                var icon = dom.$('.outline-element-icon symbol-icon');
                var labelContainer = dom.$('.outline-element-label');
                var detail = dom.$('.outline-element-detail');
                var decoration = dom.$('.outline-element-decoration');
                dom.addClass(container, 'outline-element');
                dom.append(container, icon, labelContainer, detail, decoration);
                return { icon: icon, labelContainer: labelContainer, label: new highlightedLabel_1.HighlightedLabel(labelContainer), detail: detail, decoration: decoration };
            }
            if (templateId === 'outline-group') {
                var labelContainer = dom.$('.outline-element-label');
                dom.addClass(container, 'outline-element');
                dom.append(container, labelContainer);
                return { labelContainer: labelContainer, label: new highlightedLabel_1.HighlightedLabel(labelContainer) };
            }
            throw new Error(templateId);
        };
        OutlineRenderer.prototype.renderElement = function (tree, element, templateId, template) {
            if (element instanceof outlineModel_1.OutlineElement) {
                template.icon.className = "outline-element-icon " + modes_1.symbolKindToCssClass(element.symbol.kind);
                template.label.set(element.symbol.name, element.score ? filters_1.createMatches(element.score[1]) : undefined, nls_1.localize('title.template', "{0} ({1})", element.symbol.name, OutlineRenderer._symbolKindNames[element.symbol.kind]));
                template.detail.innerText = element.symbol.detail || '';
                this._renderMarkerInfo(element, template);
            }
            if (element instanceof outlineModel_1.OutlineGroup) {
                template.label.set(element.provider.displayName || nls_1.localize('provider', "Outline Provider"));
            }
        };
        OutlineRenderer.prototype._renderMarkerInfo = function (element, template) {
            if (!element.marker) {
                dom.hide(template.decoration);
                template.labelContainer.style.removeProperty('--outline-element-color');
                return;
            }
            var _a = element.marker, count = _a.count, topSev = _a.topSev;
            var color = this._themeService.getTheme().getColor(topSev === markers_1.MarkerSeverity.Error ? colorRegistry_1.listErrorForeground : colorRegistry_1.listWarningForeground);
            var cssColor = color ? color.toString() : 'inherit';
            // color of the label
            if (this.renderProblemColors) {
                template.labelContainer.style.setProperty('--outline-element-color', cssColor);
            }
            else {
                template.labelContainer.style.removeProperty('--outline-element-color');
            }
            // badge with color/rollup
            if (!this.renderProblemBadges) {
                dom.hide(template.decoration);
            }
            else if (count > 0) {
                dom.show(template.decoration);
                dom.removeClass(template.decoration, 'bubble');
                template.decoration.innerText = count < 10 ? count.toString() : '+9';
                template.decoration.title = count === 1 ? nls_1.localize('1.problem', "1 problem in this element") : nls_1.localize('N.problem', "{0} problems in this element", count);
                template.decoration.style.setProperty('--outline-element-color', cssColor);
            }
            else {
                dom.show(template.decoration);
                dom.addClass(template.decoration, 'bubble');
                template.decoration.innerText = '\uf052';
                template.decoration.title = nls_1.localize('deep.problem', "Contains elements with problems");
                template.decoration.style.setProperty('--outline-element-color', cssColor);
            }
        };
        OutlineRenderer.prototype.disposeTemplate = function (tree, templateId, template) {
            template.label.dispose();
        };
        OutlineRenderer._symbolKindNames = (_a = {},
            _a[modes_1.SymbolKind.Array] = nls_1.localize('Array', "array"),
            _a[modes_1.SymbolKind.Boolean] = nls_1.localize('Boolean', "boolean"),
            _a[modes_1.SymbolKind.Class] = nls_1.localize('Class', "class"),
            _a[modes_1.SymbolKind.Constant] = nls_1.localize('Constant', "constant"),
            _a[modes_1.SymbolKind.Constructor] = nls_1.localize('Constructor', "constructor"),
            _a[modes_1.SymbolKind.Enum] = nls_1.localize('Enum', "enumeration"),
            _a[modes_1.SymbolKind.EnumMember] = nls_1.localize('EnumMember', "enumeration member"),
            _a[modes_1.SymbolKind.Event] = nls_1.localize('Event', "event"),
            _a[modes_1.SymbolKind.Field] = nls_1.localize('Field', "field"),
            _a[modes_1.SymbolKind.File] = nls_1.localize('File', "file"),
            _a[modes_1.SymbolKind.Function] = nls_1.localize('Function', "function"),
            _a[modes_1.SymbolKind.Interface] = nls_1.localize('Interface', "interface"),
            _a[modes_1.SymbolKind.Key] = nls_1.localize('Key', "key"),
            _a[modes_1.SymbolKind.Method] = nls_1.localize('Method', "method"),
            _a[modes_1.SymbolKind.Module] = nls_1.localize('Module', "module"),
            _a[modes_1.SymbolKind.Namespace] = nls_1.localize('Namespace', "namespace"),
            _a[modes_1.SymbolKind.Null] = nls_1.localize('Null', "null"),
            _a[modes_1.SymbolKind.Number] = nls_1.localize('Number', "number"),
            _a[modes_1.SymbolKind.Object] = nls_1.localize('Object', "object"),
            _a[modes_1.SymbolKind.Operator] = nls_1.localize('Operator', "operator"),
            _a[modes_1.SymbolKind.Package] = nls_1.localize('Package', "package"),
            _a[modes_1.SymbolKind.Property] = nls_1.localize('Property', "property"),
            _a[modes_1.SymbolKind.String] = nls_1.localize('String', "string"),
            _a[modes_1.SymbolKind.Struct] = nls_1.localize('Struct', "struct"),
            _a[modes_1.SymbolKind.TypeParameter] = nls_1.localize('TypeParameter', "type parameter"),
            _a[modes_1.SymbolKind.Variable] = nls_1.localize('Variable', "variable"),
            _a);
        OutlineRenderer = __decorate([
            __param(0, themeService_1.IThemeService),
            __param(1, configuration_1.IConfigurationService)
        ], OutlineRenderer);
        return OutlineRenderer;
    }());
    exports.OutlineRenderer = OutlineRenderer;
    var OutlineTreeState = /** @class */ (function () {
        function OutlineTreeState() {
        }
        OutlineTreeState.capture = function (tree) {
            // selection
            var selected;
            var element = tree.getSelection()[0];
            if (element instanceof outlineModel_1.TreeElement) {
                selected = element.id;
            }
            // focus
            var focused;
            element = tree.getFocus(true);
            if (element instanceof outlineModel_1.TreeElement) {
                focused = element.id;
            }
            // expansion
            var expanded = new Array();
            var nav = tree.getNavigator();
            while (nav.next()) {
                var element_1 = nav.current();
                if (element_1 instanceof outlineModel_1.TreeElement) {
                    if (tree.isExpanded(element_1)) {
                        expanded.push(element_1.id);
                    }
                }
            }
            return { selected: selected, focused: focused, expanded: expanded };
        };
        OutlineTreeState.restore = function (tree, state, eventPayload) {
            return __awaiter(this, void 0, void 0, function () {
                var model, items, _i, _a, id, item, selected, focused;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            model = tree.getInput();
                            if (!state || !(model instanceof outlineModel_1.OutlineModel)) {
                                return [2 /*return*/, winjs_base_1.TPromise.as(undefined)];
                            }
                            items = [];
                            for (_i = 0, _a = state.expanded; _i < _a.length; _i++) {
                                id = _a[_i];
                                item = model.getItemById(id);
                                if (item) {
                                    items.push(item);
                                }
                            }
                            return [4 /*yield*/, tree.collapseAll(undefined)];
                        case 1:
                            _b.sent();
                            return [4 /*yield*/, tree.expandAll(items)];
                        case 2:
                            _b.sent();
                            selected = model.getItemById(state.selected);
                            focused = model.getItemById(state.focused);
                            tree.setSelection([selected], eventPayload);
                            tree.setFocus(focused, eventPayload);
                            return [2 /*return*/];
                    }
                });
            });
        };
        return OutlineTreeState;
    }());
    exports.OutlineTreeState = OutlineTreeState;
    var OutlineController = /** @class */ (function (_super) {
        __extends(OutlineController, _super);
        function OutlineController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OutlineController.prototype.shouldToggleExpansion = function (element, event, origin) {
            if (element instanceof outlineModel_1.OutlineElement) {
                return this.isClickOnTwistie(event);
            }
            else {
                return _super.prototype.shouldToggleExpansion.call(this, element, event, origin);
            }
        };
        return OutlineController;
    }(listService_1.WorkbenchTreeController));
    exports.OutlineController = OutlineController;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












































define(__m[264/*vs/platform/extensionManagement/common/extensionEnablementService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,122/*vs/platform/extensionManagement/common/extensionManagement*/,294/*vs/platform/extensionManagement/common/extensionManagementUtil*/,20/*vs/platform/workspace/common/workspace*/,44/*vs/platform/storage/common/storage*/,43/*vs/platform/environment/common/environment*/]), function (require, exports, nls_1, winjs_base_1, event_1, lifecycle_1, extensionManagement_1, extensionManagementUtil_1, workspace_1, storage_1, environment_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DISABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/disabled';
    var ENABLED_EXTENSIONS_STORAGE_PATH = 'extensionsIdentifiers/enabled';
    var ExtensionEnablementService = /** @class */ (function () {
        function ExtensionEnablementService(storageService, contextService, environmentService, extensionManagementService) {
            this.storageService = storageService;
            this.contextService = contextService;
            this.environmentService = environmentService;
            this.extensionManagementService = extensionManagementService;
            this.disposables = [];
            this._onEnablementChanged = new event_1.Emitter();
            this.onEnablementChanged = this._onEnablementChanged.event;
            extensionManagementService.onDidUninstallExtension(this._onDidUninstallExtension, this, this.disposables);
        }
        Object.defineProperty(ExtensionEnablementService.prototype, "hasWorkspace", {
            get: function () {
                return this.contextService.getWorkbenchState() !== 1 /* EMPTY */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtensionEnablementService.prototype, "allUserExtensionsDisabled", {
            get: function () {
                return this.environmentService.disableExtensions === true;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionEnablementService.prototype.getDisabledExtensions = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, _loop_1, _i, _a, e, workspaceEnabledExtensions_1, allInstalledExtensions, _loop_2, this_1, _b, allInstalledExtensions_1, installedExtension;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            result = this._getDisabledExtensions(0 /* GLOBAL */);
                            if (this.hasWorkspace) {
                                _loop_1 = function (e) {
                                    if (!result.some(function (r) { return extensionManagementUtil_1.areSameExtensions(r, e); })) {
                                        result.push(e);
                                    }
                                };
                                for (_i = 0, _a = this._getDisabledExtensions(1 /* WORKSPACE */); _i < _a.length; _i++) {
                                    e = _a[_i];
                                    _loop_1(e);
                                }
                                workspaceEnabledExtensions_1 = this._getEnabledExtensions(1 /* WORKSPACE */);
                                if (workspaceEnabledExtensions_1.length) {
                                    result = result.filter(function (r) { return !workspaceEnabledExtensions_1.some(function (e) { return extensionManagementUtil_1.areSameExtensions(e, r); }); });
                                }
                            }
                            if (!this.environmentService.disableExtensions) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.extensionManagementService.getInstalled()];
                        case 1:
                            allInstalledExtensions = _c.sent();
                            _loop_2 = function (installedExtension) {
                                if (this_1._isExtensionDisabledInEnvironment(installedExtension)) {
                                    if (!result.some(function (r) { return extensionManagementUtil_1.areSameExtensions(r, installedExtension.galleryIdentifier); })) {
                                        result.push(installedExtension.galleryIdentifier);
                                    }
                                }
                            };
                            this_1 = this;
                            for (_b = 0, allInstalledExtensions_1 = allInstalledExtensions; _b < allInstalledExtensions_1.length; _b++) {
                                installedExtension = allInstalledExtensions_1[_b];
                                _loop_2(installedExtension);
                            }
                            _c.label = 2;
                        case 2: return [2 /*return*/, result];
                    }
                });
            });
        };
        ExtensionEnablementService.prototype.getEnablementState = function (extension) {
            if (this._isExtensionDisabledInEnvironment(extension)) {
                return 0 /* Disabled */;
            }
            var identifier = extension.galleryIdentifier;
            if (this.hasWorkspace) {
                if (this._getEnabledExtensions(1 /* WORKSPACE */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                    return 3 /* WorkspaceEnabled */;
                }
                if (this._getDisabledExtensions(1 /* WORKSPACE */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                    return 1 /* WorkspaceDisabled */;
                }
            }
            if (this._getDisabledExtensions(0 /* GLOBAL */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                return 0 /* Disabled */;
            }
            return 2 /* Enabled */;
        };
        ExtensionEnablementService.prototype.canChangeEnablement = function (extension) {
            if (extension.manifest && extension.manifest.contributes && extension.manifest.contributes.localizations && extension.manifest.contributes.localizations.length) {
                return false;
            }
            if (extension.type === 1 /* User */ && this.environmentService.disableExtensions) {
                return false;
            }
            return true;
        };
        ExtensionEnablementService.prototype.setEnablement = function (arg, newState) {
            var identifier;
            if (extensionManagement_1.isIExtensionIdentifier(arg)) {
                identifier = arg;
            }
            else {
                if (!this.canChangeEnablement(arg)) {
                    return winjs_base_1.TPromise.wrap(false);
                }
                identifier = arg.galleryIdentifier;
            }
            var workspace = newState === 1 /* WorkspaceDisabled */ || newState === 3 /* WorkspaceEnabled */;
            if (workspace && !this.hasWorkspace) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('noWorkspace', "No workspace.")));
            }
            var currentState = this._getEnablementState(identifier);
            if (currentState === newState) {
                return winjs_base_1.TPromise.as(false);
            }
            switch (newState) {
                case 2 /* Enabled */:
                    this._enableExtension(identifier);
                    break;
                case 0 /* Disabled */:
                    this._disableExtension(identifier);
                    break;
                case 3 /* WorkspaceEnabled */:
                    this._enableExtensionInWorkspace(identifier);
                    break;
                case 1 /* WorkspaceDisabled */:
                    this._disableExtensionInWorkspace(identifier);
                    break;
            }
            this._onEnablementChanged.fire(identifier);
            return winjs_base_1.TPromise.as(true);
        };
        ExtensionEnablementService.prototype.isEnabled = function (extension) {
            var enablementState = this.getEnablementState(extension);
            return enablementState === 3 /* WorkspaceEnabled */ || enablementState === 2 /* Enabled */;
        };
        ExtensionEnablementService.prototype._isExtensionDisabledInEnvironment = function (extension) {
            if (this.allUserExtensionsDisabled) {
                return extension.type === 1 /* User */;
            }
            var disabledExtensions = this.environmentService.disableExtensions;
            if (Array.isArray(disabledExtensions)) {
                return disabledExtensions.some(function (id) { return extensionManagementUtil_1.areSameExtensions({ id: id }, extension.galleryIdentifier); });
            }
            return false;
        };
        ExtensionEnablementService.prototype._getEnablementState = function (identifier) {
            if (this.hasWorkspace) {
                if (this._getEnabledExtensions(1 /* WORKSPACE */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                    return 3 /* WorkspaceEnabled */;
                }
                if (this._getDisabledExtensions(1 /* WORKSPACE */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                    return 1 /* WorkspaceDisabled */;
                }
            }
            if (this._getDisabledExtensions(0 /* GLOBAL */).filter(function (e) { return extensionManagementUtil_1.areSameExtensions(e, identifier); })[0]) {
                return 0 /* Disabled */;
            }
            return 2 /* Enabled */;
        };
        ExtensionEnablementService.prototype._enableExtension = function (identifier) {
            this._removeFromDisabledExtensions(identifier, 1 /* WORKSPACE */);
            this._removeFromEnabledExtensions(identifier, 1 /* WORKSPACE */);
            this._removeFromDisabledExtensions(identifier, 0 /* GLOBAL */);
        };
        ExtensionEnablementService.prototype._disableExtension = function (identifier) {
            this._removeFromDisabledExtensions(identifier, 1 /* WORKSPACE */);
            this._removeFromEnabledExtensions(identifier, 1 /* WORKSPACE */);
            this._addToDisabledExtensions(identifier, 0 /* GLOBAL */);
        };
        ExtensionEnablementService.prototype._enableExtensionInWorkspace = function (identifier) {
            this._removeFromDisabledExtensions(identifier, 1 /* WORKSPACE */);
            this._addToEnabledExtensions(identifier, 1 /* WORKSPACE */);
        };
        ExtensionEnablementService.prototype._disableExtensionInWorkspace = function (identifier) {
            this._addToDisabledExtensions(identifier, 1 /* WORKSPACE */);
            this._removeFromEnabledExtensions(identifier, 1 /* WORKSPACE */);
        };
        ExtensionEnablementService.prototype._addToDisabledExtensions = function (identifier, scope) {
            if (scope === 1 /* WORKSPACE */ && !this.hasWorkspace) {
                return winjs_base_1.TPromise.wrap(false);
            }
            var disabledExtensions = this._getDisabledExtensions(scope);
            if (disabledExtensions.every(function (e) { return !extensionManagementUtil_1.areSameExtensions(e, identifier); })) {
                disabledExtensions.push(identifier);
                this._setDisabledExtensions(disabledExtensions, scope, identifier);
                return winjs_base_1.TPromise.wrap(true);
            }
            return winjs_base_1.TPromise.wrap(false);
        };
        ExtensionEnablementService.prototype._removeFromDisabledExtensions = function (identifier, scope) {
            if (scope === 1 /* WORKSPACE */ && !this.hasWorkspace) {
                return false;
            }
            var disabledExtensions = this._getDisabledExtensions(scope);
            for (var index = 0; index < disabledExtensions.length; index++) {
                var disabledExtension = disabledExtensions[index];
                if (extensionManagementUtil_1.areSameExtensions(disabledExtension, identifier)) {
                    disabledExtensions.splice(index, 1);
                    this._setDisabledExtensions(disabledExtensions, scope, identifier);
                    return true;
                }
            }
            return false;
        };
        ExtensionEnablementService.prototype._addToEnabledExtensions = function (identifier, scope) {
            if (scope === 1 /* WORKSPACE */ && !this.hasWorkspace) {
                return false;
            }
            var enabledExtensions = this._getEnabledExtensions(scope);
            if (enabledExtensions.every(function (e) { return !extensionManagementUtil_1.areSameExtensions(e, identifier); })) {
                enabledExtensions.push(identifier);
                this._setEnabledExtensions(enabledExtensions, scope, identifier);
                return true;
            }
            return false;
        };
        ExtensionEnablementService.prototype._removeFromEnabledExtensions = function (identifier, scope) {
            if (scope === 1 /* WORKSPACE */ && !this.hasWorkspace) {
                return false;
            }
            var enabledExtensions = this._getEnabledExtensions(scope);
            for (var index = 0; index < enabledExtensions.length; index++) {
                var disabledExtension = enabledExtensions[index];
                if (extensionManagementUtil_1.areSameExtensions(disabledExtension, identifier)) {
                    enabledExtensions.splice(index, 1);
                    this._setEnabledExtensions(enabledExtensions, scope, identifier);
                    return true;
                }
            }
            return false;
        };
        ExtensionEnablementService.prototype._getEnabledExtensions = function (scope) {
            return this._getExtensions(ENABLED_EXTENSIONS_STORAGE_PATH, scope);
        };
        ExtensionEnablementService.prototype._setEnabledExtensions = function (enabledExtensions, scope, extension) {
            this._setExtensions(ENABLED_EXTENSIONS_STORAGE_PATH, enabledExtensions, scope, extension);
        };
        ExtensionEnablementService.prototype._getDisabledExtensions = function (scope) {
            return this._getExtensions(DISABLED_EXTENSIONS_STORAGE_PATH, scope);
        };
        ExtensionEnablementService.prototype._setDisabledExtensions = function (disabledExtensions, scope, extension) {
            this._setExtensions(DISABLED_EXTENSIONS_STORAGE_PATH, disabledExtensions, scope, extension);
        };
        ExtensionEnablementService.prototype._getExtensions = function (storageId, scope) {
            if (scope === 1 /* WORKSPACE */ && !this.hasWorkspace) {
                return [];
            }
            var value = this.storageService.get(storageId, scope, '');
            return value ? JSON.parse(value) : [];
        };
        ExtensionEnablementService.prototype._setExtensions = function (storageId, extensions, scope, extension) {
            if (extensions.length) {
                this.storageService.store(storageId, JSON.stringify(extensions.map(function (_a) {
                    var id = _a.id, uuid = _a.uuid;
                    return ({ id: id, uuid: uuid });
                })), scope);
            }
            else {
                this.storageService.remove(storageId, scope);
            }
        };
        ExtensionEnablementService.prototype._onDidUninstallExtension = function (_a) {
            var identifier = _a.identifier, error = _a.error;
            if (!error) {
                var id = extensionManagementUtil_1.getIdFromLocalExtensionId(identifier.id);
                if (id) {
                    var extension = { id: id, uuid: identifier.uuid };
                    this._removeFromDisabledExtensions(extension, 1 /* WORKSPACE */);
                    this._removeFromEnabledExtensions(extension, 1 /* WORKSPACE */);
                    this._removeFromDisabledExtensions(extension, 0 /* GLOBAL */);
                }
            }
        };
        ExtensionEnablementService.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        ExtensionEnablementService = __decorate([
            __param(0, storage_1.IStorageService),
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, extensionManagement_1.IExtensionManagementService)
        ], ExtensionEnablementService);
        return ExtensionEnablementService;
    }());
    exports.ExtensionEnablementService = ExtensionEnablementService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[271/*vs/workbench/api/electron-browser/extHostCustomers*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function extHostNamedCustomer(id) {
        return function (ctor) {
            ExtHostCustomersRegistryImpl.INSTANCE.registerNamedCustomer(id, ctor);
        };
    }
    exports.extHostNamedCustomer = extHostNamedCustomer;
    function extHostCustomer(ctor) {
        ExtHostCustomersRegistryImpl.INSTANCE.registerCustomer(ctor);
    }
    exports.extHostCustomer = extHostCustomer;
    var ExtHostCustomersRegistry;
    (function (ExtHostCustomersRegistry) {
        function getNamedCustomers() {
            return ExtHostCustomersRegistryImpl.INSTANCE.getNamedCustomers();
        }
        ExtHostCustomersRegistry.getNamedCustomers = getNamedCustomers;
        function getCustomers() {
            return ExtHostCustomersRegistryImpl.INSTANCE.getCustomers();
        }
        ExtHostCustomersRegistry.getCustomers = getCustomers;
    })(ExtHostCustomersRegistry = exports.ExtHostCustomersRegistry || (exports.ExtHostCustomersRegistry = {}));
    var ExtHostCustomersRegistryImpl = /** @class */ (function () {
        function ExtHostCustomersRegistryImpl() {
            this._namedCustomers = [];
            this._customers = [];
        }
        ExtHostCustomersRegistryImpl.prototype.registerNamedCustomer = function (id, ctor) {
            var entry = [id, ctor];
            this._namedCustomers.push(entry);
        };
        ExtHostCustomersRegistryImpl.prototype.getNamedCustomers = function () {
            return this._namedCustomers;
        };
        ExtHostCustomersRegistryImpl.prototype.registerCustomer = function (ctor) {
            this._customers.push(ctor);
        };
        ExtHostCustomersRegistryImpl.prototype.getCustomers = function () {
            return this._customers;
        };
        ExtHostCustomersRegistryImpl.INSTANCE = new ExtHostCustomersRegistryImpl();
        return ExtHostCustomersRegistryImpl;
    }());
});

define(__m[112/*vs/workbench/browser/actions*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,50/*vs/base/browser/ui/actionbar/actionbar*/]), function (require, exports, platform_1, actionbar_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The action bar contributor allows to add actions to an actionbar in a given context.
     */
    var ActionBarContributor = /** @class */ (function () {
        function ActionBarContributor() {
        }
        /**
         * Returns true if this contributor has actions for the given context.
         */
        ActionBarContributor.prototype.hasActions = function (context) {
            return false;
        };
        /**
         * Returns an array of primary actions in the given context.
         */
        ActionBarContributor.prototype.getActions = function (context) {
            return [];
        };
        /**
         * Returns true if this contributor has secondary actions for the given context.
         */
        ActionBarContributor.prototype.hasSecondaryActions = function (context) {
            return false;
        };
        /**
         * Returns an array of secondary actions in the given context.
         */
        ActionBarContributor.prototype.getSecondaryActions = function (context) {
            return [];
        };
        /**
         * Can return a specific IActionItem to render the given action.
         */
        ActionBarContributor.prototype.getActionItem = function (context, action) {
            return null;
        };
        return ActionBarContributor;
    }());
    exports.ActionBarContributor = ActionBarContributor;
    /**
     * Some predefined scopes to contribute actions to
     */
    exports.Scope = {
        /**
         * Actions inside tree widgets.
         */
        VIEWER: 'viewer'
    };
    /**
     * The ContributableActionProvider leverages the actionbar contribution model to find actions.
     */
    var ContributableActionProvider = /** @class */ (function () {
        function ContributableActionProvider() {
            this.registry = platform_1.Registry.as(exports.Extensions.Actionbar);
        }
        ContributableActionProvider.prototype.toContext = function (tree, element) {
            return {
                viewer: tree,
                element: element
            };
        };
        ContributableActionProvider.prototype.hasActions = function (tree, element) {
            var context = this.toContext(tree, element);
            var contributors = this.registry.getActionBarContributors(exports.Scope.VIEWER);
            for (var i = 0; i < contributors.length; i++) {
                var contributor = contributors[i];
                if (contributor.hasActions(context)) {
                    return true;
                }
            }
            return false;
        };
        ContributableActionProvider.prototype.getActions = function (tree, element) {
            var actions = [];
            var context = this.toContext(tree, element);
            // Collect Actions
            var contributors = this.registry.getActionBarContributors(exports.Scope.VIEWER);
            for (var i = 0; i < contributors.length; i++) {
                var contributor = contributors[i];
                if (contributor.hasActions(context)) {
                    actions.push.apply(actions, contributor.getActions(context));
                }
            }
            return Promise.resolve(prepareActions(actions));
        };
        ContributableActionProvider.prototype.hasSecondaryActions = function (tree, element) {
            var context = this.toContext(tree, element);
            var contributors = this.registry.getActionBarContributors(exports.Scope.VIEWER);
            for (var i = 0; i < contributors.length; i++) {
                var contributor = contributors[i];
                if (contributor.hasSecondaryActions(context)) {
                    return true;
                }
            }
            return false;
        };
        ContributableActionProvider.prototype.getSecondaryActions = function (tree, element) {
            var actions = [];
            var context = this.toContext(tree, element);
            // Collect Actions
            var contributors = this.registry.getActionBarContributors(exports.Scope.VIEWER);
            for (var i = 0; i < contributors.length; i++) {
                var contributor = contributors[i];
                if (contributor.hasSecondaryActions(context)) {
                    actions.push.apply(actions, contributor.getSecondaryActions(context));
                }
            }
            return Promise.resolve(prepareActions(actions));
        };
        ContributableActionProvider.prototype.getActionItem = function (tree, element, action) {
            var contributors = this.registry.getActionBarContributors(exports.Scope.VIEWER);
            var context = this.toContext(tree, element);
            for (var i = contributors.length - 1; i >= 0; i--) {
                var contributor = contributors[i];
                var itemProvider = contributor.getActionItem(context, action);
                if (itemProvider) {
                    return itemProvider;
                }
            }
            return null;
        };
        return ContributableActionProvider;
    }());
    exports.ContributableActionProvider = ContributableActionProvider;
    // Helper function used in parts to massage actions before showing in action areas
    function prepareActions(actions) {
        if (!actions.length) {
            return actions;
        }
        // Clean up leading separators
        var firstIndexOfAction = -1;
        for (var i = 0; i < actions.length; i++) {
            if (actions[i].id === actionbar_1.Separator.ID) {
                continue;
            }
            firstIndexOfAction = i;
            break;
        }
        if (firstIndexOfAction === -1) {
            return [];
        }
        actions = actions.slice(firstIndexOfAction);
        // Clean up trailing separators
        for (var h = actions.length - 1; h >= 0; h--) {
            var isSeparator = actions[h].id === actionbar_1.Separator.ID;
            if (isSeparator) {
                actions.splice(h, 1);
            }
            else {
                break;
            }
        }
        // Clean up separator duplicates
        var foundAction = false;
        for (var k = actions.length - 1; k >= 0; k--) {
            var isSeparator = actions[k].id === actionbar_1.Separator.ID;
            if (isSeparator && !foundAction) {
                actions.splice(k, 1);
            }
            else if (!isSeparator) {
                foundAction = true;
            }
            else if (isSeparator) {
                foundAction = false;
            }
        }
        return actions;
    }
    exports.prepareActions = prepareActions;
    exports.Extensions = {
        Actionbar: 'workbench.contributions.actionbar'
    };
    var ActionBarRegistry = /** @class */ (function () {
        function ActionBarRegistry() {
            this.actionBarContributorConstructors = [];
            this.actionBarContributorInstances = Object.create(null);
        }
        ActionBarRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            while (this.actionBarContributorConstructors.length > 0) {
                var entry = this.actionBarContributorConstructors.shift();
                this.createActionBarContributor(entry.scope, entry.ctor);
            }
        };
        ActionBarRegistry.prototype.createActionBarContributor = function (scope, ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            var target = this.actionBarContributorInstances[scope];
            if (!target) {
                target = this.actionBarContributorInstances[scope] = [];
            }
            target.push(instance);
        };
        ActionBarRegistry.prototype.getContributors = function (scope) {
            return this.actionBarContributorInstances[scope] || [];
        };
        ActionBarRegistry.prototype.getActionBarActionsForContext = function (scope, context) {
            var actions = [];
            // Go through contributors for scope
            this.getContributors(scope).forEach(function (contributor) {
                // Primary Actions
                if (contributor.hasActions(context)) {
                    actions.push.apply(actions, contributor.getActions(context));
                }
            });
            return actions;
        };
        ActionBarRegistry.prototype.getSecondaryActionBarActionsForContext = function (scope, context) {
            var actions = [];
            // Go through contributors
            this.getContributors(scope).forEach(function (contributor) {
                // Secondary Actions
                if (contributor.hasSecondaryActions(context)) {
                    actions.push.apply(actions, contributor.getSecondaryActions(context));
                }
            });
            return actions;
        };
        ActionBarRegistry.prototype.getActionItemForContext = function (scope, context, action) {
            var contributors = this.getContributors(scope);
            for (var i = 0; i < contributors.length; i++) {
                var contributor = contributors[i];
                var item = contributor.getActionItem(context, action);
                if (item) {
                    return item;
                }
            }
            return null;
        };
        ActionBarRegistry.prototype.registerActionBarContributor = function (scope, ctor) {
            if (!this.instantiationService) {
                this.actionBarContributorConstructors.push({
                    scope: scope,
                    ctor: ctor
                });
            }
            else {
                this.createActionBarContributor(scope, ctor);
            }
        };
        ActionBarRegistry.prototype.getActionBarContributors = function (scope) {
            return this.getContributors(scope).slice(0);
        };
        return ActionBarRegistry;
    }());
    platform_1.Registry.add(exports.Extensions.Actionbar, new ActionBarRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[103/*vs/workbench/browser/parts/editor/breadcrumbs*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,2/*vs/nls*/,90/*vs/platform/configuration/common/configurationRegistry*/,80/*vs/platform/instantiation/common/extensions*/,3/*vs/platform/instantiation/common/instantiation*/,9/*vs/platform/registry/common/platform*/]), function (require, exports, event_1, nls_1, configurationRegistry_1, extensions_1, instantiation_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBreadcrumbsService = instantiation_1.createDecorator('IEditorBreadcrumbsService');
    var BreadcrumbsService = /** @class */ (function () {
        function BreadcrumbsService() {
            this._map = new Map();
        }
        BreadcrumbsService.prototype.register = function (group, widget) {
            var _this = this;
            if (this._map.has(group)) {
                throw new Error("group (" + group + ") has already a widget");
            }
            this._map.set(group, widget);
            return {
                dispose: function () { return _this._map.delete(group); }
            };
        };
        BreadcrumbsService.prototype.getWidget = function (group) {
            return this._map.get(group);
        };
        return BreadcrumbsService;
    }());
    exports.BreadcrumbsService = BreadcrumbsService;
    extensions_1.registerSingleton(exports.IBreadcrumbsService, BreadcrumbsService);
    //#region config
    var BreadcrumbsConfig = /** @class */ (function () {
        function BreadcrumbsConfig() {
            // internal
        }
        BreadcrumbsConfig._stub = function (name) {
            return {
                bindTo: function (service) {
                    var onDidChange = new event_1.Emitter();
                    var listener = service.onDidChangeConfiguration(function (e) {
                        if (e.affectsConfiguration(name)) {
                            onDidChange.fire(undefined);
                        }
                    });
                    return new /** @class */ (function () {
                        function class_1() {
                            this.name = name;
                            this.onDidChange = onDidChange.event;
                        }
                        class_1.prototype.getValue = function (overrides) {
                            return service.getValue(name, overrides);
                        };
                        class_1.prototype.updateValue = function (newValue, overrides) {
                            return service.updateValue(name, newValue, overrides);
                        };
                        class_1.prototype.dispose = function () {
                            listener.dispose();
                            onDidChange.dispose();
                        };
                        return class_1;
                    }());
                }
            };
        };
        BreadcrumbsConfig.IsEnabled = BreadcrumbsConfig._stub('breadcrumbs.enabled');
        BreadcrumbsConfig.UseQuickPick = BreadcrumbsConfig._stub('breadcrumbs.useQuickPick');
        BreadcrumbsConfig.FilePath = BreadcrumbsConfig._stub('breadcrumbs.filePath');
        BreadcrumbsConfig.SymbolPath = BreadcrumbsConfig._stub('breadcrumbs.symbolPath');
        BreadcrumbsConfig.FilterOnType = BreadcrumbsConfig._stub('breadcrumbs.filterOnType');
        BreadcrumbsConfig.FileExcludes = BreadcrumbsConfig._stub('files.exclude');
        return BreadcrumbsConfig;
    }());
    exports.BreadcrumbsConfig = BreadcrumbsConfig;
    platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).registerConfiguration({
        id: 'breadcrumbs',
        title: nls_1.localize('title', "Breadcrumb Navigation"),
        order: 101,
        type: 'object',
        properties: {
            'breadcrumbs.enabled': {
                description: nls_1.localize('enabled', "Enable/disable navigation breadcrumbs"),
                type: 'boolean',
                default: false
            },
            // 'breadcrumbs.useQuickPick': {
            // 	description: localize('useQuickPick', "Use quick pick instead of breadcrumb-pickers."),
            // 	type: 'boolean',
            // 	default: false
            // },
            'breadcrumbs.filePath': {
                description: nls_1.localize('filepath', "Controls whether and how file paths are shown in the breadcrumbs view."),
                type: 'string',
                default: 'on',
                enum: ['on', 'off', 'last'],
                enumDescriptions: [
                    nls_1.localize('filepath.on', "Show the file path in the breadcrumbs view."),
                    nls_1.localize('filepath.off', "Do not show the file path in the breadcrumbs view."),
                    nls_1.localize('filepath.last', "Only show the last element of the file path in the breadcrumbs view."),
                ]
            },
            'breadcrumbs.symbolPath': {
                description: nls_1.localize('symbolpath', "Controls whether and how symbols are shown in the breadcrumbs view."),
                type: 'string',
                default: 'on',
                enum: ['on', 'off', 'last'],
                enumDescriptions: [
                    nls_1.localize('symbolpath.on', "Show all symbols in the breadcrumbs view."),
                    nls_1.localize('symbolpath.off', "Do not show symbols in the breadcrumbs view."),
                    nls_1.localize('symbolpath.last', "Only show the current symbol in the breadcrumbs view."),
                ]
            },
        }
    });
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[204/*vs/workbench/browser/parts/editor/breadcrumbsModel*/], __M([0/*require*/,1/*exports*/,19/*vs/base/common/arrays*/,17/*vs/base/common/async*/,55/*vs/base/common/cancellation*/,118/*vs/base/common/collections*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,35/*vs/base/common/resources*/,85/*vs/editor/common/modes*/,126/*vs/editor/contrib/documentSymbols/outlineModel*/,20/*vs/platform/workspace/common/workspace*/,26/*vs/base/common/network*/,7/*vs/platform/configuration/common/configuration*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,16/*vs/platform/files/common/files*/]), function (require, exports, arrays_1, async_1, cancellation_1, collections_1, errors_1, event_1, lifecycle_1, resources_1, modes_1, outlineModel_1, workspace_1, network_1, configuration_1, breadcrumbs_1, files_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileElement = /** @class */ (function () {
        function FileElement(uri, kind) {
            this.uri = uri;
            this.kind = kind;
        }
        return FileElement;
    }());
    exports.FileElement = FileElement;
    var EditorBreadcrumbsModel = /** @class */ (function () {
        function EditorBreadcrumbsModel(_uri, _editor, workspaceService, configurationService) {
            var _this = this;
            this._uri = _uri;
            this._editor = _editor;
            this._disposables = [];
            this._outlineElements = [];
            this._outlineDisposables = [];
            this._onDidUpdate = new event_1.Emitter();
            this.onDidUpdate = this._onDidUpdate.event;
            this._cfgFilePath = breadcrumbs_1.BreadcrumbsConfig.FilePath.bindTo(configurationService);
            this._cfgSymbolPath = breadcrumbs_1.BreadcrumbsConfig.SymbolPath.bindTo(configurationService);
            this._disposables.push(this._cfgFilePath.onDidChange(function (_) { return _this._onDidUpdate.fire(_this); }));
            this._disposables.push(this._cfgSymbolPath.onDidChange(function (_) { return _this._onDidUpdate.fire(_this); }));
            this._fileInfo = EditorBreadcrumbsModel._initFilePathInfo(this._uri, workspaceService);
            this._bindToEditor();
            this._onDidUpdate.fire(this);
        }
        EditorBreadcrumbsModel.prototype.dispose = function () {
            this._cfgFilePath.dispose();
            this._cfgSymbolPath.dispose();
            lifecycle_1.dispose(this._disposables);
        };
        EditorBreadcrumbsModel.prototype.isRelative = function () {
            return Boolean(this._fileInfo.folder);
        };
        EditorBreadcrumbsModel.prototype.getElements = function () {
            var result = [];
            // file path elements
            if (this._cfgFilePath.getValue() === 'on') {
                result = result.concat(this._fileInfo.path);
            }
            else if (this._cfgFilePath.getValue() === 'last' && this._fileInfo.path.length > 0) {
                result = result.concat(this._fileInfo.path.slice(-1));
            }
            // symbol path elements
            if (this._cfgSymbolPath.getValue() === 'on') {
                result = result.concat(this._outlineElements);
            }
            else if (this._cfgSymbolPath.getValue() === 'last' && this._outlineElements.length > 0) {
                result = result.concat(this._outlineElements.slice(-1));
            }
            return result;
        };
        EditorBreadcrumbsModel._initFilePathInfo = function (uri, workspaceService) {
            if (uri.scheme === network_1.Schemas.untitled) {
                return {
                    folder: undefined,
                    path: []
                };
            }
            var info = {
                folder: workspaceService.getWorkspaceFolder(uri),
                path: []
            };
            while (uri.path !== '/') {
                if (info.folder && resources_1.isEqual(info.folder.uri, uri)) {
                    break;
                }
                info.path.unshift(new FileElement(uri, info.path.length === 0 ? files_1.FileKind.FILE : files_1.FileKind.FOLDER));
                uri = resources_1.dirname(uri);
            }
            if (info.folder && workspaceService.getWorkbenchState() === 3 /* WORKSPACE */) {
                info.path.unshift(new FileElement(info.folder.uri, files_1.FileKind.ROOT_FOLDER));
            }
            return info;
        };
        EditorBreadcrumbsModel.prototype._bindToEditor = function () {
            var _this = this;
            if (!this._editor) {
                return;
            }
            // update as model changes
            this._disposables.push(modes_1.DocumentSymbolProviderRegistry.onDidChange(function (_) { return _this._updateOutline(); }));
            this._disposables.push(this._editor.onDidChangeModel(function (_) { return _this._updateOutline(); }));
            this._disposables.push(this._editor.onDidChangeModelLanguage(function (_) { return _this._updateOutline(); }));
            this._disposables.push(event_1.debounceEvent(this._editor.onDidChangeModelContent, function (_) { return _; }, 350)(function (_) { return _this._updateOutline(true); }));
            this._updateOutline();
            // stop when editor dies
            this._disposables.push(this._editor.onDidDispose(function () { return _this._outlineDisposables = lifecycle_1.dispose(_this._outlineDisposables); }));
        };
        EditorBreadcrumbsModel.prototype._updateOutline = function (didChangeContent) {
            var _this = this;
            this._outlineDisposables = lifecycle_1.dispose(this._outlineDisposables);
            if (!didChangeContent) {
                this._updateOutlineElements([]);
            }
            var buffer = this._editor.getModel();
            if (!buffer || !modes_1.DocumentSymbolProviderRegistry.has(buffer) || !resources_1.isEqual(buffer.uri, this._uri)) {
                return;
            }
            var source = new cancellation_1.CancellationTokenSource();
            var versionIdThen = buffer.getVersionId();
            var timeout = new async_1.TimeoutTimer();
            this._outlineDisposables.push({
                dispose: function () {
                    source.cancel();
                    source.dispose();
                    timeout.dispose();
                }
            });
            outlineModel_1.OutlineModel.create(buffer, source.token).then(function (model) {
                if (outlineModel_1.TreeElement.empty(model)) {
                    // empty -> no outline elements
                    _this._updateOutlineElements([]);
                }
                else {
                    // copy the model
                    model = model.adopt();
                    _this._updateOutlineElements(_this._getOutlineElements(model, _this._editor.getPosition()));
                    _this._outlineDisposables.push(_this._editor.onDidChangeCursorPosition(function (_) {
                        timeout.cancelAndSet(function () {
                            if (!buffer.isDisposed() && versionIdThen === buffer.getVersionId() && _this._editor.getModel()) {
                                _this._updateOutlineElements(_this._getOutlineElements(model, _this._editor.getPosition()));
                            }
                        }, 150);
                    }));
                }
            }).catch(function (err) {
                _this._updateOutlineElements([]);
                errors_1.onUnexpectedError(err);
            });
        };
        EditorBreadcrumbsModel.prototype._getOutlineElements = function (model, position) {
            if (!model) {
                return [];
            }
            var item = model.getItemEnclosingPosition(position);
            if (!item) {
                return [model];
            }
            var chain = [];
            while (item) {
                chain.push(item);
                var parent_1 = item.parent;
                if (parent_1 instanceof outlineModel_1.OutlineModel) {
                    break;
                }
                if (parent_1 instanceof outlineModel_1.OutlineGroup && collections_1.size(parent_1.parent.children) === 1) {
                    break;
                }
                item = parent_1;
            }
            return chain.reverse();
        };
        EditorBreadcrumbsModel.prototype._updateOutlineElements = function (elements) {
            if (!arrays_1.equals(elements, this._outlineElements, EditorBreadcrumbsModel._outlineElementEquals)) {
                this._outlineElements = elements;
                this._onDidUpdate.fire(this);
            }
        };
        EditorBreadcrumbsModel._outlineElementEquals = function (a, b) {
            if (a === b) {
                return true;
            }
            else if (!a || !b) {
                return false;
            }
            else {
                return a.id === b.id;
            }
        };
        EditorBreadcrumbsModel = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, configuration_1.IConfigurationService)
        ], EditorBreadcrumbsModel);
        return EditorBreadcrumbsModel;
    }());
    exports.EditorBreadcrumbsModel = EditorBreadcrumbsModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[200/*vs/workbench/browser/parts/editor/editorWidgets*/], __M([0/*require*/,1/*exports*/,95/*vs/base/browser/ui/widget*/,45/*vs/editor/browser/editorBrowser*/,6/*vs/base/common/event*/,31/*vs/platform/keybinding/common/keybinding*/,14/*vs/platform/theme/common/themeService*/,8/*vs/base/browser/dom*/,40/*vs/platform/theme/common/styler*/,30/*vs/platform/theme/common/colorRegistry*/,3/*vs/platform/instantiation/common/instantiation*/,42/*vs/platform/windows/common/windows*/,20/*vs/platform/workspace/common/workspace*/,26/*vs/base/common/network*/,160/*vs/platform/workspaces/common/workspaces*/,24/*vs/base/common/paths*/,4/*vs/base/common/lifecycle*/,2/*vs/nls*/,35/*vs/base/common/resources*/]), function (require, exports, widget_1, editorBrowser_1, event_1, keybinding_1, themeService_1, dom_1, styler_1, colorRegistry_1, instantiation_1, windows_1, workspace_1, network_1, workspaces_1, paths_1, lifecycle_1, nls_1, resources_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FloatingClickWidget = /** @class */ (function (_super) {
        __extends(FloatingClickWidget, _super);
        function FloatingClickWidget(editor, label, keyBindingAction, keybindingService, themeService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.label = label;
            _this.themeService = themeService;
            _this._onClick = _this._register(new event_1.Emitter());
            if (keyBindingAction) {
                var keybinding = keybindingService.lookupKeybinding(keyBindingAction);
                if (keybinding) {
                    _this.label += " (" + keybinding.getLabel() + ")";
                }
            }
            return _this;
        }
        Object.defineProperty(FloatingClickWidget.prototype, "onClick", {
            get: function () { return this._onClick.event; },
            enumerable: true,
            configurable: true
        });
        FloatingClickWidget.prototype.getId = function () {
            return 'editor.overlayWidget.floatingClickWidget';
        };
        FloatingClickWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        FloatingClickWidget.prototype.getPosition = function () {
            return {
                preference: editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER
            };
        };
        FloatingClickWidget.prototype.render = function () {
            var _this = this;
            this._domNode = dom_1.$('.floating-click-widget');
            this._register(styler_1.attachStylerCallback(this.themeService, { buttonBackground: colorRegistry_1.buttonBackground, buttonForeground: colorRegistry_1.buttonForeground, editorBackground: colorRegistry_1.editorBackground, editorForeground: colorRegistry_1.editorForeground, contrastBorder: colorRegistry_1.contrastBorder }, function (colors) {
                _this._domNode.style.backgroundColor = colors.buttonBackground ? colors.buttonBackground.toString() : colors.editorBackground.toString();
                _this._domNode.style.color = colors.buttonForeground ? colors.buttonForeground.toString() : colors.editorForeground.toString();
                var borderColor = colors.contrastBorder ? colors.contrastBorder.toString() : null;
                _this._domNode.style.borderWidth = borderColor ? '1px' : null;
                _this._domNode.style.borderStyle = borderColor ? 'solid' : null;
                _this._domNode.style.borderColor = borderColor;
            }));
            dom_1.append(this._domNode, dom_1.$('')).textContent = this.label;
            this.onclick(this._domNode, function (e) { return _this._onClick.fire(); });
            this.editor.addOverlayWidget(this);
        };
        FloatingClickWidget.prototype.dispose = function () {
            this.editor.removeOverlayWidget(this);
            _super.prototype.dispose.call(this);
        };
        FloatingClickWidget = __decorate([
            __param(3, keybinding_1.IKeybindingService),
            __param(4, themeService_1.IThemeService)
        ], FloatingClickWidget);
        return FloatingClickWidget;
    }(widget_1.Widget));
    exports.FloatingClickWidget = FloatingClickWidget;
    var OpenWorkspaceButtonContribution = /** @class */ (function (_super) {
        __extends(OpenWorkspaceButtonContribution, _super);
        function OpenWorkspaceButtonContribution(editor, instantiationService, windowService, contextService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.instantiationService = instantiationService;
            _this.windowService = windowService;
            _this.contextService = contextService;
            _this.update();
            _this.registerListeners();
            return _this;
        }
        OpenWorkspaceButtonContribution.get = function (editor) {
            return editor.getContribution(OpenWorkspaceButtonContribution.ID);
        };
        OpenWorkspaceButtonContribution.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.editor.onDidChangeModel(function (e) { return _this.update(); }));
        };
        OpenWorkspaceButtonContribution.prototype.getId = function () {
            return OpenWorkspaceButtonContribution.ID;
        };
        OpenWorkspaceButtonContribution.prototype.update = function () {
            if (!this.shouldShowButton(this.editor)) {
                this.disposeOpenWorkspaceWidgetRenderer();
                return;
            }
            this.createOpenWorkspaceWidgetRenderer();
        };
        OpenWorkspaceButtonContribution.prototype.shouldShowButton = function (editor) {
            var model = editor.getModel();
            if (!model) {
                return false; // we need a model
            }
            if (model.uri.scheme !== network_1.Schemas.file || paths_1.extname(model.uri.fsPath) !== "." + workspaces_1.WORKSPACE_EXTENSION) {
                return false; // we need a local workspace file
            }
            if (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */) {
                var workspaceConfiguration = this.contextService.getWorkspace().configuration;
                if (workspaceConfiguration && resources_1.isEqual(workspaceConfiguration, model.uri)) {
                    return false; // already inside workspace
                }
            }
            return true;
        };
        OpenWorkspaceButtonContribution.prototype.createOpenWorkspaceWidgetRenderer = function () {
            var _this = this;
            if (!this.openWorkspaceButton) {
                this.openWorkspaceButton = this.instantiationService.createInstance(FloatingClickWidget, this.editor, nls_1.localize('openWorkspace', "Open Workspace"), null);
                this._register(this.openWorkspaceButton.onClick(function () { return _this.windowService.openWindow([_this.editor.getModel().uri]); }));
                this.openWorkspaceButton.render();
            }
        };
        OpenWorkspaceButtonContribution.prototype.disposeOpenWorkspaceWidgetRenderer = function () {
            this.openWorkspaceButton = lifecycle_1.dispose(this.openWorkspaceButton);
        };
        OpenWorkspaceButtonContribution.prototype.dispose = function () {
            this.disposeOpenWorkspaceWidgetRenderer();
            _super.prototype.dispose.call(this);
        };
        OpenWorkspaceButtonContribution.ID = 'editor.contrib.openWorkspaceButton';
        OpenWorkspaceButtonContribution = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, windows_1.IWindowService),
            __param(3, workspace_1.IWorkspaceContextService)
        ], OpenWorkspaceButtonContribution);
        return OpenWorkspaceButtonContribution;
    }(lifecycle_1.Disposable));
    exports.OpenWorkspaceButtonContribution = OpenWorkspaceButtonContribution;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[290/*vs/workbench/browser/parts/quickinput/quickInputBox*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,139/*vs/base/browser/ui/inputbox/inputBox*/,30/*vs/platform/theme/common/colorRegistry*/,4/*vs/base/common/lifecycle*/,68/*vs/base/browser/keyboardEvent*/,196/*vs/base/common/severity*/,129/*vs/css!vs/workbench/browser/parts/quickinput/quickInput*/]), function (require, exports, dom, inputBox_1, colorRegistry_1, lifecycle_1, keyboardEvent_1, severity_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = dom.$;
    var QuickInputBox = /** @class */ (function () {
        function QuickInputBox(parent) {
            var _this = this;
            this.parent = parent;
            this.disposables = [];
            this.onKeyDown = function (handler) {
                return dom.addDisposableListener(_this.inputBox.inputElement, dom.EventType.KEY_DOWN, function (e) {
                    handler(new keyboardEvent_1.StandardKeyboardEvent(e));
                });
            };
            this.onDidChange = function (handler) {
                return _this.inputBox.onDidChange(handler);
            };
            this.container = dom.append(this.parent, $('.quick-input-box'));
            this.inputBox = new inputBox_1.InputBox(this.container, null);
            this.disposables.push(this.inputBox);
        }
        Object.defineProperty(QuickInputBox.prototype, "value", {
            get: function () {
                return this.inputBox.value;
            },
            set: function (value) {
                this.inputBox.value = value;
            },
            enumerable: true,
            configurable: true
        });
        QuickInputBox.prototype.select = function (range) {
            if (range === void 0) { range = null; }
            this.inputBox.select(range);
        };
        QuickInputBox.prototype.setPlaceholder = function (placeholder) {
            this.inputBox.setPlaceHolder(placeholder);
        };
        Object.defineProperty(QuickInputBox.prototype, "placeholder", {
            get: function () {
                return this.inputBox.inputElement.getAttribute('placeholder');
            },
            set: function (placeholder) {
                this.inputBox.setPlaceHolder(placeholder);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInputBox.prototype, "password", {
            get: function () {
                return this.inputBox.inputElement.type === 'password';
            },
            set: function (password) {
                this.inputBox.inputElement.type = password ? 'password' : 'text';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInputBox.prototype, "enabled", {
            set: function (enabled) {
                this.inputBox.setEnabled(enabled);
            },
            enumerable: true,
            configurable: true
        });
        QuickInputBox.prototype.setAttribute = function (name, value) {
            this.inputBox.inputElement.setAttribute(name, value);
        };
        QuickInputBox.prototype.removeAttribute = function (name) {
            this.inputBox.inputElement.removeAttribute(name);
        };
        QuickInputBox.prototype.showDecoration = function (decoration) {
            if (decoration === severity_1.default.Ignore) {
                this.inputBox.hideMessage();
            }
            else {
                this.inputBox.showMessage({ type: decoration === severity_1.default.Info ? 1 /* INFO */ : decoration === severity_1.default.Warning ? 2 /* WARNING */ : 3 /* ERROR */, content: '' });
            }
        };
        QuickInputBox.prototype.setFocus = function () {
            this.inputBox.focus();
        };
        QuickInputBox.prototype.layout = function () {
            this.inputBox.layout();
        };
        QuickInputBox.prototype.style = function (theme) {
            this.inputBox.style({
                inputForeground: theme.getColor(colorRegistry_1.inputForeground),
                inputBackground: theme.getColor(colorRegistry_1.inputBackground),
                inputBorder: theme.getColor(colorRegistry_1.inputBorder),
                inputValidationInfoBackground: theme.getColor(colorRegistry_1.inputValidationInfoBackground),
                inputValidationInfoForeground: theme.getColor(colorRegistry_1.inputValidationInfoForeground),
                inputValidationInfoBorder: theme.getColor(colorRegistry_1.inputValidationInfoBorder),
                inputValidationWarningBackground: theme.getColor(colorRegistry_1.inputValidationWarningBackground),
                inputValidationWarningForeground: theme.getColor(colorRegistry_1.inputValidationWarningForeground),
                inputValidationWarningBorder: theme.getColor(colorRegistry_1.inputValidationWarningBorder),
                inputValidationErrorBackground: theme.getColor(colorRegistry_1.inputValidationErrorBackground),
                inputValidationErrorForeground: theme.getColor(colorRegistry_1.inputValidationErrorForeground),
                inputValidationErrorBorder: theme.getColor(colorRegistry_1.inputValidationErrorBorder),
            });
        };
        QuickInputBox.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return QuickInputBox;
    }());
    exports.QuickInputBox = QuickInputBox;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[195/*vs/workbench/browser/parts/quickinput/quickInputUtils*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,163/*vs/base/common/idGenerator*/,129/*vs/css!vs/workbench/browser/parts/quickinput/quickInput*/]), function (require, exports, dom, idGenerator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var iconPathToClass = {};
    var iconClassGenerator = new idGenerator_1.IdGenerator('quick-input-button-icon-');
    function getIconClass(iconPath) {
        var iconClass;
        var key = iconPath.dark.toString();
        if (iconPathToClass[key]) {
            iconClass = iconPathToClass[key];
        }
        else {
            iconClass = iconClassGenerator.nextId();
            dom.createCSSRule("." + iconClass, "background-image: url(\"" + (iconPath.light || iconPath.dark).toString() + "\")");
            dom.createCSSRule(".vs-dark ." + iconClass + ", .hc-black ." + iconClass, "background-image: url(\"" + iconPath.dark.toString() + "\")");
            iconPathToClass[key] = iconClass;
        }
        return iconClass;
    }
    exports.getIconClass = getIconClass;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[297/*vs/workbench/browser/parts/quickinput/quickInputList*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,4/*vs/base/common/lifecycle*/,51/*vs/platform/list/browser/listService*/,3/*vs/platform/instantiation/common/instantiation*/,289/*vs/base/common/octicon*/,166/*vs/base/common/comparers*/,6/*vs/base/common/event*/,38/*vs/base/common/objects*/,68/*vs/base/browser/keyboardEvent*/,194/*vs/base/browser/ui/iconLabel/iconLabel*/,208/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,146/*vs/base/common/decorators*/,19/*vs/base/common/arrays*/,18/*vs/base/common/platform*/,30/*vs/platform/theme/common/colorRegistry*/,14/*vs/platform/theme/common/themeService*/,50/*vs/base/browser/ui/actionbar/actionbar*/,15/*vs/base/common/actions*/,195/*vs/workbench/browser/parts/quickinput/quickInputUtils*/,129/*vs/css!vs/workbench/browser/parts/quickinput/quickInput*/]), function (require, exports, dom, lifecycle_1, listService_1, instantiation_1, octicon_1, comparers_1, event_1, objects_1, keyboardEvent_1, iconLabel_1, highlightedLabel_1, decorators_1, arrays_1, platform, colorRegistry_1, themeService_1, actionbar_1, actions_1, quickInputUtils_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = dom.$;
    var ListElement = /** @class */ (function () {
        function ListElement(init) {
            this.hidden = false;
            this._onChecked = new event_1.Emitter();
            this.onChecked = this._onChecked.event;
            objects_1.assign(this, init);
        }
        Object.defineProperty(ListElement.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (value) {
                if (value !== this._checked) {
                    this._checked = value;
                    this._onChecked.fire(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        return ListElement;
    }());
    var ListElementRenderer = /** @class */ (function () {
        function ListElementRenderer() {
        }
        Object.defineProperty(ListElementRenderer.prototype, "templateId", {
            get: function () {
                return ListElementRenderer.ID;
            },
            enumerable: true,
            configurable: true
        });
        ListElementRenderer.prototype.renderTemplate = function (container) {
            var data = Object.create(null);
            data.toDisposeElement = [];
            data.toDisposeTemplate = [];
            data.entry = dom.append(container, $('.quick-input-list-entry'));
            // Checkbox
            var label = dom.append(data.entry, $('label.quick-input-list-label'));
            data.checkbox = dom.append(label, $('input.quick-input-list-checkbox'));
            data.checkbox.type = 'checkbox';
            data.toDisposeTemplate.push(dom.addStandardDisposableListener(data.checkbox, dom.EventType.CHANGE, function (e) {
                data.element.checked = data.checkbox.checked;
            }));
            // Rows
            var rows = dom.append(label, $('.quick-input-list-rows'));
            var row1 = dom.append(rows, $('.quick-input-list-row'));
            var row2 = dom.append(rows, $('.quick-input-list-row'));
            // Label
            data.label = new iconLabel_1.IconLabel(row1, { supportHighlights: true, supportDescriptionHighlights: true });
            // Detail
            var detailContainer = dom.append(row2, $('.quick-input-list-label-meta'));
            data.detail = new highlightedLabel_1.HighlightedLabel(detailContainer);
            // Separator
            data.separator = dom.append(data.entry, $('.quick-input-list-separator'));
            // Actions
            data.actionBar = new actionbar_1.ActionBar(data.entry);
            data.actionBar.domNode.classList.add('quick-input-list-entry-action-bar');
            data.toDisposeTemplate.push(data.actionBar);
            return data;
        };
        ListElementRenderer.prototype.renderElement = function (element, index, data) {
            data.toDisposeElement = lifecycle_1.dispose(data.toDisposeElement);
            data.element = element;
            data.checkbox.checked = element.checked;
            data.toDisposeElement.push(element.onChecked(function (checked) { return data.checkbox.checked = checked; }));
            var labelHighlights = element.labelHighlights, descriptionHighlights = element.descriptionHighlights, detailHighlights = element.detailHighlights;
            // Label
            var options = Object.create(null);
            options.matches = labelHighlights || [];
            options.descriptionTitle = element.saneDescription;
            options.descriptionMatches = descriptionHighlights || [];
            options.extraClasses = element.item.iconClasses;
            data.label.setValue(element.saneLabel, element.saneDescription, options);
            // Meta
            data.detail.set(element.saneDetail, detailHighlights);
            // ARIA label
            data.entry.setAttribute('aria-label', [element.saneLabel, element.saneDescription, element.saneDetail]
                .map(function (s) { return s && octicon_1.parseOcticons(s).text; })
                .filter(function (s) { return !!s; })
                .join(', '));
            // Separator
            if (element.separator && element.separator.label) {
                data.separator.textContent = element.separator.label;
                data.separator.style.display = null;
            }
            else {
                data.separator.style.display = 'none';
            }
            if (element.separator) {
                dom.addClass(data.entry, 'quick-input-list-separator-border');
            }
            else {
                dom.removeClass(data.entry, 'quick-input-list-separator-border');
            }
            // Actions
            data.actionBar.clear();
            var buttons = element.item.buttons;
            if (buttons && buttons.length) {
                data.actionBar.push(buttons.map(function (button, index) {
                    var action = new actions_1.Action("id-" + index, '', button.iconClass || quickInputUtils_1.getIconClass(button.iconPath), true, function () {
                        element.fireButtonTriggered({
                            button: button,
                            item: element.item
                        });
                        return null;
                    });
                    action.tooltip = button.tooltip;
                    return action;
                }), { icon: true, label: false });
                dom.addClass(data.entry, 'has-actions');
            }
            else {
                dom.removeClass(data.entry, 'has-actions');
            }
        };
        ListElementRenderer.prototype.disposeElement = function (element, index, data) {
            data.toDisposeElement = lifecycle_1.dispose(data.toDisposeElement);
        };
        ListElementRenderer.prototype.disposeTemplate = function (data) {
            data.toDisposeElement = lifecycle_1.dispose(data.toDisposeElement);
            data.toDisposeTemplate = lifecycle_1.dispose(data.toDisposeTemplate);
        };
        ListElementRenderer.ID = 'listelement';
        return ListElementRenderer;
    }());
    var ListElementDelegate = /** @class */ (function () {
        function ListElementDelegate() {
        }
        ListElementDelegate.prototype.getHeight = function (element) {
            return element.saneDetail ? 44 : 22;
        };
        ListElementDelegate.prototype.getTemplateId = function (element) {
            return ListElementRenderer.ID;
        };
        return ListElementDelegate;
    }());
    var QuickInputList = /** @class */ (function () {
        function QuickInputList(parent, id, instantiationService) {
            var _this = this;
            this.parent = parent;
            this.instantiationService = instantiationService;
            this.elements = [];
            this.elementsToIndexes = new Map();
            this.matchOnDescription = false;
            this.matchOnDetail = false;
            this._onChangedAllVisibleChecked = new event_1.Emitter();
            this.onChangedAllVisibleChecked = this._onChangedAllVisibleChecked.event;
            this._onChangedCheckedCount = new event_1.Emitter();
            this.onChangedCheckedCount = this._onChangedCheckedCount.event;
            this._onChangedVisibleCount = new event_1.Emitter();
            this.onChangedVisibleCount = this._onChangedVisibleCount.event;
            this._onChangedCheckedElements = new event_1.Emitter();
            this.onChangedCheckedElements = this._onChangedCheckedElements.event;
            this._onButtonTriggered = new event_1.Emitter();
            this.onButtonTriggered = this._onButtonTriggered.event;
            this._onLeave = new event_1.Emitter();
            this.onLeave = this._onLeave.event;
            this._fireCheckedEvents = true;
            this.elementDisposables = [];
            this.disposables = [];
            this.id = id;
            this.container = dom.append(this.parent, $('.quick-input-list'));
            var delegate = new ListElementDelegate();
            this.list = this.instantiationService.createInstance(listService_1.WorkbenchList, this.container, delegate, [new ListElementRenderer()], {
                identityProvider: function (element) { return element.label; },
                openController: { shouldOpen: function () { return false; } },
                multipleSelectionSupport: false
            });
            this.list.getHTMLElement().id = id;
            this.disposables.push(this.list);
            this.disposables.push(this.list.onKeyDown(function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                switch (event.keyCode) {
                    case 10 /* Space */:
                        _this.toggleCheckbox();
                        break;
                    case 31 /* KEY_A */:
                        if (platform.isMacintosh ? e.metaKey : e.ctrlKey) {
                            _this.list.setFocus(arrays_1.range(_this.list.length));
                        }
                        break;
                    case 16 /* UpArrow */:
                    case 11 /* PageUp */:
                        var focus1 = _this.list.getFocus();
                        if (focus1.length === 1 && focus1[0] === 0) {
                            _this._onLeave.fire();
                        }
                        break;
                    case 18 /* DownArrow */:
                    case 12 /* PageDown */:
                        var focus2 = _this.list.getFocus();
                        if (focus2.length === 1 && focus2[0] === _this.list.length - 1) {
                            _this._onLeave.fire();
                        }
                        break;
                }
            }));
            this.disposables.push(dom.addDisposableListener(this.container, dom.EventType.CLICK, function (e) {
                if (e.x || e.y) { // Avoid 'click' triggered by 'space' on checkbox.
                    _this._onLeave.fire();
                }
            }));
            this.disposables.push(this.list.onSelectionChange(function (e) {
                if (e.elements.length) {
                    _this.list.setSelection([]);
                }
            }));
        }
        Object.defineProperty(QuickInputList.prototype, "onDidChangeFocus", {
            get: function () {
                return event_1.mapEvent(this.list.onFocusChange, function (e) { return e.elements.map(function (e) { return e.item; }); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInputList.prototype, "onDidChangeSelection", {
            get: function () {
                return event_1.mapEvent(this.list.onSelectionChange, function (e) { return e.elements.map(function (e) { return e.item; }); });
            },
            enumerable: true,
            configurable: true
        });
        QuickInputList.prototype.getAllVisibleChecked = function () {
            return this.allVisibleChecked(this.elements, false);
        };
        QuickInputList.prototype.allVisibleChecked = function (elements, whenNoneVisible) {
            if (whenNoneVisible === void 0) { whenNoneVisible = true; }
            for (var i = 0, n = elements.length; i < n; i++) {
                var element = elements[i];
                if (!element.hidden) {
                    if (!element.checked) {
                        return false;
                    }
                    else {
                        whenNoneVisible = true;
                    }
                }
            }
            return whenNoneVisible;
        };
        QuickInputList.prototype.getCheckedCount = function () {
            var count = 0;
            var elements = this.elements;
            for (var i = 0, n = elements.length; i < n; i++) {
                if (elements[i].checked) {
                    count++;
                }
            }
            return count;
        };
        QuickInputList.prototype.getVisibleCount = function () {
            var count = 0;
            var elements = this.elements;
            for (var i = 0, n = elements.length; i < n; i++) {
                if (!elements[i].hidden) {
                    count++;
                }
            }
            return count;
        };
        QuickInputList.prototype.setAllVisibleChecked = function (checked) {
            try {
                this._fireCheckedEvents = false;
                this.elements.forEach(function (element) {
                    if (!element.hidden) {
                        element.checked = checked;
                    }
                });
            }
            finally {
                this._fireCheckedEvents = true;
                this.fireCheckedEvents();
            }
        };
        QuickInputList.prototype.setElements = function (inputElements) {
            var _this = this;
            var _a;
            this.elementDisposables = lifecycle_1.dispose(this.elementDisposables);
            var fireButtonTriggered = function (event) { return _this.fireButtonTriggered(event); };
            this.inputElements = inputElements;
            this.elements = inputElements.reduce(function (result, item, index) {
                if (item.type !== 'separator') {
                    var previous = index && inputElements[index - 1];
                    result.push(new ListElement({
                        index: index,
                        item: item,
                        saneLabel: item.label && item.label.replace(/\r?\n/g, ' '),
                        saneDescription: item.description && item.description.replace(/\r?\n/g, ' '),
                        saneDetail: item.detail && item.detail.replace(/\r?\n/g, ' '),
                        checked: false,
                        separator: previous && previous.type === 'separator' ? previous : undefined,
                        fireButtonTriggered: fireButtonTriggered
                    }));
                }
                return result;
            }, []);
            (_a = this.elementDisposables).push.apply(_a, this.elements.map(function (element) { return element.onChecked(function () { return _this.fireCheckedEvents(); }); }));
            this.elementsToIndexes = this.elements.reduce(function (map, element, index) {
                map.set(element.item, index);
                return map;
            }, new Map());
            this.list.splice(0, this.list.length, this.elements);
            this.list.setFocus([]);
            this._onChangedVisibleCount.fire(this.elements.length);
        };
        QuickInputList.prototype.getFocusedElements = function () {
            return this.list.getFocusedElements()
                .map(function (e) { return e.item; });
        };
        QuickInputList.prototype.setFocusedElements = function (items) {
            var _this = this;
            this.list.setFocus(items
                .filter(function (item) { return _this.elementsToIndexes.has(item); })
                .map(function (item) { return _this.elementsToIndexes.get(item); }));
        };
        QuickInputList.prototype.getActiveDescendant = function () {
            return this.list.getHTMLElement().getAttribute('aria-activedescendant');
        };
        QuickInputList.prototype.getSelectedElements = function () {
            return this.list.getSelectedElements()
                .map(function (e) { return e.item; });
        };
        QuickInputList.prototype.setSelectedElements = function (items) {
            var _this = this;
            this.list.setSelection(items
                .filter(function (item) { return _this.elementsToIndexes.has(item); })
                .map(function (item) { return _this.elementsToIndexes.get(item); }));
        };
        QuickInputList.prototype.getCheckedElements = function () {
            return this.elements.filter(function (e) { return e.checked; })
                .map(function (e) { return e.item; });
        };
        QuickInputList.prototype.setCheckedElements = function (items) {
            try {
                this._fireCheckedEvents = false;
                var checked = new Set();
                for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                    var item = items_1[_i];
                    checked.add(item);
                }
                for (var _a = 0, _b = this.elements; _a < _b.length; _a++) {
                    var element = _b[_a];
                    element.checked = checked.has(element.item);
                }
            }
            finally {
                this._fireCheckedEvents = true;
                this.fireCheckedEvents();
            }
        };
        Object.defineProperty(QuickInputList.prototype, "enabled", {
            set: function (value) {
                this.list.getHTMLElement().style.pointerEvents = value ? null : 'none';
            },
            enumerable: true,
            configurable: true
        });
        QuickInputList.prototype.focus = function (what) {
            if (!this.list.length) {
                return;
            }
            if ((what === 'Next' || what === 'NextPage') && this.list.getFocus()[0] === this.list.length - 1) {
                what = 'First';
            }
            if ((what === 'Previous' || what === 'PreviousPage') && this.list.getFocus()[0] === 0) {
                what = 'Last';
            }
            this.list['focus' + what]();
            this.list.reveal(this.list.getFocus()[0]);
        };
        QuickInputList.prototype.clearFocus = function () {
            this.list.setFocus([]);
        };
        QuickInputList.prototype.domFocus = function () {
            this.list.domFocus();
        };
        QuickInputList.prototype.layout = function () {
            this.list.layout();
        };
        QuickInputList.prototype.filter = function (query) {
            var _this = this;
            query = query.trim();
            // Reset filtering
            if (!query) {
                this.elements.forEach(function (element) {
                    element.labelHighlights = undefined;
                    element.descriptionHighlights = undefined;
                    element.detailHighlights = undefined;
                    element.hidden = false;
                    var previous = element.index && _this.inputElements[element.index - 1];
                    element.separator = previous && previous.type === 'separator' ? previous : undefined;
                });
            }
            // Filter by value (since we support octicons, use octicon aware fuzzy matching)
            else {
                this.elements.forEach(function (element) {
                    var labelHighlights = octicon_1.matchesFuzzyOcticonAware(query, octicon_1.parseOcticons(element.saneLabel));
                    var descriptionHighlights = _this.matchOnDescription ? octicon_1.matchesFuzzyOcticonAware(query, octicon_1.parseOcticons(element.saneDescription || '')) : undefined;
                    var detailHighlights = _this.matchOnDetail ? octicon_1.matchesFuzzyOcticonAware(query, octicon_1.parseOcticons(element.saneDetail || '')) : undefined;
                    if (labelHighlights || descriptionHighlights || detailHighlights) {
                        element.labelHighlights = labelHighlights;
                        element.descriptionHighlights = descriptionHighlights;
                        element.detailHighlights = detailHighlights;
                        element.hidden = false;
                    }
                    else {
                        element.labelHighlights = undefined;
                        element.descriptionHighlights = undefined;
                        element.detailHighlights = undefined;
                        element.hidden = !element.item.alwaysShow;
                    }
                    element.separator = undefined;
                });
            }
            var shownElements = this.elements.filter(function (element) { return !element.hidden; });
            // Sort by value
            if (query) {
                var normalizedSearchValue_1 = query.toLowerCase();
                shownElements.sort(function (a, b) {
                    return compareEntries(a, b, normalizedSearchValue_1);
                });
            }
            this.elementsToIndexes = shownElements.reduce(function (map, element, index) {
                map.set(element.item, index);
                return map;
            }, new Map());
            this.list.splice(0, this.list.length, shownElements);
            this.list.setFocus([]);
            this.list.layout();
            this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
            this._onChangedVisibleCount.fire(shownElements.length);
        };
        QuickInputList.prototype.toggleCheckbox = function () {
            try {
                this._fireCheckedEvents = false;
                var elements = this.list.getFocusedElements();
                var allChecked = this.allVisibleChecked(elements);
                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                    var element = elements_1[_i];
                    element.checked = !allChecked;
                }
            }
            finally {
                this._fireCheckedEvents = true;
                this.fireCheckedEvents();
            }
        };
        QuickInputList.prototype.display = function (display) {
            this.container.style.display = display ? '' : 'none';
        };
        QuickInputList.prototype.isDisplayed = function () {
            return this.container.style.display !== 'none';
        };
        QuickInputList.prototype.dispose = function () {
            this.elementDisposables = lifecycle_1.dispose(this.elementDisposables);
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        QuickInputList.prototype.fireCheckedEvents = function () {
            if (this._fireCheckedEvents) {
                this._onChangedAllVisibleChecked.fire(this.getAllVisibleChecked());
                this._onChangedCheckedCount.fire(this.getCheckedCount());
                this._onChangedCheckedElements.fire(this.getCheckedElements());
            }
        };
        QuickInputList.prototype.fireButtonTriggered = function (event) {
            this._onButtonTriggered.fire(event);
        };
        __decorate([
            decorators_1.memoize
        ], QuickInputList.prototype, "onDidChangeFocus", null);
        __decorate([
            decorators_1.memoize
        ], QuickInputList.prototype, "onDidChangeSelection", null);
        QuickInputList = __decorate([
            __param(2, instantiation_1.IInstantiationService)
        ], QuickInputList);
        return QuickInputList;
    }());
    exports.QuickInputList = QuickInputList;
    function compareEntries(elementA, elementB, lookFor) {
        var labelHighlightsA = elementA.labelHighlights || [];
        var labelHighlightsB = elementB.labelHighlights || [];
        if (labelHighlightsA.length && !labelHighlightsB.length) {
            return -1;
        }
        if (!labelHighlightsA.length && labelHighlightsB.length) {
            return 1;
        }
        return comparers_1.compareAnything(elementA.saneLabel, elementB.saneLabel, lookFor);
    }
    themeService_1.registerThemingParticipant(function (theme, collector) {
        // Override inactive focus background with active focus background for single-pick case.
        var listInactiveFocusBackground = theme.getColor(colorRegistry_1.listFocusBackground);
        if (listInactiveFocusBackground) {
            collector.addRule(".quick-input-list .monaco-list .monaco-list-row.focused { background-color:  " + listInactiveFocusBackground + "; }");
            collector.addRule(".quick-input-list .monaco-list .monaco-list-row.focused:hover { background-color:  " + listInactiveFocusBackground + "; }");
        }
        var pickerGroupBorderColor = theme.getColor(colorRegistry_1.pickerGroupBorder);
        if (pickerGroupBorderColor) {
            collector.addRule(".quick-input-list .quick-input-list-entry { border-top-color:  " + pickerGroupBorderColor + "; }");
        }
        var pickerGroupForegroundColor = theme.getColor(colorRegistry_1.pickerGroupForeground);
        if (pickerGroupForegroundColor) {
            collector.addRule(".quick-input-list .quick-input-list-separator { color:  " + pickerGroupForegroundColor + "; }");
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[102/*vs/workbench/browser/parts/quickopen/quickopen*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,15/*vs/base/common/actions*/,46/*vs/platform/quickOpen/common/quickOpen*/,62/*vs/platform/quickinput/common/quickInput*/,31/*vs/platform/keybinding/common/keybinding*/,10/*vs/platform/contextkey/common/contextkey*/,37/*vs/platform/commands/common/commands*/]), function (require, exports, nls, actions_1, quickOpen_1, quickInput_1, keybinding_1, contextkey_1, commands_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inQuickOpenContext = contextkey_1.ContextKeyExpr.has('inQuickOpen');
    exports.defaultQuickOpenContextKey = 'inFilesPicker';
    exports.defaultQuickOpenContext = contextkey_1.ContextKeyExpr.and(exports.inQuickOpenContext, contextkey_1.ContextKeyExpr.has(exports.defaultQuickOpenContextKey));
    exports.QUICKOPEN_ACTION_ID = 'workbench.action.quickOpen';
    exports.QUICKOPEN_ACION_LABEL = nls.localize('quickOpen', "Go to File...");
    commands_1.CommandsRegistry.registerCommand(exports.QUICKOPEN_ACTION_ID, function (accessor, prefix) {
        if (prefix === void 0) { prefix = null; }
        var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
        return quickOpenService.show(typeof prefix === 'string' ? prefix : null).then(function () {
            return void 0;
        });
    });
    exports.QUICKOPEN_FOCUS_SECONDARY_ACTION_ID = 'workbench.action.quickOpenPreviousEditor';
    commands_1.CommandsRegistry.registerCommand(exports.QUICKOPEN_FOCUS_SECONDARY_ACTION_ID, function (accessor, prefix) {
        if (prefix === void 0) { prefix = null; }
        var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
        return quickOpenService.show(null, { autoFocus: { autoFocusSecondEntry: true } }).then(function () {
            return void 0;
        });
    });
    var BaseQuickOpenNavigateAction = /** @class */ (function (_super) {
        __extends(BaseQuickOpenNavigateAction, _super);
        function BaseQuickOpenNavigateAction(id, label, next, quickNavigate, quickOpenService, quickInputService, keybindingService) {
            var _this = _super.call(this, id, label) || this;
            _this.next = next;
            _this.quickNavigate = quickNavigate;
            _this.quickOpenService = quickOpenService;
            _this.quickInputService = quickInputService;
            _this.keybindingService = keybindingService;
            return _this;
        }
        BaseQuickOpenNavigateAction.prototype.run = function (event) {
            var keys = this.keybindingService.lookupKeybindings(this.id);
            var quickNavigate = this.quickNavigate ? { keybindings: keys } : void 0;
            this.quickOpenService.navigate(this.next, quickNavigate);
            this.quickInputService.navigate(this.next, quickNavigate);
            return Promise.resolve(true);
        };
        BaseQuickOpenNavigateAction = __decorate([
            __param(4, quickOpen_1.IQuickOpenService),
            __param(5, quickInput_1.IQuickInputService),
            __param(6, keybinding_1.IKeybindingService)
        ], BaseQuickOpenNavigateAction);
        return BaseQuickOpenNavigateAction;
    }(actions_1.Action));
    exports.BaseQuickOpenNavigateAction = BaseQuickOpenNavigateAction;
    function getQuickNavigateHandler(id, next) {
        return function (accessor) {
            var keybindingService = accessor.get(keybinding_1.IKeybindingService);
            var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            var keys = keybindingService.lookupKeybindings(id);
            var quickNavigate = { keybindings: keys };
            quickOpenService.navigate(next, quickNavigate);
            quickInputService.navigate(next, quickNavigate);
        };
    }
    exports.getQuickNavigateHandler = getQuickNavigateHandler;
    var QuickOpenNavigateNextAction = /** @class */ (function (_super) {
        __extends(QuickOpenNavigateNextAction, _super);
        function QuickOpenNavigateNextAction(id, label, quickOpenService, quickInputService, keybindingService) {
            return _super.call(this, id, label, true, true, quickOpenService, quickInputService, keybindingService) || this;
        }
        QuickOpenNavigateNextAction.ID = 'workbench.action.quickOpenNavigateNext';
        QuickOpenNavigateNextAction.LABEL = nls.localize('quickNavigateNext', "Navigate Next in Quick Open");
        QuickOpenNavigateNextAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, quickInput_1.IQuickInputService),
            __param(4, keybinding_1.IKeybindingService)
        ], QuickOpenNavigateNextAction);
        return QuickOpenNavigateNextAction;
    }(BaseQuickOpenNavigateAction));
    exports.QuickOpenNavigateNextAction = QuickOpenNavigateNextAction;
    var QuickOpenNavigatePreviousAction = /** @class */ (function (_super) {
        __extends(QuickOpenNavigatePreviousAction, _super);
        function QuickOpenNavigatePreviousAction(id, label, quickOpenService, quickInputService, keybindingService) {
            return _super.call(this, id, label, false, true, quickOpenService, quickInputService, keybindingService) || this;
        }
        QuickOpenNavigatePreviousAction.ID = 'workbench.action.quickOpenNavigatePrevious';
        QuickOpenNavigatePreviousAction.LABEL = nls.localize('quickNavigatePrevious', "Navigate Previous in Quick Open");
        QuickOpenNavigatePreviousAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, quickInput_1.IQuickInputService),
            __param(4, keybinding_1.IKeybindingService)
        ], QuickOpenNavigatePreviousAction);
        return QuickOpenNavigatePreviousAction;
    }(BaseQuickOpenNavigateAction));
    exports.QuickOpenNavigatePreviousAction = QuickOpenNavigatePreviousAction;
    var QuickOpenSelectNextAction = /** @class */ (function (_super) {
        __extends(QuickOpenSelectNextAction, _super);
        function QuickOpenSelectNextAction(id, label, quickOpenService, quickInputService, keybindingService) {
            return _super.call(this, id, label, true, false, quickOpenService, quickInputService, keybindingService) || this;
        }
        QuickOpenSelectNextAction.ID = 'workbench.action.quickOpenSelectNext';
        QuickOpenSelectNextAction.LABEL = nls.localize('quickSelectNext', "Select Next in Quick Open");
        QuickOpenSelectNextAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, quickInput_1.IQuickInputService),
            __param(4, keybinding_1.IKeybindingService)
        ], QuickOpenSelectNextAction);
        return QuickOpenSelectNextAction;
    }(BaseQuickOpenNavigateAction));
    exports.QuickOpenSelectNextAction = QuickOpenSelectNextAction;
    var QuickOpenSelectPreviousAction = /** @class */ (function (_super) {
        __extends(QuickOpenSelectPreviousAction, _super);
        function QuickOpenSelectPreviousAction(id, label, quickOpenService, quickInputService, keybindingService) {
            return _super.call(this, id, label, false, false, quickOpenService, quickInputService, keybindingService) || this;
        }
        QuickOpenSelectPreviousAction.ID = 'workbench.action.quickOpenSelectPrevious';
        QuickOpenSelectPreviousAction.LABEL = nls.localize('quickSelectPrevious', "Select Previous in Quick Open");
        QuickOpenSelectPreviousAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, quickInput_1.IQuickInputService),
            __param(4, keybinding_1.IKeybindingService)
        ], QuickOpenSelectPreviousAction);
        return QuickOpenSelectPreviousAction;
    }(BaseQuickOpenNavigateAction));
    exports.QuickOpenSelectPreviousAction = QuickOpenSelectPreviousAction;
});

define(__m[191/*vs/workbench/browser/parts/statusbar/statusbar*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,120/*vs/platform/instantiation/common/descriptors*/]), function (require, exports, platform_1, descriptors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var StatusbarItemDescriptor = /** @class */ (function () {
        function StatusbarItemDescriptor(ctor, alignment, priority) {
            this.syncDescriptor = descriptors_1.createSyncDescriptor(ctor);
            this.alignment = alignment || 0 /* LEFT */;
            this.priority = priority || 0;
        }
        return StatusbarItemDescriptor;
    }());
    exports.StatusbarItemDescriptor = StatusbarItemDescriptor;
    var StatusbarRegistry = /** @class */ (function () {
        function StatusbarRegistry() {
            this._items = [];
        }
        Object.defineProperty(StatusbarRegistry.prototype, "items", {
            get: function () {
                return this._items;
            },
            enumerable: true,
            configurable: true
        });
        StatusbarRegistry.prototype.registerStatusbarItem = function (descriptor) {
            this._items.push(descriptor);
        };
        return StatusbarRegistry;
    }());
    exports.Extensions = {
        Statusbar: 'workbench.contributions.statusbar'
    };
    platform_1.Registry.add(exports.Extensions.Statusbar, new StatusbarRegistry());
});

define(__m[47/*vs/workbench/common/actions*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,9/*vs/platform/registry/common/platform*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,37/*vs/platform/commands/common/commands*/,23/*vs/platform/actions/common/actions*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/,63/*vs/platform/lifecycle/common/lifecycle*/,28/*vs/platform/notification/common/notification*/]), function (require, exports, winjs_base_1, platform_1, keybindingsRegistry_1, commands_1, actions_1, instantiation_1, lifecycle_1, lifecycle_2, notification_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        WorkbenchActions: 'workbench.contributions.actions'
    };
    platform_1.Registry.add(exports.Extensions.WorkbenchActions, new /** @class */ (function () {
        function class_1() {
        }
        class_1.prototype.registerWorkbenchAction = function (descriptor, alias, category, when) {
            return this._registerWorkbenchCommandFromAction(descriptor, alias, category, when);
        };
        class_1.prototype._registerWorkbenchCommandFromAction = function (descriptor, alias, category, when) {
            var registrations = [];
            // command
            registrations.push(commands_1.CommandsRegistry.registerCommand(descriptor.id, this._createCommandHandler(descriptor)));
            // keybinding
            var weight = (typeof descriptor.keybindingWeight === 'undefined' ? 200 /* WorkbenchContrib */ : descriptor.keybindingWeight);
            var keybindings = descriptor.keybindings;
            keybindingsRegistry_1.KeybindingsRegistry.registerKeybindingRule({
                id: descriptor.id,
                weight: weight,
                when: descriptor.keybindingContext,
                primary: keybindings && keybindings.primary,
                secondary: keybindings && keybindings.secondary,
                win: keybindings && keybindings.win,
                mac: keybindings && keybindings.mac,
                linux: keybindings && keybindings.linux
            });
            // menu item
            // TODO@Rob slightly weird if-check required because of
            // https://github.com/Microsoft/vscode/blob/master/src/vs/workbench/parts/search/electron-browser/search.contribution.ts#L266
            if (descriptor.label) {
                var idx = alias.indexOf(': ');
                var categoryOriginal = void 0;
                if (idx > 0) {
                    categoryOriginal = alias.substr(0, idx);
                    alias = alias.substr(idx + 2);
                }
                var command = {
                    id: descriptor.id,
                    title: { value: descriptor.label, original: alias },
                    category: category && { value: category, original: categoryOriginal }
                };
                actions_1.MenuRegistry.addCommand(command);
                registrations.push(actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, { command: command, when: when }));
            }
            // TODO@alex,joh
            // support removal of keybinding rule
            // support removal of command-ui
            return lifecycle_1.combinedDisposable(registrations);
        };
        class_1.prototype._createCommandHandler = function (descriptor) {
            var _this = this;
            return function (accessor, args) {
                var notificationService = accessor.get(notification_1.INotificationService);
                var instantiationService = accessor.get(instantiation_1.IInstantiationService);
                var lifecycleService = accessor.get(lifecycle_2.ILifecycleService);
                winjs_base_1.TPromise.as(_this._triggerAndDisposeAction(instantiationService, lifecycleService, descriptor, args)).then(null, function (err) {
                    notificationService.error(err);
                });
            };
        };
        class_1.prototype._triggerAndDisposeAction = function (instantiationService, lifecycleService, descriptor, args) {
            // run action when workbench is created
            return lifecycleService.when(3 /* Running */).then(function () {
                var actionInstance = instantiationService.createInstance(descriptor.syncDescriptor);
                try {
                    actionInstance.label = descriptor.label || actionInstance.label;
                    // don't run the action when not enabled
                    if (!actionInstance.enabled) {
                        actionInstance.dispose();
                        return void 0;
                    }
                    var from = args && args.from || 'keybinding';
                    return winjs_base_1.TPromise.as(actionInstance.run(undefined, { from: from })).then(function () {
                        actionInstance.dispose();
                    }, function (err) {
                        actionInstance.dispose();
                        return winjs_base_1.TPromise.wrapError(err);
                    });
                }
                catch (err) {
                    actionInstance.dispose();
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
        };
        return class_1;
    }()));
});

define(__m[314/*vs/codesandbox/services/codesandbox/codesandbox.contribution*/], __M([0/*require*/,1/*exports*/,23/*vs/platform/actions/common/actions*/,12/*vs/base/common/uri*/,9/*vs/platform/registry/common/platform*/,47/*vs/workbench/common/actions*/,65/*vs/base/common/keyCodes*/,375/*vs/codesandbox/services/codesandbox/codesandboxActions*/]), function (require, exports, actions_1, uri_1, platform_1, actions_2, keyCodes_1, codesandboxActions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var registry = platform_1.Registry.as(actions_2.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(codesandboxActions_1.CodeSandboxTogglePreviewAction, codesandboxActions_1.CodeSandboxTogglePreviewAction.ID, codesandboxActions_1.CodeSandboxTogglePreviewAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 34 /* KEY_D */ }), 'CodeSandbox: Toggle Preview', 'CodeSandbox');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(codesandboxActions_1.CodeSandboxOpenPreviewExternalAction, codesandboxActions_1.CodeSandboxOpenPreviewExternalAction.ID, codesandboxActions_1.CodeSandboxOpenPreviewExternalAction.LABEL, { primary: 0 }), 'CodeSandbox: Open Preview In New Window', 'CodeSandbox');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(codesandboxActions_1.CodeSandboxSetThemeAction, codesandboxActions_1.CodeSandboxSetThemeAction.ID, codesandboxActions_1.CodeSandboxSetThemeAction.LABEL, {
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 50 /* KEY_T */),
    }), 'Preferences: Color Theme', 'Preferences');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(codesandboxActions_1.CodeSandboxAddDependencyAction, codesandboxActions_1.CodeSandboxAddDependencyAction.ID, codesandboxActions_1.CodeSandboxAddDependencyAction.LABEL, {
        primary: 0
    }), 'CodeSandbox: Add NPM Dependency', 'CodeSandbox');
    function appendEditorToolItem(primary, order) {
        var item = {
            command: {
                id: primary.id,
                title: primary.title,
                iconLocation: {
                    dark: uri_1.URI.parse(require.toUrl("vs/codesandbox/services/codesandbox/assets/preview.svg")),
                    light: uri_1.URI.parse(require.toUrl("vs/codesandbox/services/codesandbox/assets/preview-dark.svg")),
                },
            },
            group: 'navigation',
            order: order,
        };
        actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorTitle, item);
    }
    appendEditorToolItem({
        id: codesandboxActions_1.CodeSandboxTogglePreviewAction.ID,
        title: codesandboxActions_1.CodeSandboxTogglePreviewAction.LABEL,
    }, 10000);
});























define(__m[315/*vs/workbench/browser/actions/toggleTabsVisibility*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,7/*vs/platform/configuration/common/configuration*/]), function (require, exports, nls, platform_1, actions_1, actions_2, actions_3, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleTabsVisibilityAction = /** @class */ (function (_super) {
        __extends(ToggleTabsVisibilityAction, _super);
        function ToggleTabsVisibilityAction(id, label, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.configurationService = configurationService;
            return _this;
        }
        ToggleTabsVisibilityAction.prototype.run = function () {
            var visibility = this.configurationService.getValue(ToggleTabsVisibilityAction.tabsVisibleKey);
            var newVisibilityValue = !visibility;
            return this.configurationService.updateValue(ToggleTabsVisibilityAction.tabsVisibleKey, newVisibilityValue);
        };
        ToggleTabsVisibilityAction.ID = 'workbench.action.toggleTabsVisibility';
        ToggleTabsVisibilityAction.LABEL = nls.localize('toggleTabs', "Toggle Tab Visibility");
        ToggleTabsVisibilityAction.tabsVisibleKey = 'workbench.editor.showTabs';
        ToggleTabsVisibilityAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleTabsVisibilityAction);
        return ToggleTabsVisibilityAction;
    }(actions_1.Action));
    exports.ToggleTabsVisibilityAction = ToggleTabsVisibilityAction;
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleTabsVisibilityAction, ToggleTabsVisibilityAction.ID, ToggleTabsVisibilityAction.LABEL, { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 53 /* KEY_W */ }), 'View: Toggle Tab Visibility', nls.localize('view', "View"));
});

define(__m[107/*vs/workbench/common/contributions*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,17/*vs/base/common/async*/]), function (require, exports, platform_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Extensions;
    (function (Extensions) {
        Extensions.Workbench = 'workbench.contributions.kind';
    })(Extensions = exports.Extensions || (exports.Extensions = {}));
    var WorkbenchContributionsRegistry = /** @class */ (function () {
        function WorkbenchContributionsRegistry() {
            this.toBeInstantiated = new Map();
        }
        WorkbenchContributionsRegistry.prototype.registerWorkbenchContribution = function (ctor, phase) {
            if (phase === void 0) { phase = 1 /* Starting */; }
            // Instantiate directly if we are already matching the provided phase
            if (this.instantiationService && this.lifecycleService && this.lifecycleService.phase >= phase) {
                this.instantiationService.createInstance(ctor);
            }
            // Otherwise keep contributions by lifecycle phase
            else {
                var toBeInstantiated = this.toBeInstantiated.get(phase);
                if (!toBeInstantiated) {
                    toBeInstantiated = [];
                    this.toBeInstantiated.set(phase, toBeInstantiated);
                }
                toBeInstantiated.push(ctor);
            }
        };
        WorkbenchContributionsRegistry.prototype.start = function (instantiationService, lifecycleService) {
            var _this = this;
            this.instantiationService = instantiationService;
            this.lifecycleService = lifecycleService;
            [1 /* Starting */, 2 /* Restoring */, 3 /* Running */, 4 /* Eventually */].forEach(function (phase) {
                _this.instantiateByPhase(instantiationService, lifecycleService, phase);
            });
        };
        WorkbenchContributionsRegistry.prototype.instantiateByPhase = function (instantiationService, lifecycleService, phase) {
            var _this = this;
            // Instantiate contributions directly when phase is already reached
            if (lifecycleService.phase >= phase) {
                this.doInstantiateByPhase(instantiationService, phase);
            }
            // Otherwise wait for phase to be reached
            else {
                lifecycleService.when(phase).then(function () {
                    _this.doInstantiateByPhase(instantiationService, phase);
                });
            }
        };
        WorkbenchContributionsRegistry.prototype.doInstantiateByPhase = function (instantiationService, phase) {
            var toBeInstantiated = this.toBeInstantiated.get(phase);
            if (toBeInstantiated) {
                this.toBeInstantiated.delete(phase);
                if (phase !== 4 /* Eventually */) {
                    // instantiate everything synchronously and blocking
                    for (var _i = 0, toBeInstantiated_1 = toBeInstantiated; _i < toBeInstantiated_1.length; _i++) {
                        var ctor = toBeInstantiated_1[_i];
                        instantiationService.createInstance(ctor);
                    }
                }
                else {
                    // for the Eventually-phase we instantiate contributions
                    // only when idle. this might take a few idle-busy-cycles
                    // but will finish within the timeouts
                    var forcedTimeout_1 = 3000;
                    var i_1 = 0;
                    var instantiateSome_1 = function (idle) {
                        while (i_1 < toBeInstantiated.length) {
                            var ctor = toBeInstantiated[i_1++];
                            instantiationService.createInstance(ctor);
                            if (idle.timeRemaining() < 1) {
                                // time is up -> reschedule
                                async_1.runWhenIdle(instantiateSome_1, forcedTimeout_1);
                                break;
                            }
                        }
                    };
                    async_1.runWhenIdle(instantiateSome_1, forcedTimeout_1);
                }
            }
        };
        return WorkbenchContributionsRegistry;
    }());
    platform_1.Registry.add(Extensions.Workbench, new WorkbenchContributionsRegistry());
});














define(__m[13/*vs/workbench/common/editor*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,6/*vs/base/common/event*/,38/*vs/base/common/objects*/,29/*vs/base/common/types*/,4/*vs/base/common/lifecycle*/,10/*vs/platform/contextkey/common/contextkey*/,9/*vs/platform/registry/common/platform*/,26/*vs/base/common/network*/,15/*vs/base/common/actions*/]), function (require, exports, winjs_base_1, event_1, objects, types, lifecycle_1, contextkey_1, platform_1, network_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActiveEditorContext = new contextkey_1.RawContextKey('activeEditor', null);
    exports.EditorsVisibleContext = new contextkey_1.RawContextKey('editorIsOpen', false);
    exports.EditorGroupActiveEditorDirtyContext = new contextkey_1.RawContextKey('groupActiveEditorDirty', false);
    exports.NoEditorsVisibleContext = exports.EditorsVisibleContext.toNegated();
    exports.TextCompareEditorVisibleContext = new contextkey_1.RawContextKey('textCompareEditorVisible', false);
    exports.TextCompareEditorActiveContext = new contextkey_1.RawContextKey('textCompareEditorActive', false);
    exports.ActiveEditorGroupEmptyContext = new contextkey_1.RawContextKey('activeEditorGroupEmpty', false);
    exports.MultipleEditorGroupsContext = new contextkey_1.RawContextKey('multipleEditorGroups', false);
    exports.SingleEditorGroupsContext = exports.MultipleEditorGroupsContext.toNegated();
    exports.InEditorZenModeContext = new contextkey_1.RawContextKey('inZenMode', false);
    exports.SplitEditorsVertically = new contextkey_1.RawContextKey('splitEditorsVertically', false);
    /**
     * Text diff editor id.
     */
    exports.TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';
    /**
     * Binary diff editor id.
     */
    exports.BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';
    /**
     * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
     * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
     */
    var EditorInput = /** @class */ (function (_super) {
        __extends(EditorInput, _super);
        function EditorInput() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeLabel = _this._register(new event_1.Emitter());
            _this._onDispose = _this._register(new event_1.Emitter());
            _this.disposed = false;
            return _this;
        }
        Object.defineProperty(EditorInput.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDidChangeLabel", {
            get: function () { return this._onDidChangeLabel.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorInput.prototype, "onDispose", {
            get: function () { return this._onDispose.event; },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the associated resource of this input if any.
         */
        EditorInput.prototype.getResource = function () {
            return null;
        };
        /**
         * Returns the name of this input that can be shown to the user. Examples include showing the name of the input
         * above the editor area when the input is shown.
         */
        EditorInput.prototype.getName = function () {
            return null;
        };
        /**
         * Returns the description of this input that can be shown to the user. Examples include showing the description of
         * the input above the editor area to the side of the name of the input.
         */
        EditorInput.prototype.getDescription = function (verbosity) {
            return null;
        };
        /**
         * Returns the title of this input that can be shown to the user. Examples include showing the title of
         * the input above the editor area as hover over the input label.
         */
        EditorInput.prototype.getTitle = function (verbosity) {
            return this.getName();
        };
        /**
         * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered
         * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.
         */
        EditorInput.prototype.getPreferredEditorId = function (candidates) {
            if (candidates && candidates.length > 0) {
                return candidates[0];
            }
            return null;
        };
        /**
         * Returns a descriptor suitable for telemetry events or null if none is available.
         *
         * Subclasses should extend if they can contribute.
         */
        EditorInput.prototype.getTelemetryDescriptor = function () {
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "typeId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            return { typeId: this.getTypeId() };
        };
        /**
         * An editor that is dirty will be asked to be saved once it closes.
         */
        EditorInput.prototype.isDirty = function () {
            return false;
        };
        /**
         * Subclasses should bring up a proper dialog for the user if the editor is dirty and return the result.
         */
        EditorInput.prototype.confirmSave = function () {
            return winjs_base_1.TPromise.wrap(1 /* DONT_SAVE */);
        };
        /**
         * Saves the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.save = function () {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Reverts the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
         */
        EditorInput.prototype.revert = function (options) {
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Called when this input is no longer opened in any editor. Subclasses can free resources as needed.
         */
        EditorInput.prototype.close = function () {
            this.dispose();
        };
        /**
         * Subclasses can set this to false if it does not make sense to split the editor input.
         */
        EditorInput.prototype.supportsSplitEditor = function () {
            return true;
        };
        /**
         * Returns true if this input is identical to the otherInput.
         */
        EditorInput.prototype.matches = function (otherInput) {
            return this === otherInput;
        };
        /**
         * Returns whether this input was disposed or not.
         */
        EditorInput.prototype.isDisposed = function () {
            return this.disposed;
        };
        /**
         * Called when an editor input is no longer needed. Allows to free up any resources taken by
         * resolving the editor input.
         */
        EditorInput.prototype.dispose = function () {
            this.disposed = true;
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        return EditorInput;
    }(lifecycle_1.Disposable));
    exports.EditorInput = EditorInput;
    /**
     * Side by side editor inputs that have a master and details side.
     */
    var SideBySideEditorInput = /** @class */ (function (_super) {
        __extends(SideBySideEditorInput, _super);
        function SideBySideEditorInput(name, description, _details, _master) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.description = description;
            _this._details = _details;
            _this._master = _master;
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(SideBySideEditorInput.prototype, "master", {
            get: function () {
                return this._master;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditorInput.prototype, "details", {
            get: function () {
                return this._details;
            },
            enumerable: true,
            configurable: true
        });
        SideBySideEditorInput.prototype.isDirty = function () {
            return this.master.isDirty();
        };
        SideBySideEditorInput.prototype.confirmSave = function () {
            return this.master.confirmSave();
        };
        SideBySideEditorInput.prototype.save = function () {
            return this.master.save();
        };
        SideBySideEditorInput.prototype.revert = function () {
            return this.master.revert();
        };
        SideBySideEditorInput.prototype.getTelemetryDescriptor = function () {
            var descriptor = this.master.getTelemetryDescriptor();
            return objects.assign(descriptor, _super.prototype.getTelemetryDescriptor.call(this));
        };
        SideBySideEditorInput.prototype.registerListeners = function () {
            var _this = this;
            // When the details or master input gets disposed, dispose this diff editor input
            var onceDetailsDisposed = event_1.once(this.details.onDispose);
            this._register(onceDetailsDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            var onceMasterDisposed = event_1.once(this.master.onDispose);
            this._register(onceMasterDisposed(function () {
                if (!_this.isDisposed()) {
                    _this.dispose();
                }
            }));
            // Reemit some events from the master side to the outside
            this._register(this.master.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this._register(this.master.onDidChangeLabel(function () { return _this._onDidChangeLabel.fire(); }));
        };
        SideBySideEditorInput.prototype.resolve = function () {
            return winjs_base_1.TPromise.as(null);
        };
        SideBySideEditorInput.prototype.getTypeId = function () {
            return SideBySideEditorInput.ID;
        };
        SideBySideEditorInput.prototype.getName = function () {
            return this.name;
        };
        SideBySideEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        SideBySideEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput) {
                if (!(otherInput instanceof SideBySideEditorInput)) {
                    return false;
                }
                var otherDiffInput = otherInput;
                return this.details.matches(otherDiffInput.details) && this.master.matches(otherDiffInput.master);
            }
            return false;
        };
        SideBySideEditorInput.ID = 'workbench.editorinputs.sidebysideEditorInput';
        return SideBySideEditorInput;
    }(EditorInput));
    exports.SideBySideEditorInput = SideBySideEditorInput;
    /**
     * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it
     * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models
     * are typically cached for some while because they are expensive to construct.
     */
    var EditorModel = /** @class */ (function (_super) {
        __extends(EditorModel, _super);
        function EditorModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onDispose = _this._register(new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(EditorModel.prototype, "onDispose", {
            get: function () { return this._onDispose.event; },
            enumerable: true,
            configurable: true
        });
        /**
         * Causes this model to load returning a promise when loading is completed.
         */
        EditorModel.prototype.load = function () {
            return winjs_base_1.TPromise.as(this);
        };
        /**
         * Returns whether this model was loaded or not.
         */
        EditorModel.prototype.isResolved = function () {
            return true;
        };
        /**
         * Subclasses should implement to free resources that have been claimed through loading.
         */
        EditorModel.prototype.dispose = function () {
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        return EditorModel;
    }(lifecycle_1.Disposable));
    exports.EditorModel = EditorModel;
    function isEditorInputWithOptions(obj) {
        var editorInputWithOptions = obj;
        return !!editorInputWithOptions && !!editorInputWithOptions.editor;
    }
    exports.isEditorInputWithOptions = isEditorInputWithOptions;
    /**
     * The editor options is the base class of options that can be passed in when opening an editor.
     */
    var EditorOptions = /** @class */ (function () {
        function EditorOptions() {
        }
        /**
         * Helper to create EditorOptions inline.
         */
        EditorOptions.create = function (settings) {
            var options = new EditorOptions();
            options.preserveFocus = settings.preserveFocus;
            options.forceReload = settings.forceReload;
            options.revealIfVisible = settings.revealIfVisible;
            options.revealIfOpened = settings.revealIfOpened;
            options.pinned = settings.pinned;
            options.index = settings.index;
            options.inactive = settings.inactive;
            return options;
        };
        return EditorOptions;
    }());
    exports.EditorOptions = EditorOptions;
    /**
     * Base Text Editor Options.
     */
    var TextEditorOptions = /** @class */ (function (_super) {
        __extends(TextEditorOptions, _super);
        function TextEditorOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextEditorOptions.from = function (input) {
            if (!input || !input.options) {
                return null;
            }
            return TextEditorOptions.create(input.options);
        };
        /**
         * Helper to convert options bag to real class
         */
        TextEditorOptions.create = function (options) {
            if (options === void 0) { options = Object.create(null); }
            var textEditorOptions = new TextEditorOptions();
            if (options.selection) {
                var selection = options.selection;
                textEditorOptions.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);
            }
            if (options.viewState) {
                textEditorOptions.editorViewState = options.viewState;
            }
            if (options.forceReload) {
                textEditorOptions.forceReload = true;
            }
            if (options.revealIfVisible) {
                textEditorOptions.revealIfVisible = true;
            }
            if (options.revealIfOpened) {
                textEditorOptions.revealIfOpened = true;
            }
            if (options.preserveFocus) {
                textEditorOptions.preserveFocus = true;
            }
            if (options.revealInCenterIfOutsideViewport) {
                textEditorOptions.revealInCenterIfOutsideViewport = true;
            }
            if (options.pinned) {
                textEditorOptions.pinned = true;
            }
            if (options.inactive) {
                textEditorOptions.inactive = true;
            }
            if (typeof options.index === 'number') {
                textEditorOptions.index = options.index;
            }
            return textEditorOptions;
        };
        /**
         * Returns if this options object has objects defined for the editor.
         */
        TextEditorOptions.prototype.hasOptionsDefined = function () {
            return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));
        };
        /**
         * Tells the editor to set show the given selection when the editor is being opened.
         */
        TextEditorOptions.prototype.selection = function (startLineNumber, startColumn, endLineNumber, endColumn) {
            if (endLineNumber === void 0) { endLineNumber = startLineNumber; }
            if (endColumn === void 0) { endColumn = startColumn; }
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
            return this;
        };
        /**
         * Create a TextEditorOptions inline to be used when the editor is opening.
         */
        TextEditorOptions.fromEditor = function (editor, settings) {
            var options = TextEditorOptions.create(settings);
            // View state
            options.editorViewState = editor.saveViewState();
            return options;
        };
        /**
         * Apply the view state or selection to the given editor.
         *
         * @return if something was applied
         */
        TextEditorOptions.prototype.apply = function (editor, scrollType) {
            // View state
            return this.applyViewState(editor, scrollType);
        };
        TextEditorOptions.prototype.applyViewState = function (editor, scrollType) {
            var gotApplied = false;
            // First try viewstate
            if (this.editorViewState) {
                editor.restoreViewState(this.editorViewState);
                gotApplied = true;
            }
            // Otherwise check for selection
            else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {
                // Select
                if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {
                    var range = {
                        startLineNumber: this.startLineNumber,
                        startColumn: this.startColumn,
                        endLineNumber: this.endLineNumber,
                        endColumn: this.endColumn
                    };
                    editor.setSelection(range);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealRangeInCenterIfOutsideViewport(range, scrollType);
                    }
                    else {
                        editor.revealRangeInCenter(range, scrollType);
                    }
                }
                // Reveal
                else {
                    var pos = {
                        lineNumber: this.startLineNumber,
                        column: this.startColumn
                    };
                    editor.setPosition(pos);
                    if (this.revealInCenterIfOutsideViewport) {
                        editor.revealPositionInCenterIfOutsideViewport(pos, scrollType);
                    }
                    else {
                        editor.revealPositionInCenter(pos, scrollType);
                    }
                }
                gotApplied = true;
            }
            return gotApplied;
        };
        return TextEditorOptions;
    }(EditorOptions));
    exports.TextEditorOptions = TextEditorOptions;
    var EditorCommandsContextActionRunner = /** @class */ (function (_super) {
        __extends(EditorCommandsContextActionRunner, _super);
        function EditorCommandsContextActionRunner(context) {
            var _this = _super.call(this) || this;
            _this.context = context;
            return _this;
        }
        EditorCommandsContextActionRunner.prototype.run = function (action, context) {
            return _super.prototype.run.call(this, action, this.context);
        };
        return EditorCommandsContextActionRunner;
    }(actions_1.ActionRunner));
    exports.EditorCommandsContextActionRunner = EditorCommandsContextActionRunner;
    function toResource(editor, options) {
        if (!editor) {
            return null;
        }
        // Check for side by side if we are asked to
        if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {
            editor = editor.master;
        }
        var resource = editor.getResource();
        if (!options || !options.filter) {
            return resource; // return early if no filter is specified
        }
        if (!resource) {
            return null;
        }
        var includeFiles;
        var includeUntitled;
        if (Array.isArray(options.filter)) {
            includeFiles = (options.filter.indexOf(network_1.Schemas.file) >= 0);
            includeUntitled = (options.filter.indexOf(network_1.Schemas.untitled) >= 0);
        }
        else {
            includeFiles = (options.filter === network_1.Schemas.file);
            includeUntitled = (options.filter === network_1.Schemas.untitled);
        }
        if (includeFiles && resource.scheme === network_1.Schemas.file) {
            return resource;
        }
        if (includeUntitled && resource.scheme === network_1.Schemas.untitled) {
            return resource;
        }
        return null;
    }
    exports.toResource = toResource;
    var EditorInputFactoryRegistry = /** @class */ (function () {
        function EditorInputFactoryRegistry() {
            this.editorInputFactoryConstructors = Object.create(null);
            this.editorInputFactoryInstances = Object.create(null);
        }
        EditorInputFactoryRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            for (var key in this.editorInputFactoryConstructors) {
                var element = this.editorInputFactoryConstructors[key];
                this.createEditorInputFactory(key, element);
            }
            this.editorInputFactoryConstructors = {};
        };
        EditorInputFactoryRegistry.prototype.createEditorInputFactory = function (editorInputId, ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.editorInputFactoryInstances[editorInputId] = instance;
        };
        EditorInputFactoryRegistry.prototype.registerFileInputFactory = function (factory) {
            this.fileInputFactory = factory;
        };
        EditorInputFactoryRegistry.prototype.getFileInputFactory = function () {
            return this.fileInputFactory;
        };
        EditorInputFactoryRegistry.prototype.registerEditorInputFactory = function (editorInputId, ctor) {
            if (!this.instantiationService) {
                this.editorInputFactoryConstructors[editorInputId] = ctor;
            }
            else {
                this.createEditorInputFactory(editorInputId, ctor);
            }
        };
        EditorInputFactoryRegistry.prototype.getEditorInputFactory = function (editorInputId) {
            return this.editorInputFactoryInstances[editorInputId];
        };
        return EditorInputFactoryRegistry;
    }());
    exports.Extensions = {
        EditorInputFactories: 'workbench.contributions.editor.inputFactories'
    };
    platform_1.Registry.add(exports.Extensions.EditorInputFactories, new EditorInputFactoryRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[87/*vs/workbench/browser/parts/editor/editor*/], __M([0/*require*/,1/*exports*/,13/*vs/workbench/common/editor*/,8/*vs/base/browser/dom*/,38/*vs/base/common/objects*/,45/*vs/editor/browser/editorBrowser*/]), function (require, exports, editor_1, dom_1, objects_1, editorBrowser_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EDITOR_TITLE_HEIGHT = 35;
    exports.DEFAULT_EDITOR_MIN_DIMENSIONS = new dom_1.Dimension(220, 70);
    exports.DEFAULT_EDITOR_MAX_DIMENSIONS = new dom_1.Dimension(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
    exports.DEFAULT_EDITOR_PART_OPTIONS = {
        showTabs: true,
        tabCloseButton: 'right',
        tabSizing: 'fit',
        showIcons: true,
        enablePreview: true,
        openPositioning: 'right',
        openSideBySideDirection: 'right',
        closeEmptyGroups: true,
        labelFormat: 'default',
        iconTheme: 'vs-seti'
    };
    function impactsEditorPartOptions(event) {
        return event.affectsConfiguration('workbench.editor') || event.affectsConfiguration('workbench.iconTheme');
    }
    exports.impactsEditorPartOptions = impactsEditorPartOptions;
    function getEditorPartOptions(config) {
        var options = objects_1.assign(Object.create(null), exports.DEFAULT_EDITOR_PART_OPTIONS);
        if (!config || !config.workbench) {
            return options;
        }
        if (typeof config.workbench.iconTheme === 'string') {
            options.iconTheme = config.workbench.iconTheme;
        }
        if (config.workbench.editor) {
            objects_1.assign(options, config.workbench.editor);
        }
        return options;
    }
    exports.getEditorPartOptions = getEditorPartOptions;
    function getActiveTextEditorOptions(group, expectedActiveEditor, presetOptions) {
        var activeGroupCodeEditor = group.activeControl ? editorBrowser_1.getCodeEditor(group.activeControl.getControl()) : void 0;
        if (activeGroupCodeEditor) {
            if (!expectedActiveEditor || expectedActiveEditor.matches(group.activeEditor)) {
                return editor_1.TextEditorOptions.fromEditor(activeGroupCodeEditor, presetOptions);
            }
        }
        return presetOptions || new editor_1.EditorOptions();
    }
    exports.getActiveTextEditorOptions = getActiveTextEditorOptions;
});














define(__m[190/*vs/workbench/common/editor/diffEditorModel*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/]), function (require, exports, winjs_base_1, editor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base editor model for the diff editor. It is made up of two editor models, the original version
     * and the modified version.
     */
    var DiffEditorModel = /** @class */ (function (_super) {
        __extends(DiffEditorModel, _super);
        function DiffEditorModel(originalModel, modifiedModel) {
            var _this = _super.call(this) || this;
            _this._originalModel = originalModel;
            _this._modifiedModel = modifiedModel;
            return _this;
        }
        Object.defineProperty(DiffEditorModel.prototype, "originalModel", {
            get: function () {
                return this._originalModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DiffEditorModel.prototype, "modifiedModel", {
            get: function () {
                return this._modifiedModel;
            },
            enumerable: true,
            configurable: true
        });
        DiffEditorModel.prototype.load = function () {
            var _this = this;
            return winjs_base_1.TPromise.join([
                this._originalModel.load(),
                this._modifiedModel.load()
            ]).then(function () {
                return _this;
            });
        };
        DiffEditorModel.prototype.isResolved = function () {
            return this.originalModel.isResolved() && this.modifiedModel.isResolved();
        };
        DiffEditorModel.prototype.dispose = function () {
            // Do not propagate the dispose() call to the two models inside. We never created the two models
            // (original and modified) so we can not dispose them without sideeffects. Rather rely on the
            // models getting disposed when their related inputs get disposed from the diffEditorInput.
            _super.prototype.dispose.call(this);
        };
        return DiffEditorModel;
    }(editor_1.EditorModel));
    exports.DiffEditorModel = DiffEditorModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[188/*vs/workbench/common/editor/editorGroup*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,13/*vs/workbench/common/editor*/,3/*vs/platform/instantiation/common/instantiation*/,7/*vs/platform/configuration/common/configuration*/,4/*vs/base/common/lifecycle*/,9/*vs/platform/registry/common/platform*/,39/*vs/base/common/map*/]), function (require, exports, event_1, editor_1, instantiation_1, configuration_1, lifecycle_1, platform_1, map_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditorOpenPositioning = {
        LEFT: 'left',
        RIGHT: 'right',
        FIRST: 'first',
        LAST: 'last'
    };
    function isSerializedEditorGroup(obj) {
        var group = obj;
        return obj && typeof obj === 'object' && Array.isArray(group.editors) && Array.isArray(group.mru);
    }
    exports.isSerializedEditorGroup = isSerializedEditorGroup;
    var EditorGroup = /** @class */ (function (_super) {
        __extends(EditorGroup, _super);
        function EditorGroup(labelOrSerializedGroup, instantiationService, configurationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.configurationService = configurationService;
            //#region events
            _this._onDidEditorActivate = _this._register(new event_1.Emitter());
            _this._onDidEditorOpen = _this._register(new event_1.Emitter());
            _this._onDidEditorClose = _this._register(new event_1.Emitter());
            _this._onDidEditorDispose = _this._register(new event_1.Emitter());
            _this._onDidEditorBecomeDirty = _this._register(new event_1.Emitter());
            _this._onDidEditorLabelChange = _this._register(new event_1.Emitter());
            _this._onDidEditorMove = _this._register(new event_1.Emitter());
            _this._onDidEditorPin = _this._register(new event_1.Emitter());
            _this._onDidEditorUnpin = _this._register(new event_1.Emitter());
            _this.editors = [];
            _this.mru = [];
            _this.mapResourceToEditorCount = new map_1.ResourceMap();
            if (isSerializedEditorGroup(labelOrSerializedGroup)) {
                _this.deserialize(labelOrSerializedGroup);
            }
            else {
                _this._id = EditorGroup.IDS++;
            }
            _this.onConfigurationUpdated();
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(EditorGroup.prototype, "onDidEditorActivate", {
            get: function () { return this._onDidEditorActivate.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorOpen", {
            get: function () { return this._onDidEditorOpen.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorClose", {
            get: function () { return this._onDidEditorClose.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorDispose", {
            get: function () { return this._onDidEditorDispose.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorBecomeDirty", {
            get: function () { return this._onDidEditorBecomeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorLabelChange", {
            get: function () { return this._onDidEditorLabelChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorMove", {
            get: function () { return this._onDidEditorMove.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorPin", {
            get: function () { return this._onDidEditorPin.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "onDidEditorUnpin", {
            get: function () { return this._onDidEditorUnpin.event; },
            enumerable: true,
            configurable: true
        });
        EditorGroup.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(e); }));
        };
        EditorGroup.prototype.onConfigurationUpdated = function (event) {
            this.editorOpenPositioning = this.configurationService.getValue('workbench.editor.openPositioning');
        };
        Object.defineProperty(EditorGroup.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroup.prototype, "count", {
            get: function () {
                return this.editors.length;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroup.prototype.getEditors = function (mru) {
            return mru ? this.mru.slice(0) : this.editors.slice(0);
        };
        EditorGroup.prototype.getEditor = function (arg1) {
            if (typeof arg1 === 'number') {
                return this.editors[arg1];
            }
            var resource = arg1;
            if (!this.contains(resource)) {
                return null; // fast check for resource opened or not
            }
            for (var i = 0; i < this.editors.length; i++) {
                var editor = this.editors[i];
                var editorResource = editor_1.toResource(editor, { supportSideBySide: true });
                if (editorResource && editorResource.toString() === resource.toString()) {
                    return editor;
                }
            }
            return null;
        };
        Object.defineProperty(EditorGroup.prototype, "activeEditor", {
            get: function () {
                return this.active;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroup.prototype.isActive = function (editor) {
            return this.matches(this.active, editor);
        };
        Object.defineProperty(EditorGroup.prototype, "previewEditor", {
            get: function () {
                return this.preview;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroup.prototype.isPreview = function (editor) {
            return this.matches(this.preview, editor);
        };
        EditorGroup.prototype.openEditor = function (editor, options) {
            var index = this.indexOf(editor);
            var makePinned = options && options.pinned;
            var makeActive = (options && options.active) || !this.activeEditor || (!makePinned && this.matches(this.preview, this.activeEditor));
            // New editor
            if (index === -1) {
                var targetIndex = void 0;
                var indexOfActive = this.indexOf(this.active);
                // Insert into specific position
                if (options && typeof options.index === 'number') {
                    targetIndex = options.index;
                }
                // Insert to the BEGINNING
                else if (this.editorOpenPositioning === EditorOpenPositioning.FIRST) {
                    targetIndex = 0;
                }
                // Insert to the END
                else if (this.editorOpenPositioning === EditorOpenPositioning.LAST) {
                    targetIndex = this.editors.length;
                }
                // Insert to the LEFT of active editor
                else if (this.editorOpenPositioning === EditorOpenPositioning.LEFT) {
                    if (indexOfActive === 0 || !this.editors.length) {
                        targetIndex = 0; // to the left becoming first editor in list
                    }
                    else {
                        targetIndex = indexOfActive; // to the left of active editor
                    }
                }
                // Insert to the RIGHT of active editor
                else {
                    targetIndex = indexOfActive + 1;
                }
                // Insert into our list of editors if pinned or we have no preview editor
                if (makePinned || !this.preview) {
                    this.splice(targetIndex, false, editor);
                }
                // Handle preview
                if (!makePinned) {
                    // Replace existing preview with this editor if we have a preview
                    if (this.preview) {
                        var indexOfPreview = this.indexOf(this.preview);
                        if (targetIndex > indexOfPreview) {
                            targetIndex--; // accomodate for the fact that the preview editor closes
                        }
                        this.replaceEditor(this.preview, editor, targetIndex, !makeActive);
                    }
                    this.preview = editor;
                }
                // Listeners
                this.registerEditorListeners(editor);
                // Event
                this._onDidEditorOpen.fire(editor);
                // Handle active
                if (makeActive) {
                    this.setActive(editor);
                }
            }
            // Existing editor
            else {
                // Pin it
                if (makePinned) {
                    this.pin(editor);
                }
                // Activate it
                if (makeActive) {
                    this.setActive(editor);
                }
                // Respect index
                if (options && typeof options.index === 'number') {
                    this.moveEditor(editor, options.index);
                }
            }
        };
        EditorGroup.prototype.registerEditorListeners = function (editor) {
            var _this = this;
            var unbind = [];
            // Re-emit disposal of editor input as our own event
            var onceDispose = event_1.once(editor.onDispose);
            unbind.push(onceDispose(function () {
                if (_this.indexOf(editor) >= 0) {
                    _this._onDidEditorDispose.fire(editor);
                }
            }));
            // Re-Emit dirty state changes
            unbind.push(editor.onDidChangeDirty(function () {
                _this._onDidEditorBecomeDirty.fire(editor);
            }));
            // Re-Emit label changes
            unbind.push(editor.onDidChangeLabel(function () {
                _this._onDidEditorLabelChange.fire(editor);
            }));
            // Clean up dispose listeners once the editor gets closed
            unbind.push(this.onDidEditorClose(function (event) {
                if (event.editor.matches(editor)) {
                    lifecycle_1.dispose(unbind);
                }
            }));
        };
        EditorGroup.prototype.replaceEditor = function (toReplace, replaceWidth, replaceIndex, openNext) {
            if (openNext === void 0) { openNext = true; }
            var event = this.doCloseEditor(toReplace, openNext, true); // optimization to prevent multiple setActive() in one call
            // We want to first add the new editor into our model before emitting the close event because
            // firing the close event can trigger a dispose on the same editor that is now being added.
            // This can lead into opening a disposed editor which is not what we want.
            this.splice(replaceIndex, false, replaceWidth);
            if (event) {
                this._onDidEditorClose.fire(event);
            }
        };
        EditorGroup.prototype.closeEditor = function (editor, openNext) {
            if (openNext === void 0) { openNext = true; }
            var event = this.doCloseEditor(editor, openNext, false);
            if (event) {
                this._onDidEditorClose.fire(event);
                return event.index;
            }
            return void 0;
        };
        EditorGroup.prototype.doCloseEditor = function (editor, openNext, replaced) {
            var index = this.indexOf(editor);
            if (index === -1) {
                return null; // not found
            }
            // Active Editor closed
            if (openNext && this.matches(this.active, editor)) {
                // More than one editor
                if (this.mru.length > 1) {
                    this.setActive(this.mru[1]); // active editor is always first in MRU, so pick second editor after as new active
                }
                // One Editor
                else {
                    this.active = null;
                }
            }
            // Preview Editor closed
            if (this.matches(this.preview, editor)) {
                this.preview = null;
            }
            // Remove from arrays
            this.splice(index, true);
            // Event
            return { editor: editor, replaced: replaced, index: index, groupId: this.id };
        };
        EditorGroup.prototype.closeEditors = function (except, direction) {
            var _this = this;
            var index = this.indexOf(except);
            if (index === -1) {
                return; // not found
            }
            // Close to the left
            if (direction === 0 /* LEFT */) {
                for (var i = index - 1; i >= 0; i--) {
                    this.closeEditor(this.editors[i]);
                }
            }
            // Close to the right
            else if (direction === 1 /* RIGHT */) {
                for (var i = this.editors.length - 1; i > index; i--) {
                    this.closeEditor(this.editors[i]);
                }
            }
            // Both directions
            else {
                this.mru.filter(function (e) { return !_this.matches(e, except); }).forEach(function (e) { return _this.closeEditor(e); });
            }
        };
        EditorGroup.prototype.closeAllEditors = function () {
            var _this = this;
            // Optimize: close all non active editors first to produce less upstream work
            this.mru.filter(function (e) { return !_this.matches(e, _this.active); }).forEach(function (e) { return _this.closeEditor(e); });
            this.closeEditor(this.active);
        };
        EditorGroup.prototype.moveEditor = function (editor, toIndex) {
            var index = this.indexOf(editor);
            if (index < 0) {
                return;
            }
            // Move
            this.editors.splice(index, 1);
            this.editors.splice(toIndex, 0, editor);
            // Event
            this._onDidEditorMove.fire(editor);
        };
        EditorGroup.prototype.setActive = function (editor) {
            var index = this.indexOf(editor);
            if (index === -1) {
                return; // not found
            }
            if (this.matches(this.active, editor)) {
                return; // already active
            }
            this.active = editor;
            // Bring to front in MRU list
            this.setMostRecentlyUsed(editor);
            // Event
            this._onDidEditorActivate.fire(editor);
        };
        EditorGroup.prototype.pin = function (editor) {
            var index = this.indexOf(editor);
            if (index === -1) {
                return; // not found
            }
            if (!this.isPreview(editor)) {
                return; // can only pin a preview editor
            }
            // Convert the preview editor to be a pinned editor
            this.preview = null;
            // Event
            this._onDidEditorPin.fire(editor);
        };
        EditorGroup.prototype.unpin = function (editor) {
            var index = this.indexOf(editor);
            if (index === -1) {
                return; // not found
            }
            if (!this.isPinned(editor)) {
                return; // can only unpin a pinned editor
            }
            // Set new
            var oldPreview = this.preview;
            this.preview = editor;
            // Event
            this._onDidEditorUnpin.fire(editor);
            // Close old preview editor if any
            this.closeEditor(oldPreview);
        };
        EditorGroup.prototype.isPinned = function (arg1) {
            var editor;
            var index;
            if (typeof arg1 === 'number') {
                editor = this.editors[arg1];
                index = arg1;
            }
            else {
                editor = arg1;
                index = this.indexOf(editor);
            }
            if (index === -1 || !editor) {
                return false; // editor not found
            }
            if (!this.preview) {
                return true; // no preview editor
            }
            return !this.matches(this.preview, editor);
        };
        EditorGroup.prototype.splice = function (index, del, editor) {
            var editorToDeleteOrReplace = this.editors[index];
            var args = [index, del ? 1 : 0];
            if (editor) {
                args.push(editor);
            }
            // Perform on editors array
            this.editors.splice.apply(this.editors, args);
            // Add
            if (!del && editor) {
                this.mru.push(editor); // make it LRU editor
                this.updateResourceMap(editor, false /* add */); // add new to resource map
            }
            // Remove / Replace
            else {
                var indexInMRU = this.indexOf(editorToDeleteOrReplace, this.mru);
                // Remove
                if (del && !editor) {
                    this.mru.splice(indexInMRU, 1); // remove from MRU
                    this.updateResourceMap(editorToDeleteOrReplace, true /* delete */); // remove from resource map
                }
                // Replace
                else {
                    this.mru.splice(indexInMRU, 1, editor); // replace MRU at location
                    this.updateResourceMap(editor, false /* add */); // add new to resource map
                    this.updateResourceMap(editorToDeleteOrReplace, true /* delete */); // remove replaced from resource map
                }
            }
        };
        EditorGroup.prototype.updateResourceMap = function (editor, remove) {
            var resource = editor_1.toResource(editor, { supportSideBySide: true });
            if (resource) {
                // It is possible to have the same resource opened twice (once as normal input and once as diff input)
                // So we need to do ref counting on the resource to provide the correct picture
                var counter = this.mapResourceToEditorCount.get(resource) || 0;
                var newCounter = void 0;
                if (remove) {
                    if (counter > 1) {
                        newCounter = counter - 1;
                    }
                }
                else {
                    newCounter = counter + 1;
                }
                this.mapResourceToEditorCount.set(resource, newCounter);
            }
        };
        EditorGroup.prototype.indexOf = function (candidate, editors) {
            if (editors === void 0) { editors = this.editors; }
            if (!candidate) {
                return -1;
            }
            for (var i = 0; i < editors.length; i++) {
                if (this.matches(editors[i], candidate)) {
                    return i;
                }
            }
            return -1;
        };
        EditorGroup.prototype.contains = function (editorOrResource, supportSideBySide) {
            if (editorOrResource instanceof editor_1.EditorInput) {
                var index = this.indexOf(editorOrResource);
                if (index >= 0) {
                    return true;
                }
                if (supportSideBySide && editorOrResource instanceof editor_1.SideBySideEditorInput) {
                    var index_1 = this.indexOf(editorOrResource.master);
                    if (index_1 >= 0) {
                        return true;
                    }
                }
                return false;
            }
            var counter = this.mapResourceToEditorCount.get(editorOrResource);
            return typeof counter === 'number' && counter > 0;
        };
        EditorGroup.prototype.setMostRecentlyUsed = function (editor) {
            var index = this.indexOf(editor);
            if (index === -1) {
                return; // editor not found
            }
            var mruIndex = this.indexOf(editor, this.mru);
            // Remove old index
            this.mru.splice(mruIndex, 1);
            // Set editor to front
            this.mru.unshift(editor);
        };
        EditorGroup.prototype.matches = function (editorA, editorB) {
            return !!editorA && !!editorB && editorA.matches(editorB);
        };
        EditorGroup.prototype.clone = function () {
            var group = this.instantiationService.createInstance(EditorGroup, void 0);
            group.editors = this.editors.slice(0);
            group.mru = this.mru.slice(0);
            group.mapResourceToEditorCount = this.mapResourceToEditorCount.clone();
            group.preview = this.preview;
            group.active = this.active;
            group.editorOpenPositioning = this.editorOpenPositioning;
            return group;
        };
        EditorGroup.prototype.serialize = function () {
            var _this = this;
            var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
            // Serialize all editor inputs so that we can store them.
            // Editors that cannot be serialized need to be ignored
            // from mru, active and preview if any.
            var serializableEditors = [];
            var serializedEditors = [];
            var serializablePreviewIndex;
            this.editors.forEach(function (e) {
                var factory = registry.getEditorInputFactory(e.getTypeId());
                if (factory) {
                    var value = factory.serialize(e);
                    if (typeof value === 'string') {
                        serializedEditors.push({ id: e.getTypeId(), value: value });
                        serializableEditors.push(e);
                        if (_this.preview === e) {
                            serializablePreviewIndex = serializableEditors.length - 1;
                        }
                    }
                }
            });
            var serializableMru = this.mru.map(function (e) { return _this.indexOf(e, serializableEditors); }).filter(function (i) { return i >= 0; });
            return {
                id: this.id,
                editors: serializedEditors,
                mru: serializableMru,
                preview: serializablePreviewIndex,
            };
        };
        EditorGroup.prototype.deserialize = function (data) {
            var _this = this;
            var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
            if (typeof data.id === 'number') {
                this._id = data.id;
                EditorGroup.IDS = Math.max(data.id + 1, EditorGroup.IDS); // make sure our ID generator is always larger
            }
            else {
                this._id = EditorGroup.IDS++; // backwards compatibility
            }
            this.editors = data.editors.map(function (e) {
                var factory = registry.getEditorInputFactory(e.id);
                if (factory) {
                    var editor = factory.deserialize(_this.instantiationService, e.value);
                    _this.registerEditorListeners(editor);
                    _this.updateResourceMap(editor, false /* add */);
                    return editor;
                }
                return null;
            }).filter(function (e) { return !!e; });
            this.mru = data.mru.map(function (i) { return _this.editors[i]; });
            this.active = this.mru[0];
            this.preview = this.editors[data.preview];
        };
        EditorGroup.IDS = 0;
        EditorGroup = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, configuration_1.IConfigurationService)
        ], EditorGroup);
        return EditorGroup;
    }(lifecycle_1.Disposable));
    exports.EditorGroup = EditorGroup;
});














define(__m[187/*vs/workbench/common/editor/textDiffEditorModel*/], __M([0/*require*/,1/*exports*/,190/*vs/workbench/common/editor/diffEditorModel*/]), function (require, exports, diffEditorModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base text editor model for the diff editor. It is made up of two text editor models, the original version
     * and the modified version.
     */
    var TextDiffEditorModel = /** @class */ (function (_super) {
        __extends(TextDiffEditorModel, _super);
        function TextDiffEditorModel(originalModel, modifiedModel) {
            var _this = _super.call(this, originalModel, modifiedModel) || this;
            _this.updateTextDiffEditorModel();
            return _this;
        }
        Object.defineProperty(TextDiffEditorModel.prototype, "originalModel", {
            get: function () {
                return this._originalModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextDiffEditorModel.prototype, "modifiedModel", {
            get: function () {
                return this._modifiedModel;
            },
            enumerable: true,
            configurable: true
        });
        TextDiffEditorModel.prototype.load = function () {
            var _this = this;
            return _super.prototype.load.call(this).then(function () {
                _this.updateTextDiffEditorModel();
                return _this;
            });
        };
        TextDiffEditorModel.prototype.updateTextDiffEditorModel = function () {
            if (this.originalModel.isResolved() && this.modifiedModel.isResolved()) {
                // Create new
                if (!this._textDiffEditorModel) {
                    this._textDiffEditorModel = {
                        original: this.originalModel.textEditorModel,
                        modified: this.modifiedModel.textEditorModel
                    };
                }
                // Update existing
                else {
                    this._textDiffEditorModel.original = this.originalModel.textEditorModel;
                    this._textDiffEditorModel.modified = this.modifiedModel.textEditorModel;
                }
            }
        };
        Object.defineProperty(TextDiffEditorModel.prototype, "textDiffEditorModel", {
            get: function () {
                return this._textDiffEditorModel;
            },
            enumerable: true,
            configurable: true
        });
        TextDiffEditorModel.prototype.isResolved = function () {
            return !!this._textDiffEditorModel;
        };
        TextDiffEditorModel.prototype.isReadonly = function () {
            return this.modifiedModel.isReadonly();
        };
        TextDiffEditorModel.prototype.dispose = function () {
            // Free the diff editor model but do not propagate the dispose() call to the two models
            // inside. We never created the two models (original and modified) so we can not dispose
            // them without sideeffects. Rather rely on the models getting disposed when their related
            // inputs get disposed from the diffEditorInput.
            this._textDiffEditorModel = null;
            _super.prototype.dispose.call(this);
        };
        return TextDiffEditorModel;
    }(diffEditorModel_1.DiffEditorModel));
    exports.TextDiffEditorModel = TextDiffEditorModel;
});























define(__m[116/*vs/workbench/common/editor/textEditorModel*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/]), function (require, exports, winjs_base_1, editor_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base text editor model leverages the code editor model. This class is only intended to be subclassed and not instantiated.
     */
    var BaseTextEditorModel = /** @class */ (function (_super) {
        __extends(BaseTextEditorModel, _super);
        function BaseTextEditorModel(modelService, modeService, textEditorModelHandle) {
            var _this = _super.call(this) || this;
            _this.modelService = modelService;
            _this.modeService = modeService;
            if (textEditorModelHandle) {
                _this.handleExistingModel(textEditorModelHandle);
            }
            return _this;
        }
        BaseTextEditorModel.prototype.handleExistingModel = function (textEditorModelHandle) {
            // We need the resource to point to an existing model
            var model = this.modelService.getModel(textEditorModelHandle);
            if (!model) {
                throw new Error("Document with resource " + textEditorModelHandle.toString() + " does not exist");
            }
            this.textEditorModelHandle = textEditorModelHandle;
            // Make sure we clean up when this model gets disposed
            this.registerModelDisposeListener(model);
        };
        BaseTextEditorModel.prototype.registerModelDisposeListener = function (model) {
            var _this = this;
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose();
            }
            this.modelDisposeListener = model.onWillDispose(function () {
                _this.textEditorModelHandle = null; // make sure we do not dispose code editor model again
                _this.dispose();
            });
        };
        Object.defineProperty(BaseTextEditorModel.prototype, "textEditorModel", {
            get: function () {
                return this.textEditorModelHandle ? this.modelService.getModel(this.textEditorModelHandle) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates the text editor model with the provided value, modeId (can be comma separated for multiple values) and optional resource URL.
         */
        BaseTextEditorModel.prototype.createTextEditorModel = function (value, resource, modeId) {
            var firstLineText = this.getFirstLineText(value);
            var mode = this.getOrCreateMode(this.modeService, modeId, firstLineText);
            return winjs_base_1.TPromise.as(this.doCreateTextEditorModel(value, mode, resource));
        };
        BaseTextEditorModel.prototype.doCreateTextEditorModel = function (value, mode, resource) {
            var model = resource && this.modelService.getModel(resource);
            if (!model) {
                model = this.modelService.createModel(value, mode, resource);
                this.createdEditorModel = true;
                // Make sure we clean up when this model gets disposed
                this.registerModelDisposeListener(model);
            }
            else {
                this.modelService.updateModel(model, value);
                this.modelService.setMode(model, mode);
            }
            this.textEditorModelHandle = model.uri;
            return this;
        };
        BaseTextEditorModel.prototype.getFirstLineText = function (value) {
            // text buffer factory
            var textBufferFactory = value;
            if (typeof textBufferFactory.getFirstLineText === 'function') {
                return textBufferFactory.getFirstLineText(100);
            }
            // text model
            var textSnapshot = value;
            return textSnapshot.getLineContent(1).substr(0, 100);
        };
        /**
         * Gets the mode for the given identifier. Subclasses can override to provide their own implementation of this lookup.
         *
         * @param firstLineText optional first line of the text buffer to set the mode on. This can be used to guess a mode from content.
         */
        BaseTextEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            return modeService.getOrCreateMode(modeId);
        };
        /**
         * Updates the text editor model with the provided value. If the value is the same as the model has, this is a no-op.
         */
        BaseTextEditorModel.prototype.updateTextEditorModel = function (newValue) {
            if (!this.textEditorModel) {
                return;
            }
            this.modelService.updateModel(this.textEditorModel, newValue);
        };
        BaseTextEditorModel.prototype.createSnapshot = function () {
            var model = this.textEditorModel;
            if (model) {
                return model.createSnapshot(true /* Preserve BOM */);
            }
            return null;
        };
        BaseTextEditorModel.prototype.isResolved = function () {
            return !!this.textEditorModelHandle;
        };
        BaseTextEditorModel.prototype.dispose = function () {
            if (this.modelDisposeListener) {
                this.modelDisposeListener.dispose(); // dispose this first because it will trigger another dispose() otherwise
                this.modelDisposeListener = null;
            }
            if (this.textEditorModelHandle && this.createdEditorModel) {
                this.modelService.destroyModel(this.textEditorModelHandle);
            }
            this.textEditorModelHandle = null;
            this.createdEditorModel = false;
            _super.prototype.dispose.call(this);
        };
        BaseTextEditorModel = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, modeService_1.IModeService)
        ], BaseTextEditorModel);
        return BaseTextEditorModel;
    }(editor_1.EditorModel));
    exports.BaseTextEditorModel = BaseTextEditorModel;
});














define(__m[110/*vs/workbench/common/editor/diffEditorInput*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/,116/*vs/workbench/common/editor/textEditorModel*/,190/*vs/workbench/common/editor/diffEditorModel*/,187/*vs/workbench/common/editor/textDiffEditorModel*/]), function (require, exports, winjs_base_1, editor_1, textEditorModel_1, diffEditorModel_1, textDiffEditorModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base editor input for the diff editor. It is made up of two editor inputs, the original version
     * and the modified version.
     */
    var DiffEditorInput = /** @class */ (function (_super) {
        __extends(DiffEditorInput, _super);
        function DiffEditorInput(name, description, original, modified, forceOpenAsBinary) {
            var _this = _super.call(this, name, description, original, modified) || this;
            _this.forceOpenAsBinary = forceOpenAsBinary;
            return _this;
        }
        DiffEditorInput.prototype.getTypeId = function () {
            return DiffEditorInput.ID;
        };
        Object.defineProperty(DiffEditorInput.prototype, "originalInput", {
            get: function () {
                return this.details;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DiffEditorInput.prototype, "modifiedInput", {
            get: function () {
                return this.master;
            },
            enumerable: true,
            configurable: true
        });
        DiffEditorInput.prototype.resolve = function () {
            var _this = this;
            // Create Model - we never reuse our cached model if refresh is true because we cannot
            // decide for the inputs within if the cached model can be reused or not. There may be
            // inputs that need to be loaded again and thus we always recreate the model and dispose
            // the previous one - if any.
            return this.createModel().then(function (resolvedModel) {
                if (_this.cachedModel) {
                    _this.cachedModel.dispose();
                }
                _this.cachedModel = resolvedModel;
                return _this.cachedModel;
            });
        };
        DiffEditorInput.prototype.getPreferredEditorId = function (candidates) {
            return this.forceOpenAsBinary ? editor_1.BINARY_DIFF_EDITOR_ID : editor_1.TEXT_DIFF_EDITOR_ID;
        };
        DiffEditorInput.prototype.createModel = function (refresh) {
            // Join resolve call over two inputs and build diff editor model
            return winjs_base_1.TPromise.join([
                this.originalInput.resolve(),
                this.modifiedInput.resolve()
            ]).then(function (models) {
                var originalEditorModel = models[0];
                var modifiedEditorModel = models[1];
                // If both are text models, return textdiffeditor model
                if (modifiedEditorModel instanceof textEditorModel_1.BaseTextEditorModel && originalEditorModel instanceof textEditorModel_1.BaseTextEditorModel) {
                    return new textDiffEditorModel_1.TextDiffEditorModel(originalEditorModel, modifiedEditorModel);
                }
                // Otherwise return normal diff model
                return new diffEditorModel_1.DiffEditorModel(originalEditorModel, modifiedEditorModel);
            });
        };
        DiffEditorInput.prototype.dispose = function () {
            // Free the diff editor model but do not propagate the dispose() call to the two inputs
            // We never created the two inputs (original and modified) so we can not dispose
            // them without sideeffects.
            if (this.cachedModel) {
                this.cachedModel.dispose();
                this.cachedModel = null;
            }
            _super.prototype.dispose.call(this);
        };
        DiffEditorInput.ID = 'workbench.editors.diffEditorInput';
        return DiffEditorInput;
    }(editor_1.SideBySideEditorInput));
    exports.DiffEditorInput = DiffEditorInput;
});























define(__m[186/*vs/workbench/common/editor/resourceEditorModel*/], __M([0/*require*/,1/*exports*/,116/*vs/workbench/common/editor/textEditorModel*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/]), function (require, exports, textEditorModel_1, modeService_1, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor model whith an in-memory, readonly content that is backed by an existing editor model.
     */
    var ResourceEditorModel = /** @class */ (function (_super) {
        __extends(ResourceEditorModel, _super);
        function ResourceEditorModel(resource, modeService, modelService) {
            var _this = _super.call(this, modelService, modeService, resource) || this;
            // TODO@Joao: force this class to dispose the underlying model
            _this.createdEditorModel = true;
            return _this;
        }
        ResourceEditorModel.prototype.isReadonly = function () {
            return true;
        };
        ResourceEditorModel = __decorate([
            __param(1, modeService_1.IModeService),
            __param(2, modelService_1.IModelService)
        ], ResourceEditorModel);
        return ResourceEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.ResourceEditorModel = ResourceEditorModel;
});

define(__m[348/*vs/workbench/common/memento*/], __M([0/*require*/,1/*exports*/,29/*vs/base/common/types*/]), function (require, exports, types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A memento provides access to a datastructure that is persisted and restored as part of the workbench lifecycle.
     */
    var Memento = /** @class */ (function () {
        function Memento(id) {
            this.id = Memento.COMMON_PREFIX + id.toLowerCase();
        }
        /**
         * Returns a JSON Object that represents the data of this memento. The optional
         * parameter scope allows to specify the scope of the memento to load. If not
         * provided, the scope will be global, Memento.Scope.WORKSPACE can be used to
         * scope the memento to the workspace.
         */
        Memento.prototype.getMemento = function (storageService, scope) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            // Scope by Workspace
            if (scope === 1 /* WORKSPACE */) {
                var workspaceMemento = Memento.workspaceMementos[this.id];
                if (!workspaceMemento) {
                    workspaceMemento = new ScopedMemento(this.id, scope, storageService);
                    Memento.workspaceMementos[this.id] = workspaceMemento;
                }
                return workspaceMemento.getMemento();
            }
            // Use global scope
            var globalMemento = Memento.globalMementos[this.id];
            if (!globalMemento) {
                globalMemento = new ScopedMemento(this.id, scope, storageService);
                Memento.globalMementos[this.id] = globalMemento;
            }
            return globalMemento.getMemento();
        };
        /**
         * Saves all data of the mementos that have been loaded to the local storage. This includes
         * global and workspace scope.
         */
        Memento.prototype.saveMemento = function () {
            // Global
            var globalMemento = Memento.globalMementos[this.id];
            if (globalMemento) {
                globalMemento.save();
            }
            // Workspace
            var workspaceMemento = Memento.workspaceMementos[this.id];
            if (workspaceMemento) {
                workspaceMemento.save();
            }
        };
        // Mementos are static to ensure that for a given component with an id only ever one memento gets loaded
        Memento.globalMementos = {};
        Memento.workspaceMementos = {};
        Memento.COMMON_PREFIX = 'memento/';
        return Memento;
    }());
    exports.Memento = Memento;
    var ScopedMemento = /** @class */ (function () {
        function ScopedMemento(id, scope, storageService) {
            this.storageService = storageService;
            this.id = id;
            this.scope = scope;
            this.mementoObj = this.loadMemento();
        }
        ScopedMemento.prototype.getMemento = function () {
            return this.mementoObj;
        };
        ScopedMemento.prototype.loadMemento = function () {
            var storageScope = this.scope === 0 /* GLOBAL */ ? 0 /* GLOBAL */ : 1 /* WORKSPACE */;
            var memento = this.storageService.get(this.id, storageScope);
            if (memento) {
                return JSON.parse(memento);
            }
            return {};
        };
        ScopedMemento.prototype.save = function () {
            var storageScope = this.scope === 0 /* GLOBAL */ ? 0 /* GLOBAL */ : 1 /* WORKSPACE */;
            if (!types.isEmptyObject(this.mementoObj)) {
                this.storageService.store(this.id, JSON.stringify(this.mementoObj), storageScope);
            }
            else {
                this.storageService.remove(this.id, storageScope);
            }
        };
        return ScopedMemento;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[82/*vs/workbench/common/resources*/], __M([0/*require*/,1/*exports*/,24/*vs/base/common/paths*/,10/*vs/platform/contextkey/common/contextkey*/,41/*vs/editor/common/services/modeService*/,16/*vs/platform/files/common/files*/,4/*vs/base/common/lifecycle*/,26/*vs/base/common/network*/]), function (require, exports, paths, contextkey_1, modeService_1, files_1, lifecycle_1, network_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourceContextKey = /** @class */ (function (_super) {
        __extends(ResourceContextKey, _super);
        function ResourceContextKey(contextKeyService, _fileService, _modeService) {
            var _this = _super.call(this) || this;
            _this._fileService = _fileService;
            _this._modeService = _modeService;
            _this._schemeKey = ResourceContextKey.Scheme.bindTo(contextKeyService);
            _this._filenameKey = ResourceContextKey.Filename.bindTo(contextKeyService);
            _this._langIdKey = ResourceContextKey.LangId.bindTo(contextKeyService);
            _this._resourceKey = ResourceContextKey.Resource.bindTo(contextKeyService);
            _this._extensionKey = ResourceContextKey.Extension.bindTo(contextKeyService);
            _this._hasResource = ResourceContextKey.HasResource.bindTo(contextKeyService);
            _this._isfileSystemResource = ResourceContextKey.IsFileSystemResource.bindTo(contextKeyService);
            _this._isFileSystemResourceOrUntitled = ResourceContextKey.IsFileSystemResourceOrUntitled.bindTo(contextKeyService);
            _this._register(_fileService.onDidChangeFileSystemProviderRegistrations(function () {
                var resource = _this._resourceKey.get();
                _this._isfileSystemResource.set(resource && _fileService.canHandleResource(resource));
                _this._isFileSystemResourceOrUntitled.set(_this._isfileSystemResource.get() || _this._schemeKey.get() === network_1.Schemas.untitled);
            }));
            return _this;
        }
        ResourceContextKey.prototype.set = function (value) {
            this._resourceKey.set(value);
            this._schemeKey.set(value && value.scheme);
            this._filenameKey.set(value && paths.basename(value.fsPath));
            this._langIdKey.set(value && this._modeService.getModeIdByFilepathOrFirstLine(value.fsPath));
            this._extensionKey.set(value && paths.extname(value.fsPath));
            this._hasResource.set(!!value);
            this._isfileSystemResource.set(value && this._fileService.canHandleResource(value));
            this._isFileSystemResourceOrUntitled.set(this._isfileSystemResource.get() || this._schemeKey.get() === network_1.Schemas.untitled);
        };
        ResourceContextKey.prototype.reset = function () {
            this._schemeKey.reset();
            this._langIdKey.reset();
            this._resourceKey.reset();
            this._langIdKey.reset();
            this._extensionKey.reset();
            this._hasResource.reset();
        };
        ResourceContextKey.prototype.get = function () {
            return this._resourceKey.get();
        };
        ResourceContextKey.Scheme = new contextkey_1.RawContextKey('resourceScheme', undefined);
        ResourceContextKey.Filename = new contextkey_1.RawContextKey('resourceFilename', undefined);
        ResourceContextKey.LangId = new contextkey_1.RawContextKey('resourceLangId', undefined);
        ResourceContextKey.Resource = new contextkey_1.RawContextKey('resource', undefined);
        ResourceContextKey.Extension = new contextkey_1.RawContextKey('resourceExtname', undefined);
        ResourceContextKey.HasResource = new contextkey_1.RawContextKey('resourceSet', false);
        ResourceContextKey.IsFileSystemResource = new contextkey_1.RawContextKey('isFileSystemResource', false);
        ResourceContextKey.IsFileSystemResourceOrUntitled = new contextkey_1.RawContextKey('isFileSystemResourceOrUntitled', false);
        ResourceContextKey = __decorate([
            __param(0, contextkey_1.IContextKeyService),
            __param(1, files_1.IFileService),
            __param(2, modeService_1.IModeService)
        ], ResourceContextKey);
        return ResourceContextKey;
    }(lifecycle_1.Disposable));
    exports.ResourceContextKey = ResourceContextKey;
    /**
     * Data URI related helpers.
     */
    var DataUri;
    (function (DataUri) {
        DataUri.META_DATA_LABEL = 'label';
        DataUri.META_DATA_DESCRIPTION = 'description';
        DataUri.META_DATA_SIZE = 'size';
        DataUri.META_DATA_MIME = 'mime';
        function parseMetaData(dataUri) {
            var metadata = new Map();
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the metadata is: size:2313;label:SomeLabel;description:SomeDescription
            var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));
            meta.split(';').forEach(function (property) {
                var _a = property.split(':'), key = _a[0], value = _a[1];
                if (key && value) {
                    metadata.set(key, value);
                }
            });
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the mime is: image/png
            var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));
            if (mime) {
                metadata.set(DataUri.META_DATA_MIME, mime);
            }
            return metadata;
        }
        DataUri.parseMetaData = parseMetaData;
    })(DataUri = exports.DataUri || (exports.DataUri = {}));
});























define(__m[127/*vs/workbench/common/editor/binaryEditorModel*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/,16/*vs/platform/files/common/files*/,26/*vs/base/common/network*/,82/*vs/workbench/common/resources*/]), function (require, exports, winjs_base_1, editor_1, files_1, network_1, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor model that just represents a resource that can be loaded.
     */
    var BinaryEditorModel = /** @class */ (function (_super) {
        __extends(BinaryEditorModel, _super);
        function BinaryEditorModel(resource, name, fileService) {
            var _this = _super.call(this) || this;
            _this.fileService = fileService;
            _this.resource = resource;
            _this.name = name;
            if (resource.scheme === network_1.Schemas.data) {
                var metadata = resources_1.DataUri.parseMetaData(resource);
                if (metadata.has(resources_1.DataUri.META_DATA_SIZE)) {
                    _this.size = Number(metadata.get(resources_1.DataUri.META_DATA_SIZE));
                }
                _this.mime = metadata.get(resources_1.DataUri.META_DATA_MIME);
            }
            return _this;
        }
        /**
         * The name of the binary resource.
         */
        BinaryEditorModel.prototype.getName = function () {
            return this.name;
        };
        /**
         * The resource of the binary resource.
         */
        BinaryEditorModel.prototype.getResource = function () {
            return this.resource;
        };
        /**
         * The size of the binary resource if known.
         */
        BinaryEditorModel.prototype.getSize = function () {
            return this.size;
        };
        /**
         * The mime of the binary resource if known.
         */
        BinaryEditorModel.prototype.getMime = function () {
            return this.mime;
        };
        /**
         * The etag of the binary resource if known.
         */
        BinaryEditorModel.prototype.getETag = function () {
            return this.etag;
        };
        BinaryEditorModel.prototype.load = function () {
            var _this = this;
            // Make sure to resolve up to date stat for file resources
            if (this.fileService.canHandleResource(this.resource)) {
                return this.fileService.resolveFile(this.resource).then(function (stat) {
                    _this.etag = stat.etag;
                    _this.size = stat.size;
                    return _this;
                });
            }
            return winjs_base_1.TPromise.wrap(this);
        };
        BinaryEditorModel = __decorate([
            __param(2, files_1.IFileService)
        ], BinaryEditorModel);
        return BinaryEditorModel;
    }(editor_1.EditorModel));
    exports.BinaryEditorModel = BinaryEditorModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[185/*vs/workbench/common/editor/dataUriEditorInput*/], __M([0/*require*/,1/*exports*/,13/*vs/workbench/common/editor*/,3/*vs/platform/instantiation/common/instantiation*/,127/*vs/workbench/common/editor/binaryEditorModel*/,82/*vs/workbench/common/resources*/]), function (require, exports, editor_1, instantiation_1, binaryEditorModel_1, resources_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor input to present data URIs in a binary editor. Data URIs have the form of:
     * data:[mime type];[meta data <key=value>;...];base64,[base64 encoded value]
     */
    var DataUriEditorInput = /** @class */ (function (_super) {
        __extends(DataUriEditorInput, _super);
        function DataUriEditorInput(name, description, resource, instantiationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.name = name;
            _this.description = description;
            _this.resource = resource;
            if (!_this.name || !_this.description) {
                var metadata = resources_1.DataUri.parseMetaData(_this.resource);
                if (!_this.name) {
                    _this.name = metadata.get(resources_1.DataUri.META_DATA_LABEL);
                }
                if (!_this.description) {
                    _this.description = metadata.get(resources_1.DataUri.META_DATA_DESCRIPTION);
                }
            }
            return _this;
        }
        DataUriEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        DataUriEditorInput.prototype.getTypeId = function () {
            return DataUriEditorInput.ID;
        };
        DataUriEditorInput.prototype.getName = function () {
            return this.name;
        };
        DataUriEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        DataUriEditorInput.prototype.resolve = function () {
            return this.instantiationService.createInstance(binaryEditorModel_1.BinaryEditorModel, this.resource, this.getName()).load().then(function (m) { return m; });
        };
        DataUriEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof DataUriEditorInput) {
                var otherDataUriEditorInput = otherInput;
                // Compare by resource
                return otherDataUriEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        DataUriEditorInput.ID = 'workbench.editors.dataUriEditorInput';
        DataUriEditorInput = __decorate([
            __param(3, instantiation_1.IInstantiationService)
        ], DataUriEditorInput);
        return DataUriEditorInput;
    }(editor_1.EditorInput));
    exports.DataUriEditorInput = DataUriEditorInput;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[58/*vs/workbench/common/theme*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,30/*vs/platform/theme/common/colorRegistry*/,4/*vs/base/common/lifecycle*/,75/*vs/base/common/color*/]), function (require, exports, nls, colorRegistry_1, lifecycle_1, color_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // < --- Workbench (not customizable) --- >
    function WORKBENCH_BACKGROUND(theme) {
        switch (theme.type) {
            case 'dark':
                return color_1.Color.fromHex('#252526');
            case 'light':
                return color_1.Color.fromHex('#F3F3F3');
            default:
                return color_1.Color.fromHex('#000000');
        }
    }
    exports.WORKBENCH_BACKGROUND = WORKBENCH_BACKGROUND;
    // < --- Tabs --- >
    exports.TAB_ACTIVE_BACKGROUND = colorRegistry_1.registerColor('tab.activeBackground', {
        dark: colorRegistry_1.editorBackground,
        light: colorRegistry_1.editorBackground,
        hc: colorRegistry_1.editorBackground
    }, nls.localize('tabActiveBackground', "Active tab background color. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_INACTIVE_BACKGROUND = colorRegistry_1.registerColor('tab.inactiveBackground', {
        dark: '#2D2D2D',
        light: '#ECECEC',
        hc: null
    }, nls.localize('tabInactiveBackground', "Inactive tab background color. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_HOVER_BACKGROUND = colorRegistry_1.registerColor('tab.hoverBackground', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('tabHoverBackground', "Tab background color when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_HOVER_BACKGROUND = colorRegistry_1.registerColor('tab.unfocusedHoverBackground', {
        dark: colorRegistry_1.transparent(exports.TAB_HOVER_BACKGROUND, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_HOVER_BACKGROUND, 0.7),
        hc: null
    }, nls.localize('tabUnfocusedHoverBackground', "Tab background color in an unfocused group when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_BORDER = colorRegistry_1.registerColor('tab.border', {
        dark: '#252526',
        light: '#F3F3F3',
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('tabBorder', "Border to separate tabs from each other. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_ACTIVE_BORDER = colorRegistry_1.registerColor('tab.activeBorder', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('tabActiveBorder', "Border on the bottom of an active tab. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_ACTIVE_BORDER_TOP = colorRegistry_1.registerColor('tab.activeBorderTop', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('tabActiveBorderTop', "Border to the top of an active tab. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_ACTIVE_BORDER = colorRegistry_1.registerColor('tab.unfocusedActiveBorder', {
        dark: colorRegistry_1.transparent(exports.TAB_ACTIVE_BORDER, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_ACTIVE_BORDER, 0.7),
        hc: null
    }, nls.localize('tabActiveUnfocusedBorder', "Border on the bottom of an active tab in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_ACTIVE_BORDER_TOP = colorRegistry_1.registerColor('tab.unfocusedActiveBorderTop', {
        dark: colorRegistry_1.transparent(exports.TAB_ACTIVE_BORDER_TOP, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_ACTIVE_BORDER_TOP, 0.7),
        hc: null
    }, nls.localize('tabActiveUnfocusedBorderTop', "Border to the top of an active tab in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_HOVER_BORDER = colorRegistry_1.registerColor('tab.hoverBorder', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('tabHoverBorder', "Border to highlight tabs when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_HOVER_BORDER = colorRegistry_1.registerColor('tab.unfocusedHoverBorder', {
        dark: colorRegistry_1.transparent(exports.TAB_HOVER_BORDER, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_HOVER_BORDER, 0.7),
        hc: null
    }, nls.localize('tabUnfocusedHoverBorder', "Border to highlight tabs in an unfocused group when hovering. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_ACTIVE_FOREGROUND = colorRegistry_1.registerColor('tab.activeForeground', {
        dark: color_1.Color.white,
        light: '#333333',
        hc: color_1.Color.white
    }, nls.localize('tabActiveForeground', "Active tab foreground color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_INACTIVE_FOREGROUND = colorRegistry_1.registerColor('tab.inactiveForeground', {
        dark: colorRegistry_1.transparent(exports.TAB_ACTIVE_FOREGROUND, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_ACTIVE_FOREGROUND, 0.5),
        hc: color_1.Color.white
    }, nls.localize('tabInactiveForeground', "Inactive tab foreground color in an active group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_ACTIVE_FOREGROUND = colorRegistry_1.registerColor('tab.unfocusedActiveForeground', {
        dark: colorRegistry_1.transparent(exports.TAB_ACTIVE_FOREGROUND, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_ACTIVE_FOREGROUND, 0.7),
        hc: color_1.Color.white
    }, nls.localize('tabUnfocusedActiveForeground', "Active tab foreground color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    exports.TAB_UNFOCUSED_INACTIVE_FOREGROUND = colorRegistry_1.registerColor('tab.unfocusedInactiveForeground', {
        dark: colorRegistry_1.transparent(exports.TAB_INACTIVE_FOREGROUND, 0.5),
        light: colorRegistry_1.transparent(exports.TAB_INACTIVE_FOREGROUND, 0.5),
        hc: color_1.Color.white
    }, nls.localize('tabUnfocusedInactiveForeground', "Inactive tab foreground color in an unfocused group. Tabs are the containers for editors in the editor area. Multiple tabs can be opened in one editor group. There can be multiple editor groups."));
    // < --- Editors --- >
    exports.EDITOR_PANE_BACKGROUND = colorRegistry_1.registerColor('editorPane.background', {
        dark: colorRegistry_1.editorBackground,
        light: colorRegistry_1.editorBackground,
        hc: colorRegistry_1.editorBackground
    }, nls.localize('editorPaneBackground', "Background color of the editor pane visible on the left and right side of the centered editor layout."));
    colorRegistry_1.registerColor('editorGroup.background', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('editorGroupBackground', "Deprecated background color of an editor group."), false, nls.localize('deprecatedEditorGroupBackground', "Deprecated: Background color of an editor group is no longer being supported with the introduction of the grid editor layout. You can use editorGroup.emptyBackground to set the background color of empty editor groups."));
    exports.EDITOR_GROUP_EMPTY_BACKGROUND = colorRegistry_1.registerColor('editorGroup.emptyBackground', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('editorGroupEmptyBackground', "Background color of an empty editor group. Editor groups are the containers of editors."));
    exports.EDITOR_GROUP_FOCUSED_EMPTY_BORDER = colorRegistry_1.registerColor('editorGroup.focusedEmptyBorder', {
        dark: null,
        light: null,
        hc: colorRegistry_1.focusBorder
    }, nls.localize('editorGroupFocusedEmptyBorder', "Border color of an empty editor group that is focused. Editor groups are the containers of editors."));
    exports.EDITOR_GROUP_HEADER_TABS_BACKGROUND = colorRegistry_1.registerColor('editorGroupHeader.tabsBackground', {
        dark: '#252526',
        light: '#F3F3F3',
        hc: null
    }, nls.localize('tabsContainerBackground', "Background color of the editor group title header when tabs are enabled. Editor groups are the containers of editors."));
    exports.EDITOR_GROUP_HEADER_TABS_BORDER = colorRegistry_1.registerColor('editorGroupHeader.tabsBorder', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('tabsContainerBorder', "Border color of the editor group title header when tabs are enabled. Editor groups are the containers of editors."));
    exports.EDITOR_GROUP_HEADER_NO_TABS_BACKGROUND = colorRegistry_1.registerColor('editorGroupHeader.noTabsBackground', {
        dark: colorRegistry_1.editorBackground,
        light: colorRegistry_1.editorBackground,
        hc: colorRegistry_1.editorBackground
    }, nls.localize('editorGroupHeaderBackground', "Background color of the editor group title header when tabs are disabled (`\"workbench.editor.showTabs\": false`). Editor groups are the containers of editors."));
    exports.EDITOR_GROUP_BORDER = colorRegistry_1.registerColor('editorGroup.border', {
        dark: '#444444',
        light: '#E7E7E7',
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('editorGroupBorder', "Color to separate multiple editor groups from each other. Editor groups are the containers of editors."));
    exports.EDITOR_DRAG_AND_DROP_BACKGROUND = colorRegistry_1.registerColor('editorGroup.dropBackground', {
        dark: color_1.Color.fromHex('#53595D').transparent(0.5),
        light: color_1.Color.fromHex('#2677CB').transparent(0.18),
        hc: null
    }, nls.localize('editorDragAndDropBackground', "Background color when dragging editors around. The color should have transparency so that the editor contents can still shine through."));
    // < --- Panels --- >
    exports.PANEL_BACKGROUND = colorRegistry_1.registerColor('panel.background', {
        dark: colorRegistry_1.editorBackground,
        light: colorRegistry_1.editorBackground,
        hc: colorRegistry_1.editorBackground
    }, nls.localize('panelBackground', "Panel background color. Panels are shown below the editor area and contain views like output and integrated terminal."));
    exports.PANEL_BORDER = colorRegistry_1.registerColor('panel.border', {
        dark: color_1.Color.fromHex('#808080').transparent(0.35),
        light: color_1.Color.fromHex('#808080').transparent(0.35),
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('panelBorder', "Panel border color to separate the panel from the editor. Panels are shown below the editor area and contain views like output and integrated terminal."));
    exports.PANEL_ACTIVE_TITLE_FOREGROUND = colorRegistry_1.registerColor('panelTitle.activeForeground', {
        dark: '#E7E7E7',
        light: '#424242',
        hc: color_1.Color.white
    }, nls.localize('panelActiveTitleForeground', "Title color for the active panel. Panels are shown below the editor area and contain views like output and integrated terminal."));
    exports.PANEL_INACTIVE_TITLE_FOREGROUND = colorRegistry_1.registerColor('panelTitle.inactiveForeground', {
        dark: colorRegistry_1.transparent(exports.PANEL_ACTIVE_TITLE_FOREGROUND, 0.6),
        light: colorRegistry_1.transparent(exports.PANEL_ACTIVE_TITLE_FOREGROUND, 0.75),
        hc: color_1.Color.white
    }, nls.localize('panelInactiveTitleForeground', "Title color for the inactive panel. Panels are shown below the editor area and contain views like output and integrated terminal."));
    exports.PANEL_ACTIVE_TITLE_BORDER = colorRegistry_1.registerColor('panelTitle.activeBorder', {
        dark: exports.PANEL_BORDER,
        light: exports.PANEL_BORDER,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('panelActiveTitleBorder', "Border color for the active panel title. Panels are shown below the editor area and contain views like output and integrated terminal."));
    exports.PANEL_DRAG_AND_DROP_BACKGROUND = colorRegistry_1.registerColor('panel.dropBackground', {
        dark: color_1.Color.white.transparent(0.12),
        light: color_1.Color.fromHex('#2677CB').transparent(0.18),
        hc: color_1.Color.white.transparent(0.12)
    }, nls.localize('panelDragAndDropBackground', "Drag and drop feedback color for the panel title items. The color should have transparency so that the panel entries can still shine through. Panels are shown below the editor area and contain views like output and integrated terminal."));
    // < --- Status --- >
    exports.STATUS_BAR_FOREGROUND = colorRegistry_1.registerColor('statusBar.foreground', {
        dark: '#FFFFFF',
        light: '#FFFFFF',
        hc: '#FFFFFF'
    }, nls.localize('statusBarForeground', "Status bar foreground color when a workspace is opened. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_NO_FOLDER_FOREGROUND = colorRegistry_1.registerColor('statusBar.noFolderForeground', {
        dark: exports.STATUS_BAR_FOREGROUND,
        light: exports.STATUS_BAR_FOREGROUND,
        hc: exports.STATUS_BAR_FOREGROUND
    }, nls.localize('statusBarNoFolderForeground', "Status bar foreground color when no folder is opened. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_BACKGROUND = colorRegistry_1.registerColor('statusBar.background', {
        dark: '#007ACC',
        light: '#007ACC',
        hc: null
    }, nls.localize('statusBarBackground', "Status bar background color when a workspace is opened. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_NO_FOLDER_BACKGROUND = colorRegistry_1.registerColor('statusBar.noFolderBackground', {
        dark: '#68217A',
        light: '#68217A',
        hc: null
    }, nls.localize('statusBarNoFolderBackground', "Status bar background color when no folder is opened. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_BORDER = colorRegistry_1.registerColor('statusBar.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('statusBarBorder', "Status bar border color separating to the sidebar and editor. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_NO_FOLDER_BORDER = colorRegistry_1.registerColor('statusBar.noFolderBorder', {
        dark: exports.STATUS_BAR_BORDER,
        light: exports.STATUS_BAR_BORDER,
        hc: exports.STATUS_BAR_BORDER
    }, nls.localize('statusBarNoFolderBorder', "Status bar border color separating to the sidebar and editor when no folder is opened. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_ITEM_ACTIVE_BACKGROUND = colorRegistry_1.registerColor('statusBarItem.activeBackground', {
        dark: color_1.Color.white.transparent(0.18),
        light: color_1.Color.white.transparent(0.18),
        hc: color_1.Color.white.transparent(0.18)
    }, nls.localize('statusBarItemActiveBackground', "Status bar item background color when clicking. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_ITEM_HOVER_BACKGROUND = colorRegistry_1.registerColor('statusBarItem.hoverBackground', {
        dark: color_1.Color.white.transparent(0.12),
        light: color_1.Color.white.transparent(0.12),
        hc: color_1.Color.white.transparent(0.12)
    }, nls.localize('statusBarItemHoverBackground', "Status bar item background color when hovering. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_PROMINENT_ITEM_BACKGROUND = colorRegistry_1.registerColor('statusBarItem.prominentBackground', {
        dark: '#388A34',
        light: '#388A34',
        hc: '#3883A4'
    }, nls.localize('statusBarProminentItemBackground', "Status bar prominent items background color. Prominent items stand out from other status bar entries to indicate importance. Change mode `Toggle Tab Key Moves Focus` from command palette to see an example. The status bar is shown in the bottom of the window."));
    exports.STATUS_BAR_PROMINENT_ITEM_HOVER_BACKGROUND = colorRegistry_1.registerColor('statusBarItem.prominentHoverBackground', {
        dark: '#369432',
        light: '#369432',
        hc: '#369432'
    }, nls.localize('statusBarProminentItemHoverBackground', "Status bar prominent items background color when hovering. Prominent items stand out from other status bar entries to indicate importance. Change mode `Toggle Tab Key Moves Focus` from command palette to see an example. The status bar is shown in the bottom of the window."));
    // < --- Activity Bar --- >
    exports.ACTIVITY_BAR_BACKGROUND = colorRegistry_1.registerColor('activityBar.background', {
        dark: '#333333',
        light: '#2C2C2C',
        hc: '#000000'
    }, nls.localize('activityBarBackground', "Activity bar background color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_FOREGROUND = colorRegistry_1.registerColor('activityBar.foreground', {
        dark: color_1.Color.white,
        light: color_1.Color.white,
        hc: color_1.Color.white
    }, nls.localize('activityBarForeground', "Activity bar item foreground color when it is active. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_INACTIVE_FOREGROUND = colorRegistry_1.registerColor('activityBar.inactiveForeground', {
        dark: colorRegistry_1.transparent(exports.ACTIVITY_BAR_FOREGROUND, 0.6),
        light: colorRegistry_1.transparent(exports.ACTIVITY_BAR_FOREGROUND, 0.6),
        hc: color_1.Color.white
    }, nls.localize('activityBarInActiveForeground', "Activity bar item foreground color when it is inactive. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_BORDER = colorRegistry_1.registerColor('activityBar.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('activityBarBorder', "Activity bar border color separating to the side bar. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_DRAG_AND_DROP_BACKGROUND = colorRegistry_1.registerColor('activityBar.dropBackground', {
        dark: color_1.Color.white.transparent(0.12),
        light: color_1.Color.white.transparent(0.12),
        hc: color_1.Color.white.transparent(0.12),
    }, nls.localize('activityBarDragAndDropBackground', "Drag and drop feedback color for the activity bar items. The color should have transparency so that the activity bar entries can still shine through. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_BADGE_BACKGROUND = colorRegistry_1.registerColor('activityBarBadge.background', {
        dark: '#007ACC',
        light: '#007ACC',
        hc: '#000000'
    }, nls.localize('activityBarBadgeBackground', "Activity notification badge background color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    exports.ACTIVITY_BAR_BADGE_FOREGROUND = colorRegistry_1.registerColor('activityBarBadge.foreground', {
        dark: color_1.Color.white,
        light: color_1.Color.white,
        hc: color_1.Color.white
    }, nls.localize('activityBarBadgeForeground', "Activity notification badge foreground color. The activity bar is showing on the far left or right and allows to switch between views of the side bar."));
    // < --- Side Bar --- >
    exports.SIDE_BAR_BACKGROUND = colorRegistry_1.registerColor('sideBar.background', {
        dark: '#252526',
        light: '#F3F3F3',
        hc: '#000000'
    }, nls.localize('sideBarBackground', "Side bar background color. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_FOREGROUND = colorRegistry_1.registerColor('sideBar.foreground', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('sideBarForeground', "Side bar foreground color. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_BORDER = colorRegistry_1.registerColor('sideBar.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('sideBarBorder', "Side bar border color on the side separating to the editor. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_TITLE_FOREGROUND = colorRegistry_1.registerColor('sideBarTitle.foreground', {
        dark: exports.SIDE_BAR_FOREGROUND,
        light: exports.SIDE_BAR_FOREGROUND,
        hc: exports.SIDE_BAR_FOREGROUND
    }, nls.localize('sideBarTitleForeground', "Side bar title foreground color. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_DRAG_AND_DROP_BACKGROUND = colorRegistry_1.registerColor('sideBar.dropBackground', {
        dark: color_1.Color.white.transparent(0.12),
        light: color_1.Color.white.transparent(0.12),
        hc: color_1.Color.white.transparent(0.12),
    }, nls.localize('sideBarDragAndDropBackground', "Drag and drop feedback color for the side bar sections. The color should have transparency so that the side bar sections can still shine through. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_SECTION_HEADER_BACKGROUND = colorRegistry_1.registerColor('sideBarSectionHeader.background', {
        dark: color_1.Color.fromHex('#808080').transparent(0.2),
        light: color_1.Color.fromHex('#808080').transparent(0.2),
        hc: null
    }, nls.localize('sideBarSectionHeaderBackground', "Side bar section header background color. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_SECTION_HEADER_FOREGROUND = colorRegistry_1.registerColor('sideBarSectionHeader.foreground', {
        dark: exports.SIDE_BAR_FOREGROUND,
        light: exports.SIDE_BAR_FOREGROUND,
        hc: exports.SIDE_BAR_FOREGROUND
    }, nls.localize('sideBarSectionHeaderForeground', "Side bar section header foreground color. The side bar is the container for views like explorer and search."));
    exports.SIDE_BAR_SECTION_HEADER_BORDER = colorRegistry_1.registerColor('sideBarSectionHeader.border', {
        dark: colorRegistry_1.contrastBorder,
        light: colorRegistry_1.contrastBorder,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('sideBarSectionHeaderBorder', "Side bar section header border color. The side bar is the container for views like explorer and search."));
    // < --- Title Bar --- >
    exports.TITLE_BAR_ACTIVE_FOREGROUND = colorRegistry_1.registerColor('titleBar.activeForeground', {
        dark: '#CCCCCC',
        light: '#333333',
        hc: '#FFFFFF'
    }, nls.localize('titleBarActiveForeground', "Title bar foreground when the window is active. Note that this color is currently only supported on macOS."));
    exports.TITLE_BAR_INACTIVE_FOREGROUND = colorRegistry_1.registerColor('titleBar.inactiveForeground', {
        dark: colorRegistry_1.transparent(exports.TITLE_BAR_ACTIVE_FOREGROUND, 0.6),
        light: colorRegistry_1.transparent(exports.TITLE_BAR_ACTIVE_FOREGROUND, 0.6),
        hc: null
    }, nls.localize('titleBarInactiveForeground', "Title bar foreground when the window is inactive. Note that this color is currently only supported on macOS."));
    exports.TITLE_BAR_ACTIVE_BACKGROUND = colorRegistry_1.registerColor('titleBar.activeBackground', {
        dark: '#3C3C3C',
        light: '#DDDDDD',
        hc: '#000000'
    }, nls.localize('titleBarActiveBackground', "Title bar background when the window is active. Note that this color is currently only supported on macOS."));
    exports.TITLE_BAR_INACTIVE_BACKGROUND = colorRegistry_1.registerColor('titleBar.inactiveBackground', {
        dark: colorRegistry_1.transparent(exports.TITLE_BAR_ACTIVE_BACKGROUND, 0.6),
        light: colorRegistry_1.transparent(exports.TITLE_BAR_ACTIVE_BACKGROUND, 0.6),
        hc: null
    }, nls.localize('titleBarInactiveBackground', "Title bar background when the window is inactive. Note that this color is currently only supported on macOS."));
    exports.TITLE_BAR_BORDER = colorRegistry_1.registerColor('titleBar.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('titleBarBorder', "Title bar border color. Note that this color is currently only supported on macOS."));
    // < --- Menubar --- >
    exports.MENUBAR_SELECTION_FOREGROUND = colorRegistry_1.registerColor('menubar.selectionForeground', {
        dark: exports.TITLE_BAR_ACTIVE_FOREGROUND,
        light: exports.TITLE_BAR_ACTIVE_FOREGROUND,
        hc: exports.TITLE_BAR_ACTIVE_FOREGROUND
    }, nls.localize('menubarSelectionForeground', "Foreground color of the selected menu item in the menubar."));
    exports.MENUBAR_SELECTION_BACKGROUND = colorRegistry_1.registerColor('menubar.selectionBackground', {
        dark: colorRegistry_1.transparent(color_1.Color.white, 0.1),
        light: colorRegistry_1.transparent(color_1.Color.black, 0.1),
        hc: null
    }, nls.localize('menubarSelectionBackground', "Background color of the selected menu item in the menubar."));
    exports.MENUBAR_SELECTION_BORDER = colorRegistry_1.registerColor('menubar.selectionBorder', {
        dark: null,
        light: null,
        hc: colorRegistry_1.activeContrastBorder
    }, nls.localize('menubarSelectionBorder', "Border color of the selected menu item in the menubar."));
    // < --- Notifications --- >
    exports.NOTIFICATIONS_CENTER_BORDER = colorRegistry_1.registerColor('notificationCenter.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('notificationCenterBorder', "Notifications center border color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_TOAST_BORDER = colorRegistry_1.registerColor('notificationToast.border', {
        dark: null,
        light: null,
        hc: colorRegistry_1.contrastBorder
    }, nls.localize('notificationToastBorder', "Notification toast border color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_FOREGROUND = colorRegistry_1.registerColor('notifications.foreground', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('notificationsForeground', "Notifications foreground color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_BACKGROUND = colorRegistry_1.registerColor('notifications.background', {
        dark: colorRegistry_1.editorWidgetBackground,
        light: colorRegistry_1.editorWidgetBackground,
        hc: colorRegistry_1.editorWidgetBackground
    }, nls.localize('notificationsBackground', "Notifications background color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_LINKS = colorRegistry_1.registerColor('notificationLink.foreground', {
        dark: colorRegistry_1.textLinkForeground,
        light: colorRegistry_1.textLinkForeground,
        hc: colorRegistry_1.textLinkForeground
    }, nls.localize('notificationsLink', "Notification links foreground color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_CENTER_HEADER_FOREGROUND = colorRegistry_1.registerColor('notificationCenterHeader.foreground', {
        dark: null,
        light: null,
        hc: null
    }, nls.localize('notificationCenterHeaderForeground', "Notifications center header foreground color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_CENTER_HEADER_BACKGROUND = colorRegistry_1.registerColor('notificationCenterHeader.background', {
        dark: colorRegistry_1.lighten(exports.NOTIFICATIONS_BACKGROUND, 0.3),
        light: colorRegistry_1.darken(exports.NOTIFICATIONS_BACKGROUND, 0.05),
        hc: exports.NOTIFICATIONS_BACKGROUND
    }, nls.localize('notificationCenterHeaderBackground', "Notifications center header background color. Notifications slide in from the bottom right of the window."));
    exports.NOTIFICATIONS_BORDER = colorRegistry_1.registerColor('notifications.border', {
        dark: exports.NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
        light: exports.NOTIFICATIONS_CENTER_HEADER_BACKGROUND,
        hc: exports.NOTIFICATIONS_CENTER_HEADER_BACKGROUND
    }, nls.localize('notificationsBorder', "Notifications border color separating from other notifications in the notifications center. Notifications slide in from the bottom right of the window."));
    /**
     * Base class for all themable workbench components.
     */
    var Themable = /** @class */ (function (_super) {
        __extends(Themable, _super);
        function Themable(themeService) {
            var _this = _super.call(this) || this;
            _this.themeService = themeService;
            _this.theme = themeService.getTheme();
            // Hook up to theme changes
            _this._register(_this.themeService.onThemeChange(function (theme) { return _this.onThemeChange(theme); }));
            return _this;
        }
        Themable.prototype.onThemeChange = function (theme) {
            this.theme = theme;
            this.updateStyles();
        };
        Themable.prototype.updateStyles = function () {
            // Subclasses to override
        };
        Themable.prototype.getColor = function (id, modify) {
            var color = this.theme.getColor(id);
            if (color && modify) {
                color = modify(color, this.theme);
            }
            return color ? color.toString() : null;
        };
        return Themable;
    }(lifecycle_1.Disposable));
    exports.Themable = Themable;
});














define(__m[147/*vs/workbench/common/component*/], __M([0/*require*/,1/*exports*/,348/*vs/workbench/common/memento*/,58/*vs/workbench/common/theme*/]), function (require, exports, memento_1, theme_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Component = /** @class */ (function (_super) {
        __extends(Component, _super);
        function Component(id, themeService) {
            var _this = _super.call(this, themeService) || this;
            _this.id = id;
            _this.componentMemento = new memento_1.Memento(_this.id);
            return _this;
        }
        Component.prototype.getId = function () {
            return this.id;
        };
        /**
        * Returns a JSON Object that represents the data of this memento. The optional
        * parameter scope allows to specify the scope of the memento to load. If not
        * provided, the scope will be global, Scope.WORKSPACE can be used to
        * scope the memento to the workspace.
        *
        * Mementos are shared across components with the same id. This means that multiple components
        * with the same id will store data into the same data structure.
        */
        Component.prototype.getMemento = function (storageService, scope) {
            if (scope === void 0) { scope = 0 /* GLOBAL */; }
            return this.componentMemento.getMemento(storageService, scope);
        };
        /**
        * Saves all data of the mementos that have been loaded to the local storage. This includes
        * global and workspace scope.
        *
        * Mementos are shared across components with the same id. This means that multiple components
        * with the same id will store data into the same data structure.
        */
        Component.prototype.saveMemento = function () {
            this.componentMemento.saveMemento();
        };
        Component.prototype.shutdown = function () {
            // Save Memento
            this.saveMemento();
        };
        return Component;
    }(theme_1.Themable));
    exports.Component = Component;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[182/*vs/workbench/browser/composite*/], __M([0/*require*/,1/*exports*/,15/*vs/base/common/actions*/,147/*vs/workbench/common/component*/,6/*vs/base/common/event*/,8/*vs/base/browser/dom*/]), function (require, exports, actions_1, component_1, event_1, dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Composites are layed out in the sidebar and panel part of the workbench. At a time only one composite
     * can be open in the sidebar, and only one composite can be open in the panel.
     * Each composite has a minimized representation that is good enough to provide some
     * information about the state of the composite data.
     * The workbench will keep a composite alive after it has been created and show/hide it based on
     * user interaction. The lifecycle of a composite goes in the order create(), setVisible(true|false),
     * layout(), focus(), dispose(). During use of the workbench, a composite will often receive a setVisible,
     * layout and focus call, but only one create and dispose call.
     */
    var Composite = /** @class */ (function (_super) {
        __extends(Composite, _super);
        /**
         * Create a new composite with the given ID and context.
         */
        function Composite(id, _telemetryService, themeService) {
            var _this = _super.call(this, id, themeService) || this;
            _this._telemetryService = _telemetryService;
            _this._onTitleAreaUpdate = _this._register(new event_1.Emitter());
            _this.visible = false;
            return _this;
        }
        Object.defineProperty(Composite.prototype, "onTitleAreaUpdate", {
            get: function () { return this._onTitleAreaUpdate.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Composite.prototype, "onDidFocus", {
            get: function () {
                if (!this._onDidFocus) {
                    this._registerFocusTrackEvents();
                }
                return this._onDidFocus.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Composite.prototype, "onDidBlur", {
            get: function () {
                if (!this._onDidBlur) {
                    this._registerFocusTrackEvents();
                }
                return this._onDidBlur.event;
            },
            enumerable: true,
            configurable: true
        });
        Composite.prototype._registerFocusTrackEvents = function () {
            var _this = this;
            this._onDidFocus = this._register(new event_1.Emitter());
            this._onDidBlur = this._register(new event_1.Emitter());
            var focusTracker = this._register(dom_1.trackFocus(this.getContainer()));
            this._register(focusTracker.onDidFocus(function () { return _this._onDidFocus.fire(); }));
            this._register(focusTracker.onDidBlur(function () { return _this._onDidBlur.fire(); }));
        };
        Composite.prototype.getTitle = function () {
            return null;
        };
        Object.defineProperty(Composite.prototype, "telemetryService", {
            get: function () {
                return this._telemetryService;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Note: Clients should not call this method, the workbench calls this
         * method. Calling it otherwise may result in unexpected behavior.
         *
         * Called to create this composite on the provided parent. This method is only
         * called once during the lifetime of the workbench.
         * Note that DOM-dependent calculations should be performed from the setVisible()
         * call. Only then the composite will be part of the DOM.
         */
        Composite.prototype.create = function (parent) {
            this.parent = parent;
            return Promise.resolve(null);
        };
        Composite.prototype.updateStyles = function () {
            _super.prototype.updateStyles.call(this);
        };
        /**
         * Returns the container this composite is being build in.
         */
        Composite.prototype.getContainer = function () {
            return this.parent;
        };
        /**
         * Note: Clients should not call this method, the workbench calls this
         * method. Calling it otherwise may result in unexpected behavior.
         *
         * Called to indicate that the composite has become visible or hidden. This method
         * is called more than once during workbench lifecycle depending on the user interaction.
         * The composite will be on-DOM if visible is set to true and off-DOM otherwise.
         *
         * The returned promise is complete when the composite is visible. As such it is valid
         * to do a long running operation from this call. Typically this operation should be
         * fast though because setVisible might be called many times during a session.
         */
        Composite.prototype.setVisible = function (visible) {
            this.visible = visible;
            return Promise.resolve(null);
        };
        /**
         * Called when this composite should receive keyboard focus.
         */
        Composite.prototype.focus = function () {
            // Subclasses can implement
        };
        /**
         * Returns an array of actions to show in the action bar of the composite.
         */
        Composite.prototype.getActions = function () {
            return [];
        };
        /**
         * Returns an array of actions to show in the action bar of the composite
         * in a less prominent way then action from getActions.
         */
        Composite.prototype.getSecondaryActions = function () {
            return [];
        };
        /**
         * Returns an array of actions to show in the context menu of the composite
         */
        Composite.prototype.getContextMenuActions = function () {
            return [];
        };
        /**
         * For any of the actions returned by this composite, provide an IActionItem in
         * cases where the implementor of the composite wants to override the presentation
         * of an action. Returns null to indicate that the action is not rendered through
         * an action item.
         */
        Composite.prototype.getActionItem = function (action) {
            return null;
        };
        /**
         * Returns the instance of IActionRunner to use with this composite for the
         * composite tool bar.
         */
        Composite.prototype.getActionRunner = function () {
            if (!this.actionRunner) {
                this.actionRunner = new actions_1.ActionRunner();
            }
            return this.actionRunner;
        };
        /**
         * Method for composite implementors to indicate to the composite container that the title or the actions
         * of the composite have changed. Calling this method will cause the container to ask for title (getTitle())
         * and actions (getActions(), getSecondaryActions()) if the composite is visible or the next time the composite
         * gets visible.
         */
        Composite.prototype.updateTitleArea = function () {
            this._onTitleAreaUpdate.fire();
        };
        /**
         * Returns true if this composite is currently visible and false otherwise.
         */
        Composite.prototype.isVisible = function () {
            return this.visible;
        };
        /**
         * Returns the underlying composite control or null if it is not accessible.
         */
        Composite.prototype.getControl = function () {
            return null;
        };
        return Composite;
    }(component_1.Component));
    exports.Composite = Composite;
    /**
     * A composite descriptor is a leightweight descriptor of a composite in the workbench.
     */
    var CompositeDescriptor = /** @class */ (function () {
        function CompositeDescriptor(ctor, id, name, cssClass, order, keybindingId) {
            this.ctor = ctor;
            this.id = id;
            this.name = name;
            this.cssClass = cssClass;
            this.order = order;
            this.enabled = true;
            this.keybindingId = keybindingId;
        }
        CompositeDescriptor.prototype.instantiate = function (instantiationService) {
            return instantiationService.createInstance(this.ctor);
        };
        return CompositeDescriptor;
    }());
    exports.CompositeDescriptor = CompositeDescriptor;
    var CompositeRegistry = /** @class */ (function () {
        function CompositeRegistry() {
            this._onDidRegister = new event_1.Emitter();
            this.composites = [];
        }
        Object.defineProperty(CompositeRegistry.prototype, "onDidRegister", {
            get: function () { return this._onDidRegister.event; },
            enumerable: true,
            configurable: true
        });
        CompositeRegistry.prototype.registerComposite = function (descriptor) {
            if (this.compositeById(descriptor.id) !== null) {
                return;
            }
            this.composites.push(descriptor);
            this._onDidRegister.fire(descriptor);
        };
        CompositeRegistry.prototype.getComposite = function (id) {
            return this.compositeById(id);
        };
        CompositeRegistry.prototype.getComposites = function () {
            return this.composites.slice(0);
        };
        CompositeRegistry.prototype.compositeById = function (id) {
            for (var i = 0; i < this.composites.length; i++) {
                if (this.composites[i].id === id) {
                    return this.composites[i];
                }
            }
            return null;
        };
        return CompositeRegistry;
    }());
    exports.CompositeRegistry = CompositeRegistry;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[180/*vs/workbench/browser/panel*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,182/*vs/workbench/browser/composite*/,15/*vs/base/common/actions*/,8/*vs/base/browser/dom*/]), function (require, exports, platform_1, composite_1, actions_1, dom_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Panel = /** @class */ (function (_super) {
        __extends(Panel, _super);
        function Panel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Panel;
    }(composite_1.Composite));
    exports.Panel = Panel;
    /**
     * A panel descriptor is a leightweight descriptor of a panel in the workbench.
     */
    var PanelDescriptor = /** @class */ (function (_super) {
        __extends(PanelDescriptor, _super);
        function PanelDescriptor(ctor, id, name, cssClass, order, _commandId) {
            return _super.call(this, ctor, id, name, cssClass, order, _commandId) || this;
        }
        return PanelDescriptor;
    }(composite_1.CompositeDescriptor));
    exports.PanelDescriptor = PanelDescriptor;
    var PanelRegistry = /** @class */ (function (_super) {
        __extends(PanelRegistry, _super);
        function PanelRegistry() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Registers a panel to the platform.
         */
        PanelRegistry.prototype.registerPanel = function (descriptor) {
            _super.prototype.registerComposite.call(this, descriptor);
        };
        /**
         * Returns an array of registered panels known to the platform.
         */
        PanelRegistry.prototype.getPanels = function () {
            return this.getComposites();
        };
        /**
         * Sets the id of the panel that should open on startup by default.
         */
        PanelRegistry.prototype.setDefaultPanelId = function (id) {
            this.defaultPanelId = id;
        };
        /**
         * Gets the id of the panel that should open on startup by default.
         */
        PanelRegistry.prototype.getDefaultPanelId = function () {
            return this.defaultPanelId;
        };
        return PanelRegistry;
    }(composite_1.CompositeRegistry));
    exports.PanelRegistry = PanelRegistry;
    /**
     * A reusable action to toggle a panel with a specific id depending on focus.
     */
    var TogglePanelAction = /** @class */ (function (_super) {
        __extends(TogglePanelAction, _super);
        function TogglePanelAction(id, label, panelId, panelService, partService, cssClass) {
            var _this = _super.call(this, id, label, cssClass) || this;
            _this.panelService = panelService;
            _this.partService = partService;
            _this.panelId = panelId;
            return _this;
        }
        TogglePanelAction.prototype.run = function () {
            if (this.isPanelFocused()) {
                return this.partService.setPanelHidden(true);
            }
            return this.panelService.openPanel(this.panelId, true);
        };
        TogglePanelAction.prototype.isPanelActive = function () {
            var activePanel = this.panelService.getActivePanel();
            return activePanel && activePanel.getId() === this.panelId;
        };
        TogglePanelAction.prototype.isPanelFocused = function () {
            var activeElement = document.activeElement;
            return this.isPanelActive() && activeElement && dom_1.isAncestor(activeElement, this.partService.getContainer(2 /* PANEL_PART */));
        };
        return TogglePanelAction;
    }(actions_1.Action));
    exports.TogglePanelAction = TogglePanelAction;
    exports.Extensions = {
        Panels: 'workbench.contributions.panels'
    };
    platform_1.Registry.add(exports.Extensions.Panels, new PanelRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[364/*vs/workbench/browser/part*/], __M([0/*require*/,1/*exports*/,147/*vs/workbench/common/component*/,8/*vs/base/browser/dom*/,373/*vs/css!vs/workbench/browser/media/part*/]), function (require, exports, component_1, dom_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Parts are layed out in the workbench and have their own layout that arranges an optional title
     * and mandatory content area to show content.
     */
    var Part = /** @class */ (function (_super) {
        __extends(Part, _super);
        function Part(id, options, themeService) {
            var _this = _super.call(this, id, themeService) || this;
            _this.options = options;
            return _this;
        }
        Part.prototype.onThemeChange = function (theme) {
            // only call if our create() method has been called
            if (this.parent) {
                _super.prototype.onThemeChange.call(this, theme);
            }
        };
        /**
         * Note: Clients should not call this method, the workbench calls this
         * method. Calling it otherwise may result in unexpected behavior.
         *
         * Called to create title and content area of the part.
         */
        Part.prototype.create = function (parent) {
            this.parent = parent;
            this.titleArea = this.createTitleArea(parent);
            this.contentArea = this.createContentArea(parent);
            this.partLayout = new PartLayout(this.parent, this.options, this.titleArea, this.contentArea);
            this.updateStyles();
        };
        /**
         * Returns the overall part container.
         */
        Part.prototype.getContainer = function () {
            return this.parent;
        };
        /**
         * Subclasses override to provide a title area implementation.
         */
        Part.prototype.createTitleArea = function (parent) {
            return null;
        };
        /**
         * Returns the title area container.
         */
        Part.prototype.getTitleArea = function () {
            return this.titleArea;
        };
        /**
         * Subclasses override to provide a content area implementation.
         */
        Part.prototype.createContentArea = function (parent) {
            return null;
        };
        /**
         * Returns the content area container.
         */
        Part.prototype.getContentArea = function () {
            return this.contentArea;
        };
        /**
         * Layout title and content area in the given dimension.
         */
        Part.prototype.layout = function (dimension) {
            return this.partLayout.layout(dimension);
        };
        return Part;
    }(component_1.Component));
    exports.Part = Part;
    var TITLE_HEIGHT = 35;
    var PartLayout = /** @class */ (function () {
        function PartLayout(container, options, titleArea, contentArea) {
            this.options = options;
            this.contentArea = contentArea;
        }
        PartLayout.prototype.layout = function (dimension) {
            var width = dimension.width, height = dimension.height;
            // Return the applied sizes to title and content
            var sizes = [];
            // Title Size: Width (Fill), Height (Variable)
            var titleSize;
            if (this.options && this.options.hasTitle) {
                titleSize = new dom_1.Dimension(width, Math.min(height, TITLE_HEIGHT));
            }
            else {
                titleSize = new dom_1.Dimension(0, 0);
            }
            // Content Size: Width (Fill), Height (Variable)
            var contentSize = new dom_1.Dimension(width, height - titleSize.height);
            if (this.options && typeof this.options.borderWidth === 'function') {
                contentSize.width -= this.options.borderWidth(); // adjust for border size
            }
            sizes.push(titleSize);
            sizes.push(contentSize);
            // Content
            if (this.contentArea) {
                dom_1.size(this.contentArea, contentSize.width, contentSize.height);
            }
            return sizes;
        };
        return PartLayout;
    }());
    exports.PartLayout = PartLayout;
});














define(__m[74/*vs/workbench/browser/parts/editor/baseEditor*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,180/*vs/workbench/browser/panel*/,13/*vs/workbench/common/editor*/,39/*vs/base/common/map*/,6/*vs/base/common/event*/,29/*vs/base/common/types*/,87/*vs/workbench/browser/parts/editor/editor*/]), function (require, exports, winjs_base_1, panel_1, editor_1, map_1, event_1, types_1, editor_2) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The base class of editors in the workbench. Editors register themselves for specific editor inputs.
     * Editors are layed out in the editor part of the workbench in editor groups. Multiple editors can be
     * open at the same time. Each editor has a minimized representation that is good enough to provide some
     * information about the state of the editor data.
     *
     * The workbench will keep an editor alive after it has been created and show/hide it based on
     * user interaction. The lifecycle of a editor goes in the order create(), setVisible(true|false),
     * layout(), setInput(), focus(), dispose(). During use of the workbench, a editor will often receive a
     * clearInput, setVisible, layout and focus call, but only one create and dispose call.
     *
     * This class is only intended to be subclassed and not instantiated.
     */
    var BaseEditor = /** @class */ (function (_super) {
        __extends(BaseEditor, _super);
        function BaseEditor(id, telemetryService, themeService) {
            var _this = _super.call(this, id, telemetryService, themeService) || this;
            _this.minimumWidth = editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.width;
            _this.maximumWidth = editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.width;
            _this.minimumHeight = editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.height;
            _this.maximumHeight = editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.height;
            _this.onDidSizeConstraintsChange = event_1.Event.None;
            return _this;
        }
        Object.defineProperty(BaseEditor.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseEditor.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseEditor.prototype, "group", {
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Note: Clients should not call this method, the workbench calls this
         * method. Calling it otherwise may result in unexpected behavior.
         *
         * Sets the given input with the options to the editor. The input is guaranteed
         * to be different from the previous input that was set using the input.matches()
         * method.
         *
         * The provided cancellation token should be used to test if the operation
         * was cancelled.
         */
        BaseEditor.prototype.setInput = function (input, options, token) {
            this._input = input;
            this._options = options;
            return winjs_base_1.TPromise.wrap(null);
        };
        /**
         * Called to indicate to the editor that the input should be cleared and
         * resources associated with the input should be freed.
         */
        BaseEditor.prototype.clearInput = function () {
            this._input = null;
            this._options = null;
        };
        /**
         * Note: Clients should not call this method, the workbench calls this
         * method. Calling it otherwise may result in unexpected behavior.
         *
         * Sets the given options to the editor. Clients should apply the options
         * to the current input.
         */
        BaseEditor.prototype.setOptions = function (options) {
            this._options = options;
        };
        BaseEditor.prototype.create = function (parent) {
            var res = _super.prototype.create.call(this, parent);
            // Create Editor
            this.createEditor(parent);
            return res;
        };
        BaseEditor.prototype.setVisible = function (visible, group) {
            var promise = _super.prototype.setVisible.call(this, visible);
            // Propagate to Editor
            this.setEditorVisible(visible, group);
            return promise;
        };
        /**
         * Indicates that the editor control got visible or hidden in a specific group. A
         * editor instance will only ever be visible in one editor group.
         *
         * @param visible the state of visibility of this editor
         * @param group the editor group this editor is in.
         */
        BaseEditor.prototype.setEditorVisible = function (visible, group) {
            this._group = group;
        };
        BaseEditor.prototype.getEditorMemento = function (storageService, editorGroupService, key, limit) {
            if (limit === void 0) { limit = 10; }
            var mementoKey = "" + this.getId() + key;
            var editorMemento = BaseEditor.EDITOR_MEMENTOS.get(mementoKey);
            if (!editorMemento) {
                editorMemento = new EditorMemento(this.getId(), key, this.getMemento(storageService, 1 /* WORKSPACE */), limit, editorGroupService);
                BaseEditor.EDITOR_MEMENTOS.set(mementoKey, editorMemento);
            }
            return editorMemento;
        };
        BaseEditor.prototype.shutdown = function () {
            var _this = this;
            // Shutdown all editor memento for this editor type
            BaseEditor.EDITOR_MEMENTOS.forEach(function (editorMemento) {
                if (editorMemento.id === _this.getId()) {
                    editorMemento.shutdown();
                }
            });
            _super.prototype.shutdown.call(this);
        };
        BaseEditor.prototype.dispose = function () {
            this._input = null;
            this._options = null;
            _super.prototype.dispose.call(this);
        };
        BaseEditor.EDITOR_MEMENTOS = new Map();
        return BaseEditor;
    }(panel_1.Panel));
    exports.BaseEditor = BaseEditor;
    var EditorMemento = /** @class */ (function () {
        function EditorMemento(_id, key, memento, limit, editorGroupService) {
            this._id = _id;
            this.key = key;
            this.memento = memento;
            this.limit = limit;
            this.editorGroupService = editorGroupService;
            this.cleanedUp = false;
        }
        Object.defineProperty(EditorMemento.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        EditorMemento.prototype.saveState = function (group, resourceOrEditor, state) {
            var _this = this;
            var resource = this.doGetResource(resourceOrEditor);
            if (!resource || !group) {
                return; // we are not in a good state to save any state for a resource
            }
            var cache = this.doLoad();
            var mementoForResource = cache.get(resource.toString());
            if (!mementoForResource) {
                mementoForResource = Object.create(null);
                cache.set(resource.toString(), mementoForResource);
            }
            mementoForResource[group.id] = state;
            // Automatically clear when editor input gets disposed if any
            if (resourceOrEditor instanceof editor_1.EditorInput) {
                event_1.once(resourceOrEditor.onDispose)(function () {
                    _this.clearState(resource);
                });
            }
        };
        EditorMemento.prototype.loadState = function (group, resourceOrEditor) {
            var resource = this.doGetResource(resourceOrEditor);
            if (!resource || !group) {
                return void 0; // we are not in a good state to load any state for a resource
            }
            var cache = this.doLoad();
            var mementoForResource = cache.get(resource.toString());
            if (mementoForResource) {
                return mementoForResource[group.id];
            }
            return void 0;
        };
        EditorMemento.prototype.clearState = function (resourceOrEditor, group) {
            var resource = this.doGetResource(resourceOrEditor);
            if (resource) {
                var cache = this.doLoad();
                if (group) {
                    var resourceViewState = cache.get(resource.toString());
                    if (resourceViewState) {
                        delete resourceViewState[group.id];
                    }
                }
                else {
                    cache.delete(resource.toString());
                }
            }
        };
        EditorMemento.prototype.doGetResource = function (resourceOrEditor) {
            if (resourceOrEditor instanceof editor_1.EditorInput) {
                return resourceOrEditor.getResource();
            }
            return resourceOrEditor;
        };
        EditorMemento.prototype.doLoad = function () {
            if (!this.cache) {
                this.cache = new map_1.LRUCache(this.limit);
                // Restore from serialized map state
                var rawEditorMemento = this.memento[this.key];
                if (Array.isArray(rawEditorMemento)) {
                    this.cache.fromJSON(rawEditorMemento);
                }
            }
            return this.cache;
        };
        EditorMemento.prototype.shutdown = function () {
            var cache = this.doLoad();
            // Cleanup once during shutdown
            if (!this.cleanedUp) {
                this.cleanUp();
                this.cleanedUp = true;
            }
            this.memento[this.key] = cache.toJSON();
        };
        EditorMemento.prototype.cleanUp = function () {
            var _this = this;
            var cache = this.doLoad();
            // Remove groups from states that no longer exist
            cache.forEach(function (mapGroupToMemento, resource) {
                Object.keys(mapGroupToMemento).forEach(function (group) {
                    var groupId = Number(group);
                    if (!_this.editorGroupService.getGroup(groupId)) {
                        delete mapGroupToMemento[groupId];
                        if (types_1.isEmptyObject(mapGroupToMemento)) {
                            cache.delete(resource);
                        }
                    }
                });
            });
        };
        return EditorMemento;
    }());
    exports.EditorMemento = EditorMemento;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[105/*vs/workbench/browser/editor*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,29/*vs/base/common/types*/]), function (require, exports, platform_1, baseEditor_1, types_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A lightweight descriptor of an editor. The descriptor is deferred so that heavy editors
     * can load lazily in the workbench.
     */
    var EditorDescriptor = /** @class */ (function () {
        function EditorDescriptor(ctor, id, name) {
            this.ctor = ctor;
            this.id = id;
            this.name = name;
        }
        EditorDescriptor.prototype.instantiate = function (instantiationService) {
            return instantiationService.createInstance(this.ctor);
        };
        EditorDescriptor.prototype.getId = function () {
            return this.id;
        };
        EditorDescriptor.prototype.getName = function () {
            return this.name;
        };
        EditorDescriptor.prototype.describes = function (obj) {
            return obj instanceof baseEditor_1.BaseEditor && obj.getId() === this.id;
        };
        return EditorDescriptor;
    }());
    exports.EditorDescriptor = EditorDescriptor;
    var INPUT_DESCRIPTORS_PROPERTY = '__$inputDescriptors';
    var EditorRegistry = /** @class */ (function () {
        function EditorRegistry() {
            this.editors = [];
        }
        EditorRegistry.prototype.registerEditor = function (descriptor, editorInputDescriptor) {
            // Support both non-array and array parameter
            var inputDescriptors = [];
            if (!types_1.isArray(editorInputDescriptor)) {
                inputDescriptors.push(editorInputDescriptor);
            }
            else {
                inputDescriptors = editorInputDescriptor;
            }
            // Register (Support multiple Editors per Input)
            descriptor[INPUT_DESCRIPTORS_PROPERTY] = inputDescriptors;
            this.editors.push(descriptor);
        };
        EditorRegistry.prototype.getEditor = function (input) {
            var _this = this;
            var findEditorDescriptors = function (input, byInstanceOf) {
                var matchingDescriptors = [];
                for (var i = 0; i < _this.editors.length; i++) {
                    var editor = _this.editors[i];
                    var inputDescriptors = editor[INPUT_DESCRIPTORS_PROPERTY];
                    for (var j = 0; j < inputDescriptors.length; j++) {
                        var inputClass = inputDescriptors[j].ctor;
                        // Direct check on constructor type (ignores prototype chain)
                        if (!byInstanceOf && input.constructor === inputClass) {
                            matchingDescriptors.push(editor);
                            break;
                        }
                        // Normal instanceof check
                        else if (byInstanceOf && input instanceof inputClass) {
                            matchingDescriptors.push(editor);
                            break;
                        }
                    }
                }
                // If no descriptors found, continue search using instanceof and prototype chain
                if (!byInstanceOf && matchingDescriptors.length === 0) {
                    return findEditorDescriptors(input, true);
                }
                if (byInstanceOf) {
                    return matchingDescriptors;
                }
                return matchingDescriptors;
            };
            var descriptors = findEditorDescriptors(input);
            if (descriptors && descriptors.length > 0) {
                // Ask the input for its preferred Editor
                var preferredEditorId = input.getPreferredEditorId(descriptors.map(function (d) { return d.getId(); }));
                if (preferredEditorId) {
                    return this.getEditorById(preferredEditorId);
                }
                // Otherwise, first come first serve
                return descriptors[0];
            }
            return null;
        };
        EditorRegistry.prototype.getEditorById = function (editorId) {
            for (var i = 0; i < this.editors.length; i++) {
                var editor = this.editors[i];
                if (editor.getId() === editorId) {
                    return editor;
                }
            }
            return null;
        };
        EditorRegistry.prototype.getEditors = function () {
            return this.editors.slice(0);
        };
        EditorRegistry.prototype.setEditors = function (editorsToSet) {
            this.editors = editorsToSet;
        };
        EditorRegistry.prototype.getEditorInputs = function () {
            var inputClasses = [];
            for (var i = 0; i < this.editors.length; i++) {
                var editor = this.editors[i];
                var editorInputDescriptors = editor[INPUT_DESCRIPTORS_PROPERTY];
                inputClasses.push.apply(inputClasses, editorInputDescriptors.map(function (descriptor) { return descriptor.ctor; }));
            }
            return inputClasses;
        };
        return EditorRegistry;
    }());
    exports.Extensions = {
        Editors: 'workbench.contributions.editors'
    };
    platform_1.Registry.add(exports.Extensions.Editors, new EditorRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[158/*vs/workbench/browser/parts/editor/sideBySideEditor*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,9/*vs/platform/registry/common/platform*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,32/*vs/platform/telemetry/common/telemetry*/,3/*vs/platform/instantiation/common/instantiation*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,105/*vs/workbench/browser/editor*/,101/*vs/base/browser/ui/splitview/splitview*/,6/*vs/base/common/event*/]), function (require, exports, DOM, platform_1, baseEditor_1, telemetry_1, instantiation_1, themeService_1, colorRegistry_1, editor_1, splitview_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SideBySideEditor = /** @class */ (function (_super) {
        __extends(SideBySideEditor, _super);
        function SideBySideEditor(telemetryService, instantiationService, themeService) {
            var _this = _super.call(this, SideBySideEditor.ID, telemetryService, themeService) || this;
            _this.instantiationService = instantiationService;
            _this.dimension = new DOM.Dimension(0, 0);
            _this.onDidCreateEditors = _this._register(new event_1.Emitter());
            _this._onDidSizeConstraintsChange = _this._register(new event_1.Relay());
            _this.onDidSizeConstraintsChange = event_1.anyEvent(_this.onDidCreateEditors.event, _this._onDidSizeConstraintsChange.event);
            return _this;
        }
        Object.defineProperty(SideBySideEditor.prototype, "minimumMasterWidth", {
            get: function () { return this.masterEditor ? this.masterEditor.minimumWidth : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumMasterWidth", {
            get: function () { return this.masterEditor ? this.masterEditor.maximumWidth : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "minimumMasterHeight", {
            get: function () { return this.masterEditor ? this.masterEditor.minimumHeight : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumMasterHeight", {
            get: function () { return this.masterEditor ? this.masterEditor.maximumHeight : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "minimumDetailsWidth", {
            get: function () { return this.detailsEditor ? this.detailsEditor.minimumWidth : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumDetailsWidth", {
            get: function () { return this.detailsEditor ? this.detailsEditor.maximumWidth : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "minimumDetailsHeight", {
            get: function () { return this.detailsEditor ? this.detailsEditor.minimumHeight : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumDetailsHeight", {
            get: function () { return this.detailsEditor ? this.detailsEditor.maximumHeight : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "minimumWidth", {
            get: function () { return this.minimumMasterWidth + this.minimumDetailsWidth; },
            // these setters need to exist because this extends from BaseEditor
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumWidth", {
            get: function () { return this.maximumMasterWidth + this.maximumDetailsWidth; },
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "minimumHeight", {
            get: function () { return this.minimumMasterHeight + this.minimumDetailsHeight; },
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySideEditor.prototype, "maximumHeight", {
            get: function () { return this.maximumMasterHeight + this.maximumDetailsHeight; },
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        SideBySideEditor.prototype.createEditor = function (parent) {
            var _this = this;
            DOM.addClass(parent, 'side-by-side-editor');
            this.splitview = this._register(new splitview_1.SplitView(parent, { orientation: 1 /* HORIZONTAL */ }));
            this._register(this.splitview.onDidSashReset(function () { return _this.splitview.distributeViewSizes(); }));
            this.detailsEditorContainer = DOM.$('.details-editor-container');
            this.splitview.addView({
                element: this.detailsEditorContainer,
                layout: function (size) { return _this.detailsEditor && _this.detailsEditor.layout(new DOM.Dimension(size, _this.dimension.height)); },
                minimumSize: 220,
                maximumSize: Number.POSITIVE_INFINITY,
                onDidChange: event_1.Event.None
            }, splitview_1.Sizing.Distribute);
            this.masterEditorContainer = DOM.$('.master-editor-container');
            this.splitview.addView({
                element: this.masterEditorContainer,
                layout: function (size) { return _this.masterEditor && _this.masterEditor.layout(new DOM.Dimension(size, _this.dimension.height)); },
                minimumSize: 220,
                maximumSize: Number.POSITIVE_INFINITY,
                onDidChange: event_1.Event.None
            }, splitview_1.Sizing.Distribute);
            this.updateStyles();
        };
        SideBySideEditor.prototype.setInput = function (newInput, options, token) {
            var _this = this;
            var oldInput = this.input;
            return _super.prototype.setInput.call(this, newInput, options, token)
                .then(function () { return _this.updateInput(oldInput, newInput, options, token); });
        };
        SideBySideEditor.prototype.setOptions = function (options) {
            if (this.masterEditor) {
                this.masterEditor.setOptions(options);
            }
        };
        SideBySideEditor.prototype.setEditorVisible = function (visible, group) {
            if (this.masterEditor) {
                this.masterEditor.setVisible(visible, group);
            }
            if (this.detailsEditor) {
                this.detailsEditor.setVisible(visible, group);
            }
            _super.prototype.setEditorVisible.call(this, visible, group);
        };
        SideBySideEditor.prototype.clearInput = function () {
            if (this.masterEditor) {
                this.masterEditor.clearInput();
            }
            if (this.detailsEditor) {
                this.detailsEditor.clearInput();
            }
            this.disposeEditors();
            _super.prototype.clearInput.call(this);
        };
        SideBySideEditor.prototype.focus = function () {
            if (this.masterEditor) {
                this.masterEditor.focus();
            }
        };
        SideBySideEditor.prototype.layout = function (dimension) {
            this.dimension = dimension;
            this.splitview.layout(dimension.width);
        };
        SideBySideEditor.prototype.getControl = function () {
            if (this.masterEditor) {
                return this.masterEditor.getControl();
            }
            return null;
        };
        SideBySideEditor.prototype.getMasterEditor = function () {
            return this.masterEditor;
        };
        SideBySideEditor.prototype.getDetailsEditor = function () {
            return this.detailsEditor;
        };
        SideBySideEditor.prototype.updateInput = function (oldInput, newInput, options, token) {
            if (!newInput.matches(oldInput)) {
                if (oldInput) {
                    this.disposeEditors();
                }
                return this.setNewInput(newInput, options, token);
            }
            return Promise.all([this.detailsEditor.setInput(newInput.details, null, token), this.masterEditor.setInput(newInput.master, options, token)]).then(function () { return void 0; });
        };
        SideBySideEditor.prototype.setNewInput = function (newInput, options, token) {
            var detailsEditor = this._createEditor(newInput.details, this.detailsEditorContainer);
            var masterEditor = this._createEditor(newInput.master, this.masterEditorContainer);
            return this.onEditorsCreated(detailsEditor, masterEditor, newInput.details, newInput.master, options, token);
        };
        SideBySideEditor.prototype._createEditor = function (editorInput, container) {
            var descriptor = platform_1.Registry.as(editor_1.Extensions.Editors).getEditor(editorInput);
            var editor = descriptor.instantiate(this.instantiationService);
            editor.create(container);
            editor.setVisible(this.isVisible(), this.group);
            return editor;
        };
        SideBySideEditor.prototype.onEditorsCreated = function (details, master, detailsInput, masterInput, options, token) {
            var _this = this;
            this.detailsEditor = details;
            this.masterEditor = master;
            this._onDidSizeConstraintsChange.input = event_1.anyEvent(event_1.mapEvent(details.onDidSizeConstraintsChange, function () { return undefined; }), event_1.mapEvent(master.onDidSizeConstraintsChange, function () { return undefined; }));
            this.onDidCreateEditors.fire();
            return Promise.all([this.detailsEditor.setInput(detailsInput, null, token), this.masterEditor.setInput(masterInput, options, token)]).then(function () { return _this.focus(); });
        };
        SideBySideEditor.prototype.updateStyles = function () {
            _super.prototype.updateStyles.call(this);
            if (this.masterEditorContainer) {
                this.masterEditorContainer.style.boxShadow = "-6px 0 5px -5px " + this.getColor(colorRegistry_1.scrollbarShadow);
            }
        };
        SideBySideEditor.prototype.disposeEditors = function () {
            if (this.detailsEditor) {
                this.detailsEditor.dispose();
                this.detailsEditor = null;
            }
            if (this.masterEditor) {
                this.masterEditor.dispose();
                this.masterEditor = null;
            }
            this.detailsEditorContainer.innerHTML = '';
            this.masterEditorContainer.innerHTML = '';
        };
        SideBySideEditor.prototype.dispose = function () {
            this.disposeEditors();
            _super.prototype.dispose.call(this);
        };
        SideBySideEditor.ID = 'workbench.editor.sidebysideEditor';
        SideBySideEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, themeService_1.IThemeService)
        ], SideBySideEditor);
        return SideBySideEditor;
    }(baseEditor_1.BaseEditor));
    exports.SideBySideEditor = SideBySideEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[108/*vs/workbench/common/views*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,2/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/,39/*vs/base/common/map*/,9/*vs/platform/registry/common/platform*/]), function (require, exports, event_1, nls_1, instantiation_1, map_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TEST_VIEW_CONTAINER_ID = 'workbench.view.extension.test';
    var Extensions;
    (function (Extensions) {
        Extensions.ViewContainersRegistry = 'workbench.registry.view.containers';
    })(Extensions = exports.Extensions || (exports.Extensions = {}));
    var ViewContainer = /** @class */ (function () {
        function ViewContainer(id, extensionId) {
            this.id = id;
            this.extensionId = extensionId;
        }
        return ViewContainer;
    }());
    exports.ViewContainer = ViewContainer;
    var ViewContainersRegistryImpl = /** @class */ (function () {
        function ViewContainersRegistryImpl() {
            this._onDidRegister = new event_1.Emitter();
            this.onDidRegister = this._onDidRegister.event;
            this.viewContainers = new Map();
        }
        Object.defineProperty(ViewContainersRegistryImpl.prototype, "all", {
            get: function () {
                return map_1.values(this.viewContainers);
            },
            enumerable: true,
            configurable: true
        });
        ViewContainersRegistryImpl.prototype.registerViewContainer = function (id, extensionId) {
            if (!this.viewContainers.has(id)) {
                var viewContainer = new /** @class */ (function (_super) {
                    __extends(class_1, _super);
                    function class_1() {
                        return _super.call(this, id, extensionId) || this;
                    }
                    return class_1;
                }(ViewContainer));
                this.viewContainers.set(id, viewContainer);
                this._onDidRegister.fire(viewContainer);
            }
            return this.get(id);
        };
        ViewContainersRegistryImpl.prototype.get = function (id) {
            return this.viewContainers.get(id);
        };
        return ViewContainersRegistryImpl;
    }());
    platform_1.Registry.add(Extensions.ViewContainersRegistry, new ViewContainersRegistryImpl());
    exports.ViewsRegistry = new /** @class */ (function () {
        function class_2() {
            this._onViewsRegistered = new event_1.Emitter();
            this.onViewsRegistered = this._onViewsRegistered.event;
            this._onViewsDeregistered = new event_1.Emitter();
            this.onViewsDeregistered = this._onViewsDeregistered.event;
            this._viewContainer = [];
            this._views = new Map();
        }
        class_2.prototype.registerViews = function (viewDescriptors) {
            if (viewDescriptors.length) {
                var _loop_1 = function (viewDescriptor) {
                    var views = this_1._views.get(viewDescriptor.container);
                    if (!views) {
                        views = [];
                        this_1._views.set(viewDescriptor.container, views);
                        this_1._viewContainer.push(viewDescriptor.container);
                    }
                    if (views.some(function (v) { return v.id === viewDescriptor.id; })) {
                        throw new Error(nls_1.localize('duplicateId', "A view with id '{0}' is already registered in the container '{1}'", viewDescriptor.id, viewDescriptor.container.id));
                    }
                    views.push(viewDescriptor);
                };
                var this_1 = this;
                for (var _i = 0, viewDescriptors_1 = viewDescriptors; _i < viewDescriptors_1.length; _i++) {
                    var viewDescriptor = viewDescriptors_1[_i];
                    _loop_1(viewDescriptor);
                }
                this._onViewsRegistered.fire(viewDescriptors);
            }
        };
        class_2.prototype.deregisterViews = function (ids, container) {
            var views = this._views.get(container);
            if (!views) {
                return;
            }
            var viewsToDeregister = views.filter(function (view) { return ids.indexOf(view.id) !== -1; });
            if (viewsToDeregister.length) {
                var remaningViews = views.filter(function (view) { return ids.indexOf(view.id) === -1; });
                if (remaningViews.length) {
                    this._views.set(container, remaningViews);
                }
                else {
                    this._views.delete(container);
                    this._viewContainer.splice(this._viewContainer.indexOf(container), 1);
                }
                this._onViewsDeregistered.fire(viewsToDeregister);
            }
        };
        class_2.prototype.getViews = function (loc) {
            return this._views.get(loc) || [];
        };
        class_2.prototype.getView = function (id) {
            for (var _i = 0, _a = this._viewContainer; _i < _a.length; _i++) {
                var viewContainer = _a[_i];
                var viewDescriptor = (this._views.get(viewContainer) || []).filter(function (v) { return v.id === id; })[0];
                if (viewDescriptor) {
                    return viewDescriptor;
                }
            }
            return null;
        };
        class_2.prototype.getAllViews = function () {
            var allViews = [];
            this._views.forEach(function (views) { return allViews.push.apply(allViews, views); });
            return allViews;
        };
        return class_2;
    }());
    exports.IViewsService = instantiation_1.createDecorator('viewsService');
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState = exports.TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[175/*vs/workbench/electron-browser/resources*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,38/*vs/base/common/objects*/,20/*vs/platform/workspace/common/workspace*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,7/*vs/platform/configuration/common/configuration*/,142/*vs/base/common/glob*/,78/*path*/,24/*vs/base/common/paths*/]), function (require, exports, uri_1, objects, workspace_1, lifecycle_1, event_1, configuration_1, glob_1, path_1, paths_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourceGlobMatcher = /** @class */ (function (_super) {
        __extends(ResourceGlobMatcher, _super);
        function ResourceGlobMatcher(globFn, shouldUpdate, contextService, configurationService) {
            var _this = _super.call(this) || this;
            _this.globFn = globFn;
            _this.shouldUpdate = shouldUpdate;
            _this.contextService = contextService;
            _this.configurationService = configurationService;
            _this._onExpressionChange = _this._register(new event_1.Emitter());
            _this.mapRootToParsedExpression = new Map();
            _this.mapRootToExpressionConfig = new Map();
            _this.updateExcludes(false);
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(ResourceGlobMatcher.prototype, "onExpressionChange", {
            get: function () { return this._onExpressionChange.event; },
            enumerable: true,
            configurable: true
        });
        ResourceGlobMatcher.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.configurationService.onDidChangeConfiguration(function (e) {
                if (_this.shouldUpdate(e)) {
                    _this.updateExcludes(true);
                }
            }));
            this._register(this.contextService.onDidChangeWorkspaceFolders(function () { return _this.updateExcludes(true); }));
        };
        ResourceGlobMatcher.prototype.updateExcludes = function (fromEvent) {
            var _this = this;
            var changed = false;
            // Add excludes per workspaces that got added
            this.contextService.getWorkspace().folders.forEach(function (folder) {
                var rootExcludes = _this.globFn(folder.uri);
                if (!_this.mapRootToExpressionConfig.has(folder.uri.toString()) || !objects.equals(_this.mapRootToExpressionConfig.get(folder.uri.toString()), rootExcludes)) {
                    changed = true;
                    _this.mapRootToParsedExpression.set(folder.uri.toString(), glob_1.parse(rootExcludes));
                    _this.mapRootToExpressionConfig.set(folder.uri.toString(), objects.deepClone(rootExcludes));
                }
            });
            // Remove excludes per workspace no longer present
            this.mapRootToExpressionConfig.forEach(function (value, root) {
                if (root === ResourceGlobMatcher.NO_ROOT) {
                    return; // always keep this one
                }
                if (!_this.contextService.getWorkspaceFolder(uri_1.URI.parse(root))) {
                    _this.mapRootToParsedExpression.delete(root);
                    _this.mapRootToExpressionConfig.delete(root);
                    changed = true;
                }
            });
            // Always set for resources outside root as well
            var globalExcludes = this.globFn();
            if (!this.mapRootToExpressionConfig.has(ResourceGlobMatcher.NO_ROOT) || !objects.equals(this.mapRootToExpressionConfig.get(ResourceGlobMatcher.NO_ROOT), globalExcludes)) {
                changed = true;
                this.mapRootToParsedExpression.set(ResourceGlobMatcher.NO_ROOT, glob_1.parse(globalExcludes));
                this.mapRootToExpressionConfig.set(ResourceGlobMatcher.NO_ROOT, objects.deepClone(globalExcludes));
            }
            if (fromEvent && changed) {
                this._onExpressionChange.fire();
            }
        };
        ResourceGlobMatcher.prototype.matches = function (resource) {
            var folder = this.contextService.getWorkspaceFolder(resource);
            var expressionForRoot;
            if (folder && this.mapRootToParsedExpression.has(folder.uri.toString())) {
                expressionForRoot = this.mapRootToParsedExpression.get(folder.uri.toString());
            }
            else {
                expressionForRoot = this.mapRootToParsedExpression.get(ResourceGlobMatcher.NO_ROOT);
            }
            // If the resource if from a workspace, convert its absolute path to a relative
            // path so that glob patterns have a higher probability to match. For example
            // a glob pattern of "src/**" will not match on an absolute path "/folder/src/file.txt"
            // but can match on "src/file.txt"
            var resourcePathToMatch;
            if (folder) {
                resourcePathToMatch = paths_1.normalize(path_1.relative(folder.uri.fsPath, resource.fsPath));
            }
            else {
                resourcePathToMatch = resource.fsPath;
            }
            return !!expressionForRoot(resourcePathToMatch);
        };
        ResourceGlobMatcher.NO_ROOT = null;
        ResourceGlobMatcher = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, configuration_1.IConfigurationService)
        ], ResourceGlobMatcher);
        return ResourceGlobMatcher;
    }(lifecycle_1.Disposable));
    exports.ResourceGlobMatcher = ResourceGlobMatcher;
});














define(__m[172/*vs/workbench/parts/codeEditor/browser/menuPreventer*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,56/*vs/editor/browser/editorExtensions*/]), function (require, exports, lifecycle_1, editorExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Prevents the top-level menu from showing up when doing Alt + Click in the editor
     */
    var MenuPreventer = /** @class */ (function (_super) {
        __extends(MenuPreventer, _super);
        function MenuPreventer(editor) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._altListeningMouse = false;
            _this._altMouseTriggered = false;
            // A global crossover handler to prevent menu bar from showing up
            // When <alt> is hold, we will listen to mouse events and prevent
            // the release event up <alt> if the mouse is triggered.
            _this._register(_this._editor.onMouseDown(function (e) {
                if (_this._altListeningMouse) {
                    _this._altMouseTriggered = true;
                }
            }));
            _this._register(_this._editor.onKeyDown(function (e) {
                if (e.equals(512 /* Alt */)) {
                    if (!_this._altListeningMouse) {
                        _this._altMouseTriggered = false;
                    }
                    _this._altListeningMouse = true;
                }
            }));
            _this._register(_this._editor.onKeyUp(function (e) {
                if (e.equals(512 /* Alt */)) {
                    if (_this._altMouseTriggered) {
                        e.preventDefault();
                    }
                    _this._altListeningMouse = false;
                    _this._altMouseTriggered = false;
                }
            }));
            return _this;
        }
        MenuPreventer.prototype.getId = function () {
            return MenuPreventer.ID;
        };
        MenuPreventer.ID = 'editor.contrib.menuPreventer';
        return MenuPreventer;
    }(lifecycle_1.Disposable));
    exports.MenuPreventer = MenuPreventer;
    editorExtensions_1.registerEditorContribution(MenuPreventer);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[382/*vs/workbench/parts/codeEditor/browser/simpleEditorOptions*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getSimpleEditorOptions() {
        return {
            wordWrap: 'on',
            overviewRulerLanes: 0,
            glyphMargin: false,
            lineNumbers: 'off',
            folding: false,
            selectOnLineNumbers: false,
            hideCursorInOverviewRuler: true,
            selectionHighlight: false,
            scrollbar: {
                horizontal: 'hidden'
            },
            lineDecorationsWidth: 0,
            overviewRulerBorder: false,
            scrollBeyondLastLine: false,
            renderLineHighlight: 'none',
            fixedOverflowWidgets: true,
            acceptSuggestionOnEnter: 'smart',
            minimap: {
                enabled: false
            }
        };
    }
    exports.getSimpleEditorOptions = getSimpleEditorOptions;
});























define(__m[390/*vs/workbench/parts/codeEditor/electron-browser/largeFileOptimizations*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,78/*path*/,4/*vs/base/common/lifecycle*/,56/*vs/editor/browser/editorExtensions*/,28/*vs/platform/notification/common/notification*/,44/*vs/platform/storage/common/storage*/,7/*vs/platform/configuration/common/configuration*/]), function (require, exports, nls, path, lifecycle_1, editorExtensions_1, notification_1, storage_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shows a message when opening a large file which has been memory optimized (and features disabled).
     */
    var LargeFileOptimizationsWarner = /** @class */ (function (_super) {
        __extends(LargeFileOptimizationsWarner, _super);
        function LargeFileOptimizationsWarner(_editor, _notificationService, _configurationService, _storageService) {
            var _this = _super.call(this) || this;
            _this._editor = _editor;
            _this._notificationService = _notificationService;
            _this._configurationService = _configurationService;
            _this._storageService = _storageService;
            _this._isDisabled = _this._storageService.getBoolean('editor.neverPromptForLargeFiles', 0 /* GLOBAL */, false);
            _this._register(_this._editor.onDidChangeModel(function (e) {
                var model = _this._editor.getModel();
                if (!model) {
                    return;
                }
                if (_this._isDisabled) {
                    return;
                }
                if (model.isTooLargeForTokenization()) {
                    var message = nls.localize({
                        key: 'largeFile',
                        comment: [
                            'Variable 0 will be a file name.'
                        ]
                    }, "{0}: tokenization, wrapping and folding have been turned off for this large file in order to reduce memory usage and avoid freezing or crashing.", path.basename(model.uri.path));
                    _this._notificationService.prompt(notification_1.Severity.Info, message, [
                        {
                            label: nls.localize('neverShowAgain', "OK. Never show again"),
                            run: function () {
                                _this._isDisabled = true;
                                _this._storageService.store('editor.neverPromptForLargeFiles', true, 0 /* GLOBAL */);
                            }
                        },
                        {
                            label: nls.localize('removeOptimizations', "Forcefully enable features"),
                            run: function () {
                                _this._configurationService.updateValue("editor.largeFileOptimizations", false).then(function () {
                                    _this._notificationService.info(nls.localize('reopenFilePrompt', "Please reopen file in order for this setting to take effect."));
                                }, function (err) {
                                    _this._notificationService.error(err);
                                });
                            }
                        }
                    ]);
                }
            }));
            return _this;
        }
        LargeFileOptimizationsWarner.prototype.getId = function () {
            return LargeFileOptimizationsWarner.ID;
        };
        LargeFileOptimizationsWarner.ID = 'editor.contrib.largeFileOptimizationsWarner';
        LargeFileOptimizationsWarner = __decorate([
            __param(1, notification_1.INotificationService),
            __param(2, configuration_1.IConfigurationService),
            __param(3, storage_1.IStorageService)
        ], LargeFileOptimizationsWarner);
        return LargeFileOptimizationsWarner;
    }(lifecycle_1.Disposable));
    exports.LargeFileOptimizationsWarner = LargeFileOptimizationsWarner;
    editorExtensions_1.registerEditorContribution(LargeFileOptimizationsWarner);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[171/*vs/workbench/parts/codeEditor/electron-browser/selectionClipboard*/], __M([0/*require*/,1/*exports*/,350/*electron*/,18/*vs/base/common/platform*/,45/*vs/editor/browser/editorBrowser*/,4/*vs/base/common/lifecycle*/,72/*vs/editor/common/model*/,56/*vs/editor/browser/editorExtensions*/,10/*vs/platform/contextkey/common/contextkey*/,17/*vs/base/common/async*/,48/*vs/editor/common/core/range*/]), function (require, exports, electron_1, platform, editorBrowser_1, lifecycle_1, model_1, editorExtensions_1, contextkey_1, async_1, range_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SelectionClipboard = /** @class */ (function (_super) {
        __extends(SelectionClipboard, _super);
        function SelectionClipboard(editor, contextKeyService) {
            var _this = _super.call(this) || this;
            if (platform.isLinux) {
                var isEnabled_1 = editor.getConfiguration().contribInfo.selectionClipboard;
                _this._register(editor.onDidChangeConfiguration(function (e) {
                    if (e.contribInfo) {
                        isEnabled_1 = editor.getConfiguration().contribInfo.selectionClipboard;
                    }
                }));
                _this._register(editor.onMouseDown(function (e) {
                    if (!isEnabled_1) {
                        return;
                    }
                    if (!editor.getModel()) {
                        return;
                    }
                    if (e.event.middleButton) {
                        e.event.preventDefault();
                        editor.focus();
                        if (e.target.position) {
                            editor.setPosition(e.target.position);
                        }
                        if (e.target.type === editorBrowser_1.MouseTargetType.SCROLLBAR) {
                            return;
                        }
                        process.nextTick(function () {
                            // TODO@Alex: electron weirdness: calling clipboard.readText('selection') generates a paste event, so no need to execute paste ourselves
                            electron_1.clipboard.readText('selection');
                            // keybindingService.executeCommand(Handler.Paste, {
                            // 	text: clipboard.readText('selection'),
                            // 	pasteOnNewLine: false
                            // });
                        });
                    }
                }));
                var setSelectionToClipboard_1 = _this._register(new async_1.RunOnceScheduler(function () {
                    var model = editor.getModel();
                    if (!model) {
                        return;
                    }
                    var selections = editor.getSelections();
                    selections = selections.slice(0);
                    selections.sort(range_1.Range.compareRangesUsingStarts);
                    var resultLength = 0;
                    for (var i = 0; i < selections.length; i++) {
                        var sel = selections[i];
                        if (sel.isEmpty()) {
                            // Only write if all cursors have selection
                            return;
                        }
                        resultLength += model.getValueLengthInRange(sel);
                    }
                    if (resultLength > SelectionClipboard.SELECTION_LENGTH_LIMIT) {
                        // This is a large selection!
                        // => do not write it to the selection clipboard
                        return;
                    }
                    var result = [];
                    for (var i = 0; i < selections.length; i++) {
                        var sel = selections[i];
                        result.push(model.getValueInRange(sel, model_1.EndOfLinePreference.TextDefined));
                    }
                    var textToCopy = result.join(model.getEOL());
                    electron_1.clipboard.writeText(textToCopy, 'selection');
                }, 100));
                _this._register(editor.onDidChangeCursorSelection(function (e) {
                    if (!isEnabled_1) {
                        return;
                    }
                    setSelectionToClipboard_1.schedule();
                }));
            }
            return _this;
        }
        SelectionClipboard.prototype.getId = function () {
            return SelectionClipboard.ID;
        };
        SelectionClipboard.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        SelectionClipboard.SELECTION_LENGTH_LIMIT = 65536;
        SelectionClipboard.ID = 'editor.contrib.selectionClipboard';
        SelectionClipboard = __decorate([
            __param(1, contextkey_1.IContextKeyService)
        ], SelectionClipboard);
        return SelectionClipboard;
    }(lifecycle_1.Disposable));
    exports.SelectionClipboard = SelectionClipboard;
    editorExtensions_1.registerEditorContribution(SelectionClipboard);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[399/*vs/workbench/parts/codeEditor/electron-browser/suggestEnabledInput*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,95/*vs/base/browser/ui/widget*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,18/*vs/base/common/platform*/,12/*vs/base/common/uri*/,212/*vs/editor/browser/widget/codeEditorWidget*/,135/*vs/editor/common/core/position*/,48/*vs/editor/common/core/range*/,85/*vs/editor/common/modes*/,36/*vs/editor/common/services/modelService*/,481/*vs/editor/contrib/contextmenu/contextmenu*/,136/*vs/editor/contrib/snippet/snippetController2*/,480/*vs/editor/contrib/suggest/suggestController*/,3/*vs/platform/instantiation/common/instantiation*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,172/*vs/workbench/parts/codeEditor/browser/menuPreventer*/,382/*vs/workbench/parts/codeEditor/browser/simpleEditorOptions*/,89/*vs/editor/common/core/editOperation*/,38/*vs/base/common/objects*/,171/*vs/workbench/parts/codeEditor/electron-browser/selectionClipboard*/,257/*vs/css!vs/workbench/parts/codeEditor/electron-browser/media/suggestEnabledInput*/]), function (require, exports, dom_1, widget_1, event_1, lifecycle_1, platform_1, uri_1, codeEditorWidget_1, position_1, range_1, modes, modelService_1, contextmenu_1, snippetController2_1, suggestController_1, instantiation_1, colorRegistry_1, styler_1, themeService_1, menuPreventer_1, simpleEditorOptions_1, editOperation_1, objects_1, selectionClipboard_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function attachSuggestEnabledInputBoxStyler(widget, themeService, style) {
        return styler_1.attachStyler(themeService, {
            inputBackground: (style && style.inputBackground) || colorRegistry_1.inputBackground,
            inputForeground: (style && style.inputForeground) || colorRegistry_1.inputForeground,
            inputBorder: (style && style.inputBorder) || colorRegistry_1.inputBorder,
            inputPlaceholderForeground: (style && style.inputPlaceholderForeground) || colorRegistry_1.inputPlaceholderForeground,
        }, widget);
    }
    exports.attachSuggestEnabledInputBoxStyler = attachSuggestEnabledInputBoxStyler;
    var SuggestEnabledInput = /** @class */ (function (_super) {
        __extends(SuggestEnabledInput, _super);
        function SuggestEnabledInput(id, parent, suggestionProvider, ariaLabel, resourceHandle, options, instantiationService, modelService) {
            var _this = _super.call(this) || this;
            _this._onShouldFocusResults = new event_1.Emitter();
            _this.onShouldFocusResults = _this._onShouldFocusResults.event;
            _this._onEnter = new event_1.Emitter();
            _this.onEnter = _this._onEnter.event;
            _this._onInputDidChange = new event_1.Emitter();
            _this.onInputDidChange = _this._onInputDidChange.event;
            _this.disposables = [];
            _this.stylingContainer = dom_1.append(parent, dom_1.$('.suggest-input-container'));
            _this.placeholderText = dom_1.append(_this.stylingContainer, dom_1.$('.suggest-input-placeholder', null, options.placeholderText || ''));
            var editorOptions = objects_1.mixin(simpleEditorOptions_1.getSimpleEditorOptions(), getSuggestEnabledInputOptions(ariaLabel));
            _this.inputWidget = instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, _this.stylingContainer, editorOptions, {
                contributions: [suggestController_1.SuggestController, snippetController2_1.SnippetController2, contextmenu_1.ContextMenuController, menuPreventer_1.MenuPreventer, selectionClipboard_1.SelectionClipboard],
                isSimpleWidget: true,
            });
            var scopeHandle = uri_1.URI.parse(resourceHandle);
            _this.inputWidget.setModel(modelService.createModel('', null, scopeHandle, true));
            _this.disposables.push(_this.inputWidget.onDidPaste(function () { return _this.setValue(_this.getValue()); })); // setter cleanses
            _this.disposables.push((_this.inputWidget.onDidFocusEditorText(function () {
                if (options.focusContextKey) {
                    options.focusContextKey.set(true);
                }
                dom_1.addClass(_this.stylingContainer, 'synthetic-focus');
            })));
            _this.disposables.push((_this.inputWidget.onDidBlurEditorText(function () {
                if (options.focusContextKey) {
                    options.focusContextKey.set(false);
                }
                dom_1.removeClass(_this.stylingContainer, 'synthetic-focus');
            })));
            var onKeyDownMonaco = event_1.chain(_this.inputWidget.onKeyDown);
            onKeyDownMonaco.filter(function (e) { return e.keyCode === 3 /* Enter */; }).on(function (e) { e.preventDefault(); _this._onEnter.fire(); }, _this, _this.disposables);
            onKeyDownMonaco.filter(function (e) { return e.keyCode === 18 /* DownArrow */ && (platform_1.isMacintosh ? e.metaKey : e.ctrlKey); }).on(function () { return _this._onShouldFocusResults.fire(); }, _this, _this.disposables);
            var preexistingContent = _this.getValue();
            _this.disposables.push(_this.inputWidget.getModel().onDidChangeContent(function () {
                var content = _this.getValue();
                _this.placeholderText.style.visibility = content ? 'hidden' : 'visible';
                if (preexistingContent.trim() === content.trim()) {
                    return;
                }
                _this._onInputDidChange.fire();
                preexistingContent = content;
            }));
            var validatedSuggestProvider = {
                provideResults: suggestionProvider.provideResults,
                sortKey: suggestionProvider.sortKey || (function (a) { return a; }),
                triggerCharacters: suggestionProvider.triggerCharacters || []
            };
            _this.disposables.push(modes.CompletionProviderRegistry.register({ scheme: scopeHandle.scheme, pattern: '**/' + scopeHandle.path, hasAccessToAllModels: true }, {
                triggerCharacters: validatedSuggestProvider.triggerCharacters,
                provideCompletionItems: function (model, position, _context) {
                    var query = model.getValue();
                    var wordStart = query.lastIndexOf(' ', position.column - 1) + 1;
                    var alreadyTypedCount = position.column - wordStart - 1;
                    // dont show suggestions if the user has typed something, but hasn't used the trigger character
                    if (alreadyTypedCount > 0 && (validatedSuggestProvider.triggerCharacters).indexOf(query[wordStart]) === -1) {
                        return { suggestions: [] };
                    }
                    return {
                        suggestions: suggestionProvider.provideResults(query).map(function (result) {
                            return {
                                label: result,
                                insertText: result,
                                overwriteBefore: alreadyTypedCount,
                                sortText: validatedSuggestProvider.sortKey(result),
                                kind: 17 /* Keyword */
                            };
                        })
                    };
                }
            }));
            return _this;
        }
        SuggestEnabledInput.prototype.setValue = function (val) {
            val = val.replace(/\s/g, ' ');
            var fullRange = new range_1.Range(1, 1, 1, this.getValue().length + 1);
            this.inputWidget.executeEdits('suggestEnabledInput.setValue', [editOperation_1.EditOperation.replace(fullRange, val)]);
            this.inputWidget.setScrollTop(0);
            this.inputWidget.setPosition(new position_1.Position(1, val.length + 1));
        };
        SuggestEnabledInput.prototype.getValue = function () {
            return this.inputWidget.getValue();
        };
        SuggestEnabledInput.prototype.style = function (colors) {
            this.stylingContainer.style.backgroundColor = colors.inputBackground && colors.inputBackground.toString();
            this.stylingContainer.style.color = colors.inputForeground && colors.inputForeground.toString();
            this.placeholderText.style.color = colors.inputPlaceholderForeground && colors.inputPlaceholderForeground.toString();
            this.stylingContainer.style.borderWidth = '1px';
            this.stylingContainer.style.borderStyle = 'solid';
            this.stylingContainer.style.borderColor = colors.inputBorder ?
                colors.inputBorder.toString() :
                'transparent';
            var cursor = this.stylingContainer.getElementsByClassName('cursor')[0];
            if (cursor) {
                cursor.style.backgroundColor = colors.inputForeground && colors.inputForeground.toString();
            }
        };
        SuggestEnabledInput.prototype.focus = function (selectAll) {
            this.inputWidget.focus();
            if (selectAll && this.inputWidget.getValue()) {
                this.selectAll();
            }
        };
        SuggestEnabledInput.prototype.layout = function (dimension) {
            this.inputWidget.layout(dimension);
            this.placeholderText.style.width = dimension.width + "px";
        };
        SuggestEnabledInput.prototype.selectAll = function () {
            this.inputWidget.setSelection(new range_1.Range(1, 1, 1, this.getValue().length + 1));
        };
        SuggestEnabledInput.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            _super.prototype.dispose.call(this);
        };
        SuggestEnabledInput = __decorate([
            __param(6, instantiation_1.IInstantiationService),
            __param(7, modelService_1.IModelService)
        ], SuggestEnabledInput);
        return SuggestEnabledInput;
    }(widget_1.Widget));
    exports.SuggestEnabledInput = SuggestEnabledInput;
    // Override styles in selections.ts
    themeService_1.registerThemingParticipant(function (theme, collector) {
        var workbenchSelectionColor = theme.getColor(colorRegistry_1.selectionBackground);
        if (workbenchSelectionColor) {
            collector.addRule(".suggest-input-container .monaco-editor .focused .selected-text { background-color: " + workbenchSelectionColor + "; }");
        }
        // Override inactive selection bg
        var inputBackgroundColor = theme.getColor(colorRegistry_1.inputBackground);
        if (colorRegistry_1.inputBackground) {
            collector.addRule(".suggest-input-container .monaco-editor .selected-text { background-color: " + inputBackgroundColor + "; }");
        }
        // Override selected fg
        var inputForegroundColor = theme.getColor(colorRegistry_1.inputForeground);
        if (inputForegroundColor) {
            collector.addRule(".suggest-input-container .monaco-editor .view-line span.inline-selected-text { color: " + inputForegroundColor + "; }");
        }
    });
    function getSuggestEnabledInputOptions(ariaLabel) {
        return {
            fontSize: 13,
            lineHeight: 20,
            wordWrap: 'off',
            scrollbar: { vertical: 'hidden', },
            roundedSelection: false,
            renderIndentGuides: false,
            cursorWidth: 1,
            fontFamily: ' -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", "Ubuntu", "Droid Sans", sans-serif',
            ariaLabel: ariaLabel || '',
            snippetSuggestions: 'none',
            suggest: { filterGraceful: false },
            iconsInSuggestions: false
        };
    }
});























define(__m[410/*vs/workbench/parts/codeEditor/electron-browser/toggleMinimap*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,9/*vs/platform/registry/common/platform*/,47/*vs/workbench/common/actions*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/]), function (require, exports, nls, configuration_1, platform_1, actions_1, actions_2, actions_3) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleMinimapAction = /** @class */ (function (_super) {
        __extends(ToggleMinimapAction, _super);
        function ToggleMinimapAction(id, label, _configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this._configurationService = _configurationService;
            return _this;
        }
        ToggleMinimapAction.prototype.run = function () {
            var newValue = !this._configurationService.getValue('editor.minimap.enabled');
            return this._configurationService.updateValue('editor.minimap.enabled', newValue, 1 /* USER */);
        };
        ToggleMinimapAction.ID = 'editor.action.toggleMinimap';
        ToggleMinimapAction.LABEL = nls.localize('toggleMinimap', "View: Toggle Minimap");
        ToggleMinimapAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleMinimapAction);
        return ToggleMinimapAction;
    }(actions_2.Action));
    exports.ToggleMinimapAction = ToggleMinimapAction;
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(ToggleMinimapAction, ToggleMinimapAction.ID, ToggleMinimapAction.LABEL), 'View: Toggle Minimap');
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarViewMenu, {
        group: '5_editor',
        command: {
            id: ToggleMinimapAction.ID,
            title: nls.localize({ key: 'miToggleMinimap', comment: ['&& denotes a mnemonic'] }, "Toggle &&Minimap")
        },
        order: 2
    });
});























define(__m[411/*vs/workbench/parts/codeEditor/electron-browser/toggleMultiCursorModifier*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,18/*vs/base/common/platform*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,7/*vs/platform/configuration/common/configuration*/,107/*vs/workbench/common/contributions*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, nls, platform, platform_1, actions_1, actions_2, actions_3, configuration_1, contributions_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleMultiCursorModifierAction = /** @class */ (function (_super) {
        __extends(ToggleMultiCursorModifierAction, _super);
        function ToggleMultiCursorModifierAction(id, label, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.configurationService = configurationService;
            return _this;
        }
        ToggleMultiCursorModifierAction.prototype.run = function () {
            var editorConf = this.configurationService.getValue('editor');
            var newValue = (editorConf.multiCursorModifier === 'ctrlCmd' ? 'alt' : 'ctrlCmd');
            return this.configurationService.updateValue(ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey, newValue, 1 /* USER */);
        };
        ToggleMultiCursorModifierAction.ID = 'workbench.action.toggleMultiCursorModifier';
        ToggleMultiCursorModifierAction.LABEL = nls.localize('toggleLocation', "Toggle Multi-Cursor Modifier");
        ToggleMultiCursorModifierAction.multiCursorModifierConfigurationKey = 'editor.multiCursorModifier';
        ToggleMultiCursorModifierAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleMultiCursorModifierAction);
        return ToggleMultiCursorModifierAction;
    }(actions_1.Action));
    exports.ToggleMultiCursorModifierAction = ToggleMultiCursorModifierAction;
    var multiCursorModifier = new contextkey_1.RawContextKey('multiCursorModifier', 'altKey');
    var MultiCursorModifierContextKeyController = /** @class */ (function () {
        function MultiCursorModifierContextKeyController(configurationService, contextKeyService) {
            var _this = this;
            this.configurationService = configurationService;
            this._multiCursorModifier = multiCursorModifier.bindTo(contextKeyService);
            configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('editor.multiCursorModifier')) {
                    _this._update();
                }
            });
        }
        MultiCursorModifierContextKeyController.prototype._update = function () {
            var editorConf = this.configurationService.getValue('editor');
            var value = (editorConf.multiCursorModifier === 'ctrlCmd' ? 'ctrlCmd' : 'altKey');
            this._multiCursorModifier.set(value);
        };
        MultiCursorModifierContextKeyController = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, contextkey_1.IContextKeyService)
        ], MultiCursorModifierContextKeyController);
        return MultiCursorModifierContextKeyController;
    }());
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(MultiCursorModifierContextKeyController, 3 /* Running */);
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleMultiCursorModifierAction, ToggleMultiCursorModifierAction.ID, ToggleMultiCursorModifierAction.LABEL), 'Toggle Multi-Cursor Modifier');
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarSelectionMenu, {
        group: '3_multi',
        command: {
            id: ToggleMultiCursorModifierAction.ID,
            title: nls.localize('miMultiCursorAlt', "Switch to Alt+Click for Multi-Cursor")
        },
        when: multiCursorModifier.isEqualTo('ctrlCmd'),
        order: 1
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarSelectionMenu, {
        group: '3_multi',
        command: {
            id: ToggleMultiCursorModifierAction.ID,
            title: (platform.isMacintosh
                ? nls.localize('miMultiCursorCmd', "Switch to Cmd+Click for Multi-Cursor")
                : nls.localize('miMultiCursorCtrl', "Switch to Ctrl+Click for Multi-Cursor"))
        },
        when: multiCursorModifier.isEqualTo('altKey'),
        order: 1
    });
});























define(__m[413/*vs/workbench/parts/codeEditor/electron-browser/toggleRenderControlCharacter*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,9/*vs/platform/registry/common/platform*/,47/*vs/workbench/common/actions*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/]), function (require, exports, nls, configuration_1, platform_1, actions_1, actions_2, actions_3) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleRenderControlCharacterAction = /** @class */ (function (_super) {
        __extends(ToggleRenderControlCharacterAction, _super);
        function ToggleRenderControlCharacterAction(id, label, _configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this._configurationService = _configurationService;
            return _this;
        }
        ToggleRenderControlCharacterAction.prototype.run = function () {
            var newRenderControlCharacters = !this._configurationService.getValue('editor.renderControlCharacters');
            return this._configurationService.updateValue('editor.renderControlCharacters', newRenderControlCharacters, 1 /* USER */);
        };
        ToggleRenderControlCharacterAction.ID = 'editor.action.toggleRenderControlCharacter';
        ToggleRenderControlCharacterAction.LABEL = nls.localize('toggleRenderControlCharacters', "View: Toggle Control Characters");
        ToggleRenderControlCharacterAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleRenderControlCharacterAction);
        return ToggleRenderControlCharacterAction;
    }(actions_2.Action));
    exports.ToggleRenderControlCharacterAction = ToggleRenderControlCharacterAction;
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(ToggleRenderControlCharacterAction, ToggleRenderControlCharacterAction.ID, ToggleRenderControlCharacterAction.LABEL), 'View: Toggle Control Characters');
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarViewMenu, {
        group: '5_editor',
        command: {
            id: ToggleRenderControlCharacterAction.ID,
            title: nls.localize({ key: 'miToggleRenderControlCharacters', comment: ['&& denotes a mnemonic'] }, "Toggle &&Control Characters")
        },
        order: 4
    });
});























define(__m[415/*vs/workbench/parts/codeEditor/electron-browser/toggleRenderWhitespace*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,9/*vs/platform/registry/common/platform*/,47/*vs/workbench/common/actions*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/]), function (require, exports, nls, configuration_1, platform_1, actions_1, actions_2, actions_3) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleRenderWhitespaceAction = /** @class */ (function (_super) {
        __extends(ToggleRenderWhitespaceAction, _super);
        function ToggleRenderWhitespaceAction(id, label, _configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this._configurationService = _configurationService;
            return _this;
        }
        ToggleRenderWhitespaceAction.prototype.run = function () {
            var renderWhitespace = this._configurationService.getValue('editor.renderWhitespace');
            var newRenderWhitespace;
            if (renderWhitespace === 'none') {
                newRenderWhitespace = 'all';
            }
            else {
                newRenderWhitespace = 'none';
            }
            return this._configurationService.updateValue('editor.renderWhitespace', newRenderWhitespace, 1 /* USER */);
        };
        ToggleRenderWhitespaceAction.ID = 'editor.action.toggleRenderWhitespace';
        ToggleRenderWhitespaceAction.LABEL = nls.localize('toggleRenderWhitespace', "View: Toggle Render Whitespace");
        ToggleRenderWhitespaceAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleRenderWhitespaceAction);
        return ToggleRenderWhitespaceAction;
    }(actions_2.Action));
    exports.ToggleRenderWhitespaceAction = ToggleRenderWhitespaceAction;
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(ToggleRenderWhitespaceAction, ToggleRenderWhitespaceAction.ID, ToggleRenderWhitespaceAction.LABEL), 'View: Toggle Render Whitespace');
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarViewMenu, {
        group: '5_editor',
        command: {
            id: ToggleRenderWhitespaceAction.ID,
            title: nls.localize({ key: 'miToggleRenderWhitespace', comment: ['&& denotes a mnemonic'] }, "Toggle &&Render Whitespace")
        },
        order: 3
    });
});























define(__m[416/*vs/workbench/parts/codeEditor/electron-browser/toggleWordWrap*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,56/*vs/editor/browser/editorExtensions*/,96/*vs/editor/browser/services/codeEditorService*/,23/*vs/platform/actions/common/actions*/,10/*vs/platform/contextkey/common/contextkey*/,4/*vs/base/common/lifecycle*/,12/*vs/base/common/uri*/,201/*vs/editor/common/config/editorOptions*/,88/*vs/editor/common/services/resourceConfiguration*/,28/*vs/platform/notification/common/notification*/]), function (require, exports, nls, editorExtensions_1, codeEditorService_1, actions_1, contextkey_1, lifecycle_1, uri_1, editorOptions_1, resourceConfiguration_1, notification_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var transientWordWrapState = 'transientWordWrapState';
    var isWordWrapMinifiedKey = 'isWordWrapMinified';
    var isDominatedByLongLinesKey = 'isDominatedByLongLines';
    var inDiffEditorKey = 'inDiffEditor';
    /**
     * Store (in memory) the word wrap state for a particular model.
     */
    function writeTransientState(model, state, codeEditorService) {
        codeEditorService.setTransientModelProperty(model, transientWordWrapState, state);
    }
    /**
     * Read (in memory) the word wrap state for a particular model.
     */
    function readTransientState(model, codeEditorService) {
        return codeEditorService.getTransientModelProperty(model, transientWordWrapState);
    }
    function readWordWrapState(model, configurationService, codeEditorService) {
        var editorConfig = configurationService.getValue(model.uri, 'editor');
        var _configuredWordWrap = editorConfig && (typeof editorConfig.wordWrap === 'string' || typeof editorConfig.wordWrap === 'boolean') ? editorConfig.wordWrap : void 0;
        // Compatibility with old true or false values
        if (_configuredWordWrap === true) {
            _configuredWordWrap = 'on';
        }
        else if (_configuredWordWrap === false) {
            _configuredWordWrap = 'off';
        }
        var _configuredWordWrapMinified = editorConfig && typeof editorConfig.wordWrapMinified === 'boolean' ? editorConfig.wordWrapMinified : void 0;
        var _transientState = readTransientState(model, codeEditorService);
        return {
            configuredWordWrap: _configuredWordWrap,
            configuredWordWrapMinified: (typeof _configuredWordWrapMinified === 'boolean' ? _configuredWordWrapMinified : editorOptions_1.EDITOR_DEFAULTS.wordWrapMinified),
            transientState: _transientState
        };
    }
    function toggleWordWrap(editor, state) {
        if (state.transientState) {
            // toggle off => go to null
            return {
                configuredWordWrap: state.configuredWordWrap,
                configuredWordWrapMinified: state.configuredWordWrapMinified,
                transientState: null
            };
        }
        var config = editor.getConfiguration();
        var transientState;
        var actualWrappingInfo = config.wrappingInfo;
        if (actualWrappingInfo.isWordWrapMinified) {
            // => wrapping due to minified file
            transientState = {
                forceWordWrap: 'off',
                forceWordWrapMinified: false
            };
        }
        else if (state.configuredWordWrap !== 'off') {
            // => wrapping is configured to be on (or some variant)
            transientState = {
                forceWordWrap: 'off',
                forceWordWrapMinified: false
            };
        }
        else {
            // => wrapping is configured to be off
            transientState = {
                forceWordWrap: 'on',
                forceWordWrapMinified: state.configuredWordWrapMinified
            };
        }
        return {
            configuredWordWrap: state.configuredWordWrap,
            configuredWordWrapMinified: state.configuredWordWrapMinified,
            transientState: transientState
        };
    }
    var TOGGLE_WORD_WRAP_ID = 'editor.action.toggleWordWrap';
    var ToggleWordWrapAction = /** @class */ (function (_super) {
        __extends(ToggleWordWrapAction, _super);
        function ToggleWordWrapAction() {
            return _super.call(this, {
                id: TOGGLE_WORD_WRAP_ID,
                label: nls.localize('toggle.wordwrap', "View: Toggle Word Wrap"),
                alias: 'View: Toggle Word Wrap',
                precondition: null,
                kbOpts: {
                    kbExpr: null,
                    primary: 512 /* Alt */ | 56 /* KEY_Z */,
                    weight: 100 /* EditorContrib */
                }
            }) || this;
        }
        ToggleWordWrapAction.prototype.run = function (accessor, editor) {
            var editorConfiguration = editor.getConfiguration();
            if (editorConfiguration.wrappingInfo.inDiffEditor) {
                // Cannot change wrapping settings inside the diff editor
                var notificationService = accessor.get(notification_1.INotificationService);
                notificationService.info(nls.localize('wordWrap.notInDiffEditor', "Cannot toggle word wrap in a diff editor."));
                return;
            }
            var textResourceConfigurationService = accessor.get(resourceConfiguration_1.ITextResourceConfigurationService);
            var codeEditorService = accessor.get(codeEditorService_1.ICodeEditorService);
            var model = editor.getModel();
            if (!canToggleWordWrap(model.uri)) {
                return;
            }
            // Read the current state
            var currentState = readWordWrapState(model, textResourceConfigurationService, codeEditorService);
            // Compute the new state
            var newState = toggleWordWrap(editor, currentState);
            // Write the new state
            // (this will cause an event and the controller will apply the state)
            writeTransientState(model, newState.transientState, codeEditorService);
        };
        return ToggleWordWrapAction;
    }(editorExtensions_1.EditorAction));
    var ToggleWordWrapController = /** @class */ (function (_super) {
        __extends(ToggleWordWrapController, _super);
        function ToggleWordWrapController(editor, contextKeyService, configurationService, codeEditorService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.contextKeyService = contextKeyService;
            _this.configurationService = configurationService;
            _this.codeEditorService = codeEditorService;
            var configuration = _this.editor.getConfiguration();
            var isWordWrapMinified = _this.contextKeyService.createKey(isWordWrapMinifiedKey, _this._isWordWrapMinified(configuration));
            var isDominatedByLongLines = _this.contextKeyService.createKey(isDominatedByLongLinesKey, _this._isDominatedByLongLines(configuration));
            var inDiffEditor = _this.contextKeyService.createKey(inDiffEditorKey, _this._inDiffEditor(configuration));
            var currentlyApplyingEditorConfig = false;
            _this._register(editor.onDidChangeConfiguration(function (e) {
                if (!e.wrappingInfo) {
                    return;
                }
                var configuration = _this.editor.getConfiguration();
                isWordWrapMinified.set(_this._isWordWrapMinified(configuration));
                isDominatedByLongLines.set(_this._isDominatedByLongLines(configuration));
                inDiffEditor.set(_this._inDiffEditor(configuration));
                if (!currentlyApplyingEditorConfig) {
                    // I am not the cause of the word wrap getting changed
                    ensureWordWrapSettings();
                }
            }));
            _this._register(editor.onDidChangeModel(function (e) {
                ensureWordWrapSettings();
            }));
            _this._register(codeEditorService.onDidChangeTransientModelProperty(function () {
                ensureWordWrapSettings();
            }));
            var ensureWordWrapSettings = function () {
                // Ensure correct word wrap settings
                var newModel = _this.editor.getModel();
                if (!newModel) {
                    return;
                }
                var configuration = _this.editor.getConfiguration();
                if (_this._inDiffEditor(configuration)) {
                    return;
                }
                if (!canToggleWordWrap(newModel.uri)) {
                    return;
                }
                // Read current configured values and toggle state
                var desiredState = readWordWrapState(newModel, _this.configurationService, _this.codeEditorService);
                // Apply the state
                try {
                    currentlyApplyingEditorConfig = true;
                    _this._applyWordWrapState(desiredState);
                }
                finally {
                    currentlyApplyingEditorConfig = false;
                }
            };
            return _this;
        }
        ToggleWordWrapController.prototype._applyWordWrapState = function (state) {
            if (state.transientState) {
                // toggle is on
                this.editor.updateOptions({
                    wordWrap: state.transientState.forceWordWrap,
                    wordWrapMinified: state.transientState.forceWordWrapMinified
                });
                return;
            }
            // toggle is off
            this.editor.updateOptions({
                wordWrap: state.configuredWordWrap,
                wordWrapMinified: state.configuredWordWrapMinified
            });
        };
        ToggleWordWrapController.prototype._isWordWrapMinified = function (config) {
            return config.wrappingInfo.isWordWrapMinified;
        };
        ToggleWordWrapController.prototype._isDominatedByLongLines = function (config) {
            return config.wrappingInfo.isDominatedByLongLines;
        };
        ToggleWordWrapController.prototype._inDiffEditor = function (config) {
            return config.wrappingInfo.inDiffEditor;
        };
        ToggleWordWrapController.prototype.getId = function () {
            return ToggleWordWrapController._ID;
        };
        ToggleWordWrapController._ID = 'editor.contrib.toggleWordWrapController';
        ToggleWordWrapController = __decorate([
            __param(1, contextkey_1.IContextKeyService),
            __param(2, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(3, codeEditorService_1.ICodeEditorService)
        ], ToggleWordWrapController);
        return ToggleWordWrapController;
    }(lifecycle_1.Disposable));
    function canToggleWordWrap(uri) {
        if (!uri) {
            return false;
        }
        return (uri.scheme !== 'output' && uri.scheme !== 'vscode');
    }
    editorExtensions_1.registerEditorContribution(ToggleWordWrapController);
    editorExtensions_1.registerEditorAction(ToggleWordWrapAction);
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorTitle, {
        command: {
            id: TOGGLE_WORD_WRAP_ID,
            title: nls.localize('unwrapMinified', "Disable wrapping for this file"),
            iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/parts/codeEditor/electron-browser/media/WordWrap_16x.svg')) }
        },
        group: 'navigation',
        order: 1,
        when: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not(inDiffEditorKey), contextkey_1.ContextKeyExpr.has(isDominatedByLongLinesKey), contextkey_1.ContextKeyExpr.has(isWordWrapMinifiedKey))
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorTitle, {
        command: {
            id: TOGGLE_WORD_WRAP_ID,
            title: nls.localize('wrapMinified', "Enable wrapping for this file"),
            iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/parts/codeEditor/electron-browser/media/WordWrap_16x.svg')) }
        },
        group: 'navigation',
        order: 1,
        when: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not(inDiffEditorKey), contextkey_1.ContextKeyExpr.has(isDominatedByLongLinesKey), contextkey_1.ContextKeyExpr.not(isWordWrapMinifiedKey))
    });
    // View menu
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {
        group: '5_editor',
        command: {
            id: TOGGLE_WORD_WRAP_ID,
            title: nls.localize({ key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] }, "Toggle &&Word Wrap")
        },
        order: 1
    });
});























define(__m[427/*vs/workbench/parts/codeEditor/electron-browser/workbenchReferenceSearch*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/,7/*vs/platform/configuration/common/configuration*/,44/*vs/platform/storage/common/storage*/,56/*vs/editor/browser/editorExtensions*/,28/*vs/platform/notification/common/notification*/,479/*vs/editor/contrib/referenceSearch/referencesController*/,96/*vs/editor/browser/services/codeEditorService*/]), function (require, exports, instantiation_1, contextkey_1, configuration_1, storage_1, editorExtensions_1, notification_1, referencesController_1, codeEditorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkbenchReferencesController = /** @class */ (function (_super) {
        __extends(WorkbenchReferencesController, _super);
        function WorkbenchReferencesController(editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
            return _super.call(this, false, editor, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) || this;
        }
        WorkbenchReferencesController = __decorate([
            __param(1, contextkey_1.IContextKeyService),
            __param(2, codeEditorService_1.ICodeEditorService),
            __param(3, notification_1.INotificationService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, storage_1.IStorageService),
            __param(6, configuration_1.IConfigurationService)
        ], WorkbenchReferencesController);
        return WorkbenchReferencesController;
    }(referencesController_1.ReferencesController));
    exports.WorkbenchReferencesController = WorkbenchReferencesController;
    editorExtensions_1.registerEditorContribution(WorkbenchReferencesController);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[91/*vs/workbench/parts/files/common/explorerModel*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,39/*vs/base/common/map*/,18/*vs/base/common/platform*/,20/*vs/platform/workspace/common/workspace*/,13/*vs/workbench/common/editor*/,4/*vs/base/common/lifecycle*/,26/*vs/base/common/network*/,22/*vs/base/common/strings*/]), function (require, exports, uri_1, paths, resources, map_1, platform_1, workspace_1, editor_1, lifecycle_1, network_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Model = /** @class */ (function () {
        function Model(contextService) {
            var _this = this;
            this.contextService = contextService;
            var setRoots = function () { return _this._roots = _this.contextService.getWorkspace().folders
                .map(function (folder) { return new ExplorerItem(folder.uri, undefined, false, false, true, folder.name); }); };
            this._listener = this.contextService.onDidChangeWorkspaceFolders(function () { return setRoots(); });
            setRoots();
        }
        Object.defineProperty(Model.prototype, "roots", {
            get: function () {
                return this._roots;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns an array of child stat from this stat that matches with the provided path.
         * Starts matching from the first root.
         * Will return empty array in case the FileStat does not exist.
         */
        Model.prototype.findAll = function (resource) {
            return this.roots.map(function (root) { return root.find(resource); }).filter(function (stat) { return !!stat; });
        };
        /**
         * Returns a FileStat that matches the passed resource.
         * In case multiple FileStat are matching the resource (same folder opened multiple times) returns the FileStat that has the closest root.
         * Will return null in case the FileStat does not exist.
         */
        Model.prototype.findClosest = function (resource) {
            var folder = this.contextService.getWorkspaceFolder(resource);
            if (folder) {
                var root = this.roots.filter(function (r) { return r.resource.toString() === folder.uri.toString(); }).pop();
                if (root) {
                    return root.find(resource);
                }
            }
            return null;
        };
        Model.prototype.dispose = function () {
            this._listener = lifecycle_1.dispose(this._listener);
        };
        Model = __decorate([
            __param(0, workspace_1.IWorkspaceContextService)
        ], Model);
        return Model;
    }());
    exports.Model = Model;
    var ExplorerItem = /** @class */ (function () {
        function ExplorerItem(resource, root, isSymbolicLink, isReadonly, isDirectory, name, mtime, etag, isError) {
            if (name === void 0) { name = resources.basenameOrAuthority(resource); }
            this.root = root;
            this.resource = resource;
            this._name = name;
            this.isDirectory = !!isDirectory;
            this._isSymbolicLink = !!isSymbolicLink;
            this._isReadonly = !!isReadonly;
            this.etag = etag;
            this.mtime = mtime;
            this._isError = !!isError;
            if (!this.root) {
                this.root = this;
            }
            this.isDirectoryResolved = false;
        }
        Object.defineProperty(ExplorerItem.prototype, "isSymbolicLink", {
            get: function () {
                return this._isSymbolicLink;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerItem.prototype, "isDirectory", {
            get: function () {
                return this._isDirectory;
            },
            set: function (value) {
                if (value !== this._isDirectory) {
                    this._isDirectory = value;
                    if (this._isDirectory) {
                        this.children = new Map();
                    }
                    else {
                        this.children = undefined;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerItem.prototype, "isReadonly", {
            get: function () {
                return this._isReadonly;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerItem.prototype, "isError", {
            get: function () {
                return this._isError;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerItem.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        ExplorerItem.prototype.updateName = function (value) {
            // Re-add to parent since the parent has a name map to children and the name might have changed
            if (this.parent) {
                this.parent.removeChild(this);
            }
            this._name = value;
            if (this.parent) {
                this.parent.addChild(this);
            }
        };
        ExplorerItem.prototype.getId = function () {
            return this.resource.toString();
        };
        Object.defineProperty(ExplorerItem.prototype, "isRoot", {
            get: function () {
                return this === this.root;
            },
            enumerable: true,
            configurable: true
        });
        ExplorerItem.create = function (raw, root, resolveTo, isError) {
            if (isError === void 0) { isError = false; }
            var stat = new ExplorerItem(raw.resource, root, raw.isSymbolicLink, raw.isReadonly, raw.isDirectory, raw.name, raw.mtime, raw.etag, isError);
            // Recursively add children if present
            if (stat.isDirectory) {
                // isDirectoryResolved is a very important indicator in the stat model that tells if the folder was fully resolved
                // the folder is fully resolved if either it has a list of children or the client requested this by using the resolveTo
                // array of resource path to resolve.
                stat.isDirectoryResolved = !!raw.children || (!!resolveTo && resolveTo.some(function (r) {
                    return resources.isEqualOrParent(r, stat.resource);
                }));
                // Recurse into children
                if (raw.children) {
                    for (var i = 0, len = raw.children.length; i < len; i++) {
                        var child = ExplorerItem.create(raw.children[i], root, resolveTo);
                        child.parent = stat;
                        stat.addChild(child);
                    }
                }
            }
            return stat;
        };
        /**
         * Merges the stat which was resolved from the disk with the local stat by copying over properties
         * and children. The merge will only consider resolved stat elements to avoid overwriting data which
         * exists locally.
         */
        ExplorerItem.mergeLocalWithDisk = function (disk, local) {
            if (disk.resource.toString() !== local.resource.toString()) {
                return; // Merging only supported for stats with the same resource
            }
            // Stop merging when a folder is not resolved to avoid loosing local data
            var mergingDirectories = disk.isDirectory || local.isDirectory;
            if (mergingDirectories && local.isDirectoryResolved && !disk.isDirectoryResolved) {
                return;
            }
            // Properties
            local.resource = disk.resource;
            local.updateName(disk.name);
            local.isDirectory = disk.isDirectory;
            local.mtime = disk.mtime;
            local.isDirectoryResolved = disk.isDirectoryResolved;
            local._isSymbolicLink = disk.isSymbolicLink;
            local._isReadonly = disk.isReadonly;
            local._isError = disk.isError;
            // Merge Children if resolved
            if (mergingDirectories && disk.isDirectoryResolved) {
                // Map resource => stat
                var oldLocalChildren_1 = new map_1.ResourceMap();
                if (local.children) {
                    local.children.forEach(function (child) {
                        oldLocalChildren_1.set(child.resource, child);
                    });
                }
                // Clear current children
                local.children = new Map();
                // Merge received children
                disk.children.forEach(function (diskChild) {
                    var formerLocalChild = oldLocalChildren_1.get(diskChild.resource);
                    // Existing child: merge
                    if (formerLocalChild) {
                        ExplorerItem.mergeLocalWithDisk(diskChild, formerLocalChild);
                        formerLocalChild.parent = local;
                        local.addChild(formerLocalChild);
                    }
                    // New child: add
                    else {
                        diskChild.parent = local;
                        local.addChild(diskChild);
                    }
                });
            }
        };
        /**
         * Adds a child element to this folder.
         */
        ExplorerItem.prototype.addChild = function (child) {
            if (!this.children) {
                this.isDirectory = true;
            }
            // Inherit some parent properties to child
            child.parent = this;
            child.updateResource(false);
            this.children.set(this.getPlatformAwareName(child.name), child);
        };
        ExplorerItem.prototype.getChild = function (name) {
            if (!this.children) {
                return undefined;
            }
            return this.children.get(this.getPlatformAwareName(name));
        };
        /**
         * Only use this method if you need all the children since it converts a map to an array
         */
        ExplorerItem.prototype.getChildrenArray = function () {
            if (!this.children) {
                return undefined;
            }
            var items = [];
            this.children.forEach(function (child) {
                items.push(child);
            });
            return items;
        };
        ExplorerItem.prototype.getChildrenCount = function () {
            if (!this.children) {
                return 0;
            }
            return this.children.size;
        };
        /**
         * Removes a child element from this folder.
         */
        ExplorerItem.prototype.removeChild = function (child) {
            this.children.delete(this.getPlatformAwareName(child.name));
        };
        ExplorerItem.prototype.getPlatformAwareName = function (name) {
            return (platform_1.isLinux || !name) ? name : name.toLowerCase();
        };
        /**
         * Moves this element under a new parent element.
         */
        ExplorerItem.prototype.move = function (newParent, fnBetweenStates, fnDone) {
            var _this = this;
            if (!fnBetweenStates) {
                fnBetweenStates = function (cb) { cb(); };
            }
            this.parent.removeChild(this);
            fnBetweenStates(function () {
                newParent.removeChild(_this); // make sure to remove any previous version of the file if any
                newParent.addChild(_this);
                _this.updateResource(true);
                if (fnDone) {
                    fnDone();
                }
            });
        };
        ExplorerItem.prototype.updateResource = function (recursive) {
            this.resource = resources.joinPath(this.parent.resource, this.name);
            if (recursive) {
                if (this.isDirectory && this.children) {
                    this.children.forEach(function (child) {
                        child.updateResource(true);
                    });
                }
            }
        };
        /**
         * Tells this stat that it was renamed. This requires changes to all children of this stat (if any)
         * so that the path property can be updated properly.
         */
        ExplorerItem.prototype.rename = function (renamedStat) {
            // Merge a subset of Properties that can change on rename
            this.updateName(renamedStat.name);
            this.mtime = renamedStat.mtime;
            // Update Paths including children
            this.updateResource(true);
        };
        /**
         * Returns a child stat from this stat that matches with the provided path.
         * Will return "null" in case the child does not exist.
         */
        ExplorerItem.prototype.find = function (resource) {
            // Return if path found
            // For performance reasons try to do the comparison as fast as possible
            if (resource && this.resource.scheme === resource.scheme && strings_1.equalsIgnoreCase(this.resource.authority, resource.authority) &&
                (resources.hasToIgnoreCase(resource) ? strings_1.startsWithIgnoreCase(resource.path, this.resource.path) : strings_1.startsWith(resource.path, this.resource.path))) {
                return this.findByPath(strings_1.rtrim(resource.path, paths.sep), this.resource.path.length);
            }
            return null; //Unable to find
        };
        ExplorerItem.prototype.findByPath = function (path, index) {
            if (paths.isEqual(strings_1.rtrim(this.resource.path, paths.sep), path, !platform_1.isLinux)) {
                return this;
            }
            if (this.children) {
                // Ignore separtor to more easily deduct the next name to search
                while (index < path.length && path[index] === paths.sep) {
                    index++;
                }
                var indexOfNextSep = path.indexOf(paths.sep, index);
                if (indexOfNextSep === -1) {
                    // If there is no separator take the remainder of the path
                    indexOfNextSep = path.length;
                }
                // The name to search is between two separators
                var name_1 = path.substring(index, indexOfNextSep);
                var child = this.children.get(this.getPlatformAwareName(name_1));
                if (child) {
                    // We found a child with the given name, search inside it
                    return child.findByPath(path, indexOfNextSep);
                }
            }
            return null;
        };
        return ExplorerItem;
    }());
    exports.ExplorerItem = ExplorerItem;
    /* A helper that can be used to show a placeholder when creating a new stat */
    var NewStatPlaceholder = /** @class */ (function (_super) {
        __extends(NewStatPlaceholder, _super);
        function NewStatPlaceholder(isDirectory, root) {
            var _this = _super.call(this, uri_1.URI.file(''), root, false, false, false, NewStatPlaceholder.NAME) || this;
            _this.id = NewStatPlaceholder.ID++;
            _this.isDirectoryResolved = isDirectory;
            _this.directoryPlaceholder = isDirectory;
            return _this;
        }
        NewStatPlaceholder.prototype.destroy = function () {
            this.parent.removeChild(this);
            this.isDirectoryResolved = void 0;
            this.isDirectory = void 0;
            this.mtime = void 0;
        };
        NewStatPlaceholder.prototype.getId = function () {
            return "new-stat-placeholder:" + this.id + ":" + this.parent.resource.toString();
        };
        NewStatPlaceholder.prototype.isDirectoryPlaceholder = function () {
            return this.directoryPlaceholder;
        };
        NewStatPlaceholder.prototype.addChild = function (child) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.removeChild = function (child) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.move = function (newParent) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.rename = function (renamedStat) {
            throw new Error('Can\'t perform operations in NewStatPlaceholder.');
        };
        NewStatPlaceholder.prototype.find = function (resource) {
            return null;
        };
        NewStatPlaceholder.addNewStatPlaceholder = function (parent, isDirectory) {
            var child = new NewStatPlaceholder(isDirectory, parent.root);
            // Inherit some parent properties to child
            child.parent = parent;
            parent.addChild(child);
            return child;
        };
        NewStatPlaceholder.NAME = '';
        NewStatPlaceholder.ID = 0;
        return NewStatPlaceholder;
    }(ExplorerItem));
    exports.NewStatPlaceholder = NewStatPlaceholder;
    var OpenEditor = /** @class */ (function () {
        function OpenEditor(_editor, _group) {
            this._editor = _editor;
            this._group = _group;
            // noop
        }
        Object.defineProperty(OpenEditor.prototype, "editor", {
            get: function () {
                return this._editor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpenEditor.prototype, "editorIndex", {
            get: function () {
                return this._group.getIndexOfEditor(this.editor);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpenEditor.prototype, "group", {
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpenEditor.prototype, "groupId", {
            get: function () {
                return this._group.id;
            },
            enumerable: true,
            configurable: true
        });
        OpenEditor.prototype.getId = function () {
            return "openeditor:" + this.groupId + ":" + this.editorIndex + ":" + this.editor.getName() + ":" + this.editor.getDescription();
        };
        OpenEditor.prototype.isPreview = function () {
            return this._group.previewEditor === this.editor;
        };
        OpenEditor.prototype.isUntitled = function () {
            return !!editor_1.toResource(this.editor, { supportSideBySide: true, filter: network_1.Schemas.untitled });
        };
        OpenEditor.prototype.isDirty = function () {
            return this.editor.isDirty();
        };
        OpenEditor.prototype.getResource = function () {
            return editor_1.toResource(this.editor, { supportSideBySide: true });
        };
        return OpenEditor;
    }());
    exports.OpenEditor = OpenEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[178/*vs/workbench/parts/files/browser/files*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,91/*vs/workbench/parts/files/common/explorerModel*/,13/*vs/workbench/common/editor*/,176/*vs/base/parts/tree/browser/treeImpl*/,240/*vs/base/browser/ui/list/listWidget*/]), function (require, exports, uri_1, explorerModel_1, editor_1, treeImpl_1, listWidget_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Commands can get exeucted from a command pallete, from a context menu or from some list using a keybinding
    // To cover all these cases we need to properly compute the resource on which the command is being executed
    function getResourceForCommand(resource, listService, editorService) {
        if (uri_1.URI.isUri(resource)) {
            return resource;
        }
        var list = listService.lastFocusedList;
        if (list && list.isDOMFocused()) {
            var focus_1;
            if (list instanceof listWidget_1.List) {
                var focused = list.getFocusedElements();
                if (focused.length) {
                    focus_1 = focused[0];
                }
            }
            else {
                focus_1 = list.getFocus();
            }
            if (focus_1 instanceof explorerModel_1.ExplorerItem) {
                return focus_1.resource;
            }
            else if (focus_1 instanceof explorerModel_1.OpenEditor) {
                return focus_1.getResource();
            }
        }
        return editor_1.toResource(editorService.activeEditor, { supportSideBySide: true });
    }
    exports.getResourceForCommand = getResourceForCommand;
    function getMultiSelectedResources(resource, listService, editorService) {
        var list = listService.lastFocusedList;
        if (list && list.isDOMFocused()) {
            // Explorer
            if (list instanceof treeImpl_1.Tree) {
                var selection = list.getSelection().map(function (fs) { return fs.resource; });
                var focus_2 = list.getFocus();
                var mainUriStr_1 = uri_1.URI.isUri(resource) ? resource.toString() : focus_2 instanceof explorerModel_1.ExplorerItem ? focus_2.resource.toString() : undefined;
                // If the resource is passed it has to be a part of the returned context.
                // We only respect the selection if it contains the focused element.
                if (selection.some(function (s) { return uri_1.URI.isUri(s) && s.toString() === mainUriStr_1; })) {
                    return selection;
                }
            }
            // Open editors view
            if (list instanceof listWidget_1.List) {
                var selection = list.getSelectedElements().filter(function (s) { return s instanceof explorerModel_1.OpenEditor; }).map(function (oe) { return oe.getResource(); });
                var focusedElements = list.getFocusedElements();
                var focus_3 = focusedElements.length ? focusedElements[0] : undefined;
                var mainUriStr_2 = uri_1.URI.isUri(resource) ? resource.toString() : (focus_3 instanceof explorerModel_1.OpenEditor) ? focus_3.getResource().toString() : undefined;
                // We only respect the selection if it contains the main element.
                if (selection.some(function (s) { return s.toString() === mainUriStr_2; })) {
                    return selection;
                }
            }
        }
        var result = getResourceForCommand(resource, listService, editorService);
        return !!result ? [result] : [];
    }
    exports.getMultiSelectedResources = getMultiSelectedResources;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[241/*vs/workbench/parts/files/electron-browser/views/explorerDecorationsProvider*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,2/*vs/nls*/,20/*vs/platform/workspace/common/workspace*/,30/*vs/platform/theme/common/colorRegistry*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, nls_1, workspace_1, colorRegistry_1, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExplorerDecorationsProvider = /** @class */ (function () {
        function ExplorerDecorationsProvider(model, contextService) {
            var _this = this;
            this.model = model;
            this.label = nls_1.localize('label', "Explorer");
            this._onDidChange = new event_1.Emitter();
            this.toDispose = [];
            this.toDispose.push(contextService.onDidChangeWorkspaceFolders(function (e) {
                _this._onDidChange.fire(e.changed.concat(e.added).map(function (wf) { return wf.uri; }));
            }));
        }
        Object.defineProperty(ExplorerDecorationsProvider.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        ExplorerDecorationsProvider.prototype.changed = function (uris) {
            this._onDidChange.fire(uris);
        };
        ExplorerDecorationsProvider.prototype.provideDecorations = function (resource) {
            var fileStat = this.model.findClosest(resource);
            if (fileStat && fileStat.isRoot && fileStat.isError) {
                return {
                    tooltip: nls_1.localize('canNotResolve', "Can not resolve workspace folder"),
                    letter: '!',
                    color: colorRegistry_1.listInvalidItemForeground,
                };
            }
            if (fileStat && fileStat.isSymbolicLink) {
                return {
                    tooltip: nls_1.localize('symbolicLlink', "Symbolic Link"),
                    letter: '\u2937'
                };
            }
            return undefined;
        };
        ExplorerDecorationsProvider.prototype.dispose = function () {
            return lifecycle_1.dispose(this.toDispose);
        };
        ExplorerDecorationsProvider = __decorate([
            __param(1, workspace_1.IWorkspaceContextService)
        ], ExplorerDecorationsProvider);
        return ExplorerDecorationsProvider;
    }());
    exports.ExplorerDecorationsProvider = ExplorerDecorationsProvider;
});

define(__m[173/*vs/workbench/parts/output/common/output*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,9/*vs/platform/registry/common/platform*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, event_1, platform_1, instantiation_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Mime type used by the output editor.
     */
    exports.OUTPUT_MIME = 'text/x-code-output';
    /**
     * Output resource scheme.
     */
    exports.OUTPUT_SCHEME = 'output';
    /**
     * Id used by the output editor.
     */
    exports.OUTPUT_MODE_ID = 'Log';
    /**
     * Mime type used by the log output editor.
     */
    exports.LOG_MIME = 'text/x-code-log-output';
    /**
     * Log resource scheme.
     */
    exports.LOG_SCHEME = 'log';
    /**
     * Id used by the log output editor.
     */
    exports.LOG_MODE_ID = 'log';
    /**
     * Output panel id
     */
    exports.OUTPUT_PANEL_ID = 'workbench.panel.output';
    exports.Extensions = {
        OutputChannels: 'workbench.contributions.outputChannels'
    };
    exports.OUTPUT_SERVICE_ID = 'outputService';
    exports.MAX_OUTPUT_LENGTH = 10000 /* Max. number of output lines to show in output */ * 100 /* Guestimated chars per line */;
    exports.CONTEXT_IN_OUTPUT = new contextkey_1.RawContextKey('inOutput', false);
    exports.CONTEXT_ACTIVE_LOG_OUTPUT = new contextkey_1.RawContextKey('activeLogOutput', false);
    exports.IOutputService = instantiation_1.createDecorator(exports.OUTPUT_SERVICE_ID);
    var OutputChannelRegistry = /** @class */ (function () {
        function OutputChannelRegistry() {
            this.channels = new Map();
            this._onDidRegisterChannel = new event_1.Emitter();
            this.onDidRegisterChannel = this._onDidRegisterChannel.event;
            this._onDidRemoveChannel = new event_1.Emitter();
            this.onDidRemoveChannel = this._onDidRemoveChannel.event;
        }
        OutputChannelRegistry.prototype.registerChannel = function (descriptor) {
            if (!this.channels.has(descriptor.id)) {
                this.channels.set(descriptor.id, descriptor);
                this._onDidRegisterChannel.fire(descriptor.id);
            }
        };
        OutputChannelRegistry.prototype.getChannels = function () {
            var result = [];
            this.channels.forEach(function (value) { return result.push(value); });
            return result;
        };
        OutputChannelRegistry.prototype.getChannel = function (id) {
            return this.channels.get(id);
        };
        OutputChannelRegistry.prototype.removeChannel = function (id) {
            this.channels.delete(id);
            this._onDidRemoveChannel.fire(id);
        };
        return OutputChannelRegistry;
    }());
    platform_1.Registry.add(exports.Extensions.OutputChannels, new OutputChannelRegistry());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[144/*vs/workbench/parts/preferences/browser/preferencesWidgets*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,12/*vs/base/common/uri*/,8/*vs/base/browser/dom*/,5/*vs/base/common/winjs.base*/,4/*vs/base/common/lifecycle*/,95/*vs/base/browser/ui/widget*/,6/*vs/base/common/event*/,68/*vs/base/browser/keyboardEvent*/,45/*vs/editor/browser/editorBrowser*/,139/*vs/base/browser/ui/inputbox/inputBox*/,3/*vs/platform/instantiation/common/instantiation*/,34/*vs/platform/contextview/browser/contextView*/,20/*vs/platform/workspace/common/workspace*/,15/*vs/base/common/actions*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,50/*vs/base/browser/ui/actionbar/actionbar*/,170/*vs/base/common/htmlContent*/,58/*vs/workbench/common/theme*/,72/*vs/editor/common/model*/]), function (require, exports, nls_1, uri_1, DOM, winjs_base_1, lifecycle_1, widget_1, event_1, keyboardEvent_1, editorBrowser_1, inputBox_1, instantiation_1, contextView_1, workspace_1, actions_1, styler_1, themeService_1, colorRegistry_1, actionbar_1, htmlContent_1, theme_1, model_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingsHeaderWidget = /** @class */ (function (_super) {
        __extends(SettingsHeaderWidget, _super);
        function SettingsHeaderWidget(editor, title) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.title = title;
            _this.create();
            _this._register(_this.editor.onDidChangeConfiguration(function () { return _this.layout(); }));
            _this._register(_this.editor.onDidLayoutChange(function () { return _this.layout(); }));
            return _this;
        }
        Object.defineProperty(SettingsHeaderWidget.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsHeaderWidget.prototype, "heightInLines", {
            get: function () {
                return 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsHeaderWidget.prototype, "afterLineNumber", {
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        SettingsHeaderWidget.prototype.create = function () {
            var _this = this;
            this._domNode = DOM.$('.settings-header-widget');
            this.titleContainer = DOM.append(this._domNode, DOM.$('.title-container'));
            if (this.title) {
                DOM.append(this.titleContainer, DOM.$('.title')).textContent = this.title;
            }
            this.messageElement = DOM.append(this.titleContainer, DOM.$('.message'));
            if (this.title) {
                this.messageElement.style.paddingLeft = '12px';
            }
            this.editor.changeViewZones(function (accessor) {
                _this.id = accessor.addZone(_this);
                _this.layout();
            });
        };
        SettingsHeaderWidget.prototype.setMessage = function (message) {
            this.messageElement.textContent = message;
        };
        SettingsHeaderWidget.prototype.layout = function () {
            var configuration = this.editor.getConfiguration();
            this.titleContainer.style.fontSize = configuration.fontInfo.fontSize + 'px';
            if (!configuration.contribInfo.folding) {
                this.titleContainer.style.paddingLeft = '6px';
            }
        };
        SettingsHeaderWidget.prototype.dispose = function () {
            var _this = this;
            this.editor.changeViewZones(function (accessor) {
                accessor.removeZone(_this.id);
            });
            _super.prototype.dispose.call(this);
        };
        return SettingsHeaderWidget;
    }(widget_1.Widget));
    exports.SettingsHeaderWidget = SettingsHeaderWidget;
    var DefaultSettingsHeaderWidget = /** @class */ (function (_super) {
        __extends(DefaultSettingsHeaderWidget, _super);
        function DefaultSettingsHeaderWidget() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._onClick = _this._register(new event_1.Emitter());
            _this.onClick = _this._onClick.event;
            return _this;
        }
        DefaultSettingsHeaderWidget.prototype.create = function () {
            _super.prototype.create.call(this);
            this.toggleMessage(true);
        };
        DefaultSettingsHeaderWidget.prototype.toggleMessage = function (hasSettings) {
            if (hasSettings) {
                this.setMessage(nls_1.localize('defaultSettings', "Place your settings in the right hand side editor to override."));
            }
            else {
                this.setMessage(nls_1.localize('noSettingsFound', "No Settings Found."));
            }
        };
        return DefaultSettingsHeaderWidget;
    }(SettingsHeaderWidget));
    exports.DefaultSettingsHeaderWidget = DefaultSettingsHeaderWidget;
    var SettingsGroupTitleWidget = /** @class */ (function (_super) {
        __extends(SettingsGroupTitleWidget, _super);
        function SettingsGroupTitleWidget(editor, settingsGroup) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.settingsGroup = settingsGroup;
            _this._onToggled = _this._register(new event_1.Emitter());
            _this.onToggled = _this._onToggled.event;
            _this.create();
            _this._register(_this.editor.onDidChangeConfiguration(function () { return _this.layout(); }));
            _this._register(_this.editor.onDidLayoutChange(function () { return _this.layout(); }));
            _this._register(_this.editor.onDidChangeCursorPosition(function (e) { return _this.onCursorChange(e); }));
            return _this;
        }
        Object.defineProperty(SettingsGroupTitleWidget.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsGroupTitleWidget.prototype, "heightInLines", {
            get: function () {
                return 1.5;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsGroupTitleWidget.prototype, "afterLineNumber", {
            get: function () {
                return this._afterLineNumber;
            },
            enumerable: true,
            configurable: true
        });
        SettingsGroupTitleWidget.prototype.create = function () {
            var _this = this;
            this._domNode = DOM.$('.settings-group-title-widget');
            this.titleContainer = DOM.append(this._domNode, DOM.$('.title-container'));
            this.titleContainer.tabIndex = 0;
            this.onclick(this.titleContainer, function () { return _this.toggle(); });
            this.onkeydown(this.titleContainer, function (e) { return _this.onKeyDown(e); });
            var focusTracker = this._register(DOM.trackFocus(this.titleContainer));
            this._register(focusTracker.onDidFocus(function () { return _this.toggleFocus(true); }));
            this._register(focusTracker.onDidBlur(function () { return _this.toggleFocus(false); }));
            this.icon = DOM.append(this.titleContainer, DOM.$('.expand-collapse-icon'));
            this.title = DOM.append(this.titleContainer, DOM.$('.title'));
            this.title.textContent = this.settingsGroup.title + (" (" + this.settingsGroup.sections.reduce(function (count, section) { return count + section.settings.length; }, 0) + ")");
            this.layout();
        };
        SettingsGroupTitleWidget.prototype.render = function () {
            var _this = this;
            this._afterLineNumber = this.settingsGroup.range.startLineNumber - 2;
            this.editor.changeViewZones(function (accessor) {
                _this.id = accessor.addZone(_this);
                _this.layout();
            });
        };
        SettingsGroupTitleWidget.prototype.toggleCollapse = function (collapse) {
            DOM.toggleClass(this.titleContainer, 'collapsed', collapse);
        };
        SettingsGroupTitleWidget.prototype.toggleFocus = function (focus) {
            DOM.toggleClass(this.titleContainer, 'focused', focus);
        };
        SettingsGroupTitleWidget.prototype.isCollapsed = function () {
            return DOM.hasClass(this.titleContainer, 'collapsed');
        };
        SettingsGroupTitleWidget.prototype.layout = function () {
            var configuration = this.editor.getConfiguration();
            var layoutInfo = this.editor.getLayoutInfo();
            this._domNode.style.width = layoutInfo.contentWidth - layoutInfo.verticalScrollbarWidth + 'px';
            this.titleContainer.style.lineHeight = configuration.lineHeight + 3 + 'px';
            this.titleContainer.style.height = configuration.lineHeight + 3 + 'px';
            this.titleContainer.style.fontSize = configuration.fontInfo.fontSize + 'px';
            this.icon.style.minWidth = this.getIconSize(16) + "px";
        };
        SettingsGroupTitleWidget.prototype.getIconSize = function (minSize) {
            var fontSize = this.editor.getConfiguration().fontInfo.fontSize;
            return fontSize > 8 ? Math.max(fontSize, minSize) : 12;
        };
        SettingsGroupTitleWidget.prototype.onKeyDown = function (keyboardEvent) {
            switch (keyboardEvent.keyCode) {
                case 3 /* Enter */:
                case 10 /* Space */:
                    this.toggle();
                    break;
                case 15 /* LeftArrow */:
                    this.collapse(true);
                    break;
                case 17 /* RightArrow */:
                    this.collapse(false);
                    break;
                case 16 /* UpArrow */:
                    if (this.settingsGroup.range.startLineNumber - 3 !== 1) {
                        this.editor.focus();
                        var lineNumber_1 = this.settingsGroup.range.startLineNumber - 2;
                        this.editor.setPosition({ lineNumber: lineNumber_1, column: this.editor.getModel().getLineMinColumn(lineNumber_1) });
                    }
                    break;
                case 18 /* DownArrow */:
                    var lineNumber = this.isCollapsed() ? this.settingsGroup.range.startLineNumber : this.settingsGroup.range.startLineNumber - 1;
                    this.editor.focus();
                    this.editor.setPosition({ lineNumber: lineNumber, column: this.editor.getModel().getLineMinColumn(lineNumber) });
                    break;
            }
        };
        SettingsGroupTitleWidget.prototype.toggle = function () {
            this.collapse(!this.isCollapsed());
        };
        SettingsGroupTitleWidget.prototype.collapse = function (collapse) {
            if (collapse !== this.isCollapsed()) {
                DOM.toggleClass(this.titleContainer, 'collapsed', collapse);
                this._onToggled.fire(collapse);
            }
        };
        SettingsGroupTitleWidget.prototype.onCursorChange = function (e) {
            if (e.source !== 'mouse' && this.focusTitle(e.position)) {
                this.titleContainer.focus();
            }
        };
        SettingsGroupTitleWidget.prototype.focusTitle = function (currentPosition) {
            var previousPosition = this.previousPosition;
            this.previousPosition = currentPosition;
            if (!previousPosition) {
                return false;
            }
            if (previousPosition.lineNumber === currentPosition.lineNumber) {
                return false;
            }
            if (currentPosition.lineNumber === this.settingsGroup.range.startLineNumber - 1 || currentPosition.lineNumber === this.settingsGroup.range.startLineNumber - 2) {
                return true;
            }
            if (this.isCollapsed() && currentPosition.lineNumber === this.settingsGroup.range.endLineNumber) {
                return true;
            }
            return false;
        };
        SettingsGroupTitleWidget.prototype.dispose = function () {
            var _this = this;
            this.editor.changeViewZones(function (accessor) {
                accessor.removeZone(_this.id);
            });
            _super.prototype.dispose.call(this);
        };
        return SettingsGroupTitleWidget;
    }(widget_1.Widget));
    exports.SettingsGroupTitleWidget = SettingsGroupTitleWidget;
    var FolderSettingsActionItem = /** @class */ (function (_super) {
        __extends(FolderSettingsActionItem, _super);
        function FolderSettingsActionItem(action, contextService, contextMenuService) {
            var _this = _super.call(this, null, action) || this;
            _this.contextService = contextService;
            _this.contextMenuService = contextMenuService;
            _this._folderSettingCounts = new Map();
            _this.disposables = [];
            var workspace = _this.contextService.getWorkspace();
            _this._folder = workspace.folders.length === 1 ? workspace.folders[0] : null;
            _this.disposables.push(_this.contextService.onDidChangeWorkspaceFolders(function () { return _this.onWorkspaceFoldersChanged(); }));
            return _this;
        }
        Object.defineProperty(FolderSettingsActionItem.prototype, "folder", {
            get: function () {
                return this._folder;
            },
            set: function (folder) {
                this._folder = folder;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        FolderSettingsActionItem.prototype.setCount = function (settingsTarget, count) {
            var folder = this.contextService.getWorkspaceFolder(settingsTarget).uri;
            this._folderSettingCounts.set(folder.toString(), count);
            this.update();
        };
        FolderSettingsActionItem.prototype.render = function (container) {
            var _this = this;
            this.element = container;
            this.container = container;
            this.labelElement = DOM.$('.action-title');
            this.detailsElement = DOM.$('.action-details');
            this.dropDownElement = DOM.$('.dropdown-icon.octicon.octicon-triangle-down.hide');
            this.anchorElement = DOM.$('a.action-label.folder-settings', {
                role: 'button',
                'aria-haspopup': 'true',
                'tabindex': '0'
            }, this.labelElement, this.detailsElement, this.dropDownElement);
            this.disposables.push(DOM.addDisposableListener(this.anchorElement, DOM.EventType.CLICK, function (e) { return _this.onClick(e); }));
            this.disposables.push(DOM.addDisposableListener(this.anchorElement, DOM.EventType.KEY_UP, function (e) { return _this.onKeyUp(e); }));
            DOM.append(this.container, this.anchorElement);
            this.update();
        };
        FolderSettingsActionItem.prototype.onKeyUp = function (event) {
            var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(event);
            switch (keyboardEvent.keyCode) {
                case 3 /* Enter */:
                case 10 /* Space */:
                    this.onClick(event);
                    return;
            }
        };
        FolderSettingsActionItem.prototype.onClick = function (event) {
            DOM.EventHelper.stop(event, true);
            if (!this.folder || this._action.checked) {
                this.showMenu();
            }
            else {
                this._action.run(this._folder);
            }
        };
        FolderSettingsActionItem.prototype.updateEnabled = function () {
            this.update();
        };
        FolderSettingsActionItem.prototype.updateChecked = function () {
            this.update();
        };
        FolderSettingsActionItem.prototype.onWorkspaceFoldersChanged = function () {
            var _this = this;
            var oldFolder = this._folder;
            var workspace = this.contextService.getWorkspace();
            if (this._folder) {
                this._folder = workspace.folders.filter(function (folder) { return folder.uri.toString() === _this._folder.uri.toString(); })[0] || workspace.folders[0];
            }
            this._folder = this._folder ? this._folder : workspace.folders.length === 1 ? workspace.folders[0] : null;
            this.update();
            if (this._action.checked) {
                if ((oldFolder || !this._folder)
                    || (!oldFolder || this._folder)
                    || (oldFolder && this._folder && oldFolder.uri.toString() === this._folder.uri.toString())) {
                    this._action.run(this._folder);
                }
            }
        };
        FolderSettingsActionItem.prototype.update = function () {
            var total = 0;
            this._folderSettingCounts.forEach(function (n) { return total += n; });
            var workspace = this.contextService.getWorkspace();
            if (this._folder) {
                this.labelElement.textContent = this._folder.name;
                this.anchorElement.title = this._folder.name;
                var detailsText = this.labelWithCount(this._action.label, total);
                this.detailsElement.textContent = detailsText;
                DOM.toggleClass(this.dropDownElement, 'hide', workspace.folders.length === 1 || !this._action.checked);
            }
            else {
                var labelText = this.labelWithCount(this._action.label, total);
                this.labelElement.textContent = labelText;
                this.detailsElement.textContent = '';
                this.anchorElement.title = this._action.label;
                DOM.removeClass(this.dropDownElement, 'hide');
            }
            DOM.toggleClass(this.anchorElement, 'checked', this._action.checked);
            DOM.toggleClass(this.container, 'disabled', !this._action.enabled);
        };
        FolderSettingsActionItem.prototype.showMenu = function () {
            var _this = this;
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return _this.container; },
                getActions: function () { return winjs_base_1.TPromise.as(_this.getDropdownMenuActions()); },
                getActionItem: function () { return null; },
                onHide: function () {
                    _this.anchorElement.blur();
                }
            });
        };
        FolderSettingsActionItem.prototype.getDropdownMenuActions = function () {
            var _this = this;
            var actions = [];
            var workspaceFolders = this.contextService.getWorkspace().folders;
            if (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ && workspaceFolders.length > 0) {
                actions.push.apply(actions, workspaceFolders.map(function (folder, index) {
                    var folderCount = _this._folderSettingCounts.get(folder.uri.toString());
                    return {
                        id: 'folderSettingsTarget' + index,
                        label: _this.labelWithCount(folder.name, folderCount),
                        checked: _this.folder && _this.folder.uri.toString() === folder.uri.toString(),
                        enabled: true,
                        run: function () { return _this._action.run(folder); }
                    };
                }));
            }
            return actions;
        };
        FolderSettingsActionItem.prototype.labelWithCount = function (label, count) {
            // Append the count if it's >0 and not undefined
            if (count) {
                label += " (" + count + ")";
            }
            return label;
        };
        FolderSettingsActionItem.prototype.dispose = function () {
            lifecycle_1.dispose(this.disposables);
            _super.prototype.dispose.call(this);
        };
        FolderSettingsActionItem = __decorate([
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, contextView_1.IContextMenuService)
        ], FolderSettingsActionItem);
        return FolderSettingsActionItem;
    }(actionbar_1.BaseActionItem));
    exports.FolderSettingsActionItem = FolderSettingsActionItem;
    var SettingsTargetsWidget = /** @class */ (function (_super) {
        __extends(SettingsTargetsWidget, _super);
        function SettingsTargetsWidget(parent, contextService, instantiationService) {
            var _this = _super.call(this) || this;
            _this.contextService = contextService;
            _this.instantiationService = instantiationService;
            _this._onDidTargetChange = new event_1.Emitter();
            _this.onDidTargetChange = _this._onDidTargetChange.event;
            _this.create(parent);
            _this._register(_this.contextService.onDidChangeWorkbenchState(function () { return _this.onWorkbenchStateChanged(); }));
            _this._register(_this.contextService.onDidChangeWorkspaceFolders(function () { return _this.update(); }));
            return _this;
        }
        SettingsTargetsWidget.prototype.create = function (parent) {
            var _this = this;
            var settingsTabsWidget = DOM.append(parent, DOM.$('.settings-tabs-widget'));
            this.settingsSwitcherBar = this._register(new actionbar_1.ActionBar(settingsTabsWidget, {
                orientation: 0 /* HORIZONTAL */,
                ariaLabel: nls_1.localize('settingsSwitcherBarAriaLabel', "Settings Switcher"),
                animated: false,
                actionItemProvider: function (action) { return action.id === 'folderSettings' ? _this.folderSettings : null; }
            }));
            this.userSettings = new actions_1.Action('userSettings', nls_1.localize('userSettings', "User Settings"), '.settings-tab', true, function () { return _this.updateTarget(1 /* USER */); });
            this.userSettings.tooltip = this.userSettings.label;
            this.workspaceSettings = new actions_1.Action('workspaceSettings', nls_1.localize('workspaceSettings', "Workspace Settings"), '.settings-tab', false, function () { return _this.updateTarget(2 /* WORKSPACE */); });
            this.workspaceSettings.tooltip = this.workspaceSettings.label;
            var folderSettingsAction = new actions_1.Action('folderSettings', nls_1.localize('folderSettings', "Folder Settings"), '.settings-tab', false, function (folder) { return _this.updateTarget(folder ? folder.uri : 1 /* USER */); });
            this.folderSettings = this.instantiationService.createInstance(FolderSettingsActionItem, folderSettingsAction);
            this.update();
            this.settingsSwitcherBar.push([this.userSettings, this.workspaceSettings, folderSettingsAction]);
        };
        Object.defineProperty(SettingsTargetsWidget.prototype, "settingsTarget", {
            get: function () {
                return this._settingsTarget;
            },
            set: function (settingsTarget) {
                this._settingsTarget = settingsTarget;
                this.userSettings.checked = 1 /* USER */ === this.settingsTarget;
                this.workspaceSettings.checked = 2 /* WORKSPACE */ === this.settingsTarget;
                if (this.settingsTarget instanceof uri_1.URI) {
                    this.folderSettings.getAction().checked = true;
                    this.folderSettings.folder = this.contextService.getWorkspaceFolder(this.settingsTarget);
                }
                else {
                    this.folderSettings.getAction().checked = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        SettingsTargetsWidget.prototype.setResultCount = function (settingsTarget, count) {
            if (settingsTarget === 2 /* WORKSPACE */) {
                var label = nls_1.localize('workspaceSettings', "Workspace Settings");
                if (count) {
                    label += " (" + count + ")";
                }
                this.workspaceSettings.label = label;
            }
            else if (settingsTarget === 1 /* USER */) {
                var label = nls_1.localize('userSettings', "User Settings");
                if (count) {
                    label += " (" + count + ")";
                }
                this.userSettings.label = label;
            }
            else if (settingsTarget instanceof uri_1.URI) {
                this.folderSettings.setCount(settingsTarget, count);
            }
        };
        SettingsTargetsWidget.prototype.onWorkbenchStateChanged = function () {
            this.folderSettings.folder = null;
            this.update();
            if (this.settingsTarget === 2 /* WORKSPACE */ && this.contextService.getWorkbenchState() === 3 /* WORKSPACE */) {
                this.updateTarget(1 /* USER */);
            }
        };
        SettingsTargetsWidget.prototype.updateTarget = function (settingsTarget) {
            var isSameTarget = this.settingsTarget === settingsTarget || settingsTarget instanceof uri_1.URI && this.settingsTarget instanceof uri_1.URI && this.settingsTarget.toString() === settingsTarget.toString();
            if (!isSameTarget) {
                this.settingsTarget = settingsTarget;
                this._onDidTargetChange.fire(this.settingsTarget);
            }
            return winjs_base_1.TPromise.as(null);
        };
        SettingsTargetsWidget.prototype.update = function () {
            DOM.toggleClass(this.settingsSwitcherBar.domNode, 'empty-workbench', this.contextService.getWorkbenchState() === 1 /* EMPTY */);
            this.workspaceSettings.enabled = this.contextService.getWorkbenchState() !== 1 /* EMPTY */;
            this.folderSettings.getAction().enabled = this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ && this.contextService.getWorkspace().folders.length > 0;
        };
        SettingsTargetsWidget = __decorate([
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, instantiation_1.IInstantiationService)
        ], SettingsTargetsWidget);
        return SettingsTargetsWidget;
    }(widget_1.Widget));
    exports.SettingsTargetsWidget = SettingsTargetsWidget;
    var SearchWidget = /** @class */ (function (_super) {
        __extends(SearchWidget, _super);
        function SearchWidget(parent, options, contextViewService, instantiationService, themeService) {
            var _this = _super.call(this) || this;
            _this.options = options;
            _this.contextViewService = contextViewService;
            _this.instantiationService = instantiationService;
            _this.themeService = themeService;
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            _this._onFocus = _this._register(new event_1.Emitter());
            _this.onFocus = _this._onFocus.event;
            _this.create(parent);
            return _this;
        }
        SearchWidget.prototype.create = function (parent) {
            var _this = this;
            this.domNode = DOM.append(parent, DOM.$('div.settings-header-widget'));
            this.createSearchContainer(DOM.append(this.domNode, DOM.$('div.settings-search-container')));
            this.controlsDiv = DOM.append(this.domNode, DOM.$('div.settings-search-controls'));
            if (this.options.showResultCount) {
                this.countElement = DOM.append(this.controlsDiv, DOM.$('.settings-count-widget'));
                this._register(styler_1.attachStylerCallback(this.themeService, { badgeBackground: colorRegistry_1.badgeBackground, contrastBorder: colorRegistry_1.contrastBorder }, function (colors) {
                    var background = colors.badgeBackground ? colors.badgeBackground.toString() : null;
                    var border = colors.contrastBorder ? colors.contrastBorder.toString() : null;
                    _this.countElement.style.backgroundColor = background;
                    _this.countElement.style.borderWidth = border ? '1px' : null;
                    _this.countElement.style.borderStyle = border ? 'solid' : null;
                    _this.countElement.style.borderColor = border;
                    _this.styleCountElementForeground();
                }));
            }
            this.inputBox.inputElement.setAttribute('aria-live', this.options.ariaLive || 'off');
            if (this.options.ariaLabelledBy) {
                this.inputBox.inputElement.setAttribute('aria-labelledBy', this.options.ariaLabelledBy);
            }
            var focusTracker = this._register(DOM.trackFocus(this.inputBox.inputElement));
            this._register(focusTracker.onDidFocus(function () { return _this._onFocus.fire(); }));
            if (this.options.focusKey) {
                this._register(focusTracker.onDidFocus(function () { return _this.options.focusKey.set(true); }));
                this._register(focusTracker.onDidBlur(function () { return _this.options.focusKey.set(false); }));
            }
        };
        SearchWidget.prototype.createSearchContainer = function (searchContainer) {
            var _this = this;
            this.searchContainer = searchContainer;
            var searchInput = DOM.append(this.searchContainer, DOM.$('div.settings-search-input'));
            this.inputBox = this._register(this.createInputBox(searchInput));
            this._register(this.inputBox.onDidChange(function (value) { return _this._onDidChange.fire(value); }));
        };
        SearchWidget.prototype.createInputBox = function (parent) {
            var box = this._register(new inputBox_1.InputBox(parent, this.contextViewService, this.options));
            this._register(styler_1.attachInputBoxStyler(box, this.themeService));
            return box;
        };
        SearchWidget.prototype.showMessage = function (message, count) {
            // Avoid setting the aria-label unnecessarily, the screenreader will read the count every time it's set, since it's aria-live:assertive. #50968
            if (this.countElement && message !== this.countElement.textContent) {
                this.countElement.textContent = message;
                this.inputBox.inputElement.setAttribute('aria-label', message);
                DOM.toggleClass(this.countElement, 'no-results', count === 0);
                this.inputBox.inputElement.style.paddingRight = this.getControlsWidth() + 'px';
                this.styleCountElementForeground();
            }
        };
        SearchWidget.prototype.styleCountElementForeground = function () {
            var colorId = DOM.hasClass(this.countElement, 'no-results') ? colorRegistry_1.errorForeground : colorRegistry_1.badgeForeground;
            var color = this.themeService.getTheme().getColor(colorId);
            this.countElement.style.color = color ? color.toString() : null;
        };
        SearchWidget.prototype.layout = function (dimension) {
            if (dimension.width < 400) {
                if (this.countElement) {
                    DOM.addClass(this.countElement, 'hide');
                }
                this.inputBox.inputElement.style.paddingRight = '0px';
            }
            else {
                if (this.countElement) {
                    DOM.removeClass(this.countElement, 'hide');
                }
                this.inputBox.inputElement.style.paddingRight = this.getControlsWidth() + 'px';
            }
        };
        SearchWidget.prototype.getControlsWidth = function () {
            var countWidth = this.countElement ? DOM.getTotalWidth(this.countElement) : 0;
            return countWidth + 20;
        };
        SearchWidget.prototype.focus = function () {
            this.inputBox.focus();
            if (this.getValue()) {
                this.inputBox.select();
            }
        };
        SearchWidget.prototype.hasFocus = function () {
            return this.inputBox.hasFocus();
        };
        SearchWidget.prototype.clear = function () {
            this.inputBox.value = '';
        };
        SearchWidget.prototype.getValue = function () {
            return this.inputBox.value;
        };
        SearchWidget.prototype.setValue = function (value) {
            return this.inputBox.value = value;
        };
        SearchWidget.prototype.dispose = function () {
            if (this.options.focusKey) {
                this.options.focusKey.set(false);
            }
            _super.prototype.dispose.call(this);
        };
        SearchWidget = __decorate([
            __param(2, contextView_1.IContextViewService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, themeService_1.IThemeService)
        ], SearchWidget);
        return SearchWidget;
    }(widget_1.Widget));
    exports.SearchWidget = SearchWidget;
    var EditPreferenceWidget = /** @class */ (function (_super) {
        __extends(EditPreferenceWidget, _super);
        function EditPreferenceWidget(editor) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this._onClick = new event_1.Emitter();
            _this._editPreferenceDecoration = [];
            _this._register(_this.editor.onMouseDown(function (e) {
                var data = e.target.detail;
                if (e.target.type !== editorBrowser_1.MouseTargetType.GUTTER_GLYPH_MARGIN || data.isAfterLines || !_this.isVisible()) {
                    return;
                }
                _this._onClick.fire(e);
            }));
            return _this;
        }
        Object.defineProperty(EditPreferenceWidget.prototype, "onClick", {
            get: function () { return this._onClick.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditPreferenceWidget.prototype, "preferences", {
            get: function () {
                return this._preferences;
            },
            enumerable: true,
            configurable: true
        });
        EditPreferenceWidget.prototype.getLine = function () {
            return this._line;
        };
        EditPreferenceWidget.prototype.show = function (line, hoverMessage, preferences) {
            this._preferences = preferences;
            var newDecoration = [];
            this._line = line;
            newDecoration.push({
                options: {
                    glyphMarginClassName: EditPreferenceWidget.GLYPH_MARGIN_CLASS_NAME,
                    glyphMarginHoverMessage: new htmlContent_1.MarkdownString().appendText(hoverMessage),
                    stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                },
                range: {
                    startLineNumber: line,
                    startColumn: 1,
                    endLineNumber: line,
                    endColumn: 1
                }
            });
            this._editPreferenceDecoration = this.editor.deltaDecorations(this._editPreferenceDecoration, newDecoration);
        };
        EditPreferenceWidget.prototype.hide = function () {
            this._editPreferenceDecoration = this.editor.deltaDecorations(this._editPreferenceDecoration, []);
        };
        EditPreferenceWidget.prototype.isVisible = function () {
            return this._editPreferenceDecoration.length > 0;
        };
        EditPreferenceWidget.prototype.dispose = function () {
            this.hide();
            _super.prototype.dispose.call(this);
        };
        EditPreferenceWidget.GLYPH_MARGIN_CLASS_NAME = 'edit-preferences-widget';
        return EditPreferenceWidget;
    }(lifecycle_1.Disposable));
    exports.EditPreferenceWidget = EditPreferenceWidget;
    themeService_1.registerThemingParticipant(function (theme, collector) {
        collector.addRule("\n\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:focus,\n\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label.checked {\n\t\t\tborder-bottom: 1px solid;\n\t\t}\n\t");
        // Title Active
        var titleActive = theme.getColor(theme_1.PANEL_ACTIVE_TITLE_FOREGROUND);
        var titleActiveBorder = theme.getColor(theme_1.PANEL_ACTIVE_TITLE_BORDER);
        if (titleActive || titleActiveBorder) {
            collector.addRule("\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:hover,\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label.checked {\n\t\t\t\tcolor: " + titleActive + ";\n\t\t\t\tborder-bottom-color: " + titleActiveBorder + ";\n\t\t\t}\n\t\t");
        }
        // Title Inactive
        var titleInactive = theme.getColor(theme_1.PANEL_INACTIVE_TITLE_FOREGROUND);
        if (titleInactive) {
            collector.addRule("\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label {\n\t\t\t\tcolor: " + titleInactive + ";\n\t\t\t}\n\t\t");
        }
        // Title focus
        var focusBorderColor = theme.getColor(colorRegistry_1.focusBorder);
        if (focusBorderColor) {
            collector.addRule("\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:focus {\n\t\t\t\tborder-bottom-color: " + focusBorderColor + " !important;\n\t\t\t}\n\t\t\t");
            collector.addRule("\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:focus {\n\t\t\t\toutline: none;\n\t\t\t}\n\t\t\t");
        }
        // Styling with Outline color (e.g. high contrast theme)
        var outline = theme.getColor(colorRegistry_1.activeContrastBorder);
        if (outline) {
            var outline_1 = theme.getColor(colorRegistry_1.activeContrastBorder);
            collector.addRule("\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label.checked,\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:hover {\n\t\t\t\toutline-color: " + outline_1 + ";\n\t\t\t\toutline-width: 1px;\n\t\t\t\toutline-style: solid;\n\t\t\t\tborder-bottom: none;\n\t\t\t\tpadding-bottom: 0;\n\t\t\t\toutline-offset: 2px;\n\t\t\t}\n\n\t\t\t.settings-tabs-widget > .monaco-action-bar .action-item .action-label:not(.checked):hover {\n\t\t\t\toutline-style: dashed;\n\t\t\t}\n\t\t");
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[169/*vs/workbench/parts/preferences/browser/keybindingWidgets*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,18/*vs/base/common/platform*/,5/*vs/base/common/winjs.base*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,236/*vs/base/browser/ui/keybindingLabel/keybindingLabel*/,95/*vs/base/browser/ui/widget*/,8/*vs/base/browser/dom*/,68/*vs/base/browser/keyboardEvent*/,475/*vs/base/browser/fastDomNode*/,31/*vs/platform/keybinding/common/keybinding*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,144/*vs/workbench/parts/preferences/browser/preferencesWidgets*/,261/*vs/css!vs/workbench/parts/preferences/browser/media/keybindings*/]), function (require, exports, nls, platform_1, winjs_base_1, lifecycle_1, event_1, keybindingLabel_1, widget_1, dom, keyboardEvent_1, fastDomNode_1, keybinding_1, contextView_1, instantiation_1, styler_1, themeService_1, colorRegistry_1, preferencesWidgets_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingsSearchWidget = /** @class */ (function (_super) {
        __extends(KeybindingsSearchWidget, _super);
        function KeybindingsSearchWidget(parent, options, contextViewService, keybindingService, instantiationService, themeService) {
            var _this = _super.call(this, parent, options, contextViewService, instantiationService, themeService) || this;
            _this.keybindingService = keybindingService;
            _this.recordDisposables = [];
            _this._onKeybinding = _this._register(new event_1.Emitter());
            _this.onKeybinding = _this._onKeybinding.event;
            _this._onEnter = _this._register(new event_1.Emitter());
            _this.onEnter = _this._onEnter.event;
            _this._onEscape = _this._register(new event_1.Emitter());
            _this.onEscape = _this._onEscape.event;
            _this._onBlur = _this._register(new event_1.Emitter());
            _this.onBlur = _this._onBlur.event;
            _this._register(styler_1.attachInputBoxStyler(_this.inputBox, themeService));
            _this._register(lifecycle_1.toDisposable(function () { return _this.stopRecordingKeys(); }));
            _this._reset();
            return _this;
        }
        KeybindingsSearchWidget.prototype.clear = function () {
            this._reset();
            _super.prototype.clear.call(this);
        };
        KeybindingsSearchWidget.prototype.startRecordingKeys = function () {
            var _this = this;
            this.recordDisposables.push(dom.addDisposableListener(this.inputBox.inputElement, dom.EventType.KEY_DOWN, function (e) { return _this._onKeyDown(new keyboardEvent_1.StandardKeyboardEvent(e)); }));
            this.recordDisposables.push(dom.addDisposableListener(this.inputBox.inputElement, dom.EventType.BLUR, function () { return _this._onBlur.fire(); }));
            this.recordDisposables.push(dom.addDisposableListener(this.inputBox.inputElement, dom.EventType.INPUT, function () {
                // Prevent other characters from showing up
                _this.setInputValue(_this._inputValue);
            }));
        };
        KeybindingsSearchWidget.prototype.stopRecordingKeys = function () {
            this._reset();
            lifecycle_1.dispose(this.recordDisposables);
        };
        KeybindingsSearchWidget.prototype.setInputValue = function (value) {
            this._inputValue = value;
            this.inputBox.value = this._inputValue;
        };
        KeybindingsSearchWidget.prototype.focus = function () {
            this.inputBox.focus();
        };
        KeybindingsSearchWidget.prototype._reset = function () {
            this._firstPart = null;
            this._chordPart = null;
        };
        KeybindingsSearchWidget.prototype._onKeyDown = function (keyboardEvent) {
            keyboardEvent.preventDefault();
            keyboardEvent.stopPropagation();
            var options = this.options;
            if (!options.recordEnter && keyboardEvent.equals(3 /* Enter */)) {
                this._onEnter.fire();
                return;
            }
            if (keyboardEvent.equals(9 /* Escape */)) {
                this._onEscape.fire();
                return;
            }
            this.printKeybinding(keyboardEvent);
        };
        KeybindingsSearchWidget.prototype.printKeybinding = function (keyboardEvent) {
            var keybinding = this.keybindingService.resolveKeyboardEvent(keyboardEvent);
            var info = "code: " + keyboardEvent.browserEvent.code + ", keyCode: " + keyboardEvent.browserEvent.keyCode + ", key: " + keyboardEvent.browserEvent.key + " => UI: " + keybinding.getAriaLabel() + ", user settings: " + keybinding.getUserSettingsLabel() + ", dispatch: " + keybinding.getDispatchParts()[0];
            var hasFirstPart = (this._firstPart && this._firstPart.getDispatchParts()[0] !== null);
            var hasChordPart = (this._chordPart && this._chordPart.getDispatchParts()[0] !== null);
            if (hasFirstPart && hasChordPart) {
                // Reset
                this._firstPart = keybinding;
                this._chordPart = null;
            }
            else if (!hasFirstPart) {
                this._firstPart = keybinding;
            }
            else {
                this._chordPart = keybinding;
            }
            var value = '';
            if (this._firstPart) {
                value = this._firstPart.getUserSettingsLabel();
            }
            if (this._chordPart) {
                value = value + ' ' + this._chordPart.getUserSettingsLabel();
            }
            this.setInputValue(value);
            this.inputBox.inputElement.title = info;
            this._onKeybinding.fire([this._firstPart, this._chordPart]);
        };
        KeybindingsSearchWidget = __decorate([
            __param(2, contextView_1.IContextViewService),
            __param(3, keybinding_1.IKeybindingService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, themeService_1.IThemeService)
        ], KeybindingsSearchWidget);
        return KeybindingsSearchWidget;
    }(preferencesWidgets_1.SearchWidget));
    exports.KeybindingsSearchWidget = KeybindingsSearchWidget;
    var DefineKeybindingWidget = /** @class */ (function (_super) {
        __extends(DefineKeybindingWidget, _super);
        function DefineKeybindingWidget(parent, instantiationService, themeService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.themeService = themeService;
            _this._firstPart = null;
            _this._chordPart = null;
            _this._isVisible = false;
            _this._onHide = _this._register(new event_1.Emitter());
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            _this._onShowExistingKeybindings = _this._register(new event_1.Emitter());
            _this.onShowExistingKeybidings = _this._onShowExistingKeybindings.event;
            _this.create();
            if (parent) {
                dom.append(parent, _this._domNode.domNode);
            }
            return _this;
        }
        Object.defineProperty(DefineKeybindingWidget.prototype, "domNode", {
            get: function () {
                return this._domNode.domNode;
            },
            enumerable: true,
            configurable: true
        });
        DefineKeybindingWidget.prototype.define = function () {
            var _this = this;
            this._keybindingInputWidget.clear();
            return new winjs_base_1.TPromise(function (c, e) {
                if (!_this._isVisible) {
                    _this._isVisible = true;
                    _this._domNode.setDisplay('block');
                    _this._firstPart = null;
                    _this._chordPart = null;
                    _this._keybindingInputWidget.setInputValue('');
                    dom.clearNode(_this._outputNode);
                    dom.clearNode(_this._showExistingKeybindingsNode);
                    _this._keybindingInputWidget.focus();
                }
                var disposable = _this._onHide.event(function () {
                    c(_this.getUserSettingsLabel());
                    disposable.dispose();
                });
            });
        };
        DefineKeybindingWidget.prototype.layout = function (layout) {
            var top = Math.round((layout.height - DefineKeybindingWidget.HEIGHT) / 2);
            this._domNode.setTop(top);
            var left = Math.round((layout.width - DefineKeybindingWidget.WIDTH) / 2);
            this._domNode.setLeft(left);
        };
        DefineKeybindingWidget.prototype.printExisting = function (numberOfExisting) {
            var _this = this;
            if (numberOfExisting > 0) {
                var existingElement = dom.$('span.existingText');
                var text = numberOfExisting === 1 ? nls.localize('defineKeybinding.oneExists', "1 existing command has this keybinding", numberOfExisting) : nls.localize('defineKeybinding.existing', "{0} existing commands have this keybinding", numberOfExisting);
                dom.append(existingElement, document.createTextNode(text));
                this._showExistingKeybindingsNode.appendChild(existingElement);
                existingElement.onmousedown = function (e) { e.preventDefault(); };
                existingElement.onmouseup = function (e) { e.preventDefault(); };
                existingElement.onclick = function () { _this._onShowExistingKeybindings.fire(_this.getUserSettingsLabel()); };
            }
        };
        DefineKeybindingWidget.prototype.create = function () {
            var _this = this;
            this._domNode = fastDomNode_1.createFastDomNode(document.createElement('div'));
            this._domNode.setDisplay('none');
            this._domNode.setClassName('defineKeybindingWidget');
            this._domNode.setWidth(DefineKeybindingWidget.WIDTH);
            this._domNode.setHeight(DefineKeybindingWidget.HEIGHT);
            var message = nls.localize('defineKeybinding.initial', "Press desired key combination and then press ENTER.");
            dom.append(this._domNode.domNode, dom.$('.message', null, message));
            this._register(styler_1.attachStylerCallback(this.themeService, { editorWidgetBackground: colorRegistry_1.editorWidgetBackground, widgetShadow: colorRegistry_1.widgetShadow }, function (colors) {
                if (colors.editorWidgetBackground) {
                    _this._domNode.domNode.style.backgroundColor = colors.editorWidgetBackground.toString();
                }
                else {
                    _this._domNode.domNode.style.backgroundColor = null;
                }
                if (colors.widgetShadow) {
                    _this._domNode.domNode.style.boxShadow = "0 2px 8px " + colors.widgetShadow;
                }
                else {
                    _this._domNode.domNode.style.boxShadow = null;
                }
            }));
            this._keybindingInputWidget = this._register(this.instantiationService.createInstance(KeybindingsSearchWidget, this._domNode.domNode, { ariaLabel: message }));
            this._keybindingInputWidget.startRecordingKeys();
            this._register(this._keybindingInputWidget.onKeybinding(function (keybinding) { return _this.onKeybinding(keybinding); }));
            this._register(this._keybindingInputWidget.onEnter(function () { return _this.hide(); }));
            this._register(this._keybindingInputWidget.onEscape(function () { return _this.onCancel(); }));
            this._register(this._keybindingInputWidget.onBlur(function () { return _this.onCancel(); }));
            this._outputNode = dom.append(this._domNode.domNode, dom.$('.output'));
            this._showExistingKeybindingsNode = dom.append(this._domNode.domNode, dom.$('.existing'));
        };
        DefineKeybindingWidget.prototype.onKeybinding = function (keybinding) {
            var firstPart = keybinding[0], chordPart = keybinding[1];
            this._firstPart = firstPart;
            this._chordPart = chordPart;
            dom.clearNode(this._outputNode);
            dom.clearNode(this._showExistingKeybindingsNode);
            new keybindingLabel_1.KeybindingLabel(this._outputNode, platform_1.OS).set(this._firstPart, null);
            if (this._chordPart) {
                this._outputNode.appendChild(document.createTextNode(nls.localize('defineKeybinding.chordsTo', "chord to")));
                new keybindingLabel_1.KeybindingLabel(this._outputNode, platform_1.OS).set(this._chordPart, null);
            }
            var label = this.getUserSettingsLabel();
            if (label) {
                this._onDidChange.fire(label);
            }
        };
        DefineKeybindingWidget.prototype.getUserSettingsLabel = function () {
            var label = null;
            if (this._firstPart) {
                label = this._firstPart.getUserSettingsLabel();
                if (this._chordPart) {
                    label = label + ' ' + this._chordPart.getUserSettingsLabel();
                }
            }
            return label;
        };
        DefineKeybindingWidget.prototype.onCancel = function () {
            this._firstPart = null;
            this._chordPart = null;
            this.hide();
        };
        DefineKeybindingWidget.prototype.hide = function () {
            this._domNode.setDisplay('none');
            this._isVisible = false;
            this._onHide.fire();
        };
        DefineKeybindingWidget.WIDTH = 400;
        DefineKeybindingWidget.HEIGHT = 110;
        DefineKeybindingWidget = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, themeService_1.IThemeService)
        ], DefineKeybindingWidget);
        return DefineKeybindingWidget;
    }(widget_1.Widget));
    exports.DefineKeybindingWidget = DefineKeybindingWidget;
    var DefineKeybindingOverlayWidget = /** @class */ (function (_super) {
        __extends(DefineKeybindingOverlayWidget, _super);
        function DefineKeybindingOverlayWidget(_editor, instantiationService) {
            var _this = _super.call(this) || this;
            _this._editor = _editor;
            _this._widget = instantiationService.createInstance(DefineKeybindingWidget, null);
            _this._editor.addOverlayWidget(_this);
            return _this;
        }
        DefineKeybindingOverlayWidget.prototype.getId = function () {
            return DefineKeybindingOverlayWidget.ID;
        };
        DefineKeybindingOverlayWidget.prototype.getDomNode = function () {
            return this._widget.domNode;
        };
        DefineKeybindingOverlayWidget.prototype.getPosition = function () {
            return {
                preference: null
            };
        };
        DefineKeybindingOverlayWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            _super.prototype.dispose.call(this);
        };
        DefineKeybindingOverlayWidget.prototype.start = function () {
            this._editor.revealPositionInCenterIfOutsideViewport(this._editor.getPosition(), 0 /* Smooth */);
            var layoutInfo = this._editor.getLayoutInfo();
            this._widget.layout(new dom.Dimension(layoutInfo.width, layoutInfo.height));
            return this._widget.define();
        };
        DefineKeybindingOverlayWidget.ID = 'editor.contrib.defineKeybindingWidget';
        DefineKeybindingOverlayWidget = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], DefineKeybindingOverlayWidget);
        return DefineKeybindingOverlayWidget;
    }(lifecycle_1.Disposable));
    exports.DefineKeybindingOverlayWidget = DefineKeybindingOverlayWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[193/*vs/workbench/parts/preferences/browser/settingsLayout*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/]), function (require, exports, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commonlyUsedData = {
        id: 'commonlyUsed',
        label: nls_1.localize('commonlyUsed', "Commonly Used"),
        settings: ['files.autoSave', 'editor.fontSize', 'editor.fontFamily', 'editor.tabSize', 'editor.renderWhitespace', 'editor.cursorStyle', 'editor.multiCursorModifier', 'editor.insertSpaces', 'editor.wordWrap', 'files.exclude', 'files.associations']
    };
    exports.tocData = {
        id: 'root',
        label: 'root',
        children: [
            {
                id: 'editor',
                label: nls_1.localize('textEditor', "Text Editor"),
                settings: ['editor.*'],
                children: [
                    {
                        id: 'editor/cursor',
                        label: nls_1.localize('cursor', "Cursor"),
                        settings: ['editor.cursor*']
                    },
                    {
                        id: 'editor/find',
                        label: nls_1.localize('find', "Find"),
                        settings: ['editor.find.*']
                    },
                    {
                        id: 'editor/font',
                        label: nls_1.localize('font', "Font"),
                        settings: ['editor.font*']
                    },
                    {
                        id: 'editor/format',
                        label: nls_1.localize('formatting', "Formatting"),
                        settings: ['editor.format*']
                    },
                    {
                        id: 'editor/diffEditor',
                        label: nls_1.localize('diffEditor', "Diff Editor"),
                        settings: ['diffEditor.*']
                    },
                    {
                        id: 'editor/minimap',
                        label: nls_1.localize('minimap', "Minimap"),
                        settings: ['editor.minimap.*']
                    },
                    {
                        id: 'editor/suggestions',
                        label: nls_1.localize('suggestions', "Suggestions"),
                        settings: ['editor.*suggest*']
                    },
                    {
                        id: 'editor/files',
                        label: nls_1.localize('files', "Files"),
                        settings: ['files.*']
                    }
                ]
            },
            {
                id: 'workbench',
                label: nls_1.localize('workbench', "Workbench"),
                settings: ['workbench.*'],
                children: [
                    {
                        id: 'workbench/appearance',
                        label: nls_1.localize('appearance', "Appearance"),
                        settings: ['workbench.activityBar.*', 'workbench.*color*', 'workbench.fontAliasing', 'workbench.iconTheme', 'workbench.sidebar.location', 'workbench.*.visible', 'workbench.tips.enabled', 'workbench.tree.*', 'workbench.view.*']
                    },
                    {
                        id: 'workbench/breadcrumbs',
                        label: nls_1.localize('breadcrumbs', "Breadcrumbs"),
                        settings: ['breadcrumbs.*']
                    },
                    {
                        id: 'workbench/editor',
                        label: nls_1.localize('editorManagement', "Editor Management"),
                        settings: ['workbench.editor.*']
                    },
                    {
                        id: 'workbench/settings',
                        label: nls_1.localize('settings', "Settings Editor"),
                        settings: ['workbench.settings.*']
                    },
                    {
                        id: 'workbench/zenmode',
                        label: nls_1.localize('zenMode', "Zen Mode"),
                        settings: ['zenmode.*']
                    }
                ]
            },
            {
                id: 'window',
                label: nls_1.localize('window', "Window"),
                settings: ['window.*'],
                children: [
                    {
                        id: 'window/newWindow',
                        label: nls_1.localize('newWindow', "New Window"),
                        settings: ['window.*newwindow*']
                    }
                ]
            },
            {
                id: 'features',
                label: nls_1.localize('features', "Features"),
                children: [
                    {
                        id: 'features/explorer',
                        label: nls_1.localize('fileExplorer', "Explorer"),
                        settings: ['explorer.*', 'outline.*']
                    },
                    {
                        id: 'features/search',
                        label: nls_1.localize('search', "Search"),
                        settings: ['search.*']
                    },
                    {
                        id: 'features/debug',
                        label: nls_1.localize('debug', "Debug"),
                        settings: ['debug.*', 'launch']
                    },
                    {
                        id: 'features/scm',
                        label: nls_1.localize('scm', "SCM"),
                        settings: ['scm.*']
                    },
                    {
                        id: 'features/extensions',
                        label: nls_1.localize('extensionViewlet', "Extension Viewlet"),
                        settings: ['extensions.*']
                    },
                    {
                        id: 'features/terminal',
                        label: nls_1.localize('terminal', "Terminal"),
                        settings: ['terminal.*']
                    },
                    {
                        id: 'features/problems',
                        label: nls_1.localize('problems', "Problems"),
                        settings: ['problems.*']
                    }
                ]
            },
            {
                id: 'application',
                label: nls_1.localize('application', "Application"),
                children: [
                    {
                        id: 'application/http',
                        label: nls_1.localize('proxy', "Proxy"),
                        settings: ['http.*']
                    },
                    {
                        id: 'application/keyboard',
                        label: nls_1.localize('keyboard', "Keyboard"),
                        settings: ['keyboard.*']
                    },
                    {
                        id: 'application/update',
                        label: nls_1.localize('update', "Update"),
                        settings: ['update.*']
                    },
                    {
                        id: 'application/telemetry',
                        label: nls_1.localize('telemetry', "Telemetry"),
                        settings: ['telemetry.*']
                    }
                ]
            }
        ]
    };
    exports.knownAcronyms = new Set();
    [
        'css',
        'html',
        'scss',
        'less',
        'json',
        'js',
        'ts',
        'ie',
        'id',
        'php',
    ].forEach(function (str) { return exports.knownAcronyms.add(str); });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[151/*vs/workbench/parts/preferences/browser/settingsWidgets*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,50/*vs/base/browser/ui/actionbar/actionbar*/,121/*vs/base/browser/ui/button/button*/,139/*vs/base/browser/ui/inputbox/inputBox*/,75/*vs/base/common/color*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,2/*vs/nls*/,34/*vs/platform/contextview/browser/contextView*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,270/*vs/css!vs/workbench/parts/preferences/browser/media/settingsWidgets*/]), function (require, exports, DOM, actionbar_1, button_1, inputBox_1, color_1, event_1, lifecycle_1, nls_1, contextView_1, colorRegistry_1, styler_1, themeService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = DOM.$;
    exports.settingsHeaderForeground = colorRegistry_1.registerColor('settings.headerForeground', { light: '#444444', dark: '#e7e7e7', hc: '#ffffff' }, nls_1.localize('headerForeground', "(For settings editor preview) The foreground color for a section header or active title."));
    exports.modifiedItemIndicator = colorRegistry_1.registerColor('settings.modifiedItemIndicator', {
        light: new color_1.Color(new color_1.RGBA(102, 175, 224)),
        dark: new color_1.Color(new color_1.RGBA(12, 125, 157)),
        hc: new color_1.Color(new color_1.RGBA(0, 73, 122))
    }, nls_1.localize('modifiedItemForeground', "(For settings editor preview) The color of the modified setting indicator."));
    // Enum control colors
    exports.settingsSelectBackground = colorRegistry_1.registerColor('settings.dropdownBackground', { dark: colorRegistry_1.selectBackground, light: colorRegistry_1.selectBackground, hc: colorRegistry_1.selectBackground }, nls_1.localize('settingsDropdownBackground', "(For settings editor preview) Settings editor dropdown background."));
    exports.settingsSelectForeground = colorRegistry_1.registerColor('settings.dropdownForeground', { dark: colorRegistry_1.selectForeground, light: colorRegistry_1.selectForeground, hc: colorRegistry_1.selectForeground }, nls_1.localize('settingsDropdownForeground', "(For settings editor preview) Settings editor dropdown foreground."));
    exports.settingsSelectBorder = colorRegistry_1.registerColor('settings.dropdownBorder', { dark: colorRegistry_1.selectBorder, light: colorRegistry_1.selectBorder, hc: colorRegistry_1.selectBorder }, nls_1.localize('settingsDropdownBorder', "(For settings editor preview) Settings editor dropdown border."));
    exports.settingsSelectListBorder = colorRegistry_1.registerColor('settings.dropdownListBorder', { dark: colorRegistry_1.editorWidgetBorder, light: colorRegistry_1.editorWidgetBorder, hc: colorRegistry_1.editorWidgetBorder }, nls_1.localize('settingsDropdownListBorder', "(For settings editor preview) Settings editor dropdown list border. This surrounds the options and separates the options from the description."));
    // Bool control colors
    exports.settingsCheckboxBackground = colorRegistry_1.registerColor('settings.checkboxBackground', { dark: colorRegistry_1.selectBackground, light: colorRegistry_1.selectBackground, hc: colorRegistry_1.selectBackground }, nls_1.localize('settingsCheckboxBackground', "(For settings editor preview) Settings editor checkbox background."));
    exports.settingsCheckboxForeground = colorRegistry_1.registerColor('settings.checkboxForeground', { dark: colorRegistry_1.selectForeground, light: colorRegistry_1.selectForeground, hc: colorRegistry_1.selectForeground }, nls_1.localize('settingsCheckboxForeground', "(For settings editor preview) Settings editor checkbox foreground."));
    exports.settingsCheckboxBorder = colorRegistry_1.registerColor('settings.checkboxBorder', { dark: colorRegistry_1.selectBorder, light: colorRegistry_1.selectBorder, hc: colorRegistry_1.selectBorder }, nls_1.localize('settingsCheckboxBorder', "(For settings editor preview) Settings editor checkbox border."));
    // Text control colors
    exports.settingsTextInputBackground = colorRegistry_1.registerColor('settings.textInputBackground', { dark: colorRegistry_1.inputBackground, light: colorRegistry_1.inputBackground, hc: colorRegistry_1.inputBackground }, nls_1.localize('textInputBoxBackground', "(For settings editor preview) Settings editor text input box background."));
    exports.settingsTextInputForeground = colorRegistry_1.registerColor('settings.textInputForeground', { dark: colorRegistry_1.inputForeground, light: colorRegistry_1.inputForeground, hc: colorRegistry_1.inputForeground }, nls_1.localize('textInputBoxForeground', "(For settings editor preview) Settings editor text input box foreground."));
    exports.settingsTextInputBorder = colorRegistry_1.registerColor('settings.textInputBorder', { dark: colorRegistry_1.inputBorder, light: colorRegistry_1.inputBorder, hc: colorRegistry_1.inputBorder }, nls_1.localize('textInputBoxBorder', "(For settings editor preview) Settings editor text input box border."));
    // Number control colors
    exports.settingsNumberInputBackground = colorRegistry_1.registerColor('settings.numberInputBackground', { dark: colorRegistry_1.inputBackground, light: colorRegistry_1.inputBackground, hc: colorRegistry_1.inputBackground }, nls_1.localize('numberInputBoxBackground', "(For settings editor preview) Settings editor number input box background."));
    exports.settingsNumberInputForeground = colorRegistry_1.registerColor('settings.numberInputForeground', { dark: colorRegistry_1.inputForeground, light: colorRegistry_1.inputForeground, hc: colorRegistry_1.inputForeground }, nls_1.localize('numberInputBoxForeground', "(For settings editor preview) Settings editor number input box foreground."));
    exports.settingsNumberInputBorder = colorRegistry_1.registerColor('settings.numberInputBorder', { dark: colorRegistry_1.inputBorder, light: colorRegistry_1.inputBorder, hc: colorRegistry_1.inputBorder }, nls_1.localize('numberInputBoxBorder', "(For settings editor preview) Settings editor number input box border."));
    themeService_1.registerThemingParticipant(function (theme, collector) {
        var checkboxBackgroundColor = theme.getColor(exports.settingsCheckboxBackground);
        if (checkboxBackgroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item-bool .setting-value-checkbox { background-color: " + checkboxBackgroundColor + " !important; }");
        }
        var checkboxBorderColor = theme.getColor(exports.settingsCheckboxBorder);
        if (checkboxBorderColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item-bool .setting-value-checkbox { border-color: " + checkboxBorderColor + " !important; }");
        }
        var link = theme.getColor(colorRegistry_1.textLinkForeground);
        if (link) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description-markdown a { color: " + link + "; }");
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description-markdown a > code { color: " + link + "; }");
            collector.addRule(".monaco-select-box-dropdown-container > .select-box-details-pane > .select-box-description-markdown a { color: " + link + "; }");
            collector.addRule(".monaco-select-box-dropdown-container > .select-box-details-pane > .select-box-description-markdown a > code { color: " + link + "; }");
        }
        var headerForegroundColor = theme.getColor(exports.settingsHeaderForeground);
        if (headerForegroundColor) {
            collector.addRule(".settings-editor > .settings-header > .settings-header-controls .settings-tabs-widget .action-label.checked { color: " + headerForegroundColor + "; border-bottom-color: " + headerForegroundColor + "; }");
        }
        var foregroundColor = theme.getColor(colorRegistry_1.foreground);
        if (foregroundColor) {
            collector.addRule(".settings-editor > .settings-header > .settings-header-controls .settings-tabs-widget .action-label { color: " + foregroundColor + "; }");
        }
        // Exclude control
        var listHoverBackgroundColor = theme.getColor(colorRegistry_1.listHoverBackground);
        if (listHoverBackgroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row:hover { background-color: " + listHoverBackgroundColor + "; }");
        }
        var listHoverForegroundColor = theme.getColor(colorRegistry_1.listHoverForeground);
        if (listHoverForegroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row:hover { color: " + listHoverForegroundColor + "; }");
        }
        var listSelectBackgroundColor = theme.getColor(colorRegistry_1.listActiveSelectionBackground);
        if (listSelectBackgroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row.selected:focus { background-color: " + listSelectBackgroundColor + "; }");
        }
        var listInactiveSelectionBackgroundColor = theme.getColor(colorRegistry_1.listInactiveSelectionBackground);
        if (listInactiveSelectionBackgroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row.selected:not(:focus) { background-color: " + listInactiveSelectionBackgroundColor + "; }");
        }
        var listInactiveSelectionForegroundColor = theme.getColor(colorRegistry_1.listInactiveSelectionForeground);
        if (listInactiveSelectionForegroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row.selected:not(:focus) { color: " + listInactiveSelectionForegroundColor + "; }");
        }
        var listSelectForegroundColor = theme.getColor(colorRegistry_1.listActiveSelectionForeground);
        if (listSelectForegroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.setting-item-exclude .setting-exclude-row.selected:focus { color: " + listSelectForegroundColor + "; }");
        }
        var codeTextForegroundColor = theme.getColor(colorRegistry_1.textPreformatForeground);
        if (codeTextForegroundColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description-markdown code { color: " + codeTextForegroundColor + " }");
            collector.addRule(".monaco-select-box-dropdown-container > .select-box-details-pane > .select-box-description-markdown code { color: " + codeTextForegroundColor + " }");
        }
        var modifiedItemIndicatorColor = theme.getColor(exports.modifiedItemIndicator);
        if (modifiedItemIndicatorColor) {
            collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item > .setting-item-modified-indicator { border-color: " + modifiedItemIndicatorColor + "; }");
        }
    });
    var ExcludeSettingListModel = /** @class */ (function () {
        function ExcludeSettingListModel() {
            this._dataItems = [];
        }
        Object.defineProperty(ExcludeSettingListModel.prototype, "items", {
            get: function () {
                var _this = this;
                var items = this._dataItems.map(function (item, i) {
                    var editing = item.pattern === _this._editKey;
                    return __assign({}, item, { editing: editing, selected: i === _this._selectedIdx || editing });
                });
                if (this._editKey === '') {
                    items.push({
                        editing: true,
                        selected: true,
                        pattern: '',
                        sibling: ''
                    });
                }
                return items;
            },
            enumerable: true,
            configurable: true
        });
        ExcludeSettingListModel.prototype.setEditKey = function (key) {
            this._editKey = key;
        };
        ExcludeSettingListModel.prototype.setValue = function (excludeData) {
            this._dataItems = excludeData;
        };
        ExcludeSettingListModel.prototype.select = function (idx) {
            this._selectedIdx = idx;
        };
        ExcludeSettingListModel.prototype.getSelected = function () {
            return this._selectedIdx;
        };
        ExcludeSettingListModel.prototype.selectNext = function () {
            if (typeof this._selectedIdx === 'number') {
                this._selectedIdx = Math.min(this._selectedIdx + 1, this._dataItems.length - 1);
            }
            else {
                this._selectedIdx = 0;
            }
        };
        ExcludeSettingListModel.prototype.selectPrevious = function () {
            if (typeof this._selectedIdx === 'number') {
                this._selectedIdx = Math.max(this._selectedIdx - 1, 0);
            }
            else {
                this._selectedIdx = 0;
            }
        };
        return ExcludeSettingListModel;
    }());
    exports.ExcludeSettingListModel = ExcludeSettingListModel;
    var ExcludeSettingWidget = /** @class */ (function (_super) {
        __extends(ExcludeSettingWidget, _super);
        function ExcludeSettingWidget(container, themeService, contextViewService) {
            var _this = _super.call(this) || this;
            _this.container = container;
            _this.themeService = themeService;
            _this.contextViewService = contextViewService;
            _this.listDisposables = [];
            _this.model = new ExcludeSettingListModel();
            _this._onDidChangeExclude = new event_1.Emitter();
            _this.onDidChangeExclude = _this._onDidChangeExclude.event;
            _this.listElement = DOM.append(container, $('.setting-exclude-widget'));
            _this.listElement.setAttribute('tabindex', '0');
            DOM.append(container, _this.renderAddButton());
            _this.renderList();
            _this._register(DOM.addDisposableListener(_this.listElement, DOM.EventType.CLICK, function (e) { return _this.onListClick(e); }));
            _this._register(DOM.addDisposableListener(_this.listElement, DOM.EventType.DBLCLICK, function (e) { return _this.onListDoubleClick(e); }));
            _this._register(DOM.addStandardDisposableListener(_this.listElement, 'keydown', function (e) {
                if (e.keyCode === 16 /* UpArrow */) {
                    _this.model.selectPrevious();
                    _this.renderList();
                    e.preventDefault();
                    e.stopPropagation();
                }
                else if (e.keyCode === 18 /* DownArrow */) {
                    _this.model.selectNext();
                    _this.renderList();
                    e.preventDefault();
                    e.stopPropagation();
                }
            }));
            return _this;
        }
        Object.defineProperty(ExcludeSettingWidget.prototype, "domNode", {
            get: function () {
                return this.listElement;
            },
            enumerable: true,
            configurable: true
        });
        ExcludeSettingWidget.prototype.setValue = function (excludeData) {
            this.model.setValue(excludeData);
            this.renderList();
        };
        ExcludeSettingWidget.prototype.onListClick = function (e) {
            var targetIdx = this.getClickedItemIndex(e);
            if (targetIdx < 0) {
                return;
            }
            if (this.model.getSelected() === targetIdx) {
                return;
            }
            this.model.select(targetIdx);
            this.renderList();
            e.preventDefault();
            e.stopPropagation();
        };
        ExcludeSettingWidget.prototype.onListDoubleClick = function (e) {
            var targetIdx = this.getClickedItemIndex(e);
            if (targetIdx < 0) {
                return;
            }
            var item = this.model.items[targetIdx];
            if (item) {
                this.editSetting(item.pattern);
                e.preventDefault();
                e.stopPropagation();
            }
        };
        ExcludeSettingWidget.prototype.getClickedItemIndex = function (e) {
            if (!e.target) {
                return -1;
            }
            var actionbar = DOM.findParentWithClass(e.target, 'monaco-action-bar');
            if (actionbar) {
                // Don't handle doubleclicks inside the action bar
                return -1;
            }
            var element = DOM.findParentWithClass(e.target, 'setting-exclude-row');
            if (!element) {
                return -1;
            }
            var targetIdxStr = element.getAttribute('data-index');
            if (!targetIdxStr) {
                return -1;
            }
            var targetIdx = parseInt(targetIdxStr);
            return targetIdx;
        };
        ExcludeSettingWidget.prototype.renderList = function () {
            var _this = this;
            var focused = DOM.isAncestor(document.activeElement, this.listElement);
            DOM.clearNode(this.listElement);
            this.listDisposables = lifecycle_1.dispose(this.listDisposables);
            var newMode = this.model.items.some(function (item) { return item.editing && !item.pattern; });
            DOM.toggleClass(this.container, 'setting-exclude-new-mode', newMode);
            this.model.items
                .map(function (item, i) { return _this.renderItem(item, i, focused); })
                .forEach(function (itemElement) { return _this.listElement.appendChild(itemElement); });
            var listHeight = 22 * this.model.items.length;
            this.listElement.style.height = listHeight + 'px';
        };
        ExcludeSettingWidget.prototype.createDeleteAction = function (key) {
            var _this = this;
            return {
                class: 'setting-excludeAction-remove',
                enabled: true,
                id: 'workbench.action.removeExcludeItem',
                tooltip: nls_1.localize('removeExcludeItem', "Remove Exclude Item"),
                run: function () { return _this._onDidChangeExclude.fire({ originalPattern: key, pattern: undefined }); }
            };
        };
        ExcludeSettingWidget.prototype.createEditAction = function (key) {
            var _this = this;
            return {
                class: 'setting-excludeAction-edit',
                enabled: true,
                id: 'workbench.action.editExcludeItem',
                tooltip: nls_1.localize('editExcludeItem', "Edit Exclude Item"),
                run: function () {
                    _this.editSetting(key);
                }
            };
        };
        ExcludeSettingWidget.prototype.editSetting = function (key) {
            this.model.setEditKey(key);
            this.renderList();
        };
        ExcludeSettingWidget.prototype.renderItem = function (item, idx, listFocused) {
            return item.editing ?
                this.renderEditItem(item) :
                this.renderDataItem(item, idx, listFocused);
        };
        ExcludeSettingWidget.prototype.renderDataItem = function (item, idx, listFocused) {
            var rowElement = $('.setting-exclude-row');
            rowElement.setAttribute('data-index', idx + '');
            rowElement.setAttribute('tabindex', item.selected ? '0' : '-1');
            DOM.toggleClass(rowElement, 'selected', item.selected);
            var actionBar = new actionbar_1.ActionBar(rowElement);
            this.listDisposables.push(actionBar);
            var patternElement = DOM.append(rowElement, $('.setting-exclude-pattern'));
            var siblingElement = DOM.append(rowElement, $('.setting-exclude-sibling'));
            patternElement.textContent = item.pattern;
            siblingElement.textContent = item.sibling && ('when: ' + item.sibling);
            actionBar.push([
                this.createEditAction(item.pattern),
                this.createDeleteAction(item.pattern)
            ], { icon: true, label: false });
            rowElement.title = item.sibling ?
                nls_1.localize('excludeSiblingHintLabel', "Exclude files matching `{0}`, only when a file matching `{1}` is present", item.pattern, item.sibling) :
                nls_1.localize('excludePatternHintLabel', "Exclude files matching `{0}`", item.pattern);
            if (item.selected) {
                if (listFocused) {
                    setTimeout(function () {
                        rowElement.focus();
                    }, 10);
                }
            }
            return rowElement;
        };
        ExcludeSettingWidget.prototype.renderAddButton = function () {
            var _this = this;
            var rowElement = $('.setting-exclude-new-row');
            var startAddButton = this._register(new button_1.Button(rowElement));
            startAddButton.label = nls_1.localize('addPattern', "Add Pattern");
            startAddButton.element.classList.add('setting-exclude-addButton');
            this._register(styler_1.attachButtonStyler(startAddButton, this.themeService));
            this._register(startAddButton.onDidClick(function () {
                _this.model.setEditKey('');
                _this.renderList();
            }));
            return rowElement;
        };
        ExcludeSettingWidget.prototype.renderEditItem = function (item) {
            var _this = this;
            var rowElement = $('.setting-exclude-edit-row');
            var onSubmit = function (edited) {
                _this.model.setEditKey(null);
                var pattern = patternInput.value.trim();
                if (edited && pattern) {
                    _this._onDidChangeExclude.fire({
                        originalPattern: item.pattern,
                        pattern: pattern,
                        sibling: siblingInput && siblingInput.value.trim()
                    });
                }
                _this.renderList();
            };
            var onKeydown = function (e) {
                if (e.equals(3 /* Enter */)) {
                    onSubmit(true);
                }
                else if (e.equals(9 /* Escape */)) {
                    onSubmit(false);
                    e.preventDefault();
                }
            };
            var patternInput = new inputBox_1.InputBox(rowElement, this.contextViewService, {
                placeholder: nls_1.localize('excludePatternInputPlaceholder', "Exclude Pattern...")
            });
            patternInput.element.classList.add('setting-exclude-patternInput');
            this.listDisposables.push(styler_1.attachInputBoxStyler(patternInput, this.themeService, {
                inputBackground: exports.settingsTextInputBackground,
                inputForeground: exports.settingsTextInputForeground,
                inputBorder: exports.settingsTextInputBorder
            }));
            this.listDisposables.push(patternInput);
            patternInput.value = item.pattern;
            this.listDisposables.push(DOM.addStandardDisposableListener(patternInput.inputElement, DOM.EventType.KEY_DOWN, onKeydown));
            var siblingInput;
            if (item.sibling) {
                siblingInput = new inputBox_1.InputBox(rowElement, this.contextViewService, {
                    placeholder: nls_1.localize('excludeSiblingInputPlaceholder', "When Pattern Is Present...")
                });
                siblingInput.element.classList.add('setting-exclude-siblingInput');
                this.listDisposables.push(siblingInput);
                this.listDisposables.push(styler_1.attachInputBoxStyler(siblingInput, this.themeService, {
                    inputBackground: exports.settingsTextInputBackground,
                    inputForeground: exports.settingsTextInputForeground,
                    inputBorder: exports.settingsTextInputBorder
                }));
                siblingInput.value = item.sibling;
                this.listDisposables.push(DOM.addStandardDisposableListener(siblingInput.inputElement, DOM.EventType.KEY_DOWN, onKeydown));
            }
            var okButton = this._register(new button_1.Button(rowElement));
            okButton.label = nls_1.localize('okButton', "OK");
            okButton.element.classList.add('setting-exclude-okButton');
            this.listDisposables.push(styler_1.attachButtonStyler(okButton, this.themeService));
            this.listDisposables.push(okButton.onDidClick(function () { return onSubmit(true); }));
            var cancelButton = this._register(new button_1.Button(rowElement));
            cancelButton.label = nls_1.localize('cancelButton', "Cancel");
            cancelButton.element.classList.add('setting-exclude-cancelButton');
            this.listDisposables.push(styler_1.attachButtonStyler(cancelButton, this.themeService));
            this.listDisposables.push(cancelButton.onDidClick(function () { return onSubmit(false); }));
            setTimeout(function () {
                patternInput.focus();
                patternInput.select();
            }, 0);
            return rowElement;
        };
        ExcludeSettingWidget.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.listDisposables = lifecycle_1.dispose(this.listDisposables);
        };
        ExcludeSettingWidget = __decorate([
            __param(1, themeService_1.IThemeService),
            __param(2, contextView_1.IContextViewService)
        ], ExcludeSettingWidget);
        return ExcludeSettingWidget;
    }(lifecycle_1.Disposable));
    exports.ExcludeSettingWidget = ExcludeSettingWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[109/*vs/workbench/parts/preferences/common/preferences*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/,24/*vs/base/common/paths*/]), function (require, exports, instantiation_1, contextkey_1, paths_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IPreferencesSearchService = instantiation_1.createDecorator('preferencesSearchService');
    exports.CONTEXT_SETTINGS_EDITOR = new contextkey_1.RawContextKey('inSettingsEditor', false);
    exports.CONTEXT_SETTINGS_SEARCH_FOCUS = new contextkey_1.RawContextKey('inSettingsSearch', false);
    exports.CONTEXT_TOC_ROW_FOCUS = new contextkey_1.RawContextKey('settingsTocRowFocus', false);
    exports.CONTEXT_KEYBINDINGS_EDITOR = new contextkey_1.RawContextKey('inKeybindings', false);
    exports.CONTEXT_KEYBINDINGS_SEARCH_FOCUS = new contextkey_1.RawContextKey('inKeybindingsSearch', false);
    exports.CONTEXT_KEYBINDINGS_SEARCH_VALUE = new contextkey_1.RawContextKey('hasKeybindingsSearchValue', false);
    exports.CONTEXT_KEYBINDING_FOCUS = new contextkey_1.RawContextKey('keybindingFocus', false);
    exports.SETTINGS_EDITOR_COMMAND_SEARCH = 'settings.action.search';
    exports.SETTINGS_EDITOR_COMMAND_CLEAR_SEARCH_RESULTS = 'settings.action.clearSearchResults';
    exports.SETTINGS_EDITOR_COMMAND_FOCUS_NEXT_SETTING = 'settings.action.focusNextSetting';
    exports.SETTINGS_EDITOR_COMMAND_FOCUS_PREVIOUS_SETTING = 'settings.action.focusPreviousSetting';
    exports.SETTINGS_EDITOR_COMMAND_FOCUS_FILE = 'settings.action.focusSettingsFile';
    exports.SETTINGS_EDITOR_COMMAND_EDIT_FOCUSED_SETTING = 'settings.action.editFocusedSetting';
    exports.SETTINGS_EDITOR_COMMAND_FOCUS_SETTINGS_FROM_SEARCH = 'settings.action.focusSettingsFromSearch';
    exports.SETTINGS_EDITOR_COMMAND_FOCUS_SETTINGS_LIST = 'settings.action.focusSettingsList';
    exports.SETTINGS_EDITOR_COMMAND_SHOW_CONTEXT_MENU = 'settings.action.showContextMenu';
    exports.KEYBINDINGS_EDITOR_COMMAND_SEARCH = 'keybindings.editor.searchKeybindings';
    exports.KEYBINDINGS_EDITOR_COMMAND_CLEAR_SEARCH_RESULTS = 'keybindings.editor.clearSearchResults';
    exports.KEYBINDINGS_EDITOR_COMMAND_RECORD_SEARCH_KEYS = 'keybindings.editor.recordSearchKeys';
    exports.KEYBINDINGS_EDITOR_COMMAND_SORTBY_PRECEDENCE = 'keybindings.editor.toggleSortByPrecedence';
    exports.KEYBINDINGS_EDITOR_COMMAND_DEFINE = 'keybindings.editor.defineKeybinding';
    exports.KEYBINDINGS_EDITOR_COMMAND_REMOVE = 'keybindings.editor.removeKeybinding';
    exports.KEYBINDINGS_EDITOR_COMMAND_RESET = 'keybindings.editor.resetKeybinding';
    exports.KEYBINDINGS_EDITOR_COMMAND_COPY = 'keybindings.editor.copyKeybindingEntry';
    exports.KEYBINDINGS_EDITOR_COMMAND_COPY_COMMAND = 'keybindings.editor.copyCommandKeybindingEntry';
    exports.KEYBINDINGS_EDITOR_COMMAND_SHOW_SIMILAR = 'keybindings.editor.showConflicts';
    exports.KEYBINDINGS_EDITOR_COMMAND_FOCUS_KEYBINDINGS = 'keybindings.editor.focusKeybindings';
    exports.KEYBINDINGS_EDITOR_CLEAR_INPUT = 'keybindings.editor.showDefaultKeybindings';
    exports.KEYBINDINGS_EDITOR_SHOW_DEFAULT_KEYBINDINGS = 'keybindings.editor.showDefaultKeybindings';
    exports.KEYBINDINGS_EDITOR_SHOW_USER_KEYBINDINGS = 'keybindings.editor.showUserKeybindings';
    exports.FOLDER_SETTINGS_PATH = paths_1.join('.vscode', 'settings.json');
    exports.DEFAULT_SETTINGS_EDITOR_SETTING = 'workbench.settings.openDefaultSettings';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[251/*vs/workbench/parts/preferences/common/smartSnippetInserter*/], __M([0/*require*/,1/*exports*/,77/*vs/base/common/json*/,135/*vs/editor/common/core/position*/,48/*vs/editor/common/core/range*/]), function (require, exports, json_1, position_1, range_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SmartSnippetInserter = /** @class */ (function () {
        function SmartSnippetInserter() {
        }
        SmartSnippetInserter.hasOpenBrace = function (scanner) {
            while (scanner.scan() !== 16 /* EOF */) {
                var kind = scanner.getToken();
                if (kind === 1 /* OpenBraceToken */) {
                    return true;
                }
            }
            return false;
        };
        SmartSnippetInserter.offsetToPosition = function (model, offset) {
            var offsetBeforeLine = 0;
            var eolLength = model.getEOL().length;
            var lineCount = model.getLineCount();
            for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
                var lineTotalLength = model.getLineContent(lineNumber).length + eolLength;
                var offsetAfterLine = offsetBeforeLine + lineTotalLength;
                if (offsetAfterLine > offset) {
                    return new position_1.Position(lineNumber, offset - offsetBeforeLine + 1);
                }
                offsetBeforeLine = offsetAfterLine;
            }
            return new position_1.Position(lineCount, model.getLineMaxColumn(lineCount));
        };
        SmartSnippetInserter.insertSnippet = function (model, _position) {
            var desiredPosition = model.getValueLengthInRange(new range_1.Range(1, 1, _position.lineNumber, _position.column));
            // <INVALID> [ <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT>, <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT> ] <INVALID>
            var State;
            (function (State) {
                State[State["INVALID"] = 0] = "INVALID";
                State[State["AFTER_OBJECT"] = 1] = "AFTER_OBJECT";
                State[State["BEFORE_OBJECT"] = 2] = "BEFORE_OBJECT";
            })(State || (State = {}));
            var currentState = State.INVALID;
            var lastValidPos = -1;
            var lastValidState = State.INVALID;
            var scanner = json_1.createScanner(model.getValue());
            var arrayLevel = 0;
            var objLevel = 0;
            var checkRangeStatus = function (pos, state) {
                if (state !== State.INVALID && arrayLevel === 1 && objLevel === 0) {
                    currentState = state;
                    lastValidPos = pos;
                    lastValidState = state;
                }
                else {
                    if (currentState !== State.INVALID) {
                        currentState = State.INVALID;
                        lastValidPos = scanner.getTokenOffset();
                    }
                }
            };
            while (scanner.scan() !== 16 /* EOF */) {
                var currentPos = scanner.getPosition();
                var kind = scanner.getToken();
                var goodKind = false;
                switch (kind) {
                    case 3 /* OpenBracketToken */:
                        goodKind = true;
                        arrayLevel++;
                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);
                        break;
                    case 4 /* CloseBracketToken */:
                        goodKind = true;
                        arrayLevel--;
                        checkRangeStatus(currentPos, State.INVALID);
                        break;
                    case 5 /* CommaToken */:
                        goodKind = true;
                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);
                        break;
                    case 1 /* OpenBraceToken */:
                        goodKind = true;
                        objLevel++;
                        checkRangeStatus(currentPos, State.INVALID);
                        break;
                    case 2 /* CloseBraceToken */:
                        goodKind = true;
                        objLevel--;
                        checkRangeStatus(currentPos, State.AFTER_OBJECT);
                        break;
                    case 15 /* Trivia */:
                    case 14 /* LineBreakTrivia */:
                        goodKind = true;
                }
                if (currentPos >= desiredPosition && (currentState !== State.INVALID || lastValidPos !== -1)) {
                    var acceptPosition = void 0;
                    var acceptState = void 0;
                    if (currentState !== State.INVALID) {
                        acceptPosition = (goodKind ? currentPos : scanner.getTokenOffset());
                        acceptState = currentState;
                    }
                    else {
                        acceptPosition = lastValidPos;
                        acceptState = lastValidState;
                    }
                    if (acceptState === State.AFTER_OBJECT) {
                        return {
                            position: this.offsetToPosition(model, acceptPosition),
                            prepend: ',',
                            append: ''
                        };
                    }
                    else {
                        scanner.setPosition(acceptPosition);
                        return {
                            position: this.offsetToPosition(model, acceptPosition),
                            prepend: '',
                            append: this.hasOpenBrace(scanner) ? ',' : ''
                        };
                    }
                }
            }
            // no valid position found!
            var modelLineCount = model.getLineCount();
            return {
                position: new position_1.Position(modelLineCount, model.getLineMaxColumn(modelLineCount)),
                prepend: '\n[',
                append: ']'
            };
        };
        return SmartSnippetInserter;
    }());
    exports.SmartSnippetInserter = SmartSnippetInserter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[252/*vs/workbench/parts/search/browser/patternInputWidget*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,8/*vs/base/browser/dom*/,95/*vs/base/browser/ui/widget*/,225/*vs/base/browser/ui/checkbox/checkbox*/,6/*vs/base/common/event*/,14/*vs/platform/theme/common/themeService*/,40/*vs/platform/theme/common/styler*/,254/*vs/platform/widget/browser/contextScopedHistoryWidget*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, nls, dom, widget_1, checkbox_1, event_1, themeService_1, styler_1, contextScopedHistoryWidget_1, contextkey_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PatternInputWidget = /** @class */ (function (_super) {
        __extends(PatternInputWidget, _super);
        function PatternInputWidget(parent, contextViewProvider, options, themeService, contextKeyService) {
            if (options === void 0) { options = Object.create(null); }
            var _this = _super.call(this) || this;
            _this.contextViewProvider = contextViewProvider;
            _this.themeService = themeService;
            _this.contextKeyService = contextKeyService;
            _this._onSubmit = _this._register(new event_1.Emitter());
            _this.onSubmit = _this._onSubmit.event;
            _this._onCancel = _this._register(new event_1.Emitter());
            _this.onCancel = _this._onCancel.event;
            _this.onOptionChange = null;
            _this.width = options.width || 100;
            _this.placeholder = options.placeholder || '';
            _this.ariaLabel = options.ariaLabel || nls.localize('defaultLabel', "input");
            _this.domNode = null;
            _this.inputBox = null;
            _this.render(options);
            parent.appendChild(_this.domNode);
            return _this;
        }
        PatternInputWidget.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.inputFocusTracker) {
                this.inputFocusTracker.dispose();
            }
        };
        PatternInputWidget.prototype.on = function (eventType, handler) {
            switch (eventType) {
                case 'keydown':
                case 'keyup':
                    this._register(dom.addDisposableListener(this.inputBox.inputElement, eventType, handler));
                    break;
                case PatternInputWidget.OPTION_CHANGE:
                    this.onOptionChange = handler;
                    break;
            }
            return this;
        };
        PatternInputWidget.prototype.setWidth = function (newWidth) {
            this.width = newWidth;
            this.domNode.style.width = this.width + 'px';
            this.contextViewProvider.layout();
            this.setInputWidth();
        };
        PatternInputWidget.prototype.getValue = function () {
            return this.inputBox.value;
        };
        PatternInputWidget.prototype.setValue = function (value) {
            if (this.inputBox.value !== value) {
                this.inputBox.value = value;
            }
        };
        PatternInputWidget.prototype.select = function () {
            this.inputBox.select();
        };
        PatternInputWidget.prototype.focus = function () {
            this.inputBox.focus();
        };
        PatternInputWidget.prototype.inputHasFocus = function () {
            return this.inputBox.hasFocus();
        };
        PatternInputWidget.prototype.setInputWidth = function () {
            this.inputBox.width = this.width - this.getSubcontrolsWidth() - 2; // 2 for input box border
        };
        PatternInputWidget.prototype.getSubcontrolsWidth = function () {
            return 0;
        };
        PatternInputWidget.prototype.getHistory = function () {
            return this.inputBox.getHistory();
        };
        PatternInputWidget.prototype.clearHistory = function () {
            this.inputBox.clearHistory();
        };
        PatternInputWidget.prototype.onSearchSubmit = function () {
            this.inputBox.addToHistory();
        };
        PatternInputWidget.prototype.showNextTerm = function () {
            this.inputBox.showNextValue();
        };
        PatternInputWidget.prototype.showPreviousTerm = function () {
            this.inputBox.showPreviousValue();
        };
        PatternInputWidget.prototype.render = function (options) {
            var _this = this;
            this.domNode = document.createElement('div');
            this.domNode.style.width = this.width + 'px';
            dom.addClass(this.domNode, 'monaco-findInput');
            this.inputBox = new contextScopedHistoryWidget_1.ContextScopedHistoryInputBox(this.domNode, this.contextViewProvider, {
                placeholder: this.placeholder || '',
                ariaLabel: this.ariaLabel || '',
                validationOptions: {
                    validation: null
                },
                history: options.history || []
            }, this.contextKeyService);
            this._register(styler_1.attachInputBoxStyler(this.inputBox, this.themeService));
            this.inputFocusTracker = dom.trackFocus(this.inputBox.inputElement);
            this.onkeyup(this.inputBox.inputElement, function (keyboardEvent) { return _this.onInputKeyUp(keyboardEvent); });
            var controls = document.createElement('div');
            controls.className = 'controls';
            this.renderSubcontrols(controls);
            this.domNode.appendChild(controls);
            this.setInputWidth();
        };
        PatternInputWidget.prototype.renderSubcontrols = function (controlsDiv) {
        };
        PatternInputWidget.prototype.onInputKeyUp = function (keyboardEvent) {
            switch (keyboardEvent.keyCode) {
                case 3 /* Enter */:
                    this._onSubmit.fire();
                    return;
                case 9 /* Escape */:
                    this._onCancel.fire();
                    return;
                default:
                    return;
            }
        };
        PatternInputWidget.OPTION_CHANGE = 'optionChange';
        PatternInputWidget = __decorate([
            __param(3, themeService_1.IThemeService),
            __param(4, contextkey_1.IContextKeyService)
        ], PatternInputWidget);
        return PatternInputWidget;
    }(widget_1.Widget));
    exports.PatternInputWidget = PatternInputWidget;
    var ExcludePatternInputWidget = /** @class */ (function (_super) {
        __extends(ExcludePatternInputWidget, _super);
        function ExcludePatternInputWidget(parent, contextViewProvider, options, themeService, contextKeyService) {
            if (options === void 0) { options = Object.create(null); }
            return _super.call(this, parent, contextViewProvider, options, themeService, contextKeyService) || this;
        }
        ExcludePatternInputWidget.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.useExcludesAndIgnoreFilesBox.dispose();
        };
        ExcludePatternInputWidget.prototype.useExcludesAndIgnoreFiles = function () {
            return this.useExcludesAndIgnoreFilesBox.checked;
        };
        ExcludePatternInputWidget.prototype.setUseExcludesAndIgnoreFiles = function (value) {
            this.useExcludesAndIgnoreFilesBox.checked = value;
        };
        ExcludePatternInputWidget.prototype.getSubcontrolsWidth = function () {
            return _super.prototype.getSubcontrolsWidth.call(this) + this.useExcludesAndIgnoreFilesBox.width();
        };
        ExcludePatternInputWidget.prototype.renderSubcontrols = function (controlsDiv) {
            var _this = this;
            this.useExcludesAndIgnoreFilesBox = this._register(new checkbox_1.Checkbox({
                actionClassName: 'useExcludesAndIgnoreFiles',
                title: nls.localize('useExcludesAndIgnoreFilesDescription', "Use Exclude Settings and Ignore Files"),
                isChecked: true,
            }));
            this._register(this.useExcludesAndIgnoreFilesBox.onChange(function (viaKeyboard) {
                _this.onOptionChange(null);
                if (!viaKeyboard) {
                    _this.inputBox.focus();
                }
            }));
            this._register(styler_1.attachCheckboxStyler(this.useExcludesAndIgnoreFilesBox, this.themeService));
            controlsDiv.appendChild(this.useExcludesAndIgnoreFilesBox.domNode);
            _super.prototype.renderSubcontrols.call(this, controlsDiv);
        };
        ExcludePatternInputWidget = __decorate([
            __param(3, themeService_1.IThemeService),
            __param(4, contextkey_1.IContextKeyService)
        ], ExcludePatternInputWidget);
        return ExcludePatternInputWidget;
    }(PatternInputWidget));
    exports.ExcludePatternInputWidget = ExcludePatternInputWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[148/*vs/workbench/parts/search/common/constants*/], __M([0/*require*/,1/*exports*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, contextkey_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FindInFilesActionId = 'workbench.action.findInFiles';
    exports.FocusActiveEditorCommandId = 'search.action.focusActiveEditor';
    exports.FocusSearchFromResults = 'search.action.focusSearchFromResults';
    exports.OpenMatchToSide = 'search.action.openResultToSide';
    exports.CancelActionId = 'search.action.cancel';
    exports.RemoveActionId = 'search.action.remove';
    exports.CopyPathCommandId = 'search.action.copyPath';
    exports.CopyMatchCommandId = 'search.action.copyMatch';
    exports.CopyAllCommandId = 'search.action.copyAll';
    exports.ClearSearchHistoryCommandId = 'search.action.clearHistory';
    exports.FocusSearchListCommandID = 'search.action.focusSearchList';
    exports.ReplaceActionId = 'search.action.replace';
    exports.ReplaceAllInFileActionId = 'search.action.replaceAllInFile';
    exports.ReplaceAllInFolderActionId = 'search.action.replaceAllInFolder';
    exports.CloseReplaceWidgetActionId = 'closeReplaceInFilesWidget';
    exports.ToggleCaseSensitiveCommandId = 'toggleSearchCaseSensitive';
    exports.ToggleWholeWordCommandId = 'toggleSearchWholeWord';
    exports.ToggleRegexCommandId = 'toggleSearchRegex';
    exports.ToggleSearchViewPositionCommandId = 'search.action.toggleSearchViewPosition';
    exports.SearchViewVisibleKey = new contextkey_1.RawContextKey('searchViewletVisible', true);
    exports.SearchViewFocusedKey = new contextkey_1.RawContextKey('searchViewletFocus', false);
    exports.InputBoxFocusedKey = new contextkey_1.RawContextKey('inputBoxFocus', false);
    exports.SearchInputBoxFocusedKey = new contextkey_1.RawContextKey('searchInputBoxFocus', false);
    exports.ReplaceInputBoxFocusedKey = new contextkey_1.RawContextKey('replaceInputBoxFocus', false);
    exports.PatternIncludesFocusedKey = new contextkey_1.RawContextKey('patternIncludesInputBoxFocus', false);
    exports.PatternExcludesFocusedKey = new contextkey_1.RawContextKey('patternExcludesInputBoxFocus', false);
    exports.ReplaceActiveKey = new contextkey_1.RawContextKey('replaceActive', false);
    exports.HasSearchResults = new contextkey_1.RawContextKey('hasSearchResult', false);
    exports.FirstMatchFocusKey = new contextkey_1.RawContextKey('firstMatchFocus', false);
    exports.FileMatchOrMatchFocusKey = new contextkey_1.RawContextKey('fileMatchOrMatchFocus', false); // This is actually, Match or File or Folder
    exports.FileMatchOrFolderMatchFocusKey = new contextkey_1.RawContextKey('fileMatchOrFolderMatchFocus', false);
    exports.FileFocusKey = new contextkey_1.RawContextKey('fileMatchFocus', false);
    exports.FolderFocusKey = new contextkey_1.RawContextKey('folderMatchFocus', false);
    exports.MatchFocusKey = new contextkey_1.RawContextKey('matchFocus', false);
});










define(__m[231/*vs/workbench/parts/search/common/queryBuilder*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,19/*vs/base/common/arrays*/,38/*vs/base/common/objects*/,118/*vs/base/common/collections*/,22/*vs/base/common/strings*/,142/*vs/base/common/glob*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,12/*vs/base/common/uri*/,83/*vs/base/common/labels*/,20/*vs/platform/workspace/common/workspace*/,71/*vs/platform/search/common/search*/,7/*vs/platform/configuration/common/configuration*/,43/*vs/platform/environment/common/environment*/]), function (require, exports, nls, arrays, objects, collections, strings, glob, paths, resources, uri_1, labels_1, workspace_1, search_1, configuration_1, environment_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var QueryBuilder = /** @class */ (function () {
        function QueryBuilder(configurationService, workspaceContextService, environmentService) {
            this.configurationService = configurationService;
            this.workspaceContextService = workspaceContextService;
            this.environmentService = environmentService;
        }
        QueryBuilder.prototype.text = function (contentPattern, folderResources, options) {
            return this.query(2 /* Text */, contentPattern, folderResources, options);
        };
        QueryBuilder.prototype.file = function (folderResources, options) {
            return this.query(1 /* File */, null, folderResources, options);
        };
        QueryBuilder.prototype.query = function (type, contentPattern, folderResources, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var _a = this.parseSearchPaths(options.includePattern), searchPaths = _a.searchPaths, includePattern = _a.pattern;
            var excludePattern = this.parseExcludePattern(options.excludePattern);
            // Build folderQueries from searchPaths, if given, otherwise folderResources
            var folderQueries = folderResources && folderResources.map(function (uri) { return _this.getFolderQueryForRoot(uri, type === 1 /* File */, options); });
            if (searchPaths && searchPaths.length) {
                var allRootExcludes = folderQueries && this.mergeExcludesFromFolderQueries(folderQueries);
                folderQueries = searchPaths.map(function (searchPath) { return _this.getFolderQueryForSearchPath(searchPath); });
                if (allRootExcludes) {
                    excludePattern = objects.mixin(excludePattern || Object.create(null), allRootExcludes);
                }
            }
            // TODO@rob - see #37998
            var useIgnoreFiles = !folderResources || folderResources.every(function (folder) {
                var folderConfig = _this.configurationService.getValue({ resource: folder });
                return folderConfig.search.useIgnoreFiles;
            });
            var useRipgrep = !folderResources || folderResources.every(function (folder) {
                var folderConfig = _this.configurationService.getValue({ resource: folder });
                return folderConfig.search.useRipgrep;
            });
            var ignoreSymlinks = !this.configurationService.getValue().search.followSymlinks;
            if (contentPattern) {
                this.resolveSmartCaseToCaseSensitive(contentPattern);
                contentPattern.wordSeparators = this.configurationService.getValue().editor.wordSeparators;
            }
            var query = {
                type: type,
                folderQueries: folderQueries,
                usingSearchPaths: !!(searchPaths && searchPaths.length),
                extraFileResources: options.extraFileResources,
                filePattern: options.filePattern
                    ? options.filePattern.trim()
                    : options.filePattern,
                excludePattern: excludePattern,
                includePattern: includePattern,
                maxResults: options.maxResults,
                sortByScore: options.sortByScore,
                cacheKey: options.cacheKey,
                contentPattern: contentPattern,
                useRipgrep: useRipgrep,
                disregardIgnoreFiles: options.disregardIgnoreFiles || !useIgnoreFiles,
                disregardExcludeSettings: options.disregardExcludeSettings,
                ignoreSymlinks: ignoreSymlinks,
                previewOptions: options.previewOptions,
                exists: options.exists
            };
            // Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace
            var extraFileResources = options.extraFileResources && options.extraFileResources.filter(function (extraFile) { return search_1.pathIncludedInQuery(query, extraFile.fsPath); });
            query.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;
            return query;
        };
        /**
         * Fix the isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.
         */
        QueryBuilder.prototype.resolveSmartCaseToCaseSensitive = function (contentPattern) {
            if (contentPattern.isSmartCase) {
                if (contentPattern.isRegExp) {
                    // Consider it case sensitive if it contains an unescaped capital letter
                    if (strings.containsUppercaseCharacter(contentPattern.pattern, true)) {
                        contentPattern.isCaseSensitive = true;
                    }
                }
                else if (strings.containsUppercaseCharacter(contentPattern.pattern)) {
                    contentPattern.isCaseSensitive = true;
                }
            }
        };
        /**
         * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and
         * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\/foo/bar}.
         *
         * Public for test.
         */
        QueryBuilder.prototype.parseSearchPaths = function (pattern) {
            var _this = this;
            var isSearchPath = function (segment) {
                // A segment is a search path if it is an absolute path or starts with ./, ../, .\, or ..\
                return paths.isAbsolute(segment) || /^\.\.?[\/\\]/.test(segment);
            };
            var segments = splitGlobPattern(pattern)
                .map(function (segment) { return labels_1.untildify(segment, _this.environmentService.userHome); });
            var groups = collections.groupBy(segments, function (segment) { return isSearchPath(segment) ? 'searchPaths' : 'exprSegments'; });
            var expandedExprSegments = (groups.exprSegments || [])
                .map(function (p) {
                if (p[0] === '.') {
                    p = '*' + p; // convert ".js" to "*.js"
                }
                return expandGlobalGlob(p);
            });
            var exprSegments = arrays.flatten(expandedExprSegments);
            var result = {};
            var searchPaths = this.expandSearchPathPatterns(groups.searchPaths);
            if (searchPaths && searchPaths.length) {
                result.searchPaths = searchPaths;
            }
            var includePattern = patternListToIExpression(exprSegments);
            if (includePattern) {
                result.pattern = includePattern;
            }
            return result;
        };
        /**
         * Takes the input from the excludePattern as seen in the searchView. Runs the same algorithm as parseSearchPaths,
         * but the result is a single IExpression that encapsulates all the exclude patterns.
         */
        QueryBuilder.prototype.parseExcludePattern = function (pattern) {
            var result = this.parseSearchPaths(pattern);
            var excludeExpression = glob.getEmptyExpression();
            if (result.pattern) {
                excludeExpression = objects.mixin(excludeExpression, result.pattern);
            }
            if (result.searchPaths) {
                result.searchPaths.forEach(function (searchPath) {
                    var excludeFsPath = searchPath.searchPath.fsPath;
                    var excludePath = searchPath.pattern ?
                        paths.join(excludeFsPath, searchPath.pattern) :
                        excludeFsPath;
                    excludeExpression[excludePath] = true;
                });
            }
            return Object.keys(excludeExpression).length ? excludeExpression : undefined;
        };
        QueryBuilder.prototype.mergeExcludesFromFolderQueries = function (folderQueries) {
            var _this = this;
            var mergedExcludes = folderQueries.reduce(function (merged, fq) {
                if (fq.excludePattern) {
                    objects.mixin(merged, _this.getAbsoluteIExpression(fq.excludePattern, fq.folder.fsPath));
                }
                return merged;
            }, Object.create(null));
            // Don't return an empty IExpression
            return Object.keys(mergedExcludes).length ? mergedExcludes : undefined;
        };
        QueryBuilder.prototype.getAbsoluteIExpression = function (expr, root) {
            return Object.keys(expr)
                .reduce(function (absExpr, key) {
                if (expr[key] && !paths.isAbsolute(key)) {
                    var absPattern = paths.join(root, key);
                    absExpr[absPattern] = expr[key];
                }
                return absExpr;
            }, Object.create(null));
        };
        QueryBuilder.prototype.getExcludesForFolder = function (folderConfig, options) {
            return options.disregardExcludeSettings ?
                undefined :
                search_1.getExcludes(folderConfig);
        };
        /**
         * Split search paths (./ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths
         */
        QueryBuilder.prototype.expandSearchPathPatterns = function (searchPaths) {
            var _this = this;
            if (this.workspaceContextService.getWorkbenchState() === 1 /* EMPTY */ || !searchPaths || !searchPaths.length) {
                // No workspace => ignore search paths
                return [];
            }
            var searchPathPatterns = arrays.flatten(searchPaths.map(function (searchPath) {
                // 1 open folder => just resolve the search paths to absolute paths
                var _a = splitGlobFromPath(searchPath), pathPortion = _a.pathPortion, globPortion = _a.globPortion;
                var pathPortions = _this.expandAbsoluteSearchPaths(pathPortion);
                return pathPortions.map(function (searchPath) {
                    return {
                        searchPath: searchPath,
                        pattern: globPortion
                    };
                });
            }));
            return searchPathPatterns.filter(arrays.uniqueFilter(function (searchPathPattern) { return searchPathPattern.searchPath.toString(); }));
        };
        /**
         * Takes a searchPath like `./a/foo` and expands it to absolute paths for all the workspaces it matches.
         */
        QueryBuilder.prototype.expandAbsoluteSearchPaths = function (searchPath) {
            if (paths.isAbsolute(searchPath)) {
                // Currently only local resources can be searched for with absolute search paths
                return [uri_1.URI.file(paths.normalize(searchPath))];
            }
            if (this.workspaceContextService.getWorkbenchState() === 2 /* FOLDER */) {
                var workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;
                return [resources.joinPath(workspaceUri, searchPath)];
            }
            else if (searchPath === './') {
                return []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces
            }
            else {
                var relativeSearchPathMatch_1 = searchPath.match(/\.[\/\\]([^\/\\]+)([\/\\].+)?/);
                if (relativeSearchPathMatch_1) {
                    var searchPathRoot_1 = relativeSearchPathMatch_1[1];
                    var matchingRoots = this.workspaceContextService.getWorkspace().folders.filter(function (folder) { return folder.name === searchPathRoot_1; });
                    if (matchingRoots.length) {
                        return matchingRoots.map(function (root) {
                            return relativeSearchPathMatch_1[2] ?
                                resources.joinPath(root.uri, relativeSearchPathMatch_1[2]) :
                                root.uri;
                        });
                    }
                    else {
                        // No root folder with name
                        var searchPathNotFoundError = nls.localize('search.noWorkspaceWithName', "No folder in workspace with name: {0}", searchPathRoot_1);
                        throw new Error(searchPathNotFoundError);
                    }
                }
                else {
                    // Malformed ./ search path, ignore
                }
            }
            return [];
        };
        QueryBuilder.prototype.getFolderQueryForSearchPath = function (searchPath) {
            var folder = searchPath.searchPath;
            var folderConfig = this.configurationService.getValue({ resource: folder });
            return {
                folder: folder,
                includePattern: searchPath.pattern && patternListToIExpression([searchPath.pattern]),
                fileEncoding: folderConfig.files && folderConfig.files.encoding
            };
        };
        QueryBuilder.prototype.getFolderQueryForRoot = function (folder, perFolderUseIgnoreFiles, options) {
            var folderConfig = this.configurationService.getValue({ resource: folder });
            return {
                folder: folder,
                excludePattern: this.getExcludesForFolder(folderConfig, options),
                fileEncoding: folderConfig.files && folderConfig.files.encoding,
                disregardIgnoreFiles: perFolderUseIgnoreFiles ? !folderConfig.search.useIgnoreFiles : undefined
            };
        };
        QueryBuilder = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, environment_1.IEnvironmentService)
        ], QueryBuilder);
        return QueryBuilder;
    }());
    exports.QueryBuilder = QueryBuilder;
    function splitGlobFromPath(searchPath) {
        var globCharMatch = searchPath.match(/[\*\{\}\(\)\[\]\?]/);
        if (globCharMatch) {
            var globCharIdx = globCharMatch.index;
            var lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\][^/\\]*$/);
            if (lastSlashMatch) {
                var pathPortion = searchPath.substr(0, lastSlashMatch.index);
                if (!pathPortion.match(/[/\\]/)) {
                    // If the last slash was the only slash, then we now have '' or 'C:'. Append a slash.
                    pathPortion += '/';
                }
                return {
                    pathPortion: pathPortion,
                    globPortion: searchPath.substr(lastSlashMatch.index + 1)
                };
            }
        }
        // No glob char, or malformed
        return {
            pathPortion: searchPath
        };
    }
    function patternListToIExpression(patterns) {
        return patterns.length ?
            patterns.reduce(function (glob, cur) { glob[cur] = true; return glob; }, Object.create(null)) :
            undefined;
    }
    function splitGlobPattern(pattern) {
        return glob.splitGlobAware(pattern, ',')
            .map(function (s) { return s.trim(); })
            .filter(function (s) { return !!s.length; });
    }
    /**
     * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/Microsoft/vscode/issues/32761
     */
    function expandGlobalGlob(pattern) {
        var patterns = [
            "**/" + pattern + "/**",
            "**/" + pattern
        ];
        return patterns.map(function (p) { return p.replace(/\*\*\/\*\*/g, '**'); });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[119/*vs/workbench/parts/search/common/replace*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IReplaceService = instantiation_1.createDecorator('replaceService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[143/*vs/workbench/parts/search/common/search*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,25/*vs/base/common/errors*/,13/*vs/workbench/common/editor*/,55/*vs/base/common/cancellation*/]), function (require, exports, winjs_base_1, errors_1, editor_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkspaceSymbolProviderRegistry;
    (function (WorkspaceSymbolProviderRegistry) {
        var _supports = [];
        function register(support) {
            if (support) {
                _supports.push(support);
            }
            return {
                dispose: function () {
                    if (support) {
                        var idx = _supports.indexOf(support);
                        if (idx >= 0) {
                            _supports.splice(idx, 1);
                            support = undefined;
                        }
                    }
                }
            };
        }
        WorkspaceSymbolProviderRegistry.register = register;
        function all() {
            return _supports.slice(0);
        }
        WorkspaceSymbolProviderRegistry.all = all;
    })(WorkspaceSymbolProviderRegistry = exports.WorkspaceSymbolProviderRegistry || (exports.WorkspaceSymbolProviderRegistry = {}));
    function getWorkspaceSymbols(query, token) {
        if (token === void 0) { token = cancellation_1.CancellationToken.None; }
        var result = [];
        var promises = WorkspaceSymbolProviderRegistry.all().map(function (support) {
            return Promise.resolve(support.provideWorkspaceSymbols(query, token)).then(function (value) {
                if (Array.isArray(value)) {
                    result.push([support, value]);
                }
            }, errors_1.onUnexpectedError);
        });
        return winjs_base_1.TPromise.join(promises).then(function (_) { return result; });
    }
    exports.getWorkspaceSymbols = getWorkspaceSymbols;
    /**
     * Helper to return all opened editors with resources not belonging to the currently opened workspace.
     */
    function getOutOfWorkspaceEditorResources(editorService, contextService) {
        var resources = [];
        editorService.editors.forEach(function (editor) {
            var resource = editor_1.toResource(editor, { supportSideBySide: true });
            if (resource && !contextService.isInsideWorkspace(resource)) {
                resources.push(resource);
            }
        });
        return resources;
    }
    exports.getOutOfWorkspaceEditorResources = getOutOfWorkspaceEditorResources;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[106/*vs/workbench/parts/search/common/searchModel*/], __M([0/*require*/,1/*exports*/,17/*vs/base/common/async*/,55/*vs/base/common/cancellation*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,83/*vs/base/common/labels*/,4/*vs/base/common/lifecycle*/,39/*vs/base/common/map*/,38/*vs/base/common/objects*/,22/*vs/base/common/strings*/,12/*vs/base/common/uri*/,48/*vs/editor/common/core/range*/,72/*vs/editor/common/model*/,73/*vs/editor/common/model/textModel*/,36/*vs/editor/common/services/modelService*/,3/*vs/platform/instantiation/common/instantiation*/,403/*vs/platform/search/common/replace*/,71/*vs/platform/search/common/search*/,32/*vs/platform/telemetry/common/telemetry*/,30/*vs/platform/theme/common/colorRegistry*/,14/*vs/platform/theme/common/themeService*/,119/*vs/workbench/parts/search/common/replace*/]), function (require, exports, async_1, cancellation_1, errors, event_1, labels_1, lifecycle_1, map_1, objects, strings_1, uri_1, range_1, model_1, textModel_1, modelService_1, instantiation_1, replace_1, search_1, telemetry_1, colorRegistry_1, themeService_1, replace_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Match = /** @class */ (function () {
        function Match(_parent, _result) {
            this._parent = _parent;
            this._range = new range_1.Range(_result.range.startLineNumber + 1, _result.range.startColumn + 1, _result.range.endLineNumber + 1, _result.range.endColumn + 1);
            this._rangeInPreviewText = new range_1.Range(_result.preview.match.startLineNumber + 1, _result.preview.match.startColumn + 1, _result.preview.match.endLineNumber + 1, _result.preview.match.endColumn + 1);
            this._previewText = _result.preview.text;
            this._id = this._parent.id() + '>' + this._range + this.getMatchString();
        }
        Match.prototype.id = function () {
            return this._id;
        };
        Match.prototype.parent = function () {
            return this._parent;
        };
        Match.prototype.text = function () {
            return this._previewText;
        };
        Match.prototype.range = function () {
            return this._range;
        };
        Match.prototype.preview = function () {
            var before = this._previewText.substring(0, this._rangeInPreviewText.startColumn - 1), inside = this.getMatchString(), after = this._previewText.substring(this._rangeInPreviewText.endColumn - 1);
            before = strings_1.lcut(before, 26);
            var charsRemaining = Match.MAX_PREVIEW_CHARS - before.length;
            inside = inside.substr(0, charsRemaining);
            charsRemaining -= inside.length;
            after = after.substr(0, charsRemaining);
            return {
                before: before,
                inside: inside,
                after: after,
            };
        };
        Object.defineProperty(Match.prototype, "replaceString", {
            get: function () {
                var searchModel = this.parent().parent().searchModel;
                var matchString = this.getMatchString();
                var replaceString = searchModel.replacePattern.getReplaceString(matchString);
                // If match string is not matching then regex pattern has a lookahead expression
                if (replaceString === null) {
                    replaceString = searchModel.replacePattern.getReplaceString(matchString + this._previewText.substring(this._rangeInPreviewText.endColumn - 1));
                }
                // Match string is still not matching. Could be unsupported matches (multi-line).
                if (replaceString === null) {
                    replaceString = searchModel.replacePattern.pattern;
                }
                return replaceString;
            },
            enumerable: true,
            configurable: true
        });
        Match.prototype.getMatchString = function () {
            return this._previewText.substring(this._rangeInPreviewText.startColumn - 1, this._rangeInPreviewText.endColumn - 1);
        };
        Match.MAX_PREVIEW_CHARS = 250;
        return Match;
    }());
    exports.Match = Match;
    var FileMatch = /** @class */ (function (_super) {
        __extends(FileMatch, _super);
        function FileMatch(_query, _previewOptions, _maxResults, _parent, rawMatch, modelService, replaceService) {
            var _this = _super.call(this) || this;
            _this._query = _query;
            _this._previewOptions = _previewOptions;
            _this._maxResults = _maxResults;
            _this._parent = _parent;
            _this.rawMatch = rawMatch;
            _this.modelService = modelService;
            _this.replaceService = replaceService;
            _this._onChange = _this._register(new event_1.Emitter());
            _this.onChange = _this._onChange.event;
            _this._onDispose = _this._register(new event_1.Emitter());
            _this.onDispose = _this._onDispose.event;
            _this._modelDecorations = [];
            _this._resource = _this.rawMatch.resource;
            _this._matches = new Map();
            _this._removedMatches = new Set();
            _this._updateScheduler = new async_1.RunOnceScheduler(_this.updateMatchesForModel.bind(_this), 250);
            _this.createMatches();
            _this.registerListeners();
            return _this;
        }
        FileMatch.getDecorationOption = function (selected) {
            return (selected ? FileMatch._CURRENT_FIND_MATCH : FileMatch._FIND_MATCH);
        };
        FileMatch.prototype.createMatches = function () {
            var _this = this;
            var model = this.modelService.getModel(this._resource);
            if (model) {
                this.bindModel(model);
                this.updateMatchesForModel();
            }
            else {
                this.rawMatch.matches.forEach(function (rawLineMatch) {
                    var match = new Match(_this, rawLineMatch);
                    _this.add(match);
                });
            }
        };
        FileMatch.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.modelService.onModelAdded(function (model) {
                if (model.uri.toString() === _this._resource.toString()) {
                    _this.bindModel(model);
                }
            }));
        };
        FileMatch.prototype.bindModel = function (model) {
            var _this = this;
            this._model = model;
            this._modelListener = this._model.onDidChangeContent(function () {
                _this._updateScheduler.schedule();
            });
            this._model.onWillDispose(function () { return _this.onModelWillDispose(); });
            this.updateHighlights();
        };
        FileMatch.prototype.onModelWillDispose = function () {
            // Update matches because model might have some dirty changes
            this.updateMatchesForModel();
            this.unbindModel();
        };
        FileMatch.prototype.unbindModel = function () {
            if (this._model) {
                this._updateScheduler.cancel();
                this._model.deltaDecorations(this._modelDecorations, []);
                this._model = null;
                this._modelListener.dispose();
            }
        };
        FileMatch.prototype.updateMatchesForModel = function () {
            // this is called from a timeout and might fire
            // after the model has been disposed
            if (!this._model) {
                return;
            }
            this._matches = new Map();
            var matches = this._model
                .findMatches(this._query.pattern, this._model.getFullModelRange(), this._query.isRegExp, this._query.isCaseSensitive, this._query.isWordMatch ? this._query.wordSeparators : null, false, this._maxResults);
            this.updateMatches(matches, true);
        };
        FileMatch.prototype.updatesMatchesForLineAfterReplace = function (lineNumber, modelChange) {
            var _this = this;
            var range = {
                startLineNumber: lineNumber,
                startColumn: this._model.getLineMinColumn(lineNumber),
                endLineNumber: lineNumber,
                endColumn: this._model.getLineMaxColumn(lineNumber)
            };
            var oldMatches = map_1.values(this._matches).filter(function (match) { return match.range().startLineNumber === lineNumber; });
            oldMatches.forEach(function (match) { return _this._matches.delete(match.id()); });
            var matches = this._model.findMatches(this._query.pattern, range, this._query.isRegExp, this._query.isCaseSensitive, this._query.isWordMatch ? this._query.wordSeparators : null, false, this._maxResults);
            this.updateMatches(matches, modelChange);
        };
        FileMatch.prototype.updateMatches = function (matches, modelChange) {
            var _this = this;
            matches.forEach(function (m) {
                var textSearchResult = editorMatchToTextSearchResult(m, _this._model, _this._previewOptions);
                var match = new Match(_this, textSearchResult);
                if (!_this._removedMatches.has(match.id())) {
                    _this.add(match);
                    if (_this.isMatchSelected(match)) {
                        _this._selectedMatch = match;
                    }
                }
            });
            this._onChange.fire(modelChange);
            this.updateHighlights();
        };
        FileMatch.prototype.updateHighlights = function () {
            var _this = this;
            if (!this._model) {
                return;
            }
            if (this.parent().showHighlights) {
                this._modelDecorations = this._model.deltaDecorations(this._modelDecorations, this.matches().map(function (match) { return ({
                    range: match.range(),
                    options: FileMatch.getDecorationOption(_this.isMatchSelected(match))
                }); }));
            }
            else {
                this._modelDecorations = this._model.deltaDecorations(this._modelDecorations, []);
            }
        };
        FileMatch.prototype.id = function () {
            return this.resource().toString();
        };
        FileMatch.prototype.parent = function () {
            return this._parent;
        };
        FileMatch.prototype.matches = function () {
            return map_1.values(this._matches);
        };
        FileMatch.prototype.remove = function (match) {
            this.removeMatch(match);
            this._removedMatches.add(match.id());
            this._onChange.fire(false);
        };
        FileMatch.prototype.replace = function (toReplace) {
            var _this = this;
            return this.replaceService.replace(toReplace)
                .then(function () { return _this.updatesMatchesForLineAfterReplace(toReplace.range().startLineNumber, false); });
        };
        FileMatch.prototype.setSelectedMatch = function (match) {
            if (match) {
                if (!this._matches.has(match.id())) {
                    return;
                }
                if (this.isMatchSelected(match)) {
                    return;
                }
            }
            this._selectedMatch = match;
            this.updateHighlights();
        };
        FileMatch.prototype.getSelectedMatch = function () {
            return this._selectedMatch;
        };
        FileMatch.prototype.isMatchSelected = function (match) {
            return this._selectedMatch && this._selectedMatch.id() === match.id();
        };
        FileMatch.prototype.count = function () {
            return this.matches().length;
        };
        FileMatch.prototype.resource = function () {
            return this._resource;
        };
        FileMatch.prototype.name = function () {
            return labels_1.getBaseLabel(this.resource());
        };
        FileMatch.prototype.add = function (match, trigger) {
            this._matches.set(match.id(), match);
            if (trigger) {
                this._onChange.fire(true);
            }
        };
        FileMatch.prototype.removeMatch = function (match) {
            this._matches.delete(match.id());
            if (this.isMatchSelected(match)) {
                this.setSelectedMatch(null);
            }
            else {
                this.updateHighlights();
            }
        };
        FileMatch.prototype.dispose = function () {
            this.setSelectedMatch(null);
            this.unbindModel();
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        FileMatch._CURRENT_FIND_MATCH = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            zIndex: 13,
            className: 'currentFindMatch',
            overviewRuler: {
                color: themeService_1.themeColorFromId(colorRegistry_1.overviewRulerFindMatchForeground),
                position: model_1.OverviewRulerLane.Center
            }
        });
        FileMatch._FIND_MATCH = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'findMatch',
            overviewRuler: {
                color: themeService_1.themeColorFromId(colorRegistry_1.overviewRulerFindMatchForeground),
                position: model_1.OverviewRulerLane.Center
            }
        });
        FileMatch = __decorate([
            __param(5, modelService_1.IModelService), __param(6, replace_2.IReplaceService)
        ], FileMatch);
        return FileMatch;
    }(lifecycle_1.Disposable));
    exports.FileMatch = FileMatch;
    var FolderMatch = /** @class */ (function (_super) {
        __extends(FolderMatch, _super);
        function FolderMatch(_resource, _id, _index, _query, _parent, _searchModel, replaceService, instantiationService) {
            var _this = _super.call(this) || this;
            _this._resource = _resource;
            _this._id = _id;
            _this._index = _index;
            _this._query = _query;
            _this._parent = _parent;
            _this._searchModel = _searchModel;
            _this.replaceService = replaceService;
            _this.instantiationService = instantiationService;
            _this._onChange = _this._register(new event_1.Emitter());
            _this.onChange = _this._onChange.event;
            _this._onDispose = _this._register(new event_1.Emitter());
            _this.onDispose = _this._onDispose.event;
            _this._replacingAll = false;
            _this._fileMatches = new map_1.ResourceMap();
            _this._unDisposedFileMatches = new map_1.ResourceMap();
            return _this;
        }
        Object.defineProperty(FolderMatch.prototype, "searchModel", {
            get: function () {
                return this._searchModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FolderMatch.prototype, "showHighlights", {
            get: function () {
                return this._parent.showHighlights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FolderMatch.prototype, "replacingAll", {
            set: function (b) {
                this._replacingAll = b;
            },
            enumerable: true,
            configurable: true
        });
        FolderMatch.prototype.id = function () {
            return this._id;
        };
        FolderMatch.prototype.resource = function () {
            return this._resource;
        };
        FolderMatch.prototype.index = function () {
            return this._index;
        };
        FolderMatch.prototype.name = function () {
            return labels_1.getBaseLabel(this.resource());
        };
        FolderMatch.prototype.parent = function () {
            return this._parent;
        };
        FolderMatch.prototype.hasResource = function () {
            return !!this._resource;
        };
        FolderMatch.prototype.add = function (raw, silent) {
            var _this = this;
            var changed = [];
            raw.forEach(function (rawFileMatch) {
                if (_this._fileMatches.has(rawFileMatch.resource)) {
                    _this._fileMatches.get(rawFileMatch.resource).dispose();
                }
                var fileMatch = _this.instantiationService.createInstance(FileMatch, _this._query.contentPattern, _this._query.previewOptions, _this._query.maxResults, _this, rawFileMatch);
                _this.doAdd(fileMatch);
                changed.push(fileMatch);
                var disposable = fileMatch.onChange(function () { return _this.onFileChange(fileMatch); });
                fileMatch.onDispose(function () { return disposable.dispose(); });
            });
            if (!silent && changed.length) {
                this._onChange.fire({ elements: changed, added: true });
            }
        };
        FolderMatch.prototype.clear = function () {
            var changed = this.matches();
            this.disposeMatches();
            this._onChange.fire({ elements: changed, removed: true });
        };
        FolderMatch.prototype.remove = function (match) {
            this.doRemove(match);
        };
        FolderMatch.prototype.replace = function (match) {
            var _this = this;
            return this.replaceService.replace([match]).then(function () {
                _this.doRemove(match, false, true);
            });
        };
        FolderMatch.prototype.replaceAll = function () {
            var _this = this;
            var matches = this.matches();
            return this.replaceService.replace(matches).then(function () {
                matches.forEach(function (match) { return _this.doRemove(match, false, true); });
            });
        };
        FolderMatch.prototype.matches = function () {
            return this._fileMatches.values();
        };
        FolderMatch.prototype.isEmpty = function () {
            return this.fileCount() === 0;
        };
        FolderMatch.prototype.fileCount = function () {
            return this._fileMatches.size;
        };
        FolderMatch.prototype.count = function () {
            return this.matches().reduce(function (prev, match) { return prev + match.count(); }, 0);
        };
        FolderMatch.prototype.onFileChange = function (fileMatch) {
            var added = false;
            var removed = false;
            if (!this._fileMatches.has(fileMatch.resource())) {
                this.doAdd(fileMatch);
                added = true;
            }
            if (fileMatch.count() === 0) {
                this.doRemove(fileMatch, false, false);
                added = false;
                removed = true;
            }
            if (!this._replacingAll) {
                this._onChange.fire({ elements: [fileMatch], added: added, removed: removed });
            }
        };
        FolderMatch.prototype.doAdd = function (fileMatch) {
            this._fileMatches.set(fileMatch.resource(), fileMatch);
            if (this._unDisposedFileMatches.has(fileMatch.resource())) {
                this._unDisposedFileMatches.delete(fileMatch.resource());
            }
        };
        FolderMatch.prototype.doRemove = function (fileMatch, dispose, trigger) {
            if (dispose === void 0) { dispose = true; }
            if (trigger === void 0) { trigger = true; }
            this._fileMatches.delete(fileMatch.resource());
            if (dispose) {
                fileMatch.dispose();
            }
            else {
                this._unDisposedFileMatches.set(fileMatch.resource(), fileMatch);
            }
            if (trigger) {
                this._onChange.fire({ elements: [fileMatch], removed: true });
            }
        };
        FolderMatch.prototype.disposeMatches = function () {
            this._fileMatches.values().forEach(function (fileMatch) { return fileMatch.dispose(); });
            this._unDisposedFileMatches.values().forEach(function (fileMatch) { return fileMatch.dispose(); });
            this._fileMatches.clear();
            this._unDisposedFileMatches.clear();
        };
        FolderMatch.prototype.dispose = function () {
            this.disposeMatches();
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        FolderMatch = __decorate([
            __param(6, replace_2.IReplaceService),
            __param(7, instantiation_1.IInstantiationService)
        ], FolderMatch);
        return FolderMatch;
    }(lifecycle_1.Disposable));
    exports.FolderMatch = FolderMatch;
    /**
     * Compares instances of the same match type. Different match types should not be siblings
     * and their sort order is undefined.
     */
    function searchMatchComparer(elementA, elementB) {
        if (elementA instanceof FolderMatch && elementB instanceof FolderMatch) {
            return elementA.index() - elementB.index();
        }
        if (elementA instanceof FileMatch && elementB instanceof FileMatch) {
            return elementA.resource().fsPath.localeCompare(elementB.resource().fsPath) || elementA.name().localeCompare(elementB.name());
        }
        if (elementA instanceof Match && elementB instanceof Match) {
            return range_1.Range.compareRangesUsingStarts(elementA.range(), elementB.range());
        }
        return undefined;
    }
    exports.searchMatchComparer = searchMatchComparer;
    var SearchResult = /** @class */ (function (_super) {
        __extends(SearchResult, _super);
        function SearchResult(_searchModel, replaceService, telemetryService, instantiationService) {
            var _this = _super.call(this) || this;
            _this._searchModel = _searchModel;
            _this.replaceService = replaceService;
            _this.telemetryService = telemetryService;
            _this.instantiationService = instantiationService;
            _this._onChange = _this._register(new event_1.Emitter());
            _this.onChange = _this._onChange.event;
            _this._folderMatches = [];
            _this._folderMatchesMap = map_1.TernarySearchTree.forPaths();
            _this._rangeHighlightDecorations = _this.instantiationService.createInstance(RangeHighlightDecorations);
            return _this;
        }
        Object.defineProperty(SearchResult.prototype, "query", {
            set: function (query) {
                var _this = this;
                // When updating the query we could change the roots, so ensure we clean up the old roots first.
                this.clear();
                this._folderMatches = (query.folderQueries || [])
                    .map(function (fq) { return fq.folder; })
                    .map(function (resource, index) { return _this.createFolderMatch(resource, resource.toString(), index, query); });
                this._folderMatches.forEach(function (fm) { return _this._folderMatchesMap.set(fm.resource().toString(), fm); });
                this._otherFilesMatch = this.createFolderMatch(null, 'otherFiles', this._folderMatches.length + 1, query);
            },
            enumerable: true,
            configurable: true
        });
        SearchResult.prototype.createFolderMatch = function (resource, id, index, query) {
            var _this = this;
            var folderMatch = this.instantiationService.createInstance(FolderMatch, resource, id, index, query, this, this._searchModel);
            var disposable = folderMatch.onChange(function (event) { return _this._onChange.fire(event); });
            folderMatch.onDispose(function () { return disposable.dispose(); });
            return folderMatch;
        };
        Object.defineProperty(SearchResult.prototype, "searchModel", {
            get: function () {
                return this._searchModel;
            },
            enumerable: true,
            configurable: true
        });
        SearchResult.prototype.add = function (allRaw, silent) {
            var _this = this;
            if (silent === void 0) { silent = false; }
            // Split up raw into a list per folder so we can do a batch add per folder.
            var rawPerFolder = new map_1.ResourceMap();
            var otherFileMatches = [];
            this._folderMatches.forEach(function (folderMatch) { return rawPerFolder.set(folderMatch.resource(), []); });
            allRaw.forEach(function (rawFileMatch) {
                var folderMatch = _this.getFolderMatch(rawFileMatch.resource);
                if (folderMatch.resource()) {
                    rawPerFolder.get(folderMatch.resource()).push(rawFileMatch);
                }
                else {
                    otherFileMatches.push(rawFileMatch);
                }
            });
            rawPerFolder.forEach(function (raw) {
                if (!raw.length) {
                    return;
                }
                var folderMatch = _this.getFolderMatch(raw[0].resource);
                if (folderMatch) {
                    folderMatch.add(raw, silent);
                }
            });
            this.otherFiles.add(otherFileMatches, silent);
        };
        SearchResult.prototype.clear = function () {
            this.folderMatches().forEach(function (folderMatch) { return folderMatch.clear(); });
            this.disposeMatches();
        };
        SearchResult.prototype.remove = function (match) {
            if (match instanceof FileMatch) {
                this.getFolderMatch(match.resource()).remove(match);
            }
            else {
                match.clear();
            }
        };
        SearchResult.prototype.replace = function (match) {
            return this.getFolderMatch(match.resource()).replace(match);
        };
        SearchResult.prototype.replaceAll = function (progressRunner) {
            var _this = this;
            this.replacingAll = true;
            var promise = this.replaceService.replace(this.matches(), progressRunner);
            var onDone = event_1.stopwatch(event_1.fromPromise(promise));
            /* __GDPR__
                "replaceAll.started" : {
                    "duration" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true }
                }
            */
            onDone(function (duration) { return _this.telemetryService.publicLog('replaceAll.started', { duration: duration }); });
            return promise.then(function () {
                _this.replacingAll = false;
                _this.clear();
            }, function () {
                _this.replacingAll = false;
            });
        };
        SearchResult.prototype.folderMatches = function () {
            return this._otherFilesMatch ?
                this._folderMatches.concat(this._otherFilesMatch) :
                this._folderMatches.concat();
        };
        SearchResult.prototype.matches = function () {
            var matches = [];
            this.folderMatches().forEach(function (folderMatch) {
                matches.push(folderMatch.matches());
            });
            return [].concat.apply([], matches);
        };
        SearchResult.prototype.isEmpty = function () {
            return this.folderMatches().every(function (folderMatch) { return folderMatch.isEmpty(); });
        };
        SearchResult.prototype.fileCount = function () {
            return this.folderMatches().reduce(function (prev, match) { return prev + match.fileCount(); }, 0);
        };
        SearchResult.prototype.count = function () {
            return this.matches().reduce(function (prev, match) { return prev + match.count(); }, 0);
        };
        Object.defineProperty(SearchResult.prototype, "showHighlights", {
            get: function () {
                return this._showHighlights;
            },
            enumerable: true,
            configurable: true
        });
        SearchResult.prototype.toggleHighlights = function (value) {
            if (this._showHighlights === value) {
                return;
            }
            this._showHighlights = value;
            var selectedMatch = null;
            this.matches().forEach(function (fileMatch) {
                fileMatch.updateHighlights();
                if (!selectedMatch) {
                    selectedMatch = fileMatch.getSelectedMatch();
                }
            });
            if (this._showHighlights && selectedMatch) {
                this._rangeHighlightDecorations.highlightRange(selectedMatch.parent().resource(), selectedMatch.range());
            }
            else {
                this._rangeHighlightDecorations.removeHighlightRange();
            }
        };
        Object.defineProperty(SearchResult.prototype, "rangeHighlightDecorations", {
            get: function () {
                return this._rangeHighlightDecorations;
            },
            enumerable: true,
            configurable: true
        });
        SearchResult.prototype.getFolderMatch = function (resource) {
            var folderMatch = this._folderMatchesMap.findSubstr(resource.toString());
            return folderMatch ? folderMatch : this.otherFiles;
        };
        Object.defineProperty(SearchResult.prototype, "otherFiles", {
            get: function () {
                return this._otherFilesMatch;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchResult.prototype, "replacingAll", {
            set: function (running) {
                this.folderMatches().forEach(function (folderMatch) {
                    folderMatch.replacingAll = running;
                });
            },
            enumerable: true,
            configurable: true
        });
        SearchResult.prototype.disposeMatches = function () {
            this.folderMatches().forEach(function (folderMatch) { return folderMatch.dispose(); });
            this._folderMatches = [];
            this._otherFilesMatch = null;
            this._folderMatchesMap = map_1.TernarySearchTree.forPaths();
            this._rangeHighlightDecorations.removeHighlightRange();
        };
        SearchResult.prototype.dispose = function () {
            this.disposeMatches();
            this._rangeHighlightDecorations.dispose();
            _super.prototype.dispose.call(this);
        };
        SearchResult = __decorate([
            __param(1, replace_2.IReplaceService), __param(2, telemetry_1.ITelemetryService),
            __param(3, instantiation_1.IInstantiationService)
        ], SearchResult);
        return SearchResult;
    }(lifecycle_1.Disposable));
    exports.SearchResult = SearchResult;
    var SearchModel = /** @class */ (function (_super) {
        __extends(SearchModel, _super);
        function SearchModel(searchService, telemetryService, instantiationService) {
            var _this = _super.call(this) || this;
            _this.searchService = searchService;
            _this.telemetryService = telemetryService;
            _this.instantiationService = instantiationService;
            _this._searchQuery = null;
            _this._replaceActive = false;
            _this._replaceString = null;
            _this._replacePattern = null;
            _this._onReplaceTermChanged = _this._register(new event_1.Emitter());
            _this.onReplaceTermChanged = _this._onReplaceTermChanged.event;
            _this._searchResult = _this.instantiationService.createInstance(SearchResult, _this);
            return _this;
        }
        SearchModel.prototype.isReplaceActive = function () {
            return this._replaceActive;
        };
        Object.defineProperty(SearchModel.prototype, "replaceActive", {
            set: function (replaceActive) {
                this._replaceActive = replaceActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchModel.prototype, "replacePattern", {
            get: function () {
                return this._replacePattern;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchModel.prototype, "replaceString", {
            get: function () {
                return this._replaceString;
            },
            set: function (replaceString) {
                this._replaceString = replaceString;
                if (this._searchQuery) {
                    this._replacePattern = new replace_1.ReplacePattern(replaceString, this._searchQuery.contentPattern);
                }
                this._onReplaceTermChanged.fire();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchModel.prototype, "searchResult", {
            get: function () {
                return this._searchResult;
            },
            enumerable: true,
            configurable: true
        });
        SearchModel.prototype.search = function (query, onProgress) {
            var _this = this;
            this.cancelSearch();
            this._searchQuery = query;
            this.searchResult.clear();
            this._searchResult.query = this._searchQuery;
            var progressEmitter = new event_1.Emitter();
            this._replacePattern = new replace_1.ReplacePattern(this._replaceString, this._searchQuery.contentPattern);
            var tokenSource = this.currentCancelTokenSource = new cancellation_1.CancellationTokenSource();
            var currentRequest = this.searchService.search(this._searchQuery, this.currentCancelTokenSource.token, function (p) {
                progressEmitter.fire();
                _this.onSearchProgress(p);
                if (onProgress) {
                    onProgress(p);
                }
            });
            var dispose = function () { return tokenSource.dispose(); };
            currentRequest.then(dispose, dispose);
            var onDone = event_1.fromPromise(currentRequest);
            var onFirstRender = event_1.anyEvent(onDone, progressEmitter.event);
            var onFirstRenderStopwatch = event_1.stopwatch(onFirstRender);
            /* __GDPR__
                "searchResultsFirstRender" : {
                    "duration" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true }
                }
            */
            onFirstRenderStopwatch(function (duration) { return _this.telemetryService.publicLog('searchResultsFirstRender', { duration: duration }); });
            var onDoneStopwatch = event_1.stopwatch(onDone);
            var start = Date.now();
            /* __GDPR__
                "searchResultsFinished" : {
                    "duration" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true }
                }
            */
            onDoneStopwatch(function (duration) { return _this.telemetryService.publicLog('searchResultsFinished', { duration: duration }); });
            currentRequest.then(function (value) { return _this.onSearchCompleted(value, Date.now() - start); }, function (e) { return _this.onSearchError(e, Date.now() - start); });
            return currentRequest;
        };
        SearchModel.prototype.onSearchCompleted = function (completed, duration) {
            var options = objects.assign({}, this._searchQuery.contentPattern);
            delete options.pattern;
            var stats = completed && completed.stats;
            var fileSchemeOnly = this._searchQuery.folderQueries.every(function (fq) { return fq.folder.scheme === 'file'; });
            var otherSchemeOnly = this._searchQuery.folderQueries.every(function (fq) { return fq.folder.scheme !== 'file'; });
            var scheme = fileSchemeOnly ? 'file' :
                otherSchemeOnly ? 'other' :
                    'mixed';
            /* __GDPR__
                "searchResultsShown" : {
                    "count" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "fileCount": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "options": { "${inline}": [ "${IPatternInfo}" ] },
                    "duration": { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true },
                    "useRipgrep": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "type" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" },
                    "scheme" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
                }
            */
            this.telemetryService.publicLog('searchResultsShown', {
                count: this._searchResult.count(),
                fileCount: this._searchResult.fileCount(),
                options: options,
                duration: duration,
                useRipgrep: this._searchQuery.useRipgrep,
                type: stats && stats.type,
                scheme: scheme
            });
            return completed;
        };
        SearchModel.prototype.onSearchError = function (e, duration) {
            if (errors.isPromiseCanceledError(e)) {
                this.onSearchCompleted(null, duration);
            }
        };
        SearchModel.prototype.onSearchProgress = function (p) {
            if (p.resource) {
                this._searchResult.add([p], true);
            }
        };
        SearchModel.prototype.cancelSearch = function () {
            if (this.currentCancelTokenSource) {
                this.currentCancelTokenSource.cancel();
                return true;
            }
            return false;
        };
        SearchModel.prototype.dispose = function () {
            this.cancelSearch();
            this.searchResult.dispose();
            _super.prototype.dispose.call(this);
        };
        SearchModel = __decorate([
            __param(0, search_1.ISearchService), __param(1, telemetry_1.ITelemetryService), __param(2, instantiation_1.IInstantiationService)
        ], SearchModel);
        return SearchModel;
    }(lifecycle_1.Disposable));
    exports.SearchModel = SearchModel;
    var SearchWorkbenchService = /** @class */ (function () {
        function SearchWorkbenchService(instantiationService) {
            this.instantiationService = instantiationService;
        }
        Object.defineProperty(SearchWorkbenchService.prototype, "searchModel", {
            get: function () {
                if (!this._searchModel) {
                    this._searchModel = this.instantiationService.createInstance(SearchModel);
                }
                return this._searchModel;
            },
            enumerable: true,
            configurable: true
        });
        SearchWorkbenchService = __decorate([
            __param(0, instantiation_1.IInstantiationService)
        ], SearchWorkbenchService);
        return SearchWorkbenchService;
    }());
    exports.SearchWorkbenchService = SearchWorkbenchService;
    exports.ISearchWorkbenchService = instantiation_1.createDecorator('searchWorkbenchService');
    /**
     * Can add a range highlight decoration to a model.
     * It will automatically remove it when the model has its decorations changed.
     */
    var RangeHighlightDecorations = /** @class */ (function () {
        function RangeHighlightDecorations(_modelService) {
            this._modelService = _modelService;
            this._decorationId = null;
            this._model = null;
            this._modelDisposables = [];
        }
        RangeHighlightDecorations.prototype.removeHighlightRange = function () {
            if (this._model && this._decorationId) {
                this._model.deltaDecorations([this._decorationId], []);
            }
            this._decorationId = null;
        };
        RangeHighlightDecorations.prototype.highlightRange = function (resource, range, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            var model;
            if (uri_1.URI.isUri(resource)) {
                model = this._modelService.getModel(resource);
            }
            else {
                model = resource;
            }
            if (model) {
                this.doHighlightRange(model, range);
            }
        };
        RangeHighlightDecorations.prototype.doHighlightRange = function (model, range) {
            this.removeHighlightRange();
            this._decorationId = model.deltaDecorations([], [{ range: range, options: RangeHighlightDecorations._RANGE_HIGHLIGHT_DECORATION }])[0];
            this.setModel(model);
        };
        RangeHighlightDecorations.prototype.setModel = function (model) {
            var _this = this;
            if (this._model !== model) {
                this.disposeModelListeners();
                this._model = model;
                this._modelDisposables.push(this._model.onDidChangeDecorations(function (e) {
                    _this.disposeModelListeners();
                    _this.removeHighlightRange();
                    _this._model = null;
                }));
                this._modelDisposables.push(this._model.onWillDispose(function () {
                    _this.disposeModelListeners();
                    _this.removeHighlightRange();
                    _this._model = null;
                }));
            }
        };
        RangeHighlightDecorations.prototype.disposeModelListeners = function () {
            this._modelDisposables.forEach(function (disposable) { return disposable.dispose(); });
            this._modelDisposables = [];
        };
        RangeHighlightDecorations.prototype.dispose = function () {
            if (this._model) {
                this.removeHighlightRange();
                this.disposeModelListeners();
                this._model = null;
            }
        };
        RangeHighlightDecorations._RANGE_HIGHLIGHT_DECORATION = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'rangeHighlight',
            isWholeLine: true
        });
        RangeHighlightDecorations = __decorate([
            __param(0, modelService_1.IModelService)
        ], RangeHighlightDecorations);
        return RangeHighlightDecorations;
    }());
    exports.RangeHighlightDecorations = RangeHighlightDecorations;
    /**
     * While search doesn't support multiline matches, collapse editor matches to a single line
     */
    function editorMatchToTextSearchResult(match, model, previewOptions) {
        var endLineNumber = match.range.endLineNumber - 1;
        var endCol = match.range.endColumn - 1;
        if (match.range.endLineNumber !== match.range.startLineNumber) {
            endLineNumber = match.range.startLineNumber - 1;
            endCol = model.getLineLength(match.range.startLineNumber);
        }
        return new search_1.TextSearchResult(model.getLineContent(match.range.startLineNumber), new range_1.Range(match.range.startLineNumber - 1, match.range.startColumn - 1, endLineNumber, endCol), previewOptions);
    }
    exports.editorMatchToTextSearchResult = editorMatchToTextSearchResult;
});

define(__m[117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,198/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,2/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, platform_1, JSONContributionRegistry, nls, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ISnippetsService = instantiation_1.createDecorator('snippetService');
    var languageScopeSchemaId = 'vscode://schemas/snippets';
    var languageScopeSchema = {
        id: languageScopeSchemaId,
        allowComments: true,
        defaultSnippets: [{
                label: nls.localize('snippetSchema.json.default', "Empty snippet"),
                body: { '${1:snippetName}': { 'prefix': '${2:prefix}', 'body': '${3:snippet}', 'description': '${4:description}' } }
            }],
        type: 'object',
        description: nls.localize('snippetSchema.json', 'User snippet configuration'),
        additionalProperties: {
            type: 'object',
            required: ['prefix', 'body'],
            properties: {
                prefix: {
                    description: nls.localize('snippetSchema.json.prefix', 'The prefix to used when selecting the snippet in intellisense'),
                    type: ['string', 'array']
                },
                body: {
                    description: nls.localize('snippetSchema.json.body', 'The snippet content. Use \'$1\', \'${1:defaultText}\' to define cursor positions, use \'$0\' for the final cursor position. Insert variable values with \'${varName}\' and \'${varName:defaultText}\', e.g \'This is file: $TM_FILENAME\'.'),
                    type: ['string', 'array'],
                    items: {
                        type: 'string'
                    }
                },
                description: {
                    description: nls.localize('snippetSchema.json.description', 'The snippet description.'),
                    type: 'string'
                }
            },
            additionalProperties: false
        }
    };
    var globalSchemaId = 'vscode://schemas/global-snippets';
    var globalSchema = {
        id: globalSchemaId,
        allowComments: true,
        defaultSnippets: [{
                label: nls.localize('snippetSchema.json.default', "Empty snippet"),
                body: { '${1:snippetName}': { 'scope': '${2:scope}', 'prefix': '${3:prefix}', 'body': '${4:snippet}', 'description': '${5:description}' } }
            }],
        type: 'object',
        description: nls.localize('snippetSchema.json', 'User snippet configuration'),
        additionalProperties: {
            type: 'object',
            required: ['prefix', 'body'],
            properties: {
                prefix: {
                    description: nls.localize('snippetSchema.json.prefix', 'The prefix to used when selecting the snippet in intellisense'),
                    type: ['string', 'array']
                },
                scope: {
                    description: nls.localize('snippetSchema.json.scope', "A list of language names to which this snippet applies, e.g 'typescript,javascript'."),
                    type: 'string'
                },
                body: {
                    description: nls.localize('snippetSchema.json.body', 'The snippet content. Use \'$1\', \'${1:defaultText}\' to define cursor positions, use \'$0\' for the final cursor position. Insert variable values with \'${varName}\' and \'${varName:defaultText}\', e.g \'This is file: $TM_FILENAME\'.'),
                    type: ['string', 'array'],
                    items: {
                        type: 'string'
                    }
                },
                description: {
                    description: nls.localize('snippetSchema.json.description', 'The snippet description.'),
                    type: 'string'
                }
            },
            additionalProperties: false
        }
    };
    var reg = platform_1.Registry.as(JSONContributionRegistry.Extensions.JSONContribution);
    reg.registerSchema(languageScopeSchemaId, languageScopeSchema);
    reg.registerSchema(globalSchemaId, globalSchema);
});




































define(__m[263/*vs/workbench/parts/snippets/electron-browser/configureSnippets*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,37/*vs/platform/commands/common/commands*/,43/*vs/platform/environment/common/environment*/,41/*vs/editor/common/services/modeService*/,42/*vs/platform/windows/common/windows*/,78/*path*/,23/*vs/platform/actions/common/actions*/,17/*vs/base/common/async*/,138/*vs/platform/opener/common/opener*/,12/*vs/base/common/uri*/,117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/,39/*vs/base/common/map*/,62/*vs/platform/quickinput/common/quickInput*/,20/*vs/platform/workspace/common/workspace*/,16/*vs/platform/files/common/files*/]), function (require, exports, nls, commands_1, environment_1, modeService_1, windows_1, path_1, actions_1, async_1, opener_1, uri_1, snippets_contribution_1, map_1, quickInput_1, workspace_1, files_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var _this = this;
    Object.defineProperty(exports, "__esModule", { value: true });
    var id = 'workbench.action.openSnippets';
    var ISnippetPick;
    (function (ISnippetPick) {
        function is(thing) {
            return thing && typeof thing.filepath === 'string';
        }
        ISnippetPick.is = is;
    })(ISnippetPick || (ISnippetPick = {}));
    function computePicks(snippetService, envService, modeService) {
        return __awaiter(this, void 0, void 0, function () {
            var existing, future, seen, _i, _a, file, names, _b, _c, snippet, _d, _e, scope, name_1, mode, dir, _f, _g, mode, label;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        existing = [];
                        future = [];
                        seen = new Set();
                        _i = 0;
                        return [4 /*yield*/, snippetService.getSnippetFiles()];
                    case 1:
                        _a = _h.sent();
                        _h.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3 /*break*/, 6];
                        file = _a[_i];
                        if (file.source === 3 /* Extension */) {
                            // skip extension snippets
                            return [3 /*break*/, 5];
                        }
                        if (!file.isGlobalSnippets) return [3 /*break*/, 4];
                        return [4 /*yield*/, file.load()];
                    case 3:
                        _h.sent();
                        names = new Set();
                        outer: for (_b = 0, _c = file.data; _b < _c.length; _b++) {
                            snippet = _c[_b];
                            for (_d = 0, _e = snippet.scopes; _d < _e.length; _d++) {
                                scope = _e[_d];
                                name_1 = modeService.getLanguageName(scope);
                                if (names.size >= 4) {
                                    names.add(name_1 + "...");
                                    break outer;
                                }
                                else {
                                    names.add(name_1);
                                }
                            }
                        }
                        existing.push({
                            label: path_1.basename(file.location.fsPath),
                            filepath: file.location.fsPath,
                            description: names.size === 0
                                ? nls.localize('global.scope', "(global)")
                                : nls.localize('global.1', "({0})", map_1.values(names).join(', '))
                        });
                        return [3 /*break*/, 5];
                    case 4:
                        mode = path_1.basename(file.location.fsPath, '.json');
                        existing.push({
                            label: path_1.basename(file.location.fsPath),
                            description: "(" + modeService.getLanguageName(mode) + ")",
                            filepath: file.location.fsPath
                        });
                        seen.add(mode);
                        _h.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 2];
                    case 6:
                        dir = path_1.join(envService.appSettingsHome, 'snippets');
                        for (_f = 0, _g = modeService.getRegisteredModes(); _f < _g.length; _f++) {
                            mode = _g[_f];
                            label = modeService.getLanguageName(mode);
                            if (label && !seen.has(mode)) {
                                future.push({
                                    label: mode,
                                    description: "(" + label + ")",
                                    filepath: path_1.join(dir, mode + ".json"),
                                    hint: true
                                });
                            }
                        }
                        existing.sort(function (a, b) {
                            var a_ext = path_1.extname(a.filepath);
                            var b_ext = path_1.extname(b.filepath);
                            if (a_ext === b_ext) {
                                return a.label.localeCompare(b.label);
                            }
                            else if (a_ext === '.code-snippets') {
                                return -1;
                            }
                            else {
                                return 1;
                            }
                        });
                        future.sort(function (a, b) {
                            return a.label.localeCompare(b.label);
                        });
                        return [2 /*return*/, { existing: existing, future: future }];
                }
            });
        });
    }
    function createGlobalSnippetFile(defaultPath, windowService, fileService, opener) {
        return __awaiter(this, void 0, void 0, function () {
            var path, resource;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fileService.createFolder(defaultPath)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, async_1.timeout(100)];
                    case 2:
                        _a.sent(); // ensure quick pick closes...
                        return [4 /*yield*/, windowService.showSaveDialog({
                                defaultPath: defaultPath.fsPath,
                                filters: [{ name: 'Code Snippets', extensions: ['code-snippets'] }]
                            })];
                    case 3:
                        path = _a.sent();
                        if (!path) {
                            return [2 /*return*/, undefined];
                        }
                        resource = uri_1.URI.file(path);
                        if (path_1.dirname(resource.fsPath) !== defaultPath.fsPath) {
                            return [2 /*return*/, undefined];
                        }
                        return [4 /*yield*/, fileService.updateContent(resource, [
                                '{',
                                '\t// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and ',
                                '\t// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope ',
                                '\t// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is ',
                                '\t// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: ',
                                '\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. ',
                                '\t// Placeholders with the same ids are connected.',
                                '\t// Example:',
                                '\t// "Print to console": {',
                                '\t// \t"scope": "javascript,typescript",',
                                '\t// \t"prefix": "log",',
                                '\t// \t"body": [',
                                '\t// \t\t"console.log(\'$1\');",',
                                '\t// \t\t"$2"',
                                '\t// \t],',
                                '\t// \t"description": "Log output to console"',
                                '\t// }',
                                '}'
                            ].join('\n'))];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, opener.open(resource)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    function createLanguageSnippetFile(pick, fileService) {
        return __awaiter(this, void 0, void 0, function () {
            var contents;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fileService.existsFile(uri_1.URI.file(pick.filepath))];
                    case 1:
                        if (_a.sent()) {
                            return [2 /*return*/];
                        }
                        contents = [
                            '{',
                            '\t// Place your snippets for ' + pick.label + ' here. Each snippet is defined under a snippet name and has a prefix, body and ',
                            '\t// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:',
                            '\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the ',
                            '\t// same ids are connected.',
                            '\t// Example:',
                            '\t// "Print to console": {',
                            '\t// \t"prefix": "log",',
                            '\t// \t"body": [',
                            '\t// \t\t"console.log(\'$1\');",',
                            '\t// \t\t"$2"',
                            '\t// \t],',
                            '\t// \t"description": "Log output to console"',
                            '\t// }',
                            '}'
                        ].join('\n');
                        return [4 /*yield*/, fileService.updateContent(uri_1.URI.file(pick.filepath), contents)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    commands_1.CommandsRegistry.registerCommand(id, function (accessor) { return __awaiter(_this, void 0, void 0, function () {
        var snippetService, quickInputService, opener, windowService, modeService, envService, workspaceService, fileService, picks, existing, globalSnippetPicks, _i, _a, folder, pick;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    snippetService = accessor.get(snippets_contribution_1.ISnippetsService);
                    quickInputService = accessor.get(quickInput_1.IQuickInputService);
                    opener = accessor.get(opener_1.IOpenerService);
                    windowService = accessor.get(windows_1.IWindowService);
                    modeService = accessor.get(modeService_1.IModeService);
                    envService = accessor.get(environment_1.IEnvironmentService);
                    workspaceService = accessor.get(workspace_1.IWorkspaceContextService);
                    fileService = accessor.get(files_1.IFileService);
                    return [4 /*yield*/, computePicks(snippetService, envService, modeService)];
                case 1:
                    picks = _b.sent();
                    existing = picks.existing;
                    globalSnippetPicks = [{
                            label: nls.localize('new.global', "New Global Snippets file..."),
                            uri: uri_1.URI.file(path_1.join(envService.appSettingsHome, 'snippets'))
                        }];
                    for (_i = 0, _a = workspaceService.getWorkspace().folders; _i < _a.length; _i++) {
                        folder = _a[_i];
                        globalSnippetPicks.push({
                            label: nls.localize('new.folder', "New Snippets file for '{0}'...", folder.name),
                            uri: folder.toResource('.vscode')
                        });
                    }
                    if (existing.length > 0) {
                        existing.unshift({ type: 'separator', label: nls.localize('group.global', "Existing Snippets") });
                        existing.push({ type: 'separator', label: nls.localize('new.global.sep', "New Snippets") });
                    }
                    else {
                        existing.push({ type: 'separator', label: nls.localize('new.global.sep', "New Snippets") });
                    }
                    return [4 /*yield*/, quickInputService.pick([].concat(existing, globalSnippetPicks, picks.future), {
                            placeHolder: nls.localize('openSnippet.pickLanguage', "Select Snippets File or Create Snippets"),
                            matchOnDescription: true,
                        })];
                case 2:
                    pick = _b.sent();
                    if (!(globalSnippetPicks.indexOf(pick) >= 0)) return [3 /*break*/, 3];
                    return [2 /*return*/, createGlobalSnippetFile(pick.uri, windowService, fileService, opener)];
                case 3:
                    if (!ISnippetPick.is(pick)) return [3 /*break*/, 6];
                    if (!pick.hint) return [3 /*break*/, 5];
                    return [4 /*yield*/, createLanguageSnippetFile(pick, fileService)];
                case 4:
                    _b.sent();
                    _b.label = 5;
                case 5: return [2 /*return*/, opener.open(uri_1.URI.file(pick.filepath))];
                case 6: return [2 /*return*/];
            }
        });
    }); });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
        command: {
            id: id,
            title: { value: nls.localize('openSnippet.label', "Configure User Snippets"), original: 'Preferences: Configure User Snippets' },
            category: nls.localize('preferences', "Preferences")
        }
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarPreferencesMenu, {
        group: '3_snippets',
        command: {
            id: id,
            title: nls.localize({ key: 'miOpenSnippets', comment: ['&& denotes a mnemonic'] }, "User &&Snippets")
        },
        order: 1
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[206/*vs/workbench/parts/snippets/electron-browser/snippetsFile*/], __M([0/*require*/,1/*exports*/,77/*vs/base/common/json*/,118/*vs/base/common/collections*/,2/*vs/nls*/,78/*path*/,266/*vs/editor/contrib/snippet/snippetParser*/,474/*vs/editor/contrib/snippet/snippetVariables*/,22/*vs/base/common/strings*/]), function (require, exports, json_1, collections_1, nls_1, path_1, snippetParser_1, snippetVariables_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Snippet = /** @class */ (function () {
        function Snippet(scopes, name, prefix, description, body, source, snippetSource) {
            this.scopes = scopes;
            this.name = name;
            this.prefix = prefix;
            this.description = description;
            this.body = body;
            this.source = source;
            this.snippetSource = snippetSource;
            //
            this.prefixLow = prefix ? prefix.toLowerCase() : prefix;
        }
        Object.defineProperty(Snippet.prototype, "codeSnippet", {
            get: function () {
                this._ensureCodeSnippet();
                return this._codeSnippet;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Snippet.prototype, "isBogous", {
            get: function () {
                this._ensureCodeSnippet();
                return this._isBogous;
            },
            enumerable: true,
            configurable: true
        });
        Snippet.prototype._ensureCodeSnippet = function () {
            if (!this._codeSnippet) {
                var rewrite = Snippet._rewriteBogousVariables(this.body);
                if (typeof rewrite === 'string') {
                    this._codeSnippet = rewrite;
                    this._isBogous = true;
                }
                else {
                    this._codeSnippet = this.body;
                    this._isBogous = false;
                }
            }
        };
        Snippet.compare = function (a, b) {
            if (a.snippetSource < b.snippetSource) {
                return -1;
            }
            else if (a.snippetSource > b.snippetSource) {
                return 1;
            }
            else if (a.name > b.name) {
                return 1;
            }
            else if (a.name < b.name) {
                return -1;
            }
            else {
                return 0;
            }
        };
        Snippet._rewriteBogousVariables = function (template) {
            var textmateSnippet = new snippetParser_1.SnippetParser().parse(template, false);
            var placeholders = new Map();
            var placeholderMax = 0;
            for (var _i = 0, _a = textmateSnippet.placeholders; _i < _a.length; _i++) {
                var placeholder = _a[_i];
                placeholderMax = Math.max(placeholderMax, placeholder.index);
            }
            var didChange = false;
            var stack = textmateSnippet.children.slice();
            while (stack.length > 0) {
                var marker = stack.shift();
                if (marker instanceof snippetParser_1.Variable
                    && marker.children.length === 0
                    && !snippetVariables_1.KnownSnippetVariableNames[marker.name]) {
                    // a 'variable' without a default value and not being one of our supported
                    // variables is automatically turned into a placeholder. This is to restore
                    // a bug we had before. So `${foo}` becomes `${N:foo}`
                    var index = placeholders.has(marker.name) ? placeholders.get(marker.name) : ++placeholderMax;
                    placeholders.set(marker.name, index);
                    var synthetic = new snippetParser_1.Placeholder(index).appendChild(new snippetParser_1.Text(marker.name));
                    textmateSnippet.replace(marker, [synthetic]);
                    didChange = true;
                }
                else {
                    // recurse
                    stack.push.apply(stack, marker.children);
                }
            }
            if (!didChange) {
                return false;
            }
            else {
                return textmateSnippet.toTextmateString();
            }
        };
        return Snippet;
    }());
    exports.Snippet = Snippet;
    function isJsonSerializedSnippet(thing) {
        return Boolean(thing.body) && Boolean(thing.prefix);
    }
    var SnippetFile = /** @class */ (function () {
        function SnippetFile(source, location, defaultScopes, _extension, _fileService) {
            this.source = source;
            this.location = location;
            this.defaultScopes = defaultScopes;
            this._extension = _extension;
            this._fileService = _fileService;
            this.data = [];
            this.isGlobalSnippets = path_1.extname(location.path) === '.code-snippets';
            this.isUserSnippets = !this._extension;
        }
        SnippetFile.prototype.select = function (selector, bucket) {
            if (this.isGlobalSnippets || !this.isUserSnippets) {
                this._scopeSelect(selector, bucket);
            }
            else {
                this._filepathSelect(selector, bucket);
            }
        };
        SnippetFile.prototype._filepathSelect = function (selector, bucket) {
            // for `fooLang.json` files all snippets are accepted
            if (selector === path_1.basename(this.location.path, '.json')) {
                bucket.push.apply(bucket, this.data);
            }
        };
        SnippetFile.prototype._scopeSelect = function (selector, bucket) {
            // for `my.code-snippets` files we need to look at each snippet
            for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
                var snippet = _a[_i];
                var len = snippet.scopes.length;
                if (len === 0) {
                    // always accept
                    bucket.push(snippet);
                }
                else {
                    for (var i = 0; i < len; i++) {
                        // match
                        if (snippet.scopes[i] === selector) {
                            bucket.push(snippet);
                            break; // match only once!
                        }
                    }
                }
            }
            var idx = selector.lastIndexOf('.');
            if (idx >= 0) {
                this._scopeSelect(selector.substring(0, idx), bucket);
            }
        };
        SnippetFile.prototype.load = function () {
            var _this = this;
            if (!this._loadPromise) {
                this._loadPromise = Promise.resolve(this._fileService.resolveContent(this.location, { encoding: 'utf8' })).then(function (content) {
                    var data = json_1.parse(content.value.toString());
                    if (typeof data === 'object') {
                        collections_1.forEach(data, function (entry) {
                            var name = entry.key, scopeOrTemplate = entry.value;
                            if (isJsonSerializedSnippet(scopeOrTemplate)) {
                                _this._parseSnippet(name, scopeOrTemplate, _this.data);
                            }
                            else {
                                collections_1.forEach(scopeOrTemplate, function (entry) {
                                    var name = entry.key, template = entry.value;
                                    _this._parseSnippet(name, template, _this.data);
                                });
                            }
                        });
                    }
                    return _this;
                });
            }
            return this._loadPromise;
        };
        SnippetFile.prototype.reset = function () {
            this._loadPromise = undefined;
            this.data.length = 0;
        };
        SnippetFile.prototype._parseSnippet = function (name, snippet, bucket) {
            var _this = this;
            var prefix = snippet.prefix, body = snippet.body, description = snippet.description;
            if (Array.isArray(body)) {
                body = body.join('\n');
            }
            if ((typeof prefix !== 'string' && !Array.isArray(prefix)) || typeof body !== 'string') {
                return;
            }
            var scopes;
            if (this.defaultScopes) {
                scopes = this.defaultScopes;
            }
            else if (typeof snippet.scope === 'string') {
                scopes = snippet.scope.split(',').map(function (s) { return s.trim(); }).filter(function (s) { return !strings_1.isFalsyOrWhitespace(s); });
            }
            else {
                scopes = [];
            }
            var source;
            if (this._extension) {
                // extension snippet -> show the name of the extension
                source = this._extension.displayName || this._extension.name;
            }
            else if (this.source === 2 /* Workspace */) {
                // workspace -> only *.code-snippets files
                source = nls_1.localize('source.workspaceSnippetGlobal', "Workspace Snippet");
            }
            else {
                // user -> global (*.code-snippets) and language snippets
                if (this.isGlobalSnippets) {
                    source = nls_1.localize('source.userSnippetGlobal', "Global User Snippet");
                }
                else {
                    source = nls_1.localize('source.userSnippet', "User Snippet");
                }
            }
            var prefixes = Array.isArray(prefix) ? prefix : [prefix];
            prefixes.forEach(function (p) {
                bucket.push(new Snippet(scopes, name, p, description, body, source, _this.source));
            });
        };
        return SnippetFile;
    }());
    exports.SnippetFile = SnippetFile;
});

















































define(__m[268/*vs/workbench/parts/snippets/electron-browser/insertSnippet*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,56/*vs/editor/browser/editorExtensions*/,41/*vs/editor/common/services/modeService*/,37/*vs/platform/commands/common/commands*/,117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/,136/*vs/editor/contrib/snippet/snippetController2*/,114/*vs/editor/common/editorContextKeys*/,206/*vs/workbench/parts/snippets/electron-browser/snippetsFile*/,62/*vs/platform/quickinput/common/quickInput*/]), function (require, exports, nls, editorExtensions_1, modeService_1, commands_1, snippets_contribution_1, snippetController2_1, editorContextKeys_1, snippetsFile_1, quickInput_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Args = /** @class */ (function () {
        function Args(snippet, name, langId) {
            this.snippet = snippet;
            this.name = name;
            this.langId = langId;
        }
        Args.fromUser = function (arg) {
            if (!arg || typeof arg !== 'object') {
                return Args._empty;
            }
            var snippet = arg.snippet, name = arg.name, langId = arg.langId;
            if (typeof snippet !== 'string') {
                snippet = undefined;
            }
            if (typeof name !== 'string') {
                name = undefined;
            }
            if (typeof langId !== 'string') {
                langId = undefined;
            }
            return new Args(snippet, name, langId);
        };
        Args._empty = new Args(undefined, undefined, undefined);
        return Args;
    }());
    var InsertSnippetAction = /** @class */ (function (_super) {
        __extends(InsertSnippetAction, _super);
        function InsertSnippetAction() {
            return _super.call(this, {
                id: 'editor.action.insertSnippet',
                label: nls.localize('snippet.suggestions.label', "Insert Snippet"),
                alias: 'Insert Snippet',
                precondition: editorContextKeys_1.EditorContextKeys.writable
            }) || this;
        }
        InsertSnippetAction.prototype.run = function (accessor, editor, arg) {
            var _this = this;
            var modeService = accessor.get(modeService_1.IModeService);
            var snippetService = accessor.get(snippets_contribution_1.ISnippetsService);
            if (!editor.getModel()) {
                return undefined;
            }
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            var _a = editor.getPosition(), lineNumber = _a.lineNumber, column = _a.column;
            var _b = Args.fromUser(arg), snippet = _b.snippet, name = _b.name, langId = _b.langId;
            return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                var languageId, language, snippets, picks, prevSnippet, _i, snippets_1, snippet_1, pick, label;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (snippet) {
                                return [2 /*return*/, resolve(new snippetsFile_1.Snippet(undefined, undefined, undefined, undefined, snippet, undefined, 1 /* User */))];
                            }
                            if (langId) {
                                languageId = modeService.getLanguageIdentifier(langId).id;
                            }
                            else {
                                editor.getModel().tokenizeIfCheap(lineNumber);
                                languageId = editor.getModel().getLanguageIdAtPosition(lineNumber, column);
                                language = modeService.getLanguageIdentifier(languageId).language;
                                if (!modeService.getLanguageName(language)) {
                                    languageId = editor.getModel().getLanguageIdentifier().id;
                                }
                            }
                            if (!name) return [3 /*break*/, 2];
                            return [4 /*yield*/, snippetService.getSnippets(languageId)];
                        case 1:
                            // take selected snippet
                            (_a.sent()).every(function (snippet) {
                                if (snippet.name !== name) {
                                    return true;
                                }
                                resolve(snippet);
                                return false;
                            });
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, snippetService.getSnippets(languageId)];
                        case 3:
                            snippets = (_a.sent()).sort(snippetsFile_1.Snippet.compare);
                            picks = [];
                            prevSnippet = void 0;
                            for (_i = 0, snippets_1 = snippets; _i < snippets_1.length; _i++) {
                                snippet_1 = snippets_1[_i];
                                pick = {
                                    label: snippet_1.prefix,
                                    detail: snippet_1.description,
                                    snippet: snippet_1
                                };
                                if (!prevSnippet || prevSnippet.snippetSource !== snippet_1.snippetSource) {
                                    label = '';
                                    switch (snippet_1.snippetSource) {
                                        case 1 /* User */:
                                            label = nls.localize('sep.userSnippet', "User Snippets");
                                            break;
                                        case 3 /* Extension */:
                                            label = nls.localize('sep.extSnippet', "Extension Snippets");
                                            break;
                                        case 2 /* Workspace */:
                                            label = nls.localize('sep.workspaceSnippet', "Workspace Snippets");
                                            break;
                                    }
                                    picks.push({ type: 'separator', label: label });
                                }
                                picks.push(pick);
                                prevSnippet = snippet_1;
                            }
                            return [2 /*return*/, quickInputService.pick(picks, { matchOnDetail: true }).then(function (pick) { return resolve(pick && pick.snippet); }, reject)];
                        case 4: return [2 /*return*/];
                    }
                });
            }); }).then(function (snippet) {
                if (snippet) {
                    snippetController2_1.SnippetController2.get(editor).insert(snippet.codeSnippet, 0, 0);
                }
            });
        };
        return InsertSnippetAction;
    }(editorExtensions_1.EditorAction));
    editorExtensions_1.registerEditorAction(InsertSnippetAction);
    // compatibility command to make sure old keybinding are still working
    commands_1.CommandsRegistry.registerCommand('editor.action.showSnippets', function (accessor) {
        return accessor.get(commands_1.ICommandService).executeCommand('editor.action.insertSnippet');
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[269/*vs/workbench/parts/terminal/common/terminal*/], __M([0/*require*/,1/*exports*/,10/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TERMINAL_PANEL_ID = 'workbench.panel.terminal';
    exports.TERMINAL_SERVICE_ID = 'terminalService';
    /** A context key that is set when there is at least one opened integrated terminal. */
    exports.KEYBINDING_CONTEXT_TERMINAL_IS_OPEN = new contextkey_1.RawContextKey('terminalIsOpen', false);
    /** A context key that is set when the integrated terminal has focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS = new contextkey_1.RawContextKey('terminalFocus', undefined);
    /** A context key that is set when the integrated terminal does not have focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS.toNegated();
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED = new contextkey_1.RawContextKey('terminalTextSelected', undefined);
    /** A keybinding context key that is set when the integrated terminal does not have text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_NOT_SELECTED = exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.toNegated();
    /**  A context key that is set when the find widget in integrated terminal is visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('terminalFindWidgetVisible', undefined);
    /**  A context key that is set when the find widget in integrated terminal is not visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_NOT_VISIBLE = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.toNegated();
    /**  A context key that is set when the find widget find input in integrated terminal is focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetInputFocused', false);
    /**  A context key that is set when the find widget in integrated terminal is focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetFocused', false);
    /**  A context key that is set when the find widget find input in integrated terminal is not focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED.toNegated();
    exports.IS_WORKSPACE_SHELL_ALLOWED_STORAGE_KEY = 'terminal.integrated.isWorkspaceShellAllowed';
    exports.NEVER_SUGGEST_SELECT_WINDOWS_SHELL_STORAGE_KEY = 'terminal.integrated.neverSuggestSelectWindowsShell';
    exports.NEVER_MEASURE_RENDER_TIME_STORAGE_KEY = 'terminal.integrated.neverMeasureRenderTime';
    // The creation of extension host terminals is delayed by this value (milliseconds). The purpose of
    // this delay is to allow the terminal instance to initialize correctly and have its ID set before
    // trying to create the corressponding object on the ext host.
    exports.EXT_HOST_CREATION_DELAY = 100;
    exports.ITerminalService = instantiation_1.createDecorator(exports.TERMINAL_SERVICE_ID);
    exports.TerminalCursorStyle = {
        BLOCK: 'block',
        LINE: 'line',
        UNDERLINE: 'underline'
    };
    exports.TERMINAL_CONFIG_SECTION = 'terminal.integrated';
    exports.DEFAULT_LETTER_SPACING = 0;
    exports.MINIMUM_LETTER_SPACING = -5;
    exports.DEFAULT_LINE_HEIGHT = 1.0;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[159/*vs/workbench/services/activity/common/activity*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseBadge = /** @class */ (function () {
        function BaseBadge(descriptorFn) {
            this.descriptorFn = descriptorFn;
        }
        BaseBadge.prototype.getDescription = function () {
            return this.descriptorFn(null);
        };
        return BaseBadge;
    }());
    exports.BaseBadge = BaseBadge;
    var NumberBadge = /** @class */ (function (_super) {
        __extends(NumberBadge, _super);
        function NumberBadge(number, descriptorFn) {
            var _this = _super.call(this, descriptorFn) || this;
            _this.number = number;
            return _this;
        }
        NumberBadge.prototype.getDescription = function () {
            return this.descriptorFn(this.number);
        };
        return NumberBadge;
    }(BaseBadge));
    exports.NumberBadge = NumberBadge;
    var TextBadge = /** @class */ (function (_super) {
        __extends(TextBadge, _super);
        function TextBadge(text, descriptorFn) {
            var _this = _super.call(this, descriptorFn) || this;
            _this.text = text;
            return _this;
        }
        return TextBadge;
    }(BaseBadge));
    exports.TextBadge = TextBadge;
    var IconBadge = /** @class */ (function (_super) {
        __extends(IconBadge, _super);
        function IconBadge(descriptorFn) {
            return _super.call(this, descriptorFn) || this;
        }
        return IconBadge;
    }(BaseBadge));
    exports.IconBadge = IconBadge;
    var ProgressBadge = /** @class */ (function (_super) {
        __extends(ProgressBadge, _super);
        function ProgressBadge() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ProgressBadge;
    }(BaseBadge));
    exports.ProgressBadge = ProgressBadge;
    exports.IActivityService = instantiation_1.createDecorator('activityService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[113/*vs/workbench/services/backup/common/backup*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBackupFileService = instantiation_1.createDecorator('backupFileService');
    exports.BACKUP_FILE_RESOLVE_OPTIONS = { acceptTextOnly: true, encoding: 'utf8' };
    exports.BACKUP_FILE_UPDATE_OPTIONS = { encoding: 'utf8' };
});























define(__m[272/*vs/workbench/common/editor/untitledEditorModel*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,116/*vs/workbench/common/editor/textEditorModel*/,152/*vs/editor/common/modes/modesRegistry*/,16/*vs/platform/files/common/files*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/,6/*vs/base/common/event*/,17/*vs/base/common/async*/,113/*vs/workbench/services/backup/common/backup*/,88/*vs/editor/common/services/resourceConfiguration*/,73/*vs/editor/common/model/textModel*/]), function (require, exports, winjs_base_1, textEditorModel_1, modesRegistry_1, files_1, modeService_1, modelService_1, event_1, async_1, backup_1, resourceConfiguration_1, textModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var UntitledEditorModel = /** @class */ (function (_super) {
        __extends(UntitledEditorModel, _super);
        function UntitledEditorModel(modeId, resource, hasAssociatedFilePath, initialValue, preferredEncoding, modeService, modelService, backupFileService, configurationService) {
            var _this = _super.call(this, modelService, modeService) || this;
            _this.modeId = modeId;
            _this.resource = resource;
            _this.hasAssociatedFilePath = hasAssociatedFilePath;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.backupFileService = backupFileService;
            _this.configurationService = configurationService;
            _this._onDidChangeContent = _this._register(new event_1.Emitter());
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeEncoding = _this._register(new event_1.Emitter());
            _this.dirty = false;
            _this.versionId = 0;
            _this.contentChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidChangeContent.fire(); }, UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeContent", {
            get: function () { return this._onDidChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorModel.prototype, "onDidChangeEncoding", {
            get: function () { return this._onDidChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        UntitledEditorModel.prototype.getOrCreateMode = function (modeService, modeId, firstLineText) {
            if (!modeId || modeId === modesRegistry_1.PLAINTEXT_MODE_ID) {
                return modeService.getOrCreateModeByFilepathOrFirstLine(this.resource.fsPath, firstLineText); // lookup mode via resource path if the provided modeId is unspecific
            }
            return _super.prototype.getOrCreateMode.call(this, modeService, modeId, firstLineText);
        };
        UntitledEditorModel.prototype.registerListeners = function () {
            var _this = this;
            // Config Changes
            this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationChange(); }));
        };
        UntitledEditorModel.prototype.onConfigurationChange = function () {
            var configuredEncoding = this.configurationService.getValue(this.resource, 'files.encoding');
            if (this.configuredEncoding !== configuredEncoding) {
                this.configuredEncoding = configuredEncoding;
                if (!this.preferredEncoding) {
                    this._onDidChangeEncoding.fire(); // do not fire event if we have a preferred encoding set
                }
            }
        };
        UntitledEditorModel.prototype.getVersionId = function () {
            return this.versionId;
        };
        UntitledEditorModel.prototype.getModeId = function () {
            if (this.textEditorModel) {
                return this.textEditorModel.getLanguageIdentifier().language;
            }
            return null;
        };
        UntitledEditorModel.prototype.getEncoding = function () {
            return this.preferredEncoding || this.configuredEncoding;
        };
        UntitledEditorModel.prototype.setEncoding = function (encoding) {
            var oldEncoding = this.getEncoding();
            this.preferredEncoding = encoding;
            // Emit if it changed
            if (oldEncoding !== this.preferredEncoding) {
                this._onDidChangeEncoding.fire();
            }
        };
        UntitledEditorModel.prototype.isDirty = function () {
            return this.dirty;
        };
        UntitledEditorModel.prototype.setDirty = function (dirty) {
            if (this.dirty === dirty) {
                return;
            }
            this.dirty = dirty;
            this._onDidChangeDirty.fire();
        };
        UntitledEditorModel.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorModel.prototype.revert = function () {
            this.setDirty(false);
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.load = function () {
            var _this = this;
            // Check for backups first
            return this.backupFileService.loadBackupResource(this.resource).then(function (backupResource) {
                if (backupResource) {
                    return _this.backupFileService.resolveBackupContent(backupResource);
                }
                return null;
            }).then(function (backupTextBufferFactory) {
                var hasBackup = !!backupTextBufferFactory;
                // untitled associated to file path are dirty right away as well as untitled with content
                _this.setDirty(_this.hasAssociatedFilePath || hasBackup);
                var untitledContents;
                if (backupTextBufferFactory) {
                    untitledContents = backupTextBufferFactory;
                }
                else {
                    untitledContents = textModel_1.createTextBufferFactory(_this.initialValue || '');
                }
                return _this.doLoad(untitledContents).then(function (model) {
                    // Encoding
                    _this.configuredEncoding = _this.configurationService.getValue(_this.resource, 'files.encoding');
                    // Listen to content changes
                    _this._register(_this.textEditorModel.onDidChangeContent(function () { return _this.onModelContentChanged(); }));
                    // Listen to mode changes
                    _this._register(_this.textEditorModel.onDidChangeLanguage(function () { return _this.onConfigurationChange(); })); // mode change can have impact on config
                    return model;
                });
            });
        };
        UntitledEditorModel.prototype.doLoad = function (content) {
            var _this = this;
            // Create text editor model if not yet done
            if (!this.textEditorModel) {
                return this.createTextEditorModel(content, this.resource, this.modeId).then(function (model) { return _this; });
            }
            // Otherwise update
            else {
                this.updateTextEditorModel(content);
            }
            return winjs_base_1.TPromise.as(this);
        };
        UntitledEditorModel.prototype.onModelContentChanged = function () {
            this.versionId++;
            // mark the untitled editor as non-dirty once its content becomes empty and we do
            // not have an associated path set. we never want dirty indicator in that case.
            if (!this.hasAssociatedFilePath && this.textEditorModel.getLineCount() === 1 && this.textEditorModel.getLineContent(1) === '') {
                this.setDirty(false);
            }
            // turn dirty otherwise
            else {
                this.setDirty(true);
            }
            // Handle content change event buffered
            this.contentChangeEventScheduler.schedule();
        };
        UntitledEditorModel.prototype.isReadonly = function () {
            return false;
        };
        UntitledEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;
        UntitledEditorModel = __decorate([
            __param(5, modeService_1.IModeService),
            __param(6, modelService_1.IModelService),
            __param(7, backup_1.IBackupFileService),
            __param(8, resourceConfiguration_1.ITextResourceConfigurationService)
        ], UntitledEditorModel);
        return UntitledEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.UntitledEditorModel = UntitledEditorModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[153/*vs/workbench/services/configuration/common/configuration*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FOLDER_CONFIG_FOLDER_NAME = '.vscode';
    exports.FOLDER_SETTINGS_NAME = 'settings';
    exports.FOLDER_SETTINGS_PATH = exports.FOLDER_CONFIG_FOLDER_NAME + "/" + exports.FOLDER_SETTINGS_NAME + ".json";
    exports.IWorkspaceConfigurationService = instantiation_1.createDecorator('configurationService');
    exports.defaultSettingsSchemaId = 'vscode://schemas/settings/default';
    exports.userSettingsSchemaId = 'vscode://schemas/settings/user';
    exports.workspaceSettingsSchemaId = 'vscode://schemas/settings/workspace';
    exports.folderSettingsSchemaId = 'vscode://schemas/settings/folder';
    exports.launchSchemaId = 'vscode://schemas/launch';
    exports.TASKS_CONFIGURATION_KEY = 'tasks';
    exports.LAUNCH_CONFIGURATION_KEY = 'launch';
    exports.WORKSPACE_STANDALONE_CONFIGURATIONS = Object.create(null);
    exports.WORKSPACE_STANDALONE_CONFIGURATIONS[exports.TASKS_CONFIGURATION_KEY] = exports.FOLDER_CONFIG_FOLDER_NAME + "/" + exports.TASKS_CONFIGURATION_KEY + ".json";
    exports.WORKSPACE_STANDALONE_CONFIGURATIONS[exports.LAUNCH_CONFIGURATION_KEY] = exports.FOLDER_CONFIG_FOLDER_NAME + "/" + exports.LAUNCH_CONFIGURATION_KEY + ".json";
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




































































define(__m[230/*vs/workbench/parts/preferences/electron-browser/preferencesSearch*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,19/*vs/base/common/arrays*/,22/*vs/base/common/strings*/,9/*vs/platform/registry/common/platform*/,90/*vs/platform/configuration/common/configurationRegistry*/,69/*vs/base/common/filters*/,153/*vs/workbench/services/configuration/common/configuration*/,43/*vs/platform/environment/common/environment*/,3/*vs/platform/instantiation/common/instantiation*/,473/*vs/base/node/request*/,4/*vs/base/common/lifecycle*/,122/*vs/platform/extensionManagement/common/extensionManagement*/,86/*vs/platform/log/common/log*/,55/*vs/base/common/cancellation*/,25/*vs/base/common/errors*/]), function (require, exports, winjs_base_1, arrays_1, strings, platform_1, configurationRegistry_1, filters_1, configuration_1, environment_1, instantiation_1, request_1, lifecycle_1, extensionManagement_1, log_1, cancellation_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PreferencesSearchService = /** @class */ (function (_super) {
        __extends(PreferencesSearchService, _super);
        function PreferencesSearchService(configurationService, environmentService, instantiationService, extensionManagementService, extensionEnablementService) {
            var _this = _super.call(this) || this;
            _this.configurationService = configurationService;
            _this.environmentService = environmentService;
            _this.instantiationService = instantiationService;
            _this.extensionManagementService = extensionManagementService;
            _this.extensionEnablementService = extensionEnablementService;
            // This request goes to the shared process but results won't change during a window's lifetime, so cache the results.
            _this._installedExtensions = _this.extensionManagementService.getInstalled(1 /* User */).then(function (exts) {
                // Filter to enabled extensions that have settings
                return exts
                    .filter(function (ext) { return _this.extensionEnablementService.isEnabled(ext); })
                    .filter(function (ext) { return ext.manifest && ext.manifest.contributes && ext.manifest.contributes.configuration; })
                    .filter(function (ext) { return !!ext.identifier.uuid; });
            });
            return _this;
        }
        Object.defineProperty(PreferencesSearchService.prototype, "remoteSearchAllowed", {
            get: function () {
                var workbenchSettings = this.configurationService.getValue().workbench.settings;
                return false;
                if (!workbenchSettings.enableNaturalLanguageSearch) {
                    return false;
                }
                return !!this._endpoint.urlBase;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesSearchService.prototype, "_endpoint", {
            get: function () {
                var workbenchSettings = this.configurationService.getValue().workbench.settings;
                if (workbenchSettings.naturalLanguageSearchEndpoint) {
                    return {
                        urlBase: workbenchSettings.naturalLanguageSearchEndpoint,
                        key: workbenchSettings.naturalLanguageSearchKey
                    };
                }
                else {
                    return {
                        urlBase: this.environmentService.settingsSearchUrl
                    };
                }
            },
            enumerable: true,
            configurable: true
        });
        PreferencesSearchService.prototype.getRemoteSearchProvider = function (filter, newExtensionsOnly) {
            if (newExtensionsOnly === void 0) { newExtensionsOnly = false; }
            var opts = {
                filter: filter,
                newExtensionsOnly: newExtensionsOnly,
                endpoint: this._endpoint
            };
            return this.remoteSearchAllowed && this.instantiationService.createInstance(RemoteSearchProvider, opts, this._installedExtensions);
        };
        PreferencesSearchService.prototype.getLocalSearchProvider = function (filter) {
            return this.instantiationService.createInstance(LocalSearchProvider, filter);
        };
        PreferencesSearchService = __decorate([
            __param(0, configuration_1.IWorkspaceConfigurationService),
            __param(1, environment_1.IEnvironmentService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, extensionManagement_1.IExtensionManagementService),
            __param(4, extensionManagement_1.IExtensionEnablementService)
        ], PreferencesSearchService);
        return PreferencesSearchService;
    }(lifecycle_1.Disposable));
    exports.PreferencesSearchService = PreferencesSearchService;
    var LocalSearchProvider = /** @class */ (function () {
        function LocalSearchProvider(_filter) {
            this._filter = _filter;
            // Remove " and : which are likely to be copypasted as part of a setting name.
            // Leave other special characters which the user might want to search for.
            this._filter = this._filter
                .replace(/[":]/g, ' ')
                .replace(/  /g, ' ')
                .trim();
        }
        LocalSearchProvider.prototype.searchModel = function (preferencesModel, token) {
            var _this = this;
            if (!this._filter) {
                return winjs_base_1.TPromise.wrap(null);
            }
            var orderedScore = LocalSearchProvider.START_SCORE; // Sort is not stable
            var settingMatcher = function (setting) {
                var matches = new SettingMatches(_this._filter, setting, true, true, function (filter, setting) { return preferencesModel.findValueMatches(filter, setting); }).matches;
                var score = _this._filter === setting.key ?
                    LocalSearchProvider.EXACT_MATCH_SCORE :
                    orderedScore--;
                return matches && matches.length ?
                    {
                        matches: matches,
                        score: score
                    } :
                    null;
            };
            var filterMatches = preferencesModel.filterSettings(this._filter, this.getGroupFilter(this._filter), settingMatcher);
            if (filterMatches[0] && filterMatches[0].score === LocalSearchProvider.EXACT_MATCH_SCORE) {
                return winjs_base_1.TPromise.wrap({
                    filterMatches: filterMatches.slice(0, 1),
                    exactMatch: true
                });
            }
            else {
                return winjs_base_1.TPromise.wrap({
                    filterMatches: filterMatches
                });
            }
        };
        LocalSearchProvider.prototype.getGroupFilter = function (filter) {
            var regex = strings.createRegExp(filter, false, { global: true });
            return function (group) {
                return regex.test(group.title);
            };
        };
        LocalSearchProvider.EXACT_MATCH_SCORE = 10000;
        LocalSearchProvider.START_SCORE = 1000;
        return LocalSearchProvider;
    }());
    exports.LocalSearchProvider = LocalSearchProvider;
    var RemoteSearchProvider = /** @class */ (function () {
        function RemoteSearchProvider(options, installedExtensions, environmentService, 
        // @IRequestService private requestService: IRequestService,
        logService) {
            this.options = options;
            this.installedExtensions = installedExtensions;
            this.environmentService = environmentService;
            this.logService = logService;
            this._remoteSearchP = this.options.filter ?
                winjs_base_1.TPromise.wrap(this.getSettingsForFilter(this.options.filter)) :
                winjs_base_1.TPromise.wrap(null);
        }
        RemoteSearchProvider.prototype.searchModel = function (preferencesModel, token) {
            var _this = this;
            return this._remoteSearchP.then(function (remoteResult) {
                if (!remoteResult) {
                    return null;
                }
                if (token && token.isCancellationRequested) {
                    throw errors_1.canceled();
                }
                var resultKeys = Object.keys(remoteResult.scoredResults);
                var highScoreKey = arrays_1.top(resultKeys, function (a, b) { return remoteResult.scoredResults[b].score - remoteResult.scoredResults[a].score; }, 1)[0];
                var highScore = highScoreKey ? remoteResult.scoredResults[highScoreKey].score : 0;
                var minScore = highScore / 5;
                if (_this.options.newExtensionsOnly) {
                    return _this.installedExtensions.then(function (installedExtensions) {
                        var newExtsMinScore = Math.max(RemoteSearchProvider.NEW_EXTENSIONS_MIN_SCORE, minScore);
                        var passingScoreKeys = resultKeys
                            .filter(function (k) {
                            var result = remoteResult.scoredResults[k];
                            var resultExtId = (result.extensionPublisher + '.' + result.extensionName).toLowerCase();
                            return !installedExtensions.some(function (ext) { return ext.galleryIdentifier.id.toLowerCase() === resultExtId; });
                        })
                            .filter(function (k) { return remoteResult.scoredResults[k].score >= newExtsMinScore; });
                        var filterMatches = passingScoreKeys.map(function (k) {
                            var remoteSetting = remoteResult.scoredResults[k];
                            var setting = remoteSettingToISetting(remoteSetting);
                            return {
                                setting: setting,
                                score: remoteSetting.score,
                                matches: [] // TODO
                            };
                        });
                        return {
                            filterMatches: filterMatches,
                            metadata: remoteResult
                        };
                    });
                }
                else {
                    var settingMatcher = _this.getRemoteSettingMatcher(remoteResult.scoredResults, minScore, preferencesModel);
                    var filterMatches = preferencesModel.filterSettings(_this.options.filter, function (group) { return null; }, settingMatcher);
                    return {
                        filterMatches: filterMatches,
                        metadata: remoteResult
                    };
                }
            });
        };
        RemoteSearchProvider.prototype.getSettingsForFilter = function (filter) {
            return __awaiter(this, void 0, void 0, function () {
                var allRequestDetails, i, details;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            allRequestDetails = [];
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < RemoteSearchProvider.MAX_REQUESTS)) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.prepareRequest(filter, i)];
                        case 2:
                            details = _a.sent();
                            allRequestDetails.push(details);
                            if (!details.hasMoreFilters) {
                                return [3 /*break*/, 4];
                            }
                            _a.label = 3;
                        case 3:
                            i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/, winjs_base_1.TPromise.join(allRequestDetails.map(function (details) { return _this.getSettingsFromBing(details); })).then(function (allResponses) {
                                // Merge all IFilterMetadata
                                var metadata = allResponses[0];
                                metadata.requestCount = 1;
                                for (var _i = 0, _a = allResponses.slice(1); _i < _a.length; _i++) {
                                    var response = _a[_i];
                                    metadata.requestCount++;
                                    metadata.scoredResults = __assign({}, metadata.scoredResults, response.scoredResults);
                                }
                                return metadata;
                            })];
                    }
                });
            });
        };
        RemoteSearchProvider.prototype.getSettingsFromBing = function (details) {
            this.logService.debug("Searching settings via " + details.url);
            if (details.body) {
                this.logService.debug("Body: " + details.body);
            }
            var requestType = details.body ? 'post' : 'get';
            var start = Date.now();
            return this.requestService.request({
                type: requestType,
                url: details.url,
                data: details.body,
                headers: {
                    'User-Agent': 'request',
                    'Content-Type': 'application/json; charset=utf-8',
                    'api-key': this.options.endpoint.key
                },
                timeout: 5000
            }, cancellation_1.CancellationToken.None).then(function (context) {
                if (context.res.statusCode >= 300) {
                    throw new Error(details + " returned status code: " + context.res.statusCode);
                }
                return request_1.asJson(context);
            }).then(function (result) {
                var timestamp = Date.now();
                var duration = timestamp - start;
                var remoteSettings = (result.value || [])
                    .map(function (r) {
                    var _a;
                    var key = JSON.parse(r.setting || r.Setting);
                    var packageId = r['packageid'];
                    var id = getSettingKey(key, packageId);
                    var value = r['value'];
                    var defaultValue = value ? JSON.parse(value) : value;
                    var packageName = r['packagename'];
                    var extensionName;
                    var extensionPublisher;
                    if (packageName && packageName.indexOf('##') >= 0) {
                        _a = packageName.split('##'), extensionPublisher = _a[0], extensionName = _a[1];
                    }
                    return {
                        key: key,
                        id: id,
                        defaultValue: defaultValue,
                        score: r['@search.score'],
                        description: JSON.parse(r['details']),
                        packageId: packageId,
                        extensionName: extensionName,
                        extensionPublisher: extensionPublisher
                    };
                });
                var scoredResults = Object.create(null);
                remoteSettings.forEach(function (s) {
                    scoredResults[s.id] = s;
                });
                return {
                    requestUrl: details.url,
                    requestBody: details.body,
                    duration: duration,
                    timestamp: timestamp,
                    scoredResults: scoredResults,
                    context: result['@odata.context'],
                    extensions: details.extensions
                };
            });
        };
        RemoteSearchProvider.prototype.getRemoteSettingMatcher = function (scoredResults, minScore, preferencesModel) {
            var _this = this;
            return function (setting, group) {
                var remoteSetting = scoredResults[getSettingKey(setting.key, group.id)] || // extension setting
                    scoredResults[getSettingKey(setting.key, 'core')] || // core setting
                    scoredResults[getSettingKey(setting.key)]; // core setting from original prod endpoint
                if (remoteSetting && remoteSetting.score >= minScore) {
                    var settingMatches = new SettingMatches(_this.options.filter, setting, false, true, function (filter, setting) { return preferencesModel.findValueMatches(filter, setting); }).matches;
                    return { matches: settingMatches, score: remoteSetting.score };
                }
                return null;
            };
        };
        RemoteSearchProvider.prototype.prepareRequest = function (query, filterPage) {
            if (filterPage === void 0) { filterPage = 0; }
            return __awaiter(this, void 0, void 0, function () {
                var verbatimQuery, boost, boostedQuery, encodedQuery, url, extensions, filters, filterStr, hasMoreFilters, body;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            verbatimQuery = query;
                            query = escapeSpecialChars(query);
                            boost = 10;
                            boostedQuery = "(" + query + ")^" + boost;
                            // Appending Fuzzy after each word.
                            query = query.replace(/\ +/g, '~ ') + '~';
                            encodedQuery = encodeURIComponent(boostedQuery + ' || ' + query);
                            url = "" + this.options.endpoint.urlBase;
                            if (this.options.endpoint.key) {
                                url += API_VERSION + "&" + QUERY_TYPE;
                            }
                            return [4 /*yield*/, this.installedExtensions];
                        case 1:
                            extensions = _a.sent();
                            filters = this.options.newExtensionsOnly ?
                                ["diminish eq 'latest'"] :
                                this.getVersionFilters(extensions, this.environmentService.settingsSearchBuildId);
                            filterStr = filters
                                .slice(filterPage * RemoteSearchProvider.MAX_REQUEST_FILTERS, (filterPage + 1) * RemoteSearchProvider.MAX_REQUEST_FILTERS)
                                .join(' or ');
                            hasMoreFilters = filters.length > (filterPage + 1) * RemoteSearchProvider.MAX_REQUEST_FILTERS;
                            body = JSON.stringify({
                                query: encodedQuery,
                                filters: encodeURIComponent(filterStr),
                                rawQuery: encodeURIComponent(verbatimQuery)
                            });
                            return [2 /*return*/, {
                                    url: url,
                                    body: body,
                                    hasMoreFilters: hasMoreFilters,
                                    extensions: extensions
                                }];
                    }
                });
            });
        };
        RemoteSearchProvider.prototype.getVersionFilters = function (exts, buildNumber) {
            var _this = this;
            // Only search extensions that contribute settings
            var filters = exts
                .filter(function (ext) { return ext.manifest.contributes && ext.manifest.contributes.configuration; })
                .map(function (ext) { return _this.getExtensionFilter(ext); });
            if (buildNumber) {
                filters.push("(packageid eq 'core' and startbuildno le '" + buildNumber + "' and endbuildno ge '" + buildNumber + "')");
            }
            return filters;
        };
        RemoteSearchProvider.prototype.getExtensionFilter = function (ext) {
            var uuid = ext.identifier.uuid;
            var versionString = ext.manifest.version
                .split('.')
                .map(function (versionPart) { return strings.pad(versionPart, 10); })
                .join('');
            return "(packageid eq '" + uuid + "' and startbuildno le '" + versionString + "' and endbuildno ge '" + versionString + "')";
        };
        // Must keep extension filter size under 8kb. 42 filters puts us there.
        RemoteSearchProvider.MAX_REQUEST_FILTERS = 42;
        RemoteSearchProvider.MAX_REQUESTS = 10;
        RemoteSearchProvider.NEW_EXTENSIONS_MIN_SCORE = 1;
        RemoteSearchProvider = __decorate([
            __param(2, environment_1.IEnvironmentService),
            __param(3, log_1.ILogService)
        ], RemoteSearchProvider);
        return RemoteSearchProvider;
    }());
    function getSettingKey(name, packageId) {
        return packageId ?
            packageId + '##' + name :
            name;
    }
    var API_VERSION = 'api-version=2016-09-01-Preview';
    var QUERY_TYPE = 'querytype=full';
    function escapeSpecialChars(query) {
        return query.replace(/\./g, ' ')
            .replace(/[\\/+\-&|!"~*?:(){}\[\]\^]/g, '\\$&')
            .replace(/  /g, ' ') // collapse spaces
            .trim();
    }
    function remoteSettingToISetting(remoteSetting) {
        return {
            description: remoteSetting.description.split('\n'),
            descriptionIsMarkdown: false,
            descriptionRanges: null,
            key: remoteSetting.key,
            keyRange: null,
            value: remoteSetting.defaultValue,
            range: null,
            valueRange: null,
            overrides: [],
            extensionName: remoteSetting.extensionName,
            extensionPublisher: remoteSetting.extensionPublisher
        };
    }
    var SettingMatches = /** @class */ (function () {
        function SettingMatches(searchString, setting, requireFullQueryMatch, searchDescription, valuesMatcher) {
            this.requireFullQueryMatch = requireFullQueryMatch;
            this.searchDescription = searchDescription;
            this.valuesMatcher = valuesMatcher;
            this.descriptionMatchingWords = new Map();
            this.keyMatchingWords = new Map();
            this.valueMatchingWords = new Map();
            this.matches = arrays_1.distinct(this._findMatchesInSetting(searchString, setting), function (match) { return match.startLineNumber + "_" + match.startColumn + "_" + match.endLineNumber + "_" + match.endColumn + "_"; });
        }
        SettingMatches.prototype._findMatchesInSetting = function (searchString, setting) {
            var result = this._doFindMatchesInSetting(searchString, setting);
            if (setting.overrides && setting.overrides.length) {
                for (var _i = 0, _a = setting.overrides; _i < _a.length; _i++) {
                    var subSetting = _a[_i];
                    var subSettingMatches = new SettingMatches(searchString, subSetting, this.requireFullQueryMatch, this.searchDescription, this.valuesMatcher);
                    var words = searchString.split(' ');
                    var descriptionRanges = this.getRangesForWords(words, this.descriptionMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                    var keyRanges = this.getRangesForWords(words, this.keyMatchingWords, [subSettingMatches.descriptionMatchingWords, subSettingMatches.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                    var subSettingKeyRanges = this.getRangesForWords(words, subSettingMatches.keyMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.valueMatchingWords]);
                    var subSettinValueRanges = this.getRangesForWords(words, subSettingMatches.valueMatchingWords, [this.descriptionMatchingWords, this.keyMatchingWords, subSettingMatches.keyMatchingWords]);
                    result.push.apply(result, descriptionRanges.concat(keyRanges, subSettingKeyRanges, subSettinValueRanges));
                    result.push.apply(result, subSettingMatches.matches);
                }
            }
            return result;
        };
        SettingMatches.prototype._doFindMatchesInSetting = function (searchString, setting) {
            var _this = this;
            var registry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
            var schema = registry[setting.key];
            var words = searchString.split(' ');
            var settingKeyAsWords = setting.key.split('.').join(' ');
            var _loop_1 = function (word) {
                if (this_1.searchDescription) {
                    var _loop_3 = function (lineIndex) {
                        var descriptionMatches = filters_1.matchesWords(word, setting.description[lineIndex], true);
                        if (descriptionMatches) {
                            this_1.descriptionMatchingWords.set(word, descriptionMatches.map(function (match) { return _this.toDescriptionRange(setting, match, lineIndex); }));
                        }
                    };
                    for (var lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                        _loop_3(lineIndex);
                    }
                }
                var keyMatches_1 = filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase)(word, settingKeyAsWords);
                if (keyMatches_1) {
                    this_1.keyMatchingWords.set(word, keyMatches_1.map(function (match) { return _this.toKeyRange(setting, match); }));
                }
                var valueMatches = typeof setting.value === 'string' ? filters_1.matchesContiguousSubString(word, setting.value) : null;
                if (valueMatches) {
                    this_1.valueMatchingWords.set(word, valueMatches.map(function (match) { return _this.toValueRange(setting, match); }));
                }
                else if (schema && schema.enum && schema.enum.some(function (enumValue) { return typeof enumValue === 'string' && !!filters_1.matchesContiguousSubString(word, enumValue); })) {
                    this_1.valueMatchingWords.set(word, []);
                }
            };
            var this_1 = this;
            for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
                var word = words_1[_i];
                _loop_1(word);
            }
            var descriptionRanges = [];
            if (this.searchDescription) {
                var _loop_2 = function (lineIndex) {
                    var matches = filters_1.or(filters_1.matchesContiguousSubString)(searchString, setting.description[lineIndex] || '') || [];
                    descriptionRanges.push.apply(descriptionRanges, matches.map(function (match) { return _this.toDescriptionRange(setting, match, lineIndex); }));
                };
                for (var lineIndex = 0; lineIndex < setting.description.length; lineIndex++) {
                    _loop_2(lineIndex);
                }
                if (descriptionRanges.length === 0) {
                    descriptionRanges.push.apply(descriptionRanges, this.getRangesForWords(words, this.descriptionMatchingWords, [this.keyMatchingWords, this.valueMatchingWords]));
                }
            }
            var keyMatches = filters_1.or(filters_1.matchesPrefix, filters_1.matchesContiguousSubString)(searchString, setting.key);
            var keyRanges = keyMatches ? keyMatches.map(function (match) { return _this.toKeyRange(setting, match); }) : this.getRangesForWords(words, this.keyMatchingWords, [this.descriptionMatchingWords, this.valueMatchingWords]);
            var valueRanges = [];
            if (setting.value && typeof setting.value === 'string') {
                var valueMatches = filters_1.or(filters_1.matchesPrefix, filters_1.matchesContiguousSubString)(searchString, setting.value);
                valueRanges = valueMatches ? valueMatches.map(function (match) { return _this.toValueRange(setting, match); }) : this.getRangesForWords(words, this.valueMatchingWords, [this.keyMatchingWords, this.descriptionMatchingWords]);
            }
            else {
                valueRanges = this.valuesMatcher ? this.valuesMatcher(searchString, setting) : [];
            }
            return descriptionRanges.concat(keyRanges, valueRanges);
        };
        SettingMatches.prototype.getRangesForWords = function (words, from, others) {
            var result = [];
            var _loop_4 = function (word) {
                var ranges = from.get(word);
                if (ranges) {
                    result.push.apply(result, ranges);
                }
                else if (this_2.requireFullQueryMatch && others.every(function (o) { return !o.has(word); })) {
                    return { value: [] };
                }
            };
            var this_2 = this;
            for (var _i = 0, words_2 = words; _i < words_2.length; _i++) {
                var word = words_2[_i];
                var state_1 = _loop_4(word);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return result;
        };
        SettingMatches.prototype.toKeyRange = function (setting, match) {
            if (!setting.keyRange) {
                // No source range? Return fake range, don't care
                return {
                    startLineNumber: 0,
                    startColumn: 0,
                    endLineNumber: 0,
                    endColumn: 0,
                };
            }
            return {
                startLineNumber: setting.keyRange.startLineNumber,
                startColumn: setting.keyRange.startColumn + match.start,
                endLineNumber: setting.keyRange.startLineNumber,
                endColumn: setting.keyRange.startColumn + match.end
            };
        };
        SettingMatches.prototype.toDescriptionRange = function (setting, match, lineIndex) {
            if (!setting.keyRange) {
                // No source range? Return fake range, don't care
                return {
                    startLineNumber: 0,
                    startColumn: 0,
                    endLineNumber: 0,
                    endColumn: 0,
                };
            }
            return {
                startLineNumber: setting.descriptionRanges[lineIndex].startLineNumber,
                startColumn: setting.descriptionRanges[lineIndex].startColumn + match.start,
                endLineNumber: setting.descriptionRanges[lineIndex].endLineNumber,
                endColumn: setting.descriptionRanges[lineIndex].startColumn + match.end
            };
        };
        SettingMatches.prototype.toValueRange = function (setting, match) {
            if (!setting.keyRange) {
                // No source range? Return fake range, don't care
                return {
                    startLineNumber: 0,
                    startColumn: 0,
                    endLineNumber: 0,
                    endColumn: 0,
                };
            }
            return {
                startLineNumber: setting.valueRange.startLineNumber,
                startColumn: setting.valueRange.startColumn + match.start + 1,
                endLineNumber: setting.valueRange.startLineNumber,
                endColumn: setting.valueRange.startColumn + match.end + 1
            };
        };
        return SettingMatches;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[154/*vs/workbench/services/configuration/common/jsonEditing*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IJSONEditingService = instantiation_1.createDecorator('jsonEditingService');
    var JSONEditingError = /** @class */ (function (_super) {
        __extends(JSONEditingError, _super);
        function JSONEditingError(message, code) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            return _this;
        }
        return JSONEditingError;
    }(Error));
    exports.JSONEditingError = JSONEditingError;
});

define(__m[155/*vs/workbench/services/decorations/browser/decorations*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IDecorationsService = instantiation_1.createDecorator('IFileDecorationsService');
});










define(__m[279/*vs/workbench/services/decorations/browser/decorationsService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,39/*vs/base/common/map*/,4/*vs/base/common/lifecycle*/,17/*vs/base/common/async*/,472/*vs/base/common/linkedList*/,8/*vs/base/browser/dom*/,14/*vs/platform/theme/common/themeService*/,163/*vs/base/common/idGenerator*/,22/*vs/base/common/strings*/,2/*vs/nls*/,25/*vs/base/common/errors*/,55/*vs/base/common/cancellation*/]), function (require, exports, event_1, map_1, lifecycle_1, async_1, linkedList_1, dom_1, themeService_1, idGenerator_1, strings_1, nls_1, errors_1, cancellation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DecorationRule = /** @class */ (function () {
        function DecorationRule(data) {
            this.data = data;
            this.itemColorClassName = DecorationRule._classNames.nextId();
            this.itemBadgeClassName = DecorationRule._classNames.nextId();
            this.bubbleBadgeClassName = DecorationRule._classNames.nextId();
        }
        DecorationRule.keyOf = function (data) {
            if (Array.isArray(data)) {
                return data.map(DecorationRule.keyOf).join(',');
            }
            else {
                var color = data.color, letter = data.letter;
                return color + "/" + letter;
            }
        };
        DecorationRule.prototype.appendCSSRules = function (element, theme) {
            if (!Array.isArray(this.data)) {
                this._appendForOne(this.data, element, theme);
            }
            else {
                this._appendForMany(this.data, element, theme);
            }
        };
        DecorationRule.prototype._appendForOne = function (data, element, theme) {
            var color = data.color, letter = data.letter;
            // label
            dom_1.createCSSRule("." + this.itemColorClassName, "color: " + (theme.getColor(color) || 'inherit') + ";", element);
            // letter
            if (letter) {
                dom_1.createCSSRule("." + this.itemBadgeClassName + "::after", "content: \"" + letter + "\"; color: " + (theme.getColor(color) || 'inherit') + ";", element);
            }
        };
        DecorationRule.prototype._appendForMany = function (data, element, theme) {
            // label
            var color = data[0].color;
            dom_1.createCSSRule("." + this.itemColorClassName, "color: " + (theme.getColor(color) || 'inherit') + ";", element);
            // badge
            var letters = data.filter(function (d) { return !strings_1.isFalsyOrWhitespace(d.letter); }).map(function (d) { return d.letter; });
            if (letters.length) {
                dom_1.createCSSRule("." + this.itemBadgeClassName + "::after", "content: \"" + letters.join(', ') + "\"; color: " + (theme.getColor(color) || 'inherit') + ";", element);
            }
            // bubble badge
            dom_1.createCSSRule("." + this.bubbleBadgeClassName + "::after", "content: \"\uF052\"; color: " + (theme.getColor(color) || 'inherit') + "; font-family: octicons; font-size: 14px; padding-right: 14px; opacity: 0.4;", element);
        };
        DecorationRule.prototype.removeCSSRules = function (element) {
            dom_1.removeCSSRulesContainingSelector(this.itemColorClassName, element);
            dom_1.removeCSSRulesContainingSelector(this.itemBadgeClassName, element);
            dom_1.removeCSSRulesContainingSelector(this.bubbleBadgeClassName, element);
        };
        DecorationRule.prototype.isUnused = function () {
            return !document.querySelector("." + this.itemColorClassName)
                && !document.querySelector("." + this.itemBadgeClassName)
                && !document.querySelector("." + this.bubbleBadgeClassName);
        };
        DecorationRule._classNames = new idGenerator_1.IdGenerator('monaco-decorations-style-');
        return DecorationRule;
    }());
    var DecorationStyles = /** @class */ (function () {
        function DecorationStyles(_themeService) {
            this._themeService = _themeService;
            this._styleElement = dom_1.createStyleSheet();
            this._decorationRules = new Map();
            this._disposables = [this._themeService.onThemeChange(this._onThemeChange, this)];
        }
        DecorationStyles.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
            this._styleElement.parentElement.removeChild(this._styleElement);
        };
        DecorationStyles.prototype.asDecoration = function (data, onlyChildren) {
            var _this = this;
            // sort by weight
            data.sort(function (a, b) { return b.weight - a.weight; });
            var key = DecorationRule.keyOf(data);
            var rule = this._decorationRules.get(key);
            if (!rule) {
                // new css rule
                rule = new DecorationRule(data);
                this._decorationRules.set(key, rule);
                rule.appendCSSRules(this._styleElement, this._themeService.getTheme());
            }
            var labelClassName = rule.itemColorClassName;
            var badgeClassName = rule.itemBadgeClassName;
            var tooltip = data.filter(function (d) { return !strings_1.isFalsyOrWhitespace(d.tooltip); }).map(function (d) { return d.tooltip; }).join('  ');
            if (onlyChildren) {
                // show items from its children only
                badgeClassName = rule.bubbleBadgeClassName;
                tooltip = nls_1.localize('bubbleTitle', "Contains emphasized items");
            }
            return {
                labelClassName: labelClassName,
                badgeClassName: badgeClassName,
                tooltip: tooltip,
                update: function (replace) {
                    var newData = data.slice();
                    for (var i = 0; i < newData.length; i++) {
                        if (newData[i].source === replace.source) {
                            // replace
                            newData[i] = replace;
                        }
                    }
                    return _this.asDecoration(newData, onlyChildren);
                }
            };
        };
        DecorationStyles.prototype._onThemeChange = function () {
            var _this = this;
            this._decorationRules.forEach(function (rule) {
                rule.removeCSSRules(_this._styleElement);
                rule.appendCSSRules(_this._styleElement, _this._themeService.getTheme());
            });
        };
        DecorationStyles.prototype.cleanUp = function (iter) {
            var _this = this;
            // remove every rule for which no more
            // decoration (data) is kept. this isn't cheap
            var usedDecorations = new Set();
            for (var e = iter.next(); !e.done; e = iter.next()) {
                e.value.data.forEach(function (value, key) {
                    if (value && !(value instanceof DecorationDataRequest)) {
                        usedDecorations.add(DecorationRule.keyOf(value));
                    }
                });
            }
            this._decorationRules.forEach(function (value, index) {
                var data = value.data;
                if (value.isUnused()) {
                    var remove = void 0;
                    if (Array.isArray(data)) {
                        remove = data.some(function (data) { return !usedDecorations.has(DecorationRule.keyOf(data)); });
                    }
                    else if (!usedDecorations.has(DecorationRule.keyOf(data))) {
                        remove = true;
                    }
                    if (remove) {
                        value.removeCSSRules(_this._styleElement);
                        _this._decorationRules.delete(index);
                    }
                }
            });
        };
        return DecorationStyles;
    }());
    var FileDecorationChangeEvent = /** @class */ (function () {
        function FileDecorationChangeEvent() {
            this._data = map_1.TernarySearchTree.forPaths();
        }
        FileDecorationChangeEvent.prototype.affectsResource = function (uri) {
            return this._data.get(uri.toString()) || this._data.findSuperstr(uri.toString()) !== undefined;
        };
        FileDecorationChangeEvent.debouncer = function (last, current) {
            if (!last) {
                last = new FileDecorationChangeEvent();
            }
            if (Array.isArray(current)) {
                // many
                for (var _i = 0, current_1 = current; _i < current_1.length; _i++) {
                    var uri = current_1[_i];
                    last._data.set(uri.toString(), true);
                }
            }
            else {
                // one
                last._data.set(current.toString(), true);
            }
            return last;
        };
        return FileDecorationChangeEvent;
    }());
    var DecorationDataRequest = /** @class */ (function () {
        function DecorationDataRequest(source, thenable) {
            this.source = source;
            this.thenable = thenable;
        }
        return DecorationDataRequest;
    }());
    var DecorationProviderWrapper = /** @class */ (function () {
        function DecorationProviderWrapper(_provider, _uriEmitter, _flushEmitter) {
            var _this = this;
            this._provider = _provider;
            this._uriEmitter = _uriEmitter;
            this._flushEmitter = _flushEmitter;
            this.data = map_1.TernarySearchTree.forPaths();
            this._dispoable = this._provider.onDidChange(function (uris) {
                if (!uris) {
                    // flush event -> drop all data, can affect everything
                    _this.data.clear();
                    _this._flushEmitter.fire({ affectsResource: function () { return true; } });
                }
                else {
                    // selective changes -> drop for resource, fetch again, send event
                    // perf: the map stores thenables, decorations, or `null`-markers.
                    // we make us of that and ignore all uris in which we have never
                    // been interested.
                    for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {
                        var uri = uris_1[_i];
                        _this._fetchData(uri);
                    }
                }
            });
        }
        DecorationProviderWrapper.prototype.dispose = function () {
            this._dispoable.dispose();
            this.data.clear();
        };
        DecorationProviderWrapper.prototype.knowsAbout = function (uri) {
            return Boolean(this.data.get(uri.toString())) || Boolean(this.data.findSuperstr(uri.toString()));
        };
        DecorationProviderWrapper.prototype.getOrRetrieve = function (uri, includeChildren, callback) {
            var key = uri.toString();
            var item = this.data.get(key);
            if (item === undefined) {
                // unknown -> trigger request
                item = this._fetchData(uri);
            }
            if (item && !(item instanceof DecorationDataRequest)) {
                // found something (which isn't pending anymore)
                callback(item, false);
            }
            if (includeChildren) {
                // (resolved) children
                var iter = this.data.findSuperstr(key);
                if (iter) {
                    for (var item_1 = iter.next(); !item_1.done; item_1 = iter.next()) {
                        if (item_1.value && !(item_1.value instanceof DecorationDataRequest)) {
                            callback(item_1.value, true);
                        }
                    }
                }
            }
        };
        DecorationProviderWrapper.prototype._fetchData = function (uri) {
            var _this = this;
            // check for pending request and cancel it
            var pendingRequest = this.data.get(uri.toString());
            if (pendingRequest instanceof DecorationDataRequest) {
                pendingRequest.source.cancel();
                this.data.delete(uri.toString());
            }
            var source = new cancellation_1.CancellationTokenSource();
            var dataOrThenable = this._provider.provideDecorations(uri, source.token);
            if (!async_1.isThenable(dataOrThenable)) {
                // sync -> we have a result now
                return this._keepItem(uri, dataOrThenable);
            }
            else {
                // async -> we have a result soon
                var request_1 = new DecorationDataRequest(source, Promise.resolve(dataOrThenable).then(function (data) {
                    if (_this.data.get(uri.toString()) === request_1) {
                        _this._keepItem(uri, data);
                    }
                }).catch(function (err) {
                    if (!errors_1.isPromiseCanceledError(err) && _this.data.get(uri.toString()) === request_1) {
                        _this.data.delete(uri.toString());
                    }
                }));
                this.data.set(uri.toString(), request_1);
                return undefined;
            }
        };
        DecorationProviderWrapper.prototype._keepItem = function (uri, data) {
            var deco = data ? data : null;
            var old = this.data.set(uri.toString(), deco);
            if (deco || old) {
                // only fire event when something changed
                this._uriEmitter.fire(uri);
            }
            return deco;
        };
        return DecorationProviderWrapper;
    }());
    var FileDecorationsService = /** @class */ (function () {
        function FileDecorationsService(themeService, cleanUpCount) {
            if (cleanUpCount === void 0) { cleanUpCount = 17; }
            var _this = this;
            this._data = new linkedList_1.LinkedList();
            this._onDidChangeDecorationsDelayed = new event_1.Emitter();
            this._onDidChangeDecorations = new event_1.Emitter();
            this.onDidChangeDecorations = event_1.anyEvent(this._onDidChangeDecorations.event, event_1.debounceEvent(this._onDidChangeDecorationsDelayed.event, FileDecorationChangeEvent.debouncer));
            this._decorationStyles = new DecorationStyles(themeService);
            // every so many events we check if there are
            // css styles that we don't need anymore
            var count = 0;
            var reg = this.onDidChangeDecorations(function () {
                if (++count % cleanUpCount === 0) {
                    _this._decorationStyles.cleanUp(_this._data.iterator());
                }
            });
            this._disposables = [
                reg,
                this._decorationStyles
            ];
        }
        FileDecorationsService.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
            lifecycle_1.dispose(this._onDidChangeDecorations);
            lifecycle_1.dispose(this._onDidChangeDecorationsDelayed);
        };
        FileDecorationsService.prototype.registerDecorationsProvider = function (provider) {
            var _this = this;
            var wrapper = new DecorationProviderWrapper(provider, this._onDidChangeDecorationsDelayed, this._onDidChangeDecorations);
            var remove = this._data.push(wrapper);
            this._onDidChangeDecorations.fire({
                // everything might have changed
                affectsResource: function () { return true; }
            });
            return lifecycle_1.toDisposable(function () {
                // fire event that says 'yes' for any resource
                // known to this provider. then dispose and remove it.
                remove();
                _this._onDidChangeDecorations.fire({ affectsResource: function (uri) { return wrapper.knowsAbout(uri); } });
                wrapper.dispose();
            });
        };
        FileDecorationsService.prototype.getDecoration = function (uri, includeChildren, overwrite) {
            var data = [];
            var containsChildren;
            for (var iter = this._data.iterator(), next = iter.next(); !next.done; next = iter.next()) {
                next.value.getOrRetrieve(uri, includeChildren, function (deco, isChild) {
                    if (!isChild || deco.bubble) {
                        data.push(deco);
                        containsChildren = isChild || containsChildren;
                    }
                });
            }
            if (data.length === 0) {
                // nothing, maybe overwrite data
                if (overwrite) {
                    return this._decorationStyles.asDecoration([overwrite], containsChildren);
                }
                else {
                    return undefined;
                }
            }
            else {
                // result, maybe overwrite
                var result = this._decorationStyles.asDecoration(data, containsChildren);
                if (overwrite) {
                    return result.update(overwrite);
                }
                else {
                    return result;
                }
            }
        };
        FileDecorationsService = __decorate([
            __param(0, themeService_1.IThemeService)
        ], FileDecorationsService);
        return FileDecorationsService;
    }());
    exports.FileDecorationsService = FileDecorationsService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[11/*vs/workbench/services/editor/common/editorService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    exports.ACTIVE_GROUP = -1;
    exports.SIDE_GROUP = -2;
});










define(__m[282/*vs/codesandbox/services/codesandbox/browser/codesandboxEditorConnectorService*/], __M([0/*require*/,1/*exports*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/,11/*vs/workbench/services/editor/common/editorService*/,4/*vs/base/common/lifecycle*/,13/*vs/workbench/common/editor*/]), function (require, exports, codesandbox_1, editorService_1, lifecycle_1, editor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A service that enables to search for files or with in files.
     */
    var CodeSandboxEditorConnectorService = /** @class */ (function () {
        function CodeSandboxEditorConnectorService(_codesandboxService, _editorService) {
            this._codesandboxService = _codesandboxService;
            this._editorService = _editorService;
            this._toDispose = [];
            _editorService.onDidActiveEditorChange(this.updateCurrentFileOpen, this, this._toDispose);
        }
        CodeSandboxEditorConnectorService.prototype.updateCurrentFileOpen = function () {
            var file = editor_1.toResource(this._editorService.activeEditor, {
                supportSideBySide: true,
                filter: 'file',
            });
            var path = (file ? file.fsPath : '').replace(/^\/sandbox/, '');
            if (path) {
                this._codesandboxService.runSignal('editor.moduleSelected', { path: path });
            }
            else {
                this._codesandboxService.runSignal('editor.clearModuleSelected', {});
            }
        };
        CodeSandboxEditorConnectorService.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        CodeSandboxEditorConnectorService = __decorate([
            __param(0, codesandbox_1.ICodeSandboxService),
            __param(1, editorService_1.IEditorService)
        ], CodeSandboxEditorConnectorService);
        return CodeSandboxEditorConnectorService;
    }());
    exports.CodeSandboxEditorConnectorService = CodeSandboxEditorConnectorService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[283/*vs/workbench/browser/parts/editor/rangeDecorations*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,11/*vs/workbench/services/editor/common/editorService*/,284/*vs/editor/common/controller/cursorEvents*/,73/*vs/editor/common/model/textModel*/,72/*vs/editor/common/model*/]), function (require, exports, lifecycle_1, event_1, editorService_1, cursorEvents_1, textModel_1, model_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RangeHighlightDecorations = /** @class */ (function (_super) {
        __extends(RangeHighlightDecorations, _super);
        function RangeHighlightDecorations(editorService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.rangeHighlightDecorationId = null;
            _this.editor = null;
            _this.editorDisposables = [];
            _this._onHighlightRemoved = _this._register(new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(RangeHighlightDecorations.prototype, "onHighlghtRemoved", {
            get: function () { return this._onHighlightRemoved.event; },
            enumerable: true,
            configurable: true
        });
        RangeHighlightDecorations.prototype.removeHighlightRange = function () {
            if (this.editor && this.editor.getModel() && this.rangeHighlightDecorationId) {
                this.editor.deltaDecorations([this.rangeHighlightDecorationId], []);
                this._onHighlightRemoved.fire();
            }
            this.rangeHighlightDecorationId = null;
        };
        RangeHighlightDecorations.prototype.highlightRange = function (range, editor) {
            editor = editor ? editor : this.getEditor(range);
            if (editor) {
                this.doHighlightRange(editor, range);
            }
        };
        RangeHighlightDecorations.prototype.doHighlightRange = function (editor, selectionRange) {
            var _this = this;
            this.removeHighlightRange();
            editor.changeDecorations(function (changeAccessor) {
                _this.rangeHighlightDecorationId = changeAccessor.addDecoration(selectionRange.range, _this.createRangeHighlightDecoration(selectionRange.isWholeLine));
            });
            this.setEditor(editor);
        };
        RangeHighlightDecorations.prototype.getEditor = function (resourceRange) {
            var activeEditor = this.editorService.activeEditor;
            var resource = activeEditor && activeEditor.getResource();
            if (resource) {
                if (resource.toString() === resourceRange.resource.toString()) {
                    return this.editorService.activeTextEditorWidget;
                }
            }
            return null;
        };
        RangeHighlightDecorations.prototype.setEditor = function (editor) {
            var _this = this;
            if (this.editor !== editor) {
                this.disposeEditorListeners();
                this.editor = editor;
                this.editorDisposables.push(this.editor.onDidChangeCursorPosition(function (e) {
                    if (e.reason === cursorEvents_1.CursorChangeReason.NotSet
                        || e.reason === cursorEvents_1.CursorChangeReason.Explicit
                        || e.reason === cursorEvents_1.CursorChangeReason.Undo
                        || e.reason === cursorEvents_1.CursorChangeReason.Redo) {
                        _this.removeHighlightRange();
                    }
                }));
                this.editorDisposables.push(this.editor.onDidChangeModel(function () { _this.removeHighlightRange(); }));
                this.editorDisposables.push(this.editor.onDidDispose(function () {
                    _this.removeHighlightRange();
                    _this.editor = null;
                }));
            }
        };
        RangeHighlightDecorations.prototype.disposeEditorListeners = function () {
            this.editorDisposables.forEach(function (disposable) { return disposable.dispose(); });
            this.editorDisposables = [];
        };
        RangeHighlightDecorations.prototype.createRangeHighlightDecoration = function (isWholeLine) {
            if (isWholeLine === void 0) { isWholeLine = true; }
            return (isWholeLine ? RangeHighlightDecorations._WHOLE_LINE_RANGE_HIGHLIGHT : RangeHighlightDecorations._RANGE_HIGHLIGHT);
        };
        RangeHighlightDecorations.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.editor && this.editor.getModel()) {
                this.removeHighlightRange();
                this.disposeEditorListeners();
                this.editor = null;
            }
        };
        RangeHighlightDecorations._WHOLE_LINE_RANGE_HIGHLIGHT = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'rangeHighlight',
            isWholeLine: true
        });
        RangeHighlightDecorations._RANGE_HIGHLIGHT = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'rangeHighlight'
        });
        RangeHighlightDecorations = __decorate([
            __param(0, editorService_1.IEditorService)
        ], RangeHighlightDecorations);
        return RangeHighlightDecorations;
    }(lifecycle_1.Disposable));
    exports.RangeHighlightDecorations = RangeHighlightDecorations;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[285/*vs/workbench/browser/parts/editor/resourceViewer*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,131/*vs/base/common/mime*/,8/*vs/base/browser/dom*/,39/*vs/base/common/map*/,26/*vs/base/common/network*/,344/*vs/base/common/numbers*/,58/*vs/workbench/common/theme*/,191/*vs/workbench/browser/parts/statusbar/statusbar*/,34/*vs/platform/contextview/browser/contextView*/,4/*vs/base/common/lifecycle*/,14/*vs/platform/theme/common/themeService*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,11/*vs/workbench/services/editor/common/editorService*/,146/*vs/base/common/decorators*/,18/*vs/base/common/platform*/,242/*vs/css!vs/workbench/browser/parts/editor/media/resourceviewer*/]), function (require, exports, nls, mimes, DOM, map_1, network_1, numbers_1, theme_1, statusbar_1, contextView_1, lifecycle_1, themeService_1, platform_1, actions_1, editorService_1, decorators_1, platform) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BinarySize = /** @class */ (function () {
        function BinarySize() {
        }
        BinarySize.formatSize = function (size) {
            if (size < BinarySize.KB) {
                return nls.localize('sizeB', "{0}B", size);
            }
            if (size < BinarySize.MB) {
                return nls.localize('sizeKB', "{0}KB", (size / BinarySize.KB).toFixed(2));
            }
            if (size < BinarySize.GB) {
                return nls.localize('sizeMB', "{0}MB", (size / BinarySize.MB).toFixed(2));
            }
            if (size < BinarySize.TB) {
                return nls.localize('sizeGB', "{0}GB", (size / BinarySize.GB).toFixed(2));
            }
            return nls.localize('sizeTB', "{0}TB", (size / BinarySize.TB).toFixed(2));
        };
        BinarySize.KB = 1024;
        BinarySize.MB = BinarySize.KB * BinarySize.KB;
        BinarySize.GB = BinarySize.MB * BinarySize.KB;
        BinarySize.TB = BinarySize.GB * BinarySize.KB;
        return BinarySize;
    }());
    /**
     * Helper to actually render the given resource into the provided container. Will adjust scrollbar (if provided) automatically based on loading
     * progress of the binary resource.
     */
    var ResourceViewer = /** @class */ (function () {
        function ResourceViewer() {
        }
        ResourceViewer.show = function (descriptor, fileService, container, scrollbar, openInternalClb, openExternalClb, metadataClb) {
            // Ensure CSS class
            container.className = 'monaco-resource-viewer';
            // Images
            if (ResourceViewer.isImageResource(descriptor)) {
                return ImageView.create(container, descriptor, fileService, scrollbar, openExternalClb, metadataClb);
            }
            // Large Files
            if (descriptor.size > ResourceViewer.MAX_OPEN_INTERNAL_SIZE) {
                return FileTooLargeFileView.create(container, descriptor, scrollbar, metadataClb);
            }
            // Seemingly Binary Files
            else {
                return FileSeemsBinaryFileView.create(container, descriptor, scrollbar, openInternalClb, metadataClb);
            }
        };
        ResourceViewer.isImageResource = function (descriptor) {
            var mime = getMime(descriptor);
            // Chrome does not support tiffs
            return mime.indexOf('image/') >= 0 && mime !== 'image/tiff';
        };
        ResourceViewer.MAX_OPEN_INTERNAL_SIZE = BinarySize.MB * 200; // max size until we offer an action to open internally
        return ResourceViewer;
    }());
    exports.ResourceViewer = ResourceViewer;
    var ImageView = /** @class */ (function () {
        function ImageView() {
        }
        ImageView.create = function (container, descriptor, fileService, scrollbar, openExternalClb, metadataClb) {
            if (ImageView.shouldShowImageInline(descriptor)) {
                return InlineImageView.create(container, descriptor, fileService, scrollbar, metadataClb);
            }
            return LargeImageView.create(container, descriptor, openExternalClb);
        };
        ImageView.shouldShowImageInline = function (descriptor) {
            var skipInlineImage;
            // Data URI
            if (descriptor.resource.scheme === network_1.Schemas.data) {
                var base64MarkerIndex = descriptor.resource.path.indexOf(ImageView.BASE64_MARKER);
                var hasData = base64MarkerIndex >= 0 && descriptor.resource.path.substring(base64MarkerIndex + ImageView.BASE64_MARKER.length).length > 0;
                skipInlineImage = !hasData || descriptor.size > ImageView.MAX_IMAGE_SIZE || descriptor.resource.path.length > ImageView.MAX_IMAGE_SIZE;
            }
            // File URI
            else {
                skipInlineImage = typeof descriptor.size !== 'number' || descriptor.size > ImageView.MAX_IMAGE_SIZE;
            }
            return !skipInlineImage;
        };
        ImageView.MAX_IMAGE_SIZE = BinarySize.MB; // showing images inline is memory intense, so we have a limit
        ImageView.BASE64_MARKER = 'base64,';
        return ImageView;
    }());
    var LargeImageView = /** @class */ (function () {
        function LargeImageView() {
        }
        LargeImageView.create = function (container, descriptor, openExternalClb) {
            DOM.clearNode(container);
            var disposables = [];
            var label = document.createElement('p');
            label.textContent = nls.localize('largeImageError', "The image is not displayed in the editor because it is too large ({0}).", BinarySize.formatSize(descriptor.size));
            container.appendChild(label);
            if (descriptor.resource.scheme !== network_1.Schemas.data) {
                var link = DOM.append(label, DOM.$('a.embedded-link'));
                link.setAttribute('role', 'button');
                link.textContent = nls.localize('resourceOpenExternalButton', "Open image using external program?");
                disposables.push(DOM.addDisposableListener(link, DOM.EventType.CLICK, function () { return openExternalClb(descriptor.resource); }));
            }
            return lifecycle_1.combinedDisposable(disposables);
        };
        return LargeImageView;
    }());
    var FileTooLargeFileView = /** @class */ (function () {
        function FileTooLargeFileView() {
        }
        FileTooLargeFileView.create = function (container, descriptor, scrollbar, metadataClb) {
            DOM.clearNode(container);
            var size = BinarySize.formatSize(descriptor.size);
            var label = document.createElement('span');
            label.textContent = nls.localize('nativeFileTooLargeError', "The file is not displayed in the editor because it is too large ({0}).", size);
            container.appendChild(label);
            if (metadataClb) {
                metadataClb(size);
            }
            scrollbar.scanDomNode();
            return lifecycle_1.Disposable.None;
        };
        return FileTooLargeFileView;
    }());
    var FileSeemsBinaryFileView = /** @class */ (function () {
        function FileSeemsBinaryFileView() {
        }
        FileSeemsBinaryFileView.create = function (container, descriptor, scrollbar, openInternalClb, metadataClb) {
            DOM.clearNode(container);
            var disposables = [];
            var label = document.createElement('p');
            label.textContent = nls.localize('nativeBinaryError', "The file is not displayed in the editor because it is either binary or uses an unsupported text encoding.");
            container.appendChild(label);
            if (descriptor.resource.scheme !== network_1.Schemas.data) {
                var link = DOM.append(label, DOM.$('a.embedded-link'));
                link.setAttribute('role', 'button');
                link.textContent = nls.localize('openAsText', "Do you want to open it anyway?");
                disposables.push(DOM.addDisposableListener(link, DOM.EventType.CLICK, function () { return openInternalClb(descriptor.resource); }));
            }
            if (metadataClb) {
                metadataClb(BinarySize.formatSize(descriptor.size));
            }
            scrollbar.scanDomNode();
            return lifecycle_1.combinedDisposable(disposables);
        };
        return FileSeemsBinaryFileView;
    }());
    var ZoomStatusbarItem = /** @class */ (function (_super) {
        __extends(ZoomStatusbarItem, _super);
        function ZoomStatusbarItem(contextMenuService, editorService, themeService) {
            var _this = _super.call(this, themeService) || this;
            _this.contextMenuService = contextMenuService;
            ZoomStatusbarItem.instance = _this;
            _this._register(editorService.onDidActiveEditorChange(function () { return _this.onActiveEditorChanged(); }));
            return _this;
        }
        ZoomStatusbarItem.prototype.onActiveEditorChanged = function () {
            this.hide();
            this.onSelectScale = void 0;
        };
        ZoomStatusbarItem.prototype.show = function (scale, onSelectScale) {
            var _this = this;
            clearTimeout(this.showTimeout);
            this.showTimeout = setTimeout(function () {
                _this.onSelectScale = onSelectScale;
                _this.statusBarItem.style.display = 'block';
                _this.updateLabel(scale);
            }, 0);
        };
        ZoomStatusbarItem.prototype.hide = function () {
            this.statusBarItem.style.display = 'none';
        };
        ZoomStatusbarItem.prototype.render = function (container) {
            var _this = this;
            if (!this.statusBarItem && container) {
                this.statusBarItem = DOM.append(container, DOM.$('a.zoom-statusbar-item'));
                this.statusBarItem.setAttribute('role', 'button');
                this.statusBarItem.style.display = 'none';
                DOM.addDisposableListener(this.statusBarItem, DOM.EventType.CLICK, function () {
                    _this.contextMenuService.showContextMenu({
                        getAnchor: function () { return container; },
                        getActions: function () { return Promise.resolve(_this.zoomActions); }
                    });
                });
            }
            return this;
        };
        ZoomStatusbarItem.prototype.updateLabel = function (scale) {
            this.statusBarItem.textContent = ZoomStatusbarItem.zoomLabel(scale);
        };
        Object.defineProperty(ZoomStatusbarItem.prototype, "zoomActions", {
            get: function () {
                var _this = this;
                var scales = [10, 5, 2, 1, 0.5, 0.2, 'fit'];
                return scales.map(function (scale) {
                    return new actions_1.Action("zoom." + scale, ZoomStatusbarItem.zoomLabel(scale), void 0, void 0, function () {
                        if (_this.onSelectScale) {
                            _this.onSelectScale(scale);
                        }
                        return void 0;
                    });
                });
            },
            enumerable: true,
            configurable: true
        });
        ZoomStatusbarItem.zoomLabel = function (scale) {
            return scale === 'fit'
                ? nls.localize('zoom.action.fit.label', 'Whole Image')
                : Math.round(scale * 100) + "%";
        };
        __decorate([
            decorators_1.memoize
        ], ZoomStatusbarItem.prototype, "zoomActions", null);
        ZoomStatusbarItem = __decorate([
            __param(0, contextView_1.IContextMenuService),
            __param(1, editorService_1.IEditorService),
            __param(2, themeService_1.IThemeService)
        ], ZoomStatusbarItem);
        return ZoomStatusbarItem;
    }(theme_1.Themable));
    platform_1.Registry.as(statusbar_1.Extensions.Statusbar).registerStatusbarItem(new statusbar_1.StatusbarItemDescriptor(ZoomStatusbarItem, 1 /* RIGHT */, 101 /* to the left of editor status (100) */));
    var InlineImageView = /** @class */ (function () {
        function InlineImageView() {
        }
        InlineImageView.create = function (container, descriptor, fileService, scrollbar, metadataClb) {
            var disposables = [];
            var context = {
                layout: function (dimension) { },
                dispose: function () { return lifecycle_1.combinedDisposable(disposables).dispose(); }
            };
            var cacheKey = descriptor.resource.toString();
            var ctrlPressed = false;
            var altPressed = false;
            var initialState = InlineImageView.imageStateCache.get(cacheKey) || { scale: 'fit', offsetX: 0, offsetY: 0 };
            var scale = initialState.scale;
            var image = null;
            function updateScale(newScale) {
                if (!image || !image.parentElement) {
                    return;
                }
                if (newScale === 'fit') {
                    scale = 'fit';
                    DOM.addClass(image, 'scale-to-fit');
                    DOM.removeClass(image, 'pixelated');
                    image.style.minWidth = 'auto';
                    image.style.width = 'auto';
                    InlineImageView.imageStateCache.set(cacheKey, null);
                }
                else {
                    var oldWidth = image.width;
                    var oldHeight = image.height;
                    scale = numbers_1.clamp(newScale, InlineImageView.MIN_SCALE, InlineImageView.MAX_SCALE);
                    if (scale >= InlineImageView.PIXELATION_THRESHOLD) {
                        DOM.addClass(image, 'pixelated');
                    }
                    else {
                        DOM.removeClass(image, 'pixelated');
                    }
                    var _a = image.parentElement, scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;
                    var dx = (scrollLeft + image.parentElement.clientWidth / 2) / image.parentElement.scrollWidth;
                    var dy = (scrollTop + image.parentElement.clientHeight / 2) / image.parentElement.scrollHeight;
                    DOM.removeClass(image, 'scale-to-fit');
                    image.style.minWidth = (image.naturalWidth * scale) + "px";
                    image.style.widows = (image.naturalWidth * scale) + "px";
                    var newWidth = image.width;
                    var scaleFactor = (newWidth - oldWidth) / oldWidth;
                    var newScrollLeft = ((oldWidth * scaleFactor * dx) + scrollLeft);
                    var newScrollTop = ((oldHeight * scaleFactor * dy) + scrollTop);
                    scrollbar.setScrollPosition({
                        scrollLeft: newScrollLeft,
                        scrollTop: newScrollTop,
                    });
                    InlineImageView.imageStateCache.set(cacheKey, { scale: scale, offsetX: newScrollLeft, offsetY: newScrollTop });
                }
                ZoomStatusbarItem.instance.show(scale, updateScale);
                scrollbar.scanDomNode();
            }
            function firstZoom() {
                scale = image.clientWidth / image.naturalWidth;
                updateScale(scale);
            }
            disposables.push(DOM.addDisposableListener(container, DOM.EventType.KEY_DOWN, function (e) {
                if (!image) {
                    return;
                }
                ctrlPressed = e.ctrlKey;
                altPressed = e.altKey;
                if (platform.isMacintosh ? altPressed : ctrlPressed) {
                    DOM.removeClass(container, 'zoom-in');
                    DOM.addClass(container, 'zoom-out');
                }
            }));
            disposables.push(DOM.addDisposableListener(container, DOM.EventType.KEY_UP, function (e) {
                if (!image) {
                    return;
                }
                ctrlPressed = e.ctrlKey;
                altPressed = e.altKey;
                if (!(platform.isMacintosh ? altPressed : ctrlPressed)) {
                    DOM.removeClass(container, 'zoom-out');
                    DOM.addClass(container, 'zoom-in');
                }
            }));
            disposables.push(DOM.addDisposableListener(container, DOM.EventType.CLICK, function (e) {
                if (!image) {
                    return;
                }
                if (e.button !== 0) {
                    return;
                }
                // left click
                if (scale === 'fit') {
                    firstZoom();
                }
                if (!(platform.isMacintosh ? altPressed : ctrlPressed)) { // zoom in
                    var i = 0;
                    for (; i < InlineImageView.zoomLevels.length; ++i) {
                        if (InlineImageView.zoomLevels[i] > scale) {
                            break;
                        }
                    }
                    updateScale(InlineImageView.zoomLevels[i] || InlineImageView.MAX_SCALE);
                }
                else {
                    var i = InlineImageView.zoomLevels.length - 1;
                    for (; i >= 0; --i) {
                        if (InlineImageView.zoomLevels[i] < scale) {
                            break;
                        }
                    }
                    updateScale(InlineImageView.zoomLevels[i] || InlineImageView.MIN_SCALE);
                }
            }));
            disposables.push(DOM.addDisposableListener(container, DOM.EventType.WHEEL, function (e) {
                if (!image) {
                    return;
                }
                var isScrollWhellKeyPressed = platform.isMacintosh ? altPressed : ctrlPressed;
                if (!isScrollWhellKeyPressed && !e.ctrlKey) { // pinching is reported as scroll wheel + ctrl
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                if (scale === 'fit') {
                    firstZoom();
                }
                var delta = e.deltaY < 0 ? 1 : -1;
                // Pinching should increase the scale
                if (e.ctrlKey && !isScrollWhellKeyPressed) {
                    delta *= -1;
                }
                updateScale(scale * (1 - delta * InlineImageView.SCALE_PINCH_FACTOR));
            }));
            disposables.push(DOM.addDisposableListener(container, DOM.EventType.SCROLL, function () {
                if (!image || !image.parentElement || scale === 'fit') {
                    return;
                }
                var entry = InlineImageView.imageStateCache.get(cacheKey);
                if (entry) {
                    var _a = image.parentElement, scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;
                    InlineImageView.imageStateCache.set(cacheKey, { scale: entry.scale, offsetX: scrollLeft, offsetY: scrollTop });
                }
            }));
            DOM.clearNode(container);
            DOM.addClasses(container, 'image', 'zoom-in');
            image = DOM.append(container, DOM.$('img.scale-to-fit'));
            image.style.visibility = 'hidden';
            disposables.push(DOM.addDisposableListener(image, DOM.EventType.LOAD, function (e) {
                metadataClb(nls.localize('imgMeta', '{0}x{1} {2}', image.naturalWidth, image.naturalHeight, BinarySize.formatSize(descriptor.size)));
                scrollbar.scanDomNode();
                image.style.visibility = 'visible';
                updateScale(scale);
                if (initialState.scale !== 'fit') {
                    scrollbar.setScrollPosition({
                        scrollLeft: initialState.offsetX,
                        scrollTop: initialState.offsetY,
                    });
                }
            }));
            InlineImageView.imageSrc(descriptor, fileService).then(function (dataUri) {
                var imgs = container.getElementsByTagName('img');
                if (imgs.length) {
                    imgs[0].src = dataUri;
                }
            });
            return context;
        };
        InlineImageView.imageSrc = function (descriptor, fileService) {
            if (descriptor.resource.scheme === network_1.Schemas.data) {
                return Promise.resolve(descriptor.resource.toString(true /* skip encoding */));
            }
            return fileService.resolveContent(descriptor.resource, { encoding: 'base64' }).then(function (data) {
                var mime = getMime(descriptor);
                return "data:" + mime + ";base64," + data.value;
            });
        };
        InlineImageView.SCALE_PINCH_FACTOR = 0.075;
        InlineImageView.MAX_SCALE = 20;
        InlineImageView.MIN_SCALE = 0.1;
        InlineImageView.zoomLevels = [
            0.1,
            0.2,
            0.3,
            0.4,
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.5,
            2,
            3,
            5,
            7,
            10,
            15,
            20
        ];
        /**
         * Enable image-rendering: pixelated for images scaled by more than this.
         */
        InlineImageView.PIXELATION_THRESHOLD = 3;
        /**
         * Store the scale and position of an image so it can be restored when changing editor tabs
         */
        InlineImageView.imageStateCache = new map_1.LRUCache(100);
        return InlineImageView;
    }());
    function getMime(descriptor) {
        var mime = descriptor.mime;
        if (!mime && descriptor.resource.scheme !== network_1.Schemas.data) {
            mime = mimes.getMediaMime(descriptor.resource.path);
        }
        return mime || mimes.MIME_BINARY;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[157/*vs/workbench/browser/parts/editor/binaryEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,6/*vs/base/common/event*/,5/*vs/base/common/winjs.base*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,127/*vs/workbench/common/editor/binaryEditorModel*/,223/*vs/base/browser/ui/scrollbar/scrollableElement*/,134/*vs/base/common/scrollable*/,285/*vs/workbench/browser/parts/editor/resourceViewer*/,8/*vs/base/browser/dom*/,16/*vs/platform/files/common/files*/,4/*vs/base/common/lifecycle*/]), function (require, exports, nls, event_1, winjs_base_1, baseEditor_1, binaryEditorModel_1, scrollableElement_1, scrollable_1, resourceViewer_1, dom_1, files_1, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
     * This class is only intended to be subclassed and not instantiated.
     */
    var BaseBinaryResourceEditor = /** @class */ (function (_super) {
        __extends(BaseBinaryResourceEditor, _super);
        function BaseBinaryResourceEditor(id, callbacks, telemetryService, themeService, _fileService) {
            var _this = _super.call(this, id, telemetryService, themeService) || this;
            _this._fileService = _fileService;
            _this._onMetadataChanged = _this._register(new event_1.Emitter());
            _this.callbacks = callbacks;
            return _this;
        }
        Object.defineProperty(BaseBinaryResourceEditor.prototype, "onMetadataChanged", {
            get: function () { return this._onMetadataChanged.event; },
            enumerable: true,
            configurable: true
        });
        BaseBinaryResourceEditor.prototype.getTitle = function () {
            return this.input ? this.input.getName() : nls.localize('binaryEditor', "Binary Viewer");
        };
        BaseBinaryResourceEditor.prototype.createEditor = function (parent) {
            // Container for Binary
            this.binaryContainer = document.createElement('div');
            this.binaryContainer.className = 'binary-container';
            this.binaryContainer.style.outline = 'none';
            this.binaryContainer.tabIndex = 0; // enable focus support from the editor part (do not remove)
            // Custom Scrollbars
            this.scrollbar = this._register(new scrollableElement_1.DomScrollableElement(this.binaryContainer, { horizontal: scrollable_1.ScrollbarVisibility.Auto, vertical: scrollable_1.ScrollbarVisibility.Auto }));
            parent.appendChild(this.scrollbar.getDomNode());
        };
        BaseBinaryResourceEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            return _super.prototype.setInput.call(this, input, options, token).then(function () {
                return input.resolve().then(function (model) {
                    // Check for cancellation
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    // Assert Model instance
                    if (!(model instanceof binaryEditorModel_1.BinaryEditorModel)) {
                        return winjs_base_1.TPromise.wrapError(new Error('Unable to open file as binary'));
                    }
                    // Render Input
                    _this.resourceViewerContext = resourceViewer_1.ResourceViewer.show({ name: model.getName(), resource: model.getResource(), size: model.getSize(), etag: model.getETag(), mime: model.getMime() }, _this._fileService, _this.binaryContainer, _this.scrollbar, function (resource) { return _this.callbacks.openInternal(input, options); }, function (resource) { return _this.callbacks.openExternal(resource); }, function (meta) { return _this.handleMetadataChanged(meta); });
                    return void 0;
                });
            });
        };
        BaseBinaryResourceEditor.prototype.handleMetadataChanged = function (meta) {
            this.metadata = meta;
            this._onMetadataChanged.fire();
        };
        BaseBinaryResourceEditor.prototype.getMetadata = function () {
            return this.metadata;
        };
        BaseBinaryResourceEditor.prototype.clearInput = function () {
            // Clear Meta
            this.handleMetadataChanged(null);
            // Clear Resource Viewer
            dom_1.clearNode(this.binaryContainer);
            this.resourceViewerContext = lifecycle_1.dispose(this.resourceViewerContext);
            _super.prototype.clearInput.call(this);
        };
        BaseBinaryResourceEditor.prototype.layout = function (dimension) {
            // Pass on to Binary Container
            dom_1.size(this.binaryContainer, dimension.width, dimension.height);
            this.scrollbar.scanDomNode();
            if (this.resourceViewerContext && this.resourceViewerContext.layout) {
                this.resourceViewerContext.layout(dimension);
            }
        };
        BaseBinaryResourceEditor.prototype.focus = function () {
            this.binaryContainer.focus();
        };
        BaseBinaryResourceEditor.prototype.dispose = function () {
            this.binaryContainer.remove();
            this.resourceViewerContext = lifecycle_1.dispose(this.resourceViewerContext);
            _super.prototype.dispose.call(this);
        };
        BaseBinaryResourceEditor = __decorate([
            __param(4, files_1.IFileService)
        ], BaseBinaryResourceEditor);
        return BaseBinaryResourceEditor;
    }(baseEditor_1.BaseEditor));
    exports.BaseBinaryResourceEditor = BaseBinaryResourceEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[174/*vs/workbench/browser/parts/editor/binaryDiffEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,13/*vs/workbench/common/editor*/,32/*vs/platform/telemetry/common/telemetry*/,14/*vs/platform/theme/common/themeService*/,158/*vs/workbench/browser/parts/editor/sideBySideEditor*/,3/*vs/platform/instantiation/common/instantiation*/,157/*vs/workbench/browser/parts/editor/binaryEditor*/]), function (require, exports, nls, editor_1, telemetry_1, themeService_1, sideBySideEditor_1, instantiation_1, binaryEditor_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An implementation of editor for diffing binary files like images or videos.
     */
    var BinaryResourceDiffEditor = /** @class */ (function (_super) {
        __extends(BinaryResourceDiffEditor, _super);
        function BinaryResourceDiffEditor(telemetryService, instantiationService, themeService) {
            return _super.call(this, telemetryService, instantiationService, themeService) || this;
        }
        BinaryResourceDiffEditor.prototype.getMetadata = function () {
            var master = this.masterEditor;
            var details = this.detailsEditor;
            if (master instanceof binaryEditor_1.BaseBinaryResourceEditor && details instanceof binaryEditor_1.BaseBinaryResourceEditor) {
                return nls.localize('metadataDiff', "{0}  {1}", details.getMetadata(), master.getMetadata());
            }
            return null;
        };
        BinaryResourceDiffEditor.ID = editor_1.BINARY_DIFF_EDITOR_ID;
        BinaryResourceDiffEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, themeService_1.IThemeService)
        ], BinaryResourceDiffEditor);
        return BinaryResourceDiffEditor;
    }(sideBySideEditor_1.SideBySideEditor));
    exports.BinaryResourceDiffEditor = BinaryResourceDiffEditor;
});























define(__m[53/*vs/workbench/browser/quickopen*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,38/*vs/base/common/objects*/,19/*vs/base/common/arrays*/,22/*vs/base/common/strings*/,29/*vs/base/common/types*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,13/*vs/workbench/common/editor*/,46/*vs/platform/quickOpen/common/quickOpen*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, nls, objects, arrays, strings, types, platform_1, actions_1, quickOpenModel_1, editor_1, quickOpen_1, editorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CLOSE_ON_FOCUS_LOST_CONFIG = 'workbench.quickOpen.closeOnFocusLost';
    exports.PREFILL_CONFIG = 'workbench.quickOpen.prefill';
    exports.SEARCH_EDITOR_HISTORY = 'search.quickOpen.includeHistory';
    var QuickOpenHandler = /** @class */ (function () {
        function QuickOpenHandler() {
        }
        /**
         * A quick open handler returns results for a given input string. The resolved promise
         * returns an instance of quick open model. It is up to the handler to keep and reuse an
         * instance of the same model across multiple calls. This helps in situations where the user is
         * narrowing down a search and the model is just filtering some items out.
         *
         * As such, returning the same model instance across multiple searches will yield best
         * results in terms of performance when many items are shown.
         */
        QuickOpenHandler.prototype.getResults = function (searchValue, token) {
            return Promise.resolve(null);
        };
        /**
         * The ARIA label to apply when this quick open handler is active in quick open.
         */
        QuickOpenHandler.prototype.getAriaLabel = function () {
            return null;
        };
        /**
         * Extra CSS class name to add to the quick open widget to do custom styling of entries.
         */
        QuickOpenHandler.prototype.getClass = function () {
            return null;
        };
        /**
         * Indicates if the handler can run in the current environment. Return a string if the handler cannot run but has
         * a good message to show in this case.
         */
        QuickOpenHandler.prototype.canRun = function () {
            return true;
        };
        /**
         * Hints to the outside that this quick open handler typically returns results fast.
         */
        QuickOpenHandler.prototype.hasShortResponseTime = function () {
            return false;
        };
        /**
         * Indicates if the handler wishes the quick open widget to automatically select the first result entry or an entry
         * based on a specific prefix match.
         */
        QuickOpenHandler.prototype.getAutoFocus = function (searchValue, context) {
            return {};
        };
        /**
         * Indicates to the handler that the quick open widget has been opened.
         */
        QuickOpenHandler.prototype.onOpen = function () {
            return;
        };
        /**
         * Indicates to the handler that the quick open widget has been closed. Allows to free up any resources as needed.
         * The parameter canceled indicates if the quick open widget was closed with an entry being run or not.
         */
        QuickOpenHandler.prototype.onClose = function (canceled) {
            return;
        };
        /**
         * Allows to return a label that will be placed to the side of the results from this handler or null if none.
         */
        QuickOpenHandler.prototype.getGroupLabel = function () {
            return null;
        };
        /**
         * Allows to return a label that will be used when there are no results found
         */
        QuickOpenHandler.prototype.getEmptyLabel = function (searchString) {
            if (searchString.length > 0) {
                return nls.localize('noResultsMatching', "No results matching");
            }
            return nls.localize('noResultsFound2', "No results found");
        };
        return QuickOpenHandler;
    }());
    exports.QuickOpenHandler = QuickOpenHandler;
    /**
     * A lightweight descriptor of a quick open handler.
     */
    var QuickOpenHandlerDescriptor = /** @class */ (function () {
        function QuickOpenHandlerDescriptor(ctor, id, prefix, contextKey, param, instantProgress) {
            if (instantProgress === void 0) { instantProgress = false; }
            this.ctor = ctor;
            this.id = id;
            this.prefix = prefix;
            this.contextKey = contextKey;
            this.instantProgress = instantProgress;
            if (types.isString(param)) {
                this.description = param;
            }
            else {
                this.helpEntries = param;
            }
        }
        QuickOpenHandlerDescriptor.prototype.getId = function () {
            return this.id;
        };
        QuickOpenHandlerDescriptor.prototype.instantiate = function (instantiationService) {
            return instantiationService.createInstance(this.ctor);
        };
        return QuickOpenHandlerDescriptor;
    }());
    exports.QuickOpenHandlerDescriptor = QuickOpenHandlerDescriptor;
    exports.Extensions = {
        Quickopen: 'workbench.contributions.quickopen'
    };
    var QuickOpenRegistry = /** @class */ (function () {
        function QuickOpenRegistry() {
            this.handlers = [];
        }
        QuickOpenRegistry.prototype.registerQuickOpenHandler = function (descriptor) {
            this.handlers.push(descriptor);
            // sort the handlers by decreasing prefix length, such that longer
            // prefixes take priority: 'ext' vs 'ext install' - the latter should win
            this.handlers.sort(function (h1, h2) { return h2.prefix.length - h1.prefix.length; });
        };
        QuickOpenRegistry.prototype.registerDefaultQuickOpenHandler = function (descriptor) {
            this.defaultHandler = descriptor;
        };
        QuickOpenRegistry.prototype.getQuickOpenHandlers = function () {
            return this.handlers.slice(0);
        };
        QuickOpenRegistry.prototype.getQuickOpenHandler = function (text) {
            return text ? arrays.first(this.handlers, function (h) { return strings.startsWith(text, h.prefix); }, null) : null;
        };
        QuickOpenRegistry.prototype.getDefaultQuickOpenHandler = function () {
            return this.defaultHandler;
        };
        return QuickOpenRegistry;
    }());
    platform_1.Registry.add(exports.Extensions.Quickopen, new QuickOpenRegistry());
    /**
     * A subclass of quick open entry that will open an editor with input and options when running.
     */
    var EditorQuickOpenEntry = /** @class */ (function (_super) {
        __extends(EditorQuickOpenEntry, _super);
        function EditorQuickOpenEntry(_editorService) {
            var _this = _super.call(this) || this;
            _this._editorService = _editorService;
            return _this;
        }
        Object.defineProperty(EditorQuickOpenEntry.prototype, "editorService", {
            get: function () {
                return this._editorService;
            },
            enumerable: true,
            configurable: true
        });
        EditorQuickOpenEntry.prototype.getInput = function () {
            return null;
        };
        EditorQuickOpenEntry.prototype.getOptions = function () {
            return null;
        };
        EditorQuickOpenEntry.prototype.run = function (mode, context) {
            var hideWidget = (mode === 1 /* OPEN */);
            if (mode === 1 /* OPEN */ || mode === 2 /* OPEN_IN_BACKGROUND */) {
                var sideBySide = context.keymods.ctrlCmd;
                var openOptions = void 0;
                if (mode === 2 /* OPEN_IN_BACKGROUND */) {
                    openOptions = { pinned: true, preserveFocus: true };
                }
                else if (context.keymods.alt) {
                    openOptions = { pinned: true };
                }
                var input = this.getInput();
                if (input instanceof editor_1.EditorInput) {
                    var opts = this.getOptions();
                    if (opts) {
                        opts = objects.mixin(opts, openOptions, true);
                    }
                    else if (openOptions) {
                        opts = editor_1.EditorOptions.create(openOptions);
                    }
                    this.editorService.openEditor(input, opts, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);
                }
                else {
                    var resourceInput = input;
                    if (openOptions) {
                        resourceInput.options = objects.assign(resourceInput.options || Object.create(null), openOptions);
                    }
                    this.editorService.openEditor(resourceInput, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);
                }
            }
            return hideWidget;
        };
        return EditorQuickOpenEntry;
    }(quickOpenModel_1.QuickOpenEntry));
    exports.EditorQuickOpenEntry = EditorQuickOpenEntry;
    /**
     * A subclass of quick open entry group that provides access to editor input and options.
     */
    var EditorQuickOpenEntryGroup = /** @class */ (function (_super) {
        __extends(EditorQuickOpenEntryGroup, _super);
        function EditorQuickOpenEntryGroup() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EditorQuickOpenEntryGroup.prototype.getInput = function () {
            return null;
        };
        EditorQuickOpenEntryGroup.prototype.getOptions = function () {
            return null;
        };
        return EditorQuickOpenEntryGroup;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.EditorQuickOpenEntryGroup = EditorQuickOpenEntryGroup;
    var QuickOpenAction = /** @class */ (function (_super) {
        __extends(QuickOpenAction, _super);
        function QuickOpenAction(id, label, prefix, quickOpenService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.prefix = prefix;
            _this.enabled = !!_this.quickOpenService;
            return _this;
        }
        QuickOpenAction.prototype.run = function (context) {
            // Show with prefix
            this.quickOpenService.show(this.prefix);
            return Promise.resolve(null);
        };
        QuickOpenAction = __decorate([
            __param(3, quickOpen_1.IQuickOpenService)
        ], QuickOpenAction);
        return QuickOpenAction;
    }(actions_1.Action));
    exports.QuickOpenAction = QuickOpenAction;
});























define(__m[291/*vs/workbench/parts/quickopen/browser/gotoLineHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,29/*vs/base/common/types*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,72/*vs/editor/common/model*/,46/*vs/platform/quickOpen/common/quickOpen*/,177/*vs/editor/common/view/editorColorRegistry*/,14/*vs/platform/theme/common/themeService*/,11/*vs/workbench/services/editor/common/editorService*/,45/*vs/editor/browser/editorBrowser*/,6/*vs/base/common/event*/]), function (require, exports, winjs_base_1, nls, types, quickOpenModel_1, quickopen_1, model_1, quickOpen_1, editorColorRegistry_1, themeService_1, editorService_1, editorBrowser_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GOTO_LINE_PREFIX = ':';
    var GotoLineAction = /** @class */ (function (_super) {
        __extends(GotoLineAction, _super);
        function GotoLineAction(actionId, actionLabel, _quickOpenService, editorService) {
            var _this = _super.call(this, actionId, actionLabel, exports.GOTO_LINE_PREFIX, _quickOpenService) || this;
            _this._quickOpenService = _quickOpenService;
            _this.editorService = editorService;
            return _this;
        }
        GotoLineAction.prototype.run = function () {
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (editorBrowser_1.isDiffEditor(activeTextEditorWidget)) {
                activeTextEditorWidget = activeTextEditorWidget.getModifiedEditor();
            }
            var restoreOptions = null;
            if (editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {
                var config = activeTextEditorWidget.getConfiguration();
                if (config.viewInfo.renderLineNumbers === 2 /* Relative */) {
                    activeTextEditorWidget.updateOptions({
                        lineNumbers: 'on'
                    });
                    restoreOptions = {
                        lineNumbers: 'relative'
                    };
                }
            }
            var result = _super.prototype.run.call(this);
            if (restoreOptions) {
                event_1.once(this._quickOpenService.onHide)(function () {
                    activeTextEditorWidget.updateOptions(restoreOptions);
                });
            }
            return result;
        };
        GotoLineAction.ID = 'workbench.action.gotoLine';
        GotoLineAction.LABEL = nls.localize('gotoLine', "Go to Line...");
        GotoLineAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, editorService_1.IEditorService)
        ], GotoLineAction);
        return GotoLineAction;
    }(quickopen_1.QuickOpenAction));
    exports.GotoLineAction = GotoLineAction;
    var GotoLineEntry = /** @class */ (function (_super) {
        __extends(GotoLineEntry, _super);
        function GotoLineEntry(line, editorService, handler) {
            var _this = _super.call(this, editorService) || this;
            _this.parseInput(line);
            _this.handler = handler;
            return _this;
        }
        GotoLineEntry.prototype.parseInput = function (line) {
            var numbers = line.split(/,|:|#/).map(function (part) { return parseInt(part, 10); }).filter(function (part) { return !isNaN(part); });
            this.line = numbers[0];
            this.column = numbers[1];
        };
        GotoLineEntry.prototype.getLabel = function () {
            // Inform user about valid range if input is invalid
            var maxLineNumber = this.getMaxLineNumber();
            if (this.invalidRange(maxLineNumber)) {
                if (maxLineNumber > 0) {
                    return nls.localize('gotoLineLabelEmptyWithLimit', "Type a line number between 1 and {0} to navigate to", maxLineNumber);
                }
                return nls.localize('gotoLineLabelEmpty', "Type a line number to navigate to");
            }
            // Input valid, indicate action
            return this.column ? nls.localize('gotoLineColumnLabel', "Go to line {0} and character {1}", this.line, this.column) : nls.localize('gotoLineLabel', "Go to line {0}", this.line);
        };
        GotoLineEntry.prototype.invalidRange = function (maxLineNumber) {
            if (maxLineNumber === void 0) { maxLineNumber = this.getMaxLineNumber(); }
            return !this.line || !types.isNumber(this.line) || (maxLineNumber > 0 && types.isNumber(this.line) && this.line > maxLineNumber);
        };
        GotoLineEntry.prototype.getMaxLineNumber = function () {
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            var model = activeTextEditorWidget.getModel();
            if (model && model.modified && model.original) {
                model = model.modified; // Support for diff editor models
            }
            return model && types.isFunction(model.getLineCount) ? model.getLineCount() : -1;
        };
        GotoLineEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                return this.runOpen(context);
            }
            return this.runPreview();
        };
        GotoLineEntry.prototype.getInput = function () {
            return this.editorService.activeEditor;
        };
        GotoLineEntry.prototype.getOptions = function (pinned) {
            return {
                selection: this.toSelection(),
                pinned: pinned
            };
        };
        GotoLineEntry.prototype.runOpen = function (context) {
            // No-op if range is not valid
            if (this.invalidRange()) {
                return false;
            }
            // Check for sideBySide use
            var sideBySide = context.keymods.ctrlCmd;
            if (sideBySide) {
                this.editorService.openEditor(this.getInput(), this.getOptions(context.keymods.alt), editorService_1.SIDE_GROUP);
            }
            // Apply selection and focus
            var range = this.toSelection();
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (activeTextEditorWidget) {
                activeTextEditorWidget.setSelection(range);
                activeTextEditorWidget.revealRangeInCenter(range, 0 /* Smooth */);
            }
            return true;
        };
        GotoLineEntry.prototype.runPreview = function () {
            // No-op if range is not valid
            if (this.invalidRange()) {
                this.handler.clearDecorations();
                return false;
            }
            // Select Line Position
            var range = this.toSelection();
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (activeTextEditorWidget) {
                activeTextEditorWidget.revealRangeInCenter(range, 0 /* Smooth */);
                // Decorate if possible
                if (types.isFunction(activeTextEditorWidget.changeDecorations)) {
                    this.handler.decorateOutline(range, activeTextEditorWidget, this.editorService.activeControl.group);
                }
            }
            return false;
        };
        GotoLineEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this.line,
                startColumn: this.column || 1,
                endLineNumber: this.line,
                endColumn: this.column || 1
            };
        };
        return GotoLineEntry;
    }(quickopen_1.EditorQuickOpenEntry));
    var GotoLineHandler = /** @class */ (function (_super) {
        __extends(GotoLineHandler, _super);
        function GotoLineHandler(editorService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            return _this;
        }
        GotoLineHandler.prototype.getAriaLabel = function () {
            return nls.localize('gotoLineHandlerAriaLabel', "Type a line number to navigate to.");
        };
        GotoLineHandler.prototype.getResults = function (searchValue, token) {
            searchValue = searchValue.trim();
            // Remember view state to be able to restore on cancel
            if (!this.lastKnownEditorViewState) {
                var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
                this.lastKnownEditorViewState = activeTextEditorWidget.saveViewState();
            }
            return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel([new GotoLineEntry(searchValue, this.editorService, this)]));
        };
        GotoLineHandler.prototype.canRun = function () {
            var canRun = !!this.editorService.activeTextEditorWidget;
            return canRun ? true : nls.localize('cannotRunGotoLine', "Open a text file first to go to a line");
        };
        GotoLineHandler.prototype.decorateOutline = function (range, editor, group) {
            var _this = this;
            editor.changeDecorations(function (changeAccessor) {
                var deleteDecorations = [];
                if (_this.rangeHighlightDecorationId) {
                    deleteDecorations.push(_this.rangeHighlightDecorationId.lineDecorationId);
                    deleteDecorations.push(_this.rangeHighlightDecorationId.rangeHighlightId);
                    _this.rangeHighlightDecorationId = null;
                }
                var newDecorations = [
                    // rangeHighlight at index 0
                    {
                        range: range,
                        options: {
                            className: 'rangeHighlight',
                            isWholeLine: true
                        }
                    },
                    // lineDecoration at index 1
                    {
                        range: range,
                        options: {
                            overviewRuler: {
                                color: themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerRangeHighlight),
                                position: model_1.OverviewRulerLane.Full
                            }
                        }
                    }
                ];
                var decorations = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
                var rangeHighlightId = decorations[0];
                var lineDecorationId = decorations[1];
                _this.rangeHighlightDecorationId = {
                    groupId: group.id,
                    rangeHighlightId: rangeHighlightId,
                    lineDecorationId: lineDecorationId,
                };
            });
        };
        GotoLineHandler.prototype.clearDecorations = function () {
            var _this = this;
            if (this.rangeHighlightDecorationId) {
                this.editorService.visibleControls.forEach(function (editor) {
                    if (editor.group.id === _this.rangeHighlightDecorationId.groupId) {
                        var editorControl = editor.getControl();
                        editorControl.changeDecorations(function (changeAccessor) {
                            changeAccessor.deltaDecorations([
                                _this.rangeHighlightDecorationId.lineDecorationId,
                                _this.rangeHighlightDecorationId.rangeHighlightId
                            ], []);
                        });
                    }
                });
                this.rangeHighlightDecorationId = null;
            }
        };
        GotoLineHandler.prototype.onClose = function (canceled) {
            // Clear Highlight Decorations if present
            this.clearDecorations();
            // Restore selection if canceled
            if (canceled && this.lastKnownEditorViewState) {
                var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
                if (activeTextEditorWidget) {
                    activeTextEditorWidget.restoreViewState(this.lastKnownEditorViewState);
                }
            }
            this.lastKnownEditorViewState = null;
        };
        GotoLineHandler.prototype.getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: searchValue.trim().length > 0
            };
        };
        GotoLineHandler.ID = 'workbench.picker.line';
        GotoLineHandler = __decorate([
            __param(0, editorService_1.IEditorService)
        ], GotoLineHandler);
        return GotoLineHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.GotoLineHandler = GotoLineHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[293/*vs/workbench/parts/quickopen/browser/gotoSymbolHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,29/*vs/base/common/types*/,22/*vs/base/common/strings*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,69/*vs/base/common/filters*/,72/*vs/editor/common/model*/,46/*vs/platform/quickOpen/common/quickOpen*/,471/*vs/editor/contrib/quickOpen/quickOpen*/,85/*vs/editor/common/modes*/,14/*vs/platform/theme/common/themeService*/,177/*vs/editor/common/view/editorColorRegistry*/,11/*vs/workbench/services/editor/common/editorService*/,17/*vs/base/common/async*/,55/*vs/base/common/cancellation*/,214/*vs/css!vs/editor/contrib/documentSymbols/media/symbol-icons*/]), function (require, exports, winjs_base_1, nls, types, strings, quickOpenModel_1, quickopen_1, filters, model_1, quickOpen_1, quickOpen_2, modes_1, themeService_1, editorColorRegistry_1, editorService_1, async_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a;
    exports.GOTO_SYMBOL_PREFIX = '@';
    exports.SCOPE_PREFIX = ':';
    var FALLBACK_NLS_SYMBOL_KIND = nls.localize('property', "properties ({0})");
    var NLS_SYMBOL_KIND_CACHE = (_a = {},
        _a[modes_1.SymbolKind.Method] = nls.localize('method', "methods ({0})"),
        _a[modes_1.SymbolKind.Function] = nls.localize('function', "functions ({0})"),
        _a[modes_1.SymbolKind.Constructor] = nls.localize('_constructor', "constructors ({0})"),
        _a[modes_1.SymbolKind.Variable] = nls.localize('variable', "variables ({0})"),
        _a[modes_1.SymbolKind.Class] = nls.localize('class', "classes ({0})"),
        _a[modes_1.SymbolKind.Struct] = nls.localize('struct', "structs ({0})"),
        _a[modes_1.SymbolKind.Event] = nls.localize('event', "events ({0})"),
        _a[modes_1.SymbolKind.Operator] = nls.localize('operator', "operators ({0})"),
        _a[modes_1.SymbolKind.Interface] = nls.localize('interface', "interfaces ({0})"),
        _a[modes_1.SymbolKind.Namespace] = nls.localize('namespace', "namespaces ({0})"),
        _a[modes_1.SymbolKind.Package] = nls.localize('package', "packages ({0})"),
        _a[modes_1.SymbolKind.TypeParameter] = nls.localize('typeParameter', "type parameters ({0})"),
        _a[modes_1.SymbolKind.Module] = nls.localize('modules', "modules ({0})"),
        _a[modes_1.SymbolKind.Property] = nls.localize('property', "properties ({0})"),
        _a[modes_1.SymbolKind.Enum] = nls.localize('enum', "enumerations ({0})"),
        _a[modes_1.SymbolKind.EnumMember] = nls.localize('enumMember', "enumeration members ({0})"),
        _a[modes_1.SymbolKind.String] = nls.localize('string', "strings ({0})"),
        _a[modes_1.SymbolKind.File] = nls.localize('file', "files ({0})"),
        _a[modes_1.SymbolKind.Array] = nls.localize('array', "arrays ({0})"),
        _a[modes_1.SymbolKind.Number] = nls.localize('number', "numbers ({0})"),
        _a[modes_1.SymbolKind.Boolean] = nls.localize('boolean', "booleans ({0})"),
        _a[modes_1.SymbolKind.Object] = nls.localize('object', "objects ({0})"),
        _a[modes_1.SymbolKind.Key] = nls.localize('key', "keys ({0})"),
        _a[modes_1.SymbolKind.Field] = nls.localize('field', "fields ({0})"),
        _a[modes_1.SymbolKind.Constant] = nls.localize('constant', "constants ({0})"),
        _a);
    var GotoSymbolAction = /** @class */ (function (_super) {
        __extends(GotoSymbolAction, _super);
        function GotoSymbolAction(actionId, actionLabel, quickOpenService) {
            return _super.call(this, actionId, actionLabel, exports.GOTO_SYMBOL_PREFIX, quickOpenService) || this;
        }
        GotoSymbolAction.ID = 'workbench.action.gotoSymbol';
        GotoSymbolAction.LABEL = nls.localize('gotoSymbol', "Go to Symbol in File...");
        GotoSymbolAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService)
        ], GotoSymbolAction);
        return GotoSymbolAction;
    }(quickopen_1.QuickOpenAction));
    exports.GotoSymbolAction = GotoSymbolAction;
    var OutlineModel = /** @class */ (function (_super) {
        __extends(OutlineModel, _super);
        function OutlineModel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OutlineModel.prototype.applyFilter = function (searchValue) {
            // Normalize search
            var normalizedSearchValue = searchValue;
            if (searchValue.indexOf(exports.SCOPE_PREFIX) === 0) {
                normalizedSearchValue = normalizedSearchValue.substr(exports.SCOPE_PREFIX.length);
            }
            // Check for match and update visibility and group label
            this.entries.forEach(function (entry) {
                // Clear all state first
                entry.setGroupLabel(null);
                entry.setShowBorder(false);
                entry.setHighlights(null);
                entry.setHidden(false);
                // Filter by search
                if (normalizedSearchValue) {
                    var highlights = filters.matchesFuzzy(normalizedSearchValue, entry.getLabel());
                    if (highlights) {
                        entry.setHighlights(highlights);
                        entry.setHidden(false);
                    }
                    else if (!entry.isHidden()) {
                        entry.setHidden(true);
                    }
                }
            });
            // Sort properly if actually searching
            if (searchValue) {
                if (searchValue.indexOf(exports.SCOPE_PREFIX) === 0) {
                    this.entries.sort(this.sortScoped.bind(this, searchValue.toLowerCase()));
                }
                else {
                    this.entries.sort(this.sortNormal.bind(this, searchValue.toLowerCase()));
                }
            }
            // Otherwise restore order as appearing in outline
            else {
                this.entries.sort(function (a, b) { return a.getIndex() - b.getIndex(); });
            }
            // Mark all type groups
            var visibleResults = this.getEntries(true);
            if (visibleResults.length > 0 && searchValue.indexOf(exports.SCOPE_PREFIX) === 0) {
                var currentType = null;
                var currentResult = null;
                var typeCounter = 0;
                for (var i = 0; i < visibleResults.length; i++) {
                    var result = visibleResults[i];
                    // Found new type
                    if (currentType !== result.getKind()) {
                        // Update previous result with count
                        if (currentResult) {
                            currentResult.setGroupLabel(this.renderGroupLabel(currentType, typeCounter));
                        }
                        currentType = result.getKind();
                        currentResult = result;
                        typeCounter = 1;
                        result.setShowBorder(i > 0);
                    }
                    // Existing type, keep counting
                    else {
                        typeCounter++;
                    }
                }
                // Update previous result with count
                if (currentResult) {
                    currentResult.setGroupLabel(this.renderGroupLabel(currentType, typeCounter));
                }
            }
            // Mark first entry as outline
            else if (visibleResults.length > 0) {
                visibleResults[0].setGroupLabel(nls.localize('symbols', "symbols ({0})", visibleResults.length));
            }
        };
        OutlineModel.prototype.sortNormal = function (searchValue, elementA, elementB) {
            // Handle hidden elements
            if (elementA.isHidden() && elementB.isHidden()) {
                return 0;
            }
            else if (elementA.isHidden()) {
                return 1;
            }
            else if (elementB.isHidden()) {
                return -1;
            }
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            // Compare by name
            var r = elementAName.localeCompare(elementBName);
            if (r !== 0) {
                return r;
            }
            // If name identical sort by range instead
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        OutlineModel.prototype.sortScoped = function (searchValue, elementA, elementB) {
            // Handle hidden elements
            if (elementA.isHidden() && elementB.isHidden()) {
                return 0;
            }
            else if (elementA.isHidden()) {
                return 1;
            }
            else if (elementB.isHidden()) {
                return -1;
            }
            // Remove scope char
            searchValue = searchValue.substr(exports.SCOPE_PREFIX.length);
            // Sort by type first if scoped search
            var elementATypeLabel = NLS_SYMBOL_KIND_CACHE[elementA.getKind()] || FALLBACK_NLS_SYMBOL_KIND;
            var elementBTypeLabel = NLS_SYMBOL_KIND_CACHE[elementB.getKind()] || FALLBACK_NLS_SYMBOL_KIND;
            var r = elementATypeLabel.localeCompare(elementBTypeLabel);
            if (r !== 0) {
                return r;
            }
            // Special sort when searching in scoped mode
            if (searchValue) {
                var elementAName = elementA.getLabel().toLowerCase();
                var elementBName = elementB.getLabel().toLowerCase();
                // Compare by name
                r = elementAName.localeCompare(elementBName);
                if (r !== 0) {
                    return r;
                }
            }
            // Default to sort by range
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        OutlineModel.prototype.renderGroupLabel = function (type, count) {
            var pattern = NLS_SYMBOL_KIND_CACHE[type];
            if (!pattern) {
                pattern = FALLBACK_NLS_SYMBOL_KIND;
            }
            return strings.format(pattern, count);
        };
        return OutlineModel;
    }(quickOpenModel_1.QuickOpenModel));
    var SymbolEntry = /** @class */ (function (_super) {
        __extends(SymbolEntry, _super);
        function SymbolEntry(index, name, kind, description, icon, range, revealRange, highlights, editorService, handler) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.name = name;
            _this.kind = kind;
            _this.icon = icon;
            _this.description = description;
            _this.range = range;
            _this.revealRange = revealRange || range;
            _this.setHighlights(highlights);
            _this.editorService = editorService;
            _this.handler = handler;
            return _this;
        }
        SymbolEntry.prototype.getIndex = function () {
            return this.index;
        };
        SymbolEntry.prototype.getLabel = function () {
            return this.name;
        };
        SymbolEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, symbols", this.getLabel());
        };
        SymbolEntry.prototype.getIcon = function () {
            return this.icon;
        };
        SymbolEntry.prototype.getDescription = function () {
            return this.description;
        };
        SymbolEntry.prototype.getKind = function () {
            return this.kind;
        };
        SymbolEntry.prototype.getRange = function () {
            return this.range;
        };
        SymbolEntry.prototype.getInput = function () {
            return this.editorService.activeEditor;
        };
        SymbolEntry.prototype.getOptions = function (pinned) {
            return {
                selection: this.toSelection(),
                pinned: pinned
            };
        };
        SymbolEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                return this.runOpen(context);
            }
            return this.runPreview();
        };
        SymbolEntry.prototype.runOpen = function (context) {
            // Check for sideBySide use
            var sideBySide = context.keymods.ctrlCmd;
            if (sideBySide) {
                this.editorService.openEditor(this.getInput(), this.getOptions(context.keymods.alt), editorService_1.SIDE_GROUP);
            }
            // Apply selection and focus
            else {
                var range = this.toSelection();
                var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
                if (activeTextEditorWidget) {
                    activeTextEditorWidget.setSelection(range);
                    activeTextEditorWidget.revealRangeInCenter(range, 0 /* Smooth */);
                }
            }
            return true;
        };
        SymbolEntry.prototype.runPreview = function () {
            // Select Outline Position
            var range = this.toSelection();
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (activeTextEditorWidget) {
                activeTextEditorWidget.revealRangeInCenter(range, 0 /* Smooth */);
                // Decorate if possible
                if (types.isFunction(activeTextEditorWidget.changeDecorations)) {
                    this.handler.decorateOutline(this.range, range, activeTextEditorWidget, this.editorService.activeControl.group);
                }
            }
            return false;
        };
        SymbolEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this.revealRange.startLineNumber,
                startColumn: this.revealRange.startColumn || 1,
                endLineNumber: this.revealRange.startLineNumber,
                endColumn: this.revealRange.startColumn || 1
            };
        };
        return SymbolEntry;
    }(quickopen_1.EditorQuickOpenEntryGroup));
    var GotoSymbolHandler = /** @class */ (function (_super) {
        __extends(GotoSymbolHandler, _super);
        function GotoSymbolHandler(editorService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.registerListeners();
            return _this;
        }
        GotoSymbolHandler.prototype.registerListeners = function () {
            var _this = this;
            this.editorService.onDidActiveEditorChange(function () { return _this.onDidActiveEditorChange(); });
        };
        GotoSymbolHandler.prototype.onDidActiveEditorChange = function () {
            this.clearOutlineRequest();
            this.lastKnownEditorViewState = void 0;
            this.rangeHighlightDecorationId = void 0;
        };
        GotoSymbolHandler.prototype.getResults = function (searchValue, token) {
            searchValue = searchValue.trim();
            // Support to cancel pending outline requests
            if (!this.pendingOutlineRequest) {
                this.pendingOutlineRequest = new cancellation_1.CancellationTokenSource();
            }
            // Remember view state to be able to restore on cancel
            if (!this.lastKnownEditorViewState) {
                var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
                this.lastKnownEditorViewState = activeTextEditorWidget.saveViewState();
            }
            // Resolve Outline Model
            return this.getOutline().then(function (outline) {
                if (token.isCancellationRequested) {
                    return outline;
                }
                // Filter by search
                outline.applyFilter(searchValue);
                return outline;
            });
        };
        GotoSymbolHandler.prototype.getEmptyLabel = function (searchString) {
            if (searchString.length > 0) {
                return nls.localize('noSymbolsMatching', "No symbols matching");
            }
            return nls.localize('noSymbolsFound', "No symbols found");
        };
        GotoSymbolHandler.prototype.getAriaLabel = function () {
            return nls.localize('gotoSymbolHandlerAriaLabel', "Type to narrow down symbols of the currently active editor.");
        };
        GotoSymbolHandler.prototype.canRun = function () {
            var canRun = false;
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (activeTextEditorWidget) {
                var model = activeTextEditorWidget.getModel();
                if (model && model.modified && model.original) {
                    model = model.modified; // Support for diff editor models
                }
                if (model && types.isFunction(model.getLanguageIdentifier)) {
                    canRun = modes_1.DocumentSymbolProviderRegistry.has(model);
                }
            }
            return canRun ? true : activeTextEditorWidget !== null ? nls.localize('cannotRunGotoSymbolInFile', "No symbol information for the file") : nls.localize('cannotRunGotoSymbol', "Open a text file first to go to a symbol");
        };
        GotoSymbolHandler.prototype.getAutoFocus = function (searchValue) {
            searchValue = searchValue.trim();
            // Remove any type pattern (:) from search value as needed
            if (searchValue.indexOf(exports.SCOPE_PREFIX) === 0) {
                searchValue = searchValue.substr(exports.SCOPE_PREFIX.length);
            }
            return {
                autoFocusPrefixMatch: searchValue,
                autoFocusFirstEntry: !!searchValue
            };
        };
        GotoSymbolHandler.prototype.toQuickOpenEntries = function (flattened) {
            var results = [];
            for (var i = 0; i < flattened.length; i++) {
                var element = flattened[i];
                var label = strings.trim(element.name);
                // Show parent scope as description
                var description = element.containerName;
                var icon = modes_1.symbolKindToCssClass(element.kind);
                // Add
                results.push(new SymbolEntry(i, label, element.kind, description, "symbol-icon " + icon, element.range, element.selectionRange, null, this.editorService, this));
            }
            return results;
        };
        GotoSymbolHandler.prototype.getOutline = function () {
            if (!this.cachedOutlineRequest) {
                this.cachedOutlineRequest = this.doGetActiveOutline();
            }
            return this.cachedOutlineRequest;
        };
        GotoSymbolHandler.prototype.doGetActiveOutline = function () {
            var _this = this;
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (activeTextEditorWidget) {
                var model_2 = activeTextEditorWidget.getModel();
                if (model_2 && model_2.modified && model_2.original) {
                    model_2 = model_2.modified; // Support for diff editor models
                }
                if (model_2 && types.isFunction(model_2.getLanguageIdentifier)) {
                    return winjs_base_1.TPromise.wrap(async_1.asThenable(function () { return quickOpen_2.getDocumentSymbols(model_2, true, _this.pendingOutlineRequest.token); }).then(function (entries) {
                        return new OutlineModel(_this.toQuickOpenEntries(entries));
                    }));
                }
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        GotoSymbolHandler.prototype.decorateOutline = function (fullRange, startRange, editor, group) {
            var _this = this;
            editor.changeDecorations(function (changeAccessor) {
                var deleteDecorations = [];
                if (_this.rangeHighlightDecorationId) {
                    deleteDecorations.push(_this.rangeHighlightDecorationId.lineDecorationId);
                    deleteDecorations.push(_this.rangeHighlightDecorationId.rangeHighlightId);
                    _this.rangeHighlightDecorationId = null;
                }
                var newDecorations = [
                    // rangeHighlight at index 0
                    {
                        range: fullRange,
                        options: {
                            className: 'rangeHighlight',
                            isWholeLine: true
                        }
                    },
                    // lineDecoration at index 1
                    {
                        range: startRange,
                        options: {
                            overviewRuler: {
                                color: themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerRangeHighlight),
                                position: model_1.OverviewRulerLane.Full
                            }
                        }
                    }
                ];
                var decorations = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
                var rangeHighlightId = decorations[0];
                var lineDecorationId = decorations[1];
                _this.rangeHighlightDecorationId = {
                    groupId: group.id,
                    rangeHighlightId: rangeHighlightId,
                    lineDecorationId: lineDecorationId,
                };
            });
        };
        GotoSymbolHandler.prototype.clearDecorations = function () {
            var _this = this;
            if (this.rangeHighlightDecorationId) {
                this.editorService.visibleControls.forEach(function (editor) {
                    if (editor.group.id === _this.rangeHighlightDecorationId.groupId) {
                        var editorControl = editor.getControl();
                        editorControl.changeDecorations(function (changeAccessor) {
                            changeAccessor.deltaDecorations([
                                _this.rangeHighlightDecorationId.lineDecorationId,
                                _this.rangeHighlightDecorationId.rangeHighlightId
                            ], []);
                        });
                    }
                });
                this.rangeHighlightDecorationId = null;
            }
        };
        GotoSymbolHandler.prototype.onClose = function (canceled) {
            // Cancel any pending/cached outline request now
            this.clearOutlineRequest();
            // Clear Highlight Decorations if present
            this.clearDecorations();
            // Restore selection if canceled
            if (canceled && this.lastKnownEditorViewState) {
                var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
                if (activeTextEditorWidget) {
                    activeTextEditorWidget.restoreViewState(this.lastKnownEditorViewState);
                }
                this.lastKnownEditorViewState = null;
            }
        };
        GotoSymbolHandler.prototype.clearOutlineRequest = function () {
            if (this.pendingOutlineRequest) {
                this.pendingOutlineRequest.cancel();
                this.pendingOutlineRequest.dispose();
                this.pendingOutlineRequest = void 0;
            }
            this.cachedOutlineRequest = null;
        };
        GotoSymbolHandler.ID = 'workbench.picker.filesymbols';
        GotoSymbolHandler = __decorate([
            __param(0, editorService_1.IEditorService)
        ], GotoSymbolHandler);
        return GotoSymbolHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.GotoSymbolHandler = GotoSymbolHandler;
});























define(__m[295/*vs/workbench/parts/quickopen/browser/helpHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,29/*vs/base/common/types*/,9/*vs/platform/registry/common/platform*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,46/*vs/platform/quickOpen/common/quickOpen*/]), function (require, exports, winjs_base_1, nls, types, platform_1, quickOpenModel_1, quickopen_1, quickOpen_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HELP_PREFIX = '?';
    var HelpEntry = /** @class */ (function (_super) {
        __extends(HelpEntry, _super);
        function HelpEntry(prefix, description, quickOpenService, openOnPreview) {
            var _this = _super.call(this) || this;
            if (!prefix) {
                _this.prefix = '';
                _this.prefixLabel = '\u2026' /* ... */;
            }
            else {
                _this.prefix = _this.prefixLabel = prefix;
            }
            _this.description = description;
            _this.quickOpenService = quickOpenService;
            _this.openOnPreview = openOnPreview;
            return _this;
        }
        HelpEntry.prototype.getLabel = function () {
            return this.prefixLabel;
        };
        HelpEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, picker help", this.getLabel());
        };
        HelpEntry.prototype.getDescription = function () {
            return this.description;
        };
        HelpEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */ || this.openOnPreview) {
                this.quickOpenService.show(this.prefix);
            }
            return false;
        };
        return HelpEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    var HelpHandler = /** @class */ (function (_super) {
        __extends(HelpHandler, _super);
        function HelpHandler(quickOpenService) {
            var _this = _super.call(this) || this;
            _this.quickOpenService = quickOpenService;
            return _this;
        }
        HelpHandler.prototype.getResults = function (searchValue, token) {
            var _this = this;
            searchValue = searchValue.trim();
            var registry = (platform_1.Registry.as(quickopen_1.Extensions.Quickopen));
            var handlerDescriptors = registry.getQuickOpenHandlers();
            var defaultHandler = registry.getDefaultQuickOpenHandler();
            if (defaultHandler) {
                handlerDescriptors.push(defaultHandler);
            }
            var workbenchScoped = [];
            var editorScoped = [];
            var matchingHandlers = [];
            handlerDescriptors.sort(function (h1, h2) { return h1.prefix.localeCompare(h2.prefix); }).forEach(function (handlerDescriptor) {
                if (handlerDescriptor.prefix !== exports.HELP_PREFIX) {
                    // Descriptor has multiple help entries
                    if (types.isArray(handlerDescriptor.helpEntries)) {
                        for (var j = 0; j < handlerDescriptor.helpEntries.length; j++) {
                            var helpEntry = handlerDescriptor.helpEntries[j];
                            if (helpEntry.prefix.indexOf(searchValue) === 0) {
                                matchingHandlers.push(helpEntry);
                            }
                        }
                    }
                    // Single Help entry for descriptor
                    else if (handlerDescriptor.prefix.indexOf(searchValue) === 0) {
                        matchingHandlers.push(handlerDescriptor);
                    }
                }
            });
            matchingHandlers.forEach(function (handler) {
                if (handler instanceof quickopen_1.QuickOpenHandlerDescriptor) {
                    workbenchScoped.push(new HelpEntry(handler.prefix, handler.description, _this.quickOpenService, matchingHandlers.length === 1));
                }
                else {
                    var entry = new HelpEntry(handler.prefix, handler.description, _this.quickOpenService, matchingHandlers.length === 1);
                    if (handler.needsEditor) {
                        editorScoped.push(entry);
                    }
                    else {
                        workbenchScoped.push(entry);
                    }
                }
            });
            // Add separator for workbench scoped handlers
            if (workbenchScoped.length > 0) {
                workbenchScoped[0].setGroupLabel(nls.localize('globalCommands', "global commands"));
            }
            // Add separator for editor scoped handlers
            if (editorScoped.length > 0) {
                editorScoped[0].setGroupLabel(nls.localize('editorCommands', "editor commands"));
                if (workbenchScoped.length > 0) {
                    editorScoped[0].setShowBorder(true);
                }
            }
            return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel(workbenchScoped.concat(editorScoped)));
        };
        HelpHandler.prototype.getAutoFocus = function (searchValue) {
            searchValue = searchValue.trim();
            return {
                autoFocusFirstEntry: searchValue.length > 0,
                autoFocusPrefixMatch: searchValue
            };
        };
        HelpHandler.ID = 'workbench.picker.help';
        HelpHandler = __decorate([
            __param(0, quickOpen_1.IQuickOpenService)
        ], HelpHandler);
        return HelpHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.HelpHandler = HelpHandler;
});























define(__m[179/*vs/workbench/parts/search/browser/openSymbolHandler*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,25/*vs/base/common/errors*/,17/*vs/base/common/async*/,53/*vs/workbench/browser/quickopen*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,69/*vs/base/common/filters*/,22/*vs/base/common/strings*/,48/*vs/editor/common/core/range*/,85/*vs/editor/common/modes*/,3/*vs/platform/instantiation/common/instantiation*/,7/*vs/platform/configuration/common/configuration*/,143/*vs/workbench/parts/search/common/search*/,24/*vs/base/common/paths*/,11/*vs/workbench/services/editor/common/editorService*/,59/*vs/platform/label/common/label*/,55/*vs/base/common/cancellation*/,26/*vs/base/common/network*/,138/*vs/platform/opener/common/opener*/]), function (require, exports, nls, winjs_base_1, errors_1, async_1, quickopen_1, quickOpenModel_1, filters, strings, range_1, modes_1, instantiation_1, configuration_1, search_1, paths_1, editorService_1, label_1, cancellation_1, network_1, opener_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SymbolEntry = /** @class */ (function (_super) {
        __extends(SymbolEntry, _super);
        function SymbolEntry(bearing, provider, configurationService, editorService, labelService, openerService) {
            var _this = _super.call(this, editorService) || this;
            _this.bearing = bearing;
            _this.provider = provider;
            _this.configurationService = configurationService;
            _this.labelService = labelService;
            _this.openerService = openerService;
            return _this;
        }
        SymbolEntry.prototype.getLabel = function () {
            return this.bearing.name;
        };
        SymbolEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, symbols picker", this.getLabel());
        };
        SymbolEntry.prototype.getDescription = function () {
            var containerName = this.bearing.containerName;
            if (this.bearing.location.uri) {
                if (containerName) {
                    return containerName + " \u2014 " + paths_1.basename(this.bearing.location.uri.fsPath);
                }
                return this.labelService.getUriLabel(this.bearing.location.uri, { relative: true });
            }
            return containerName;
        };
        SymbolEntry.prototype.getIcon = function () {
            return modes_1.symbolKindToCssClass(this.bearing.kind);
        };
        SymbolEntry.prototype.getResource = function () {
            return this.bearing.location.uri;
        };
        SymbolEntry.prototype.run = function (mode, context) {
            var _this = this;
            // resolve this type bearing if neccessary
            if (!this.bearingResolve && typeof this.provider.resolveWorkspaceSymbol === 'function' && !this.bearing.location.range) {
                this.bearingResolve = Promise.resolve(this.provider.resolveWorkspaceSymbol(this.bearing, cancellation_1.CancellationToken.None)).then(function (result) {
                    _this.bearing = result || _this.bearing;
                    return _this;
                }, errors_1.onUnexpectedError);
            }
            // open after resolving
            winjs_base_1.TPromise.as(this.bearingResolve).then(function () {
                var scheme = _this.bearing.location.uri ? _this.bearing.location.uri.scheme : void 0;
                if (scheme === network_1.Schemas.http || scheme === network_1.Schemas.https) {
                    _this.openerService.open(_this.bearing.location.uri); // support http/https resources (https://github.com/Microsoft/vscode/issues/58924))
                }
                else {
                    _super.prototype.run.call(_this, mode, context);
                }
            });
            // hide if OPEN
            return mode === 1 /* OPEN */;
        };
        SymbolEntry.prototype.getInput = function () {
            var input = {
                resource: this.bearing.location.uri,
                options: {
                    pinned: !this.configurationService.getValue().workbench.editor.enablePreviewFromQuickOpen
                }
            };
            if (this.bearing.location.range) {
                input.options.selection = range_1.Range.collapseToStart(this.bearing.location.range);
            }
            return input;
        };
        SymbolEntry.compare = function (elementA, elementB, searchValue) {
            // Sort by Type if name is identical
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            if (elementAName === elementBName) {
                var elementAType = modes_1.symbolKindToCssClass(elementA.bearing.kind);
                var elementBType = modes_1.symbolKindToCssClass(elementB.bearing.kind);
                return elementAType.localeCompare(elementBType);
            }
            return quickOpenModel_1.compareEntries(elementA, elementB, searchValue);
        };
        SymbolEntry = __decorate([
            __param(2, configuration_1.IConfigurationService),
            __param(3, editorService_1.IEditorService),
            __param(4, label_1.ILabelService),
            __param(5, opener_1.IOpenerService)
        ], SymbolEntry);
        return SymbolEntry;
    }(quickopen_1.EditorQuickOpenEntry));
    var OpenSymbolHandler = /** @class */ (function (_super) {
        __extends(OpenSymbolHandler, _super);
        function OpenSymbolHandler(instantiationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.delayer = new async_1.ThrottledDelayer(OpenSymbolHandler.TYPING_SEARCH_DELAY);
            _this.options = Object.create(null);
            return _this;
        }
        OpenSymbolHandler.prototype.setOptions = function (options) {
            this.options = options;
        };
        OpenSymbolHandler.prototype.canRun = function () {
            return true;
        };
        OpenSymbolHandler.prototype.getResults = function (searchValue, token) {
            var _this = this;
            searchValue = searchValue.trim();
            var promise;
            if (!this.options.skipDelay) {
                promise = this.delayer.trigger(function () {
                    if (token.isCancellationRequested) {
                        return winjs_base_1.TPromise.wrap([]);
                    }
                    return _this.doGetResults(searchValue, token);
                });
            }
            else {
                promise = this.doGetResults(searchValue, token);
            }
            return promise.then(function (e) { return new quickOpenModel_1.QuickOpenModel(e); });
        };
        OpenSymbolHandler.prototype.doGetResults = function (searchValue, token) {
            var _this = this;
            return search_1.getWorkspaceSymbols(searchValue, token).then(function (tuples) {
                if (token.isCancellationRequested) {
                    return [];
                }
                var result = [];
                for (var _i = 0, tuples_1 = tuples; _i < tuples_1.length; _i++) {
                    var tuple = tuples_1[_i];
                    var provider = tuple[0], bearings = tuple[1];
                    _this.fillInSymbolEntries(result, provider, bearings, searchValue);
                }
                // Sort (Standalone only)
                if (!_this.options.skipSorting) {
                    searchValue = searchValue ? strings.stripWildcards(searchValue.toLowerCase()) : searchValue;
                    return result.sort(function (a, b) { return SymbolEntry.compare(a, b, searchValue); });
                }
                return result;
            });
        };
        OpenSymbolHandler.prototype.fillInSymbolEntries = function (bucket, provider, types, searchValue) {
            // Convert to Entries
            for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
                var element = types_1[_i];
                if (this.options.skipLocalSymbols && !!element.containerName) {
                    continue; // ignore local symbols if we are told so
                }
                var entry = this.instantiationService.createInstance(SymbolEntry, element, provider);
                entry.setHighlights(filters.matchesFuzzy(searchValue, entry.getLabel()));
                bucket.push(entry);
            }
        };
        OpenSymbolHandler.prototype.getGroupLabel = function () {
            return nls.localize('symbols', "symbol results");
        };
        OpenSymbolHandler.prototype.getEmptyLabel = function (searchString) {
            if (searchString.length > 0) {
                return nls.localize('noSymbolsMatching', "No symbols matching");
            }
            return nls.localize('noSymbolsWithoutInput', "Type to search for symbols");
        };
        OpenSymbolHandler.prototype.getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: true,
                autoFocusPrefixMatch: searchValue.trim()
            };
        };
        OpenSymbolHandler.ID = 'workbench.picker.symbols';
        OpenSymbolHandler.TYPING_SEARCH_DELAY = 200; // This delay accommodates for the user typing a word and then stops typing to start searching
        OpenSymbolHandler = __decorate([
            __param(0, instantiation_1.IInstantiationService)
        ], OpenSymbolHandler);
        return OpenSymbolHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.OpenSymbolHandler = OpenSymbolHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[298/*vs/workbench/services/codeEditor/browser/codeEditorService*/], __M([0/*require*/,1/*exports*/,470/*vs/editor/browser/services/codeEditorServiceImpl*/,45/*vs/editor/browser/editorBrowser*/,11/*vs/workbench/services/editor/common/editorService*/,14/*vs/platform/theme/common/themeService*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/]), function (require, exports, codeEditorServiceImpl_1, editorBrowser_1, editorService_1, themeService_1, winjs_base_1, editor_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeEditorService = /** @class */ (function (_super) {
        __extends(CodeEditorService, _super);
        function CodeEditorService(editorService, themeService) {
            var _this = _super.call(this, themeService) || this;
            _this.editorService = editorService;
            return _this;
        }
        CodeEditorService.prototype.getActiveCodeEditor = function () {
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {
                return activeTextEditorWidget;
            }
            if (editorBrowser_1.isDiffEditor(activeTextEditorWidget)) {
                return activeTextEditorWidget.getModifiedEditor();
            }
            return null;
        };
        CodeEditorService.prototype.openCodeEditor = function (input, source, sideBySide) {
            // Special case: If the active editor is a diff editor and the request to open originates and
            // targets the modified side of it, we just apply the request there to prevent opening the modified
            // side as separate editor.
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (!sideBySide && // we need the current active group to be the taret
                editorBrowser_1.isDiffEditor(activeTextEditorWidget) && // we only support this for active text diff editors
                input.options && // we need options to apply
                input.resource && // we need a request resource to compare with
                activeTextEditorWidget.getModel() && // we need a target model to compare with
                source === activeTextEditorWidget.getModifiedEditor() && // we need the source of this request to be the modified side of the diff editor
                input.resource.toString() === activeTextEditorWidget.getModel().modified.uri.toString() // we need the input resources to match with modified side
            ) {
                var targetEditor = activeTextEditorWidget.getModifiedEditor();
                var textOptions = editor_1.TextEditorOptions.create(input.options);
                textOptions.apply(targetEditor, 0 /* Smooth */);
                return winjs_base_1.TPromise.as(targetEditor);
            }
            // Open using our normal editor service
            return this.doOpenCodeEditor(input, source, sideBySide);
        };
        CodeEditorService.prototype.doOpenCodeEditor = function (input, source, sideBySide) {
            return this.editorService.openEditor(input, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP).then(function (control) {
                if (control) {
                    var widget = control.getControl();
                    if (editorBrowser_1.isCodeEditor(widget)) {
                        return widget;
                    }
                }
                return null;
            });
        };
        CodeEditorService = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, themeService_1.IThemeService)
        ], CodeEditorService);
        return CodeEditorService;
    }(codeEditorServiceImpl_1.CodeEditorServiceImpl));
    exports.CodeEditorService = CodeEditorService;
});

define(__m[70/*vs/workbench/services/extensions/common/extensions*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IExtensionService = instantiation_1.createDecorator('extensionService');
    var ActivationTimes = /** @class */ (function () {
        function ActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
            this.activationEvent = activationEvent;
        }
        return ActivationTimes;
    }());
    exports.ActivationTimes = ActivationTimes;
    var ExtensionPointContribution = /** @class */ (function () {
        function ExtensionPointContribution(description, value) {
            this.description = description;
            this.value = value;
        }
        return ExtensionPointContribution;
    }());
    exports.ExtensionPointContribution = ExtensionPointContribution;
    exports.ExtensionHostLogFileName = 'exthost';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[301/*vs/workbench/parts/quickopen/browser/commandsHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,19/*vs/base/common/arrays*/,29/*vs/base/common/types*/,18/*vs/base/common/platform*/,15/*vs/base/common/actions*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,23/*vs/platform/actions/common/actions*/,10/*vs/platform/contextkey/common/contextkey*/,53/*vs/workbench/browser/quickopen*/,69/*vs/base/common/filters*/,3/*vs/platform/instantiation/common/instantiation*/,32/*vs/platform/telemetry/common/telemetry*/,31/*vs/platform/keybinding/common/keybinding*/,46/*vs/platform/quickOpen/common/quickOpen*/,56/*vs/editor/browser/editorExtensions*/,44/*vs/platform/storage/common/storage*/,63/*vs/platform/lifecycle/common/lifecycle*/,6/*vs/base/common/event*/,39/*vs/base/common/map*/,7/*vs/platform/configuration/common/configuration*/,11/*vs/workbench/services/editor/common/editorService*/,25/*vs/base/common/errors*/,28/*vs/platform/notification/common/notification*/,70/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, winjs_base_1, nls, arrays, types, platform_1, actions_1, quickOpenModel_1, actions_2, contextkey_1, quickopen_1, filters_1, instantiation_1, telemetry_1, keybinding_1, quickOpen_1, editorExtensions_1, storage_1, lifecycle_1, event_1, map_1, configuration_1, editorService_1, errors_1, notification_1, extensions_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ALL_COMMANDS_PREFIX = '>';
    var lastCommandPaletteInput;
    var commandHistory;
    var commandCounter = 1;
    function resolveCommandHistory(configurationService) {
        var config = configurationService.getValue();
        var commandHistory = config.workbench && config.workbench.commandPalette && config.workbench.commandPalette.history;
        if (typeof commandHistory !== 'number') {
            commandHistory = CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH;
        }
        return commandHistory;
    }
    var CommandsHistory = /** @class */ (function () {
        function CommandsHistory(storageService, lifecycleService, configurationService) {
            this.storageService = storageService;
            this.lifecycleService = lifecycleService;
            this.configurationService = configurationService;
            this.updateConfiguration();
            this.load();
            this.registerListeners();
        }
        CommandsHistory.prototype.updateConfiguration = function () {
            this.commandHistoryLength = resolveCommandHistory(this.configurationService);
            if (commandHistory) {
                commandHistory.limit = this.commandHistoryLength;
            }
        };
        CommandsHistory.prototype.load = function () {
            var raw = this.storageService.get(CommandsHistory.PREF_KEY_CACHE);
            var serializedCache;
            if (raw) {
                try {
                    serializedCache = JSON.parse(raw);
                }
                catch (error) {
                    // invalid data
                }
            }
            commandHistory = new map_1.LRUCache(this.commandHistoryLength, 1);
            if (serializedCache) {
                var entries = void 0;
                if (serializedCache.usesLRU) {
                    entries = serializedCache.entries;
                }
                else {
                    entries = serializedCache.entries.sort(function (a, b) { return a.value - b.value; });
                }
                entries.forEach(function (entry) { return commandHistory.set(entry.key, entry.value); });
            }
            commandCounter = this.storageService.getInteger(CommandsHistory.PREF_KEY_COUNTER, void 0, commandCounter);
        };
        CommandsHistory.prototype.registerListeners = function () {
            var _this = this;
            this.configurationService.onDidChangeConfiguration(function (e) { return _this.updateConfiguration(); });
            event_1.once(this.lifecycleService.onShutdown)(function (reason) { return _this.save(); });
        };
        CommandsHistory.prototype.save = function () {
            var serializedCache = { usesLRU: true, entries: [] };
            commandHistory.forEach(function (value, key) { return serializedCache.entries.push({ key: key, value: value }); });
            this.storageService.store(CommandsHistory.PREF_KEY_CACHE, JSON.stringify(serializedCache));
            this.storageService.store(CommandsHistory.PREF_KEY_COUNTER, commandCounter);
        };
        CommandsHistory.prototype.push = function (commandId) {
            commandHistory.set(commandId, commandCounter++); // set counter to command
        };
        CommandsHistory.prototype.peek = function (commandId) {
            return commandHistory.peek(commandId);
        };
        CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
        CommandsHistory.PREF_KEY_CACHE = 'commandPalette.mru.cache';
        CommandsHistory.PREF_KEY_COUNTER = 'commandPalette.mru.counter';
        CommandsHistory = __decorate([
            __param(0, storage_1.IStorageService),
            __param(1, lifecycle_1.ILifecycleService),
            __param(2, configuration_1.IConfigurationService)
        ], CommandsHistory);
        return CommandsHistory;
    }());
    var ShowAllCommandsAction = /** @class */ (function (_super) {
        __extends(ShowAllCommandsAction, _super);
        function ShowAllCommandsAction(id, label, quickOpenService, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.configurationService = configurationService;
            return _this;
        }
        ShowAllCommandsAction.prototype.run = function (context) {
            var config = this.configurationService.getValue();
            var restoreInput = config.workbench && config.workbench.commandPalette && config.workbench.commandPalette.preserveInput === true;
            // Show with last command palette input if any and configured
            var value = exports.ALL_COMMANDS_PREFIX;
            if (restoreInput && lastCommandPaletteInput) {
                value = "" + value + lastCommandPaletteInput;
            }
            this.quickOpenService.show(value, { inputSelection: lastCommandPaletteInput ? { start: 1 /* after prefix */, end: value.length } : void 0 });
            return winjs_base_1.TPromise.as(null);
        };
        ShowAllCommandsAction.ID = 'workbench.action.showCommands';
        ShowAllCommandsAction.LABEL = nls.localize('showTriggerActions', "Show All Commands");
        ShowAllCommandsAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, configuration_1.IConfigurationService)
        ], ShowAllCommandsAction);
        return ShowAllCommandsAction;
    }(actions_1.Action));
    exports.ShowAllCommandsAction = ShowAllCommandsAction;
    var ClearCommandHistoryAction = /** @class */ (function (_super) {
        __extends(ClearCommandHistoryAction, _super);
        function ClearCommandHistoryAction(id, label, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.configurationService = configurationService;
            return _this;
        }
        ClearCommandHistoryAction.prototype.run = function (context) {
            var commandHistoryLength = resolveCommandHistory(this.configurationService);
            if (commandHistoryLength > 0) {
                commandHistory = new map_1.LRUCache(commandHistoryLength);
                commandCounter = 1;
            }
            return winjs_base_1.TPromise.as(null);
        };
        ClearCommandHistoryAction.ID = 'workbench.action.clearCommandHistory';
        ClearCommandHistoryAction.LABEL = nls.localize('clearCommandHistory', "Clear Command History");
        ClearCommandHistoryAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ClearCommandHistoryAction);
        return ClearCommandHistoryAction;
    }(actions_1.Action));
    exports.ClearCommandHistoryAction = ClearCommandHistoryAction;
    var CommandPaletteEditorAction = /** @class */ (function (_super) {
        __extends(CommandPaletteEditorAction, _super);
        function CommandPaletteEditorAction() {
            return _super.call(this, {
                id: ShowAllCommandsAction.ID,
                label: nls.localize('showCommands.label', "Command Palette..."),
                alias: 'Command Palette',
                precondition: null,
                menuOpts: {
                    group: 'z_commands',
                    order: 1
                }
            }) || this;
        }
        CommandPaletteEditorAction.prototype.run = function (accessor, editor) {
            var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
            // Show with prefix
            quickOpenService.show(exports.ALL_COMMANDS_PREFIX);
            return winjs_base_1.TPromise.as(null);
        };
        return CommandPaletteEditorAction;
    }(editorExtensions_1.EditorAction));
    var BaseCommandEntry = /** @class */ (function (_super) {
        __extends(BaseCommandEntry, _super);
        function BaseCommandEntry(commandId, keybinding, label, alias, highlights, onBeforeRun, notificationService, telemetryService) {
            var _this = _super.call(this) || this;
            _this.commandId = commandId;
            _this.keybinding = keybinding;
            _this.label = label;
            _this.onBeforeRun = onBeforeRun;
            _this.notificationService = notificationService;
            _this.telemetryService = telemetryService;
            _this.labelLowercase = _this.label.toLowerCase();
            _this.keybindingAriaLabel = keybinding ? keybinding.getAriaLabel() : void 0;
            if (_this.label !== alias) {
                _this.alias = alias;
            }
            else {
                highlights.alias = null;
            }
            _this.setHighlights(highlights.label, null, highlights.alias);
            return _this;
        }
        BaseCommandEntry.prototype.getCommandId = function () {
            return this.commandId;
        };
        BaseCommandEntry.prototype.getLabel = function () {
            return this.label;
        };
        BaseCommandEntry.prototype.getSortLabel = function () {
            return this.labelLowercase;
        };
        BaseCommandEntry.prototype.getDescription = function () {
            return this.description;
        };
        BaseCommandEntry.prototype.setDescription = function (description) {
            this.description = description;
        };
        BaseCommandEntry.prototype.getKeybinding = function () {
            return this.keybinding;
        };
        BaseCommandEntry.prototype.getDetail = function () {
            return this.alias;
        };
        BaseCommandEntry.prototype.getAriaLabel = function () {
            if (this.keybindingAriaLabel) {
                return nls.localize('entryAriaLabelWithKey', "{0}, {1}, commands", this.getLabel(), this.keybindingAriaLabel);
            }
            return nls.localize('entryAriaLabel', "{0}, commands", this.getLabel());
        };
        BaseCommandEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                this.runAction(this.getAction());
                return true;
            }
            return false;
        };
        BaseCommandEntry.prototype.runAction = function (action) {
            var _this = this;
            // Indicate onBeforeRun
            this.onBeforeRun(this.commandId);
            // Use a timeout to give the quick open widget a chance to close itself first
            setTimeout(function () {
                if (action && (!(action instanceof actions_1.Action) || action.enabled)) {
                    try {
                        /* __GDPR__
                            "workbenchActionExecuted" : {
                                "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                                "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                            }
                        */
                        _this.telemetryService.publicLog('workbenchActionExecuted', { id: action.id, from: 'quick open' });
                        (action.run() || winjs_base_1.TPromise.as(null)).then(function () {
                            if (action instanceof actions_1.Action) {
                                action.dispose();
                            }
                        }, function (err) { return _this.onError(err); });
                    }
                    catch (error) {
                        _this.onError(error);
                    }
                }
                else {
                    _this.notificationService.info(nls.localize('actionNotEnabled', "Command '{0}' is not enabled in the current context.", _this.getLabel()));
                }
            }, 50);
        };
        BaseCommandEntry.prototype.onError = function (error) {
            if (errors_1.isPromiseCanceledError(error)) {
                return;
            }
            this.notificationService.error(error || nls.localize('canNotRun', "Command '{0}' resulted in an error.", this.label));
        };
        BaseCommandEntry = __decorate([
            __param(6, notification_1.INotificationService),
            __param(7, telemetry_1.ITelemetryService)
        ], BaseCommandEntry);
        return BaseCommandEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    var EditorActionCommandEntry = /** @class */ (function (_super) {
        __extends(EditorActionCommandEntry, _super);
        function EditorActionCommandEntry(commandId, keybinding, label, meta, highlights, action, onBeforeRun, notificationService, telemetryService) {
            var _this = _super.call(this, commandId, keybinding, label, meta, highlights, onBeforeRun, notificationService, telemetryService) || this;
            _this.action = action;
            return _this;
        }
        EditorActionCommandEntry.prototype.getAction = function () {
            return this.action;
        };
        EditorActionCommandEntry = __decorate([
            __param(7, notification_1.INotificationService),
            __param(8, telemetry_1.ITelemetryService)
        ], EditorActionCommandEntry);
        return EditorActionCommandEntry;
    }(BaseCommandEntry));
    var ActionCommandEntry = /** @class */ (function (_super) {
        __extends(ActionCommandEntry, _super);
        function ActionCommandEntry(commandId, keybinding, label, alias, highlights, action, onBeforeRun, notificationService, telemetryService) {
            var _this = _super.call(this, commandId, keybinding, label, alias, highlights, onBeforeRun, notificationService, telemetryService) || this;
            _this.action = action;
            return _this;
        }
        ActionCommandEntry.prototype.getAction = function () {
            return this.action;
        };
        ActionCommandEntry = __decorate([
            __param(7, notification_1.INotificationService),
            __param(8, telemetry_1.ITelemetryService)
        ], ActionCommandEntry);
        return ActionCommandEntry;
    }(BaseCommandEntry));
    var wordFilter = filters_1.or(filters_1.matchesPrefix, filters_1.matchesWords, filters_1.matchesContiguousSubString);
    var CommandsHandler = /** @class */ (function (_super) {
        __extends(CommandsHandler, _super);
        function CommandsHandler(editorService, instantiationService, keybindingService, menuService, configurationService, extensionService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.instantiationService = instantiationService;
            _this.keybindingService = keybindingService;
            _this.menuService = menuService;
            _this.configurationService = configurationService;
            _this.extensionService = extensionService;
            _this.commandsHistory = _this.instantiationService.createInstance(CommandsHistory);
            _this.configurationService.onDidChangeConfiguration(function (e) { return _this.updateConfiguration(); });
            _this.updateConfiguration();
            return _this;
        }
        CommandsHandler.prototype.updateConfiguration = function () {
            this.commandHistoryEnabled = resolveCommandHistory(this.configurationService) > 0;
        };
        CommandsHandler.prototype.getResults = function (searchValue, token) {
            var _this = this;
            // wait for extensions being registered to cover all commands
            // also from extensions
            return this.extensionService.whenInstalledExtensionsRegistered().then(function () {
                if (token.isCancellationRequested) {
                    return new quickOpenModel_1.QuickOpenModel([]);
                }
                searchValue = searchValue.trim();
                // Remember as last command palette input
                lastCommandPaletteInput = searchValue;
                // Editor Actions
                var activeTextEditorWidget = _this.editorService.activeTextEditorWidget;
                var editorActions = [];
                if (activeTextEditorWidget && types.isFunction(activeTextEditorWidget.getSupportedActions)) {
                    editorActions = activeTextEditorWidget.getSupportedActions();
                }
                var editorEntries = _this.editorActionsToEntries(editorActions, searchValue);
                // Other Actions
                var menu = _this.editorService.invokeWithinEditorContext(function (accessor) { return _this.menuService.createMenu(actions_2.MenuId.CommandPalette, accessor.get(contextkey_1.IContextKeyService)); });
                var menuActions = menu.getActions().reduce(function (r, _a) {
                    var actions = _a[1];
                    return r.concat(actions);
                }, []).filter(function (action) { return action instanceof actions_2.MenuItemAction; });
                var commandEntries = _this.menuItemActionsToEntries(menuActions, searchValue);
                // Concat
                var entries = editorEntries.concat(commandEntries);
                // Remove duplicates
                entries = arrays.distinct(entries, function (entry) { return "" + entry.getLabel() + entry.getGroupLabel() + entry.getCommandId(); });
                // Handle label clashes
                var commandLabels = new Set();
                entries.forEach(function (entry) {
                    var commandLabel = "" + entry.getLabel() + entry.getGroupLabel();
                    if (commandLabels.has(commandLabel)) {
                        entry.setDescription(entry.getCommandId());
                    }
                    else {
                        commandLabels.add(commandLabel);
                    }
                });
                // Sort by MRU order and fallback to name otherwie
                entries = entries.sort(function (elementA, elementB) {
                    var counterA = _this.commandsHistory.peek(elementA.getCommandId());
                    var counterB = _this.commandsHistory.peek(elementB.getCommandId());
                    if (counterA && counterB) {
                        return counterA > counterB ? -1 : 1; // use more recently used command before older
                    }
                    if (counterA) {
                        return -1; // first command was used, so it wins over the non used one
                    }
                    if (counterB) {
                        return 1; // other command was used so it wins over the command
                    }
                    // both commands were never used, so we sort by name
                    return elementA.getSortLabel().localeCompare(elementB.getSortLabel());
                });
                // Introduce group marker border between recently used and others
                // only if we have recently used commands in the result set
                var firstEntry = entries[0];
                if (firstEntry && _this.commandsHistory.peek(firstEntry.getCommandId())) {
                    firstEntry.setGroupLabel(nls.localize('recentlyUsed', "recently used"));
                    for (var i = 1; i < entries.length; i++) {
                        var entry = entries[i];
                        if (!_this.commandsHistory.peek(entry.getCommandId())) {
                            entry.setShowBorder(true);
                            entry.setGroupLabel(nls.localize('morecCommands', "other commands"));
                            break;
                        }
                    }
                }
                return new quickOpenModel_1.QuickOpenModel(entries);
            });
        };
        CommandsHandler.prototype.editorActionsToEntries = function (actions, searchValue) {
            var _this = this;
            var entries = [];
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                if (action.id === ShowAllCommandsAction.ID) {
                    continue; // avoid duplicates
                }
                var label = action.label;
                if (label) {
                    // Alias for non default languages
                    var alias = (platform_1.language !== platform_1.LANGUAGE_DEFAULT) ? action.alias : null;
                    var labelHighlights = wordFilter(searchValue, label);
                    var aliasHighlights = alias ? wordFilter(searchValue, alias) : null;
                    if (labelHighlights || aliasHighlights) {
                        entries.push(this.instantiationService.createInstance(EditorActionCommandEntry, action.id, this.keybindingService.lookupKeybinding(action.id), label, alias, { label: labelHighlights, alias: aliasHighlights }, action, function (id) { return _this.onBeforeRunCommand(id); }));
                    }
                }
            }
            return entries;
        };
        CommandsHandler.prototype.onBeforeRunCommand = function (commandId) {
            // Remember in commands history
            this.commandsHistory.push(commandId);
        };
        CommandsHandler.prototype.menuItemActionsToEntries = function (actions, searchValue) {
            var _this = this;
            var entries = [];
            for (var _i = 0, actions_3 = actions; _i < actions_3.length; _i++) {
                var action = actions_3[_i];
                var title = typeof action.item.title === 'string' ? action.item.title : action.item.title.value;
                var category = void 0, label = title;
                if (action.item.category) {
                    category = typeof action.item.category === 'string' ? action.item.category : action.item.category.value;
                    label = nls.localize('cat.title', "{0}: {1}", category, title);
                }
                if (label) {
                    var labelHighlights = wordFilter(searchValue, label);
                    // Add an 'alias' in original language when running in different locale
                    var aliasTitle = (platform_1.language !== platform_1.LANGUAGE_DEFAULT && typeof action.item.title !== 'string') ? action.item.title.original : null;
                    var aliasCategory = (platform_1.language !== platform_1.LANGUAGE_DEFAULT && category && typeof action.item.category !== 'string') ? action.item.category.original : null;
                    var alias = void 0;
                    if (aliasTitle && category) {
                        alias = aliasCategory ? aliasCategory + ": " + aliasTitle : category + ": " + aliasTitle;
                    }
                    else if (aliasTitle) {
                        alias = aliasTitle;
                    }
                    var aliasHighlights = alias ? wordFilter(searchValue, alias) : null;
                    if (labelHighlights || aliasHighlights) {
                        entries.push(this.instantiationService.createInstance(ActionCommandEntry, action.id, this.keybindingService.lookupKeybinding(action.item.id), label, alias, { label: labelHighlights, alias: aliasHighlights }, action, function (id) { return _this.onBeforeRunCommand(id); }));
                    }
                }
            }
            return entries;
        };
        CommandsHandler.prototype.getAutoFocus = function (searchValue, context) {
            var autoFocusPrefixMatch = searchValue.trim();
            if (autoFocusPrefixMatch && this.commandHistoryEnabled) {
                var firstEntry = context.model && context.model.entries[0];
                if (firstEntry instanceof BaseCommandEntry && this.commandsHistory.peek(firstEntry.getCommandId())) {
                    autoFocusPrefixMatch = void 0; // keep focus on MRU element if we have history elements
                }
            }
            return {
                autoFocusFirstEntry: true,
                autoFocusPrefixMatch: autoFocusPrefixMatch
            };
        };
        CommandsHandler.prototype.getEmptyLabel = function (searchString) {
            return nls.localize('noCommandsMatching', "No commands matching");
        };
        CommandsHandler.ID = 'workbench.picker.commands';
        CommandsHandler = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, keybinding_1.IKeybindingService),
            __param(3, actions_2.IMenuService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, extensions_1.IExtensionService)
        ], CommandsHandler);
        return CommandsHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.CommandsHandler = CommandsHandler;
    editorExtensions_1.registerEditorAction(CommandPaletteEditorAction);
});

define(__m[183/*vs/workbench/services/extensions/common/extensionsRegistry*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,25/*vs/base/common/errors*/,196/*vs/base/common/severity*/,198/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,9/*vs/platform/registry/common/platform*/,122/*vs/platform/extensionManagement/common/extensionManagement*/]), function (require, exports, nls, errors_1, severity_1, jsonContributionRegistry_1, platform_1, extensionManagement_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ExtensionMessageCollector = /** @class */ (function () {
        function ExtensionMessageCollector(messageHandler, extension, extensionPointId) {
            this._messageHandler = messageHandler;
            this._extension = extension;
            this._extensionPointId = extensionPointId;
        }
        ExtensionMessageCollector.prototype._msg = function (type, message) {
            this._messageHandler({
                type: type,
                message: message,
                extensionId: this._extension.id,
                extensionPointId: this._extensionPointId
            });
        };
        ExtensionMessageCollector.prototype.error = function (message) {
            this._msg(severity_1.default.Error, message);
        };
        ExtensionMessageCollector.prototype.warn = function (message) {
            this._msg(severity_1.default.Warning, message);
        };
        ExtensionMessageCollector.prototype.info = function (message) {
            this._msg(severity_1.default.Info, message);
        };
        return ExtensionMessageCollector;
    }());
    exports.ExtensionMessageCollector = ExtensionMessageCollector;
    var ExtensionPoint = /** @class */ (function () {
        function ExtensionPoint(name) {
            this.name = name;
            this._handler = null;
            this._users = null;
            this._done = false;
        }
        ExtensionPoint.prototype.setHandler = function (handler) {
            if (this._handler !== null || this._done) {
                throw new Error('Handler already set!');
            }
            this._handler = handler;
            this._handle();
        };
        ExtensionPoint.prototype.acceptUsers = function (users) {
            if (this._users !== null || this._done) {
                throw new Error('Users already set!');
            }
            this._users = users;
            this._handle();
        };
        ExtensionPoint.prototype._handle = function () {
            if (this._handler === null || this._users === null) {
                return;
            }
            this._done = true;
            var handler = this._handler;
            this._handler = null;
            var users = this._users;
            this._users = null;
            try {
                handler(users);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
            }
        };
        return ExtensionPoint;
    }());
    exports.ExtensionPoint = ExtensionPoint;
    var schemaId = 'vscode://schemas/vscode-extensions';
    exports.schema = {
        properties: {
            engines: {
                type: 'object',
                description: nls.localize('vscode.extension.engines', "Engine compatibility."),
                properties: {
                    'vscode': {
                        type: 'string',
                        description: nls.localize('vscode.extension.engines.vscode', 'For VS Code extensions, specifies the VS Code version that the extension is compatible with. Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.'),
                        default: '^1.22.0',
                    }
                }
            },
            publisher: {
                description: nls.localize('vscode.extension.publisher', 'The publisher of the VS Code extension.'),
                type: 'string'
            },
            displayName: {
                description: nls.localize('vscode.extension.displayName', 'The display name for the extension used in the VS Code gallery.'),
                type: 'string'
            },
            categories: {
                description: nls.localize('vscode.extension.categories', 'The categories used by the VS Code gallery to categorize the extension.'),
                type: 'array',
                uniqueItems: true,
                items: {
                    oneOf: [{
                            type: 'string',
                            enum: ['Programming Languages', 'Snippets', 'Linters', 'Themes', 'Debuggers', 'Other', 'Keymaps', 'Formatters', 'Extension Packs', 'SCM Providers', 'Azure', 'Language Packs'],
                        },
                        {
                            type: 'string',
                            const: 'Languages',
                            deprecationMessage: nls.localize('vscode.extension.category.languages.deprecated', 'Use \'Programming  Languages\' instead'),
                        }]
                }
            },
            galleryBanner: {
                type: 'object',
                description: nls.localize('vscode.extension.galleryBanner', 'Banner used in the VS Code marketplace.'),
                properties: {
                    color: {
                        description: nls.localize('vscode.extension.galleryBanner.color', 'The banner color on the VS Code marketplace page header.'),
                        type: 'string'
                    },
                    theme: {
                        description: nls.localize('vscode.extension.galleryBanner.theme', 'The color theme for the font used in the banner.'),
                        type: 'string',
                        enum: ['dark', 'light']
                    }
                }
            },
            contributes: {
                description: nls.localize('vscode.extension.contributes', 'All contributions of the VS Code extension represented by this package.'),
                type: 'object',
                properties: {
                // extensions will fill in
                },
                default: {}
            },
            preview: {
                type: 'boolean',
                description: nls.localize('vscode.extension.preview', 'Sets the extension to be flagged as a Preview in the Marketplace.'),
            },
            activationEvents: {
                description: nls.localize('vscode.extension.activationEvents', 'Activation events for the VS Code extension.'),
                type: 'array',
                items: {
                    type: 'string',
                    defaultSnippets: [
                        {
                            label: 'onLanguage',
                            description: nls.localize('vscode.extension.activationEvents.onLanguage', 'An activation event emitted whenever a file that resolves to the specified language gets opened.'),
                            body: 'onLanguage:${1:languageId}'
                        },
                        {
                            label: 'onCommand',
                            description: nls.localize('vscode.extension.activationEvents.onCommand', 'An activation event emitted whenever the specified command gets invoked.'),
                            body: 'onCommand:${2:commandId}'
                        },
                        {
                            label: 'onDebug',
                            description: nls.localize('vscode.extension.activationEvents.onDebug', 'An activation event emitted whenever a user is about to start debugging or about to setup debug configurations.'),
                            body: 'onDebug'
                        },
                        {
                            label: 'onDebugInitialConfigurations',
                            description: nls.localize('vscode.extension.activationEvents.onDebugInitialConfigurations', 'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).'),
                            body: 'onDebugInitialConfigurations'
                        },
                        {
                            label: 'onDebugResolve',
                            description: nls.localize('vscode.extension.activationEvents.onDebugResolve', 'An activation event emitted whenever a debug session with the specific type is about to be launched (and a corresponding resolveDebugConfiguration method needs to be called).'),
                            body: 'onDebugResolve:${6:type}'
                        },
                        {
                            label: 'workspaceContains',
                            description: nls.localize('vscode.extension.activationEvents.workspaceContains', 'An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern.'),
                            body: 'workspaceContains:${4:filePattern}'
                        },
                        {
                            label: 'onFileSystem',
                            description: nls.localize('vscode.extension.activationEvents.onFileSystem', 'An activation event emitted whenever a file or folder is accessed with the given scheme.'),
                            body: 'onFileSystem:${1:scheme}'
                        },
                        {
                            label: 'onSearch',
                            description: nls.localize('vscode.extension.activationEvents.onSearch', 'An activation event emitted whenever a search is started in the folder with the given scheme.'),
                            body: 'onSearch:${7:scheme}'
                        },
                        {
                            label: 'onView',
                            body: 'onView:${5:viewId}',
                            description: nls.localize('vscode.extension.activationEvents.onView', 'An activation event emitted whenever the specified view is expanded.'),
                        },
                        {
                            label: 'onUri',
                            body: 'onUri',
                            description: nls.localize('vscode.extension.activationEvents.onUri', 'An activation event emitted whenever a system-wide Uri directed towards this extension is open.'),
                        },
                        {
                            label: '*',
                            description: nls.localize('vscode.extension.activationEvents.star', 'An activation event emitted on VS Code startup. To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case.'),
                            body: '*'
                        }
                    ],
                }
            },
            badges: {
                type: 'array',
                description: nls.localize('vscode.extension.badges', 'Array of badges to display in the sidebar of the Marketplace\'s extension page.'),
                items: {
                    type: 'object',
                    required: ['url', 'href', 'description'],
                    properties: {
                        url: {
                            type: 'string',
                            description: nls.localize('vscode.extension.badges.url', 'Badge image URL.')
                        },
                        href: {
                            type: 'string',
                            description: nls.localize('vscode.extension.badges.href', 'Badge link.')
                        },
                        description: {
                            type: 'string',
                            description: nls.localize('vscode.extension.badges.description', 'Badge description.')
                        }
                    }
                }
            },
            markdown: {
                type: 'string',
                description: nls.localize('vscode.extension.markdown', "Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard."),
                enum: ['github', 'standard'],
                default: 'github'
            },
            qna: {
                default: 'marketplace',
                description: nls.localize('vscode.extension.qna', "Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether."),
                anyOf: [
                    {
                        type: ['string', 'boolean'],
                        enum: ['marketplace', false]
                    },
                    {
                        type: 'string'
                    }
                ]
            },
            extensionDependencies: {
                description: nls.localize('vscode.extension.extensionDependencies', 'Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.'),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    pattern: extensionManagement_1.EXTENSION_IDENTIFIER_PATTERN
                }
            },
            extensionPack: {
                description: nls.localize('vscode.extension.contributes.extensionPack', "A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp."),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    pattern: extensionManagement_1.EXTENSION_IDENTIFIER_PATTERN
                }
            },
            scripts: {
                type: 'object',
                properties: {
                    'vscode:prepublish': {
                        description: nls.localize('vscode.extension.scripts.prepublish', 'Script executed before the package is published as a VS Code extension.'),
                        type: 'string'
                    },
                    'vscode:uninstall': {
                        description: nls.localize('vscode.extension.scripts.uninstall', 'Uninstall hook for VS Code extension. Script that gets executed when the extension is completely uninstalled from VS Code which is when VS Code is restarted (shutdown and start) after the extension is uninstalled. Only Node scripts are supported.'),
                        type: 'string'
                    }
                }
            },
            icon: {
                type: 'string',
                description: nls.localize('vscode.extension.icon', 'The path to a 128x128 pixel icon.')
            }
        }
    };
    var ExtensionsRegistryImpl = /** @class */ (function () {
        function ExtensionsRegistryImpl() {
            this._extensionPoints = {};
        }
        ExtensionsRegistryImpl.prototype.registerExtensionPoint = function (extensionPoint, deps, jsonSchema) {
            if (hasOwnProperty.call(this._extensionPoints, extensionPoint)) {
                throw new Error('Duplicate extension point: ' + extensionPoint);
            }
            var result = new ExtensionPoint(extensionPoint);
            this._extensionPoints[extensionPoint] = result;
            exports.schema.properties['contributes'].properties[extensionPoint] = jsonSchema;
            schemaRegistry.registerSchema(schemaId, exports.schema);
            return result;
        };
        ExtensionsRegistryImpl.prototype.getExtensionPoints = function () {
            var _this = this;
            return Object.keys(this._extensionPoints).map(function (point) { return _this._extensionPoints[point]; });
        };
        return ExtensionsRegistryImpl;
    }());
    exports.ExtensionsRegistryImpl = ExtensionsRegistryImpl;
    var PRExtensions = {
        ExtensionsRegistry: 'ExtensionsRegistry'
    };
    platform_1.Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
    exports.ExtensionsRegistry = platform_1.Registry.as(PRExtensions.ExtensionsRegistry);
    schemaRegistry.registerSchema(schemaId, exports.schema);
});

define(__m[303/*vs/workbench/services/extensions/node/proxyIdentifier*/], __M([0/*require*/,1/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProxyIdentifier = /** @class */ (function () {
        function ProxyIdentifier(isMain, sid) {
            this.isMain = isMain;
            this.sid = sid;
            this.nid = (++ProxyIdentifier.count);
        }
        ProxyIdentifier.count = 0;
        return ProxyIdentifier;
    }());
    exports.ProxyIdentifier = ProxyIdentifier;
    var identifiers = [];
    function createMainContextProxyIdentifier(identifier) {
        var result = new ProxyIdentifier(true, identifier);
        identifiers[result.nid] = result;
        return result;
    }
    exports.createMainContextProxyIdentifier = createMainContextProxyIdentifier;
    function createExtHostContextProxyIdentifier(identifier) {
        var result = new ProxyIdentifier(false, identifier);
        identifiers[result.nid] = result;
        return result;
    }
    exports.createExtHostContextProxyIdentifier = createExtHostContextProxyIdentifier;
    function getStringIdentifierForProxy(nid) {
        return identifiers[nid].sid;
    }
    exports.getStringIdentifierForProxy = getStringIdentifierForProxy;
});

define(__m[304/*vs/workbench/api/node/extHost.protocol*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,303/*vs/workbench/services/extensions/node/proxyIdentifier*/]), function (require, exports, uri_1, proxyIdentifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var ObjectIdentifier;
    (function (ObjectIdentifier) {
        ObjectIdentifier.name = '$ident';
        function mixin(obj, id) {
            Object.defineProperty(obj, ObjectIdentifier.name, { value: id, enumerable: true });
            return obj;
        }
        ObjectIdentifier.mixin = mixin;
        function of(obj) {
            return obj[ObjectIdentifier.name];
        }
        ObjectIdentifier.of = of;
    })(ObjectIdentifier = exports.ObjectIdentifier || (exports.ObjectIdentifier = {}));
    var IdObject = /** @class */ (function () {
        function IdObject() {
        }
        IdObject.mixin = function (object) {
            object._id = IdObject._n++;
            return object;
        };
        IdObject._n = 0;
        return IdObject;
    }());
    exports.IdObject = IdObject;
    function reviveWorkspaceEditDto(data) {
        if (data && data.edits) {
            for (var _i = 0, _a = data.edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (typeof edit.resource === 'object') {
                    edit.resource = uri_1.URI.revive(edit.resource);
                }
                else {
                    edit.newUri = uri_1.URI.revive(edit.newUri);
                    edit.oldUri = uri_1.URI.revive(edit.oldUri);
                }
            }
        }
        return data;
    }
    exports.reviveWorkspaceEditDto = reviveWorkspaceEditDto;
    // --- proxy identifiers
    exports.MainContext = {
        MainThreadCommands: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadCommands'),
        MainThreadComments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadComments'),
        MainThreadConfiguration: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadConfiguration'),
        // MainThreadDebugService: createMainId<MainThreadDebugServiceShape>('MainThreadDebugService'),
        MainThreadDecorations: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDecorations'),
        MainThreadDiagnostics: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiagnostics'),
        MainThreadDialogs: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiaglogs'),
        MainThreadDocuments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocuments'),
        MainThreadDocumentContentProviders: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocumentContentProviders'),
        MainThreadTextEditors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTextEditors'),
        MainThreadErrors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadErrors'),
        MainThreadTreeViews: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTreeViews'),
        MainThreadLanguageFeatures: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguageFeatures'),
        MainThreadLanguages: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguages'),
        MainThreadMessageService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadMessageService'),
        MainThreadOutputService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadOutputService'),
        MainThreadProgress: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadProgress'),
        MainThreadQuickOpen: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadQuickOpen'),
        // MainThreadStatusBar: createMainId<MainThreadStatusBarShape>('MainThreadStatusBar'),
        MainThreadStorage: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadStorage'),
        MainThreadTelemetry: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTelemetry'),
        // MainThreadTerminalService: createMainId<MainThreadTerminalServiceShape>('MainThreadTerminalService'),
        // MainThreadWebviews: createMainId<MainThreadWebviewsShape>('MainThreadWebviews'),
        // MainThreadUrls: createMainId<MainThreadUrlsShape>('MainThreadUrls'),
        // MainThreadWorkspace: createMainId<MainThreadWorkspaceShape>('MainThreadWorkspace'),
        MainThreadFileSystem: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadFileSystem'),
        MainThreadExtensionService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadExtensionService'),
        // MainThreadSCM: createMainId<MainThreadSCMShape>('MainThreadSCM'),
        // MainThreadSearch: createMainId<MainThreadSearchShape>('MainThreadSearch'),
        // MainThreadTask: createMainId<MainThreadTaskShape>('MainThreadTask'),
        MainThreadWindow: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWindow'),
    };
    exports.ExtHostContext = {
        ExtHostCommands: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostCommands'),
        ExtHostConfiguration: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostConfiguration'),
        ExtHostDiagnostics: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDiagnostics'),
        // ExtHostDebugService: createExtId<ExtHostDebugServiceShape>('ExtHostDebugService'),
        ExtHostDecorations: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDecorations'),
        ExtHostDocumentsAndEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentsAndEditors'),
        ExtHostDocuments: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocuments'),
        ExtHostDocumentContentProviders: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentContentProviders'),
        ExtHostDocumentSaveParticipant: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentSaveParticipant'),
        ExtHostEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostEditors'),
        ExtHostTreeViews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTreeViews'),
        ExtHostFileSystem: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystem'),
        ExtHostFileSystemEventService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystemEventService'),
        ExtHostHeapService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostHeapMonitor'),
        ExtHostLanguageFeatures: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLanguageFeatures'),
        ExtHostQuickOpen: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostQuickOpen'),
        ExtHostExtensionService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostExtensionService'),
        ExtHostLogService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLogService'),
        // ExtHostTerminalService: createExtId<ExtHostTerminalServiceShape>('ExtHostTerminalService'),
        // ExtHostSCM: createExtId<ExtHostSCMShape>('ExtHostSCM'),
        // ExtHostSearch: createExtId<ExtHostSearchShape>('ExtHostSearch'),
        // ExtHostTask: createExtId<ExtHostTaskShape>('ExtHostTask'),
        // ExtHostWorkspace: createExtId<ExtHostWorkspaceShape>('ExtHostWorkspace'),
        ExtHostWindow: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWindow'),
        // ExtHostWebviews: createExtId<ExtHostWebviewsShape>('ExtHostWebviews'),
        ExtHostProgress: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostProgress'),
        ExtHostComments: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostComments'),
        ExtHostUrls: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostUrls'),
        ExtHostOutputService: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostOutputService'),
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[305/*vs/workbench/api/electron-browser/mainThreadHeapService*/], __M([0/*require*/,1/*exports*/,304/*vs/workbench/api/node/extHost.protocol*/,3/*vs/platform/instantiation/common/instantiation*/,80/*vs/platform/instantiation/common/extensions*/,6/*vs/base/common/event*/,271/*vs/workbench/api/electron-browser/extHostCustomers*/,17/*vs/base/common/async*/,469/*util*/]), function (require, exports, extHost_protocol_1, instantiation_1, extensions_1, event_1, extHostCustomers_1, async_1, util_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeapService = instantiation_1.createDecorator('heapService');
    var HeapService = /** @class */ (function () {
        function HeapService() {
            this._onGarbageCollection = new event_1.Emitter();
            this.onGarbageCollection = this._onGarbageCollection.event;
            this._activeSignals = new WeakMap();
            this._activeIds = new Set();
            //
        }
        HeapService.prototype.dispose = function () {
            clearInterval(this._consumeHandle);
        };
        HeapService.prototype.trackRecursive = function (obj) {
            var _this = this;
            if (async_1.isThenable(obj)) {
                return obj.then(function (result) { return _this.trackRecursive(result); });
            }
            else {
                return this._doTrackRecursive(obj);
            }
        };
        HeapService.prototype._doTrackRecursive = function (obj) {
            var _this = this;
            if (util_1.isNullOrUndefined(obj)) {
                return Promise.resolve(obj);
            }
            return new Promise(function (resolve_1, reject_1) { require(['gc-signals'], resolve_1, reject_1); }).then(function (_a) {
                var GCSignal = _a.GCSignal, consumeSignals = _a.consumeSignals;
                if (_this._consumeHandle === void 0) {
                    // ensure that there is one consumer of signals
                    _this._consumeHandle = setInterval(function () {
                        var ids = consumeSignals();
                        if (ids.length > 0) {
                            // local book-keeping
                            for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                                var id = ids_1[_i];
                                _this._activeIds.delete(id);
                            }
                            // fire event
                            _this._onGarbageCollection.fire(ids);
                        }
                    }, 15 * 1000);
                }
                var stack = [obj];
                while (stack.length > 0) {
                    // remove first element
                    var obj_1 = stack.shift();
                    if (!obj_1 || typeof obj_1 !== 'object') {
                        continue;
                    }
                    for (var key in obj_1) {
                        if (!Object.prototype.hasOwnProperty.call(obj_1, key)) {
                            continue;
                        }
                        var value = obj_1[key];
                        // recurse -> object/array
                        if (typeof value === 'object') {
                            stack.push(value);
                        }
                        else if (key === extHost_protocol_1.ObjectIdentifier.name) {
                            // track new $ident-objects
                            if (typeof value === 'number' && !_this._activeIds.has(value)) {
                                _this._activeIds.add(value);
                                _this._activeSignals.set(obj_1, new GCSignal(value));
                            }
                        }
                    }
                }
                return obj;
            });
        };
        return HeapService;
    }());
    exports.HeapService = HeapService;
    var MainThreadHeapService = /** @class */ (function () {
        function MainThreadHeapService(extHostContext, heapService) {
            var proxy = extHostContext.getProxy(extHost_protocol_1.ExtHostContext.ExtHostHeapService);
            this._toDispose = heapService.onGarbageCollection(function (ids) {
                // send to ext host
                proxy.$onGarbageCollection(ids);
            });
        }
        MainThreadHeapService.prototype.dispose = function () {
            this._toDispose.dispose();
        };
        MainThreadHeapService = __decorate([
            extHostCustomers_1.extHostCustomer,
            __param(1, exports.IHeapService)
        ], MainThreadHeapService);
        return MainThreadHeapService;
    }());
    exports.MainThreadHeapService = MainThreadHeapService;
    extensions_1.registerSingleton(exports.IHeapService, HeapService);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[307/*vs/workbench/services/files/node/watcher/common*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,16/*vs/platform/files/common/files*/,18/*vs/base/common/platform*/]), function (require, exports, uri_1, files_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function toFileChangesEvent(changes) {
        // map to file changes event that talks about URIs
        return new files_1.FileChangesEvent(changes.map(function (c) {
            return {
                type: c.type,
                resource: uri_1.URI.file(c.path)
            };
        }));
    }
    exports.toFileChangesEvent = toFileChangesEvent;
    /**
     * Given events that occurred, applies some rules to normalize the events
     */
    function normalize(changes) {
        // Build deltas
        var normalizer = new EventNormalizer();
        for (var i = 0; i < changes.length; i++) {
            var event_1 = changes[i];
            normalizer.processEvent(event_1);
        }
        return normalizer.normalize();
    }
    exports.normalize = normalize;
    var EventNormalizer = /** @class */ (function () {
        function EventNormalizer() {
            this.normalized = [];
            this.mapPathToChange = Object.create(null);
        }
        EventNormalizer.prototype.processEvent = function (event) {
            // Event path already exists
            var existingEvent = this.mapPathToChange[event.path];
            if (existingEvent) {
                var currentChangeType = existingEvent.type;
                var newChangeType = event.type;
                // ignore CREATE followed by DELETE in one go
                if (currentChangeType === 1 /* ADDED */ && newChangeType === 2 /* DELETED */) {
                    delete this.mapPathToChange[event.path];
                    this.normalized.splice(this.normalized.indexOf(existingEvent), 1);
                }
                // flatten DELETE followed by CREATE into CHANGE
                else if (currentChangeType === 2 /* DELETED */ && newChangeType === 1 /* ADDED */) {
                    existingEvent.type = 0 /* UPDATED */;
                }
                // Do nothing. Keep the created event
                else if (currentChangeType === 1 /* ADDED */ && newChangeType === 0 /* UPDATED */) {
                }
                // Otherwise apply change type
                else {
                    existingEvent.type = newChangeType;
                }
            }
            // Otherwise Store
            else {
                this.normalized.push(event);
                this.mapPathToChange[event.path] = event;
            }
        };
        EventNormalizer.prototype.normalize = function () {
            var addedChangeEvents = [];
            var deletedPaths = [];
            // This algorithm will remove all DELETE events up to the root folder
            // that got deleted if any. This ensures that we are not producing
            // DELETE events for each file inside a folder that gets deleted.
            //
            // 1.) split ADD/CHANGE and DELETED events
            // 2.) sort short deleted paths to the top
            // 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case
            return this.normalized.filter(function (e) {
                if (e.type !== 2 /* DELETED */) {
                    addedChangeEvents.push(e);
                    return false; // remove ADD / CHANGE
                }
                return true; // keep DELETE
            }).sort(function (e1, e2) {
                return e1.path.length - e2.path.length; // shortest path first
            }).filter(function (e) {
                if (deletedPaths.some(function (d) { return files_1.isParent(e.path, d, !platform_1.isLinux /* ignorecase */); })) {
                    return false; // DELETE is ignored if parent is deleted already
                }
                // otherwise mark as deleted
                deletedPaths.push(e.path);
                return true;
            }).concat(addedChangeEvents);
        };
        return EventNormalizer;
    }());
});





































































define(__m[308/*vs/codesandbox/fileService*/], __M([0/*require*/,1/*exports*/,468/*fs*/,464/*vs/base/node/extfs*/,12/*vs/base/common/uri*/,16/*vs/platform/files/common/files*/,5/*vs/base/common/winjs.base*/,4/*vs/base/common/lifecycle*/,6/*vs/base/common/event*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/,78/*path*/,26/*vs/base/common/network*/,24/*vs/base/common/paths*/,307/*vs/workbench/services/files/node/watcher/common*/,39/*vs/base/common/map*/,17/*vs/base/common/async*/,63/*vs/platform/lifecycle/common/lifecycle*/]), function (require, exports, fs, extfs, uri_1, files_1, winjs_base_1, lifecycle_1, event_1, codesandbox_1, path_1, network_1, paths_1, common_1, map_1, async_1, lifecycle_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var generateRandomCallbackID = function () {
        return 'cb-' + Math.floor(Math.random() * 10000);
    };
    var createStreamFromString = function (value) { return ({
        on: function (e, cb) {
            if (e === 'data') {
                cb(value);
            }
            if (e === 'end') {
                cb();
            }
        },
    }); };
    var createFileFromModule = function (p, m) {
        return m
            ? {
                isDirectory: false,
                resource: uri_1.URI.file(p),
                etag: undefined,
                mtime: new Date(m.updatedAt).getTime(),
                name: path_1.basename(p),
            }
            : {
                isDirectory: true,
                resource: uri_1.URI.file(p),
                etag: undefined,
                mtime: new Date().getTime(),
                name: p,
            };
    };
    function doFsStat(resource) {
        var _this = this;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            fs.stat(resource.fsPath, function (err, stat) { return __awaiter(_this, void 0, void 0, function () {
                var children, childrenFolders, resolvedChildren;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (err) {
                                return [2 /*return*/, reject(err)];
                            }
                            children = [];
                            if (stat.isDirectory()) {
                                childrenFolders = fs.readdirSync(resource.fsPath);
                                childrenFolders.forEach(function (p) {
                                    var joinedFolder = paths_1.join(resource.fsPath, p);
                                    children.push(uri_1.URI.file(joinedFolder));
                                });
                            }
                            return [4 /*yield*/, Promise.all(children.map(doFsStat))];
                        case 1:
                            resolvedChildren = _a.sent();
                            return [2 /*return*/, resolve({
                                    isDirectory: stat.isDirectory(),
                                    mtime: stat.mtime.getTime(),
                                    size: stat.size,
                                    resource: resource,
                                    name: path_1.basename(resource.fsPath),
                                    etag: undefined,
                                    children: resolvedChildren,
                                })];
                    }
                });
            }); });
        });
    }
    var CodeSandboxFileService = /** @class */ (function (_super) {
        __extends(CodeSandboxFileService, _super);
        function CodeSandboxFileService(codesandboxService, lifecycleService) {
            var _this = _super.call(this) || this;
            _this.codesandboxService = codesandboxService;
            _this.lifecycleService = lifecycleService;
            _this._onFileChanges = _this._register(new event_1.Emitter());
            _this._onAfterOperation = _this._register(new event_1.Emitter());
            _this._onDidChangeFileSystemProviderRegistrations = _this._register(new event_1.Emitter());
            _this.activeFileChangesWatchers = new map_1.ResourceMap();
            _this.fileChangesWatchDelayer = new async_1.ThrottledDelayer(CodeSandboxFileService.FS_EVENT_DELAY);
            _this.undeliveredRawFileChangesEvents = [];
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(CodeSandboxFileService.prototype, "onFileChanges", {
            get: function () {
                return this._onFileChanges.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxFileService.prototype, "onAfterOperation", {
            get: function () {
                return this._onAfterOperation.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSandboxFileService.prototype, "onDidChangeFileSystemProviderRegistrations", {
            get: function () {
                return this._onDidChangeFileSystemProviderRegistrations.event;
            },
            enumerable: true,
            configurable: true
        });
        CodeSandboxFileService.prototype.registerListeners = function () {
            // Wait until we are fully running before starting file watchers
            this.lifecycleService.when(3 /* Running */).then(function () {
                // this.setupFileWatching();
            });
            // Lifecycle
            this.lifecycleService.onShutdown(this.dispose, this);
        };
        CodeSandboxFileService.prototype.registerProvider = function (scheme, provider) {
            throw new Error('Method not implemented.');
        };
        CodeSandboxFileService.prototype.canHandleResource = function (resource) {
            return resource.scheme === network_1.Schemas.file;
        };
        CodeSandboxFileService.prototype.resolveFile = function (resource, options) {
            return doFsStat(resource);
        };
        CodeSandboxFileService.prototype.resolveFiles = function (toResolve) {
            throw new Error('resolveFiles not implemented.');
        };
        CodeSandboxFileService.prototype.existsFile = function (resource) {
            return new winjs_base_1.TPromise(function (r) {
                fs.stat(resource.fsPath, function (err, stats) {
                    if (err) {
                        r(false);
                        return;
                    }
                    r(true);
                });
            });
        };
        CodeSandboxFileService.prototype.resolveContent = function (resource, options) {
            return new winjs_base_1.TPromise(function (resolve, reject) {
                fs.stat(resource.fsPath, function (err, stat) {
                    if (err) {
                        // Wrap file not found errors
                        if (err.code === 'ENOENT') {
                            return reject(new files_1.FileOperationError("File not found (" + resource.toString(true) + ")", 2 /* FILE_NOT_FOUND */, options));
                        }
                        return reject(err);
                    }
                    fs.readFile(resource.fsPath, function (err, data) {
                        resolve({
                            encoding: 'utf8',
                            value: data.toString(),
                            name: path_1.basename(resource.fsPath),
                            resource: uri_1.URI.file(resource.fsPath),
                            etag: undefined,
                            isReadonly: false,
                            mtime: stat.mtime.getTime(),
                        });
                    });
                });
            });
        };
        CodeSandboxFileService.prototype.resolveStreamContent = function (resource, options) {
            return this.resolveContent(resource, options).then(function (syncValue) {
                var asyncValue = __assign({}, syncValue, { value: createStreamFromString(syncValue.value) });
                return asyncValue;
            });
        };
        CodeSandboxFileService.prototype.updateContent = function (resource, value, options) {
            var _this = this;
            if (resource.fsPath.indexOf('/vscode/') === 0) {
                // @ts-ignore
                var strValue_1 = value.read ? value.read() : value;
                return new winjs_base_1.TPromise(function (resolve, reject) {
                    fs.writeFile(resource.fsPath, strValue_1, function (err) {
                        if (err) {
                            reject(err);
                        }
                        fs.stat(resource.fsPath, function (err, stats) {
                            resolve({
                                isDirectory: stats.isDirectory(),
                                resource: uri_1.URI.file(resource.fsPath),
                                etag: undefined,
                                mtime: stats.mtime.getTime(),
                                name: path_1.basename(resource.fsPath),
                            });
                        });
                    });
                });
            }
            var module = this.codesandboxService.getFilesByPath()[resource.fsPath];
            //@ts-ignore
            var code = value.read ? value.read() : value;
            var cbID = generateRandomCallbackID();
            fs.writeFileSync(resource.fsPath, code);
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var _a;
                window.cbs = window.cbs || {};
                window.cbs[cbID] = function (err, data) {
                    if (err) {
                        return reject(null);
                    }
                    var module = _this.codesandboxService.getFilesByPath()[resource.fsPath];
                    resolve(createFileFromModule(resource.fsPath, module));
                };
                if (module) {
                    _this.codesandboxService.runSignal('editor.codeSaved', {
                        cbID: cbID,
                        code: code,
                        moduleShortid: module.shortid,
                    });
                }
                else {
                    _this.codesandboxService.runSignal('files.createModulesByPath', {
                        cbID: cbID,
                        files: (_a = {},
                            _a[resource.fsPath.replace(/^\/sandbox/, '')] = {
                                isBinary: false,
                                content: code,
                            },
                            _a),
                    });
                }
            });
        };
        CodeSandboxFileService.prototype.moveFile = function (source, target, overwrite) {
            throw new Error('moveFile not implemented.');
        };
        CodeSandboxFileService.prototype.copyFile = function (source, target, overwrite) {
            throw new Error('copyFile not implemented.');
        };
        CodeSandboxFileService.prototype.createFile = function (resource, content, options) {
            throw new Error('createFile not implemented.');
        };
        CodeSandboxFileService.prototype.createFolder = function (resource) {
            if (resource.fsPath.indexOf('/vscode') === 0) {
                try {
                    fs.mkdirSync(resource.fsPath);
                }
                catch (e) {
                    // ignore
                }
                return doFsStat(resource);
            }
            throw new Error('createFolder not implemented.');
        };
        CodeSandboxFileService.prototype.del = function (resource, options) {
            throw new Error('del not implemented.');
        };
        CodeSandboxFileService.prototype.watchFileChanges = function (resource) {
            var _this = this;
            if (!(resource && resource.scheme === network_1.Schemas.file)) {
                return;
            }
            // Check for existing watcher first
            var entry = this.activeFileChangesWatchers.get(resource);
            if (entry) {
                entry.count += 1;
                return;
            }
            // Create or get watcher for provided path
            var fsPath = resource.fsPath;
            var fsName = path_1.basename(resource.fsPath);
            var watcherDisposable = extfs.watch(fsPath, function (eventType, filename) {
                var renamedOrDeleted = (filename && filename !== fsName) || eventType === 'rename';
                // The file was either deleted or renamed. Many tools apply changes to files in an
                // atomic way ("Atomic Save") by first renaming the file to a temporary name and then
                // renaming it back to the original name. Our watcher will detect this as a rename
                // and then stops to work on Mac and Linux because the watcher is applied to the
                // inode and not the name. The fix is to detect this case and trying to watch the file
                // again after a certain delay.
                // In addition, we send out a delete event if after a timeout we detect that the file
                // does indeed not exist anymore.
                if (renamedOrDeleted) {
                    // Very important to dispose the watcher which now points to a stale inode
                    watcherDisposable.dispose();
                    _this.activeFileChangesWatchers.delete(resource);
                    // Wait a bit and try to install watcher again, assuming that the file was renamed quickly ("Atomic Save")
                    setTimeout(function () {
                        _this.existsFile(resource).then(function (exists) {
                            // File still exists, so reapply the watcher
                            if (exists) {
                                _this.watchFileChanges(resource);
                            }
                            else {
                                // File seems to be really gone, so emit a deleted event
                                _this.onRawFileChange({
                                    type: 2 /* DELETED */,
                                    path: fsPath,
                                });
                            }
                        });
                    }, CodeSandboxFileService.FS_REWATCH_DELAY);
                }
                // Handle raw file change
                _this.onRawFileChange({
                    type: 0 /* UPDATED */,
                    path: fsPath,
                });
            }, function (error) { return new Error(error); });
            // Remember in map
            this.activeFileChangesWatchers.set(resource, {
                count: 1,
                unwatch: function () { return watcherDisposable.dispose(); },
            });
        };
        CodeSandboxFileService.prototype.onRawFileChange = function (event) {
            var _this = this;
            // add to bucket of undelivered events
            this.undeliveredRawFileChangesEvents.push(event);
            // handle emit through delayer to accommodate for bulk changes
            this.fileChangesWatchDelayer.trigger(function () {
                var buffer = _this.undeliveredRawFileChangesEvents;
                _this.undeliveredRawFileChangesEvents = [];
                // Normalize
                var normalizedEvents = common_1.normalize(buffer);
                // Emit
                _this._onFileChanges.fire(common_1.toFileChangesEvent(normalizedEvents));
                return winjs_base_1.TPromise.as(null);
            });
        };
        CodeSandboxFileService.prototype.unwatchFileChanges = function (resource) {
            var watcher = this.activeFileChangesWatchers.get(resource);
            if (watcher && --watcher.count === 0) {
                watcher.unwatch();
                this.activeFileChangesWatchers.delete(resource);
            }
        };
        CodeSandboxFileService.FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)
        CodeSandboxFileService.FS_REWATCH_DELAY = 300; // delay to rewatch a file that was renamed or deleted (in ms)
        CodeSandboxFileService = __decorate([
            __param(0, codesandbox_1.ICodeSandboxService),
            __param(1, lifecycle_2.ILifecycleService)
        ], CodeSandboxFileService);
        return CodeSandboxFileService;
    }(lifecycle_1.Disposable));
    exports.CodeSandboxFileService = CodeSandboxFileService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[33/*vs/workbench/services/group/common/editorGroupsService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEditorGroupsService = instantiation_1.createDecorator('editorGroupsService');
    function preferredSideBySideGroupDirection(configurationService) {
        var openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');
        if (openSideBySideDirection === 'down') {
            return 1 /* DOWN */;
        }
        return 3 /* RIGHT */;
    }
    exports.preferredSideBySideGroupDirection = preferredSideBySideGroupDirection;
});























define(__m[312/*vs/workbench/browser/actions/toggleEditorLayout*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,4/*vs/base/common/lifecycle*/,37/*vs/platform/commands/common/commands*/,33/*vs/workbench/services/group/common/editorGroupsService*/,370/*vs/css!vs/workbench/browser/actions/media/actions*/]), function (require, exports, nls, platform_1, actions_1, actions_2, actions_3, lifecycle_1, commands_1, editorGroupsService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleEditorLayoutAction = /** @class */ (function (_super) {
        __extends(ToggleEditorLayoutAction, _super);
        function ToggleEditorLayoutAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            _this.toDispose = [];
            _this.class = 'flip-editor-layout';
            _this.updateEnablement();
            _this.registerListeners();
            return _this;
        }
        ToggleEditorLayoutAction.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(this.editorGroupService.onDidAddGroup(function () { return _this.updateEnablement(); }));
            this.toDispose.push(this.editorGroupService.onDidRemoveGroup(function () { return _this.updateEnablement(); }));
        };
        ToggleEditorLayoutAction.prototype.updateEnablement = function () {
            this.enabled = this.editorGroupService.count > 1;
        };
        ToggleEditorLayoutAction.prototype.run = function () {
            var newOrientation = (this.editorGroupService.orientation === 1 /* VERTICAL */) ? 0 /* HORIZONTAL */ : 1 /* VERTICAL */;
            this.editorGroupService.setGroupOrientation(newOrientation);
            return Promise.resolve(null);
        };
        ToggleEditorLayoutAction.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            _super.prototype.dispose.call(this);
        };
        ToggleEditorLayoutAction.ID = 'workbench.action.toggleEditorGroupLayout';
        ToggleEditorLayoutAction.LABEL = nls.localize('flipLayout', "Toggle Vertical/Horizontal Editor Layout");
        ToggleEditorLayoutAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], ToggleEditorLayoutAction);
        return ToggleEditorLayoutAction;
    }(actions_1.Action));
    exports.ToggleEditorLayoutAction = ToggleEditorLayoutAction;
    commands_1.CommandsRegistry.registerCommand('_workbench.editor.setGroupOrientation', function (accessor, args) {
        var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
        var orientation = args[0];
        editorGroupService.setGroupOrientation(orientation);
        return Promise.resolve(null);
    });
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    var group = nls.localize('view', "View");
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleEditorLayoutAction, ToggleEditorLayoutAction.ID, ToggleEditorLayoutAction.LABEL, { primary: 1024 /* Shift */ | 512 /* Alt */ | 21 /* KEY_0 */, mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 21 /* KEY_0 */ } }), 'View: Flip Editor Group Layout', group);
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarLayoutMenu, {
        group: 'z_flip',
        command: {
            id: ToggleEditorLayoutAction.ID,
            title: nls.localize({ key: 'miToggleEditorLayout', comment: ['&& denotes a mnemonic'] }, "Flip &&Layout")
        },
        order: 1
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[94/*vs/workbench/services/hash/common/hashService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHashService = instantiation_1.createDecorator('hashService');
});























define(__m[93/*vs/workbench/common/editor/resourceEditorInput*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,13/*vs/workbench/common/editor*/,189/*vs/platform/telemetry/common/telemetryUtils*/,66/*vs/editor/common/services/resolverService*/,186/*vs/workbench/common/editor/resourceEditorModel*/,94/*vs/workbench/services/hash/common/hashService*/]), function (require, exports, winjs_base_1, editor_1, telemetryUtils_1, resolverService_1, resourceEditorModel_1, hashService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A read-only text editor input whos contents are made of the provided resource that points to an existing
     * code editor model.
     */
    var ResourceEditorInput = /** @class */ (function (_super) {
        __extends(ResourceEditorInput, _super);
        function ResourceEditorInput(name, description, resource, textModelResolverService, hashService) {
            var _this = _super.call(this) || this;
            _this.textModelResolverService = textModelResolverService;
            _this.hashService = hashService;
            _this.name = name;
            _this.description = description;
            _this.resource = resource;
            return _this;
        }
        ResourceEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        ResourceEditorInput.prototype.getTypeId = function () {
            return ResourceEditorInput.ID;
        };
        ResourceEditorInput.prototype.getName = function () {
            return this.name;
        };
        ResourceEditorInput.prototype.setName = function (name) {
            if (this.name !== name) {
                this.name = name;
                this._onDidChangeLabel.fire();
            }
        };
        ResourceEditorInput.prototype.getDescription = function () {
            return this.description;
        };
        ResourceEditorInput.prototype.setDescription = function (description) {
            if (this.description !== description) {
                this.description = description;
                this._onDidChangeLabel.fire();
            }
        };
        ResourceEditorInput.prototype.getTelemetryDescriptor = function () {
            var _this = this;
            var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
            descriptor['resource'] = telemetryUtils_1.telemetryURIDescriptor(this.resource, function (path) { return _this.hashService.createSHA1(path); });
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "resource": { "${inline}": [ "${URIDescriptor}" ] }
                }
            */
            return descriptor;
        };
        ResourceEditorInput.prototype.resolve = function () {
            var _this = this;
            if (!this.modelReference) {
                this.modelReference = this.textModelResolverService.createModelReference(this.resource);
            }
            return this.modelReference.then(function (ref) {
                var model = ref.object;
                if (!(model instanceof resourceEditorModel_1.ResourceEditorModel)) {
                    ref.dispose();
                    _this.modelReference = null;
                    return winjs_base_1.TPromise.wrapError(new Error("Unexpected model for ResourceInput: " + _this.resource));
                }
                return model;
            });
        };
        ResourceEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof ResourceEditorInput) {
                var otherResourceEditorInput = otherInput;
                // Compare by properties
                return otherResourceEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        ResourceEditorInput.prototype.dispose = function () {
            if (this.modelReference) {
                this.modelReference.then(function (ref) { return ref.dispose(); });
                this.modelReference = null;
            }
            _super.prototype.dispose.call(this);
        };
        ResourceEditorInput.ID = 'workbench.editors.resourceEditorInput';
        ResourceEditorInput = __decorate([
            __param(3, resolverService_1.ITextModelService),
            __param(4, hashService_1.IHashService)
        ], ResourceEditorInput);
        return ResourceEditorInput;
    }(editor_1.EditorInput));
    exports.ResourceEditorInput = ResourceEditorInput;
});

define(__m[124/*vs/workbench/services/history/common/history*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHistoryService = instantiation_1.createDecorator('historyService');
});

define(__m[318/*vs/workbench/services/keybinding/common/keybindingIO*/], __M([0/*require*/,1/*exports*/,10/*vs/platform/contextkey/common/contextkey*/,168/*vs/base/common/keybindingParser*/]), function (require, exports, contextkey_1, keybindingParser_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingIO = /** @class */ (function () {
        function KeybindingIO() {
        }
        KeybindingIO.writeKeybindingItem = function (out, item, OS) {
            var quotedSerializedKeybinding = JSON.stringify(item.resolvedKeybinding.getUserSettingsLabel());
            out.write("{ \"key\": " + rightPaddedString(quotedSerializedKeybinding + ',', 25) + " \"command\": ");
            var quotedSerializedWhen = item.when ? JSON.stringify(item.when.serialize()) : '';
            var quotedSerializeCommand = JSON.stringify(item.command);
            if (quotedSerializedWhen.length > 0) {
                out.write(quotedSerializeCommand + ",");
                out.writeLine();
                out.write("                                     \"when\": " + quotedSerializedWhen + " ");
            }
            else {
                out.write(quotedSerializeCommand + " ");
            }
            // out.write(String(item.weight1 + '-' + item.weight2));
            out.write('}');
        };
        KeybindingIO.readUserKeybindingItem = function (input, OS) {
            var _a = (typeof input.key === 'string' ? keybindingParser_1.KeybindingParser.parseUserBinding(input.key) : [null, null]), firstPart = _a[0], chordPart = _a[1];
            var when = (typeof input.when === 'string' ? contextkey_1.ContextKeyExpr.deserialize(input.when) : null);
            var command = (typeof input.command === 'string' ? input.command : null);
            var commandArgs = (typeof input.args !== 'undefined' ? input.args : undefined);
            return {
                firstPart: firstPart,
                chordPart: chordPart,
                command: command,
                commandArgs: commandArgs,
                when: when
            };
        };
        return KeybindingIO;
    }());
    exports.KeybindingIO = KeybindingIO;
    function rightPaddedString(str, minChars) {
        if (str.length < minChars) {
            return str + (new Array(minChars - str.length).join(' '));
        }
        return str;
    }
    var OutputBuilder = /** @class */ (function () {
        function OutputBuilder() {
            this._lines = [];
            this._currentLine = '';
        }
        OutputBuilder.prototype.write = function (str) {
            this._currentLine += str;
        };
        OutputBuilder.prototype.writeLine = function (str) {
            if (str === void 0) { str = ''; }
            this._lines.push(this._currentLine + str);
            this._currentLine = '';
        };
        OutputBuilder.prototype.toString = function () {
            this.writeLine();
            return this._lines.join('\n');
        };
        return OutputBuilder;
    }());
    exports.OutputBuilder = OutputBuilder;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[319/*vs/workbench/services/keybinding/common/macLinuxFallbackKeyboardMapper*/], __M([0/*require*/,1/*exports*/,65/*vs/base/common/keyCodes*/,320/*vs/platform/keybinding/common/usLayoutResolvedKeybinding*/,130/*vs/base/common/scanCode*/]), function (require, exports, keyCodes_1, usLayoutResolvedKeybinding_1, scanCode_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A keyboard mapper to be used when reading the keymap from the OS fails.
     */
    var MacLinuxFallbackKeyboardMapper = /** @class */ (function () {
        function MacLinuxFallbackKeyboardMapper(OS) {
            this._OS = OS;
        }
        MacLinuxFallbackKeyboardMapper.prototype.dumpDebugInfo = function () {
            return 'FallbackKeyboardMapper dispatching on keyCode';
        };
        MacLinuxFallbackKeyboardMapper.prototype.resolveKeybinding = function (keybinding) {
            return [new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(keybinding, this._OS)];
        };
        MacLinuxFallbackKeyboardMapper.prototype.resolveKeyboardEvent = function (keyboardEvent) {
            var keybinding = new keyCodes_1.SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
            return new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(keybinding, this._OS);
        };
        MacLinuxFallbackKeyboardMapper.prototype._scanCodeToKeyCode = function (scanCode) {
            var immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
            if (immutableKeyCode !== -1) {
                return immutableKeyCode;
            }
            switch (scanCode) {
                case 10 /* KeyA */: return 31 /* KEY_A */;
                case 11 /* KeyB */: return 32 /* KEY_B */;
                case 12 /* KeyC */: return 33 /* KEY_C */;
                case 13 /* KeyD */: return 34 /* KEY_D */;
                case 14 /* KeyE */: return 35 /* KEY_E */;
                case 15 /* KeyF */: return 36 /* KEY_F */;
                case 16 /* KeyG */: return 37 /* KEY_G */;
                case 17 /* KeyH */: return 38 /* KEY_H */;
                case 18 /* KeyI */: return 39 /* KEY_I */;
                case 19 /* KeyJ */: return 40 /* KEY_J */;
                case 20 /* KeyK */: return 41 /* KEY_K */;
                case 21 /* KeyL */: return 42 /* KEY_L */;
                case 22 /* KeyM */: return 43 /* KEY_M */;
                case 23 /* KeyN */: return 44 /* KEY_N */;
                case 24 /* KeyO */: return 45 /* KEY_O */;
                case 25 /* KeyP */: return 46 /* KEY_P */;
                case 26 /* KeyQ */: return 47 /* KEY_Q */;
                case 27 /* KeyR */: return 48 /* KEY_R */;
                case 28 /* KeyS */: return 49 /* KEY_S */;
                case 29 /* KeyT */: return 50 /* KEY_T */;
                case 30 /* KeyU */: return 51 /* KEY_U */;
                case 31 /* KeyV */: return 52 /* KEY_V */;
                case 32 /* KeyW */: return 53 /* KEY_W */;
                case 33 /* KeyX */: return 54 /* KEY_X */;
                case 34 /* KeyY */: return 55 /* KEY_Y */;
                case 35 /* KeyZ */: return 56 /* KEY_Z */;
                case 36 /* Digit1 */: return 22 /* KEY_1 */;
                case 37 /* Digit2 */: return 23 /* KEY_2 */;
                case 38 /* Digit3 */: return 24 /* KEY_3 */;
                case 39 /* Digit4 */: return 25 /* KEY_4 */;
                case 40 /* Digit5 */: return 26 /* KEY_5 */;
                case 41 /* Digit6 */: return 27 /* KEY_6 */;
                case 42 /* Digit7 */: return 28 /* KEY_7 */;
                case 43 /* Digit8 */: return 29 /* KEY_8 */;
                case 44 /* Digit9 */: return 30 /* KEY_9 */;
                case 45 /* Digit0 */: return 21 /* KEY_0 */;
                case 51 /* Minus */: return 83 /* US_MINUS */;
                case 52 /* Equal */: return 81 /* US_EQUAL */;
                case 53 /* BracketLeft */: return 87 /* US_OPEN_SQUARE_BRACKET */;
                case 54 /* BracketRight */: return 89 /* US_CLOSE_SQUARE_BRACKET */;
                case 55 /* Backslash */: return 88 /* US_BACKSLASH */;
                case 56 /* IntlHash */: return 0 /* Unknown */; // missing
                case 57 /* Semicolon */: return 80 /* US_SEMICOLON */;
                case 58 /* Quote */: return 90 /* US_QUOTE */;
                case 59 /* Backquote */: return 86 /* US_BACKTICK */;
                case 60 /* Comma */: return 82 /* US_COMMA */;
                case 61 /* Period */: return 84 /* US_DOT */;
                case 62 /* Slash */: return 85 /* US_SLASH */;
                case 106 /* IntlBackslash */: return 92 /* OEM_102 */;
            }
            return 0 /* Unknown */;
        };
        MacLinuxFallbackKeyboardMapper.prototype._resolveSimpleUserBinding = function (binding) {
            if (!binding) {
                return null;
            }
            if (binding instanceof keyCodes_1.SimpleKeybinding) {
                return binding;
            }
            var keyCode = this._scanCodeToKeyCode(binding.scanCode);
            if (keyCode === 0 /* Unknown */) {
                return null;
            }
            return new keyCodes_1.SimpleKeybinding(binding.ctrlKey, binding.shiftKey, binding.altKey, binding.metaKey, keyCode);
        };
        MacLinuxFallbackKeyboardMapper.prototype.resolveUserBinding = function (firstPart, chordPart) {
            var _firstPart = this._resolveSimpleUserBinding(firstPart);
            var _chordPart = this._resolveSimpleUserBinding(chordPart);
            if (_firstPart && _chordPart) {
                return [new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(new keyCodes_1.ChordKeybinding(_firstPart, _chordPart), this._OS)];
            }
            if (_firstPart) {
                return [new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(_firstPart, this._OS)];
            }
            return [];
        };
        return MacLinuxFallbackKeyboardMapper;
    }());
    exports.MacLinuxFallbackKeyboardMapper = MacLinuxFallbackKeyboardMapper;
});























define(__m[321/*vs/codesandbox/keybindingService*/], __M([0/*require*/,1/*exports*/,10/*vs/platform/contextkey/common/contextkey*/,37/*vs/platform/commands/common/commands*/,32/*vs/platform/telemetry/common/telemetry*/,28/*vs/platform/notification/common/notification*/,452/*vs/platform/keybinding/common/abstractKeybindingService*/,323/*vs/platform/keybinding/common/keybindingResolver*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,68/*vs/base/browser/keyboardEvent*/,65/*vs/base/common/keyCodes*/,18/*vs/base/common/platform*/,4/*vs/base/common/lifecycle*/,324/*vs/platform/keybinding/common/resolvedKeybindingItem*/,320/*vs/platform/keybinding/common/usLayoutResolvedKeybinding*/,8/*vs/base/browser/dom*/,335/*vs/codesandbox/commandService*/,450/*vs/base/node/config*/,43/*vs/platform/environment/common/environment*/,25/*vs/base/common/errors*/,318/*vs/workbench/services/keybinding/common/keybindingIO*/,319/*vs/workbench/services/keybinding/common/macLinuxFallbackKeyboardMapper*/,168/*vs/base/common/keybindingParser*/]), function (require, exports, contextkey_1, commands_1, telemetry_1, notification_1, abstractKeybindingService_1, keybindingResolver_1, keybindingsRegistry_1, keyboardEvent_1, keyCodes_1, platform_1, lifecycle_1, resolvedKeybindingItem_1, usLayoutResolvedKeybinding_1, dom, commandService_1, config_1, environment_1, errors_1, keybindingIO_1, macLinuxFallbackKeyboardMapper_1, keybindingParser_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeSandboxKeybindingService = /** @class */ (function (_super) {
        __extends(CodeSandboxKeybindingService, _super);
        function CodeSandboxKeybindingService(window, environmentService, contextKeyService, commandService, telemetryService, notificationService) {
            var _this = _super.call(this, contextKeyService, commandService, telemetryService, notificationService) || this;
            _this._firstTimeComputingResolver = true;
            _this._cachedResolver = null;
            _this._dynamicKeybindings = [];
            _this._register(dom.addDisposableListener(window, dom.EventType.KEY_DOWN, function (e) {
                var keyEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                var shouldPreventDefault = _this._dispatch(keyEvent, keyEvent.target);
                if (shouldPreventDefault) {
                    keyEvent.preventDefault();
                }
            }));
            _this.userKeybindings = _this._register(new config_1.ConfigWatcher(environmentService.appKeybindingsPath, {
                defaultConfig: [],
                onError: function (error) { return errors_1.onUnexpectedError(error); },
            }));
            _this._keyboardMapper = new macLinuxFallbackKeyboardMapper_1.MacLinuxFallbackKeyboardMapper(platform_1.OS);
            _this._register(_this.userKeybindings.onDidUpdateConfiguration(function (event) {
                return _this.updateResolver({
                    source: 2 /* User */,
                    keybindings: event.config,
                });
            }));
            return _this;
        }
        CodeSandboxKeybindingService.prototype.addDynamicKeybinding = function (commandId, keybinding, handler, when) {
            var _this = this;
            var toDispose = [];
            this._dynamicKeybindings.push({
                keybinding: keyCodes_1.createKeybinding(keybinding, platform_1.OS),
                command: commandId,
                when: when,
                weight1: 1000,
                weight2: 0,
            });
            toDispose.push(lifecycle_1.toDisposable(function () {
                for (var i = 0; i < _this._dynamicKeybindings.length; i++) {
                    var kb = _this._dynamicKeybindings[i];
                    if (kb.command === commandId) {
                        _this._dynamicKeybindings.splice(i, 1);
                        _this.updateResolver({ source: 1 /* Default */ });
                        return;
                    }
                }
            }));
            var commandService = this._commandService;
            if (commandService instanceof commandService_1.CodeSandboxCommandService) {
                toDispose.push(commandService.addCommand({
                    id: commandId,
                    handler: handler,
                }));
            }
            else {
                throw new Error('Unknown command service!');
            }
            this.updateResolver({ source: 1 /* Default */ });
            return lifecycle_1.combinedDisposable(toDispose);
        };
        CodeSandboxKeybindingService.prototype.updateResolver = function (event) {
            this._cachedResolver = null;
            this._onDidUpdateKeybindings.fire(event);
        };
        CodeSandboxKeybindingService.prototype._getResolver = function () {
            if (!this._cachedResolver) {
                var defaults = this._resolveKeybindingItems(keybindingsRegistry_1.KeybindingsRegistry.getDefaultKeybindings(), true);
                var overrides = this._resolveUserKeybindingItems(this._getExtraKeybindings(this._firstTimeComputingResolver), false);
                this._cachedResolver = new keybindingResolver_1.KeybindingResolver(defaults, overrides);
                this._firstTimeComputingResolver = false;
            }
            return this._cachedResolver;
        };
        CodeSandboxKeybindingService.prototype._safeGetConfig = function () {
            var rawConfig = this.userKeybindings.getConfig();
            if (Array.isArray(rawConfig)) {
                return rawConfig;
            }
            return [];
        };
        CodeSandboxKeybindingService.prototype._getExtraKeybindings = function (isFirstTime) {
            var extraUserKeybindings = this._safeGetConfig();
            if (!isFirstTime) {
                var cnt = extraUserKeybindings.length;
                /* __GDPR__
                          "customKeybindingsChanged" : {
                              "keyCount" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                          }
                      */
                this._telemetryService.publicLog('customKeybindingsChanged', {
                    keyCount: cnt,
                });
            }
            return extraUserKeybindings.map(function (k) {
                return keybindingIO_1.KeybindingIO.readUserKeybindingItem(k, platform_1.OS);
            });
        };
        CodeSandboxKeybindingService.prototype._resolveKeybindingItems = function (items, isDefault) {
            var result = [], resultLen = 0;
            for (var i = 0, len = items.length; i < len; i++) {
                var item = items[i];
                var when = item.when ? item.when.normalize() : null;
                var keybinding = item.keybinding;
                if (!keybinding) {
                    // This might be a removal keybinding item in user settings => accept it
                    result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);
                }
                else {
                    var resolvedKeybindings = this.resolveKeybinding(keybinding);
                    for (var j = 0; j < resolvedKeybindings.length; j++) {
                        result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(resolvedKeybindings[j], item.command, item.commandArgs, when, isDefault);
                    }
                }
            }
            return result;
        };
        CodeSandboxKeybindingService.prototype._resolveUserKeybindingItems = function (items, isDefault) {
            var result = [], resultLen = 0;
            for (var i = 0, len = items.length; i < len; i++) {
                var item = items[i];
                var when = item.when ? item.when.normalize() : null;
                var firstPart = item.firstPart;
                var chordPart = item.chordPart;
                if (!firstPart) {
                    // This might be a removal keybinding item in user settings => accept it
                    result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);
                }
                else {
                    var resolvedKeybindings = this._keyboardMapper.resolveUserBinding(firstPart, chordPart);
                    for (var j = 0; j < resolvedKeybindings.length; j++) {
                        result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(resolvedKeybindings[j], item.command, item.commandArgs, when, isDefault);
                    }
                }
            }
            return result;
        };
        CodeSandboxKeybindingService._getDefaultKeybindings = function (defaultKeybindings) {
            var out = new keybindingIO_1.OutputBuilder();
            out.writeLine('[');
            var lastIndex = defaultKeybindings.length - 1;
            defaultKeybindings.forEach(function (k, index) {
                keybindingIO_1.KeybindingIO.writeKeybindingItem(out, k, platform_1.OS);
                if (index !== lastIndex) {
                    out.writeLine(',');
                }
                else {
                    out.writeLine();
                }
            });
            out.writeLine(']');
            return out.toString();
        };
        CodeSandboxKeybindingService._getAllCommandsAsComment = function (boundCommands) {
            var unboundCommands = keybindingResolver_1.KeybindingResolver.getAllUnboundCommands(boundCommands);
            var pretty = unboundCommands.sort().join('\n// - ');
            return '// ' + 'Here are other available commands: ' + '\n// - ' + pretty;
        };
        CodeSandboxKeybindingService.prototype.getDefaultKeybindingsContent = function () {
            var resolver = this._getResolver();
            var defaultKeybindings = resolver.getDefaultKeybindings();
            var boundCommands = resolver.getDefaultBoundCommands();
            return (CodeSandboxKeybindingService._getDefaultKeybindings(defaultKeybindings) +
                '\n\n' +
                CodeSandboxKeybindingService._getAllCommandsAsComment(boundCommands));
        };
        CodeSandboxKeybindingService.prototype._documentHasFocus = function () {
            return document.hasFocus();
        };
        CodeSandboxKeybindingService.prototype._toNormalizedKeybindingItems = function (items, isDefault) {
            var result = [], resultLen = 0;
            for (var i = 0, len = items.length; i < len; i++) {
                var item = items[i];
                var when = item.when ? item.when.normalize() : null;
                var keybinding = item.keybinding;
                if (!keybinding) {
                    // This might be a removal keybinding item in user settings => accept it
                    result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, item.command, item.commandArgs, when, isDefault);
                }
                else {
                    var resolvedKeybindings = [
                        new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(keybinding, platform_1.OS),
                    ];
                    for (var j = 0; j < resolvedKeybindings.length; j++) {
                        result[resultLen++] = new resolvedKeybindingItem_1.ResolvedKeybindingItem(resolvedKeybindings[j], item.command, item.commandArgs, when, isDefault);
                    }
                }
            }
            return result;
        };
        CodeSandboxKeybindingService.prototype.resolveKeybinding = function (keybinding) {
            return this._keyboardMapper.resolveKeybinding(keybinding);
        };
        CodeSandboxKeybindingService.prototype.resolveKeyboardEvent = function (keyboardEvent) {
            return this._keyboardMapper.resolveKeyboardEvent(keyboardEvent);
        };
        CodeSandboxKeybindingService.prototype.resolveUserBinding = function (userBinding) {
            var _a = keybindingParser_1.KeybindingParser.parseUserBinding(userBinding), firstPart = _a[0], chordPart = _a[1];
            return this._keyboardMapper.resolveUserBinding(firstPart, chordPart);
        };
        CodeSandboxKeybindingService = __decorate([
            __param(1, environment_1.IEnvironmentService),
            __param(2, contextkey_1.IContextKeyService),
            __param(3, commands_1.ICommandService),
            __param(4, telemetry_1.ITelemetryService),
            __param(5, notification_1.INotificationService)
        ], CodeSandboxKeybindingService);
        return CodeSandboxKeybindingService;
    }(abstractKeybindingService_1.AbstractKeybindingService));
    exports.CodeSandboxKeybindingService = CodeSandboxKeybindingService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[326/*vs/workbench/services/keybinding/common/windowsKeyboardMapper*/], __M([0/*require*/,1/*exports*/,65/*vs/base/common/keyCodes*/,130/*vs/base/common/scanCode*/,327/*vs/base/common/keybindingLabels*/]), function (require, exports, keyCodes_1, scanCode_1, keybindingLabels_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function windowsKeyMappingEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.vkey === b.vkey
            && a.value === b.value
            && a.withShift === b.withShift
            && a.withAltGr === b.withAltGr
            && a.withShiftAltGr === b.withShiftAltGr);
    }
    function windowsKeyboardMappingEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        for (var scanCode = 0; scanCode < 193 /* MAX_VALUE */; scanCode++) {
            var strScanCode = scanCode_1.ScanCodeUtils.toString(scanCode);
            var aEntry = a[strScanCode];
            var bEntry = b[strScanCode];
            if (!windowsKeyMappingEquals(aEntry, bEntry)) {
                return false;
            }
        }
        return true;
    }
    exports.windowsKeyboardMappingEquals = windowsKeyboardMappingEquals;
    var LOG = false;
    function log(str) {
        if (LOG) {
            console.info(str);
        }
    }
    var NATIVE_KEY_CODE_TO_KEY_CODE = _getNativeMap();
    var WindowsNativeResolvedKeybinding = /** @class */ (function (_super) {
        __extends(WindowsNativeResolvedKeybinding, _super);
        function WindowsNativeResolvedKeybinding(mapper, firstPart, chordPart) {
            var _this = _super.call(this) || this;
            if (!firstPart) {
                throw new Error("Invalid WindowsNativeResolvedKeybinding firstPart");
            }
            _this._mapper = mapper;
            _this._firstPart = firstPart;
            _this._chordPart = chordPart;
            return _this;
        }
        WindowsNativeResolvedKeybinding.prototype._getUILabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return this._mapper.getUILabelForKeyCode(keybinding.keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype.getLabel = function () {
            var firstPart = this._getUILabelForKeybinding(this._firstPart);
            var chordPart = this._getUILabelForKeybinding(this._chordPart);
            return keybindingLabels_1.UILabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, 1 /* Windows */);
        };
        WindowsNativeResolvedKeybinding.prototype._getUSLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return keyCodes_1.KeyCodeUtils.toString(keybinding.keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype.getUSLabel = function () {
            var firstPart = this._getUSLabelForKeybinding(this._firstPart);
            var chordPart = this._getUSLabelForKeybinding(this._chordPart);
            return keybindingLabels_1.UILabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, 1 /* Windows */);
        };
        WindowsNativeResolvedKeybinding.prototype._getAriaLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return this._mapper.getAriaLabelForKeyCode(keybinding.keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype.getAriaLabel = function () {
            var firstPart = this._getAriaLabelForKeybinding(this._firstPart);
            var chordPart = this._getAriaLabelForKeybinding(this._chordPart);
            return keybindingLabels_1.AriaLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, 1 /* Windows */);
        };
        WindowsNativeResolvedKeybinding.prototype._keyCodeToElectronAccelerator = function (keyCode) {
            if (keyCode >= 93 /* NUMPAD_0 */ && keyCode <= 108 /* NUMPAD_DIVIDE */) {
                // Electron cannot handle numpad keys
                return null;
            }
            switch (keyCode) {
                case 16 /* UpArrow */:
                    return 'Up';
                case 18 /* DownArrow */:
                    return 'Down';
                case 15 /* LeftArrow */:
                    return 'Left';
                case 17 /* RightArrow */:
                    return 'Right';
            }
            // electron menus always do the correct rendering on Windows
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype._getElectronAcceleratorLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return null;
            }
            return this._keyCodeToElectronAccelerator(keybinding.keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype.getElectronAccelerator = function () {
            if (this._chordPart !== null) {
                // Electron cannot handle chords
                return null;
            }
            var firstPart = this._getElectronAcceleratorLabelForKeybinding(this._firstPart);
            return keybindingLabels_1.ElectronAcceleratorLabelProvider.toLabel(this._firstPart, firstPart, null, null, 1 /* Windows */);
        };
        WindowsNativeResolvedKeybinding.prototype._getUserSettingsLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return this._mapper.getUserSettingsLabelForKeyCode(keybinding.keyCode);
        };
        WindowsNativeResolvedKeybinding.prototype.getUserSettingsLabel = function () {
            var firstPart = this._getUserSettingsLabelForKeybinding(this._firstPart);
            var chordPart = this._getUserSettingsLabelForKeybinding(this._chordPart);
            var result = keybindingLabels_1.UserSettingsLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, 1 /* Windows */);
            return (result ? result.toLowerCase() : result);
        };
        WindowsNativeResolvedKeybinding.prototype.isWYSIWYG = function () {
            if (this._firstPart && !this._isWYSIWYG(this._firstPart.keyCode)) {
                return false;
            }
            if (this._chordPart && !this._isWYSIWYG(this._chordPart.keyCode)) {
                return false;
            }
            return true;
        };
        WindowsNativeResolvedKeybinding.prototype._isWYSIWYG = function (keyCode) {
            if (keyCode === 15 /* LeftArrow */
                || keyCode === 16 /* UpArrow */
                || keyCode === 17 /* RightArrow */
                || keyCode === 18 /* DownArrow */) {
                return true;
            }
            var ariaLabel = this._mapper.getAriaLabelForKeyCode(keyCode);
            var userSettingsLabel = this._mapper.getUserSettingsLabelForKeyCode(keyCode);
            return (ariaLabel === userSettingsLabel);
        };
        WindowsNativeResolvedKeybinding.prototype.isChord = function () {
            return (this._chordPart ? true : false);
        };
        WindowsNativeResolvedKeybinding.prototype.getParts = function () {
            return [
                this._toResolvedKeybindingPart(this._firstPart),
                this._toResolvedKeybindingPart(this._chordPart)
            ];
        };
        WindowsNativeResolvedKeybinding.prototype._toResolvedKeybindingPart = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            return new keyCodes_1.ResolvedKeybindingPart(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getUILabelForKeybinding(keybinding), this._getAriaLabelForKeybinding(keybinding));
        };
        WindowsNativeResolvedKeybinding.prototype.getDispatchParts = function () {
            var firstPart = this._firstPart ? this._getDispatchStr(this._firstPart) : null;
            var chordPart = this._chordPart ? this._getDispatchStr(this._chordPart) : null;
            return [firstPart, chordPart];
        };
        WindowsNativeResolvedKeybinding.prototype._getDispatchStr = function (keybinding) {
            if (keybinding.isModifierKey()) {
                return null;
            }
            var result = '';
            if (keybinding.ctrlKey) {
                result += 'ctrl+';
            }
            if (keybinding.shiftKey) {
                result += 'shift+';
            }
            if (keybinding.altKey) {
                result += 'alt+';
            }
            if (keybinding.metaKey) {
                result += 'meta+';
            }
            result += keyCodes_1.KeyCodeUtils.toString(keybinding.keyCode);
            return result;
        };
        WindowsNativeResolvedKeybinding.getProducedCharCode = function (kb, mapping) {
            if (!mapping) {
                return null;
            }
            if (kb.ctrlKey && kb.shiftKey && kb.altKey) {
                return mapping.withShiftAltGr;
            }
            if (kb.ctrlKey && kb.altKey) {
                return mapping.withAltGr;
            }
            if (kb.shiftKey) {
                return mapping.withShift;
            }
            return mapping.value;
        };
        WindowsNativeResolvedKeybinding.getProducedChar = function (kb, mapping) {
            var char = this.getProducedCharCode(kb, mapping);
            if (char === null || char.length === 0) {
                return ' --- ';
            }
            return '  ' + char + '  ';
        };
        return WindowsNativeResolvedKeybinding;
    }(keyCodes_1.ResolvedKeybinding));
    exports.WindowsNativeResolvedKeybinding = WindowsNativeResolvedKeybinding;
    var WindowsKeyboardMapper = /** @class */ (function () {
        function WindowsKeyboardMapper(isUSStandard, rawMappings) {
            var _this = this;
            this._keyCodeToLabel = [];
            this.isUSStandard = isUSStandard;
            this._scanCodeToKeyCode = [];
            this._keyCodeToLabel = [];
            this._keyCodeExists = [];
            this._keyCodeToLabel[0 /* Unknown */] = keyCodes_1.KeyCodeUtils.toString(0 /* Unknown */);
            for (var scanCode = 0 /* None */; scanCode < 193 /* MAX_VALUE */; scanCode++) {
                var immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
                if (immutableKeyCode !== -1) {
                    this._scanCodeToKeyCode[scanCode] = immutableKeyCode;
                    this._keyCodeToLabel[immutableKeyCode] = keyCodes_1.KeyCodeUtils.toString(immutableKeyCode);
                    this._keyCodeExists[immutableKeyCode] = true;
                }
            }
            var producesLetter = [];
            this._codeInfo = [];
            for (var strCode in rawMappings) {
                if (rawMappings.hasOwnProperty(strCode)) {
                    var scanCode = scanCode_1.ScanCodeUtils.toEnum(strCode);
                    if (scanCode === 0 /* None */) {
                        log("Unknown scanCode " + strCode + " in mapping.");
                        continue;
                    }
                    var rawMapping = rawMappings[strCode];
                    var immutableKeyCode = scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
                    if (immutableKeyCode !== -1) {
                        var keyCode_1 = NATIVE_KEY_CODE_TO_KEY_CODE[rawMapping.vkey] || 0 /* Unknown */;
                        if (keyCode_1 === 0 /* Unknown */ || immutableKeyCode === keyCode_1) {
                            continue;
                        }
                        if (scanCode !== 134 /* NumpadComma */) {
                            // Looks like ScanCode.NumpadComma doesn't always map to KeyCode.NUMPAD_SEPARATOR
                            // e.g. on POR - PTB
                            continue;
                        }
                    }
                    var value = rawMapping.value;
                    var withShift = rawMapping.withShift;
                    var withAltGr = rawMapping.withAltGr;
                    var withShiftAltGr = rawMapping.withShiftAltGr;
                    var keyCode = NATIVE_KEY_CODE_TO_KEY_CODE[rawMapping.vkey] || 0 /* Unknown */;
                    var mapping = {
                        scanCode: scanCode,
                        keyCode: keyCode,
                        value: value,
                        withShift: withShift,
                        withAltGr: withAltGr,
                        withShiftAltGr: withShiftAltGr,
                    };
                    this._codeInfo[scanCode] = mapping;
                    this._scanCodeToKeyCode[scanCode] = keyCode;
                    if (keyCode === 0 /* Unknown */) {
                        continue;
                    }
                    this._keyCodeExists[keyCode] = true;
                    if (value.length === 0) {
                        // This key does not produce strings
                        this._keyCodeToLabel[keyCode] = null;
                    }
                    else if (value.length > 1) {
                        // This key produces a letter representable with multiple UTF-16 code units.
                        this._keyCodeToLabel[keyCode] = value;
                    }
                    else {
                        var charCode = value.charCodeAt(0);
                        if (charCode >= 97 /* a */ && charCode <= 122 /* z */) {
                            var upperCaseValue = 65 /* A */ + (charCode - 97 /* a */);
                            producesLetter[upperCaseValue] = true;
                            this._keyCodeToLabel[keyCode] = String.fromCharCode(65 /* A */ + (charCode - 97 /* a */));
                        }
                        else if (charCode >= 65 /* A */ && charCode <= 90 /* Z */) {
                            producesLetter[charCode] = true;
                            this._keyCodeToLabel[keyCode] = value;
                        }
                        else {
                            this._keyCodeToLabel[keyCode] = value;
                        }
                    }
                }
            }
            // Handle keyboard layouts where latin characters are not produced e.g. Cyrillic
            var _registerLetterIfMissing = function (charCode, keyCode) {
                if (!producesLetter[charCode]) {
                    _this._keyCodeToLabel[keyCode] = String.fromCharCode(charCode);
                }
            };
            _registerLetterIfMissing(65 /* A */, 31 /* KEY_A */);
            _registerLetterIfMissing(66 /* B */, 32 /* KEY_B */);
            _registerLetterIfMissing(67 /* C */, 33 /* KEY_C */);
            _registerLetterIfMissing(68 /* D */, 34 /* KEY_D */);
            _registerLetterIfMissing(69 /* E */, 35 /* KEY_E */);
            _registerLetterIfMissing(70 /* F */, 36 /* KEY_F */);
            _registerLetterIfMissing(71 /* G */, 37 /* KEY_G */);
            _registerLetterIfMissing(72 /* H */, 38 /* KEY_H */);
            _registerLetterIfMissing(73 /* I */, 39 /* KEY_I */);
            _registerLetterIfMissing(74 /* J */, 40 /* KEY_J */);
            _registerLetterIfMissing(75 /* K */, 41 /* KEY_K */);
            _registerLetterIfMissing(76 /* L */, 42 /* KEY_L */);
            _registerLetterIfMissing(77 /* M */, 43 /* KEY_M */);
            _registerLetterIfMissing(78 /* N */, 44 /* KEY_N */);
            _registerLetterIfMissing(79 /* O */, 45 /* KEY_O */);
            _registerLetterIfMissing(80 /* P */, 46 /* KEY_P */);
            _registerLetterIfMissing(81 /* Q */, 47 /* KEY_Q */);
            _registerLetterIfMissing(82 /* R */, 48 /* KEY_R */);
            _registerLetterIfMissing(83 /* S */, 49 /* KEY_S */);
            _registerLetterIfMissing(84 /* T */, 50 /* KEY_T */);
            _registerLetterIfMissing(85 /* U */, 51 /* KEY_U */);
            _registerLetterIfMissing(86 /* V */, 52 /* KEY_V */);
            _registerLetterIfMissing(87 /* W */, 53 /* KEY_W */);
            _registerLetterIfMissing(88 /* X */, 54 /* KEY_X */);
            _registerLetterIfMissing(89 /* Y */, 55 /* KEY_Y */);
            _registerLetterIfMissing(90 /* Z */, 56 /* KEY_Z */);
        }
        WindowsKeyboardMapper.prototype.dumpDebugInfo = function () {
            var result = [];
            var immutableSamples = [
                88 /* ArrowUp */,
                104 /* Numpad0 */
            ];
            var cnt = 0;
            result.push("-----------------------------------------------------------------------------------------------------------------------------------------");
            for (var scanCode = 0 /* None */; scanCode < 193 /* MAX_VALUE */; scanCode++) {
                if (scanCode_1.IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1) {
                    if (immutableSamples.indexOf(scanCode) === -1) {
                        continue;
                    }
                }
                if (cnt % 6 === 0) {
                    result.push("|       HW Code combination      |  Key  |    KeyCode combination    |          UI label         |        User settings       | WYSIWYG |");
                    result.push("-----------------------------------------------------------------------------------------------------------------------------------------");
                }
                cnt++;
                var mapping = this._codeInfo[scanCode];
                var strCode = scanCode_1.ScanCodeUtils.toString(scanCode);
                var mods = [0, 2, 5, 7];
                for (var modIndex = 0; modIndex < mods.length; modIndex++) {
                    var mod = mods[modIndex];
                    var ctrlKey = (mod & 1) ? true : false;
                    var shiftKey = (mod & 2) ? true : false;
                    var altKey = (mod & 4) ? true : false;
                    var scanCodeBinding = new scanCode_1.ScanCodeBinding(ctrlKey, shiftKey, altKey, false, scanCode);
                    var kb = this._resolveSimpleUserBinding(scanCodeBinding);
                    var strKeyCode = (kb ? keyCodes_1.KeyCodeUtils.toString(kb.keyCode) : null);
                    var resolvedKb = (kb ? new WindowsNativeResolvedKeybinding(this, kb, null) : null);
                    var outScanCode = "" + (ctrlKey ? 'Ctrl+' : '') + (shiftKey ? 'Shift+' : '') + (altKey ? 'Alt+' : '') + strCode;
                    var ariaLabel = (resolvedKb ? resolvedKb.getAriaLabel() : null);
                    var outUILabel = (ariaLabel ? ariaLabel.replace(/Control\+/, 'Ctrl+') : null);
                    var outUserSettings = (resolvedKb ? resolvedKb.getUserSettingsLabel() : null);
                    var outKey = WindowsNativeResolvedKeybinding.getProducedChar(scanCodeBinding, mapping);
                    var outKb = (strKeyCode ? "" + (ctrlKey ? 'Ctrl+' : '') + (shiftKey ? 'Shift+' : '') + (altKey ? 'Alt+' : '') + strKeyCode : null);
                    var isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);
                    var outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');
                    result.push("| " + this._leftPad(outScanCode, 30) + " | " + outKey + " | " + this._leftPad(outKb, 25) + " | " + this._leftPad(outUILabel, 25) + " |  " + this._leftPad(outUserSettings, 25) + " | " + outWYSIWYG + " |");
                }
                result.push("-----------------------------------------------------------------------------------------------------------------------------------------");
            }
            return result.join('\n');
        };
        WindowsKeyboardMapper.prototype._leftPad = function (str, cnt) {
            if (str === null) {
                str = 'null';
            }
            while (str.length < cnt) {
                str = ' ' + str;
            }
            return str;
        };
        WindowsKeyboardMapper.prototype.getUILabelForKeyCode = function (keyCode) {
            return this._getLabelForKeyCode(keyCode);
        };
        WindowsKeyboardMapper.prototype.getAriaLabelForKeyCode = function (keyCode) {
            return this._getLabelForKeyCode(keyCode);
        };
        WindowsKeyboardMapper.prototype.getUserSettingsLabelForKeyCode = function (keyCode) {
            if (this.isUSStandard) {
                return keyCodes_1.KeyCodeUtils.toUserSettingsUS(keyCode);
            }
            return keyCodes_1.KeyCodeUtils.toUserSettingsGeneral(keyCode);
        };
        WindowsKeyboardMapper.prototype._getLabelForKeyCode = function (keyCode) {
            return this._keyCodeToLabel[keyCode] || keyCodes_1.KeyCodeUtils.toString(0 /* Unknown */);
        };
        WindowsKeyboardMapper.prototype.resolveKeybinding = function (keybinding) {
            if (keybinding.type === 2 /* Chord */) {
                var firstPartKeyCode = keybinding.firstPart.keyCode;
                var chordPartKeyCode = keybinding.chordPart.keyCode;
                if (!this._keyCodeExists[firstPartKeyCode] || !this._keyCodeExists[chordPartKeyCode]) {
                    return [];
                }
                return [new WindowsNativeResolvedKeybinding(this, keybinding.firstPart, keybinding.chordPart)];
            }
            else {
                if (!this._keyCodeExists[keybinding.keyCode]) {
                    return [];
                }
                return [new WindowsNativeResolvedKeybinding(this, keybinding, null)];
            }
        };
        WindowsKeyboardMapper.prototype.resolveKeyboardEvent = function (keyboardEvent) {
            var keybinding = new keyCodes_1.SimpleKeybinding(keyboardEvent.ctrlKey, keyboardEvent.shiftKey, keyboardEvent.altKey, keyboardEvent.metaKey, keyboardEvent.keyCode);
            return new WindowsNativeResolvedKeybinding(this, keybinding, null);
        };
        WindowsKeyboardMapper.prototype._resolveSimpleUserBinding = function (binding) {
            if (!binding) {
                return null;
            }
            if (binding instanceof keyCodes_1.SimpleKeybinding) {
                if (!this._keyCodeExists[binding.keyCode]) {
                    return null;
                }
                return binding;
            }
            var keyCode = this._scanCodeToKeyCode[binding.scanCode] || 0 /* Unknown */;
            if (keyCode === 0 /* Unknown */ || !this._keyCodeExists[keyCode]) {
                return null;
            }
            return new keyCodes_1.SimpleKeybinding(binding.ctrlKey, binding.shiftKey, binding.altKey, binding.metaKey, keyCode);
        };
        WindowsKeyboardMapper.prototype.resolveUserBinding = function (firstPart, chordPart) {
            var _firstPart = this._resolveSimpleUserBinding(firstPart);
            var _chordPart = this._resolveSimpleUserBinding(chordPart);
            if (_firstPart && _chordPart) {
                return [new WindowsNativeResolvedKeybinding(this, _firstPart, _chordPart)];
            }
            if (_firstPart) {
                return [new WindowsNativeResolvedKeybinding(this, _firstPart, null)];
            }
            return [];
        };
        return WindowsKeyboardMapper;
    }());
    exports.WindowsKeyboardMapper = WindowsKeyboardMapper;
    // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
    // See https://github.com/Microsoft/node-native-keymap/blob/master/deps/chromium/keyboard_codes_win.h
    function _getNativeMap() {
        return {
            VK_BACK: 1 /* Backspace */,
            VK_TAB: 2 /* Tab */,
            VK_CLEAR: 0 /* Unknown */,
            VK_RETURN: 3 /* Enter */,
            VK_SHIFT: 4 /* Shift */,
            VK_CONTROL: 5 /* Ctrl */,
            VK_MENU: 6 /* Alt */,
            VK_PAUSE: 7 /* PauseBreak */,
            VK_CAPITAL: 8 /* CapsLock */,
            VK_KANA: 0 /* Unknown */,
            VK_HANGUL: 0 /* Unknown */,
            VK_JUNJA: 0 /* Unknown */,
            VK_FINAL: 0 /* Unknown */,
            VK_HANJA: 0 /* Unknown */,
            VK_KANJI: 0 /* Unknown */,
            VK_ESCAPE: 9 /* Escape */,
            VK_CONVERT: 0 /* Unknown */,
            VK_NONCONVERT: 0 /* Unknown */,
            VK_ACCEPT: 0 /* Unknown */,
            VK_MODECHANGE: 0 /* Unknown */,
            VK_SPACE: 10 /* Space */,
            VK_PRIOR: 11 /* PageUp */,
            VK_NEXT: 12 /* PageDown */,
            VK_END: 13 /* End */,
            VK_HOME: 14 /* Home */,
            VK_LEFT: 15 /* LeftArrow */,
            VK_UP: 16 /* UpArrow */,
            VK_RIGHT: 17 /* RightArrow */,
            VK_DOWN: 18 /* DownArrow */,
            VK_SELECT: 0 /* Unknown */,
            VK_PRINT: 0 /* Unknown */,
            VK_EXECUTE: 0 /* Unknown */,
            VK_SNAPSHOT: 0 /* Unknown */,
            VK_INSERT: 19 /* Insert */,
            VK_DELETE: 20 /* Delete */,
            VK_HELP: 0 /* Unknown */,
            VK_0: 21 /* KEY_0 */,
            VK_1: 22 /* KEY_1 */,
            VK_2: 23 /* KEY_2 */,
            VK_3: 24 /* KEY_3 */,
            VK_4: 25 /* KEY_4 */,
            VK_5: 26 /* KEY_5 */,
            VK_6: 27 /* KEY_6 */,
            VK_7: 28 /* KEY_7 */,
            VK_8: 29 /* KEY_8 */,
            VK_9: 30 /* KEY_9 */,
            VK_A: 31 /* KEY_A */,
            VK_B: 32 /* KEY_B */,
            VK_C: 33 /* KEY_C */,
            VK_D: 34 /* KEY_D */,
            VK_E: 35 /* KEY_E */,
            VK_F: 36 /* KEY_F */,
            VK_G: 37 /* KEY_G */,
            VK_H: 38 /* KEY_H */,
            VK_I: 39 /* KEY_I */,
            VK_J: 40 /* KEY_J */,
            VK_K: 41 /* KEY_K */,
            VK_L: 42 /* KEY_L */,
            VK_M: 43 /* KEY_M */,
            VK_N: 44 /* KEY_N */,
            VK_O: 45 /* KEY_O */,
            VK_P: 46 /* KEY_P */,
            VK_Q: 47 /* KEY_Q */,
            VK_R: 48 /* KEY_R */,
            VK_S: 49 /* KEY_S */,
            VK_T: 50 /* KEY_T */,
            VK_U: 51 /* KEY_U */,
            VK_V: 52 /* KEY_V */,
            VK_W: 53 /* KEY_W */,
            VK_X: 54 /* KEY_X */,
            VK_Y: 55 /* KEY_Y */,
            VK_Z: 56 /* KEY_Z */,
            VK_LWIN: 57 /* Meta */,
            VK_COMMAND: 57 /* Meta */,
            VK_RWIN: 57 /* Meta */,
            VK_APPS: 0 /* Unknown */,
            VK_SLEEP: 0 /* Unknown */,
            VK_NUMPAD0: 93 /* NUMPAD_0 */,
            VK_NUMPAD1: 94 /* NUMPAD_1 */,
            VK_NUMPAD2: 95 /* NUMPAD_2 */,
            VK_NUMPAD3: 96 /* NUMPAD_3 */,
            VK_NUMPAD4: 97 /* NUMPAD_4 */,
            VK_NUMPAD5: 98 /* NUMPAD_5 */,
            VK_NUMPAD6: 99 /* NUMPAD_6 */,
            VK_NUMPAD7: 100 /* NUMPAD_7 */,
            VK_NUMPAD8: 101 /* NUMPAD_8 */,
            VK_NUMPAD9: 102 /* NUMPAD_9 */,
            VK_MULTIPLY: 103 /* NUMPAD_MULTIPLY */,
            VK_ADD: 104 /* NUMPAD_ADD */,
            VK_SEPARATOR: 105 /* NUMPAD_SEPARATOR */,
            VK_SUBTRACT: 106 /* NUMPAD_SUBTRACT */,
            VK_DECIMAL: 107 /* NUMPAD_DECIMAL */,
            VK_DIVIDE: 108 /* NUMPAD_DIVIDE */,
            VK_F1: 59 /* F1 */,
            VK_F2: 60 /* F2 */,
            VK_F3: 61 /* F3 */,
            VK_F4: 62 /* F4 */,
            VK_F5: 63 /* F5 */,
            VK_F6: 64 /* F6 */,
            VK_F7: 65 /* F7 */,
            VK_F8: 66 /* F8 */,
            VK_F9: 67 /* F9 */,
            VK_F10: 68 /* F10 */,
            VK_F11: 69 /* F11 */,
            VK_F12: 70 /* F12 */,
            VK_F13: 71 /* F13 */,
            VK_F14: 72 /* F14 */,
            VK_F15: 73 /* F15 */,
            VK_F16: 74 /* F16 */,
            VK_F17: 75 /* F17 */,
            VK_F18: 76 /* F18 */,
            VK_F19: 77 /* F19 */,
            VK_F20: 0 /* Unknown */,
            VK_F21: 0 /* Unknown */,
            VK_F22: 0 /* Unknown */,
            VK_F23: 0 /* Unknown */,
            VK_F24: 0 /* Unknown */,
            VK_NUMLOCK: 78 /* NumLock */,
            VK_SCROLL: 79 /* ScrollLock */,
            VK_LSHIFT: 4 /* Shift */,
            VK_RSHIFT: 4 /* Shift */,
            VK_LCONTROL: 5 /* Ctrl */,
            VK_RCONTROL: 5 /* Ctrl */,
            VK_LMENU: 0 /* Unknown */,
            VK_RMENU: 0 /* Unknown */,
            VK_BROWSER_BACK: 0 /* Unknown */,
            VK_BROWSER_FORWARD: 0 /* Unknown */,
            VK_BROWSER_REFRESH: 0 /* Unknown */,
            VK_BROWSER_STOP: 0 /* Unknown */,
            VK_BROWSER_SEARCH: 0 /* Unknown */,
            VK_BROWSER_FAVORITES: 0 /* Unknown */,
            VK_BROWSER_HOME: 0 /* Unknown */,
            VK_VOLUME_MUTE: 0 /* Unknown */,
            VK_VOLUME_DOWN: 0 /* Unknown */,
            VK_VOLUME_UP: 0 /* Unknown */,
            VK_MEDIA_NEXT_TRACK: 0 /* Unknown */,
            VK_MEDIA_PREV_TRACK: 0 /* Unknown */,
            VK_MEDIA_STOP: 0 /* Unknown */,
            VK_MEDIA_PLAY_PAUSE: 0 /* Unknown */,
            VK_MEDIA_LAUNCH_MAIL: 0 /* Unknown */,
            VK_MEDIA_LAUNCH_MEDIA_SELECT: 0 /* Unknown */,
            VK_MEDIA_LAUNCH_APP1: 0 /* Unknown */,
            VK_MEDIA_LAUNCH_APP2: 0 /* Unknown */,
            VK_OEM_1: 80 /* US_SEMICOLON */,
            VK_OEM_PLUS: 81 /* US_EQUAL */,
            VK_OEM_COMMA: 82 /* US_COMMA */,
            VK_OEM_MINUS: 83 /* US_MINUS */,
            VK_OEM_PERIOD: 84 /* US_DOT */,
            VK_OEM_2: 85 /* US_SLASH */,
            VK_OEM_3: 86 /* US_BACKTICK */,
            VK_ABNT_C1: 110 /* ABNT_C1 */,
            VK_ABNT_C2: 111 /* ABNT_C2 */,
            VK_OEM_4: 87 /* US_OPEN_SQUARE_BRACKET */,
            VK_OEM_5: 88 /* US_BACKSLASH */,
            VK_OEM_6: 89 /* US_CLOSE_SQUARE_BRACKET */,
            VK_OEM_7: 90 /* US_QUOTE */,
            VK_OEM_8: 91 /* OEM_8 */,
            VK_OEM_102: 92 /* OEM_102 */,
            VK_PROCESSKEY: 0 /* Unknown */,
            VK_PACKET: 0 /* Unknown */,
            VK_DBE_SBCSCHAR: 0 /* Unknown */,
            VK_DBE_DBCSCHAR: 0 /* Unknown */,
            VK_ATTN: 0 /* Unknown */,
            VK_CRSEL: 0 /* Unknown */,
            VK_EXSEL: 0 /* Unknown */,
            VK_EREOF: 0 /* Unknown */,
            VK_PLAY: 0 /* Unknown */,
            VK_ZOOM: 0 /* Unknown */,
            VK_NONAME: 0 /* Unknown */,
            VK_PA1: 0 /* Unknown */,
            VK_OEM_CLEAR: 0 /* Unknown */,
            VK_UNKNOWN: 0 /* Unknown */,
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[328/*vs/workbench/parts/preferences/browser/keybindingsEditorContribution*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,17/*vs/base/common/async*/,170/*vs/base/common/htmlContent*/,65/*vs/base/common/keyCodes*/,4/*vs/base/common/lifecycle*/,31/*vs/platform/keybinding/common/keybinding*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/,48/*vs/editor/common/core/range*/,56/*vs/editor/browser/editorExtensions*/,136/*vs/editor/contrib/snippet/snippetController2*/,251/*vs/workbench/parts/preferences/common/smartSnippetInserter*/,169/*vs/workbench/parts/preferences/browser/keybindingWidgets*/,200/*vs/workbench/browser/parts/editor/editorWidgets*/,77/*vs/base/common/json*/,130/*vs/base/common/scanCode*/,114/*vs/editor/common/editorContextKeys*/,326/*vs/workbench/services/keybinding/common/windowsKeyboardMapper*/,14/*vs/platform/theme/common/themeService*/,177/*vs/editor/common/view/editorColorRegistry*/,72/*vs/editor/common/model*/,168/*vs/base/common/keybindingParser*/]), function (require, exports, nls, async_1, htmlContent_1, keyCodes_1, lifecycle_1, keybinding_1, instantiation_1, contextkey_1, range_1, editorExtensions_1, snippetController2_1, smartSnippetInserter_1, keybindingWidgets_1, editorWidgets_1, json_1, scanCode_1, editorContextKeys_1, windowsKeyboardMapper_1, themeService_1, editorColorRegistry_1, model_1, keybindingParser_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var NLS_LAUNCH_MESSAGE = nls.localize('defineKeybinding.start', "Define Keybinding");
    var NLS_KB_LAYOUT_ERROR_MESSAGE = nls.localize('defineKeybinding.kbLayoutErrorMessage', "You won't be able to produce this key combination under your current keyboard layout.");
    var INTERESTING_FILE = /keybindings\.json$/;
    var DefineKeybindingController = /** @class */ (function (_super) {
        __extends(DefineKeybindingController, _super);
        function DefineKeybindingController(_editor, _instantiationService) {
            var _this = _super.call(this) || this;
            _this._editor = _editor;
            _this._instantiationService = _instantiationService;
            _this._keybindingWidgetRenderer = null;
            _this._keybindingDecorationRenderer = null;
            _this._register(_this._editor.onDidChangeModel(function (e) { return _this._update(); }));
            _this._update();
            return _this;
        }
        DefineKeybindingController.get = function (editor) {
            return editor.getContribution(DefineKeybindingController.ID);
        };
        DefineKeybindingController.prototype.getId = function () {
            return DefineKeybindingController.ID;
        };
        Object.defineProperty(DefineKeybindingController.prototype, "keybindingWidgetRenderer", {
            get: function () {
                return this._keybindingWidgetRenderer;
            },
            enumerable: true,
            configurable: true
        });
        DefineKeybindingController.prototype.dispose = function () {
            this._disposeKeybindingWidgetRenderer();
            this._disposeKeybindingDecorationRenderer();
            _super.prototype.dispose.call(this);
        };
        DefineKeybindingController.prototype._update = function () {
            if (!isInterestingEditorModel(this._editor)) {
                this._disposeKeybindingWidgetRenderer();
                this._disposeKeybindingDecorationRenderer();
                return;
            }
            // Decorations are shown for the default keybindings.json **and** for the user keybindings.json
            this._createKeybindingDecorationRenderer();
            // The button to define keybindings is shown only for the user keybindings.json
            if (!this._editor.getConfiguration().readOnly) {
                this._createKeybindingWidgetRenderer();
            }
            else {
                this._disposeKeybindingWidgetRenderer();
            }
        };
        DefineKeybindingController.prototype._createKeybindingWidgetRenderer = function () {
            if (!this._keybindingWidgetRenderer) {
                this._keybindingWidgetRenderer = this._instantiationService.createInstance(KeybindingWidgetRenderer, this._editor);
            }
        };
        DefineKeybindingController.prototype._disposeKeybindingWidgetRenderer = function () {
            if (this._keybindingWidgetRenderer) {
                this._keybindingWidgetRenderer.dispose();
                this._keybindingWidgetRenderer = null;
            }
        };
        DefineKeybindingController.prototype._createKeybindingDecorationRenderer = function () {
            if (!this._keybindingDecorationRenderer) {
                this._keybindingDecorationRenderer = this._instantiationService.createInstance(KeybindingEditorDecorationsRenderer, this._editor);
            }
        };
        DefineKeybindingController.prototype._disposeKeybindingDecorationRenderer = function () {
            if (this._keybindingDecorationRenderer) {
                this._keybindingDecorationRenderer.dispose();
                this._keybindingDecorationRenderer = null;
            }
        };
        DefineKeybindingController.ID = 'editor.contrib.defineKeybinding';
        DefineKeybindingController = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], DefineKeybindingController);
        return DefineKeybindingController;
    }(lifecycle_1.Disposable));
    exports.DefineKeybindingController = DefineKeybindingController;
    var KeybindingWidgetRenderer = /** @class */ (function (_super) {
        __extends(KeybindingWidgetRenderer, _super);
        function KeybindingWidgetRenderer(_editor, _instantiationService) {
            var _this = _super.call(this) || this;
            _this._editor = _editor;
            _this._instantiationService = _instantiationService;
            _this._launchWidget = _this._register(_this._instantiationService.createInstance(editorWidgets_1.FloatingClickWidget, _this._editor, NLS_LAUNCH_MESSAGE, DefineKeybindingCommand.ID));
            _this._register(_this._launchWidget.onClick(function () { return _this.showDefineKeybindingWidget(); }));
            _this._defineWidget = _this._register(_this._instantiationService.createInstance(keybindingWidgets_1.DefineKeybindingOverlayWidget, _this._editor));
            _this._launchWidget.render();
            return _this;
        }
        KeybindingWidgetRenderer.prototype.showDefineKeybindingWidget = function () {
            var _this = this;
            this._defineWidget.start().then(function (keybinding) { return _this._onAccepted(keybinding); });
        };
        KeybindingWidgetRenderer.prototype._onAccepted = function (keybinding) {
            this._editor.focus();
            if (keybinding) {
                var regexp = new RegExp(/\\/g);
                var backslash = regexp.test(keybinding);
                if (backslash) {
                    keybinding = keybinding.slice(0, -1) + '\\\\';
                }
                var snippetText = [
                    '{',
                    '\t"key": ' + JSON.stringify(keybinding) + ',',
                    '\t"command": "${1:commandId}",',
                    '\t"when": "${2:editorTextFocus}"',
                    '}$0'
                ].join('\n');
                var smartInsertInfo = smartSnippetInserter_1.SmartSnippetInserter.insertSnippet(this._editor.getModel(), this._editor.getPosition());
                snippetText = smartInsertInfo.prepend + snippetText + smartInsertInfo.append;
                this._editor.setPosition(smartInsertInfo.position);
                snippetController2_1.SnippetController2.get(this._editor).insert(snippetText, 0, 0);
            }
        };
        KeybindingWidgetRenderer = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], KeybindingWidgetRenderer);
        return KeybindingWidgetRenderer;
    }(lifecycle_1.Disposable));
    exports.KeybindingWidgetRenderer = KeybindingWidgetRenderer;
    var KeybindingEditorDecorationsRenderer = /** @class */ (function (_super) {
        __extends(KeybindingEditorDecorationsRenderer, _super);
        function KeybindingEditorDecorationsRenderer(_editor, _keybindingService) {
            var _this = _super.call(this) || this;
            _this._editor = _editor;
            _this._keybindingService = _keybindingService;
            _this._dec = [];
            _this._updateDecorations = _this._register(new async_1.RunOnceScheduler(function () { return _this._updateDecorationsNow(); }, 500));
            var model = _this._editor.getModel();
            _this._register(model.onDidChangeContent(function () { return _this._updateDecorations.schedule(); }));
            _this._register(_this._keybindingService.onDidUpdateKeybindings(function (e) { return _this._updateDecorations.schedule(); }));
            _this._register({
                dispose: function () {
                    _this._dec = _this._editor.deltaDecorations(_this._dec, []);
                    _this._updateDecorations.cancel();
                }
            });
            _this._updateDecorations.schedule();
            return _this;
        }
        KeybindingEditorDecorationsRenderer.prototype._updateDecorationsNow = function () {
            var model = this._editor.getModel();
            var newDecorations = [];
            var root = json_1.parseTree(model.getValue());
            if (root && Array.isArray(root.children)) {
                for (var i = 0, len = root.children.length; i < len; i++) {
                    var entry = root.children[i];
                    var dec = this._getDecorationForEntry(model, entry);
                    if (dec !== null) {
                        newDecorations.push(dec);
                    }
                }
            }
            this._dec = this._editor.deltaDecorations(this._dec, newDecorations);
        };
        KeybindingEditorDecorationsRenderer.prototype._getDecorationForEntry = function (model, entry) {
            if (!Array.isArray(entry.children)) {
                return null;
            }
            for (var i = 0, len = entry.children.length; i < len; i++) {
                var prop = entry.children[i];
                if (prop.type !== 'property') {
                    continue;
                }
                if (!Array.isArray(prop.children) || prop.children.length !== 2) {
                    continue;
                }
                var key = prop.children[0];
                if (key.value !== 'key') {
                    continue;
                }
                var value = prop.children[1];
                if (value.type !== 'string') {
                    continue;
                }
                var resolvedKeybindings = this._keybindingService.resolveUserBinding(value.value);
                if (resolvedKeybindings.length === 0) {
                    return this._createDecoration(true, null, null, model, value);
                }
                var resolvedKeybinding = resolvedKeybindings[0];
                var usLabel = null;
                if (resolvedKeybinding instanceof windowsKeyboardMapper_1.WindowsNativeResolvedKeybinding) {
                    usLabel = resolvedKeybinding.getUSLabel();
                }
                if (!resolvedKeybinding.isWYSIWYG()) {
                    var uiLabel = resolvedKeybinding.getLabel();
                    if (value.value.toLowerCase() === uiLabel.toLowerCase()) {
                        // coincidentally, this is actually WYSIWYG
                        return null;
                    }
                    return this._createDecoration(false, resolvedKeybinding.getLabel(), usLabel, model, value);
                }
                if (/abnt_|oem_/.test(value.value)) {
                    return this._createDecoration(false, resolvedKeybinding.getLabel(), usLabel, model, value);
                }
                var expectedUserSettingsLabel = resolvedKeybinding.getUserSettingsLabel();
                if (!KeybindingEditorDecorationsRenderer._userSettingsFuzzyEquals(value.value, expectedUserSettingsLabel)) {
                    return this._createDecoration(false, resolvedKeybinding.getLabel(), usLabel, model, value);
                }
                return null;
            }
            return null;
        };
        KeybindingEditorDecorationsRenderer._userSettingsFuzzyEquals = function (a, b) {
            a = a.trim().toLowerCase();
            b = b.trim().toLowerCase();
            if (a === b) {
                return true;
            }
            var _a = keybindingParser_1.KeybindingParser.parseUserBinding(a), parsedA1 = _a[0], parsedA2 = _a[1];
            var _b = keybindingParser_1.KeybindingParser.parseUserBinding(b), parsedB1 = _b[0], parsedB2 = _b[1];
            return (this._userBindingEquals(parsedA1, parsedB1)
                && this._userBindingEquals(parsedA2, parsedB2));
        };
        KeybindingEditorDecorationsRenderer._userBindingEquals = function (a, b) {
            if (a === null && b === null) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            if (a instanceof keyCodes_1.SimpleKeybinding && b instanceof keyCodes_1.SimpleKeybinding) {
                return a.equals(b);
            }
            if (a instanceof scanCode_1.ScanCodeBinding && b instanceof scanCode_1.ScanCodeBinding) {
                return a.equals(b);
            }
            return false;
        };
        KeybindingEditorDecorationsRenderer.prototype._createDecoration = function (isError, uiLabel, usLabel, model, keyNode) {
            var msg;
            var className;
            var beforeContentClassName;
            var overviewRulerColor;
            if (isError) {
                // this is the error case
                msg = new htmlContent_1.MarkdownString().appendText(NLS_KB_LAYOUT_ERROR_MESSAGE);
                className = 'keybindingError';
                beforeContentClassName = 'inlineKeybindingError';
                overviewRulerColor = themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerError);
            }
            else {
                // this is the info case
                if (usLabel && uiLabel !== usLabel) {
                    msg = new htmlContent_1.MarkdownString(nls.localize({
                        key: 'defineKeybinding.kbLayoutLocalAndUSMessage',
                        comment: [
                            'Please translate maintaining the stars (*) around the placeholders such that they will be rendered in bold.',
                            'The placeholders will contain a keyboard combination e.g. Ctrl+Shift+/'
                        ]
                    }, "**{0}** for your current keyboard layout (**{1}** for US standard).", uiLabel, usLabel));
                }
                else {
                    msg = new htmlContent_1.MarkdownString(nls.localize({
                        key: 'defineKeybinding.kbLayoutLocalMessage',
                        comment: [
                            'Please translate maintaining the stars (*) around the placeholder such that it will be rendered in bold.',
                            'The placeholder will contain a keyboard combination e.g. Ctrl+Shift+/'
                        ]
                    }, "**{0}** for your current keyboard layout.", uiLabel));
                }
                className = 'keybindingInfo';
                beforeContentClassName = 'inlineKeybindingInfo';
                overviewRulerColor = themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerInfo);
            }
            var startPosition = model.getPositionAt(keyNode.offset);
            var endPosition = model.getPositionAt(keyNode.offset + keyNode.length);
            var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
            // icon + highlight + message decoration
            return {
                range: range,
                options: {
                    stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    className: className,
                    beforeContentClassName: beforeContentClassName,
                    hoverMessage: msg,
                    overviewRuler: {
                        color: overviewRulerColor,
                        position: model_1.OverviewRulerLane.Right
                    }
                }
            };
        };
        KeybindingEditorDecorationsRenderer = __decorate([
            __param(1, keybinding_1.IKeybindingService)
        ], KeybindingEditorDecorationsRenderer);
        return KeybindingEditorDecorationsRenderer;
    }(lifecycle_1.Disposable));
    exports.KeybindingEditorDecorationsRenderer = KeybindingEditorDecorationsRenderer;
    var DefineKeybindingCommand = /** @class */ (function (_super) {
        __extends(DefineKeybindingCommand, _super);
        function DefineKeybindingCommand() {
            return _super.call(this, {
                id: DefineKeybindingCommand.ID,
                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.writable, editorContextKeys_1.EditorContextKeys.languageId.isEqualTo('jsonc')),
                kbOpts: {
                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 41 /* KEY_K */),
                    weight: 100 /* EditorContrib */
                }
            }) || this;
        }
        DefineKeybindingCommand.prototype.runEditorCommand = function (accessor, editor) {
            if (!isInterestingEditorModel(editor) || editor.getConfiguration().readOnly) {
                return;
            }
            var controller = DefineKeybindingController.get(editor);
            if (controller && controller.keybindingWidgetRenderer) {
                controller.keybindingWidgetRenderer.showDefineKeybindingWidget();
            }
        };
        DefineKeybindingCommand.ID = 'editor.action.defineKeybinding';
        return DefineKeybindingCommand;
    }(editorExtensions_1.EditorCommand));
    function isInterestingEditorModel(editor) {
        var model = editor.getModel();
        if (!model) {
            return false;
        }
        var url = model.uri.toString();
        return INTERESTING_FILE.test(url);
    }
    editorExtensions_1.registerEditorContribution(DefineKeybindingController);
    editorExtensions_1.registerEditorCommand(new DefineKeybindingCommand());
});























define(__m[329/*vs/workbench/services/mode/common/workbenchModeService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,35/*vs/base/common/resources*/,131/*vs/base/common/mime*/,16/*vs/platform/files/common/files*/,70/*vs/workbench/services/extensions/common/extensions*/,183/*vs/workbench/services/extensions/common/extensionsRegistry*/,152/*vs/editor/common/modes/modesRegistry*/,7/*vs/platform/configuration/common/configuration*/,449/*vs/editor/common/services/modeServiceImpl*/,43/*vs/platform/environment/common/environment*/]), function (require, exports, nls, resources, mime, files_1, extensions_1, extensionsRegistry_1, modesRegistry_1, configuration_1, modeServiceImpl_1, environment_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.languagesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('languages', [], {
        description: nls.localize('vscode.extension.contributes.languages', 'Contributes language declarations.'),
        type: 'array',
        items: {
            type: 'object',
            defaultSnippets: [{ body: { id: '${1:languageId}', aliases: ['${2:label}'], extensions: ['${3:extension}'], configuration: './language-configuration.json' } }],
            properties: {
                id: {
                    description: nls.localize('vscode.extension.contributes.languages.id', 'ID of the language.'),
                    type: 'string'
                },
                aliases: {
                    description: nls.localize('vscode.extension.contributes.languages.aliases', 'Name aliases for the language.'),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                extensions: {
                    description: nls.localize('vscode.extension.contributes.languages.extensions', 'File extensions associated to the language.'),
                    default: ['.foo'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenames: {
                    description: nls.localize('vscode.extension.contributes.languages.filenames', 'File names associated to the language.'),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenamePatterns: {
                    description: nls.localize('vscode.extension.contributes.languages.filenamePatterns', 'File name glob patterns associated to the language.'),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                mimetypes: {
                    description: nls.localize('vscode.extension.contributes.languages.mimetypes', 'Mime types associated to the language.'),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                firstLine: {
                    description: nls.localize('vscode.extension.contributes.languages.firstLine', 'A regular expression matching the first line of a file of the language.'),
                    type: 'string'
                },
                configuration: {
                    description: nls.localize('vscode.extension.contributes.languages.configuration', 'A relative path to a file containing configuration options for the language.'),
                    type: 'string',
                    default: './language-configuration.json'
                }
            }
        }
    });
    var WorkbenchModeServiceImpl = /** @class */ (function (_super) {
        __extends(WorkbenchModeServiceImpl, _super);
        function WorkbenchModeServiceImpl(extensionService, configurationService, environmentService) {
            var _this = _super.call(this, environmentService.verbose || environmentService.isExtensionDevelopment || !environmentService.isBuilt) || this;
            _this._configurationService = configurationService;
            _this._extensionService = extensionService;
            exports.languagesExtPoint.setHandler(function (extensions) {
                var allValidLanguages = [];
                for (var i = 0, len = extensions.length; i < len; i++) {
                    var extension = extensions[i];
                    if (!Array.isArray(extension.value)) {
                        extension.collector.error(nls.localize('invalid', "Invalid `contributes.{0}`. Expected an array.", exports.languagesExtPoint.name));
                        continue;
                    }
                    for (var j = 0, lenJ = extension.value.length; j < lenJ; j++) {
                        var ext = extension.value[j];
                        if (isValidLanguageExtensionPoint(ext, extension.collector)) {
                            var configuration = void 0;
                            if (ext.configuration) {
                                configuration = resources.joinPath(extension.description.extensionLocation, ext.configuration);
                            }
                            allValidLanguages.push({
                                id: ext.id,
                                extensions: ext.extensions,
                                filenames: ext.filenames,
                                filenamePatterns: ext.filenamePatterns,
                                firstLine: ext.firstLine,
                                aliases: ext.aliases,
                                mimetypes: ext.mimetypes,
                                configuration: configuration
                            });
                        }
                    }
                }
                modesRegistry_1.ModesRegistry.registerLanguages(allValidLanguages);
            });
            _this._configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration(files_1.FILES_ASSOCIATIONS_CONFIG)) {
                    _this.updateMime();
                }
            });
            _this.onDidCreateMode(function (mode) {
                _this._extensionService.activateByEvent("onLanguage:" + mode.getId());
            });
            return _this;
        }
        WorkbenchModeServiceImpl.prototype._onReady = function () {
            var _this = this;
            if (!this._onReadyPromise) {
                this._onReadyPromise = this._extensionService.whenInstalledExtensionsRegistered().then(function () {
                    _this.updateMime();
                    return true;
                });
            }
            return this._onReadyPromise;
        };
        WorkbenchModeServiceImpl.prototype.updateMime = function () {
            var _this = this;
            var configuration = this._configurationService.getValue();
            // Clear user configured mime associations
            mime.clearTextMimes(true /* user configured */);
            // Register based on settings
            if (configuration.files && configuration.files.associations) {
                Object.keys(configuration.files.associations).forEach(function (pattern) {
                    var langId = configuration.files.associations[pattern];
                    var mimetype = _this.getMimeForMode(langId) || "text/x-" + langId;
                    mime.registerTextMime({ id: langId, mime: mimetype, filepattern: pattern, userConfigured: true });
                });
            }
        };
        WorkbenchModeServiceImpl = __decorate([
            __param(0, extensions_1.IExtensionService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, environment_1.IEnvironmentService)
        ], WorkbenchModeServiceImpl);
        return WorkbenchModeServiceImpl;
    }(modeServiceImpl_1.ModeServiceImpl));
    exports.WorkbenchModeServiceImpl = WorkbenchModeServiceImpl;
    function isUndefinedOrStringArray(value) {
        if (typeof value === 'undefined') {
            return true;
        }
        if (!Array.isArray(value)) {
            return false;
        }
        return value.every(function (item) { return typeof item === 'string'; });
    }
    function isValidLanguageExtensionPoint(value, collector) {
        if (!value) {
            collector.error(nls.localize('invalid.empty', "Empty value for `contributes.{0}`", exports.languagesExtPoint.name));
            return false;
        }
        if (typeof value.id !== 'string') {
            collector.error(nls.localize('require.id', "property `{0}` is mandatory and must be of type `string`", 'id'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.extensions)) {
            collector.error(nls.localize('opt.extensions', "property `{0}` can be omitted and must be of type `string[]`", 'extensions'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.filenames)) {
            collector.error(nls.localize('opt.filenames', "property `{0}` can be omitted and must be of type `string[]`", 'filenames'));
            return false;
        }
        if (typeof value.firstLine !== 'undefined' && typeof value.firstLine !== 'string') {
            collector.error(nls.localize('opt.firstLine', "property `{0}` can be omitted and must be of type `string`", 'firstLine'));
            return false;
        }
        if (typeof value.configuration !== 'undefined' && typeof value.configuration !== 'string') {
            collector.error(nls.localize('opt.configuration', "property `{0}` can be omitted and must be of type `string`", 'configuration'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.aliases)) {
            collector.error(nls.localize('opt.aliases', "property `{0}` can be omitted and must be of type `string[]`", 'aliases'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.mimetypes)) {
            collector.error(nls.localize('opt.mimetypes', "property `{0}` can be omitted and must be of type `string[]`", 'mimetypes'));
            return false;
        }
        return true;
    }
});










define(__m[192/*vs/workbench/parts/snippets/electron-browser/snippetsService*/], __M([0/*require*/,1/*exports*/,78/*path*/,170/*vs/base/common/htmlContent*/,4/*vs/base/common/lifecycle*/,39/*vs/base/common/map*/,35/*vs/base/common/resources*/,22/*vs/base/common/strings*/,12/*vs/base/common/uri*/,41/*vs/editor/common/services/modeService*/,266/*vs/editor/contrib/snippet/snippetParser*/,211/*vs/editor/contrib/suggest/suggest*/,2/*vs/nls*/,43/*vs/platform/environment/common/environment*/,16/*vs/platform/files/common/files*/,80/*vs/platform/instantiation/common/extensions*/,63/*vs/platform/lifecycle/common/lifecycle*/,86/*vs/platform/log/common/log*/,117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/,206/*vs/workbench/parts/snippets/electron-browser/snippetsFile*/,183/*vs/workbench/services/extensions/common/extensionsRegistry*/,329/*vs/workbench/services/mode/common/workbenchModeService*/,20/*vs/platform/workspace/common/workspace*/,19/*vs/base/common/arrays*/,48/*vs/editor/common/core/range*/]), function (require, exports, path_1, htmlContent_1, lifecycle_1, map_1, resources, strings_1, uri_1, modeService_1, snippetParser_1, suggest_1, nls_1, environment_1, files_1, extensions_1, lifecycle_2, log_1, snippets_contribution_1, snippetsFile_1, extensionsRegistry_1, workbenchModeService_1, workspace_1, arrays_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema;
    (function (schema) {
        function toValidSnippet(extension, snippet, modeService) {
            if (strings_1.isFalsyOrWhitespace(snippet.path)) {
                extension.collector.error(nls_1.localize('invalid.path.0', "Expected string in `contributes.{0}.path`. Provided value: {1}", extension.description.name, String(snippet.path)));
                return null;
            }
            if (strings_1.isFalsyOrWhitespace(snippet.language) && !strings_1.endsWith(snippet.path, '.code-snippets')) {
                extension.collector.error(nls_1.localize('invalid.language.0', "When omitting the language, the value of `contributes.{0}.path` must be a `.code-snippets`-file. Provided value: {1}", extension.description.name, String(snippet.path)));
                return null;
            }
            if (!strings_1.isFalsyOrWhitespace(snippet.language) && !modeService.isRegisteredMode(snippet.language)) {
                extension.collector.error(nls_1.localize('invalid.language', "Unknown language in `contributes.{0}.language`. Provided value: {1}", extension.description.name, String(snippet.language)));
                return null;
            }
            var extensionLocation = extension.description.extensionLocation;
            var snippetLocation = resources.joinPath(extensionLocation, snippet.path);
            if (!resources.isEqualOrParent(snippetLocation, extensionLocation)) {
                extension.collector.error(nls_1.localize('invalid.path.1', "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.", extension.description.name, snippetLocation.path, extensionLocation.path));
                return null;
            }
            return {
                language: snippet.language,
                location: snippetLocation
            };
        }
        schema.toValidSnippet = toValidSnippet;
        schema.snippetsContribution = {
            description: nls_1.localize('vscode.extension.contributes.snippets', 'Contributes snippets.'),
            type: 'array',
            defaultSnippets: [{ body: [{ language: '', path: '' }] }],
            items: {
                type: 'object',
                defaultSnippets: [{ body: { language: '${1:id}', path: './snippets/${2:id}.json.' } }],
                properties: {
                    language: {
                        description: nls_1.localize('vscode.extension.contributes.snippets-language', 'Language identifier for which this snippet is contributed to.'),
                        type: 'string'
                    },
                    path: {
                        description: nls_1.localize('vscode.extension.contributes.snippets-path', 'Path of the snippets file. The path is relative to the extension folder and typically starts with \'./snippets/\'.'),
                        type: 'string'
                    }
                }
            }
        };
    })(schema || (schema = {}));
    function watch(service, resource, callback) {
        var listener = service.onFileChanges(function (e) {
            for (var _i = 0, _a = e.changes; _i < _a.length; _i++) {
                var change = _a[_i];
                if (resources.isEqualOrParent(change.resource, resource)) {
                    callback(change.type, change.resource);
                }
            }
        });
        service.watchFileChanges(resource);
        return {
            dispose: function () {
                listener.dispose();
                service.unwatchFileChanges(resource);
            }
        };
    }
    var SnippetsService = /** @class */ (function () {
        function SnippetsService(_environmentService, _contextService, _modeService, _logService, _fileService, lifecycleService) {
            var _this = this;
            this._environmentService = _environmentService;
            this._contextService = _contextService;
            this._modeService = _modeService;
            this._logService = _logService;
            this._fileService = _fileService;
            this._disposables = [];
            this._pendingWork = [];
            this._files = new Map();
            this._pendingWork.push(Promise.resolve(lifecycleService.when(3 /* Running */).then(function () {
                _this._initExtensionSnippets();
                _this._initUserSnippets();
                _this._initWorkspaceSnippets();
            })));
            suggest_1.setSnippetSuggestSupport(new SnippetSuggestProvider(this._modeService, this));
        }
        SnippetsService.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
        };
        SnippetsService.prototype._joinSnippets = function () {
            var promises = this._pendingWork.slice(0);
            this._pendingWork.length = 0;
            return Promise.all(promises);
        };
        SnippetsService.prototype.getSnippetFiles = function () {
            var _this = this;
            return this._joinSnippets().then(function () { return map_1.values(_this._files); });
        };
        SnippetsService.prototype.getSnippets = function (languageId) {
            var _this = this;
            return this._joinSnippets().then(function () {
                var langName = _this._modeService.getLanguageIdentifier(languageId).language;
                var result = [];
                var promises = [];
                _this._files.forEach(function (file) {
                    promises.push(file.load()
                        .then(function (file) { return file.select(langName, result); })
                        .catch(function (err) { return _this._logService.error(err, file.location.toString()); }));
                });
                return Promise.all(promises).then(function () { return result; });
            });
        };
        SnippetsService.prototype.getSnippetsSync = function (languageId) {
            var langName = this._modeService.getLanguageIdentifier(languageId).language;
            var result = [];
            this._files.forEach(function (file) {
                // kick off loading (which is a noop in case it's already loaded)
                // and optimistically collect snippets
                file.load().catch(function (err) { });
                file.select(langName, result);
            });
            return result;
        };
        // --- loading, watching
        SnippetsService.prototype._initExtensionSnippets = function () {
            var _this = this;
            extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('snippets', [workbenchModeService_1.languagesExtPoint], schema.snippetsContribution).setHandler(function (extensions) {
                var _loop_1 = function (extension) {
                    var _loop_2 = function (contribution) {
                        var validContribution = schema.toValidSnippet(extension, contribution, _this._modeService);
                        if (!validContribution) {
                            return "continue";
                        }
                        if (_this._files.has(validContribution.location.toString())) {
                            _this._files.get(validContribution.location.toString()).defaultScopes.push(validContribution.language);
                        }
                        else {
                            var file_1 = new snippetsFile_1.SnippetFile(3 /* Extension */, validContribution.location, validContribution.language ? [validContribution.language] : undefined, extension.description, _this._fileService);
                            _this._files.set(file_1.location.toString(), file_1);
                            if (_this._environmentService.isExtensionDevelopment) {
                                file_1.load().then(function (file) {
                                    // warn about bad tabstop/variable usage
                                    if (file.data.some(function (snippet) { return snippet.isBogous; })) {
                                        extension.collector.warn(nls_1.localize('badVariableUse', "One or more snippets from the extension '{0}' very likely confuse snippet-variables and snippet-placeholders (see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax for more details)", extension.description.name));
                                    }
                                }, function (err) {
                                    // generic error
                                    extension.collector.warn(nls_1.localize('badFile', "The snippet file \"{0}\" could not be read.", file_1.location.toString()));
                                });
                            }
                        }
                    };
                    for (var _i = 0, _a = extension.value; _i < _a.length; _i++) {
                        var contribution = _a[_i];
                        _loop_2(contribution);
                    }
                };
                for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
                    var extension = extensions_2[_i];
                    _loop_1(extension);
                }
            });
        };
        SnippetsService.prototype._initWorkspaceSnippets = function () {
            var _this = this;
            // workspace stuff
            var disposables = [];
            var updateWorkspaceSnippets = function () {
                disposables = lifecycle_1.dispose(disposables);
                _this._pendingWork.push(_this._initWorkspaceFolderSnippets(_this._contextService.getWorkspace(), disposables));
            };
            this._disposables.push({
                dispose: function () { lifecycle_1.dispose(disposables); }
            });
            this._disposables.push(this._contextService.onDidChangeWorkspaceFolders(updateWorkspaceSnippets));
            this._disposables.push(this._contextService.onDidChangeWorkbenchState(updateWorkspaceSnippets));
            updateWorkspaceSnippets();
        };
        SnippetsService.prototype._initWorkspaceFolderSnippets = function (workspace, bucket) {
            var _this = this;
            var promises = workspace.folders.map(function (folder) {
                var snippetFolder = folder.toResource('.vscode');
                return _this._fileService.existsFile(snippetFolder).then(function (value) {
                    if (value) {
                        _this._initFolderSnippets(2 /* Workspace */, snippetFolder, bucket);
                    }
                    else {
                        // watch
                        bucket.push(watch(_this._fileService, snippetFolder, function (type) {
                            if (type === 1 /* ADDED */) {
                                _this._initFolderSnippets(2 /* Workspace */, snippetFolder, bucket);
                            }
                        }));
                    }
                });
            });
            return Promise.all(promises);
        };
        SnippetsService.prototype._initUserSnippets = function () {
            var _this = this;
            var userSnippetsFolder = uri_1.URI.file(path_1.join(this._environmentService.appSettingsHome, 'snippets'));
            return this._fileService.createFolder(userSnippetsFolder).then(function () { return _this._initFolderSnippets(1 /* User */, userSnippetsFolder, _this._disposables); });
        };
        SnippetsService.prototype._initFolderSnippets = function (source, folder, bucket) {
            var _this = this;
            var addUserSnippet = function (filepath) {
                var ext = path_1.extname(filepath.path);
                if (source === 1 /* User */ && ext === '.json') {
                    var langName = path_1.basename(filepath.path, '.json');
                    _this._files.set(filepath.toString(), new snippetsFile_1.SnippetFile(source, filepath, [langName], undefined, _this._fileService));
                }
                else if (ext === '.code-snippets') {
                    _this._files.set(filepath.toString(), new snippetsFile_1.SnippetFile(source, filepath, undefined, undefined, _this._fileService));
                }
            };
            return this._fileService.resolveFile(folder).then(function (stat) {
                if (!arrays_1.isFalsyOrEmpty(stat.children)) {
                    for (var _i = 0, _a = stat.children; _i < _a.length; _i++) {
                        var entry = _a[_i];
                        addUserSnippet(entry.resource);
                    }
                }
            }).then(function () {
                // watch
                bucket.push(watch(_this._fileService, folder, function (_type, filename) {
                    _this._fileService.existsFile(filename).then(function (value) {
                        if (value) {
                            // file created or changed
                            if (_this._files.has(filename.toString())) {
                                _this._files.get(filename.toString()).reset();
                            }
                            else {
                                addUserSnippet(filename);
                            }
                        }
                        else {
                            // file not found
                            _this._files.delete(filename.toString());
                        }
                    });
                }));
                bucket.push({
                    dispose: function () {
                        // add a disposable that removes all snippets
                        // from this folder. that ensures snippets disappear
                        // when the folder goes away
                        _this._files.forEach(function (value, index) {
                            if (resources.isEqualOrParent(value.location, folder)) {
                                _this._files.delete(index);
                            }
                        });
                    }
                });
            }).then(undefined, function (err) {
                _this._logService.error("Failed snippets from folder '" + folder.toString() + "'", err);
            });
        };
        SnippetsService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, workspace_1.IWorkspaceContextService),
            __param(2, modeService_1.IModeService),
            __param(3, log_1.ILogService),
            __param(4, files_1.IFileService),
            __param(5, lifecycle_2.ILifecycleService)
        ], SnippetsService);
        return SnippetsService;
    }());
    extensions_1.registerSingleton(snippets_contribution_1.ISnippetsService, SnippetsService);
    var SnippetSuggestion = /** @class */ (function () {
        function SnippetSuggestion(snippet, range) {
            this.snippet = snippet;
            this.label = snippet.prefix;
            this.detail = nls_1.localize('detail.snippet', "{0} ({1})", snippet.description || snippet.name, snippet.source);
            this.insertText = snippet.body;
            this.range = range;
            this.sortText = (snippet.snippetSource === 3 /* Extension */ ? 'z' : 'a') + "-" + snippet.prefix;
            this.noAutoAccept = true;
            this.kind = 18 /* Snippet */;
            this.insertTextIsSnippet = true;
        }
        SnippetSuggestion.prototype.resolve = function () {
            this.documentation = new htmlContent_1.MarkdownString().appendCodeblock('', new snippetParser_1.SnippetParser().text(this.snippet.codeSnippet));
            this.insertText = this.snippet.codeSnippet;
            return this;
        };
        SnippetSuggestion.compareByLabel = function (a, b) {
            return strings_1.compare(a.label, b.label);
        };
        return SnippetSuggestion;
    }());
    exports.SnippetSuggestion = SnippetSuggestion;
    var SnippetSuggestProvider = /** @class */ (function () {
        function SnippetSuggestProvider(_modeService, _snippets) {
            this._modeService = _modeService;
            this._snippets = _snippets;
            //
        }
        SnippetSuggestProvider.prototype.provideCompletionItems = function (model, position, context) {
            var languageId = this._getLanguageIdAtPosition(model, position);
            return this._snippets.getSnippets(languageId).then(function (snippets) {
                var suggestions;
                var shift = Math.max(0, position.column - 100);
                var pos = { lineNumber: position.lineNumber, column: Math.max(1, position.column - 100) };
                var lineOffsets = [];
                var linePrefixLow = model.getLineContent(position.lineNumber).substr(Math.max(0, position.column - 100), position.column - 1).toLowerCase();
                while (pos.column < position.column) {
                    var word = model.getWordAtPosition(pos);
                    if (word) {
                        // at a word
                        lineOffsets.push(word.startColumn - 1);
                        pos.column = word.endColumn + 1;
                        if (word.endColumn - 1 < linePrefixLow.length && !/\s/.test(linePrefixLow[word.endColumn - 1])) {
                            lineOffsets.push(word.endColumn - 1);
                        }
                    }
                    else if (!/\s/.test(linePrefixLow[pos.column - 1])) {
                        // at a none-whitespace character
                        lineOffsets.push(pos.column - 1);
                        pos.column += 1;
                    }
                    else {
                        // always advance!
                        pos.column += 1;
                    }
                }
                if (lineOffsets.length === 0) {
                    // no interesting spans found -> pick all snippets
                    suggestions = snippets.map(function (snippet) { return new SnippetSuggestion(snippet, range_1.Range.fromPositions(position)); });
                }
                else {
                    var consumed = new Set();
                    suggestions = [];
                    for (var _i = 0, lineOffsets_1 = lineOffsets; _i < lineOffsets_1.length; _i++) {
                        var start = lineOffsets_1[_i];
                        start -= shift;
                        for (var _a = 0, snippets_1 = snippets; _a < snippets_1.length; _a++) {
                            var snippet = snippets_1[_a];
                            if (!consumed.has(snippet) && matches(linePrefixLow, start, snippet.prefixLow, 0)) {
                                suggestions.push(new SnippetSuggestion(snippet, range_1.Range.fromPositions(position.delta(0, -(linePrefixLow.length - start)), position)));
                                consumed.add(snippet);
                            }
                        }
                    }
                }
                // dismbiguate suggestions with same labels
                suggestions.sort(SnippetSuggestion.compareByLabel);
                for (var i = 0; i < suggestions.length; i++) {
                    var item = suggestions[i];
                    var to = i + 1;
                    for (; to < suggestions.length && item.label === suggestions[to].label; to++) {
                        suggestions[to].label = nls_1.localize('snippetSuggest.longLabel', "{0}, {1}", suggestions[to].label, suggestions[to].snippet.name);
                    }
                    if (to > i + 1) {
                        suggestions[i].label = nls_1.localize('snippetSuggest.longLabel', "{0}, {1}", suggestions[i].label, suggestions[i].snippet.name);
                        i = to;
                    }
                }
                return { suggestions: suggestions };
            });
        };
        SnippetSuggestProvider.prototype.resolveCompletionItem = function (model, position, item) {
            return (item instanceof SnippetSuggestion) ? item.resolve() : item;
        };
        SnippetSuggestProvider.prototype._getLanguageIdAtPosition = function (model, position) {
            // validate the `languageId` to ensure this is a user
            // facing language with a name and the chance to have
            // snippets, else fall back to the outer language
            model.tokenizeIfCheap(position.lineNumber);
            var languageId = model.getLanguageIdAtPosition(position.lineNumber, position.column);
            var language = this._modeService.getLanguageIdentifier(languageId).language;
            if (!this._modeService.getLanguageName(language)) {
                languageId = model.getLanguageIdentifier().id;
            }
            return languageId;
        };
        SnippetSuggestProvider = __decorate([
            __param(0, modeService_1.IModeService),
            __param(1, snippets_contribution_1.ISnippetsService)
        ], SnippetSuggestProvider);
        return SnippetSuggestProvider;
    }());
    exports.SnippetSuggestProvider = SnippetSuggestProvider;
    function matches(pattern, patternStart, word, wordStart) {
        while (patternStart < pattern.length && wordStart < word.length) {
            if (pattern[patternStart] === word[wordStart]) {
                patternStart += 1;
            }
            wordStart += 1;
        }
        return patternStart === pattern.length;
    }
    function getNonWhitespacePrefix(model, position) {
        /**
         * Do not analyze more characters
         */
        var MAX_PREFIX_LENGTH = 100;
        var line = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
        var minChIndex = Math.max(0, line.length - MAX_PREFIX_LENGTH);
        for (var chIndex = line.length - 1; chIndex >= minChIndex; chIndex--) {
            var ch = line.charAt(chIndex);
            if (/\s/.test(ch)) {
                return line.substr(chIndex + 1);
            }
        }
        if (minChIndex === 0) {
            return line;
        }
        return '';
    }
    exports.getNonWhitespacePrefix = getNonWhitespacePrefix;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[333/*vs/workbench/parts/snippets/electron-browser/tabCompletion*/], __M([0/*require*/,1/*exports*/,10/*vs/platform/contextkey/common/contextkey*/,117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/,192/*vs/workbench/parts/snippets/electron-browser/snippetsService*/,22/*vs/base/common/strings*/,4/*vs/base/common/lifecycle*/,48/*vs/editor/common/core/range*/,56/*vs/editor/browser/editorExtensions*/,136/*vs/editor/contrib/snippet/snippetController2*/,211/*vs/editor/contrib/suggest/suggest*/,114/*vs/editor/common/editorContextKeys*/]), function (require, exports, contextkey_1, snippets_contribution_1, snippetsService_1, strings_1, lifecycle_1, range_1, editorExtensions_1, snippetController2_1, suggest_1, editorContextKeys_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TabCompletionController = /** @class */ (function () {
        function TabCompletionController(_editor, _snippetService, contextKeyService) {
            var _this = this;
            this._editor = _editor;
            this._snippetService = _snippetService;
            this._activeSnippets = [];
            this._hasSnippets = TabCompletionController.ContextKey.bindTo(contextKeyService);
            this._configListener = this._editor.onDidChangeConfiguration(function (e) {
                if (e.contribInfo) {
                    _this._update();
                }
            });
            this._update();
        }
        TabCompletionController.get = function (editor) {
            return editor.getContribution(TabCompletionController.ID);
        };
        TabCompletionController.prototype.getId = function () {
            return TabCompletionController.ID;
        };
        TabCompletionController.prototype.dispose = function () {
            lifecycle_1.dispose(this._configListener);
            lifecycle_1.dispose(this._selectionListener);
        };
        TabCompletionController.prototype._update = function () {
            var _this = this;
            var enabled = this._editor.getConfiguration().contribInfo.tabCompletion === 'onlySnippets';
            if (this._enabled !== enabled) {
                this._enabled = enabled;
                if (!this._enabled) {
                    lifecycle_1.dispose(this._selectionListener);
                }
                else {
                    this._selectionListener = this._editor.onDidChangeCursorSelection(function (e) { return _this._updateSnippets(); });
                    if (this._editor.getModel()) {
                        this._updateSnippets();
                    }
                }
            }
        };
        TabCompletionController.prototype._updateSnippets = function () {
            // reset first
            this._activeSnippets = [];
            // lots of dance for getting the
            var selection = this._editor.getSelection();
            var model = this._editor.getModel();
            model.tokenizeIfCheap(selection.positionLineNumber);
            var id = model.getLanguageIdAtPosition(selection.positionLineNumber, selection.positionColumn);
            var snippets = this._snippetService.getSnippetsSync(id);
            if (!snippets) {
                // nothing for this language
                this._hasSnippets.set(false);
                return;
            }
            if (range_1.Range.isEmpty(selection)) {
                // empty selection -> real text (no whitespace) left of cursor
                var prefix = snippetsService_1.getNonWhitespacePrefix(model, selection.getPosition());
                if (prefix) {
                    for (var _i = 0, snippets_1 = snippets; _i < snippets_1.length; _i++) {
                        var snippet = snippets_1[_i];
                        if (strings_1.endsWith(prefix, snippet.prefix)) {
                            this._activeSnippets.push(snippet);
                        }
                    }
                }
            }
            else if (!range_1.Range.spansMultipleLines(selection) && model.getValueLengthInRange(selection) <= 100) {
                // actual selection -> snippet must be a full match
                var selected = model.getValueInRange(selection);
                if (selected) {
                    for (var _a = 0, snippets_2 = snippets; _a < snippets_2.length; _a++) {
                        var snippet = snippets_2[_a];
                        if (selected === snippet.prefix) {
                            this._activeSnippets.push(snippet);
                        }
                    }
                }
            }
            this._hasSnippets.set(this._activeSnippets.length > 0);
        };
        TabCompletionController.prototype.performSnippetCompletions = function () {
            var _this = this;
            if (this._activeSnippets.length === 1) {
                // one -> just insert
                var snippet = this._activeSnippets[0];
                snippetController2_1.SnippetController2.get(this._editor).insert(snippet.codeSnippet, snippet.prefix.length, 0);
            }
            else if (this._activeSnippets.length > 1) {
                // two or more -> show IntelliSense box
                suggest_1.showSimpleSuggestions(this._editor, this._activeSnippets.map(function (snippet) {
                    var position = _this._editor.getPosition();
                    var range = range_1.Range.fromPositions(position.delta(0, -snippet.prefix.length), position);
                    return new snippetsService_1.SnippetSuggestion(snippet, range);
                }));
            }
        };
        TabCompletionController.ID = 'editor.tabCompletionController';
        TabCompletionController.ContextKey = new contextkey_1.RawContextKey('hasSnippetCompletions', undefined);
        TabCompletionController = __decorate([
            __param(1, snippets_contribution_1.ISnippetsService),
            __param(2, contextkey_1.IContextKeyService)
        ], TabCompletionController);
        return TabCompletionController;
    }());
    exports.TabCompletionController = TabCompletionController;
    editorExtensions_1.registerEditorContribution(TabCompletionController);
    var TabCompletionCommand = editorExtensions_1.EditorCommand.bindToContribution(TabCompletionController.get);
    editorExtensions_1.registerEditorCommand(new TabCompletionCommand({
        id: 'insertSnippet',
        precondition: TabCompletionController.ContextKey,
        handler: function (x) { return x.performSnippetCompletions(); },
        kbOpts: {
            weight: 100 /* EditorContrib */,
            kbExpr: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.editorTextFocus, editorContextKeys_1.EditorContextKeys.tabDoesNotMoveFocus, snippetController2_1.SnippetController2.InSnippetMode.toNegated()),
            primary: 2 /* Tab */
        }
    }));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[81/*vs/workbench/services/panel/common/panelService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IPanelService = instantiation_1.createDecorator('panelService');
});

define(__m[49/*vs/workbench/services/part/common/partService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function PositionToString(position) {
        switch (position) {
            case 0 /* LEFT */: return 'LEFT';
            case 1 /* RIGHT */: return 'RIGHT';
            case 2 /* BOTTOM */: return 'BOTTOM';
        }
    }
    exports.PositionToString = PositionToString;
    exports.IPartService = instantiation_1.createDecorator('partService');
});























define(__m[336/*vs/workbench/browser/actions/toggleSidebarPosition*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,49/*vs/workbench/services/part/common/partService*/,7/*vs/platform/configuration/common/configuration*/]), function (require, exports, nls, platform_1, actions_1, actions_2, actions_3, partService_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleSidebarPositionAction = /** @class */ (function (_super) {
        __extends(ToggleSidebarPositionAction, _super);
        function ToggleSidebarPositionAction(id, label, partService, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.partService = partService;
            _this.configurationService = configurationService;
            _this.enabled = !!_this.partService && !!_this.configurationService;
            return _this;
        }
        ToggleSidebarPositionAction.prototype.run = function () {
            var position = this.partService.getSideBarPosition();
            var newPositionValue = (position === 0 /* LEFT */) ? 'right' : 'left';
            return this.configurationService.updateValue(ToggleSidebarPositionAction.sidebarPositionConfigurationKey, newPositionValue, 1 /* USER */);
        };
        ToggleSidebarPositionAction.getLabel = function (partService) {
            return partService.getSideBarPosition() === 0 /* LEFT */ ? nls.localize('moveSidebarRight', "Move Side Bar Right") : nls.localize('moveSidebarLeft', "Move Side Bar Left");
        };
        ToggleSidebarPositionAction.ID = 'workbench.action.toggleSidebarPosition';
        ToggleSidebarPositionAction.LABEL = nls.localize('toggleSidebarPosition', "Toggle Side Bar Position");
        ToggleSidebarPositionAction.sidebarPositionConfigurationKey = 'workbench.sideBar.location';
        ToggleSidebarPositionAction = __decorate([
            __param(2, partService_1.IPartService),
            __param(3, configuration_1.IConfigurationService)
        ], ToggleSidebarPositionAction);
        return ToggleSidebarPositionAction;
    }(actions_1.Action));
    exports.ToggleSidebarPositionAction = ToggleSidebarPositionAction;
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleSidebarPositionAction, ToggleSidebarPositionAction.ID, ToggleSidebarPositionAction.LABEL), 'View: Toggle Side Bar Position', nls.localize('view', "View"));
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarAppearanceMenu, {
        group: '2_workbench_layout',
        command: {
            id: ToggleSidebarPositionAction.ID,
            title: nls.localize({ key: 'miMoveSidebarLeftRight', comment: ['&& denotes a mnemonic'] }, "&&Move Side Bar Left/Right")
        },
        order: 2
    });
});























define(__m[337/*vs/workbench/browser/actions/toggleSidebarVisibility*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,49/*vs/workbench/services/part/common/partService*/]), function (require, exports, nls, platform_1, actions_1, actions_2, actions_3, partService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleSidebarVisibilityAction = /** @class */ (function (_super) {
        __extends(ToggleSidebarVisibilityAction, _super);
        function ToggleSidebarVisibilityAction(id, label, partService) {
            var _this = _super.call(this, id, label) || this;
            _this.partService = partService;
            _this.enabled = !!_this.partService;
            return _this;
        }
        ToggleSidebarVisibilityAction.prototype.run = function () {
            var hideSidebar = this.partService.isVisible(1 /* SIDEBAR_PART */);
            return this.partService.setSideBarHidden(hideSidebar);
        };
        ToggleSidebarVisibilityAction.ID = 'workbench.action.toggleSidebarVisibility';
        ToggleSidebarVisibilityAction.LABEL = nls.localize('toggleSidebar', "Toggle Side Bar Visibility");
        ToggleSidebarVisibilityAction = __decorate([
            __param(2, partService_1.IPartService)
        ], ToggleSidebarVisibilityAction);
        return ToggleSidebarVisibilityAction;
    }(actions_1.Action));
    exports.ToggleSidebarVisibilityAction = ToggleSidebarVisibilityAction;
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleSidebarVisibilityAction, ToggleSidebarVisibilityAction.ID, ToggleSidebarVisibilityAction.LABEL, { primary: 2048 /* CtrlCmd */ | 32 /* KEY_B */ }), 'View: Toggle Side Bar Visibility', nls.localize('view', "View"));
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarAppearanceMenu, {
        group: '2_workbench_layout',
        command: {
            id: ToggleSidebarVisibilityAction.ID,
            title: nls.localize({ key: 'miToggleSidebar', comment: ['&& denotes a mnemonic'] }, "&&Toggle Side Bar")
        },
        order: 1
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[338/*vs/workbench/browser/actions/toggleZenMode*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,15/*vs/base/common/actions*/,65/*vs/base/common/keyCodes*/,9/*vs/platform/registry/common/platform*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,49/*vs/workbench/services/part/common/partService*/]), function (require, exports, nls, actions_1, keyCodes_1, platform_1, actions_2, actions_3, partService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ToggleZenMode = /** @class */ (function (_super) {
        __extends(ToggleZenMode, _super);
        function ToggleZenMode(id, label, partService) {
            var _this = _super.call(this, id, label) || this;
            _this.partService = partService;
            _this.enabled = !!_this.partService;
            return _this;
        }
        ToggleZenMode.prototype.run = function () {
            this.partService.toggleZenMode();
            return Promise.resolve(null);
        };
        ToggleZenMode.ID = 'workbench.action.toggleZenMode';
        ToggleZenMode.LABEL = nls.localize('toggleZenMode', "Toggle Zen Mode");
        ToggleZenMode = __decorate([
            __param(2, partService_1.IPartService)
        ], ToggleZenMode);
        return ToggleZenMode;
    }(actions_1.Action));
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ToggleZenMode, ToggleZenMode.ID, ToggleZenMode.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 56 /* KEY_Z */) }), 'View: Toggle Zen Mode', nls.localize('view', "View"));
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarAppearanceMenu, {
        group: '1_toggle_view',
        command: {
            id: ToggleZenMode.ID,
            title: nls.localize('miToggleZenMode', "Toggle Zen Mode")
        },
        order: 2
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[339/*vs/workbench/browser/parts/editor/editorControl*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,8/*vs/base/browser/dom*/,9/*vs/platform/registry/common/platform*/,105/*vs/workbench/browser/editor*/,5/*vs/base/common/winjs.base*/,49/*vs/workbench/services/part/common/partService*/,3/*vs/platform/instantiation/common/instantiation*/,99/*vs/platform/progress/common/progress*/,87/*vs/workbench/browser/parts/editor/editor*/,6/*vs/base/common/event*/]), function (require, exports, lifecycle_1, dom_1, platform_1, editor_1, winjs_base_1, partService_1, instantiation_1, progress_1, editor_2, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditorControl = /** @class */ (function (_super) {
        __extends(EditorControl, _super);
        function EditorControl(parent, groupView, partService, instantiationService, progressService) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            _this.groupView = groupView;
            _this.partService = partService;
            _this.instantiationService = instantiationService;
            _this._onDidFocus = _this._register(new event_1.Emitter());
            _this._onDidSizeConstraintsChange = _this._register(new event_1.Emitter());
            _this.controls = [];
            _this.activeControlDisposeables = [];
            _this.editorOperation = _this._register(new progress_1.LongRunningOperation(progressService));
            return _this;
        }
        Object.defineProperty(EditorControl.prototype, "minimumWidth", {
            get: function () { return this._activeControl ? this._activeControl.minimumWidth : editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "minimumHeight", {
            get: function () { return this._activeControl ? this._activeControl.minimumHeight : editor_2.DEFAULT_EDITOR_MIN_DIMENSIONS.height; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "maximumWidth", {
            get: function () { return this._activeControl ? this._activeControl.maximumWidth : editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "maximumHeight", {
            get: function () { return this._activeControl ? this._activeControl.maximumHeight : editor_2.DEFAULT_EDITOR_MAX_DIMENSIONS.height; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "onDidFocus", {
            get: function () { return this._onDidFocus.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "onDidSizeConstraintsChange", {
            get: function () { return this._onDidSizeConstraintsChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorControl.prototype, "activeControl", {
            get: function () {
                return this._activeControl;
            },
            enumerable: true,
            configurable: true
        });
        EditorControl.prototype.openEditor = function (editor, options) {
            // Editor control
            var descriptor = platform_1.Registry.as(editor_1.Extensions.Editors).getEditor(editor);
            var control = this.doShowEditorControl(descriptor, options);
            // Set input
            return this.doSetInput(control, editor, options).then((function (editorChanged) { return ({ control: control, editorChanged: editorChanged }); }));
        };
        EditorControl.prototype.doShowEditorControl = function (descriptor, options) {
            // Return early if the currently active editor control can handle the input
            if (this._activeControl && descriptor.describes(this._activeControl)) {
                return this._activeControl;
            }
            // Hide active one first
            this.doHideActiveEditorControl();
            // Create editor
            var control = this.doCreateEditorControl(descriptor);
            // Set editor as active
            this.doSetActiveControl(control);
            // Show editor
            this.parent.appendChild(control.getContainer());
            dom_1.show(control.getContainer());
            // Indicate to editor that it is now visible
            control.setVisible(true, this.groupView);
            // Layout
            if (this.dimension) {
                control.layout(this.dimension);
            }
            return control;
        };
        EditorControl.prototype.doCreateEditorControl = function (descriptor) {
            // Instantiate editor
            var control = this.doInstantiateEditorControl(descriptor);
            // Create editor container as needed
            if (!control.getContainer()) {
                var controlInstanceContainer = document.createElement('div');
                dom_1.addClass(controlInstanceContainer, 'editor-instance');
                controlInstanceContainer.id = descriptor.getId();
                control.create(controlInstanceContainer);
            }
            return control;
        };
        EditorControl.prototype.doInstantiateEditorControl = function (descriptor) {
            // Return early if already instantiated
            var existingControl = this.controls.filter(function (control) { return descriptor.describes(control); })[0];
            if (existingControl) {
                return existingControl;
            }
            // Otherwise instantiate new
            var control = this._register(descriptor.instantiate(this.instantiationService));
            this.controls.push(control);
            return control;
        };
        EditorControl.prototype.doSetActiveControl = function (control) {
            var _this = this;
            this._activeControl = control;
            // Clear out previous active control listeners
            this.activeControlDisposeables = lifecycle_1.dispose(this.activeControlDisposeables);
            // Listen to control changes
            if (control) {
                this.activeControlDisposeables.push(control.onDidSizeConstraintsChange(function (e) { return _this._onDidSizeConstraintsChange.fire(e); }));
                this.activeControlDisposeables.push(control.onDidFocus(function () { return _this._onDidFocus.fire(); }));
            }
            // Indicate that size constraints could have changed due to new editor
            this._onDidSizeConstraintsChange.fire();
        };
        EditorControl.prototype.doSetInput = function (control, editor, options) {
            // If the input did not change, return early and only apply the options
            // unless the options instruct us to force open it even if it is the same
            var forceReload = options && options.forceReload;
            var inputMatches = control.input && control.input.matches(editor);
            if (inputMatches && !forceReload) {
                // Forward options
                control.setOptions(options);
                // Still focus as needed
                var focus_1 = !options || !options.preserveFocus;
                if (focus_1) {
                    control.focus();
                }
                return winjs_base_1.TPromise.as(false);
            }
            // Show progress while setting input after a certain timeout. If the workbench is opening
            // be more relaxed about progress showing by increasing the delay a little bit to reduce flicker.
            var operation = this.editorOperation.start(this.partService.isCreated() ? 800 : 3200);
            // Call into editor control
            var editorWillChange = !inputMatches;
            return winjs_base_1.TPromise.wrap(control.setInput(editor, options, operation.token)).then(function () {
                // Focus (unless prevented or another operation is running)
                if (operation.isCurrent()) {
                    var focus_2 = !options || !options.preserveFocus;
                    if (focus_2) {
                        control.focus();
                    }
                }
                // Operation done
                operation.stop();
                return editorWillChange;
            }, function (e) {
                // Operation done
                operation.stop();
                return winjs_base_1.TPromise.wrapError(e);
            });
        };
        EditorControl.prototype.doHideActiveEditorControl = function () {
            if (!this._activeControl) {
                return;
            }
            // Stop any running operation
            this.editorOperation.stop();
            // Remove control from parent and hide
            var controlInstanceContainer = this._activeControl.getContainer();
            this.parent.removeChild(controlInstanceContainer);
            dom_1.hide(controlInstanceContainer);
            // Indicate to editor control
            this._activeControl.clearInput();
            this._activeControl.setVisible(false, this.groupView);
            // Clear active control
            this.doSetActiveControl(null);
        };
        EditorControl.prototype.closeEditor = function (editor) {
            if (this._activeControl && editor.matches(this._activeControl.input)) {
                this.doHideActiveEditorControl();
            }
        };
        EditorControl.prototype.layout = function (dimension) {
            this.dimension = dimension;
            if (this._activeControl && this.dimension) {
                this._activeControl.layout(this.dimension);
            }
        };
        EditorControl.prototype.shutdown = function () {
            // Forward to all editor controls
            this.controls.forEach(function (editor) { return editor.shutdown(); });
        };
        EditorControl.prototype.dispose = function () {
            this.activeControlDisposeables = lifecycle_1.dispose(this.activeControlDisposeables);
            _super.prototype.dispose.call(this);
        };
        EditorControl = __decorate([
            __param(2, partService_1.IPartService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, progress_1.IProgressService)
        ], EditorControl);
        return EditorControl;
    }(lifecycle_1.Disposable));
    exports.EditorControl = EditorControl;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[197/*vs/workbench/browser/parts/quickinput/quickInput*/], __M([0/*require*/,1/*exports*/,147/*vs/workbench/common/component*/,62/*vs/platform/quickinput/common/quickInput*/,49/*vs/workbench/services/part/common/partService*/,8/*vs/base/browser/dom*/,3/*vs/platform/instantiation/common/instantiation*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,58/*vs/workbench/common/theme*/,46/*vs/platform/quickOpen/common/quickOpen*/,5/*vs/base/common/winjs.base*/,55/*vs/base/common/cancellation*/,297/*vs/workbench/browser/parts/quickinput/quickInputList*/,290/*vs/workbench/browser/parts/quickinput/quickInputBox*/,68/*vs/base/browser/keyboardEvent*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,53/*vs/workbench/browser/quickopen*/,342/*vs/base/browser/ui/countBadge/countBadge*/,40/*vs/platform/theme/common/styler*/,43/*vs/platform/environment/common/environment*/,343/*vs/base/browser/ui/progressbar/progressbar*/,6/*vs/base/common/event*/,121/*vs/base/browser/ui/button/button*/,4/*vs/base/common/lifecycle*/,196/*vs/base/common/severity*/,33/*vs/workbench/services/group/common/editorGroupsService*/,10/*vs/platform/contextkey/common/contextkey*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/,50/*vs/base/browser/ui/actionbar/actionbar*/,15/*vs/base/common/actions*/,12/*vs/base/common/uri*/,31/*vs/platform/keybinding/common/keybinding*/,19/*vs/base/common/arrays*/,17/*vs/base/common/async*/,195/*vs/workbench/browser/parts/quickinput/quickInputUtils*/,111/*vs/base/browser/browser*/,129/*vs/css!vs/workbench/browser/parts/quickinput/quickInput*/]), function (require, exports, component_1, quickInput_1, partService_1, dom, instantiation_1, themeService_1, colorRegistry_1, theme_1, quickOpen_1, winjs_base_1, cancellation_1, quickInputList_1, quickInputBox_1, keyboardEvent_1, nls_1, configuration_1, quickopen_1, countBadge_1, styler_1, environment_1, progressbar_1, event_1, button_1, lifecycle_1, severity_1, editorGroupsService_1, contextkey_1, quickopen_2, actionbar_1, actions_1, uri_1, keybinding_1, arrays_1, async_1, quickInputUtils_1, browser) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = dom.$;
    var backButton = {
        iconPath: {
            dark: uri_1.URI.parse(require.toUrl('vs/workbench/browser/parts/quickinput/media/dark/arrow-left.svg')),
            light: uri_1.URI.parse(require.toUrl('vs/workbench/browser/parts/quickinput/media/light/arrow-left.svg'))
        },
        tooltip: nls_1.localize('quickInput.back', "Back"),
        handle: -1 // TODO
    };
    var QuickInput = /** @class */ (function () {
        function QuickInput(ui) {
            this.ui = ui;
            this.visible = false;
            this._enabled = true;
            this._busy = false;
            this._ignoreFocusOut = false;
            this._buttons = [];
            this.buttonsUpdated = false;
            this.onDidTriggerButtonEmitter = new event_1.Emitter();
            this.onDidHideEmitter = new event_1.Emitter();
            this.visibleDisposables = [];
            this.disposables = [
                this.onDidTriggerButtonEmitter,
                this.onDidHideEmitter,
            ];
            this.onDidTriggerButton = this.onDidTriggerButtonEmitter.event;
            this.onDidHide = this.onDidHideEmitter.event;
        }
        Object.defineProperty(QuickInput.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                this._title = title;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "step", {
            get: function () {
                return this._steps;
            },
            set: function (step) {
                this._steps = step;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "totalSteps", {
            get: function () {
                return this._totalSteps;
            },
            set: function (totalSteps) {
                this._totalSteps = totalSteps;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "contextKey", {
            get: function () {
                return this._contextKey;
            },
            set: function (contextKey) {
                this._contextKey = contextKey;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "busy", {
            get: function () {
                return this._busy;
            },
            set: function (busy) {
                this._busy = busy;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "ignoreFocusOut", {
            get: function () {
                return this._ignoreFocusOut;
            },
            set: function (ignoreFocusOut) {
                this._ignoreFocusOut = ignoreFocusOut;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickInput.prototype, "buttons", {
            get: function () {
                return this._buttons;
            },
            set: function (buttons) {
                this._buttons = buttons;
                this.buttonsUpdated = true;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        QuickInput.prototype.show = function () {
            var _this = this;
            if (this.visible) {
                return;
            }
            this.visibleDisposables.push(this.ui.onDidTriggerButton(function (button) {
                if (_this.buttons.indexOf(button) !== -1) {
                    _this.onDidTriggerButtonEmitter.fire(button);
                }
            }));
            this.ui.show(this);
            this.visible = true;
            this.update();
        };
        QuickInput.prototype.hide = function () {
            if (!this.visible) {
                return;
            }
            this.ui.hide();
        };
        QuickInput.prototype.didHide = function () {
            this.visible = false;
            this.visibleDisposables = lifecycle_1.dispose(this.visibleDisposables);
            this.onDidHideEmitter.fire();
        };
        QuickInput.prototype.update = function () {
            var _this = this;
            if (!this.visible) {
                return;
            }
            var title = this.getTitle();
            if (this.ui.title.textContent !== title) {
                this.ui.title.textContent = title;
            }
            if (this.busy && !this.busyDelay) {
                this.busyDelay = new async_1.TimeoutTimer();
                this.busyDelay.setIfNotSet(function () {
                    if (_this.visible) {
                        _this.ui.progressBar.infinite();
                    }
                }, 800);
            }
            if (!this.busy && this.busyDelay) {
                this.ui.progressBar.stop();
                this.busyDelay.cancel();
                this.busyDelay = null;
            }
            if (this.buttonsUpdated) {
                this.buttonsUpdated = false;
                this.ui.leftActionBar.clear();
                var leftButtons = this.buttons.filter(function (button) { return button === backButton; });
                this.ui.leftActionBar.push(leftButtons.map(function (button, index) {
                    var action = new actions_1.Action("id-" + index, '', button.iconClass || quickInputUtils_1.getIconClass(button.iconPath), true, function () { return _this.onDidTriggerButtonEmitter.fire(button); });
                    action.tooltip = button.tooltip;
                    return action;
                }), { icon: true, label: false });
                this.ui.rightActionBar.clear();
                var rightButtons = this.buttons.filter(function (button) { return button !== backButton; });
                this.ui.rightActionBar.push(rightButtons.map(function (button, index) {
                    var action = new actions_1.Action("id-" + index, '', button.iconClass || quickInputUtils_1.getIconClass(button.iconPath), true, function () { return _this.onDidTriggerButtonEmitter.fire(button); });
                    action.tooltip = button.tooltip;
                    return action;
                }), { icon: true, label: false });
            }
            this.ui.ignoreFocusOut = this.ignoreFocusOut;
            this.ui.setEnabled(this.enabled);
            this.ui.setContextKey(this.contextKey);
        };
        QuickInput.prototype.getTitle = function () {
            if (this.title && this.step) {
                return this.title + " (" + this.getSteps() + ")";
            }
            if (this.title) {
                return this.title;
            }
            if (this.step) {
                return this.getSteps();
            }
            return '';
        };
        QuickInput.prototype.getSteps = function () {
            if (this.step && this.totalSteps) {
                return nls_1.localize('quickInput.steps', "{0}/{1}", this.step, this.totalSteps);
            }
            if (this.step) {
                return String(this.step);
            }
            return '';
        };
        QuickInput.prototype.dispose = function () {
            this.hide();
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return QuickInput;
    }());
    var QuickPick = /** @class */ (function (_super) {
        __extends(QuickPick, _super);
        function QuickPick(ui) {
            var _this = _super.call(this, ui) || this;
            _this._value = '';
            _this.onDidChangeValueEmitter = new event_1.Emitter();
            _this.onDidAcceptEmitter = new event_1.Emitter();
            _this._items = [];
            _this.itemsUpdated = false;
            _this._canSelectMany = false;
            _this._matchOnDescription = false;
            _this._matchOnDetail = false;
            _this._activeItems = [];
            _this.activeItemsUpdated = false;
            _this.activeItemsToConfirm = [];
            _this.onDidChangeActiveEmitter = new event_1.Emitter();
            _this._selectedItems = [];
            _this.selectedItemsUpdated = false;
            _this.selectedItemsToConfirm = [];
            _this.onDidChangeSelectionEmitter = new event_1.Emitter();
            _this.onDidTriggerItemButtonEmitter = new event_1.Emitter();
            _this.onDidChangeValue = _this.onDidChangeValueEmitter.event;
            _this.onDidAccept = _this.onDidAcceptEmitter.event;
            _this.onDidChangeActive = _this.onDidChangeActiveEmitter.event;
            _this.onDidChangeSelection = _this.onDidChangeSelectionEmitter.event;
            _this.onDidTriggerItemButton = _this.onDidTriggerItemButtonEmitter.event;
            _this.disposables.push(_this.onDidChangeValueEmitter, _this.onDidAcceptEmitter, _this.onDidChangeActiveEmitter, _this.onDidChangeSelectionEmitter, _this.onDidTriggerItemButtonEmitter);
            return _this;
        }
        Object.defineProperty(QuickPick.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value || '';
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._placeholder = placeholder;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this._items = items;
                this.itemsUpdated = true;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "canSelectMany", {
            get: function () {
                return this._canSelectMany;
            },
            set: function (canSelectMany) {
                this._canSelectMany = canSelectMany;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "matchOnDescription", {
            get: function () {
                return this._matchOnDescription;
            },
            set: function (matchOnDescription) {
                this._matchOnDescription = matchOnDescription;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "matchOnDetail", {
            get: function () {
                return this._matchOnDetail;
            },
            set: function (matchOnDetail) {
                this._matchOnDetail = matchOnDetail;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "activeItems", {
            get: function () {
                return this._activeItems;
            },
            set: function (activeItems) {
                this._activeItems = activeItems;
                this.activeItemsUpdated = true;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "selectedItems", {
            get: function () {
                return this._selectedItems;
            },
            set: function (selectedItems) {
                this._selectedItems = selectedItems;
                this.selectedItemsUpdated = true;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickPick.prototype, "keyMods", {
            get: function () {
                return this.ui.keyMods;
            },
            enumerable: true,
            configurable: true
        });
        QuickPick.prototype.show = function () {
            var _this = this;
            if (!this.visible) {
                this.visibleDisposables.push(this.ui.inputBox.onDidChange(function (value) {
                    if (value === _this.value) {
                        return;
                    }
                    _this._value = value;
                    _this.ui.list.filter(_this.ui.inputBox.value);
                    if (!_this.ui.isScreenReaderOptimized() && !_this.canSelectMany) {
                        _this.ui.list.focus('First');
                    }
                    _this.onDidChangeValueEmitter.fire(value);
                }), this.ui.inputBox.onKeyDown(function (event) {
                    switch (event.keyCode) {
                        case 18 /* DownArrow */:
                            _this.ui.list.focus('Next');
                            if (_this.canSelectMany) {
                                _this.ui.list.domFocus();
                            }
                            break;
                        case 16 /* UpArrow */:
                            if (_this.ui.list.getFocusedElements().length) {
                                _this.ui.list.focus('Previous');
                            }
                            else {
                                _this.ui.list.focus('Last');
                            }
                            if (_this.canSelectMany) {
                                _this.ui.list.domFocus();
                            }
                            break;
                        case 12 /* PageDown */:
                            if (_this.ui.list.getFocusedElements().length) {
                                _this.ui.list.focus('NextPage');
                            }
                            else {
                                _this.ui.list.focus('First');
                            }
                            if (_this.canSelectMany) {
                                _this.ui.list.domFocus();
                            }
                            break;
                        case 11 /* PageUp */:
                            if (_this.ui.list.getFocusedElements().length) {
                                _this.ui.list.focus('PreviousPage');
                            }
                            else {
                                _this.ui.list.focus('Last');
                            }
                            if (_this.canSelectMany) {
                                _this.ui.list.domFocus();
                            }
                            break;
                    }
                }), this.ui.onDidAccept(function () {
                    if (!_this.canSelectMany && _this.activeItems[0]) {
                        _this._selectedItems = [_this.activeItems[0]];
                        _this.onDidChangeSelectionEmitter.fire(_this.selectedItems);
                    }
                    _this.onDidAcceptEmitter.fire();
                }), this.ui.list.onDidChangeFocus(function (focusedItems) {
                    if (_this.activeItemsUpdated) {
                        return; // Expect another event.
                    }
                    if (_this.activeItemsToConfirm !== _this._activeItems && arrays_1.equals(focusedItems, _this._activeItems, function (a, b) { return a === b; })) {
                        return;
                    }
                    _this._activeItems = focusedItems;
                    _this.onDidChangeActiveEmitter.fire(focusedItems);
                }), this.ui.list.onDidChangeSelection(function (selectedItems) {
                    if (_this.canSelectMany) {
                        return;
                    }
                    if (_this.selectedItemsToConfirm !== _this._selectedItems && arrays_1.equals(selectedItems, _this._selectedItems, function (a, b) { return a === b; })) {
                        return;
                    }
                    _this._selectedItems = selectedItems;
                    _this.onDidChangeSelectionEmitter.fire(selectedItems);
                    _this.onDidAcceptEmitter.fire();
                }), this.ui.list.onChangedCheckedElements(function (checkedItems) {
                    if (!_this.canSelectMany) {
                        return;
                    }
                    if (_this.selectedItemsToConfirm !== _this._selectedItems && arrays_1.equals(checkedItems, _this._selectedItems, function (a, b) { return a === b; })) {
                        return;
                    }
                    _this._selectedItems = checkedItems;
                    _this.onDidChangeSelectionEmitter.fire(checkedItems);
                }), this.ui.list.onButtonTriggered(function (event) { return _this.onDidTriggerItemButtonEmitter.fire(event); }), this.registerQuickNavigation());
            }
            _super.prototype.show.call(this); // TODO: Why have show() bubble up while update() trickles down? (Could move setComboboxAccessibility() here.)
        };
        QuickPick.prototype.registerQuickNavigation = function () {
            var _this = this;
            return dom.addDisposableListener(this.ui.container, dom.EventType.KEY_UP, function (e) {
                if (_this.canSelectMany || !_this.quickNavigate) {
                    return;
                }
                var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                var keyCode = keyboardEvent.keyCode;
                // Select element when keys are pressed that signal it
                var quickNavKeys = _this.quickNavigate.keybindings;
                var wasTriggerKeyPressed = keyCode === 3 /* Enter */ || quickNavKeys.some(function (k) {
                    var _a = k.getParts(), firstPart = _a[0], chordPart = _a[1];
                    if (chordPart) {
                        return false;
                    }
                    if (firstPart.shiftKey && keyCode === 4 /* Shift */) {
                        if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
                            return false; // this is an optimistic check for the shift key being used to navigate back in quick open
                        }
                        return true;
                    }
                    if (firstPart.altKey && keyCode === 6 /* Alt */) {
                        return true;
                    }
                    if (firstPart.ctrlKey && keyCode === 5 /* Ctrl */) {
                        return true;
                    }
                    if (firstPart.metaKey && keyCode === 57 /* Meta */) {
                        return true;
                    }
                    return false;
                });
                if (wasTriggerKeyPressed && _this.activeItems[0]) {
                    _this._selectedItems = [_this.activeItems[0]];
                    _this.onDidChangeSelectionEmitter.fire(_this.selectedItems);
                    _this.onDidAcceptEmitter.fire();
                }
            });
        };
        QuickPick.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.visible) {
                return;
            }
            if (this.ui.inputBox.value !== this.value) {
                this.ui.inputBox.value = this.value;
            }
            if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {
                this.ui.inputBox.placeholder = (this.placeholder || '');
            }
            if (this.itemsUpdated) {
                this.itemsUpdated = false;
                this.ui.list.setElements(this.items);
                this.ui.list.filter(this.ui.inputBox.value);
                this.ui.checkAll.checked = this.ui.list.getAllVisibleChecked();
                this.ui.visibleCount.setCount(this.ui.list.getVisibleCount());
                this.ui.count.setCount(this.ui.list.getCheckedCount());
                if (!this.ui.isScreenReaderOptimized() && !this.canSelectMany) {
                    this.ui.list.focus('First');
                }
            }
            if (this.ui.container.classList.contains('show-checkboxes') !== !!this.canSelectMany) {
                if (this.canSelectMany) {
                    this.ui.list.clearFocus();
                }
                else if (!this.ui.isScreenReaderOptimized()) {
                    this.ui.list.focus('First');
                }
            }
            if (this.activeItemsUpdated) {
                this.activeItemsUpdated = false;
                this.activeItemsToConfirm = this._activeItems;
                this.ui.list.setFocusedElements(this.activeItems);
                if (this.activeItemsToConfirm === this._activeItems) {
                    this.activeItemsToConfirm = null;
                }
            }
            if (this.selectedItemsUpdated) {
                this.selectedItemsUpdated = false;
                this.selectedItemsToConfirm = this._selectedItems;
                if (this.canSelectMany) {
                    this.ui.list.setCheckedElements(this.selectedItems);
                }
                else {
                    this.ui.list.setSelectedElements(this.selectedItems);
                }
                if (this.selectedItemsToConfirm === this._selectedItems) {
                    this.selectedItemsToConfirm = null;
                }
            }
            this.ui.list.matchOnDescription = this.matchOnDescription;
            this.ui.list.matchOnDetail = this.matchOnDetail;
            this.ui.setComboboxAccessibility(true);
            this.ui.inputBox.setAttribute('aria-label', QuickPick.INPUT_BOX_ARIA_LABEL);
            this.ui.setVisibilities(this.canSelectMany ? { title: !!this.title || !!this.step, checkAll: true, inputBox: true, visibleCount: true, count: true, ok: true, list: true } : { title: !!this.title || !!this.step, inputBox: true, visibleCount: true, list: true });
        };
        QuickPick.INPUT_BOX_ARIA_LABEL = nls_1.localize('quickInputBox.ariaLabel', "Type to narrow down results.");
        return QuickPick;
    }(QuickInput));
    var InputBox = /** @class */ (function (_super) {
        __extends(InputBox, _super);
        function InputBox(ui) {
            var _this = _super.call(this, ui) || this;
            _this._value = '';
            _this.valueSelectionUpdated = true;
            _this._password = false;
            _this.noValidationMessage = InputBox.noPromptMessage;
            _this.onDidValueChangeEmitter = new event_1.Emitter();
            _this.onDidAcceptEmitter = new event_1.Emitter();
            _this.onDidChangeValue = _this.onDidValueChangeEmitter.event;
            _this.onDidAccept = _this.onDidAcceptEmitter.event;
            _this.disposables.push(_this.onDidValueChangeEmitter, _this.onDidAcceptEmitter);
            return _this;
        }
        Object.defineProperty(InputBox.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value || '';
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "valueSelection", {
            set: function (valueSelection) {
                this._valueSelection = valueSelection;
                this.valueSelectionUpdated = true;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._placeholder = placeholder;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "password", {
            get: function () {
                return this._password;
            },
            set: function (password) {
                this._password = password;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "prompt", {
            get: function () {
                return this._prompt;
            },
            set: function (prompt) {
                this._prompt = prompt;
                this.noValidationMessage = prompt
                    ? nls_1.localize('inputModeEntryDescription', "{0} (Press 'Enter' to confirm or 'Escape' to cancel)", prompt)
                    : InputBox.noPromptMessage;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "validationMessage", {
            get: function () {
                return this._validationMessage;
            },
            set: function (validationMessage) {
                this._validationMessage = validationMessage;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        InputBox.prototype.show = function () {
            var _this = this;
            if (!this.visible) {
                this.visibleDisposables.push(this.ui.inputBox.onDidChange(function (value) {
                    if (value === _this.value) {
                        return;
                    }
                    _this._value = value;
                    _this.onDidValueChangeEmitter.fire(value);
                }), this.ui.onDidAccept(function () { return _this.onDidAcceptEmitter.fire(); }));
                this.valueSelectionUpdated = true;
            }
            _super.prototype.show.call(this);
        };
        InputBox.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.visible) {
                return;
            }
            if (this.ui.inputBox.value !== this.value) {
                this.ui.inputBox.value = this.value;
            }
            if (this.valueSelectionUpdated) {
                this.valueSelectionUpdated = false;
                this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] });
            }
            if (this.ui.inputBox.placeholder !== (this.placeholder || '')) {
                this.ui.inputBox.placeholder = (this.placeholder || '');
            }
            if (this.ui.inputBox.password !== this.password) {
                this.ui.inputBox.password = this.password;
            }
            if (!this.validationMessage && this.ui.message.textContent !== this.noValidationMessage) {
                this.ui.message.textContent = this.noValidationMessage;
                this.ui.inputBox.showDecoration(severity_1.default.Ignore);
            }
            if (this.validationMessage && this.ui.message.textContent !== this.validationMessage) {
                this.ui.message.textContent = this.validationMessage;
                this.ui.inputBox.showDecoration(severity_1.default.Error);
            }
            this.ui.setVisibilities({ title: !!this.title || !!this.step, inputBox: true, message: true });
        };
        InputBox.noPromptMessage = nls_1.localize('inputModeEntry', "Press 'Enter' to confirm your input or 'Escape' to cancel");
        return InputBox;
    }(QuickInput));
    var QuickInputService = /** @class */ (function (_super) {
        __extends(QuickInputService, _super);
        function QuickInputService(environmentService, configurationService, instantiationService, partService, quickOpenService, editorGroupService, keybindingService, contextKeyService, themeService) {
            var _this = _super.call(this, QuickInputService.ID, themeService) || this;
            _this.environmentService = environmentService;
            _this.configurationService = configurationService;
            _this.instantiationService = instantiationService;
            _this.partService = partService;
            _this.quickOpenService = quickOpenService;
            _this.editorGroupService = editorGroupService;
            _this.keybindingService = keybindingService;
            _this.contextKeyService = contextKeyService;
            _this.idPrefix = 'quickInput_'; // Constant since there is still only one.
            _this.comboboxAccessibility = false;
            _this.enabled = true;
            _this.inQuickOpenWidgets = {};
            _this.contexts = Object.create(null);
            _this.onDidAcceptEmitter = _this._register(new event_1.Emitter());
            _this.onDidTriggerButtonEmitter = _this._register(new event_1.Emitter());
            _this.keyMods = { ctrlCmd: false, alt: false };
            _this.backButton = backButton;
            _this.inQuickOpenContext = new contextkey_1.RawContextKey('inQuickOpen', false).bindTo(contextKeyService);
            _this._register(_this.quickOpenService.onShow(function () { return _this.inQuickOpen('quickOpen', true); }));
            _this._register(_this.quickOpenService.onHide(function () { return _this.inQuickOpen('quickOpen', false); }));
            _this.registerKeyModsListeners();
            return _this;
        }
        QuickInputService.prototype.inQuickOpen = function (widget, open) {
            if (open) {
                this.inQuickOpenWidgets[widget] = true;
            }
            else {
                delete this.inQuickOpenWidgets[widget];
            }
            if (Object.keys(this.inQuickOpenWidgets).length) {
                if (!this.inQuickOpenContext.get()) {
                    this.inQuickOpenContext.set(true);
                }
            }
            else {
                if (this.inQuickOpenContext.get()) {
                    this.inQuickOpenContext.reset();
                }
            }
        };
        QuickInputService.prototype.setContextKey = function (id) {
            var key;
            if (id) {
                key = this.contexts[id];
                if (!key) {
                    key = new contextkey_1.RawContextKey(id, false)
                        .bindTo(this.contextKeyService);
                    this.contexts[id] = key;
                }
            }
            if (key && key.get()) {
                return; // already active context
            }
            this.resetContextKeys();
            if (key) {
                key.set(true);
            }
        };
        QuickInputService.prototype.resetContextKeys = function () {
            for (var key in this.contexts) {
                if (this.contexts[key].get()) {
                    this.contexts[key].reset();
                }
            }
        };
        QuickInputService.prototype.registerKeyModsListeners = function () {
            var _this = this;
            var workbench = this.partService.getWorkbenchElement();
            this._register(dom.addDisposableListener(workbench, dom.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                switch (event.keyCode) {
                    case 5 /* Ctrl */:
                    case 57 /* Meta */:
                        _this.keyMods.ctrlCmd = true;
                        break;
                    case 6 /* Alt */:
                        _this.keyMods.alt = true;
                        break;
                }
            }));
            this._register(dom.addDisposableListener(workbench, dom.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                switch (event.keyCode) {
                    case 5 /* Ctrl */:
                    case 57 /* Meta */:
                        _this.keyMods.ctrlCmd = false;
                        break;
                    case 6 /* Alt */:
                        _this.keyMods.alt = false;
                        break;
                }
            }));
        };
        QuickInputService.prototype.create = function () {
            var _this = this;
            if (this.ui) {
                return;
            }
            var workbench = this.partService.getWorkbenchElement();
            var container = dom.append(workbench, $('.quick-input-widget.show-file-icons'));
            container.tabIndex = -1;
            container.style.display = 'none';
            this.titleBar = dom.append(container, $('.quick-input-titlebar'));
            var leftActionBar = this._register(new actionbar_1.ActionBar(this.titleBar));
            leftActionBar.domNode.classList.add('quick-input-left-action-bar');
            var title = dom.append(this.titleBar, $('.quick-input-title'));
            var rightActionBar = this._register(new actionbar_1.ActionBar(this.titleBar));
            rightActionBar.domNode.classList.add('quick-input-right-action-bar');
            var headerContainer = dom.append(container, $('.quick-input-header'));
            var checkAll = dom.append(headerContainer, $('input.quick-input-check-all'));
            checkAll.type = 'checkbox';
            this._register(dom.addStandardDisposableListener(checkAll, dom.EventType.CHANGE, function (e) {
                var checked = checkAll.checked;
                list.setAllVisibleChecked(checked);
            }));
            this._register(dom.addDisposableListener(checkAll, dom.EventType.CLICK, function (e) {
                if (e.x || e.y) { // Avoid 'click' triggered by 'space'...
                    inputBox.setFocus();
                }
            }));
            this.filterContainer = dom.append(headerContainer, $('.quick-input-filter'));
            var inputBox = this._register(new quickInputBox_1.QuickInputBox(this.filterContainer));
            inputBox.setAttribute('aria-describedby', this.idPrefix + "message");
            this.visibleCountContainer = dom.append(this.filterContainer, $('.quick-input-visible-count'));
            this.visibleCountContainer.setAttribute('aria-live', 'polite');
            this.visibleCountContainer.setAttribute('aria-atomic', 'true');
            var visibleCount = new countBadge_1.CountBadge(this.visibleCountContainer, { countFormat: nls_1.localize({ key: 'quickInput.visibleCount', comment: ['This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers.'] }, "{0} Results") });
            this.countContainer = dom.append(this.filterContainer, $('.quick-input-count'));
            this.countContainer.setAttribute('aria-live', 'polite');
            var count = new countBadge_1.CountBadge(this.countContainer, { countFormat: nls_1.localize({ key: 'quickInput.countSelected', comment: ['This tells the user how many items are selected in a list of items to select from. The items can be anything.'] }, "{0} Selected") });
            this._register(styler_1.attachBadgeStyler(count, this.themeService));
            this.okContainer = dom.append(headerContainer, $('.quick-input-action'));
            this.ok = new button_1.Button(this.okContainer);
            styler_1.attachButtonStyler(this.ok, this.themeService);
            this.ok.label = nls_1.localize('ok', "OK");
            this._register(this.ok.onDidClick(function (e) {
                _this.onDidAcceptEmitter.fire();
            }));
            var message = dom.append(container, $("#" + this.idPrefix + "message.quick-input-message"));
            var progressBar = new progressbar_1.ProgressBar(container);
            dom.addClass(progressBar.getContainer(), 'quick-input-progress');
            this._register(styler_1.attachProgressBarStyler(progressBar, this.themeService));
            var list = this._register(this.instantiationService.createInstance(quickInputList_1.QuickInputList, container, this.idPrefix + 'list'));
            this._register(list.onChangedAllVisibleChecked(function (checked) {
                checkAll.checked = checked;
            }));
            this._register(list.onChangedVisibleCount(function (c) {
                visibleCount.setCount(c);
            }));
            this._register(list.onChangedCheckedCount(function (c) {
                count.setCount(c);
            }));
            this._register(list.onLeave(function () {
                // Defer to avoid the input field reacting to the triggering key.
                setTimeout(function () {
                    inputBox.setFocus();
                    if (_this.controller instanceof QuickPick && _this.controller.canSelectMany) {
                        list.clearFocus();
                    }
                }, 0);
            }));
            this._register(list.onDidChangeFocus(function () {
                if (_this.comboboxAccessibility) {
                    _this.ui.inputBox.setAttribute('aria-activedescendant', _this.ui.list.getActiveDescendant());
                }
            }));
            var focusTracker = dom.trackFocus(container);
            this._register(focusTracker);
            this._register(focusTracker.onDidBlur(function () {
                if (!_this.ui.ignoreFocusOut && !_this.environmentService.args['sticky-quickopen'] && _this.configurationService.getValue(quickopen_1.CLOSE_ON_FOCUS_LOST_CONFIG)) {
                    _this.hide(true);
                }
            }));
            this._register(dom.addDisposableListener(container, dom.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                switch (event.keyCode) {
                    case 3 /* Enter */:
                        dom.EventHelper.stop(e, true);
                        _this.onDidAcceptEmitter.fire();
                        break;
                    case 9 /* Escape */:
                        dom.EventHelper.stop(e, true);
                        _this.hide();
                        break;
                    case 2 /* Tab */:
                        if (!event.altKey && !event.ctrlKey && !event.metaKey) {
                            var selectors = ['.action-label.icon'];
                            if (container.classList.contains('show-checkboxes')) {
                                selectors.push('input');
                            }
                            else {
                                selectors.push('input[type=text]');
                            }
                            if (_this.ui.list.isDisplayed()) {
                                selectors.push('.monaco-list');
                            }
                            var stops = container.querySelectorAll(selectors.join(', '));
                            if (event.shiftKey && event.target === stops[0]) {
                                dom.EventHelper.stop(e, true);
                                stops[stops.length - 1].focus();
                            }
                            else if (!event.shiftKey && event.target === stops[stops.length - 1]) {
                                dom.EventHelper.stop(e, true);
                                stops[0].focus();
                            }
                        }
                        break;
                }
            }));
            this._register(this.quickOpenService.onShow(function () { return _this.hide(true); }));
            this.ui = {
                container: container,
                leftActionBar: leftActionBar,
                title: title,
                rightActionBar: rightActionBar,
                checkAll: checkAll,
                inputBox: inputBox,
                visibleCount: visibleCount,
                count: count,
                message: message,
                progressBar: progressBar,
                list: list,
                onDidAccept: this.onDidAcceptEmitter.event,
                onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
                ignoreFocusOut: false,
                keyMods: this.keyMods,
                isScreenReaderOptimized: function () { return _this.isScreenReaderOptimized(); },
                show: function (controller) { return _this.show(controller); },
                hide: function () { return _this.hide(); },
                setVisibilities: function (visibilities) { return _this.setVisibilities(visibilities); },
                setComboboxAccessibility: function (enabled) { return _this.setComboboxAccessibility(enabled); },
                setEnabled: function (enabled) { return _this.setEnabled(enabled); },
                setContextKey: function (contextKey) { return _this.setContextKey(contextKey); },
            };
            this.updateStyles();
        };
        QuickInputService.prototype.pick = function (picks, options, token) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            return new winjs_base_1.TPromise(function (doResolve, reject) {
                var resolve = function (result) {
                    resolve = doResolve;
                    if (options.onKeyMods) {
                        options.onKeyMods(input.keyMods);
                    }
                    doResolve(result);
                };
                if (token.isCancellationRequested) {
                    resolve(undefined);
                    return;
                }
                var input = _this.createQuickPick();
                var activeItem;
                var disposables = [
                    input,
                    input.onDidAccept(function () {
                        if (input.canSelectMany) {
                            resolve(input.selectedItems.slice());
                            input.hide();
                        }
                        else {
                            var result = input.activeItems[0];
                            if (result) {
                                resolve(result);
                                input.hide();
                            }
                        }
                    }),
                    input.onDidChangeActive(function (items) {
                        var focused = items[0];
                        if (focused && options.onDidFocus) {
                            options.onDidFocus(focused);
                        }
                    }),
                    input.onDidChangeSelection(function (items) {
                        if (!input.canSelectMany) {
                            var result = items[0];
                            if (result) {
                                resolve(result);
                                input.hide();
                            }
                        }
                    }),
                    input.onDidTriggerItemButton(function (event) { return options.onDidTriggerItemButton && options.onDidTriggerItemButton(__assign({}, event, { removeItem: function () {
                            var index = input.items.indexOf(event.item);
                            if (index !== -1) {
                                var items = input.items.slice();
                                items.splice(index, 1);
                                input.items = items;
                            }
                        } })); }),
                    input.onDidChangeValue(function (value) {
                        if (activeItem && !value && (input.activeItems.length !== 1 || input.activeItems[0] !== activeItem)) {
                            input.activeItems = [activeItem];
                        }
                    }),
                    token.onCancellationRequested(function () {
                        input.hide();
                    }),
                    input.onDidHide(function () {
                        lifecycle_1.dispose(disposables);
                        resolve(undefined);
                    }),
                ];
                input.canSelectMany = options.canPickMany;
                input.placeholder = options.placeHolder;
                input.ignoreFocusOut = options.ignoreFocusLost;
                input.matchOnDescription = options.matchOnDescription;
                input.matchOnDetail = options.matchOnDetail;
                input.quickNavigate = options.quickNavigate;
                input.contextKey = options.contextKey;
                input.busy = true;
                winjs_base_1.TPromise.join([picks, options.activeItem])
                    .then(function (_a) {
                    var items = _a[0], _activeItem = _a[1];
                    activeItem = _activeItem;
                    input.busy = false;
                    input.items = items;
                    if (input.canSelectMany) {
                        input.selectedItems = items.filter(function (item) { return item.type !== 'separator' && item.picked; });
                    }
                    if (activeItem) {
                        input.activeItems = [activeItem];
                    }
                });
                input.show();
                winjs_base_1.TPromise.wrap(picks).then(null, function (err) {
                    reject(err);
                    input.hide();
                });
            });
        };
        QuickInputService.prototype.input = function (options, token) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            return new winjs_base_1.TPromise(function (resolve, reject) {
                if (token.isCancellationRequested) {
                    resolve(undefined);
                    return;
                }
                var input = _this.createInputBox();
                var validateInput = options.validateInput || (function () { return winjs_base_1.TPromise.as(undefined); });
                var onDidValueChange = event_1.debounceEvent(input.onDidChangeValue, function (last, cur) { return cur; }, 100);
                var validationValue = options.value || '';
                var validation = winjs_base_1.TPromise.wrap(validateInput(validationValue));
                var disposables = [
                    input,
                    onDidValueChange(function (value) {
                        if (value !== validationValue) {
                            validation = winjs_base_1.TPromise.wrap(validateInput(value));
                            validationValue = value;
                        }
                        validation.then(function (result) {
                            if (value === validationValue) {
                                input.validationMessage = result;
                            }
                        });
                    }),
                    input.onDidAccept(function () {
                        var value = input.value;
                        if (value !== validationValue) {
                            validation = winjs_base_1.TPromise.wrap(validateInput(value));
                            validationValue = value;
                        }
                        validation.then(function (result) {
                            if (!result) {
                                resolve(value);
                                input.hide();
                            }
                            else if (value === validationValue) {
                                input.validationMessage = result;
                            }
                        });
                    }),
                    token.onCancellationRequested(function () {
                        input.hide();
                    }),
                    input.onDidHide(function () {
                        lifecycle_1.dispose(disposables);
                        resolve(undefined);
                    }),
                ];
                input.value = options.value;
                input.valueSelection = options.valueSelection;
                input.prompt = options.prompt;
                input.placeholder = options.placeHolder;
                input.password = options.password;
                input.ignoreFocusOut = options.ignoreFocusLost;
                input.show();
            });
        };
        QuickInputService.prototype.createQuickPick = function () {
            this.create();
            return new QuickPick(this.ui);
        };
        QuickInputService.prototype.createInputBox = function () {
            this.create();
            return new InputBox(this.ui);
        };
        QuickInputService.prototype.show = function (controller) {
            this.create();
            this.quickOpenService.close();
            var oldController = this.controller;
            this.controller = controller;
            if (oldController) {
                oldController.didHide();
            }
            this.setEnabled(true);
            this.ui.leftActionBar.clear();
            this.ui.title.textContent = '';
            this.ui.rightActionBar.clear();
            this.ui.checkAll.checked = false;
            // this.ui.inputBox.value = ''; Avoid triggering an event.
            this.ui.inputBox.placeholder = '';
            this.ui.inputBox.password = false;
            this.ui.inputBox.showDecoration(severity_1.default.Ignore);
            this.ui.visibleCount.setCount(0);
            this.ui.count.setCount(0);
            this.ui.message.textContent = '';
            this.ui.progressBar.stop();
            this.ui.list.setElements([]);
            this.ui.list.matchOnDescription = false;
            this.ui.list.matchOnDetail = false;
            this.ui.ignoreFocusOut = false;
            this.setComboboxAccessibility(false);
            this.ui.inputBox.removeAttribute('aria-label');
            var keybinding = this.keybindingService.lookupKeybinding(BackAction.ID);
            backButton.tooltip = keybinding ? nls_1.localize('quickInput.backWithKeybinding', "Back ({0})", keybinding.getLabel()) : nls_1.localize('quickInput.back', "Back");
            this.inQuickOpen('quickInput', true);
            this.resetContextKeys();
            this.ui.container.style.display = '';
            this.updateLayout();
            this.ui.inputBox.setFocus();
        };
        QuickInputService.prototype.setVisibilities = function (visibilities) {
            this.ui.title.style.display = visibilities.title ? '' : 'none';
            this.ui.checkAll.style.display = visibilities.checkAll ? '' : 'none';
            this.filterContainer.style.display = visibilities.inputBox ? '' : 'none';
            this.visibleCountContainer.style.display = visibilities.visibleCount ? '' : 'none';
            this.countContainer.style.display = visibilities.count ? '' : 'none';
            this.okContainer.style.display = visibilities.ok ? '' : 'none';
            this.ui.message.style.display = visibilities.message ? '' : 'none';
            this.ui.list.display(visibilities.list);
            this.ui.container.classList[visibilities.checkAll ? 'add' : 'remove']('show-checkboxes');
            this.updateLayout(); // TODO
        };
        QuickInputService.prototype.setComboboxAccessibility = function (enabled) {
            if (enabled !== this.comboboxAccessibility) {
                this.comboboxAccessibility = enabled;
                if (this.comboboxAccessibility) {
                    this.ui.inputBox.setAttribute('role', 'combobox');
                    this.ui.inputBox.setAttribute('aria-haspopup', 'true');
                    this.ui.inputBox.setAttribute('aria-autocomplete', 'list');
                    this.ui.inputBox.setAttribute('aria-activedescendant', this.ui.list.getActiveDescendant());
                }
                else {
                    this.ui.inputBox.removeAttribute('role');
                    this.ui.inputBox.removeAttribute('aria-haspopup');
                    this.ui.inputBox.removeAttribute('aria-autocomplete');
                    this.ui.inputBox.removeAttribute('aria-activedescendant');
                }
            }
        };
        QuickInputService.prototype.isScreenReaderOptimized = function () {
            var detected = browser.getAccessibilitySupport() === 2 /* Enabled */;
            var config = this.configurationService.getValue('editor').accessibilitySupport;
            return config === 'on' || (config === 'auto' && detected);
        };
        QuickInputService.prototype.setEnabled = function (enabled) {
            if (enabled !== this.enabled) {
                this.enabled = enabled;
                for (var _i = 0, _a = this.ui.leftActionBar.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    item.getAction().enabled = enabled;
                }
                for (var _b = 0, _c = this.ui.rightActionBar.items; _b < _c.length; _b++) {
                    var item = _c[_b];
                    item.getAction().enabled = enabled;
                }
                this.ui.checkAll.disabled = !enabled;
                // this.ui.inputBox.enabled = enabled; Avoid loosing focus.
                this.ok.enabled = enabled;
                this.ui.list.enabled = enabled;
            }
        };
        QuickInputService.prototype.hide = function (focusLost) {
            var controller = this.controller;
            if (controller) {
                this.controller = null;
                this.inQuickOpen('quickInput', false);
                this.resetContextKeys();
                this.ui.container.style.display = 'none';
                if (!focusLost) {
                    this.editorGroupService.activeGroup.focus();
                }
                controller.didHide();
            }
        };
        QuickInputService.prototype.focus = function () {
            if (this.isDisplayed()) {
                this.ui.inputBox.setFocus();
            }
        };
        QuickInputService.prototype.toggle = function () {
            if (this.isDisplayed() && this.controller instanceof QuickPick && this.controller.canSelectMany) {
                this.ui.list.toggleCheckbox();
            }
        };
        QuickInputService.prototype.navigate = function (next, quickNavigate) {
            if (this.isDisplayed() && this.ui.list.isDisplayed()) {
                this.ui.list.focus(next ? 'Next' : 'Previous');
                if (quickNavigate && this.controller instanceof QuickPick) {
                    this.controller.quickNavigate = quickNavigate;
                }
            }
        };
        QuickInputService.prototype.accept = function () {
            this.onDidAcceptEmitter.fire();
            return winjs_base_1.TPromise.as(undefined);
        };
        QuickInputService.prototype.back = function () {
            this.onDidTriggerButtonEmitter.fire(this.backButton);
            return winjs_base_1.TPromise.as(undefined);
        };
        QuickInputService.prototype.cancel = function () {
            this.hide();
            return winjs_base_1.TPromise.as(undefined);
        };
        QuickInputService.prototype.layout = function (dimension) {
            this.layoutDimensions = dimension;
            this.updateLayout();
        };
        QuickInputService.prototype.updateLayout = function () {
            if (this.layoutDimensions && this.ui) {
                var titlebarOffset = this.partService.getTitleBarOffset();
                this.ui.container.style.top = titlebarOffset + "px";
                var style = this.ui.container.style;
                var width = Math.min(this.layoutDimensions.width * 0.62 /* golden cut */, QuickInputService.MAX_WIDTH);
                style.width = width + 'px';
                style.marginLeft = '-' + (width / 2) + 'px';
                this.ui.inputBox.layout();
                this.ui.list.layout();
            }
        };
        QuickInputService.prototype.updateStyles = function () {
            var theme = this.themeService.getTheme();
            if (this.ui) {
                // TODO
                var titleColor = { dark: 'rgba(255, 255, 255, 0.105)', light: 'rgba(0,0,0,.06)', hc: 'black' }[theme.type];
                this.titleBar.style.backgroundColor = titleColor ? titleColor.toString() : null;
                this.ui.inputBox.style(theme);
                var sideBarBackground = theme.getColor(theme_1.SIDE_BAR_BACKGROUND);
                this.ui.container.style.backgroundColor = sideBarBackground ? sideBarBackground.toString() : null;
                var sideBarForeground = theme.getColor(theme_1.SIDE_BAR_FOREGROUND);
                this.ui.container.style.color = sideBarForeground ? sideBarForeground.toString() : null;
                var contrastBorderColor = theme.getColor(colorRegistry_1.contrastBorder);
                this.ui.container.style.border = contrastBorderColor ? "1px solid " + contrastBorderColor : null;
                var widgetShadowColor = theme.getColor(colorRegistry_1.widgetShadow);
                this.ui.container.style.boxShadow = widgetShadowColor ? "0 5px 8px " + widgetShadowColor : null;
            }
        };
        QuickInputService.prototype.isDisplayed = function () {
            return this.ui && this.ui.container.style.display !== 'none';
        };
        QuickInputService.ID = 'workbench.component.quickinput';
        QuickInputService.MAX_WIDTH = 600; // Max total width of quick open widget
        QuickInputService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, partService_1.IPartService),
            __param(4, quickOpen_1.IQuickOpenService),
            __param(5, editorGroupsService_1.IEditorGroupsService),
            __param(6, keybinding_1.IKeybindingService),
            __param(7, contextkey_1.IContextKeyService),
            __param(8, themeService_1.IThemeService)
        ], QuickInputService);
        return QuickInputService;
    }(component_1.Component));
    exports.QuickInputService = QuickInputService;
    exports.QuickPickManyToggle = {
        id: 'workbench.action.quickPickManyToggle',
        weight: 200 /* WorkbenchContrib */,
        when: quickopen_2.inQuickOpenContext,
        primary: undefined,
        handler: function (accessor) {
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            quickInputService.toggle();
        }
    };
    var BackAction = /** @class */ (function (_super) {
        __extends(BackAction, _super);
        function BackAction(id, label, quickInputService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickInputService = quickInputService;
            return _this;
        }
        BackAction.prototype.run = function () {
            this.quickInputService.back();
            return winjs_base_1.TPromise.as(null);
        };
        BackAction.ID = 'workbench.action.quickInputBack';
        BackAction.LABEL = nls_1.localize('back', "Back");
        BackAction = __decorate([
            __param(2, quickInput_1.IQuickInputService)
        ], BackAction);
        return BackAction;
    }(actions_1.Action));
    exports.BackAction = BackAction;
});

define(__m[345/*vs/workbench/browser/parts/quickinput/quickInput.contribution*/], __M([0/*require*/,1/*exports*/,197/*vs/workbench/browser/parts/quickinput/quickInput*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,9/*vs/platform/registry/common/platform*/,47/*vs/workbench/common/actions*/,23/*vs/platform/actions/common/actions*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/]), function (require, exports, quickInput_1, keybindingsRegistry_1, platform_1, actions_1, actions_2, quickopen_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(quickInput_1.QuickPickManyToggle);
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(quickInput_1.BackAction, quickInput_1.BackAction.ID, quickInput_1.BackAction.LABEL, { primary: null, win: { primary: 512 /* Alt */ | 15 /* LeftArrow */ }, mac: { primary: 256 /* WinCtrl */ | 83 /* US_MINUS */ }, linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 83 /* US_MINUS */ } }, quickopen_1.inQuickOpenContext, 200 /* WorkbenchContrib */ + 50), 'Back');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[346/*vs/workbench/services/history/electron-browser/history*/], __M([0/*require*/,1/*exports*/,25/*vs/base/common/errors*/,12/*vs/base/common/uri*/,13/*vs/workbench/common/editor*/,11/*vs/workbench/services/editor/common/editorService*/,16/*vs/platform/files/common/files*/,100/*vs/editor/common/core/selection*/,20/*vs/platform/workspace/common/workspace*/,4/*vs/base/common/lifecycle*/,44/*vs/platform/storage/common/storage*/,63/*vs/platform/lifecycle/common/lifecycle*/,9/*vs/platform/registry/common/platform*/,6/*vs/base/common/event*/,7/*vs/platform/configuration/common/configuration*/,33/*vs/workbench/services/group/common/editorGroupsService*/,42/*vs/platform/windows/common/windows*/,45/*vs/editor/browser/editorBrowser*/,71/*vs/platform/search/common/search*/,3/*vs/platform/instantiation/common/instantiation*/,175/*vs/workbench/electron-browser/resources*/,49/*vs/workbench/services/part/common/partService*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, errors, uri_1, editor_1, editorService_1, files_1, selection_1, workspace_1, lifecycle_1, storage_1, lifecycle_2, platform_1, event_1, configuration_1, editorGroupsService_1, windows_1, editorBrowser_1, search_1, instantiation_1, resources_1, partService_1, contextkey_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Stores the selection & view state of an editor and allows to compare it to other selection states.
     */
    var TextEditorState = /** @class */ (function () {
        function TextEditorState(_editorInput, _selection) {
            this._editorInput = _editorInput;
            this._selection = _selection;
            this.textEditorSelection = selection_1.Selection.isISelection(_selection) ? {
                startLineNumber: _selection.startLineNumber,
                startColumn: _selection.startColumn
            } : void 0;
        }
        Object.defineProperty(TextEditorState.prototype, "editorInput", {
            get: function () {
                return this._editorInput;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEditorState.prototype, "selection", {
            get: function () {
                return this.textEditorSelection;
            },
            enumerable: true,
            configurable: true
        });
        TextEditorState.prototype.justifiesNewPushState = function (other, event) {
            if (event && event.source === 'api') {
                return true; //alwaysletAPIsourcewin(e.g."Gotodefinition"shouldaddahistoryentry)
            }
            if (!this._editorInput.matches(other._editorInput)) {
                return true; // different editor inputs
            }
            if (!selection_1.Selection.isISelection(this._selection) || !selection_1.Selection.isISelection(other._selection)) {
                return true; // unknown selections
            }
            var thisLineNumber = Math.min(this._selection.selectionStartLineNumber, this._selection.positionLineNumber);
            var otherLineNumber = Math.min(other._selection.selectionStartLineNumber, other._selection.positionLineNumber);
            if (Math.abs(thisLineNumber - otherLineNumber) < TextEditorState.EDITOR_SELECTION_THRESHOLD) {
                return false; // ignore selection changes in the range of EditorState.EDITOR_SELECTION_THRESHOLD lines
            }
            return true;
        };
        TextEditorState.EDITOR_SELECTION_THRESHOLD = 10; // number of lines to move in editor to justify for new state
        return TextEditorState;
    }());
    exports.TextEditorState = TextEditorState;
    var HistoryService = /** @class */ (function (_super) {
        __extends(HistoryService, _super);
        function HistoryService(editorService, editorGroupService, contextService, storageService, configurationService, lifecycleService, fileService, windowService, instantiationService, partService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.contextService = contextService;
            _this.storageService = storageService;
            _this.configurationService = configurationService;
            _this.lifecycleService = lifecycleService;
            _this.fileService = fileService;
            _this.windowService = windowService;
            _this.instantiationService = instantiationService;
            _this.partService = partService;
            _this.contextKeyService = contextKeyService;
            _this.activeEditorListeners = [];
            _this.canNavigateBackContextKey = (new contextkey_1.RawContextKey('canNavigateBack', false)).bindTo(_this.contextKeyService);
            _this.canNavigateForwardContextKey = (new contextkey_1.RawContextKey('canNavigateForward', false)).bindTo(_this.contextKeyService);
            _this.fileInputFactory = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).getFileInputFactory();
            _this.index = -1;
            _this.lastIndex = -1;
            _this.stack = [];
            _this.recentlyClosedFiles = [];
            _this.loaded = false;
            _this.resourceFilter = _this._register(instantiationService.createInstance(resources_1.ResourceGlobMatcher, function (root) { return _this.getExcludes(root); }, function (event) { return event.affectsConfiguration(files_1.FILES_EXCLUDE_CONFIG) || event.affectsConfiguration('search.exclude'); }));
            _this.registerListeners();
            return _this;
        }
        HistoryService.prototype.getExcludes = function (root) {
            var scope = root ? { resource: root } : void 0;
            return search_1.getExcludes(this.configurationService.getValue(scope));
        };
        HistoryService.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.editorService.onDidActiveEditorChange(function () { return _this.onActiveEditorChanged(); }));
            this._register(this.editorService.onDidOpenEditorFail(function (event) { return _this.remove(event.editor); }));
            this._register(this.editorService.onDidCloseEditor(function (event) { return _this.onEditorClosed(event); }));
            this._register(this.lifecycleService.onShutdown(function (reason) { return _this.saveHistory(); }));
            this._register(this.fileService.onFileChanges(function (event) { return _this.onFileChanges(event); }));
            this._register(this.resourceFilter.onExpressionChange(function () { return _this.handleExcludesChange(); }));
        };
        HistoryService.prototype.onActiveEditorChanged = function () {
            var _this = this;
            var activeControl = this.editorService.activeControl;
            if (this.lastActiveEditor && this.matchesEditor(this.lastActiveEditor, activeControl)) {
                return; // return if the active editor is still the same
            }
            // Remember as last active editor (can be undefined if none opened)
            this.lastActiveEditor = activeControl ? { editor: activeControl.input, groupId: activeControl.group.id } : void 0;
            // Dispose old listeners
            lifecycle_1.dispose(this.activeEditorListeners);
            this.activeEditorListeners = [];
            // Propagate to history
            this.handleActiveEditorChange(activeControl);
            // Apply listener for selection changes if this is a text editor
            var activeTextEditorWidget = editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget);
            var activeEditor = this.editorService.activeEditor;
            if (activeTextEditorWidget) {
                // Debounce the event with a timeout of 0ms so that multiple calls to
                // editor.setSelection() are folded into one. We do not want to record
                // subsequent history navigations for such API calls.
                this.activeEditorListeners.push(event_1.debounceEvent(activeTextEditorWidget.onDidChangeCursorPosition, function (last, event) { return event; }, 0)((function (event) {
                    _this.handleEditorSelectionChangeEvent(activeControl, event);
                })));
                // Track the last edit location by tracking model content change events
                // Use a debouncer to make sure to capture the correct cursor position
                // after the model content has changed.
                this.activeEditorListeners.push(event_1.debounceEvent(activeTextEditorWidget.onDidChangeModelContent, function (last, event) { return event; }, 0)((function (event) {
                    _this.lastEditLocation = { input: activeEditor };
                    var position = activeTextEditorWidget.getPosition();
                    if (position) {
                        _this.lastEditLocation.selection = {
                            startLineNumber: position.lineNumber,
                            startColumn: position.column
                        };
                    }
                })));
            }
        };
        HistoryService.prototype.matchesEditor = function (identifier, editor) {
            if (!editor || !editor.group) {
                return false;
            }
            if (identifier.groupId !== editor.group.id) {
                return false;
            }
            return identifier.editor.matches(editor.input);
        };
        HistoryService.prototype.onFileChanges = function (e) {
            if (e.gotDeleted()) {
                this.remove(e); // remove from history files that got deleted or moved
            }
        };
        HistoryService.prototype.onEditorClosed = function (event) {
            // Track closing of editor to support to reopen closed editors (unless editor was replaced)
            if (!event.replaced) {
                var resource = event.editor ? event.editor.getResource() : void 0;
                var supportsReopen = resource && this.fileService.canHandleResource(resource); // we only support file'ish things to reopen
                if (supportsReopen) {
                    // Remove all inputs matching and add as last recently closed
                    this.removeFromRecentlyClosedFiles(event.editor);
                    this.recentlyClosedFiles.push({ resource: resource, index: event.index });
                    // Bounding
                    if (this.recentlyClosedFiles.length > HistoryService.MAX_RECENTLY_CLOSED_EDITORS) {
                        this.recentlyClosedFiles.shift();
                    }
                }
            }
        };
        HistoryService.prototype.reopenLastClosedEditor = function () {
            this.ensureHistoryLoaded();
            var lastClosedFile = this.recentlyClosedFiles.pop();
            while (lastClosedFile && this.isFileOpened(lastClosedFile.resource, this.editorGroupService.activeGroup)) {
                lastClosedFile = this.recentlyClosedFiles.pop(); // pop until we find a file that is not opened
            }
            if (lastClosedFile) {
                this.editorService.openEditor({ resource: lastClosedFile.resource, options: { pinned: true, index: lastClosedFile.index } });
            }
        };
        HistoryService.prototype.openLastEditLocation = function () {
            if (this.lastEditLocation) {
                this.doNavigate(this.lastEditLocation, true);
            }
        };
        HistoryService.prototype.forward = function (acrossEditors) {
            if (this.stack.length > this.index + 1) {
                if (acrossEditors) {
                    this.doForwardAcrossEditors();
                }
                else {
                    this.doForwardInEditors();
                }
            }
        };
        HistoryService.prototype.doForwardInEditors = function () {
            this.setIndex(this.index + 1);
            this.navigate();
        };
        HistoryService.prototype.setIndex = function (value) {
            this.lastIndex = this.index;
            this.index = value;
            this.updateContextKeys();
        };
        HistoryService.prototype.doForwardAcrossEditors = function () {
            var currentIndex = this.index;
            var currentEntry = this.stack[this.index];
            // Find the next entry that does not match our current entry
            while (this.stack.length > currentIndex + 1) {
                currentIndex++;
                var previousEntry = this.stack[currentIndex];
                if (!this.matches(currentEntry.input, previousEntry.input)) {
                    this.setIndex(currentIndex);
                    this.navigate(true /* across editors */);
                    break;
                }
            }
        };
        HistoryService.prototype.back = function (acrossEditors) {
            if (this.index > 0) {
                if (acrossEditors) {
                    this.doBackAcrossEditors();
                }
                else {
                    this.doBackInEditors();
                }
            }
        };
        HistoryService.prototype.last = function () {
            if (this.lastIndex === -1) {
                this.back();
            }
            else {
                this.setIndex(this.lastIndex);
                this.navigate();
            }
        };
        HistoryService.prototype.doBackInEditors = function () {
            this.setIndex(this.index - 1);
            this.navigate();
        };
        HistoryService.prototype.doBackAcrossEditors = function () {
            var currentIndex = this.index;
            var currentEntry = this.stack[this.index];
            // Find the next previous entry that does not match our current entry
            while (currentIndex > 0) {
                currentIndex--;
                var previousEntry = this.stack[currentIndex];
                if (!this.matches(currentEntry.input, previousEntry.input)) {
                    this.setIndex(currentIndex);
                    this.navigate(true /* across editors */);
                    break;
                }
            }
        };
        HistoryService.prototype.clear = function () {
            this.ensureHistoryLoaded();
            // Navigation (next, previous)
            this.index = -1;
            this.lastIndex = -1;
            this.stack.splice(0);
            // Closed files
            this.recentlyClosedFiles = [];
            // History
            this.clearRecentlyOpened();
            this.updateContextKeys();
        };
        HistoryService.prototype.clearRecentlyOpened = function () {
            this.history = [];
        };
        HistoryService.prototype.updateContextKeys = function () {
            this.canNavigateBackContextKey.set(this.stack.length > 0 && this.index > 0);
            this.canNavigateForwardContextKey.set(this.stack.length > 0 && this.index < this.stack.length - 1);
        };
        HistoryService.prototype.navigate = function (acrossEditors) {
            var _this = this;
            this.navigatingInStack = true;
            this.doNavigate(this.stack[this.index], !acrossEditors).then(function () {
                _this.navigatingInStack = false;
            }, function (error) {
                _this.navigatingInStack = false;
                errors.onUnexpectedError(error);
            });
        };
        HistoryService.prototype.doNavigate = function (location, withSelection) {
            var options = {
                revealIfOpened: true // support to navigate across editor groups
            };
            // Unless we navigate across editors, support selection and
            // minimize scrolling by setting revealInCenterIfOutsideViewport
            if (location.selection && withSelection) {
                options.selection = location.selection;
                options.revealInCenterIfOutsideViewport = true;
            }
            if (location.input instanceof editor_1.EditorInput) {
                return this.editorService.openEditor(location.input, options);
            }
            return this.editorService.openEditor({ resource: location.input.resource, options: options });
        };
        HistoryService.prototype.handleEditorSelectionChangeEvent = function (editor, event) {
            this.handleEditorEventInStack(editor, event);
        };
        HistoryService.prototype.handleActiveEditorChange = function (editor) {
            this.handleEditorEventInHistory(editor);
            this.handleEditorEventInStack(editor);
        };
        HistoryService.prototype.handleEditorEventInHistory = function (editor) {
            var _this = this;
            var input = editor ? editor.input : void 0;
            // Ensure we have at least a name to show and not configured to exclude input
            if (!input || !input.getName() || !this.include(input)) {
                return;
            }
            this.ensureHistoryLoaded();
            var historyInput = this.preferResourceInput(input);
            // Remove any existing entry and add to the beginning
            this.removeFromHistory(input);
            this.history.unshift(historyInput);
            // Respect max entries setting
            if (this.history.length > HistoryService.MAX_HISTORY_ITEMS) {
                this.history.pop();
            }
            // Remove this from the history unless the history input is a resource
            // that can easily be restored even when the input gets disposed
            if (historyInput instanceof editor_1.EditorInput) {
                event_1.once(historyInput.onDispose)(function () { return _this.removeFromHistory(input); });
            }
        };
        HistoryService.prototype.include = function (input) {
            if (input instanceof editor_1.EditorInput) {
                return true; // include any non files
            }
            var resourceInput = input;
            return !this.resourceFilter.matches(resourceInput.resource);
        };
        HistoryService.prototype.handleExcludesChange = function () {
            this.removeExcludedFromHistory();
        };
        HistoryService.prototype.remove = function (arg1) {
            this.removeFromHistory(arg1);
            this.removeFromStack(arg1);
            this.removeFromRecentlyClosedFiles(arg1);
            this.removeFromRecentlyOpened(arg1);
        };
        HistoryService.prototype.removeExcludedFromHistory = function () {
            var _this = this;
            this.ensureHistoryLoaded();
            this.history = this.history.filter(function (e) { return _this.include(e); });
        };
        HistoryService.prototype.removeFromHistory = function (arg1) {
            var _this = this;
            this.ensureHistoryLoaded();
            this.history = this.history.filter(function (e) { return !_this.matches(arg1, e); });
        };
        HistoryService.prototype.handleEditorEventInStack = function (control, event) {
            var codeEditor = control ? editorBrowser_1.getCodeEditor(control.getControl()) : void 0;
            // treat editor changes that happen as part of stack navigation specially
            // we do not want to add a new stack entry as a matter of navigating the
            // stack but we need to keep our currentTextEditorState up to date with
            // the navigtion that occurs.
            if (this.navigatingInStack) {
                if (codeEditor && control.input) {
                    this.currentTextEditorState = new TextEditorState(control.input, codeEditor.getSelection());
                }
                else {
                    this.currentTextEditorState = null; // we navigated to a non text editor
                }
            }
            // normal navigation not part of history navigation
            else {
                // navigation inside text editor
                if (codeEditor && control.input) {
                    this.handleTextEditorEvent(control, codeEditor, event);
                }
                // navigation to non-text editor
                else {
                    this.currentTextEditorState = null; // at this time we have no active text editor view state
                    if (control && control.input) {
                        this.handleNonTextEditorEvent(control);
                    }
                }
            }
        };
        HistoryService.prototype.handleTextEditorEvent = function (editor, editorControl, event) {
            var stateCandidate = new TextEditorState(editor.input, editorControl.getSelection());
            // Add to stack if we dont have a current state or this new state justifies a push
            if (!this.currentTextEditorState || this.currentTextEditorState.justifiesNewPushState(stateCandidate, event)) {
                this.add(editor.input, stateCandidate.selection);
            }
            // Otherwise we replace the current stack entry with this one
            else {
                this.replace(editor.input, stateCandidate.selection);
            }
            // Update our current text editor state
            this.currentTextEditorState = stateCandidate;
        };
        HistoryService.prototype.handleNonTextEditorEvent = function (editor) {
            var currentStack = this.stack[this.index];
            if (currentStack && this.matches(editor.input, currentStack.input)) {
                return; // do not push same editor input again
            }
            this.add(editor.input);
        };
        HistoryService.prototype.add = function (input, selection) {
            if (!this.navigatingInStack) {
                this.addOrReplaceInStack(input, selection);
            }
        };
        HistoryService.prototype.replace = function (input, selection) {
            if (!this.navigatingInStack) {
                this.addOrReplaceInStack(input, selection, true /* force replace */);
            }
        };
        HistoryService.prototype.addOrReplaceInStack = function (input, selection, forceReplace) {
            var _this = this;
            // Overwrite an entry in the stack if we have a matching input that comes
            // with editor options to indicate that this entry is more specific. Also
            // prevent entries that have the exact same options. Finally, Overwrite
            // entries if we detect that the change came in very fast which indicates
            // that it was not coming in from a user change but rather rapid programmatic
            // changes. We just take the last of the changes to not cause too many entries
            // on the stack.
            // We can also be instructed to force replace the last entry.
            var replace = false;
            var currentEntry = this.stack[this.index];
            if (currentEntry) {
                if (forceReplace) {
                    replace = true; // replace if we are forced to
                }
                else if (this.matches(input, currentEntry.input) && this.sameSelection(currentEntry.selection, selection)) {
                    replace = true; // replace if the input is the same as the current one and the selection as well
                }
            }
            var stackInput = this.preferResourceInput(input);
            var entry = { input: stackInput, selection: selection };
            // Replace at current position
            if (replace) {
                this.stack[this.index] = entry;
            }
            // Add to stack at current position
            else {
                // If we are not at the end of history, we remove anything after
                if (this.stack.length > this.index + 1) {
                    this.stack = this.stack.slice(0, this.index + 1);
                }
                this.stack.splice(this.index + 1, 0, entry);
                // Check for limit
                if (this.stack.length > HistoryService.MAX_STACK_ITEMS) {
                    this.stack.shift(); // remove first and dispose
                    if (this.lastIndex >= 0) {
                        this.lastIndex--;
                    }
                }
                else {
                    this.setIndex(this.index + 1);
                }
            }
            // Remove this from the stack unless the stack input is a resource
            // that can easily be restored even when the input gets disposed
            if (stackInput instanceof editor_1.EditorInput) {
                event_1.once(stackInput.onDispose)(function () { return _this.removeFromStack(input); });
            }
            // Context
            this.updateContextKeys();
        };
        HistoryService.prototype.preferResourceInput = function (input) {
            if (this.fileInputFactory.isFileInput(input)) {
                return { resource: input.getResource() };
            }
            return input;
        };
        HistoryService.prototype.sameSelection = function (selectionA, selectionB) {
            if (!selectionA && !selectionB) {
                return true;
            }
            if ((!selectionA && selectionB) || (selectionA && !selectionB)) {
                return false;
            }
            return selectionA.startLineNumber === selectionB.startLineNumber; // we consider the history entry same if we are on the same line
        };
        HistoryService.prototype.removeFromStack = function (arg1) {
            var _this = this;
            this.stack = this.stack.filter(function (e) { return !_this.matches(arg1, e.input); });
            this.index = this.stack.length - 1; // reset index
            this.lastIndex = -1;
            this.updateContextKeys();
        };
        HistoryService.prototype.removeFromRecentlyClosedFiles = function (arg1) {
            var _this = this;
            this.recentlyClosedFiles = this.recentlyClosedFiles.filter(function (e) { return !_this.matchesFile(e.resource, arg1); });
        };
        HistoryService.prototype.removeFromRecentlyOpened = function (arg1) {
            if (arg1 instanceof editor_1.EditorInput || arg1 instanceof files_1.FileChangesEvent) {
                return; // for now do not delete from file events since recently open are likely out of workspace files for which there are no delete events
            }
            var input = arg1;
            this.windowService.removeFromRecentlyOpened([input.resource]);
        };
        HistoryService.prototype.isFileOpened = function (resource, group) {
            var _this = this;
            if (!group) {
                return false;
            }
            if (!this.editorService.isOpen({ resource: resource }, group)) {
                return false; // fast check
            }
            return group.editors.some(function (e) { return _this.matchesFile(resource, e); });
        };
        HistoryService.prototype.matches = function (arg1, inputB) {
            if (arg1 instanceof files_1.FileChangesEvent) {
                if (inputB instanceof editor_1.EditorInput) {
                    return false; // we only support this for IResourceInput
                }
                var resourceInputB_1 = inputB;
                return arg1.contains(resourceInputB_1.resource, 2 /* DELETED */);
            }
            if (arg1 instanceof editor_1.EditorInput && inputB instanceof editor_1.EditorInput) {
                return arg1.matches(inputB);
            }
            if (arg1 instanceof editor_1.EditorInput) {
                return this.matchesFile(inputB.resource, arg1);
            }
            if (inputB instanceof editor_1.EditorInput) {
                return this.matchesFile(arg1.resource, inputB);
            }
            var resourceInputA = arg1;
            var resourceInputB = inputB;
            return resourceInputA && resourceInputB && resourceInputA.resource.toString() === resourceInputB.resource.toString();
        };
        HistoryService.prototype.matchesFile = function (resource, arg2) {
            if (arg2 instanceof files_1.FileChangesEvent) {
                return arg2.contains(resource, 2 /* DELETED */);
            }
            if (arg2 instanceof editor_1.EditorInput) {
                var inputResource = arg2.getResource();
                if (!inputResource) {
                    return false;
                }
                if (this.partService.isCreated() && !this.fileService.canHandleResource(inputResource)) {
                    return false; // make sure to only check this when workbench has started (for https://github.com/Microsoft/vscode/issues/48275)
                }
                return inputResource.toString() === resource.toString();
            }
            var resourceInput = arg2;
            return resourceInput && resourceInput.resource.toString() === resource.toString();
        };
        HistoryService.prototype.getHistory = function () {
            this.ensureHistoryLoaded();
            return this.history.slice(0);
        };
        HistoryService.prototype.ensureHistoryLoaded = function () {
            if (!this.loaded) {
                this.loadHistory();
            }
            this.loaded = true;
        };
        HistoryService.prototype.saveHistory = function () {
            if (!this.history) {
                return; // nothing to save because history was not used
            }
            var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
            var entries = this.history.map(function (input) {
                // Editor input: try via factory
                if (input instanceof editor_1.EditorInput) {
                    var factory = registry.getEditorInputFactory(input.getTypeId());
                    if (factory) {
                        var deserialized = factory.serialize(input);
                        if (deserialized) {
                            return { editorInputJSON: { typeId: input.getTypeId(), deserialized: deserialized } };
                        }
                    }
                }
                // File resource: via URI.toJSON()
                else {
                    return { resourceJSON: input.resource.toJSON() };
                }
                return void 0;
            }).filter(function (serialized) { return !!serialized; });
            this.storageService.store(HistoryService.STORAGE_KEY, JSON.stringify(entries), 1 /* WORKSPACE */);
        };
        HistoryService.prototype.loadHistory = function () {
            var _this = this;
            var entries = [];
            var entriesRaw = this.storageService.get(HistoryService.STORAGE_KEY, 1 /* WORKSPACE */);
            if (entriesRaw) {
                entries = JSON.parse(entriesRaw).filter(function (entry) { return !!entry; });
            }
            var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
            this.history = entries.map(function (entry) {
                var serializedEditorHistoryEntry = entry;
                // File resource: via URI.revive()
                if (serializedEditorHistoryEntry.resourceJSON) {
                    return { resource: uri_1.URI.revive(serializedEditorHistoryEntry.resourceJSON) };
                }
                // Editor input: via factory
                var editorInputJSON = serializedEditorHistoryEntry.editorInputJSON;
                if (editorInputJSON && editorInputJSON.deserialized) {
                    var factory = registry.getEditorInputFactory(editorInputJSON.typeId);
                    if (factory) {
                        var input_1 = factory.deserialize(_this.instantiationService, editorInputJSON.deserialized);
                        if (input_1) {
                            event_1.once(input_1.onDispose)(function () { return _this.removeFromHistory(input_1); }); // remove from history once disposed
                        }
                        return input_1;
                    }
                }
                return void 0;
            }).filter(function (input) { return !!input; });
        };
        HistoryService.prototype.getLastActiveWorkspaceRoot = function (schemeFilter) {
            // No Folder: return early
            var folders = this.contextService.getWorkspace().folders;
            if (folders.length === 0) {
                return void 0;
            }
            // Single Folder: return early
            if (folders.length === 1) {
                var resource = folders[0].uri;
                if (!schemeFilter || resource.scheme === schemeFilter) {
                    return resource;
                }
                return void 0;
            }
            // Multiple folders: find the last active one
            var history = this.getHistory();
            for (var i = 0; i < history.length; i++) {
                var input = history[i];
                if (input instanceof editor_1.EditorInput) {
                    continue;
                }
                var resourceInput = input;
                if (schemeFilter && resourceInput.resource.scheme !== schemeFilter) {
                    continue;
                }
                var resourceWorkspace = this.contextService.getWorkspaceFolder(resourceInput.resource);
                if (resourceWorkspace) {
                    return resourceWorkspace.uri;
                }
            }
            // fallback to first workspace matching scheme filter if any
            for (var i = 0; i < folders.length; i++) {
                var resource = folders[i].uri;
                if (!schemeFilter || resource.scheme === schemeFilter) {
                    return resource;
                }
            }
            return void 0;
        };
        HistoryService.prototype.getLastActiveFile = function (schemeFilter) {
            var history = this.getHistory();
            for (var i = 0; i < history.length; i++) {
                var resource = void 0;
                var input = history[i];
                if (input instanceof editor_1.EditorInput) {
                    resource = editor_1.toResource(input, { filter: schemeFilter });
                }
                else {
                    resource = input.resource;
                }
                if (resource && resource.scheme === schemeFilter) {
                    return resource;
                }
            }
            return void 0;
        };
        HistoryService.STORAGE_KEY = 'history.entries';
        HistoryService.MAX_HISTORY_ITEMS = 200;
        HistoryService.MAX_STACK_ITEMS = 20;
        HistoryService.MAX_RECENTLY_CLOSED_EDITORS = 20;
        HistoryService = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, editorGroupsService_1.IEditorGroupsService),
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, storage_1.IStorageService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, lifecycle_2.ILifecycleService),
            __param(6, files_1.IFileService),
            __param(7, windows_1.IWindowsService),
            __param(8, instantiation_1.IInstantiationService),
            __param(9, partService_1.IPartService),
            __param(10, contextkey_1.IContextKeyService)
        ], HistoryService);
        return HistoryService;
    }(lifecycle_1.Disposable));
    exports.HistoryService = HistoryService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[199/*vs/workbench/services/preferences/common/keybindingsEditorModel*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,19/*vs/base/common/arrays*/,22/*vs/base/common/strings*/,18/*vs/base/common/platform*/,69/*vs/base/common/filters*/,9/*vs/platform/registry/common/platform*/,327/*vs/base/common/keybindingLabels*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,13/*vs/workbench/common/editor*/,70/*vs/workbench/services/extensions/common/extensions*/,31/*vs/platform/keybinding/common/keybinding*/,324/*vs/platform/keybinding/common/resolvedKeybindingItem*/,323/*vs/platform/keybinding/common/keybindingResolver*/]), function (require, exports, nls_1, arrays_1, strings, platform_1, filters_1, platform_2, keybindingLabels_1, actions_1, actions_2, editor_1, extensions_1, keybinding_1, resolvedKeybindingItem_1, keybindingResolver_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KEYBINDING_ENTRY_TEMPLATE_ID = 'keybinding.entry.template';
    exports.KEYBINDING_HEADER_TEMPLATE_ID = 'keybinding.header.template';
    var SOURCE_DEFAULT = nls_1.localize('default', "Default");
    var SOURCE_USER = nls_1.localize('user', "User");
    var wordFilter = filters_1.or(filters_1.matchesPrefix, filters_1.matchesWords, filters_1.matchesContiguousSubString);
    var KeybindingsEditorModel = /** @class */ (function (_super) {
        __extends(KeybindingsEditorModel, _super);
        function KeybindingsEditorModel(os, keybindingsService, extensionService) {
            var _this = _super.call(this) || this;
            _this.keybindingsService = keybindingsService;
            _this.extensionService = extensionService;
            _this.modifierLabels = {
                ui: keybindingLabels_1.UILabelProvider.modifierLabels[os],
                aria: keybindingLabels_1.AriaLabelProvider.modifierLabels[os],
                user: keybindingLabels_1.UserSettingsLabelProvider.modifierLabels[os]
            };
            return _this;
        }
        KeybindingsEditorModel.prototype.fetch = function (searchValue, sortByPrecedence) {
            if (sortByPrecedence === void 0) { sortByPrecedence = false; }
            var keybindingItems = sortByPrecedence ? this._keybindingItemsSortedByPrecedence : this._keybindingItems;
            if (/@source:\s*(user|default)/i.test(searchValue)) {
                keybindingItems = this.filterBySource(keybindingItems, searchValue);
                searchValue = searchValue.replace(/@source:\s*(user|default)/i, '');
            }
            searchValue = searchValue.trim();
            if (!searchValue) {
                return keybindingItems.map(function (keybindingItem) { return ({ id: KeybindingsEditorModel.getId(keybindingItem), keybindingItem: keybindingItem, templateId: exports.KEYBINDING_ENTRY_TEMPLATE_ID }); });
            }
            return this.filterByText(keybindingItems, searchValue);
        };
        KeybindingsEditorModel.prototype.filterBySource = function (keybindingItems, searchValue) {
            if (/@source:\s*default/i.test(searchValue)) {
                return keybindingItems.filter(function (k) { return k.source === SOURCE_DEFAULT; });
            }
            if (/@source:\s*user/i.test(searchValue)) {
                return keybindingItems.filter(function (k) { return k.source === SOURCE_USER; });
            }
            return keybindingItems;
        };
        KeybindingsEditorModel.prototype.filterByText = function (keybindingItems, searchValue) {
            var quoteAtFirstChar = searchValue.charAt(0) === '"';
            var quoteAtLastChar = searchValue.charAt(searchValue.length - 1) === '"';
            var completeMatch = quoteAtFirstChar && quoteAtLastChar;
            if (quoteAtFirstChar) {
                searchValue = searchValue.substring(1);
            }
            if (quoteAtLastChar) {
                searchValue = searchValue.substring(0, searchValue.length - 1);
            }
            searchValue = searchValue.trim();
            var result = [];
            var words = searchValue.split(' ');
            var keybindingWords = this.splitKeybindingWords(words);
            for (var _i = 0, keybindingItems_1 = keybindingItems; _i < keybindingItems_1.length; _i++) {
                var keybindingItem = keybindingItems_1[_i];
                var keybindingMatches = new KeybindingItemMatches(this.modifierLabels, keybindingItem, searchValue, words, keybindingWords, completeMatch);
                if (keybindingMatches.commandIdMatches
                    || keybindingMatches.commandLabelMatches
                    || keybindingMatches.commandDefaultLabelMatches
                    || keybindingMatches.sourceMatches
                    || keybindingMatches.whenMatches
                    || keybindingMatches.keybindingMatches) {
                    result.push({
                        id: KeybindingsEditorModel.getId(keybindingItem),
                        templateId: exports.KEYBINDING_ENTRY_TEMPLATE_ID,
                        commandLabelMatches: keybindingMatches.commandLabelMatches,
                        commandDefaultLabelMatches: keybindingMatches.commandDefaultLabelMatches,
                        keybindingItem: keybindingItem,
                        keybindingMatches: keybindingMatches.keybindingMatches,
                        commandIdMatches: keybindingMatches.commandIdMatches,
                        sourceMatches: keybindingMatches.sourceMatches,
                        whenMatches: keybindingMatches.whenMatches
                    });
                }
            }
            return result;
        };
        KeybindingsEditorModel.prototype.splitKeybindingWords = function (wordsSeparatedBySpaces) {
            var result = [];
            for (var _i = 0, wordsSeparatedBySpaces_1 = wordsSeparatedBySpaces; _i < wordsSeparatedBySpaces_1.length; _i++) {
                var word = wordsSeparatedBySpaces_1[_i];
                result.push.apply(result, word.split('+').filter(function (w) { return !!w; }));
            }
            return result;
        };
        KeybindingsEditorModel.prototype.resolve = function (editorActionsLabels) {
            var _this = this;
            return this.extensionService.whenInstalledExtensionsRegistered()
                .then(function () {
                var workbenchActionsRegistry = platform_2.Registry.as(actions_2.Extensions.WorkbenchActions);
                _this._keybindingItemsSortedByPrecedence = [];
                var boundCommands = new Map();
                for (var _i = 0, _a = _this.keybindingsService.getKeybindings(); _i < _a.length; _i++) {
                    var keybinding = _a[_i];
                    if (keybinding.command) { // Skip keybindings without commands
                        _this._keybindingItemsSortedByPrecedence.push(KeybindingsEditorModel.toKeybindingEntry(keybinding.command, keybinding, workbenchActionsRegistry, editorActionsLabels));
                        boundCommands.set(keybinding.command, true);
                    }
                }
                var commandsWithDefaultKeybindings = _this.keybindingsService.getDefaultKeybindings().map(function (keybinding) { return keybinding.command; });
                for (var _b = 0, _c = keybindingResolver_1.KeybindingResolver.getAllUnboundCommands(boundCommands); _b < _c.length; _b++) {
                    var command = _c[_b];
                    var keybindingItem = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, command, null, null, commandsWithDefaultKeybindings.indexOf(command) === -1);
                    _this._keybindingItemsSortedByPrecedence.push(KeybindingsEditorModel.toKeybindingEntry(command, keybindingItem, workbenchActionsRegistry, editorActionsLabels));
                }
                _this._keybindingItems = _this._keybindingItemsSortedByPrecedence.slice(0).sort(function (a, b) { return KeybindingsEditorModel.compareKeybindingData(a, b); });
                return _this;
            });
        };
        KeybindingsEditorModel.getId = function (keybindingItem) {
            return keybindingItem.command + (keybindingItem.keybinding ? keybindingItem.keybinding.getAriaLabel() : '') + keybindingItem.source + keybindingItem.when;
        };
        KeybindingsEditorModel.compareKeybindingData = function (a, b) {
            if (a.keybinding && !b.keybinding) {
                return -1;
            }
            if (b.keybinding && !a.keybinding) {
                return 1;
            }
            if (a.commandLabel && !b.commandLabel) {
                return -1;
            }
            if (b.commandLabel && !a.commandLabel) {
                return 1;
            }
            if (a.commandLabel && b.commandLabel) {
                if (a.commandLabel !== b.commandLabel) {
                    return a.commandLabel.localeCompare(b.commandLabel);
                }
            }
            if (a.command === b.command) {
                return a.keybindingItem.isDefault ? 1 : -1;
            }
            return a.command.localeCompare(b.command);
        };
        KeybindingsEditorModel.toKeybindingEntry = function (command, keybindingItem, workbenchActionsRegistry, editorActions) {
            var menuCommand = actions_1.MenuRegistry.getCommand(command);
            var editorActionLabel = editorActions[command];
            return {
                keybinding: keybindingItem.resolvedKeybinding,
                keybindingItem: keybindingItem,
                command: command,
                commandLabel: KeybindingsEditorModel.getCommandLabel(menuCommand, editorActionLabel),
                commandDefaultLabel: KeybindingsEditorModel.getCommandDefaultLabel(menuCommand, workbenchActionsRegistry),
                when: keybindingItem.when ? keybindingItem.when.serialize() : '',
                source: keybindingItem.isDefault ? SOURCE_DEFAULT : SOURCE_USER
            };
        };
        KeybindingsEditorModel.getCommandDefaultLabel = function (menuCommand, workbenchActionsRegistry) {
            if (platform_1.language !== platform_1.LANGUAGE_DEFAULT) {
                if (menuCommand && menuCommand.title && menuCommand.title.original) {
                    return menuCommand.title.original;
                }
            }
            return null;
        };
        KeybindingsEditorModel.getCommandLabel = function (menuCommand, editorActionLabel) {
            if (menuCommand) {
                return typeof menuCommand.title === 'string' ? menuCommand.title : menuCommand.title.value;
            }
            if (editorActionLabel) {
                return editorActionLabel;
            }
            return '';
        };
        KeybindingsEditorModel = __decorate([
            __param(1, keybinding_1.IKeybindingService),
            __param(2, extensions_1.IExtensionService)
        ], KeybindingsEditorModel);
        return KeybindingsEditorModel;
    }(editor_1.EditorModel));
    exports.KeybindingsEditorModel = KeybindingsEditorModel;
    var KeybindingItemMatches = /** @class */ (function () {
        function KeybindingItemMatches(modifierLabels, keybindingItem, searchValue, words, keybindingWords, completeMatch) {
            this.modifierLabels = modifierLabels;
            this.commandIdMatches = null;
            this.commandLabelMatches = null;
            this.commandDefaultLabelMatches = null;
            this.sourceMatches = null;
            this.whenMatches = null;
            this.keybindingMatches = null;
            if (!completeMatch) {
                this.commandIdMatches = this.matches(searchValue, keybindingItem.command, filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase), words);
                this.commandLabelMatches = keybindingItem.commandLabel ? this.matches(searchValue, keybindingItem.commandLabel, function (word, wordToMatchAgainst) { return filters_1.matchesWords(word, keybindingItem.commandLabel, true); }, words) : null;
                this.commandDefaultLabelMatches = keybindingItem.commandDefaultLabel ? this.matches(searchValue, keybindingItem.commandDefaultLabel, function (word, wordToMatchAgainst) { return filters_1.matchesWords(word, keybindingItem.commandDefaultLabel, true); }, words) : null;
                this.sourceMatches = this.matches(searchValue, keybindingItem.source, function (word, wordToMatchAgainst) { return filters_1.matchesWords(word, keybindingItem.source, true); }, words);
                this.whenMatches = keybindingItem.when ? this.matches(searchValue, keybindingItem.when, filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase), words) : null;
            }
            this.keybindingMatches = keybindingItem.keybinding ? this.matchesKeybinding(keybindingItem.keybinding, searchValue, keybindingWords, completeMatch) : null;
        }
        KeybindingItemMatches.prototype.matches = function (searchValue, wordToMatchAgainst, wordMatchesFilter, words) {
            var matches = wordFilter(searchValue, wordToMatchAgainst);
            if (!matches) {
                matches = this.matchesWords(words, wordToMatchAgainst, wordMatchesFilter);
            }
            if (matches) {
                matches = this.filterAndSort(matches);
            }
            return matches;
        };
        KeybindingItemMatches.prototype.matchesWords = function (words, wordToMatchAgainst, wordMatchesFilter) {
            var matches = [];
            for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
                var word = words_1[_i];
                var wordMatches = wordMatchesFilter(word, wordToMatchAgainst);
                if (wordMatches) {
                    matches = (matches || []).concat(wordMatches);
                }
                else {
                    matches = null;
                    break;
                }
            }
            return matches;
        };
        KeybindingItemMatches.prototype.filterAndSort = function (matches) {
            return arrays_1.distinct(matches, (function (a) { return a.start + '.' + a.end; })).filter(function (match) { return !matches.some(function (m) { return !(m.start === match.start && m.end === match.end) && (m.start <= match.start && m.end >= match.end); }); }).sort(function (a, b) { return a.start - b.start; });
        };
        KeybindingItemMatches.prototype.matchesKeybinding = function (keybinding, searchValue, words, completeMatch) {
            var _a = keybinding.getParts(), firstPart = _a[0], chordPart = _a[1];
            if (strings.compareIgnoreCase(searchValue, keybinding.getAriaLabel()) === 0 || strings.compareIgnoreCase(searchValue, keybinding.getLabel()) === 0) {
                return {
                    firstPart: this.createCompleteMatch(firstPart),
                    chordPart: this.createCompleteMatch(chordPart)
                };
            }
            var firstPartMatch = {};
            var chordPartMatch = {};
            var matchedWords = [];
            var firstPartMatchedWords = [];
            var chordPartMatchedWords = [];
            var matchFirstPart = true;
            for (var index = 0; index < words.length; index++) {
                var word = words[index];
                var firstPartMatched = false;
                var chordPartMatched = false;
                matchFirstPart = matchFirstPart && !firstPartMatch.keyCode;
                var matchChordPart = !chordPartMatch.keyCode;
                if (matchFirstPart) {
                    firstPartMatched = this.matchPart(firstPart, firstPartMatch, word, completeMatch);
                    if (firstPartMatch.keyCode) {
                        for (var _i = 0, chordPartMatchedWords_1 = chordPartMatchedWords; _i < chordPartMatchedWords_1.length; _i++) {
                            var cordPartMatchedWordIndex = chordPartMatchedWords_1[_i];
                            if (firstPartMatchedWords.indexOf(cordPartMatchedWordIndex) === -1) {
                                matchedWords.splice(matchedWords.indexOf(cordPartMatchedWordIndex), 1);
                            }
                        }
                        chordPartMatch = {};
                        chordPartMatchedWords = [];
                        matchChordPart = false;
                    }
                }
                if (matchChordPart) {
                    chordPartMatched = this.matchPart(chordPart, chordPartMatch, word, completeMatch);
                }
                if (firstPartMatched) {
                    firstPartMatchedWords.push(index);
                }
                if (chordPartMatched) {
                    chordPartMatchedWords.push(index);
                }
                if (firstPartMatched || chordPartMatched) {
                    matchedWords.push(index);
                }
                matchFirstPart = matchFirstPart && this.isModifier(word);
            }
            if (matchedWords.length !== words.length) {
                return null;
            }
            if (completeMatch && (!this.isCompleteMatch(firstPart, firstPartMatch) || !this.isCompleteMatch(chordPart, chordPartMatch))) {
                return null;
            }
            return this.hasAnyMatch(firstPartMatch) || this.hasAnyMatch(chordPartMatch) ? { firstPart: firstPartMatch, chordPart: chordPartMatch } : null;
        };
        KeybindingItemMatches.prototype.matchPart = function (part, match, word, completeMatch) {
            var matched = false;
            if (this.matchesMetaModifier(part, word)) {
                matched = true;
                match.metaKey = true;
            }
            if (this.matchesCtrlModifier(part, word)) {
                matched = true;
                match.ctrlKey = true;
            }
            if (this.matchesShiftModifier(part, word)) {
                matched = true;
                match.shiftKey = true;
            }
            if (this.matchesAltModifier(part, word)) {
                matched = true;
                match.altKey = true;
            }
            if (this.matchesKeyCode(part, word, completeMatch)) {
                match.keyCode = true;
                matched = true;
            }
            return matched;
        };
        KeybindingItemMatches.prototype.matchesKeyCode = function (keybinding, word, completeMatch) {
            if (!keybinding) {
                return false;
            }
            var ariaLabel = keybinding.keyAriaLabel;
            if (completeMatch || ariaLabel.length === 1 || word.length === 1) {
                if (strings.compareIgnoreCase(ariaLabel, word) === 0) {
                    return true;
                }
            }
            else {
                if (filters_1.matchesContiguousSubString(word, ariaLabel)) {
                    return true;
                }
            }
            return false;
        };
        KeybindingItemMatches.prototype.matchesMetaModifier = function (keybinding, word) {
            if (!keybinding) {
                return false;
            }
            if (!keybinding.metaKey) {
                return false;
            }
            return this.wordMatchesMetaModifier(word);
        };
        KeybindingItemMatches.prototype.wordMatchesMetaModifier = function (word) {
            if (filters_1.matchesPrefix(this.modifierLabels.ui.metaKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.aria.metaKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.user.metaKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(nls_1.localize('meta', "meta"), word)) {
                return true;
            }
            return false;
        };
        KeybindingItemMatches.prototype.matchesCtrlModifier = function (keybinding, word) {
            if (!keybinding) {
                return false;
            }
            if (!keybinding.ctrlKey) {
                return false;
            }
            return this.wordMatchesCtrlModifier(word);
        };
        KeybindingItemMatches.prototype.wordMatchesCtrlModifier = function (word) {
            if (filters_1.matchesPrefix(this.modifierLabels.ui.ctrlKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.aria.ctrlKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.user.ctrlKey, word)) {
                return true;
            }
            return false;
        };
        KeybindingItemMatches.prototype.matchesShiftModifier = function (keybinding, word) {
            if (!keybinding) {
                return false;
            }
            if (!keybinding.shiftKey) {
                return false;
            }
            return this.wordMatchesShiftModifier(word);
        };
        KeybindingItemMatches.prototype.wordMatchesShiftModifier = function (word) {
            if (filters_1.matchesPrefix(this.modifierLabels.ui.shiftKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.aria.shiftKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.user.shiftKey, word)) {
                return true;
            }
            return false;
        };
        KeybindingItemMatches.prototype.matchesAltModifier = function (keybinding, word) {
            if (!keybinding) {
                return false;
            }
            if (!keybinding.altKey) {
                return false;
            }
            return this.wordMatchesAltModifier(word);
        };
        KeybindingItemMatches.prototype.wordMatchesAltModifier = function (word) {
            if (filters_1.matchesPrefix(this.modifierLabels.ui.altKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.aria.altKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(this.modifierLabels.user.altKey, word)) {
                return true;
            }
            if (filters_1.matchesPrefix(nls_1.localize('option', "option"), word)) {
                return true;
            }
            return false;
        };
        KeybindingItemMatches.prototype.hasAnyMatch = function (keybindingMatch) {
            return keybindingMatch.altKey ||
                keybindingMatch.ctrlKey ||
                keybindingMatch.metaKey ||
                keybindingMatch.shiftKey ||
                keybindingMatch.keyCode;
        };
        KeybindingItemMatches.prototype.isCompleteMatch = function (part, match) {
            if (!part) {
                return true;
            }
            if (!match.keyCode) {
                return false;
            }
            if (part.metaKey && !match.metaKey) {
                return false;
            }
            if (part.altKey && !match.altKey) {
                return false;
            }
            if (part.ctrlKey && !match.ctrlKey) {
                return false;
            }
            if (part.shiftKey && !match.shiftKey) {
                return false;
            }
            return true;
        };
        KeybindingItemMatches.prototype.createCompleteMatch = function (part) {
            var match = {};
            if (part) {
                match.keyCode = true;
                if (part.metaKey) {
                    match.metaKey = true;
                }
                if (part.altKey) {
                    match.altKey = true;
                }
                if (part.ctrlKey) {
                    match.ctrlKey = true;
                }
                if (part.shiftKey) {
                    match.shiftKey = true;
                }
            }
            return match;
        };
        KeybindingItemMatches.prototype.isModifier = function (word) {
            if (this.wordMatchesAltModifier(word)) {
                return true;
            }
            if (this.wordMatchesCtrlModifier(word)) {
                return true;
            }
            if (this.wordMatchesMetaModifier(word)) {
                return true;
            }
            if (this.wordMatchesShiftModifier(word)) {
                return true;
            }
            return false;
        };
        return KeybindingItemMatches;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[61/*vs/workbench/services/preferences/common/preferences*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,13/*vs/workbench/common/editor*/,24/*vs/base/common/paths*/,2/*vs/nls*/]), function (require, exports, instantiation_1, editor_1, paths_1, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SettingValueType;
    (function (SettingValueType) {
        SettingValueType["Null"] = "null";
        SettingValueType["Enum"] = "enum";
        SettingValueType["String"] = "string";
        SettingValueType["Integer"] = "integer";
        SettingValueType["Number"] = "number";
        SettingValueType["Boolean"] = "boolean";
        SettingValueType["Exclude"] = "exclude";
        SettingValueType["Complex"] = "complex";
        SettingValueType["NullableInteger"] = "nullable-integer";
        SettingValueType["NullableNumber"] = "nullable-number";
    })(SettingValueType = exports.SettingValueType || (exports.SettingValueType = {}));
    /**
     * TODO Why do we need this class?
     */
    var SettingsEditorOptions = /** @class */ (function (_super) {
        __extends(SettingsEditorOptions, _super);
        function SettingsEditorOptions() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SettingsEditorOptions.create = function (settings) {
            if (!settings) {
                return null;
            }
            var options = new SettingsEditorOptions();
            options.target = settings.target;
            options.folderUri = settings.folderUri;
            options.query = settings.query;
            // IEditorOptions
            options.preserveFocus = settings.preserveFocus;
            options.forceReload = settings.forceReload;
            options.revealIfVisible = settings.revealIfVisible;
            options.revealIfOpened = settings.revealIfOpened;
            options.pinned = settings.pinned;
            options.index = settings.index;
            options.inactive = settings.inactive;
            return options;
        };
        return SettingsEditorOptions;
    }(editor_1.EditorOptions));
    exports.SettingsEditorOptions = SettingsEditorOptions;
    exports.IPreferencesService = instantiation_1.createDecorator('preferencesService');
    function getSettingsTargetName(target, resource, workspaceContextService) {
        switch (target) {
            case 1 /* USER */:
                return nls_1.localize('userSettingsTarget', "User Settings");
            case 2 /* WORKSPACE */:
                return nls_1.localize('workspaceSettingsTarget', "Workspace Settings");
            case 3 /* WORKSPACE_FOLDER */:
                var folder = workspaceContextService.getWorkspaceFolder(resource);
                return folder ? folder.name : '';
        }
        return '';
    }
    exports.getSettingsTargetName = getSettingsTargetName;
    exports.FOLDER_SETTINGS_PATH = paths_1.join('.vscode', 'settings.json');
    exports.DEFAULT_SETTINGS_EDITOR_SETTING = 'workbench.settings.openDefaultSettings';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[161/*vs/workbench/parts/preferences/browser/settingsTreeModels*/], __M([0/*require*/,1/*exports*/,19/*vs/base/common/arrays*/,29/*vs/base/common/types*/,12/*vs/base/common/uri*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,193/*vs/workbench/parts/preferences/browser/settingsLayout*/,61/*vs/workbench/services/preferences/common/preferences*/]), function (require, exports, arrays, types_1, uri_1, nls_1, configuration_1, settingsLayout_1, preferences_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MODIFIED_SETTING_TAG = 'modified';
    exports.ONLINE_SERVICES_SETTING_TAG = 'usesOnlineServices';
    var SettingsTreeElement = /** @class */ (function () {
        function SettingsTreeElement() {
        }
        return SettingsTreeElement;
    }());
    exports.SettingsTreeElement = SettingsTreeElement;
    var SettingsTreeGroupElement = /** @class */ (function (_super) {
        __extends(SettingsTreeGroupElement, _super);
        function SettingsTreeGroupElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(SettingsTreeGroupElement.prototype, "children", {
            get: function () {
                return this._children;
            },
            set: function (newChildren) {
                var _this = this;
                this._children = newChildren;
                this._childSettingKeys = new Set();
                this._children.forEach(function (child) {
                    if (child instanceof SettingsTreeSettingElement) {
                        _this._childSettingKeys.add(child.setting.key);
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns whether this group contains the given child key (to a depth of 1 only)
         */
        SettingsTreeGroupElement.prototype.containsSetting = function (key) {
            return this._childSettingKeys.has(key);
        };
        return SettingsTreeGroupElement;
    }(SettingsTreeElement));
    exports.SettingsTreeGroupElement = SettingsTreeGroupElement;
    var SettingsTreeNewExtensionsElement = /** @class */ (function (_super) {
        __extends(SettingsTreeNewExtensionsElement, _super);
        function SettingsTreeNewExtensionsElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SettingsTreeNewExtensionsElement;
    }(SettingsTreeElement));
    exports.SettingsTreeNewExtensionsElement = SettingsTreeNewExtensionsElement;
    var SettingsTreeSettingElement = /** @class */ (function (_super) {
        __extends(SettingsTreeSettingElement, _super);
        function SettingsTreeSettingElement(setting, parent, index, inspectResult) {
            var _this = _super.call(this) || this;
            _this.index = index;
            _this.setting = setting;
            _this.parent = parent;
            _this.id = sanitizeId(parent.id + '_' + setting.key);
            _this.update(inspectResult);
            return _this;
        }
        Object.defineProperty(SettingsTreeSettingElement.prototype, "displayCategory", {
            get: function () {
                if (!this._displayCategory) {
                    this.initLabel();
                }
                return this._displayCategory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsTreeSettingElement.prototype, "displayLabel", {
            get: function () {
                if (!this._displayLabel) {
                    this.initLabel();
                }
                return this._displayLabel;
            },
            enumerable: true,
            configurable: true
        });
        SettingsTreeSettingElement.prototype.initLabel = function () {
            var displayKeyFormat = settingKeyToDisplayFormat(this.setting.key, this.parent.id);
            this._displayLabel = displayKeyFormat.label;
            this._displayCategory = displayKeyFormat.category;
        };
        SettingsTreeSettingElement.prototype.update = function (inspectResult) {
            var _this = this;
            var isConfigured = inspectResult.isConfigured, inspected = inspectResult.inspected, targetSelector = inspectResult.targetSelector;
            var displayValue = isConfigured ? inspected[targetSelector] : inspected.default;
            var overriddenScopeList = [];
            if (targetSelector === 'user' && typeof inspected.workspace !== 'undefined') {
                overriddenScopeList.push(nls_1.localize('workspace', "Workspace"));
            }
            if (targetSelector === 'workspace' && typeof inspected.user !== 'undefined') {
                overriddenScopeList.push(nls_1.localize('user', "User"));
            }
            this.value = displayValue;
            this.scopeValue = isConfigured && inspected[targetSelector];
            this.defaultValue = inspected.default;
            this.isConfigured = isConfigured;
            if (isConfigured || this.setting.tags || this.tags) {
                // Don't create an empty Set for all 1000 settings, only if needed
                this.tags = new Set();
                if (isConfigured) {
                    this.tags.add(exports.MODIFIED_SETTING_TAG);
                }
                if (this.setting.tags) {
                    this.setting.tags.forEach(function (tag) { return _this.tags.add(tag); });
                }
            }
            this.overriddenScopeList = overriddenScopeList;
            this.description = this.setting.description.join('\n');
            if (this.setting.enum && (!this.setting.type || settingTypeEnumRenderable(this.setting.type))) {
                this.valueType = preferences_1.SettingValueType.Enum;
            }
            else if (this.setting.type === 'string') {
                this.valueType = preferences_1.SettingValueType.String;
            }
            else if (isExcludeSetting(this.setting)) {
                this.valueType = preferences_1.SettingValueType.Exclude;
            }
            else if (this.setting.type === 'integer') {
                this.valueType = preferences_1.SettingValueType.Integer;
            }
            else if (this.setting.type === 'number') {
                this.valueType = preferences_1.SettingValueType.Number;
            }
            else if (this.setting.type === 'boolean') {
                this.valueType = preferences_1.SettingValueType.Boolean;
            }
            else if (types_1.isArray(this.setting.type) && this.setting.type.indexOf(preferences_1.SettingValueType.Null) > -1 && this.setting.type.length === 2) {
                if (this.setting.type.indexOf(preferences_1.SettingValueType.Integer) > -1) {
                    this.valueType = preferences_1.SettingValueType.NullableInteger;
                }
                else if (this.setting.type.indexOf(preferences_1.SettingValueType.Number) > -1) {
                    this.valueType = preferences_1.SettingValueType.NullableNumber;
                }
                else {
                    this.valueType = preferences_1.SettingValueType.Complex;
                }
            }
            else {
                this.valueType = preferences_1.SettingValueType.Complex;
            }
        };
        SettingsTreeSettingElement.prototype.matchesAllTags = function (tagFilters) {
            var _this = this;
            if (!tagFilters || !tagFilters.size) {
                return true;
            }
            if (this.tags) {
                var hasFilteredTag_1 = true;
                tagFilters.forEach(function (tag) {
                    hasFilteredTag_1 = hasFilteredTag_1 && _this.tags.has(tag);
                });
                return hasFilteredTag_1;
            }
            else {
                return false;
            }
        };
        SettingsTreeSettingElement.prototype.matchesScope = function (scope) {
            var configTarget = uri_1.URI.isUri(scope) ? 3 /* WORKSPACE_FOLDER */ : scope;
            if (configTarget === 3 /* WORKSPACE_FOLDER */) {
                return this.setting.scope === 3 /* RESOURCE */;
            }
            if (configTarget === 2 /* WORKSPACE */) {
                return this.setting.scope === 2 /* WINDOW */ || this.setting.scope === 3 /* RESOURCE */;
            }
            return true;
        };
        return SettingsTreeSettingElement;
    }(SettingsTreeElement));
    exports.SettingsTreeSettingElement = SettingsTreeSettingElement;
    var SettingsTreeModel = /** @class */ (function () {
        function SettingsTreeModel(_viewState, _configurationService) {
            this._viewState = _viewState;
            this._configurationService = _configurationService;
            this._treeElementsById = new Map();
            this._treeElementsBySettingName = new Map();
        }
        Object.defineProperty(SettingsTreeModel.prototype, "root", {
            get: function () {
                return this._root;
            },
            enumerable: true,
            configurable: true
        });
        SettingsTreeModel.prototype.update = function (newTocRoot) {
            if (newTocRoot === void 0) { newTocRoot = this._tocRoot; }
            this._treeElementsById.clear();
            this._treeElementsBySettingName.clear();
            var newRoot = this.createSettingsTreeGroupElement(newTocRoot);
            if (newRoot.children[0] instanceof SettingsTreeGroupElement) {
                newRoot.children[0].isFirstGroup = true; // TODO
            }
            if (this._root) {
                this._root.children = newRoot.children;
            }
            else {
                this._root = newRoot;
            }
        };
        SettingsTreeModel.prototype.getElementById = function (id) {
            return this._treeElementsById.get(id);
        };
        SettingsTreeModel.prototype.getElementsByName = function (name) {
            return this._treeElementsBySettingName.get(name);
        };
        SettingsTreeModel.prototype.updateElementsByName = function (name) {
            var _this = this;
            if (!this._treeElementsBySettingName.has(name)) {
                return;
            }
            this._treeElementsBySettingName.get(name).forEach(function (element) {
                var inspectResult = inspectSetting(element.setting.key, _this._viewState.settingsTarget, _this._configurationService);
                element.update(inspectResult);
            });
        };
        SettingsTreeModel.prototype.createSettingsTreeGroupElement = function (tocEntry, parent) {
            var _this = this;
            var element = new SettingsTreeGroupElement();
            var index = this._treeElementsById.size;
            element.index = index;
            element.id = tocEntry.id;
            element.label = tocEntry.label;
            element.parent = parent;
            element.level = this.getDepth(element);
            var children = [];
            if (tocEntry.settings) {
                var settingChildren = tocEntry.settings.map(function (s) { return _this.createSettingsTreeSettingElement(s, element); })
                    .filter(function (el) { return el.setting.deprecationMessage ? el.isConfigured : true; });
                children.push.apply(children, settingChildren);
            }
            if (tocEntry.children) {
                var groupChildren = tocEntry.children.map(function (child) { return _this.createSettingsTreeGroupElement(child, element); });
                children.push.apply(children, groupChildren);
            }
            element.children = children;
            this._treeElementsById.set(element.id, element);
            return element;
        };
        SettingsTreeModel.prototype.getDepth = function (element) {
            if (element.parent) {
                return 1 + this.getDepth(element.parent);
            }
            else {
                return 0;
            }
        };
        SettingsTreeModel.prototype.createSettingsTreeSettingElement = function (setting, parent) {
            var index = this._treeElementsById.size;
            var inspectResult = inspectSetting(setting.key, this._viewState.settingsTarget, this._configurationService);
            var element = new SettingsTreeSettingElement(setting, parent, index, inspectResult);
            this._treeElementsById.set(element.id, element);
            var nameElements = this._treeElementsBySettingName.get(setting.key) || [];
            nameElements.push(element);
            this._treeElementsBySettingName.set(setting.key, nameElements);
            return element;
        };
        SettingsTreeModel = __decorate([
            __param(1, configuration_1.IConfigurationService)
        ], SettingsTreeModel);
        return SettingsTreeModel;
    }());
    exports.SettingsTreeModel = SettingsTreeModel;
    function inspectSetting(key, target, configurationService) {
        var inspectOverrides = uri_1.URI.isUri(target) ? { resource: target } : undefined;
        var inspected = configurationService.inspect(key, inspectOverrides);
        var targetSelector = target === 1 /* USER */ ? 'user' :
            target === 2 /* WORKSPACE */ ? 'workspace' :
                'workspaceFolder';
        var isConfigured = typeof inspected[targetSelector] !== 'undefined';
        return { isConfigured: isConfigured, inspected: inspected, targetSelector: targetSelector };
    }
    function sanitizeId(id) {
        return id.replace(/[\.\/]/, '_');
    }
    function settingKeyToDisplayFormat(key, groupId) {
        if (groupId === void 0) { groupId = ''; }
        var lastDotIdx = key.lastIndexOf('.');
        var category = '';
        if (lastDotIdx >= 0) {
            category = key.substr(0, lastDotIdx);
            key = key.substr(lastDotIdx + 1);
        }
        groupId = groupId.replace(/\//g, '.');
        category = trimCategoryForGroup(category, groupId);
        category = wordifyKey(category);
        var label = wordifyKey(key);
        return { category: category, label: label };
    }
    exports.settingKeyToDisplayFormat = settingKeyToDisplayFormat;
    function wordifyKey(key) {
        return key
            .replace(/\.([a-z])/g, function (match, p1) { return " \u203A " + p1.toUpperCase(); })
            .replace(/([a-z])([A-Z])/g, '$1 $2') // fooBar => foo Bar
            .replace(/^[a-z]/g, function (match) { return match.toUpperCase(); }) // foo => Foo
            .replace(/\b\w+\b/g, function (match) {
            return settingsLayout_1.knownAcronyms.has(match.toLowerCase()) ?
                match.toUpperCase() :
                match;
        });
    }
    function trimCategoryForGroup(category, groupId) {
        var doTrim = function (forward) {
            var parts = groupId.split('.');
            while (parts.length) {
                var reg = new RegExp("^" + parts.join('\\.') + "(\\.|$)", 'i');
                if (reg.test(category)) {
                    return category.replace(reg, '');
                }
                if (forward) {
                    parts.pop();
                }
                else {
                    parts.shift();
                }
            }
            return null;
        };
        var trimmed = doTrim(true);
        if (trimmed === null) {
            trimmed = doTrim(false);
        }
        if (trimmed === null) {
            trimmed = category;
        }
        return trimmed;
    }
    function isExcludeSetting(setting) {
        return setting.key === 'files.exclude' ||
            setting.key === 'search.exclude' ||
            setting.key === 'files.watcherExclude';
    }
    exports.isExcludeSetting = isExcludeSetting;
    function settingTypeEnumRenderable(_type) {
        var enumRenderableSettingTypes = ['string', 'boolean', 'null', 'integer', 'number'];
        var type = types_1.isArray(_type) ? _type : [_type];
        return type.every(function (type) { return enumRenderableSettingTypes.indexOf(type) > -1; });
    }
    var SearchResultModel = /** @class */ (function (_super) {
        __extends(SearchResultModel, _super);
        function SearchResultModel(viewState, configurationService) {
            var _this = _super.call(this, viewState, configurationService) || this;
            _this.id = 'searchResultModel';
            _this.update({ id: 'searchResultModel', label: '' });
            return _this;
        }
        SearchResultModel.prototype.getUniqueResults = function () {
            if (this.cachedUniqueSearchResults) {
                return this.cachedUniqueSearchResults;
            }
            if (!this.rawSearchResults) {
                return [];
            }
            var localMatchKeys = new Set();
            var localResult = this.rawSearchResults[0 /* Local */];
            if (localResult) {
                localResult.filterMatches.forEach(function (m) { return localMatchKeys.add(m.setting.key); });
            }
            var remoteResult = this.rawSearchResults[1 /* Remote */];
            if (remoteResult) {
                remoteResult.filterMatches = remoteResult.filterMatches.filter(function (m) { return !localMatchKeys.has(m.setting.key); });
            }
            if (remoteResult) {
                this.newExtensionSearchResults = this.rawSearchResults[2 /* NewExtensions */];
            }
            this.cachedUniqueSearchResults = [localResult, remoteResult];
            return this.cachedUniqueSearchResults;
        };
        SearchResultModel.prototype.getRawResults = function () {
            return this.rawSearchResults;
        };
        SearchResultModel.prototype.setResult = function (order, result) {
            this.cachedUniqueSearchResults = null;
            this.rawSearchResults = this.rawSearchResults || [];
            if (!result) {
                delete this.rawSearchResults[order];
                return;
            }
            this.rawSearchResults[order] = result;
            this.updateChildren();
        };
        SearchResultModel.prototype.updateChildren = function () {
            var _this = this;
            this.update({
                id: 'searchResultModel',
                label: 'searchResultModel',
                settings: this.getFlatSettings()
            });
            // Save time, filter children in the search model instead of relying on the tree filter, which still requires heights to be calculated.
            this.root.children = this.root.children
                .filter(function (child) { return child instanceof SettingsTreeSettingElement && child.matchesAllTags(_this._viewState.tagFilters) && child.matchesScope(_this._viewState.settingsTarget); });
            if (this.newExtensionSearchResults && this.newExtensionSearchResults.filterMatches.length) {
                var newExtElement = new SettingsTreeNewExtensionsElement();
                newExtElement.index = this._treeElementsById.size;
                newExtElement.parent = this._root;
                newExtElement.id = 'newExtensions';
                this._treeElementsById.set(newExtElement.id, newExtElement);
                var resultExtensionIds = this.newExtensionSearchResults.filterMatches
                    .map(function (result) { return result.setting; })
                    .filter(function (setting) { return setting.extensionName && setting.extensionPublisher; })
                    .map(function (setting) { return setting.extensionPublisher + "." + setting.extensionName; });
                newExtElement.extensionIds = arrays.distinct(resultExtensionIds);
                this._root.children.push(newExtElement);
            }
        };
        SearchResultModel.prototype.getFlatSettings = function () {
            var flatSettings = [];
            this.getUniqueResults()
                .filter(function (r) { return !!r; })
                .forEach(function (r) {
                flatSettings.push.apply(flatSettings, r.filterMatches.map(function (m) { return m.setting; }));
            });
            return flatSettings;
        };
        SearchResultModel = __decorate([
            __param(1, configuration_1.IConfigurationService)
        ], SearchResultModel);
        return SearchResultModel;
    }(SettingsTreeModel));
    exports.SearchResultModel = SearchResultModel;
    var tagRegex = /(^|\s)@tag:("([^"]*)"|[^"]\S*)/g;
    function parseQuery(query) {
        var tags = [];
        query = query.replace(tagRegex, function (_, __, quotedTag, tag) {
            tags.push(tag || quotedTag);
            return '';
        });
        query = query.replace("@" + exports.MODIFIED_SETTING_TAG, function () {
            tags.push(exports.MODIFIED_SETTING_TAG);
            return '';
        });
        query = query.trim();
        return {
            tags: tags,
            query: query
        };
    }
    exports.parseQuery = parseQuery;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[202/*vs/workbench/parts/preferences/browser/settingsTree*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,448/*vs/base/browser/htmlContentRenderer*/,50/*vs/base/browser/ui/actionbar/actionbar*/,352/*vs/base/browser/ui/aria/aria*/,121/*vs/base/browser/ui/button/button*/,225/*vs/base/browser/ui/checkbox/checkbox*/,139/*vs/base/browser/ui/inputbox/inputBox*/,447/*vs/base/browser/ui/selectBox/selectBox*/,133/*vs/base/browser/ui/toolbar/toolbar*/,15/*vs/base/common/actions*/,19/*vs/base/common/arrays*/,75/*vs/base/common/color*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,22/*vs/base/common/strings*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,203/*vs/base/parts/tree/browser/treeDefaults*/,176/*vs/base/parts/tree/browser/treeImpl*/,2/*vs/nls*/,79/*vs/platform/clipboard/common/clipboardService*/,37/*vs/platform/commands/common/commands*/,7/*vs/platform/configuration/common/configuration*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,51/*vs/platform/list/browser/listService*/,138/*vs/platform/opener/common/opener*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,161/*vs/workbench/parts/preferences/browser/settingsTreeModels*/,151/*vs/workbench/parts/preferences/browser/settingsWidgets*/,109/*vs/workbench/parts/preferences/common/preferences*/]), function (require, exports, DOM, htmlContentRenderer_1, actionbar_1, aria_1, button_1, checkbox_1, inputBox_1, selectBox_1, toolbar_1, actions_1, arrays, color_1, errors_1, event_1, lifecycle_1, strings_1, uri_1, winjs_base_1, treeDefaults_1, treeImpl_1, nls_1, clipboardService_1, commands_1, configuration_1, contextView_1, instantiation_1, keybinding_1, listService_1, opener_1, colorRegistry_1, styler_1, themeService_1, settingsTreeModels_1, settingsWidgets_1, preferences_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = DOM.$;
    function getExcludeDisplayValue(element) {
        var data = element.isConfigured ? __assign({}, element.defaultValue, element.scopeValue) :
            element.defaultValue;
        return Object.keys(data)
            .filter(function (key) { return !!data[key]; })
            .map(function (key) {
            var value = data[key];
            var sibling = typeof value === 'boolean' ? undefined : value.when;
            return {
                id: key,
                pattern: key,
                sibling: sibling
            };
        });
    }
    function resolveSettingsTree(tocData, coreSettingsGroups) {
        var allSettings = getFlatSettings(coreSettingsGroups);
        return {
            tree: _resolveSettingsTree(tocData, allSettings),
            leftoverSettings: allSettings
        };
    }
    exports.resolveSettingsTree = resolveSettingsTree;
    function resolveExtensionsSettings(groups) {
        var settingsGroupToEntry = function (group) {
            var flatSettings = arrays.flatten(group.sections.map(function (section) { return section.settings; }));
            return {
                id: group.id,
                label: group.title,
                settings: flatSettings
            };
        };
        var extGroups = groups
            .sort(function (a, b) { return a.title.localeCompare(b.title); })
            .map(function (g) { return settingsGroupToEntry(g); });
        return {
            id: 'extensions',
            label: nls_1.localize('extensions', "Extensions"),
            children: extGroups
        };
    }
    exports.resolveExtensionsSettings = resolveExtensionsSettings;
    function _resolveSettingsTree(tocData, allSettings) {
        var children;
        if (tocData.children) {
            children = tocData.children
                .map(function (child) { return _resolveSettingsTree(child, allSettings); })
                .filter(function (child) { return (child.children && child.children.length) || (child.settings && child.settings.length); });
        }
        var settings;
        if (tocData.settings) {
            settings = arrays.flatten(tocData.settings.map(function (pattern) { return getMatchingSettings(allSettings, pattern); }));
        }
        if (!children && !settings) {
            return null;
        }
        return {
            id: tocData.id,
            label: tocData.label,
            children: children,
            settings: settings
        };
    }
    function getMatchingSettings(allSettings, pattern) {
        var result = [];
        allSettings.forEach(function (s) {
            if (settingMatches(s, pattern)) {
                result.push(s);
                allSettings.delete(s);
            }
        });
        return result.sort(function (a, b) { return a.key.localeCompare(b.key); });
    }
    var settingPatternCache = new Map();
    function createSettingMatchRegExp(pattern) {
        pattern = strings_1.escapeRegExpCharacters(pattern)
            .replace(/\\\*/g, '.*');
        return new RegExp("^" + pattern, 'i');
    }
    function settingMatches(s, pattern) {
        var regExp = settingPatternCache.get(pattern);
        if (!regExp) {
            regExp = createSettingMatchRegExp(pattern);
            settingPatternCache.set(pattern, regExp);
        }
        return regExp.test(s.key);
    }
    function getFlatSettings(settingsGroups) {
        var result = new Set();
        for (var _i = 0, settingsGroups_1 = settingsGroups; _i < settingsGroups_1.length; _i++) {
            var group = settingsGroups_1[_i];
            for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                var section = _b[_a];
                for (var _c = 0, _d = section.settings; _c < _d.length; _c++) {
                    var s = _d[_c];
                    if (!s.overrides || !s.overrides.length) {
                        result.add(s);
                    }
                }
            }
        }
        return result;
    }
    var SettingsDataSource = /** @class */ (function () {
        function SettingsDataSource() {
        }
        SettingsDataSource.prototype.getId = function (tree, element) {
            return element.id;
        };
        SettingsDataSource.prototype.hasChildren = function (tree, element) {
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                return true;
            }
            return false;
        };
        SettingsDataSource.prototype.getChildren = function (tree, element) {
            return winjs_base_1.TPromise.as(this._getChildren(element));
        };
        SettingsDataSource.prototype._getChildren = function (element) {
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                return element.children;
            }
            else {
                // No children...
                return null;
            }
        };
        SettingsDataSource.prototype.getParent = function (tree, element) {
            return winjs_base_1.TPromise.wrap(element && element.parent);
        };
        SettingsDataSource.prototype.shouldAutoexpand = function () {
            return true;
        };
        return SettingsDataSource;
    }());
    exports.SettingsDataSource = SettingsDataSource;
    var SimplePagedDataSource = /** @class */ (function () {
        function SimplePagedDataSource(realDataSource) {
            this.realDataSource = realDataSource;
            this.reset();
        }
        SimplePagedDataSource.prototype.reset = function () {
            this.loadedToIndex = SimplePagedDataSource.SETTINGS_PER_PAGE;
        };
        SimplePagedDataSource.prototype.pageTo = function (index, top) {
            if (top === void 0) { top = false; }
            var buffer = top ? SimplePagedDataSource.SETTINGS_PER_PAGE : SimplePagedDataSource.BUFFER;
            if (index > this.loadedToIndex - buffer) {
                this.loadedToIndex = (Math.ceil(index / SimplePagedDataSource.SETTINGS_PER_PAGE) + 1) * SimplePagedDataSource.SETTINGS_PER_PAGE;
                return true;
            }
            else {
                return false;
            }
        };
        SimplePagedDataSource.prototype.getId = function (tree, element) {
            return this.realDataSource.getId(tree, element);
        };
        SimplePagedDataSource.prototype.hasChildren = function (tree, element) {
            return this.realDataSource.hasChildren(tree, element);
        };
        SimplePagedDataSource.prototype.getChildren = function (tree, element) {
            var _this = this;
            return this.realDataSource.getChildren(tree, element).then(function (realChildren) {
                return _this._getChildren(realChildren);
            });
        };
        SimplePagedDataSource.prototype._getChildren = function (realChildren) {
            var _this = this;
            var lastChild = realChildren[realChildren.length - 1];
            if (lastChild && lastChild.index > this.loadedToIndex) {
                return realChildren.filter(function (child) {
                    return child.index < _this.loadedToIndex;
                });
            }
            else {
                return realChildren;
            }
        };
        SimplePagedDataSource.prototype.getParent = function (tree, element) {
            return this.realDataSource.getParent(tree, element);
        };
        SimplePagedDataSource.prototype.shouldAutoexpand = function (tree, element) {
            return this.realDataSource.shouldAutoexpand(tree, element);
        };
        SimplePagedDataSource.SETTINGS_PER_PAGE = 30;
        SimplePagedDataSource.BUFFER = 5;
        return SimplePagedDataSource;
    }());
    exports.SimplePagedDataSource = SimplePagedDataSource;
    var SETTINGS_TEXT_TEMPLATE_ID = 'settings.text.template';
    var SETTINGS_NUMBER_TEMPLATE_ID = 'settings.number.template';
    var SETTINGS_ENUM_TEMPLATE_ID = 'settings.enum.template';
    var SETTINGS_BOOL_TEMPLATE_ID = 'settings.bool.template';
    var SETTINGS_EXCLUDE_TEMPLATE_ID = 'settings.exclude.template';
    var SETTINGS_COMPLEX_TEMPLATE_ID = 'settings.complex.template';
    var SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID = 'settings.newExtensions.template';
    var SETTINGS_GROUP_ELEMENT_TEMPLATE_ID = 'settings.group.template';
    var SettingsRenderer = /** @class */ (function () {
        function SettingsRenderer(_measureParent, themeService, contextViewService, openerService, instantiationService, commandService, contextMenuService, keybindingService) {
            var _this = this;
            this.themeService = themeService;
            this.contextViewService = contextViewService;
            this.openerService = openerService;
            this.instantiationService = instantiationService;
            this.commandService = commandService;
            this.contextMenuService = contextMenuService;
            this.keybindingService = keybindingService;
            this._onDidChangeSetting = new event_1.Emitter();
            this.onDidChangeSetting = this._onDidChangeSetting.event;
            this._onDidOpenSettings = new event_1.Emitter();
            this.onDidOpenSettings = this._onDidOpenSettings.event;
            this._onDidClickSettingLink = new event_1.Emitter();
            this.onDidClickSettingLink = this._onDidClickSettingLink.event;
            this._onDidFocusSetting = new event_1.Emitter();
            this.onDidFocusSetting = this._onDidFocusSetting.event;
            this.longestSingleLineDescription = 0;
            this.rowHeightCache = new Map();
            this.descriptionMeasureContainer = $('.setting-item-description');
            DOM.append(_measureParent, $('.setting-measure-container.monaco-tree.settings-editor-tree', undefined, $('.monaco-scrollable-element', undefined, $('.monaco-tree-wrapper', undefined, $('.monaco-tree-rows', undefined, $('.monaco-tree-row', undefined, $('.setting-item', undefined, this.descriptionMeasureContainer)))))));
            this.settingActions = [
                new actions_1.Action('settings.resetSetting', nls_1.localize('resetSettingLabel', "Reset Setting"), undefined, undefined, function (context) {
                    if (context) {
                        _this._onDidChangeSetting.fire({ key: context.setting.key, value: undefined, type: context.setting.type });
                    }
                    return winjs_base_1.TPromise.wrap(null);
                }),
                new actionbar_1.Separator(),
                this.instantiationService.createInstance(CopySettingIdAction),
                this.instantiationService.createInstance(CopySettingAsJSONAction),
            ];
        }
        SettingsRenderer.prototype.showContextMenu = function (element, settingDOMElement) {
            var _this = this;
            var toolbarElement = settingDOMElement.querySelector('.toolbar-toggle-more');
            if (toolbarElement) {
                this.contextMenuService.showContextMenu({
                    getActions: function () { return winjs_base_1.TPromise.wrap(_this.settingActions); },
                    getAnchor: function () { return toolbarElement; },
                    getActionsContext: function () { return element; }
                });
            }
        };
        SettingsRenderer.prototype.updateWidth = function (width) {
            if (this.lastRenderedWidth !== width) {
                this.rowHeightCache = new Map();
            }
            this.longestSingleLineDescription = 0;
            this.lastRenderedWidth = width;
        };
        SettingsRenderer.prototype.getHeight = function (tree, element) {
            if (this.rowHeightCache.has(element.id) && !(element instanceof settingsTreeModels_1.SettingsTreeSettingElement && settingsTreeModels_1.isExcludeSetting(element.setting))) {
                return this.rowHeightCache.get(element.id);
            }
            var h = this._getHeight(tree, element);
            this.rowHeightCache.set(element.id, h);
            return h;
        };
        SettingsRenderer.prototype._getHeight = function (tree, element) {
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                if (element.isFirstGroup) {
                    return 31;
                }
                return 40 + (7 * element.level);
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeSettingElement) {
                if (settingsTreeModels_1.isExcludeSetting(element.setting)) {
                    return this._getExcludeSettingHeight(element);
                }
                else {
                    return this.measureSettingElementHeight(tree, element);
                }
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeNewExtensionsElement) {
                return 40;
            }
            return 0;
        };
        SettingsRenderer.prototype._getExcludeSettingHeight = function (element) {
            var displayValue = getExcludeDisplayValue(element);
            return (displayValue.length + 1) * 22 + 66 + this.measureSettingDescription(element);
        };
        SettingsRenderer.prototype.measureSettingElementHeight = function (tree, element) {
            var heightExcludingDescription = 86;
            if (element.valueType === 'boolean') {
                heightExcludingDescription = 60;
            }
            return heightExcludingDescription + this.measureSettingDescription(element);
        };
        SettingsRenderer.prototype.measureSettingDescription = function (element) {
            if (element.description.length < this.longestSingleLineDescription * .8) {
                // Most setting descriptions are one short line, so try to avoid measuring them.
                // If the description is less than 80% of the longest single line description, assume this will also render to be one line.
                return 18;
            }
            var boolMeasureClass = 'measure-bool-description';
            if (element.valueType === 'boolean') {
                this.descriptionMeasureContainer.classList.add(boolMeasureClass);
            }
            else if (this.descriptionMeasureContainer.classList.contains(boolMeasureClass)) {
                this.descriptionMeasureContainer.classList.remove(boolMeasureClass);
            }
            var shouldRenderMarkdown = element.setting.descriptionIsMarkdown && element.description.indexOf('\n- ') >= 0;
            while (this.descriptionMeasureContainer.firstChild) {
                this.descriptionMeasureContainer.removeChild(this.descriptionMeasureContainer.firstChild);
            }
            if (shouldRenderMarkdown) {
                var text = fixSettingLinks(element.description);
                var rendered = htmlContentRenderer_1.renderMarkdown({ value: text });
                rendered.classList.add('setting-item-description-markdown');
                this.descriptionMeasureContainer.appendChild(rendered);
                return this.descriptionMeasureContainer.offsetHeight;
            }
            else {
                // Remove markdown links, setting links, backticks
                var measureText = element.setting.descriptionIsMarkdown ?
                    fixSettingLinks(element.description)
                        .replace(/\[(.*)\]\(.*\)/g, '$1')
                        .replace(/`([^`]*)`/g, '$1') :
                    element.description;
                this.descriptionMeasureContainer.innerText = measureText;
                var h = this.descriptionMeasureContainer.offsetHeight;
                if (h < 20 && measureText.length > this.longestSingleLineDescription) {
                    this.longestSingleLineDescription = measureText.length;
                }
                return h;
            }
        };
        SettingsRenderer.prototype.getTemplateId = function (tree, element) {
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                return SETTINGS_GROUP_ELEMENT_TEMPLATE_ID;
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeSettingElement) {
                if (element.valueType === 'boolean') {
                    return SETTINGS_BOOL_TEMPLATE_ID;
                }
                if (element.valueType === 'integer' || element.valueType === 'number' || element.valueType === 'nullable-integer' || element.valueType === 'nullable-number') {
                    return SETTINGS_NUMBER_TEMPLATE_ID;
                }
                if (element.valueType === 'string') {
                    return SETTINGS_TEXT_TEMPLATE_ID;
                }
                if (element.valueType === 'enum') {
                    return SETTINGS_ENUM_TEMPLATE_ID;
                }
                if (element.valueType === 'exclude') {
                    return SETTINGS_EXCLUDE_TEMPLATE_ID;
                }
                return SETTINGS_COMPLEX_TEMPLATE_ID;
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeNewExtensionsElement) {
                return SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID;
            }
            return '';
        };
        SettingsRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            if (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {
                return this.renderGroupTitleTemplate(container);
            }
            if (templateId === SETTINGS_TEXT_TEMPLATE_ID) {
                return this.renderSettingTextTemplate(tree, container);
            }
            if (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {
                return this.renderSettingNumberTemplate(tree, container);
            }
            if (templateId === SETTINGS_BOOL_TEMPLATE_ID) {
                return this.renderSettingBoolTemplate(tree, container);
            }
            if (templateId === SETTINGS_ENUM_TEMPLATE_ID) {
                return this.renderSettingEnumTemplate(tree, container);
            }
            if (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {
                return this.renderSettingExcludeTemplate(tree, container);
            }
            if (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {
                return this.renderSettingComplexTemplate(tree, container);
            }
            if (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {
                return this.renderNewExtensionsTemplate(container);
            }
            return null;
        };
        SettingsRenderer.prototype.renderGroupTitleTemplate = function (container) {
            DOM.addClass(container, 'group-title');
            var toDispose = [];
            var template = {
                parent: container,
                toDispose: toDispose
            };
            return template;
        };
        SettingsRenderer.prototype.renderCommonTemplate = function (tree, container, typeClass) {
            DOM.addClass(container, 'setting-item');
            DOM.addClass(container, 'setting-item-' + typeClass);
            var titleElement = DOM.append(container, $('.setting-item-title'));
            var labelCategoryContainer = DOM.append(titleElement, $('.setting-item-cat-label-container'));
            var categoryElement = DOM.append(labelCategoryContainer, $('span.setting-item-category'));
            var labelElement = DOM.append(labelCategoryContainer, $('span.setting-item-label'));
            var otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));
            var descriptionElement = DOM.append(container, $('.setting-item-description'));
            var modifiedIndicatorElement = DOM.append(container, $('.setting-item-modified-indicator'));
            modifiedIndicatorElement.title = nls_1.localize('modified', "Modified");
            var valueElement = DOM.append(container, $('.setting-item-value'));
            var controlElement = DOM.append(valueElement, $('div.setting-item-control'));
            var deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));
            var toDispose = [];
            var toolbarContainer = DOM.append(container, $('.setting-toolbar-container'));
            var toolbar = this.renderSettingToolbar(toolbarContainer);
            var template = {
                toDispose: toDispose,
                containerElement: container,
                categoryElement: categoryElement,
                labelElement: labelElement,
                descriptionElement: descriptionElement,
                controlElement: controlElement,
                deprecationWarningElement: deprecationWarningElement,
                otherOverridesElement: otherOverridesElement,
                toolbar: toolbar
            };
            // Prevent clicks from being handled by list
            toDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', function (e) { return e.stopPropagation(); }));
            toDispose.push(DOM.addStandardDisposableListener(valueElement, 'keydown', function (e) {
                if (e.keyCode === 9 /* Escape */) {
                    tree.domFocus();
                    e.browserEvent.stopPropagation();
                }
            }));
            return template;
        };
        SettingsRenderer.prototype.addSettingElementFocusHandler = function (template) {
            var _this = this;
            var focusTracker = DOM.trackFocus(template.containerElement);
            template.toDispose.push(focusTracker);
            focusTracker.onDidBlur(function () {
                if (template.containerElement.classList.contains('focused')) {
                    template.containerElement.classList.remove('focused');
                }
            });
            focusTracker.onDidFocus(function () {
                template.containerElement.classList.add('focused');
                if (template.context) {
                    _this._onDidFocusSetting.fire(template.context);
                }
            });
        };
        SettingsRenderer.prototype.renderSettingTextTemplate = function (tree, container, type) {
            if (type === void 0) { type = 'text'; }
            var common = this.renderCommonTemplate(tree, container, 'text');
            var validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));
            var inputBox = new inputBox_1.InputBox(common.controlElement, this.contextViewService);
            common.toDispose.push(inputBox);
            common.toDispose.push(styler_1.attachInputBoxStyler(inputBox, this.themeService, {
                inputBackground: settingsWidgets_1.settingsTextInputBackground,
                inputForeground: settingsWidgets_1.settingsTextInputForeground,
                inputBorder: settingsWidgets_1.settingsTextInputBorder
            }));
            common.toDispose.push(inputBox.onDidChange(function (e) {
                if (template.onChange) {
                    template.onChange(e);
                }
            }));
            common.toDispose.push(inputBox);
            inputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);
            var template = __assign({}, common, { inputBox: inputBox,
                validationErrorMessageElement: validationErrorMessageElement });
            this.addSettingElementFocusHandler(template);
            return template;
        };
        SettingsRenderer.prototype.renderSettingNumberTemplate = function (tree, container) {
            var common = this.renderCommonTemplate(tree, container, 'number');
            var validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));
            var inputBox = new inputBox_1.InputBox(common.controlElement, this.contextViewService, { type: 'number' });
            common.toDispose.push(inputBox);
            common.toDispose.push(styler_1.attachInputBoxStyler(inputBox, this.themeService, {
                inputBackground: settingsWidgets_1.settingsNumberInputBackground,
                inputForeground: settingsWidgets_1.settingsNumberInputForeground,
                inputBorder: settingsWidgets_1.settingsNumberInputBorder
            }));
            common.toDispose.push(inputBox.onDidChange(function (e) {
                if (template.onChange) {
                    template.onChange(e);
                }
            }));
            common.toDispose.push(inputBox);
            inputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);
            var template = __assign({}, common, { inputBox: inputBox,
                validationErrorMessageElement: validationErrorMessageElement });
            this.addSettingElementFocusHandler(template);
            return template;
        };
        SettingsRenderer.prototype.renderSettingToolbar = function (container) {
            var toggleMenuKeybinding = this.keybindingService.lookupKeybinding(preferences_1.SETTINGS_EDITOR_COMMAND_SHOW_CONTEXT_MENU);
            var toggleMenuTitle = nls_1.localize('settingsContextMenuTitle', "More Actions... ");
            if (toggleMenuKeybinding) {
                toggleMenuTitle += " (" + (toggleMenuKeybinding && toggleMenuKeybinding.getLabel()) + ")";
            }
            var toolbar = new toolbar_1.ToolBar(container, this.contextMenuService, {
                toggleMenuTitle: toggleMenuTitle
            });
            toolbar.setActions([], this.settingActions)();
            var button = container.querySelector('.toolbar-toggle-more');
            if (button) {
                button.tabIndex = -1;
            }
            return toolbar;
        };
        SettingsRenderer.prototype.renderSettingBoolTemplate = function (tree, container) {
            DOM.addClass(container, 'setting-item');
            DOM.addClass(container, 'setting-item-bool');
            var titleElement = DOM.append(container, $('.setting-item-title'));
            var categoryElement = DOM.append(titleElement, $('span.setting-item-category'));
            var labelElement = DOM.append(titleElement, $('span.setting-item-label'));
            var otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));
            var descriptionAndValueElement = DOM.append(container, $('.setting-item-value-description'));
            var controlElement = DOM.append(descriptionAndValueElement, $('.setting-item-bool-control'));
            var descriptionElement = DOM.append(descriptionAndValueElement, $('.setting-item-description'));
            var modifiedIndicatorElement = DOM.append(container, $('.setting-item-modified-indicator'));
            modifiedIndicatorElement.title = nls_1.localize('modified', "Modified");
            var deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));
            var toDispose = [];
            var checkbox = new checkbox_1.Checkbox({ actionClassName: 'setting-value-checkbox', isChecked: true, title: '', inputActiveOptionBorder: null });
            controlElement.appendChild(checkbox.domNode);
            toDispose.push(checkbox);
            toDispose.push(checkbox.onChange(function () {
                if (template.onChange) {
                    template.onChange(checkbox.checked);
                }
            }));
            // Need to listen for mouse clicks on description and toggle checkbox - use target ID for safety
            // Also have to ignore embedded links - too buried to stop propagation
            toDispose.push(DOM.addDisposableListener(descriptionElement, DOM.EventType.MOUSE_DOWN, function (e) {
                var targetElement = e.toElement;
                var targetId = descriptionElement.getAttribute('checkbox_label_target_id');
                // Make sure we are not a link and the target ID matches
                // Toggle target checkbox
                if (targetElement.tagName.toLowerCase() !== 'a' && targetId === template.checkbox.domNode.id) {
                    template.checkbox.checked = template.checkbox.checked ? false : true;
                    template.onChange(checkbox.checked);
                }
                DOM.EventHelper.stop(e);
            }));
            checkbox.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);
            var toolbarContainer = DOM.append(container, $('.setting-toolbar-container'));
            var toolbar = this.renderSettingToolbar(toolbarContainer);
            toDispose.push(toolbar);
            var template = {
                toDispose: toDispose,
                containerElement: container,
                categoryElement: categoryElement,
                labelElement: labelElement,
                controlElement: controlElement,
                checkbox: checkbox,
                descriptionElement: descriptionElement,
                deprecationWarningElement: deprecationWarningElement,
                otherOverridesElement: otherOverridesElement,
                toolbar: toolbar
            };
            this.addSettingElementFocusHandler(template);
            // Prevent clicks from being handled by list
            toDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', function (e) { return e.stopPropagation(); }));
            toDispose.push(DOM.addStandardDisposableListener(controlElement, 'keydown', function (e) {
                if (e.keyCode === 9 /* Escape */) {
                    tree.domFocus();
                    e.browserEvent.stopPropagation();
                }
            }));
            return template;
        };
        SettingsRenderer.prototype.cancelSuggesters = function () {
            this.contextViewService.hideContextView();
        };
        SettingsRenderer.prototype.renderSettingEnumTemplate = function (tree, container) {
            var common = this.renderCommonTemplate(tree, container, 'enum');
            var selectBox = new selectBox_1.SelectBox([], undefined, this.contextViewService, undefined, {
                hasDetails: true
            });
            common.toDispose.push(selectBox);
            common.toDispose.push(styler_1.attachSelectBoxStyler(selectBox, this.themeService, {
                selectBackground: settingsWidgets_1.settingsSelectBackground,
                selectForeground: settingsWidgets_1.settingsSelectForeground,
                selectBorder: settingsWidgets_1.settingsSelectBorder,
                selectListBorder: settingsWidgets_1.settingsSelectListBorder
            }));
            selectBox.render(common.controlElement);
            var selectElement = common.controlElement.querySelector('select');
            if (selectElement) {
                selectElement.classList.add(SettingsRenderer.CONTROL_CLASS);
            }
            common.toDispose.push(selectBox.onDidSelect(function (e) {
                if (template.onChange) {
                    template.onChange(e.index);
                }
            }));
            var enumDescriptionElement = common.containerElement.insertBefore($('.setting-item-enumDescription'), common.descriptionElement.nextSibling);
            var template = __assign({}, common, { selectBox: selectBox,
                enumDescriptionElement: enumDescriptionElement });
            this.addSettingElementFocusHandler(template);
            return template;
        };
        SettingsRenderer.prototype.renderSettingExcludeTemplate = function (tree, container) {
            var _this = this;
            var common = this.renderCommonTemplate(tree, container, 'exclude');
            var excludeWidget = this.instantiationService.createInstance(settingsWidgets_1.ExcludeSettingWidget, common.controlElement);
            excludeWidget.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);
            common.toDispose.push(excludeWidget);
            var template = __assign({}, common, { excludeWidget: excludeWidget });
            this.addSettingElementFocusHandler(template);
            common.toDispose.push(excludeWidget.onDidChangeExclude(function (e) {
                if (template.context) {
                    var newValue = __assign({}, template.context.scopeValue);
                    // first delete the existing entry, if present
                    if (e.originalPattern) {
                        if (e.originalPattern in template.context.defaultValue) {
                            // delete a default by overriding it
                            newValue[e.originalPattern] = false;
                        }
                        else {
                            delete newValue[e.originalPattern];
                        }
                    }
                    // then add the new or updated entry, if present
                    if (e.pattern) {
                        if (e.pattern in template.context.defaultValue && !e.sibling) {
                            // add a default by deleting its override
                            delete newValue[e.pattern];
                        }
                        else {
                            newValue[e.pattern] = e.sibling ? { when: e.sibling } : true;
                        }
                    }
                    var sortKeys = function (obj) {
                        var keyArray = Object.keys(obj)
                            .map(function (key) { return ({ key: key, val: obj[key] }); })
                            .sort(function (a, b) { return a.key.localeCompare(b.key); });
                        var retVal = {};
                        keyArray.forEach(function (pair) {
                            retVal[pair.key] = pair.val;
                        });
                        return retVal;
                    };
                    _this._onDidChangeSetting.fire({
                        key: template.context.setting.key,
                        value: Object.keys(newValue).length === 0 ? undefined : sortKeys(newValue),
                        type: template.context.valueType
                    });
                }
            }));
            return template;
        };
        SettingsRenderer.prototype.renderSettingComplexTemplate = function (tree, container) {
            var common = this.renderCommonTemplate(tree, container, 'complex');
            var openSettingsButton = new button_1.Button(common.controlElement, { title: true, buttonBackground: null, buttonHoverBackground: null });
            common.toDispose.push(openSettingsButton);
            common.toDispose.push(openSettingsButton.onDidClick(function () { return template.onChange(null); }));
            openSettingsButton.label = nls_1.localize('editInSettingsJson', "Edit in settings.json");
            openSettingsButton.element.classList.add('edit-in-settings-button');
            common.toDispose.push(styler_1.attachButtonStyler(openSettingsButton, this.themeService, {
                buttonBackground: color_1.Color.transparent.toString(),
                buttonHoverBackground: color_1.Color.transparent.toString(),
                buttonForeground: 'foreground'
            }));
            var template = __assign({}, common, { button: openSettingsButton });
            this.addSettingElementFocusHandler(template);
            return template;
        };
        SettingsRenderer.prototype.renderNewExtensionsTemplate = function (container) {
            var _this = this;
            var toDispose = [];
            container.classList.add('setting-item-new-extensions');
            var button = new button_1.Button(container, { title: true, buttonBackground: null, buttonHoverBackground: null });
            toDispose.push(button);
            toDispose.push(button.onDidClick(function () {
                if (template.context) {
                    _this.commandService.executeCommand('workbench.extensions.action.showExtensionsWithIds', template.context.extensionIds);
                }
            }));
            button.label = nls_1.localize('newExtensionsButtonLabel', "Show matching extensions");
            button.element.classList.add('settings-new-extensions-button');
            toDispose.push(styler_1.attachButtonStyler(button, this.themeService));
            var template = {
                button: button,
                toDispose: toDispose
            };
            // this.addSettingElementFocusHandler(template);
            return template;
        };
        SettingsRenderer.prototype.renderElement = function (tree, element, templateId, template) {
            if (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {
                return this.renderGroupElement(element, template);
            }
            if (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {
                return this.renderNewExtensionsElement(element, template);
            }
            return this.renderSettingElement(tree, element, templateId, template);
        };
        SettingsRenderer.prototype.renderGroupElement = function (element, template) {
            template.parent.innerHTML = '';
            var labelElement = DOM.append(template.parent, $('div.settings-group-title-label'));
            labelElement.classList.add("settings-group-level-" + element.level);
            labelElement.textContent = element.label;
            if (element.isFirstGroup) {
                labelElement.classList.add('settings-group-first');
            }
        };
        SettingsRenderer.prototype.renderNewExtensionsElement = function (element, template) {
            template.context = element;
        };
        SettingsRenderer.prototype.getSettingDOMElementForDOMElement = function (domElement) {
            var parent = DOM.findParentWithClass(domElement, 'setting-item');
            if (parent) {
                return parent;
            }
            return null;
        };
        SettingsRenderer.prototype.getDOMElementsForSettingKey = function (treeContainer, key) {
            return treeContainer.querySelectorAll("[" + SettingsRenderer.SETTING_KEY_ATTR + "=\"" + key + "\"]");
        };
        SettingsRenderer.prototype.getKeyForDOMElementInSetting = function (element) {
            var settingElement = this.getSettingDOMElementForDOMElement(element);
            return settingElement && settingElement.getAttribute(SettingsRenderer.SETTING_KEY_ATTR);
        };
        SettingsRenderer.prototype.renderSettingElement = function (tree, element, templateId, template) {
            template.context = element;
            template.toolbar.context = element;
            var setting = element.setting;
            DOM.toggleClass(template.containerElement, 'is-configured', element.isConfigured);
            DOM.toggleClass(template.containerElement, 'is-expanded', true);
            template.containerElement.setAttribute(SettingsRenderer.SETTING_KEY_ATTR, element.setting.key);
            var titleTooltip = setting.key + (element.isConfigured ? ' - Modified' : '');
            template.categoryElement.textContent = element.displayCategory && (element.displayCategory + ': ');
            template.categoryElement.title = titleTooltip;
            template.labelElement.textContent = element.displayLabel;
            template.labelElement.title = titleTooltip;
            this.renderValue(element, templateId, template);
            template.descriptionElement.innerHTML = '';
            if (element.setting.descriptionIsMarkdown) {
                var renderedDescription = this.renderDescriptionMarkdown(element, element.description, template.toDispose);
                template.descriptionElement.appendChild(renderedDescription);
            }
            else {
                template.descriptionElement.innerText = element.description;
            }
            var baseId = (element.displayCategory + '_' + element.displayLabel).replace(/ /g, '_').toLowerCase();
            template.descriptionElement.id = baseId + '_setting_description';
            if (templateId === SETTINGS_BOOL_TEMPLATE_ID) {
                // Add checkbox target to description clickable and able to toggle checkbox
                template.descriptionElement.setAttribute('checkbox_label_target_id', baseId + '_setting_item');
            }
            if (element.overriddenScopeList.length) {
                var otherOverridesLabel = element.isConfigured ?
                    nls_1.localize('alsoConfiguredIn', "Also modified in") :
                    nls_1.localize('configuredIn', "Modified in");
                template.otherOverridesElement.textContent = "(" + otherOverridesLabel + ": " + element.overriddenScopeList.join(', ') + ")";
            }
            else {
                template.otherOverridesElement.textContent = '';
            }
            // Remove tree attributes - sometimes overridden by tree - should be managed there
            template.containerElement.parentElement.removeAttribute('role');
            template.containerElement.parentElement.removeAttribute('aria-level');
            template.containerElement.parentElement.removeAttribute('aria-posinset');
            template.containerElement.parentElement.removeAttribute('aria-setsize');
        };
        SettingsRenderer.prototype.renderDescriptionMarkdown = function (element, text, disposeables) {
            var _this = this;
            // Rewrite `#editor.fontSize#` to link format
            text = fixSettingLinks(text);
            var renderedMarkdown = htmlContentRenderer_1.renderMarkdown({ value: text }, {
                actionHandler: {
                    callback: function (content) {
                        if (strings_1.startsWith(content, '#')) {
                            var e = {
                                source: element,
                                targetKey: content.substr(1)
                            };
                            _this._onDidClickSettingLink.fire(e);
                        }
                        else {
                            var uri = void 0;
                            try {
                                uri = uri_1.URI.parse(content);
                            }
                            catch (err) {
                                // ignore
                            }
                            if (uri) {
                                _this.openerService.open(uri).catch(errors_1.onUnexpectedError);
                            }
                        }
                    },
                    disposeables: disposeables
                }
            });
            renderedMarkdown.classList.add('setting-item-description-markdown');
            cleanRenderedMarkdown(renderedMarkdown);
            return renderedMarkdown;
        };
        SettingsRenderer.prototype.renderValue = function (element, templateId, template) {
            var _this = this;
            var onChange = function (value) { return _this._onDidChangeSetting.fire({ key: element.setting.key, value: value, type: template.context.valueType }); };
            template.deprecationWarningElement.innerText = element.setting.deprecationMessage || '';
            if (templateId === SETTINGS_ENUM_TEMPLATE_ID) {
                this.renderEnum(element, template, onChange);
            }
            else if (templateId === SETTINGS_TEXT_TEMPLATE_ID) {
                this.renderText(element, template, onChange);
            }
            else if (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {
                this.renderNumber(element, template, onChange);
            }
            else if (templateId === SETTINGS_BOOL_TEMPLATE_ID) {
                this.renderBool(element, template, onChange);
            }
            else if (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {
                this.renderExcludeSetting(element, template);
            }
            else if (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {
                this.renderComplexSetting(element, template);
            }
        };
        SettingsRenderer.prototype.renderBool = function (dataElement, template, onChange) {
            template.onChange = null;
            template.checkbox.checked = dataElement.value;
            template.onChange = onChange;
            // Setup and add ARIA attributes
            // Create id and label for control/input element - parent is wrapper div
            var baseId = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_').toLowerCase();
            var modifiedText = dataElement.isConfigured ? 'Modified' : '';
            var label = dataElement.displayCategory + ' ' + dataElement.displayLabel + ' ' + modifiedText;
            // We use the parent control div for the aria-labelledby target
            // Does not appear you can use the direct label on the element itself within a tree
            template.checkbox.domNode.parentElement.id = baseId + '_setting_label';
            template.checkbox.domNode.parentElement.setAttribute('aria-label', label);
            // Labels will not be read on descendent input elements of the parent treeitem
            // unless defined as role=treeitem and indirect aria-labelledby approach
            template.checkbox.domNode.id = baseId + '_setting_item';
            template.checkbox.domNode.setAttribute('role', 'checkbox');
            template.checkbox.domNode.setAttribute('aria-labelledby', baseId + '_setting_label');
            template.checkbox.domNode.setAttribute('aria-describedby', baseId + '_setting_description');
        };
        SettingsRenderer.prototype.renderEnum = function (dataElement, template, onChange) {
            var displayOptions = dataElement.setting.enum
                .map(String)
                .map(escapeInvisibleChars);
            template.selectBox.setOptions(displayOptions);
            var enumDescriptions = dataElement.setting.enumDescriptions;
            var enumDescriptionsAreMarkdown = dataElement.setting.enumDescriptionsAreMarkdown;
            template.selectBox.setDetailsProvider(function (index) {
                return ({
                    details: enumDescriptions && enumDescriptions[index] && (enumDescriptionsAreMarkdown ? fixSettingLinks(enumDescriptions[index], false) : enumDescriptions[index]),
                    isMarkdown: enumDescriptionsAreMarkdown
                });
            });
            var modifiedText = dataElement.isConfigured ? 'Modified' : '';
            // Use ',.' as reader pause
            var label = dataElement.displayCategory + ' ' + dataElement.displayLabel + ',. ' + modifiedText;
            var baseId = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_').toLowerCase();
            template.selectBox.setAriaLabel(label);
            var idx = dataElement.setting.enum.indexOf(dataElement.value);
            template.onChange = null;
            template.selectBox.select(idx);
            template.onChange = function (idx) { return onChange(dataElement.setting.enum[idx]); };
            if (template.controlElement.firstElementChild) {
                // SelectBox needs to have treeitem changed to combobox to read correctly within tree
                template.controlElement.firstElementChild.setAttribute('role', 'combobox');
                template.controlElement.firstElementChild.setAttribute('aria-describedby', baseId + '_setting_description settings_aria_more_actions_shortcut_label');
            }
            template.enumDescriptionElement.innerHTML = '';
        };
        SettingsRenderer.prototype.renderText = function (dataElement, template, onChange) {
            var modifiedText = dataElement.isConfigured ? 'Modified' : '';
            // Use ',.' as reader pause
            var label = dataElement.displayCategory + ' ' + dataElement.displayLabel + ',. ' + modifiedText;
            template.onChange = null;
            template.inputBox.value = dataElement.value;
            template.onChange = function (value) { renderValidations(dataElement, template, false, label); onChange(value); };
            // Setup and add ARIA attributes
            // Create id and label for control/input element - parent is wrapper div
            var baseId = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_').toLowerCase();
            // We use the parent control div for the aria-labelledby target
            // Does not appear you can use the direct label on the element itself within a tree
            template.inputBox.inputElement.parentElement.id = baseId + '_setting_label';
            template.inputBox.inputElement.parentElement.setAttribute('aria-label', label);
            // Labels will not be read on descendent input elements of the parent treeitem
            // unless defined as role=treeitem and indirect aria-labelledby approach
            template.inputBox.inputElement.id = baseId + '_setting_item';
            template.inputBox.inputElement.setAttribute('role', 'textbox');
            template.inputBox.inputElement.setAttribute('aria-labelledby', baseId + '_setting_label');
            template.inputBox.inputElement.setAttribute('aria-describedby', baseId + '_setting_description settings_aria_more_actions_shortcut_label');
            renderValidations(dataElement, template, true, label);
        };
        SettingsRenderer.prototype.renderNumber = function (dataElement, template, onChange) {
            var modifiedText = dataElement.isConfigured ? 'Modified' : '';
            // Use ',.' as reader pause
            var label = dataElement.displayCategory + ' ' + dataElement.displayLabel + ' number,. ' + modifiedText;
            var numParseFn = (dataElement.valueType === 'integer' || dataElement.valueType === 'nullable-integer')
                ? parseInt : parseFloat;
            var nullNumParseFn = (dataElement.valueType === 'nullable-integer' || dataElement.valueType === 'nullable-number')
                ? (function (v) { return v === '' ? null : numParseFn(v); }) : numParseFn;
            template.onChange = null;
            template.inputBox.value = dataElement.value;
            template.onChange = function (value) { renderValidations(dataElement, template, false, label); onChange(nullNumParseFn(value)); };
            // Setup and add ARIA attributes
            // Create id and label for control/input element - parent is wrapper div
            var baseId = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_').toLowerCase();
            // We use the parent control div for the aria-labelledby target
            // Does not appear you can use the direct label on the element itself within a tree
            template.inputBox.inputElement.parentElement.id = baseId + '_setting_label';
            template.inputBox.inputElement.parentElement.setAttribute('aria-label', label);
            // Labels will not be read on descendent input elements of the parent treeitem
            // unless defined as role=treeitem and indirect aria-labelledby approach
            template.inputBox.inputElement.id = baseId + '_setting_item';
            template.inputBox.inputElement.setAttribute('role', 'textbox');
            template.inputBox.inputElement.setAttribute('aria-labelledby', baseId + '_setting_label');
            template.inputBox.inputElement.setAttribute('aria-describedby', baseId + '_setting_description settings_aria_more_actions_shortcut_label');
            renderValidations(dataElement, template, true, label);
        };
        SettingsRenderer.prototype.renderExcludeSetting = function (dataElement, template) {
            var value = getExcludeDisplayValue(dataElement);
            template.excludeWidget.setValue(value);
            template.context = dataElement;
        };
        SettingsRenderer.prototype.renderComplexSetting = function (dataElement, template) {
            var _this = this;
            template.onChange = function () { return _this._onDidOpenSettings.fire(dataElement.setting.key); };
        };
        SettingsRenderer.prototype.disposeTemplate = function (tree, templateId, template) {
            lifecycle_1.dispose(template.toDispose);
        };
        SettingsRenderer.CONTROL_CLASS = 'setting-control-focus-target';
        SettingsRenderer.CONTROL_SELECTOR = '.' + SettingsRenderer.CONTROL_CLASS;
        SettingsRenderer.SETTING_KEY_ATTR = 'data-key';
        SettingsRenderer = __decorate([
            __param(1, themeService_1.IThemeService),
            __param(2, contextView_1.IContextViewService),
            __param(3, opener_1.IOpenerService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, commands_1.ICommandService),
            __param(6, contextView_1.IContextMenuService),
            __param(7, keybinding_1.IKeybindingService)
        ], SettingsRenderer);
        return SettingsRenderer;
    }());
    exports.SettingsRenderer = SettingsRenderer;
    function renderValidations(dataElement, template, calledOnStartup, originalAriaLabel) {
        if (dataElement.setting.validator) {
            var errMsg = dataElement.setting.validator(template.inputBox.value);
            if (errMsg) {
                DOM.addClass(template.containerElement, 'invalid-input');
                template.validationErrorMessageElement.innerText = errMsg;
                var validationError = nls_1.localize('validationError', "Validation Error.");
                template.inputBox.inputElement.parentElement.setAttribute('aria-label', [originalAriaLabel, validationError, errMsg].join(' '));
                if (!calledOnStartup) {
                    aria_1.alert(validationError + ' ' + errMsg);
                }
                return;
            }
            else {
                template.inputBox.inputElement.parentElement.setAttribute('aria-label', originalAriaLabel);
            }
        }
        DOM.removeClass(template.containerElement, 'invalid-input');
    }
    function cleanRenderedMarkdown(element) {
        for (var i = 0; i < element.childNodes.length; i++) {
            var child = element.childNodes.item(i);
            var tagName = child.tagName && child.tagName.toLowerCase();
            if (tagName === 'img') {
                element.removeChild(child);
            }
            else {
                cleanRenderedMarkdown(child);
            }
        }
    }
    function fixSettingLinks(text, linkify) {
        if (linkify === void 0) { linkify = true; }
        return text.replace(/`#([^#]*)#`/g, function (match, settingKey) {
            var targetDisplayFormat = settingsTreeModels_1.settingKeyToDisplayFormat(settingKey);
            var targetName = targetDisplayFormat.category + ": " + targetDisplayFormat.label;
            return linkify ?
                "[" + targetName + "](#" + settingKey + ")" :
                "\"" + targetName + "\"";
        });
    }
    function escapeInvisibleChars(enumValue) {
        return enumValue && enumValue
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r');
    }
    var SettingsTreeFilter = /** @class */ (function () {
        function SettingsTreeFilter(viewState) {
            this.viewState = viewState;
        }
        SettingsTreeFilter.prototype.isVisible = function (tree, element) {
            var _this = this;
            // Filter during search
            if (this.viewState.filterToCategory && element instanceof settingsTreeModels_1.SettingsTreeSettingElement) {
                if (!this.settingContainedInGroup(element.setting, this.viewState.filterToCategory)) {
                    return false;
                }
            }
            // Non-user scope selected
            if (element instanceof settingsTreeModels_1.SettingsTreeSettingElement && this.viewState.settingsTarget !== 1 /* USER */) {
                if (!element.matchesScope(this.viewState.settingsTarget)) {
                    return false;
                }
            }
            // @modified or tag
            if (element instanceof settingsTreeModels_1.SettingsTreeSettingElement && this.viewState.tagFilters) {
                if (!element.matchesAllTags(this.viewState.tagFilters)) {
                    return false;
                }
            }
            // Group with no visible children
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                if (typeof element.count === 'number') {
                    return element.count > 0;
                }
                return element.children.some(function (child) { return _this.isVisible(tree, child); });
            }
            // Filtered "new extensions" button
            if (element instanceof settingsTreeModels_1.SettingsTreeNewExtensionsElement) {
                if ((this.viewState.tagFilters && this.viewState.tagFilters.size) || this.viewState.filterToCategory) {
                    return false;
                }
            }
            return true;
        };
        SettingsTreeFilter.prototype.settingContainedInGroup = function (setting, group) {
            var _this = this;
            return group.children.some(function (child) {
                if (child instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                    return _this.settingContainedInGroup(setting, child);
                }
                else if (child instanceof settingsTreeModels_1.SettingsTreeSettingElement) {
                    return child.setting.key === setting.key;
                }
                else {
                    return false;
                }
            });
        };
        return SettingsTreeFilter;
    }());
    exports.SettingsTreeFilter = SettingsTreeFilter;
    var SettingsTreeController = /** @class */ (function (_super) {
        __extends(SettingsTreeController, _super);
        function SettingsTreeController(configurationService) {
            return _super.call(this, {}, configurationService) || this;
        }
        SettingsTreeController.prototype.onLeftClick = function (tree, element, eventish, origin) {
            var isLink = eventish.target.tagName.toLowerCase() === 'a' ||
                eventish.target.parentElement.tagName.toLowerCase() === 'a'; // <code> inside <a>
            if (isLink && (DOM.findParentWithClass(eventish.target, 'setting-item-description-markdown', tree.getHTMLElement()) || DOM.findParentWithClass(eventish.target, 'select-box-description-markdown'))) {
                return true;
            }
            return false;
        };
        SettingsTreeController = __decorate([
            __param(0, configuration_1.IConfigurationService)
        ], SettingsTreeController);
        return SettingsTreeController;
    }(listService_1.WorkbenchTreeController));
    exports.SettingsTreeController = SettingsTreeController;
    var SettingsAccessibilityProvider = /** @class */ (function () {
        function SettingsAccessibilityProvider() {
        }
        SettingsAccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            if (!element) {
                return '';
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeSettingElement) {
                return nls_1.localize('settingRowAriaLabel', "{0} {1}, Setting", element.displayCategory, element.displayLabel);
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                return nls_1.localize('groupRowAriaLabel', "{0}, group", element.label);
            }
            return '';
        };
        return SettingsAccessibilityProvider;
    }());
    exports.SettingsAccessibilityProvider = SettingsAccessibilityProvider;
    var NonExpandableOrSelectableTree = /** @class */ (function (_super) {
        __extends(NonExpandableOrSelectableTree, _super);
        function NonExpandableOrSelectableTree() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NonExpandableOrSelectableTree.prototype.expand = function () {
            return winjs_base_1.TPromise.wrap(null);
        };
        NonExpandableOrSelectableTree.prototype.collapse = function () {
            return winjs_base_1.TPromise.wrap(null);
        };
        NonExpandableOrSelectableTree.prototype.setFocus = function (element, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusNext = function (count, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusPrevious = function (count, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusParent = function (eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusFirstChild = function (eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusFirst = function (eventPayload, from) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusNth = function (index, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusLast = function (eventPayload, from) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusNextPage = function (eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.focusPreviousPage = function (eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.select = function (element, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.selectRange = function (fromElement, toElement, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.selectAll = function (elements, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.setSelection = function (elements, eventPayload) {
            return;
        };
        NonExpandableOrSelectableTree.prototype.toggleSelection = function (element, eventPayload) {
            return;
        };
        return NonExpandableOrSelectableTree;
    }(treeImpl_1.Tree));
    var SettingsTree = /** @class */ (function (_super) {
        __extends(SettingsTree, _super);
        function SettingsTree(container, viewState, configuration, themeService, instantiationService) {
            var _this = this;
            var treeClass = 'settings-editor-tree';
            var controller = instantiationService.createInstance(SettingsTreeController);
            var fullConfiguration = __assign({ controller: controller, accessibilityProvider: instantiationService.createInstance(SettingsAccessibilityProvider), filter: instantiationService.createInstance(SettingsTreeFilter, viewState), styler: new treeDefaults_1.DefaultTreestyler(DOM.createStyleSheet(container), treeClass) }, configuration);
            var options = {
                ariaLabel: nls_1.localize('treeAriaLabel', "Settings"),
                showLoading: false,
                indentPixels: 0,
                twistiePixels: 20,
            };
            _this = _super.call(this, container, fullConfiguration, options) || this;
            _this.disposables = [];
            _this.disposables.push(controller);
            _this.disposables.push(themeService_1.registerThemingParticipant(function (theme, collector) {
                var activeBorderColor = theme.getColor(colorRegistry_1.focusBorder);
                if (activeBorderColor) {
                    // TODO@rob - why isn't this applied when added to the stylesheet from tocTree.ts? Seems like a chromium glitch.
                    collector.addRule(".settings-editor > .settings-body > .settings-toc-container .monaco-tree:focus .monaco-tree-row.focused {outline: solid 1px " + activeBorderColor + "; outline-offset: -1px;  }");
                }
                var foregroundColor = theme.getColor(colorRegistry_1.foreground);
                if (foregroundColor) {
                    // Links appear inside other elements in markdown. CSS opacity acts like a mask. So we have to dynamically compute the description color to avoid
                    // applying an opacity to the link color.
                    var fgWithOpacity = new color_1.Color(new color_1.RGBA(foregroundColor.rgba.r, foregroundColor.rgba.g, foregroundColor.rgba.b, .9));
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description { color: " + fgWithOpacity + "; }");
                }
                var errorColor = theme.getColor(colorRegistry_1.errorForeground);
                if (errorColor) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-deprecation-message { color: " + errorColor + "; }");
                }
                var invalidInputBackground = theme.getColor(colorRegistry_1.inputValidationErrorBackground);
                if (invalidInputBackground) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { background-color: " + invalidInputBackground + "; }");
                }
                var invalidInputForeground = theme.getColor(colorRegistry_1.inputValidationErrorForeground);
                if (invalidInputForeground) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { color: " + invalidInputForeground + "; }");
                }
                var invalidInputBorder = theme.getColor(colorRegistry_1.inputValidationErrorBorder);
                if (invalidInputBorder) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { border-style:solid; border-width: 1px; border-color: " + invalidInputBorder + "; }");
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item.invalid-input .setting-item-control .monaco-inputbox.idle { outline-width: 0; border-style:solid; border-width: 1px; border-color: " + invalidInputBorder + "; }");
                }
                var headerForegroundColor = theme.getColor(settingsWidgets_1.settingsHeaderForeground);
                if (headerForegroundColor) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .settings-group-title-label { color: " + headerForegroundColor + "; }");
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item-label { color: " + headerForegroundColor + "; }");
                }
                var focusBorderColor = theme.getColor(colorRegistry_1.focusBorder);
                if (focusBorderColor) {
                    collector.addRule(".settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description-markdown a:focus { outline-color: " + focusBorderColor + " }");
                }
            }));
            _this.getHTMLElement().classList.add(treeClass);
            _this.disposables.push(styler_1.attachStyler(themeService, {
                listActiveSelectionBackground: colorRegistry_1.editorBackground,
                listActiveSelectionForeground: colorRegistry_1.foreground,
                listFocusAndSelectionBackground: colorRegistry_1.editorBackground,
                listFocusAndSelectionForeground: colorRegistry_1.foreground,
                listFocusBackground: colorRegistry_1.editorBackground,
                listFocusForeground: colorRegistry_1.foreground,
                listHoverForeground: colorRegistry_1.foreground,
                listHoverBackground: colorRegistry_1.editorBackground,
                listHoverOutline: colorRegistry_1.editorBackground,
                listFocusOutline: colorRegistry_1.editorBackground,
                listInactiveSelectionBackground: colorRegistry_1.editorBackground,
                listInactiveSelectionForeground: colorRegistry_1.foreground
            }, function (colors) {
                _this.style(colors);
            }));
            return _this;
        }
        SettingsTree.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        SettingsTree = __decorate([
            __param(3, themeService_1.IThemeService),
            __param(4, instantiation_1.IInstantiationService)
        ], SettingsTree);
        return SettingsTree;
    }(NonExpandableOrSelectableTree));
    exports.SettingsTree = SettingsTree;
    var CopySettingIdAction = /** @class */ (function (_super) {
        __extends(CopySettingIdAction, _super);
        function CopySettingIdAction(clipboardService) {
            var _this = _super.call(this, CopySettingIdAction.ID, CopySettingIdAction.LABEL) || this;
            _this.clipboardService = clipboardService;
            return _this;
        }
        CopySettingIdAction.prototype.run = function (context) {
            if (context) {
                this.clipboardService.writeText(context.setting.key);
            }
            return winjs_base_1.TPromise.as(null);
        };
        CopySettingIdAction.ID = 'settings.copySettingId';
        CopySettingIdAction.LABEL = nls_1.localize('copySettingIdLabel', "Copy Setting ID");
        CopySettingIdAction = __decorate([
            __param(0, clipboardService_1.IClipboardService)
        ], CopySettingIdAction);
        return CopySettingIdAction;
    }(actions_1.Action));
    var CopySettingAsJSONAction = /** @class */ (function (_super) {
        __extends(CopySettingAsJSONAction, _super);
        function CopySettingAsJSONAction(clipboardService) {
            var _this = _super.call(this, CopySettingAsJSONAction.ID, CopySettingAsJSONAction.LABEL) || this;
            _this.clipboardService = clipboardService;
            return _this;
        }
        CopySettingAsJSONAction.prototype.run = function (context) {
            if (context) {
                var jsonResult = "\"" + context.setting.key + "\": " + JSON.stringify(context.value, undefined, '  ');
                this.clipboardService.writeText(jsonResult);
            }
            return winjs_base_1.TPromise.as(null);
        };
        CopySettingAsJSONAction.ID = 'settings.copySettingAsJSON';
        CopySettingAsJSONAction.LABEL = nls_1.localize('copySettingAsJSONLabel', "Copy Setting as JSON");
        CopySettingAsJSONAction = __decorate([
            __param(0, clipboardService_1.IClipboardService)
        ], CopySettingAsJSONAction);
        return CopySettingAsJSONAction;
    }(actions_1.Action));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[356/*vs/workbench/parts/preferences/browser/tocTree*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,134/*vs/base/common/scrollable*/,5/*vs/base/common/winjs.base*/,203/*vs/base/parts/tree/browser/treeDefaults*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/,51/*vs/platform/list/browser/listService*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,202/*vs/workbench/parts/preferences/browser/settingsTree*/,161/*vs/workbench/parts/preferences/browser/settingsTreeModels*/,151/*vs/workbench/parts/preferences/browser/settingsWidgets*/]), function (require, exports, DOM, scrollable_1, winjs_base_1, treeDefaults_1, configuration_1, contextkey_1, instantiation_1, listService_1, colorRegistry_1, styler_1, themeService_1, settingsTree_1, settingsTreeModels_1, settingsWidgets_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = DOM.$;
    var TOCTreeModel = /** @class */ (function () {
        function TOCTreeModel(_viewState) {
            this._viewState = _viewState;
        }
        Object.defineProperty(TOCTreeModel.prototype, "settingsTreeRoot", {
            get: function () {
                return this._settingsTreeRoot;
            },
            set: function (value) {
                this._settingsTreeRoot = value;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TOCTreeModel.prototype, "currentSearchModel", {
            set: function (model) {
                this._currentSearchModel = model;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TOCTreeModel.prototype, "children", {
            get: function () {
                return this._settingsTreeRoot.children;
            },
            enumerable: true,
            configurable: true
        });
        TOCTreeModel.prototype.update = function () {
            if (this._settingsTreeRoot) {
                this.updateGroupCount(this._settingsTreeRoot);
            }
        };
        TOCTreeModel.prototype.updateGroupCount = function (group) {
            var _this = this;
            group.children.forEach(function (child) {
                if (child instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                    _this.updateGroupCount(child);
                }
            });
            var childCount = group.children
                .filter(function (child) { return child instanceof settingsTreeModels_1.SettingsTreeGroupElement; })
                .reduce(function (acc, cur) { return acc + cur.count; }, 0);
            group.count = childCount + this.getGroupCount(group);
        };
        TOCTreeModel.prototype.getGroupCount = function (group) {
            var _this = this;
            return group.children.filter(function (child) {
                if (!(child instanceof settingsTreeModels_1.SettingsTreeSettingElement)) {
                    return false;
                }
                if (_this._currentSearchModel && !_this._currentSearchModel.root.containsSetting(child.setting.key)) {
                    return false;
                }
                // Check everything that the SettingsFilter checks except whether it's filtered by a category
                return child.matchesScope(_this._viewState.settingsTarget) && child.matchesAllTags(_this._viewState.tagFilters);
            }).length;
        };
        return TOCTreeModel;
    }());
    exports.TOCTreeModel = TOCTreeModel;
    var TOCDataSource = /** @class */ (function () {
        function TOCDataSource(_treeFilter) {
            this._treeFilter = _treeFilter;
        }
        TOCDataSource.prototype.getId = function (tree, element) {
            return element.id;
        };
        TOCDataSource.prototype.hasChildren = function (tree, element) {
            var _this = this;
            if (element instanceof TOCTreeModel) {
                return true;
            }
            if (element instanceof settingsTreeModels_1.SettingsTreeGroupElement) {
                // Should have child which won't be filtered out
                return element.children && element.children.some(function (child) { return child instanceof settingsTreeModels_1.SettingsTreeGroupElement && _this._treeFilter.isVisible(tree, child); });
            }
            return false;
        };
        TOCDataSource.prototype.getChildren = function (tree, element) {
            return winjs_base_1.TPromise.as(this._getChildren(element));
        };
        TOCDataSource.prototype._getChildren = function (element) {
            return element.children
                .filter(function (child) { return child instanceof settingsTreeModels_1.SettingsTreeGroupElement; });
        };
        TOCDataSource.prototype.getParent = function (tree, element) {
            return winjs_base_1.TPromise.wrap(element instanceof settingsTreeModels_1.SettingsTreeGroupElement && element.parent);
        };
        return TOCDataSource;
    }());
    exports.TOCDataSource = TOCDataSource;
    var TOC_ENTRY_TEMPLATE_ID = 'settings.toc.entry';
    var TOCRenderer = /** @class */ (function () {
        function TOCRenderer() {
        }
        TOCRenderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        TOCRenderer.prototype.getTemplateId = function (tree, element) {
            return TOC_ENTRY_TEMPLATE_ID;
        };
        TOCRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            return {
                labelElement: DOM.append(container, $('.settings-toc-entry')),
                countElement: DOM.append(container, $('.settings-toc-count'))
            };
        };
        TOCRenderer.prototype.renderElement = function (tree, element, templateId, template) {
            var count = element.count;
            var label = element.label;
            DOM.toggleClass(template.labelElement, 'no-results', count === 0);
            template.labelElement.textContent = label;
            if (count) {
                template.countElement.textContent = " (" + count + ")";
            }
            else {
                template.countElement.textContent = '';
            }
        };
        TOCRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
        };
        return TOCRenderer;
    }());
    exports.TOCRenderer = TOCRenderer;
    var TOCTree = /** @class */ (function (_super) {
        __extends(TOCTree, _super);
        function TOCTree(container, viewState, configuration, contextKeyService, listService, themeService, instantiationService, configurationService) {
            var _this = this;
            var treeClass = 'settings-toc-tree';
            var filter = instantiationService.createInstance(settingsTree_1.SettingsTreeFilter, viewState);
            var fullConfiguration = __assign({ controller: instantiationService.createInstance(listService_1.WorkbenchTreeController, {}), filter: filter, styler: new treeDefaults_1.DefaultTreestyler(DOM.createStyleSheet(container), treeClass), dataSource: instantiationService.createInstance(TOCDataSource, filter), accessibilityProvider: instantiationService.createInstance(settingsTree_1.SettingsAccessibilityProvider) }, configuration);
            var options = {
                showLoading: false,
                twistiePixels: 15,
                horizontalScrollMode: scrollable_1.ScrollbarVisibility.Hidden
            };
            _this = _super.call(this, container, fullConfiguration, options, contextKeyService, listService, themeService, instantiationService, configurationService) || this;
            _this.getHTMLElement().classList.add(treeClass);
            _this.disposables.push(styler_1.attachStyler(themeService, {
                listActiveSelectionBackground: colorRegistry_1.editorBackground,
                listActiveSelectionForeground: settingsWidgets_1.settingsHeaderForeground,
                listFocusAndSelectionBackground: colorRegistry_1.editorBackground,
                listFocusAndSelectionForeground: settingsWidgets_1.settingsHeaderForeground,
                listFocusBackground: colorRegistry_1.editorBackground,
                listFocusForeground: settingsWidgets_1.settingsHeaderForeground,
                listHoverForeground: settingsWidgets_1.settingsHeaderForeground,
                listHoverBackground: colorRegistry_1.editorBackground,
                listInactiveSelectionBackground: colorRegistry_1.editorBackground,
                listInactiveSelectionForeground: settingsWidgets_1.settingsHeaderForeground,
            }, function (colors) {
                _this.style(colors);
            }));
            return _this;
        }
        TOCTree = __decorate([
            __param(3, contextkey_1.IContextKeyService),
            __param(4, listService_1.IListService),
            __param(5, themeService_1.IThemeService),
            __param(6, instantiation_1.IInstantiationService),
            __param(7, configuration_1.IConfigurationService)
        ], TOCTree);
        return TOCTree;
    }(listService_1.WorkbenchTree));
    exports.TOCTree = TOCTree;
});










define(__m[357/*vs/workbench/parts/preferences/common/preferencesContribution*/], __M([0/*require*/,1/*exports*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,198/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,9/*vs/platform/registry/common/platform*/,66/*vs/editor/common/services/resolverService*/,61/*vs/workbench/services/preferences/common/preferences*/,4/*vs/base/common/lifecycle*/,11/*vs/workbench/services/editor/common/editorService*/,22/*vs/base/common/strings*/,43/*vs/platform/environment/common/environment*/,20/*vs/platform/workspace/common/workspace*/,7/*vs/platform/configuration/common/configuration*/,18/*vs/base/common/platform*/,35/*vs/base/common/resources*/]), function (require, exports, modelService_1, modeService_1, uri_1, winjs_base_1, JSONContributionRegistry, platform_1, resolverService_1, preferences_1, lifecycle_1, editorService_1, strings_1, environment_1, workspace_1, configuration_1, platform_2, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var schemaRegistry = platform_1.Registry.as(JSONContributionRegistry.Extensions.JSONContribution);
    var PreferencesContribution = /** @class */ (function () {
        function PreferencesContribution(modelService, textModelResolverService, preferencesService, modeService, editorService, environmentService, workspaceService, configurationService) {
            var _this = this;
            this.modelService = modelService;
            this.textModelResolverService = textModelResolverService;
            this.preferencesService = preferencesService;
            this.modeService = modeService;
            this.editorService = editorService;
            this.environmentService = environmentService;
            this.workspaceService = workspaceService;
            this.configurationService = configurationService;
            this.settingsListener = this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration(preferences_1.DEFAULT_SETTINGS_EDITOR_SETTING)) {
                    _this.handleSettingsEditorOverride();
                }
            });
            this.handleSettingsEditorOverride();
            this.start();
        }
        PreferencesContribution.prototype.handleSettingsEditorOverride = function () {
            var _this = this;
            // dispose any old listener we had
            this.editorOpeningListener = lifecycle_1.dispose(this.editorOpeningListener);
            // install editor opening listener unless user has disabled this
            if (!!this.configurationService.getValue(preferences_1.DEFAULT_SETTINGS_EDITOR_SETTING)) {
                this.editorOpeningListener = this.editorService.overrideOpenEditor(function (editor, options, group) { return _this.onEditorOpening(editor, options, group); });
            }
        };
        PreferencesContribution.prototype.onEditorOpening = function (editor, options, group) {
            var resource = editor.getResource();
            if (!resource ||
                !strings_1.endsWith(resource.path, 'settings.json') || // resource must end in settings.json
                !this.configurationService.getValue(preferences_1.DEFAULT_SETTINGS_EDITOR_SETTING) // user has not disabled default settings editor
            ) {
                return void 0;
            }
            // If the resource was already opened before in the group, do not prevent
            // the opening of that resource. Otherwise we would have the same settings
            // opened twice (https://github.com/Microsoft/vscode/issues/36447)
            if (group.isOpened(editor)) {
                return void 0;
            }
            // Global User Settings File
            if (resources_1.isEqual(resource, uri_1.URI.file(this.environmentService.appSettingsPath), !platform_2.isLinux)) {
                return { override: this.preferencesService.openGlobalSettings(true, options, group) };
            }
            // Single Folder Workspace Settings File
            var state = this.workspaceService.getWorkbenchState();
            if (state === 2 /* FOLDER */) {
                var folders = this.workspaceService.getWorkspace().folders;
                if (resources_1.isEqual(resource, folders[0].toResource(preferences_1.FOLDER_SETTINGS_PATH))) {
                    return { override: this.preferencesService.openWorkspaceSettings(true, options, group) };
                }
            }
            // Multi Folder Workspace Settings File
            else if (state === 3 /* WORKSPACE */) {
                var folders = this.workspaceService.getWorkspace().folders;
                for (var i = 0; i < folders.length; i++) {
                    if (resources_1.isEqual(resource, folders[i].toResource(preferences_1.FOLDER_SETTINGS_PATH))) {
                        return { override: this.preferencesService.openFolderSettings(folders[i].uri, true, options, group) };
                    }
                }
            }
            return void 0;
        };
        PreferencesContribution.prototype.start = function () {
            var _this = this;
            this.textModelResolverService.registerTextModelContentProvider('vscode', {
                provideTextContent: function (uri) {
                    if (uri.scheme !== 'vscode') {
                        return null;
                    }
                    if (uri.authority === 'schemas') {
                        var schemaModel = _this.getSchemaModel(uri);
                        if (schemaModel) {
                            return winjs_base_1.TPromise.as(schemaModel);
                        }
                    }
                    return _this.preferencesService.resolveModel(uri);
                }
            });
        };
        PreferencesContribution.prototype.getSchemaModel = function (uri) {
            var schema = schemaRegistry.getSchemaContributions().schemas[uri.toString()];
            if (schema) {
                var modelContent = JSON.stringify(schema);
                var mode = this.modeService.getOrCreateMode('jsonc');
                var model_1 = this.modelService.createModel(modelContent, mode, uri);
                var disposables_1 = [];
                disposables_1.push(schemaRegistry.onDidChangeSchema(function (schemaUri) {
                    if (schemaUri === uri.toString()) {
                        schema = schemaRegistry.getSchemaContributions().schemas[uri.toString()];
                        model_1.setValue(JSON.stringify(schema));
                    }
                }));
                disposables_1.push(model_1.onWillDispose(function () { return lifecycle_1.dispose(disposables_1); }));
                return model_1;
            }
            return null;
        };
        PreferencesContribution.prototype.dispose = function () {
            this.editorOpeningListener = lifecycle_1.dispose(this.editorOpeningListener);
            this.settingsListener = lifecycle_1.dispose(this.settingsListener);
        };
        PreferencesContribution = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, resolverService_1.ITextModelService),
            __param(2, preferences_1.IPreferencesService),
            __param(3, modeService_1.IModeService),
            __param(4, editorService_1.IEditorService),
            __param(5, environment_1.IEnvironmentService),
            __param(6, workspace_1.IWorkspaceContextService),
            __param(7, configuration_1.IConfigurationService)
        ], PreferencesContribution);
        return PreferencesContribution;
    }());
    exports.PreferencesContribution = PreferencesContribution;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[205/*vs/workbench/services/preferences/common/preferencesEditorInput*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/platform*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,66/*vs/editor/common/services/resolverService*/,2/*vs/nls*/,3/*vs/platform/instantiation/common/instantiation*/,13/*vs/workbench/common/editor*/,93/*vs/workbench/common/editor/resourceEditorInput*/,94/*vs/workbench/services/hash/common/hashService*/,199/*vs/workbench/services/preferences/common/keybindingsEditorModel*/,61/*vs/workbench/services/preferences/common/preferences*/]), function (require, exports, platform_1, uri_1, winjs_base_1, resolverService_1, nls, instantiation_1, editor_1, resourceEditorInput_1, hashService_1, keybindingsEditorModel_1, preferences_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PreferencesEditorInput = /** @class */ (function (_super) {
        __extends(PreferencesEditorInput, _super);
        function PreferencesEditorInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PreferencesEditorInput.prototype.getTypeId = function () {
            return PreferencesEditorInput.ID;
        };
        PreferencesEditorInput.prototype.getTitle = function (verbosity) {
            return this.master.getTitle(verbosity);
        };
        PreferencesEditorInput.ID = 'workbench.editorinputs.preferencesEditorInput';
        return PreferencesEditorInput;
    }(editor_1.SideBySideEditorInput));
    exports.PreferencesEditorInput = PreferencesEditorInput;
    var DefaultPreferencesEditorInput = /** @class */ (function (_super) {
        __extends(DefaultPreferencesEditorInput, _super);
        function DefaultPreferencesEditorInput(defaultSettingsResource, textModelResolverService, hashService) {
            return _super.call(this, nls.localize('settingsEditorName', "Default Settings"), '', defaultSettingsResource, textModelResolverService, hashService) || this;
        }
        DefaultPreferencesEditorInput.prototype.getTypeId = function () {
            return DefaultPreferencesEditorInput.ID;
        };
        DefaultPreferencesEditorInput.prototype.matches = function (other) {
            if (other instanceof DefaultPreferencesEditorInput) {
                return true;
            }
            if (!_super.prototype.matches.call(this, other)) {
                return false;
            }
            return true;
        };
        DefaultPreferencesEditorInput.ID = 'workbench.editorinputs.defaultpreferences';
        DefaultPreferencesEditorInput = __decorate([
            __param(1, resolverService_1.ITextModelService),
            __param(2, hashService_1.IHashService)
        ], DefaultPreferencesEditorInput);
        return DefaultPreferencesEditorInput;
    }(resourceEditorInput_1.ResourceEditorInput));
    exports.DefaultPreferencesEditorInput = DefaultPreferencesEditorInput;
    var KeybindingsEditorInput = /** @class */ (function (_super) {
        __extends(KeybindingsEditorInput, _super);
        function KeybindingsEditorInput(instantiationService) {
            var _this = _super.call(this) || this;
            _this.keybindingsModel = instantiationService.createInstance(keybindingsEditorModel_1.KeybindingsEditorModel, platform_1.OS);
            return _this;
        }
        KeybindingsEditorInput.prototype.getTypeId = function () {
            return KeybindingsEditorInput.ID;
        };
        KeybindingsEditorInput.prototype.getName = function () {
            return nls.localize('keybindingsInputName', "Keyboard Shortcuts");
        };
        KeybindingsEditorInput.prototype.resolve = function () {
            return winjs_base_1.TPromise.as(this.keybindingsModel);
        };
        KeybindingsEditorInput.prototype.matches = function (otherInput) {
            return otherInput instanceof KeybindingsEditorInput;
        };
        KeybindingsEditorInput.ID = 'workbench.input.keybindings';
        KeybindingsEditorInput = __decorate([
            __param(0, instantiation_1.IInstantiationService)
        ], KeybindingsEditorInput);
        return KeybindingsEditorInput;
    }(editor_1.EditorInput));
    exports.KeybindingsEditorInput = KeybindingsEditorInput;
    var SettingsEditor2Input = /** @class */ (function (_super) {
        __extends(SettingsEditor2Input, _super);
        function SettingsEditor2Input(_preferencesService) {
            var _this = _super.call(this) || this;
            _this._settingsModel = _preferencesService.createSettings2EditorModel();
            return _this;
        }
        SettingsEditor2Input.prototype.matches = function (otherInput) {
            return otherInput instanceof SettingsEditor2Input;
        };
        SettingsEditor2Input.prototype.getTypeId = function () {
            return SettingsEditor2Input.ID;
        };
        SettingsEditor2Input.prototype.getName = function () {
            return nls.localize('settingsEditor2InputName', "Settings");
        };
        SettingsEditor2Input.prototype.resolve = function () {
            return winjs_base_1.TPromise.as(this._settingsModel);
        };
        SettingsEditor2Input.prototype.getResource = function () {
            return uri_1.URI.from({
                scheme: 'vscode-settings',
                path: "settingseditor"
            });
        };
        SettingsEditor2Input.ID = 'workbench.input.settings2';
        SettingsEditor2Input = __decorate([
            __param(0, preferences_1.IPreferencesService)
        ], SettingsEditor2Input);
        return SettingsEditor2Input;
    }(editor_1.EditorInput));
    exports.SettingsEditor2Input = SettingsEditor2Input;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[162/*vs/workbench/services/preferences/common/preferencesModels*/], __M([0/*require*/,1/*exports*/,19/*vs/base/common/arrays*/,6/*vs/base/common/event*/,77/*vs/base/common/json*/,4/*vs/base/common/lifecycle*/,39/*vs/base/common/map*/,38/*vs/base/common/objects*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,90/*vs/platform/configuration/common/configurationRegistry*/,31/*vs/platform/keybinding/common/keybinding*/,9/*vs/platform/registry/common/platform*/,13/*vs/workbench/common/editor*/]), function (require, exports, arrays_1, event_1, json_1, lifecycle_1, map, objects_1, range_1, selection_1, nls, configuration_1, configurationRegistry_1, keybinding_1, platform_1, editor_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractSettingsModel = /** @class */ (function (_super) {
        __extends(AbstractSettingsModel, _super);
        function AbstractSettingsModel() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._currentResultGroups = new Map();
            return _this;
        }
        AbstractSettingsModel.prototype.updateResultGroup = function (id, resultGroup) {
            if (resultGroup) {
                this._currentResultGroups.set(id, resultGroup);
            }
            else {
                this._currentResultGroups.delete(id);
            }
            this.removeDuplicateResults();
            return this.update();
        };
        /**
         * Remove duplicates between result groups, preferring results in earlier groups
         */
        AbstractSettingsModel.prototype.removeDuplicateResults = function () {
            var _this = this;
            var settingKeys = new Set();
            map.keys(this._currentResultGroups)
                .sort(function (a, b) { return _this._currentResultGroups.get(a).order - _this._currentResultGroups.get(b).order; })
                .forEach(function (groupId) {
                var group = _this._currentResultGroups.get(groupId);
                group.result.filterMatches = group.result.filterMatches.filter(function (s) { return !settingKeys.has(s.setting.key); });
                group.result.filterMatches.forEach(function (s) { return settingKeys.add(s.setting.key); });
            });
        };
        AbstractSettingsModel.prototype.filterSettings = function (filter, groupFilter, settingMatcher) {
            var allGroups = this.filterGroups;
            var filterMatches = [];
            for (var _i = 0, allGroups_1 = allGroups; _i < allGroups_1.length; _i++) {
                var group = allGroups_1[_i];
                var groupMatched = groupFilter(group);
                for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                    var section = _b[_a];
                    for (var _c = 0, _d = section.settings; _c < _d.length; _c++) {
                        var setting = _d[_c];
                        var settingMatchResult = settingMatcher(setting, group);
                        if (groupMatched || settingMatchResult) {
                            filterMatches.push({
                                setting: setting,
                                matches: settingMatchResult && settingMatchResult.matches,
                                score: settingMatchResult ? settingMatchResult.score : 0
                            });
                        }
                    }
                }
            }
            return filterMatches.sort(function (a, b) { return b.score - a.score; });
        };
        AbstractSettingsModel.prototype.getPreference = function (key) {
            for (var _i = 0, _a = this.settingsGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                for (var _b = 0, _c = group.sections; _b < _c.length; _b++) {
                    var section = _c[_b];
                    for (var _d = 0, _e = section.settings; _d < _e.length; _d++) {
                        var setting = _e[_d];
                        if (key === setting.key) {
                            return setting;
                        }
                    }
                }
            }
            return null;
        };
        AbstractSettingsModel.prototype.collectMetadata = function (groups) {
            var metadata = Object.create(null);
            var hasMetadata = false;
            groups.forEach(function (g) {
                if (g.result.metadata) {
                    metadata[g.id] = g.result.metadata;
                    hasMetadata = true;
                }
            });
            return hasMetadata ? metadata : null;
        };
        Object.defineProperty(AbstractSettingsModel.prototype, "filterGroups", {
            get: function () {
                return this.settingsGroups;
            },
            enumerable: true,
            configurable: true
        });
        return AbstractSettingsModel;
    }(editor_1.EditorModel));
    exports.AbstractSettingsModel = AbstractSettingsModel;
    var SettingsEditorModel = /** @class */ (function (_super) {
        __extends(SettingsEditorModel, _super);
        function SettingsEditorModel(reference, _configurationTarget) {
            var _this = _super.call(this) || this;
            _this._configurationTarget = _configurationTarget;
            _this._onDidChangeGroups = _this._register(new event_1.Emitter());
            _this.onDidChangeGroups = _this._onDidChangeGroups.event;
            _this.settingsModel = reference.object.textEditorModel;
            _this._register(_this.onDispose(function () { return reference.dispose(); }));
            _this._register(_this.settingsModel.onDidChangeContent(function () {
                _this._settingsGroups = null;
                _this._onDidChangeGroups.fire();
            }));
            return _this;
        }
        Object.defineProperty(SettingsEditorModel.prototype, "uri", {
            get: function () {
                return this.settingsModel.uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsEditorModel.prototype, "configurationTarget", {
            get: function () {
                return this._configurationTarget;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsEditorModel.prototype, "settingsGroups", {
            get: function () {
                if (!this._settingsGroups) {
                    this.parse();
                }
                return this._settingsGroups;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsEditorModel.prototype, "content", {
            get: function () {
                return this.settingsModel.getValue();
            },
            enumerable: true,
            configurable: true
        });
        SettingsEditorModel.prototype.findValueMatches = function (filter, setting) {
            return this.settingsModel.findMatches(filter, setting.valueRange, false, false, null, false).map(function (match) { return match.range; });
        };
        SettingsEditorModel.prototype.isSettingsProperty = function (property, previousParents) {
            return previousParents.length === 0; // Settings is root
        };
        SettingsEditorModel.prototype.parse = function () {
            var _this = this;
            this._settingsGroups = parse(this.settingsModel, function (property, previousParents) { return _this.isSettingsProperty(property, previousParents); });
        };
        SettingsEditorModel.prototype.update = function () {
            var resultGroups = map.values(this._currentResultGroups);
            if (!resultGroups.length) {
                return null;
            }
            // Transform resultGroups into IFilterResult - ISetting ranges are already correct here
            var filteredSettings = [];
            var matches = [];
            resultGroups.forEach(function (group) {
                group.result.filterMatches.forEach(function (filterMatch) {
                    filteredSettings.push(filterMatch.setting);
                    matches.push.apply(matches, filterMatch.matches);
                });
            });
            var filteredGroup;
            var modelGroup = this.settingsGroups[0]; // Editable model has one or zero groups
            if (modelGroup) {
                filteredGroup = {
                    id: modelGroup.id,
                    range: modelGroup.range,
                    sections: [{
                            settings: filteredSettings
                        }],
                    title: modelGroup.title,
                    titleRange: modelGroup.titleRange,
                    contributedByExtension: !!modelGroup.contributedByExtension
                };
            }
            var metadata = this.collectMetadata(resultGroups);
            return {
                allGroups: this.settingsGroups,
                filteredGroups: filteredGroup ? [filteredGroup] : [],
                matches: matches,
                metadata: metadata
            };
        };
        return SettingsEditorModel;
    }(AbstractSettingsModel));
    exports.SettingsEditorModel = SettingsEditorModel;
    var Settings2EditorModel = /** @class */ (function (_super) {
        __extends(Settings2EditorModel, _super);
        function Settings2EditorModel(_defaultSettings, configurationService) {
            var _this = _super.call(this) || this;
            _this._defaultSettings = _defaultSettings;
            _this._onDidChangeGroups = _this._register(new event_1.Emitter());
            _this.onDidChangeGroups = _this._onDidChangeGroups.event;
            _this.dirty = false;
            configurationService.onDidChangeConfiguration(function (e) {
                if (e.source === 4 /* DEFAULT */) {
                    _this.dirty = true;
                    _this._onDidChangeGroups.fire();
                }
            });
            return _this;
        }
        Object.defineProperty(Settings2EditorModel.prototype, "filterGroups", {
            get: function () {
                // Don't filter "commonly used"
                return this.settingsGroups.slice(1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Settings2EditorModel.prototype, "settingsGroups", {
            get: function () {
                var groups = this._defaultSettings.getSettingsGroups(this.dirty);
                this.dirty = false;
                return groups;
            },
            enumerable: true,
            configurable: true
        });
        Settings2EditorModel.prototype.findValueMatches = function (filter, setting) {
            // TODO @roblou
            return [];
        };
        Settings2EditorModel.prototype.update = function () {
            throw new Error('Not supported');
        };
        Settings2EditorModel = __decorate([
            __param(1, configuration_1.IConfigurationService)
        ], Settings2EditorModel);
        return Settings2EditorModel;
    }(AbstractSettingsModel));
    exports.Settings2EditorModel = Settings2EditorModel;
    function parse(model, isSettingsProperty) {
        var settings = [];
        var overrideSetting = null;
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        var settingsPropertyIndex = -1;
        var range = {
            startLineNumber: 0,
            startColumn: 0,
            endLineNumber: 0,
            endColumn: 0
        };
        function onValue(value, offset, length) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
            if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {
                // settings value started
                var setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];
                if (setting) {
                    var valueStartPosition = model.getPositionAt(offset);
                    var valueEndPosition = model.getPositionAt(offset + length);
                    setting.value = value;
                    setting.valueRange = {
                        startLineNumber: valueStartPosition.lineNumber,
                        startColumn: valueStartPosition.column,
                        endLineNumber: valueEndPosition.lineNumber,
                        endColumn: valueEndPosition.column
                    };
                    setting.range = objects_1.assign(setting.range, {
                        endLineNumber: valueEndPosition.lineNumber,
                        endColumn: valueEndPosition.column
                    });
                }
            }
        }
        var visitor = {
            onObjectBegin: function (offset, length) {
                if (isSettingsProperty(currentProperty, previousParents)) {
                    // Settings started
                    settingsPropertyIndex = previousParents.length;
                    var position = model.getPositionAt(offset);
                    range.startLineNumber = position.lineNumber;
                    range.startColumn = position.column;
                }
                var object = {};
                onValue(object, offset, length);
                currentParent = object;
                currentProperty = null;
                previousParents.push(currentParent);
            },
            onObjectProperty: function (name, offset, length) {
                currentProperty = name;
                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {
                    // setting started
                    var settingStartPosition = model.getPositionAt(offset);
                    var setting = {
                        description: [],
                        descriptionIsMarkdown: false,
                        key: name,
                        keyRange: {
                            startLineNumber: settingStartPosition.lineNumber,
                            startColumn: settingStartPosition.column + 1,
                            endLineNumber: settingStartPosition.lineNumber,
                            endColumn: settingStartPosition.column + length
                        },
                        range: {
                            startLineNumber: settingStartPosition.lineNumber,
                            startColumn: settingStartPosition.column,
                            endLineNumber: 0,
                            endColumn: 0
                        },
                        value: null,
                        valueRange: null,
                        descriptionRanges: null,
                        overrides: [],
                        overrideOf: overrideSetting
                    };
                    if (previousParents.length === settingsPropertyIndex + 1) {
                        settings.push(setting);
                        if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(name)) {
                            overrideSetting = setting;
                        }
                    }
                    else {
                        overrideSetting.overrides.push(setting);
                    }
                }
            },
            onObjectEnd: function (offset, length) {
                currentParent = previousParents.pop();
                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {
                    // setting ended
                    var setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];
                    if (setting) {
                        var valueEndPosition = model.getPositionAt(offset + length);
                        setting.valueRange = objects_1.assign(setting.valueRange, {
                            endLineNumber: valueEndPosition.lineNumber,
                            endColumn: valueEndPosition.column
                        });
                        setting.range = objects_1.assign(setting.range, {
                            endLineNumber: valueEndPosition.lineNumber,
                            endColumn: valueEndPosition.column
                        });
                    }
                    if (previousParents.length === settingsPropertyIndex + 1) {
                        overrideSetting = null;
                    }
                }
                if (previousParents.length === settingsPropertyIndex) {
                    // settings ended
                    var position = model.getPositionAt(offset);
                    range.endLineNumber = position.lineNumber;
                    range.endColumn = position.column;
                }
            },
            onArrayBegin: function (offset, length) {
                var array = [];
                onValue(array, offset, length);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function (offset, length) {
                currentParent = previousParents.pop();
                if (previousParents.length === settingsPropertyIndex + 1 || (previousParents.length === settingsPropertyIndex + 2 && overrideSetting !== null)) {
                    // setting value ended
                    var setting = previousParents.length === settingsPropertyIndex + 1 ? settings[settings.length - 1] : overrideSetting.overrides[overrideSetting.overrides.length - 1];
                    if (setting) {
                        var valueEndPosition = model.getPositionAt(offset + length);
                        setting.valueRange = objects_1.assign(setting.valueRange, {
                            endLineNumber: valueEndPosition.lineNumber,
                            endColumn: valueEndPosition.column
                        });
                        setting.range = objects_1.assign(setting.range, {
                            endLineNumber: valueEndPosition.lineNumber,
                            endColumn: valueEndPosition.column
                        });
                    }
                }
            },
            onLiteralValue: onValue,
            onError: function (error) {
                var setting = settings[settings.length - 1];
                if (setting && (!setting.range || !setting.keyRange || !setting.valueRange)) {
                    settings.pop();
                }
            }
        };
        if (!model.isDisposed()) {
            json_1.visit(model.getValue(), visitor);
        }
        return settings.length > 0 ? [{
                sections: [
                    {
                        settings: settings
                    }
                ],
                title: null,
                titleRange: null,
                range: range
            }] : [];
    }
    var WorkspaceConfigurationEditorModel = /** @class */ (function (_super) {
        __extends(WorkspaceConfigurationEditorModel, _super);
        function WorkspaceConfigurationEditorModel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(WorkspaceConfigurationEditorModel.prototype, "configurationGroups", {
            get: function () {
                return this._configurationGroups;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceConfigurationEditorModel.prototype.parse = function () {
            _super.prototype.parse.call(this);
            this._configurationGroups = parse(this.settingsModel, function (property, previousParents) { return previousParents.length === 0; });
        };
        WorkspaceConfigurationEditorModel.prototype.isSettingsProperty = function (property, previousParents) {
            return property === 'settings' && previousParents.length === 1;
        };
        return WorkspaceConfigurationEditorModel;
    }(SettingsEditorModel));
    exports.WorkspaceConfigurationEditorModel = WorkspaceConfigurationEditorModel;
    var DefaultSettings = /** @class */ (function (_super) {
        __extends(DefaultSettings, _super);
        function DefaultSettings(_mostCommonlyUsedSettingsKeys, target) {
            var _this = _super.call(this) || this;
            _this._mostCommonlyUsedSettingsKeys = _mostCommonlyUsedSettingsKeys;
            _this.target = target;
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            return _this;
        }
        DefaultSettings.prototype.getContent = function (forceUpdate) {
            if (forceUpdate === void 0) { forceUpdate = false; }
            if (!this._content || forceUpdate) {
                this._content = this.toContent(true, this.getSettingsGroups(forceUpdate));
            }
            return this._content;
        };
        DefaultSettings.prototype.getSettingsGroups = function (forceUpdate) {
            if (forceUpdate === void 0) { forceUpdate = false; }
            if (!this._allSettingsGroups || forceUpdate) {
                this._allSettingsGroups = this.parse();
            }
            return this._allSettingsGroups;
        };
        DefaultSettings.prototype.parse = function () {
            var settingsGroups = this.getRegisteredGroups();
            this.initAllSettingsMap(settingsGroups);
            var mostCommonlyUsed = this.getMostCommonlyUsedSettings(settingsGroups);
            return [mostCommonlyUsed].concat(settingsGroups);
        };
        Object.defineProperty(DefaultSettings.prototype, "raw", {
            get: function () {
                if (!DefaultSettings._RAW) {
                    DefaultSettings._RAW = this.toContent(false, this.getRegisteredGroups());
                }
                return DefaultSettings._RAW;
            },
            enumerable: true,
            configurable: true
        });
        DefaultSettings.prototype.getRegisteredGroups = function () {
            var _this = this;
            var configurations = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurations().slice();
            var groups = this.removeEmptySettingsGroups(configurations.sort(this.compareConfigurationNodes)
                .reduce(function (result, config, index, array) { return _this.parseConfig(config, result, array); }, []));
            return this.sortGroups(groups);
        };
        DefaultSettings.prototype.sortGroups = function (groups) {
            groups.forEach(function (group) {
                group.sections.forEach(function (section) {
                    section.settings.sort(function (a, b) { return a.key.localeCompare(b.key); });
                });
            });
            return groups;
        };
        DefaultSettings.prototype.initAllSettingsMap = function (allSettingsGroups) {
            this._settingsByName = new Map();
            for (var _i = 0, allSettingsGroups_1 = allSettingsGroups; _i < allSettingsGroups_1.length; _i++) {
                var group = allSettingsGroups_1[_i];
                for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                    var section = _b[_a];
                    for (var _c = 0, _d = section.settings; _c < _d.length; _c++) {
                        var setting = _d[_c];
                        this._settingsByName.set(setting.key, setting);
                    }
                }
            }
        };
        DefaultSettings.prototype.getMostCommonlyUsedSettings = function (allSettingsGroups) {
            var _this = this;
            var settings = this._mostCommonlyUsedSettingsKeys.map(function (key) {
                var setting = _this._settingsByName.get(key);
                if (setting) {
                    return {
                        description: setting.description,
                        key: setting.key,
                        value: setting.value,
                        range: null,
                        valueRange: null,
                        overrides: [],
                        scope: 3 /* RESOURCE */,
                        type: setting.type,
                        enum: setting.enum,
                        enumDescriptions: setting.enumDescriptions
                    };
                }
                return null;
            }).filter(function (setting) { return !!setting; });
            return {
                id: 'mostCommonlyUsed',
                range: null,
                title: nls.localize('commonlyUsed', "Commonly Used"),
                titleRange: null,
                sections: [
                    {
                        settings: settings
                    }
                ]
            };
        };
        DefaultSettings.prototype.parseConfig = function (config, result, configurations, settingsGroup, seenSettings) {
            var _this = this;
            seenSettings = seenSettings ? seenSettings : {};
            var title = config.title;
            if (!title) {
                var configWithTitleAndSameId = arrays_1.find(configurations, function (c) { return (c.id === config.id) && c.title; });
                if (configWithTitleAndSameId) {
                    title = configWithTitleAndSameId.title;
                }
            }
            if (title) {
                if (!settingsGroup) {
                    settingsGroup = arrays_1.find(result, function (g) { return g.title === title; });
                    if (!settingsGroup) {
                        settingsGroup = { sections: [{ settings: [] }], id: config.id, title: title, titleRange: null, range: null, contributedByExtension: !!config.contributedByExtension };
                        result.push(settingsGroup);
                    }
                }
                else {
                    settingsGroup.sections[settingsGroup.sections.length - 1].title = title;
                }
            }
            if (config.properties) {
                if (!settingsGroup) {
                    settingsGroup = { sections: [{ settings: [] }], id: config.id, title: config.id, titleRange: null, range: null, contributedByExtension: !!config.contributedByExtension };
                    result.push(settingsGroup);
                }
                var configurationSettings = [];
                for (var _i = 0, _a = settingsGroup.sections[settingsGroup.sections.length - 1].settings.concat(this.parseSettings(config.properties)); _i < _a.length; _i++) {
                    var setting = _a[_i];
                    if (!seenSettings[setting.key]) {
                        configurationSettings.push(setting);
                        seenSettings[setting.key] = true;
                    }
                }
                if (configurationSettings.length) {
                    settingsGroup.sections[settingsGroup.sections.length - 1].settings = configurationSettings;
                }
            }
            if (config.allOf) {
                config.allOf.forEach(function (c) { return _this.parseConfig(c, result, configurations, settingsGroup, seenSettings); });
            }
            return result;
        };
        DefaultSettings.prototype.removeEmptySettingsGroups = function (settingsGroups) {
            var result = [];
            for (var _i = 0, settingsGroups_1 = settingsGroups; _i < settingsGroups_1.length; _i++) {
                var settingsGroup = settingsGroups_1[_i];
                settingsGroup.sections = settingsGroup.sections.filter(function (section) { return section.settings.length > 0; });
                if (settingsGroup.sections.length) {
                    result.push(settingsGroup);
                }
            }
            return result;
        };
        DefaultSettings.prototype.parseSettings = function (settingsObject) {
            var result = [];
            for (var key in settingsObject) {
                var prop = settingsObject[key];
                if (this.matchesScope(prop)) {
                    var value = prop.default;
                    var description = (prop.description || prop.markdownDescription || '').split('\n');
                    var overrides = configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) ? this.parseOverrideSettings(prop.default) : [];
                    result.push({
                        key: key,
                        value: value,
                        description: description,
                        descriptionIsMarkdown: !prop.description,
                        range: null,
                        keyRange: null,
                        valueRange: null,
                        descriptionRanges: [],
                        overrides: overrides,
                        scope: prop.scope,
                        type: prop.type,
                        enum: prop.enum,
                        enumDescriptions: prop.enumDescriptions || prop.markdownEnumDescriptions,
                        enumDescriptionsAreMarkdown: !prop.enumDescriptions,
                        tags: prop.tags,
                        deprecationMessage: prop.deprecationMessage,
                        validator: createValidator(prop)
                    });
                }
            }
            return result;
        };
        DefaultSettings.prototype.parseOverrideSettings = function (overrideSettings) {
            return Object.keys(overrideSettings).map(function (key) { return ({
                key: key,
                value: overrideSettings[key],
                description: [],
                descriptionIsMarkdown: false,
                range: null,
                keyRange: null,
                valueRange: null,
                descriptionRanges: [],
                overrides: []
            }); });
        };
        DefaultSettings.prototype.matchesScope = function (property) {
            if (this.target === 3 /* WORKSPACE_FOLDER */) {
                return property.scope === 3 /* RESOURCE */;
            }
            if (this.target === 2 /* WORKSPACE */) {
                return property.scope === 2 /* WINDOW */ || property.scope === 3 /* RESOURCE */;
            }
            return true;
        };
        DefaultSettings.prototype.compareConfigurationNodes = function (c1, c2) {
            if (typeof c1.order !== 'number') {
                return 1;
            }
            if (typeof c2.order !== 'number') {
                return -1;
            }
            if (c1.order === c2.order) {
                var title1 = c1.title || '';
                var title2 = c2.title || '';
                return title1.localeCompare(title2);
            }
            return c1.order - c2.order;
        };
        DefaultSettings.prototype.toContent = function (asArray, settingsGroups) {
            var builder = new SettingsContentBuilder();
            if (asArray) {
                builder.pushLine('[');
            }
            settingsGroups.forEach(function (settingsGroup, i) {
                builder.pushGroup(settingsGroup);
                builder.pushLine(',');
            });
            if (asArray) {
                builder.pushLine(']');
            }
            return builder.getContent();
        };
        return DefaultSettings;
    }(lifecycle_1.Disposable));
    exports.DefaultSettings = DefaultSettings;
    var DefaultSettingsEditorModel = /** @class */ (function (_super) {
        __extends(DefaultSettingsEditorModel, _super);
        function DefaultSettingsEditorModel(_uri, reference, defaultSettings) {
            var _this = _super.call(this) || this;
            _this._uri = _uri;
            _this.defaultSettings = defaultSettings;
            _this._onDidChangeGroups = _this._register(new event_1.Emitter());
            _this.onDidChangeGroups = _this._onDidChangeGroups.event;
            _this._register(defaultSettings.onDidChange(function () { return _this._onDidChangeGroups.fire(); }));
            _this._model = reference.object.textEditorModel;
            _this._register(_this.onDispose(function () { return reference.dispose(); }));
            return _this;
        }
        Object.defineProperty(DefaultSettingsEditorModel.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultSettingsEditorModel.prototype, "target", {
            get: function () {
                return this.defaultSettings.target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultSettingsEditorModel.prototype, "settingsGroups", {
            get: function () {
                return this.defaultSettings.getSettingsGroups();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultSettingsEditorModel.prototype, "filterGroups", {
            get: function () {
                // Don't look at "commonly used" for filter
                return this.settingsGroups.slice(1);
            },
            enumerable: true,
            configurable: true
        });
        DefaultSettingsEditorModel.prototype.update = function () {
            // Grab current result groups, only render non-empty groups
            var resultGroups = map
                .values(this._currentResultGroups)
                .sort(function (a, b) { return a.order - b.order; });
            var nonEmptyResultGroups = resultGroups.filter(function (group) { return group.result.filterMatches.length; });
            var startLine = arrays_1.tail(this.settingsGroups).range.endLineNumber + 2;
            var _a = this.writeResultGroups(nonEmptyResultGroups, startLine), filteredGroups = _a.settingsGroups, matches = _a.matches;
            var metadata = this.collectMetadata(resultGroups);
            return resultGroups.length ?
                {
                    allGroups: this.settingsGroups,
                    filteredGroups: filteredGroups,
                    matches: matches,
                    metadata: metadata
                } :
                null;
        };
        /**
         * Translate the ISearchResultGroups to text, and write it to the editor model
         */
        DefaultSettingsEditorModel.prototype.writeResultGroups = function (groups, startLine) {
            var _this = this;
            var contentBuilderOffset = startLine - 1;
            var builder = new SettingsContentBuilder(contentBuilderOffset);
            var settingsGroups = [];
            var matches = [];
            builder.pushLine(',');
            groups.forEach(function (resultGroup) {
                var settingsGroup = _this.getGroup(resultGroup);
                settingsGroups.push(settingsGroup);
                matches.push.apply(matches, _this.writeSettingsGroupToBuilder(builder, settingsGroup, resultGroup.result.filterMatches));
            });
            // note: 1-indexed line numbers here
            var groupContent = builder.getContent() + '\n';
            var groupEndLine = this._model.getLineCount();
            var cursorPosition = new selection_1.Selection(startLine, 1, startLine, 1);
            var edit = {
                text: groupContent,
                forceMoveMarkers: true,
                range: new range_1.Range(startLine, 1, groupEndLine, 1),
                identifier: { major: 1, minor: 0 }
            };
            this._model.pushEditOperations([cursorPosition], [edit], function () { return [cursorPosition]; });
            // Force tokenization now - otherwise it may be slightly delayed, causing a flash of white text
            var tokenizeTo = Math.min(startLine + 60, this._model.getLineCount());
            this._model.forceTokenization(tokenizeTo);
            return { matches: matches, settingsGroups: settingsGroups };
        };
        DefaultSettingsEditorModel.prototype.writeSettingsGroupToBuilder = function (builder, settingsGroup, filterMatches) {
            filterMatches = filterMatches
                .map(function (filteredMatch) {
                // Fix match ranges to offset from setting start line
                return {
                    setting: filteredMatch.setting,
                    score: filteredMatch.score,
                    matches: filteredMatch.matches && filteredMatch.matches.map(function (match) {
                        return new range_1.Range(match.startLineNumber - filteredMatch.setting.range.startLineNumber, match.startColumn, match.endLineNumber - filteredMatch.setting.range.startLineNumber, match.endColumn);
                    })
                };
            });
            builder.pushGroup(settingsGroup);
            builder.pushLine(',');
            // builder has rewritten settings ranges, fix match ranges
            var fixedMatches = arrays_1.flatten(filterMatches
                .map(function (m) { return m.matches || []; })
                .map(function (settingMatches, i) {
                var setting = settingsGroup.sections[0].settings[i];
                return settingMatches.map(function (range) {
                    return new range_1.Range(range.startLineNumber + setting.range.startLineNumber, range.startColumn, range.endLineNumber + setting.range.startLineNumber, range.endColumn);
                });
            }));
            return fixedMatches;
        };
        DefaultSettingsEditorModel.prototype.copySetting = function (setting) {
            return {
                description: setting.description,
                scope: setting.scope,
                type: setting.type,
                enum: setting.enum,
                enumDescriptions: setting.enumDescriptions,
                key: setting.key,
                value: setting.value,
                range: setting.range,
                overrides: [],
                overrideOf: setting.overrideOf,
                tags: setting.tags,
                deprecationMessage: setting.deprecationMessage,
                keyRange: undefined,
                valueRange: undefined,
                descriptionIsMarkdown: undefined,
                descriptionRanges: undefined
            };
        };
        DefaultSettingsEditorModel.prototype.findValueMatches = function (filter, setting) {
            return [];
        };
        DefaultSettingsEditorModel.prototype.getPreference = function (key) {
            for (var _i = 0, _a = this.settingsGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                for (var _b = 0, _c = group.sections; _b < _c.length; _b++) {
                    var section = _c[_b];
                    for (var _d = 0, _e = section.settings; _d < _e.length; _d++) {
                        var setting = _e[_d];
                        if (setting.key === key) {
                            return setting;
                        }
                    }
                }
            }
            return null;
        };
        DefaultSettingsEditorModel.prototype.getGroup = function (resultGroup) {
            var _this = this;
            return {
                id: resultGroup.id,
                range: null,
                title: resultGroup.label,
                titleRange: null,
                sections: [
                    {
                        settings: resultGroup.result.filterMatches.map(function (m) { return _this.copySetting(m.setting); })
                    }
                ]
            };
        };
        return DefaultSettingsEditorModel;
    }(AbstractSettingsModel));
    exports.DefaultSettingsEditorModel = DefaultSettingsEditorModel;
    var SettingsContentBuilder = /** @class */ (function () {
        function SettingsContentBuilder(_rangeOffset) {
            if (_rangeOffset === void 0) { _rangeOffset = 0; }
            this._rangeOffset = _rangeOffset;
            this._contentByLines = [];
        }
        Object.defineProperty(SettingsContentBuilder.prototype, "lineCountWithOffset", {
            get: function () {
                return this._contentByLines.length + this._rangeOffset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsContentBuilder.prototype, "lastLine", {
            get: function () {
                return this._contentByLines[this._contentByLines.length - 1] || '';
            },
            enumerable: true,
            configurable: true
        });
        SettingsContentBuilder.prototype.offsetIndexToIndex = function (offsetIdx) {
            return offsetIdx - this._rangeOffset;
        };
        SettingsContentBuilder.prototype.pushLine = function () {
            var lineText = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                lineText[_i] = arguments[_i];
            }
            var _a;
            (_a = this._contentByLines).push.apply(_a, lineText);
        };
        SettingsContentBuilder.prototype.pushGroup = function (settingsGroups) {
            this._contentByLines.push('{');
            this._contentByLines.push('');
            this._contentByLines.push('');
            var lastSetting = this._pushGroup(settingsGroups);
            if (lastSetting) {
                // Strip the comma from the last setting
                var lineIdx = this.offsetIndexToIndex(lastSetting.range.endLineNumber);
                var content = this._contentByLines[lineIdx - 2];
                this._contentByLines[lineIdx - 2] = content.substring(0, content.length - 1);
            }
            this._contentByLines.push('}');
        };
        SettingsContentBuilder.prototype._pushGroup = function (group) {
            var indent = '  ';
            var lastSetting = null;
            var groupStart = this.lineCountWithOffset + 1;
            for (var _i = 0, _a = group.sections; _i < _a.length; _i++) {
                var section = _a[_i];
                if (section.title) {
                    var sectionTitleStart = this.lineCountWithOffset + 1;
                    this.addDescription([section.title], indent, this._contentByLines);
                    section.titleRange = { startLineNumber: sectionTitleStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };
                }
                if (section.settings.length) {
                    for (var _b = 0, _c = section.settings; _b < _c.length; _b++) {
                        var setting = _c[_b];
                        this.pushSetting(setting, indent);
                        lastSetting = setting;
                    }
                }
            }
            group.range = { startLineNumber: groupStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };
            return lastSetting;
        };
        SettingsContentBuilder.prototype.getContent = function () {
            return this._contentByLines.join('\n');
        };
        SettingsContentBuilder.prototype.pushSetting = function (setting, indent) {
            var settingStart = this.lineCountWithOffset + 1;
            this.pushSettingDescription(setting, indent);
            var preValueContent = indent;
            var keyString = JSON.stringify(setting.key);
            preValueContent += keyString;
            setting.keyRange = { startLineNumber: this.lineCountWithOffset + 1, startColumn: preValueContent.indexOf(setting.key) + 1, endLineNumber: this.lineCountWithOffset + 1, endColumn: setting.key.length };
            preValueContent += ': ';
            var valueStart = this.lineCountWithOffset + 1;
            this.pushValue(setting, preValueContent, indent);
            setting.valueRange = { startLineNumber: valueStart, startColumn: preValueContent.length + 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length + 1 };
            this._contentByLines[this._contentByLines.length - 1] += ',';
            this._contentByLines.push('');
            setting.range = { startLineNumber: settingStart, startColumn: 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length };
        };
        SettingsContentBuilder.prototype.pushSettingDescription = function (setting, indent) {
            var _this = this;
            var fixSettingLink = function (line) { return line.replace(/`#(.*)#`/g, function (match, settingName) { return "`" + settingName + "`"; }); };
            setting.descriptionRanges = [];
            var descriptionPreValue = indent + '// ';
            for (var _i = 0, _a = (setting.deprecationMessage ? [setting.deprecationMessage].concat(setting.description) : setting.description); _i < _a.length; _i++) {
                var line = _a[_i];
                line = fixSettingLink(line);
                this._contentByLines.push(descriptionPreValue + line);
                setting.descriptionRanges.push({ startLineNumber: this.lineCountWithOffset, startColumn: this.lastLine.indexOf(line) + 1, endLineNumber: this.lineCountWithOffset, endColumn: this.lastLine.length });
            }
            if (setting.enumDescriptions && setting.enumDescriptions.some(function (desc) { return !!desc; })) {
                setting.enumDescriptions.forEach(function (desc, i) {
                    var displayEnum = escapeInvisibleChars(String(setting.enum[i]));
                    var line = desc ?
                        displayEnum + ": " + fixSettingLink(desc) :
                        displayEnum;
                    _this._contentByLines.push("  //  - " + line);
                    setting.descriptionRanges.push({ startLineNumber: _this.lineCountWithOffset, startColumn: _this.lastLine.indexOf(line) + 1, endLineNumber: _this.lineCountWithOffset, endColumn: _this.lastLine.length });
                });
            }
        };
        SettingsContentBuilder.prototype.pushValue = function (setting, preValueConent, indent) {
            var valueString = JSON.stringify(setting.value, null, indent);
            if (valueString && (typeof setting.value === 'object')) {
                if (setting.overrides.length) {
                    this._contentByLines.push(preValueConent + ' {');
                    for (var _i = 0, _a = setting.overrides; _i < _a.length; _i++) {
                        var subSetting = _a[_i];
                        this.pushSetting(subSetting, indent + indent);
                        this._contentByLines.pop();
                    }
                    var lastSetting = setting.overrides[setting.overrides.length - 1];
                    var content = this._contentByLines[lastSetting.range.endLineNumber - 2];
                    this._contentByLines[lastSetting.range.endLineNumber - 2] = content.substring(0, content.length - 1);
                    this._contentByLines.push(indent + '}');
                }
                else {
                    var mulitLineValue = valueString.split('\n');
                    this._contentByLines.push(preValueConent + mulitLineValue[0]);
                    for (var i = 1; i < mulitLineValue.length; i++) {
                        this._contentByLines.push(indent + mulitLineValue[i]);
                    }
                }
            }
            else {
                this._contentByLines.push(preValueConent + valueString);
            }
        };
        SettingsContentBuilder.prototype.addDescription = function (description, indent, result) {
            for (var _i = 0, description_1 = description; _i < description_1.length; _i++) {
                var line = description_1[_i];
                result.push(indent + '// ' + line);
            }
        };
        return SettingsContentBuilder;
    }());
    function createValidator(prop) {
        return function (value) {
            var exclusiveMax;
            var exclusiveMin;
            if (typeof prop.exclusiveMaximum === 'boolean') {
                exclusiveMax = prop.exclusiveMaximum ? prop.maximum : undefined;
            }
            else {
                exclusiveMax = prop.exclusiveMaximum;
            }
            if (typeof prop.exclusiveMinimum === 'boolean') {
                exclusiveMin = prop.exclusiveMinimum ? prop.minimum : undefined;
            }
            else {
                exclusiveMin = prop.exclusiveMinimum;
            }
            var patternRegex;
            if (typeof prop.pattern === 'string') {
                patternRegex = new RegExp(prop.pattern);
            }
            var type = Array.isArray(prop.type) ? prop.type : [prop.type];
            var canBeType = function (t) { return type.indexOf(t) > -1; };
            var isNullable = canBeType('null');
            var isNumeric = (canBeType('number') || canBeType('integer')) && (type.length === 1 || type.length === 2 && isNullable);
            var isIntegral = (canBeType('integer')) && (type.length === 1 || type.length === 2 && isNullable);
            var numericValidations = isNumeric ? [
                {
                    enabled: exclusiveMax !== undefined && (prop.maximum === undefined || exclusiveMax <= prop.maximum),
                    isValid: (function (value) { return value < exclusiveMax; }),
                    message: nls.localize('validations.exclusiveMax', "Value must be strictly less than {0}.", exclusiveMax)
                },
                {
                    enabled: exclusiveMin !== undefined && (prop.minimum === undefined || exclusiveMin >= prop.minimum),
                    isValid: (function (value) { return value > exclusiveMin; }),
                    message: nls.localize('validations.exclusiveMin', "Value must be strictly greater than {0}.", exclusiveMin)
                },
                {
                    enabled: prop.maximum !== undefined && (exclusiveMax === undefined || exclusiveMax > prop.maximum),
                    isValid: (function (value) { return value <= prop.maximum; }),
                    message: nls.localize('validations.max', "Value must be less than or equal to {0}.", prop.maximum)
                },
                {
                    enabled: prop.minimum !== undefined && (exclusiveMin === undefined || exclusiveMin < prop.minimum),
                    isValid: (function (value) { return value >= prop.minimum; }),
                    message: nls.localize('validations.min', "Value must be greater than or equal to {0}.", prop.minimum)
                },
                {
                    enabled: prop.multipleOf !== undefined,
                    isValid: (function (value) { return value % prop.multipleOf === 0; }),
                    message: nls.localize('validations.multipleOf', "Value must be a multiple of {0}.", prop.multipleOf)
                },
                {
                    enabled: isIntegral,
                    isValid: (function (value) { return value % 1 === 0; }),
                    message: nls.localize('validations.expectedInteger', "Value must be an integer.")
                },
            ].filter(function (validation) { return validation.enabled; }) : [];
            var stringValidations = [
                {
                    enabled: prop.maxLength !== undefined,
                    isValid: (function (value) { return value.length <= prop.maxLength; }),
                    message: nls.localize('validations.maxLength', "Value must be fewer than {0} characters long.", prop.maxLength)
                },
                {
                    enabled: prop.minLength !== undefined,
                    isValid: (function (value) { return value.length >= prop.minLength; }),
                    message: nls.localize('validations.minLength', "Value must be more than {0} characters long.", prop.minLength)
                },
                {
                    enabled: patternRegex !== undefined,
                    isValid: (function (value) { return patternRegex.test(value); }),
                    message: prop.patternErrorMessage || nls.localize('validations.regex', "Value must match regex `{0}`.", prop.pattern)
                },
            ].filter(function (validation) { return validation.enabled; });
            if (prop.type === 'string' && stringValidations.length === 0) {
                return null;
            }
            if (isNullable && value === '') {
                return '';
            }
            var errors = [];
            if (isNumeric) {
                if (value === '' || isNaN(+value)) {
                    errors.push(nls.localize('validations.expectedNumeric', "Value must be a number."));
                }
                else {
                    errors.push.apply(errors, numericValidations.filter(function (validator) { return !validator.isValid(+value); }).map(function (validator) { return validator.message; }));
                }
            }
            if (prop.type === 'string') {
                errors.push.apply(errors, stringValidations.filter(function (validator) { return !validator.isValid('' + value); }).map(function (validator) { return validator.message; }));
            }
            if (errors.length) {
                return prop.errorMessage ? [prop.errorMessage].concat(errors).join(' ') : errors.join(' ');
            }
            return '';
        };
    }
    exports.createValidator = createValidator;
    function escapeInvisibleChars(enumValue) {
        return enumValue && enumValue
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r');
    }
    function defaultKeybindingsContents(keybindingService) {
        var defaultsHeader = '// ' + nls.localize('defaultKeybindingsHeader', "Overwrite key bindings by placing them into your key bindings file.");
        return defaultsHeader + '\n' + keybindingService.getDefaultKeybindingsContent();
    }
    exports.defaultKeybindingsContents = defaultKeybindingsContents;
    var DefaultKeybindingsEditorModel = /** @class */ (function () {
        function DefaultKeybindingsEditorModel(_uri, keybindingService) {
            this._uri = _uri;
            this.keybindingService = keybindingService;
        }
        Object.defineProperty(DefaultKeybindingsEditorModel.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultKeybindingsEditorModel.prototype, "content", {
            get: function () {
                if (!this._content) {
                    this._content = defaultKeybindingsContents(this.keybindingService);
                }
                return this._content;
            },
            enumerable: true,
            configurable: true
        });
        DefaultKeybindingsEditorModel.prototype.getPreference = function () {
            return null;
        };
        DefaultKeybindingsEditorModel.prototype.dispose = function () {
            // Not disposable
        };
        DefaultKeybindingsEditorModel = __decorate([
            __param(1, keybinding_1.IKeybindingService)
        ], DefaultKeybindingsEditorModel);
        return DefaultKeybindingsEditorModel;
    }());
    exports.DefaultKeybindingsEditorModel = DefaultKeybindingsEditorModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[360/*vs/workbench/parts/preferences/browser/preferencesRenderers*/], __M([0/*require*/,1/*exports*/,286/*vs/base/browser/contextmenu*/,8/*vs/base/browser/dom*/,17/*vs/base/common/async*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,5/*vs/base/common/winjs.base*/,45/*vs/editor/browser/editorBrowser*/,135/*vs/editor/common/core/position*/,48/*vs/editor/common/core/range*/,72/*vs/editor/common/model*/,73/*vs/editor/common/model/textModel*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,90/*vs/platform/configuration/common/configurationRegistry*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,9/*vs/platform/registry/common/platform*/,32/*vs/platform/telemetry/common/telemetry*/,20/*vs/platform/workspace/common/workspace*/,283/*vs/workbench/browser/parts/editor/rangeDecorations*/,144/*vs/workbench/parts/preferences/browser/preferencesWidgets*/,61/*vs/workbench/services/preferences/common/preferences*/,162/*vs/workbench/services/preferences/common/preferencesModels*/]), function (require, exports, contextmenu_1, dom_1, async_1, event_1, lifecycle_1, winjs_base_1, editorBrowser_1, position_1, range_1, model_1, textModel_1, nls, configuration_1, configurationRegistry_1, contextView_1, instantiation_1, platform_1, telemetry_1, workspace_1, rangeDecorations_1, preferencesWidgets_1, preferences_1, preferencesModels_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UserSettingsRenderer = /** @class */ (function (_super) {
        __extends(UserSettingsRenderer, _super);
        function UserSettingsRenderer(editor, preferencesModel, preferencesService, configurationService, instantiationService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.preferencesModel = preferencesModel;
            _this.preferencesService = preferencesService;
            _this.configurationService = configurationService;
            _this.instantiationService = instantiationService;
            _this.modelChangeDelayer = new async_1.Delayer(200);
            _this._onFocusPreference = new event_1.Emitter();
            _this.onFocusPreference = _this._onFocusPreference.event;
            _this._onClearFocusPreference = new event_1.Emitter();
            _this.onClearFocusPreference = _this._onClearFocusPreference.event;
            _this._onUpdatePreference = new event_1.Emitter();
            _this.onUpdatePreference = _this._onUpdatePreference.event;
            _this.settingHighlighter = _this._register(instantiationService.createInstance(SettingHighlighter, editor, _this._onFocusPreference, _this._onClearFocusPreference));
            _this.highlightMatchesRenderer = _this._register(instantiationService.createInstance(HighlightMatchesRenderer, editor));
            _this.editSettingActionRenderer = _this._register(_this.instantiationService.createInstance(EditSettingRenderer, _this.editor, _this.preferencesModel, _this.settingHighlighter));
            _this._register(_this.editSettingActionRenderer.onUpdateSetting(function (_a) {
                var key = _a.key, value = _a.value, source = _a.source;
                return _this._updatePreference(key, value, source);
            }));
            _this._register(_this.editor.getModel().onDidChangeContent(function () { return _this.modelChangeDelayer.trigger(function () { return _this.onModelChanged(); }); }));
            return _this;
        }
        UserSettingsRenderer.prototype.getAssociatedPreferencesModel = function () {
            return this.associatedPreferencesModel;
        };
        UserSettingsRenderer.prototype.setAssociatedPreferencesModel = function (associatedPreferencesModel) {
            this.associatedPreferencesModel = associatedPreferencesModel;
            this.editSettingActionRenderer.associatedPreferencesModel = associatedPreferencesModel;
            // Create header only in Settings editor mode
            this.createHeader();
        };
        UserSettingsRenderer.prototype.createHeader = function () {
            this._register(new preferencesWidgets_1.SettingsHeaderWidget(this.editor, '')).setMessage(nls.localize('emptyUserSettingsHeader', "Place your settings here to overwrite the Default Settings."));
        };
        UserSettingsRenderer.prototype.render = function () {
            this.editSettingActionRenderer.render(this.preferencesModel.settingsGroups, this.associatedPreferencesModel);
            if (this.filterResult) {
                this.filterPreferences(this.filterResult);
            }
        };
        UserSettingsRenderer.prototype._updatePreference = function (key, value, source) {
            this._onUpdatePreference.fire({ key: key, value: value, source: source });
            this.updatePreference(key, value, source);
        };
        UserSettingsRenderer.prototype.updatePreference = function (key, value, source) {
            var _this = this;
            var overrideIdentifier = source.overrideOf ? configuration_1.overrideIdentifierFromKey(source.overrideOf.key) : null;
            var resource = this.preferencesModel.uri;
            this.configurationService.updateValue(key, value, { overrideIdentifier: overrideIdentifier, resource: resource }, this.preferencesModel.configurationTarget)
                .then(function () { return _this.onSettingUpdated(source); });
        };
        UserSettingsRenderer.prototype.onModelChanged = function () {
            if (!this.editor.getModel()) {
                // model could have been disposed during the delay
                return;
            }
            this.render();
        };
        UserSettingsRenderer.prototype.onSettingUpdated = function (setting) {
            this.editor.focus();
            setting = this.getSetting(setting);
            if (setting) {
                // TODO:@sandy Selection range should be template range
                this.editor.setSelection(setting.valueRange);
                this.settingHighlighter.highlight(setting, true);
            }
        };
        UserSettingsRenderer.prototype.getSetting = function (setting) {
            var key = setting.key, overrideOf = setting.overrideOf;
            if (overrideOf) {
                var setting_1 = this.getSetting(overrideOf);
                for (var _i = 0, _a = setting_1.overrides; _i < _a.length; _i++) {
                    var override = _a[_i];
                    if (override.key === key) {
                        return override;
                    }
                }
                return null;
            }
            return this.preferencesModel.getPreference(key);
        };
        UserSettingsRenderer.prototype.filterPreferences = function (filterResult) {
            this.filterResult = filterResult;
            this.settingHighlighter.clear(true);
            this.highlightMatchesRenderer.render(filterResult ? filterResult.matches : []);
        };
        UserSettingsRenderer.prototype.focusPreference = function (setting) {
            var s = this.getSetting(setting);
            if (s) {
                this.settingHighlighter.highlight(s, true);
                this.editor.setPosition({ lineNumber: s.keyRange.startLineNumber, column: s.keyRange.startColumn });
            }
            else {
                this.settingHighlighter.clear(true);
            }
        };
        UserSettingsRenderer.prototype.clearFocus = function (setting) {
            this.settingHighlighter.clear(true);
        };
        UserSettingsRenderer.prototype.editPreference = function (setting) {
            var editableSetting = this.getSetting(setting);
            return editableSetting && this.editSettingActionRenderer.activateOnSetting(editableSetting);
        };
        UserSettingsRenderer = __decorate([
            __param(2, preferences_1.IPreferencesService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, instantiation_1.IInstantiationService)
        ], UserSettingsRenderer);
        return UserSettingsRenderer;
    }(lifecycle_1.Disposable));
    exports.UserSettingsRenderer = UserSettingsRenderer;
    var WorkspaceSettingsRenderer = /** @class */ (function (_super) {
        __extends(WorkspaceSettingsRenderer, _super);
        function WorkspaceSettingsRenderer(editor, preferencesModel, preferencesService, telemetryService, configurationService, instantiationService) {
            var _this = _super.call(this, editor, preferencesModel, preferencesService, configurationService, instantiationService) || this;
            _this.workspaceConfigurationRenderer = _this._register(instantiationService.createInstance(WorkspaceConfigurationRenderer, editor, preferencesModel));
            return _this;
        }
        WorkspaceSettingsRenderer.prototype.createHeader = function () {
            this._register(new preferencesWidgets_1.SettingsHeaderWidget(this.editor, '')).setMessage(nls.localize('emptyWorkspaceSettingsHeader', "Place your settings here to overwrite the User Settings."));
        };
        WorkspaceSettingsRenderer.prototype.setAssociatedPreferencesModel = function (associatedPreferencesModel) {
            _super.prototype.setAssociatedPreferencesModel.call(this, associatedPreferencesModel);
            this.workspaceConfigurationRenderer.render(this.getAssociatedPreferencesModel());
        };
        WorkspaceSettingsRenderer.prototype.render = function () {
            _super.prototype.render.call(this);
            this.workspaceConfigurationRenderer.render(this.getAssociatedPreferencesModel());
        };
        WorkspaceSettingsRenderer = __decorate([
            __param(2, preferences_1.IPreferencesService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, instantiation_1.IInstantiationService)
        ], WorkspaceSettingsRenderer);
        return WorkspaceSettingsRenderer;
    }(UserSettingsRenderer));
    exports.WorkspaceSettingsRenderer = WorkspaceSettingsRenderer;
    var FolderSettingsRenderer = /** @class */ (function (_super) {
        __extends(FolderSettingsRenderer, _super);
        function FolderSettingsRenderer(editor, preferencesModel, preferencesService, telemetryService, configurationService, instantiationService) {
            return _super.call(this, editor, preferencesModel, preferencesService, configurationService, instantiationService) || this;
        }
        FolderSettingsRenderer.prototype.createHeader = function () {
            this._register(new preferencesWidgets_1.SettingsHeaderWidget(this.editor, '')).setMessage(nls.localize('emptyFolderSettingsHeader', "Place your folder settings here to overwrite those from the Workspace Settings."));
        };
        FolderSettingsRenderer = __decorate([
            __param(2, preferences_1.IPreferencesService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, instantiation_1.IInstantiationService)
        ], FolderSettingsRenderer);
        return FolderSettingsRenderer;
    }(UserSettingsRenderer));
    exports.FolderSettingsRenderer = FolderSettingsRenderer;
    var DefaultSettingsRenderer = /** @class */ (function (_super) {
        __extends(DefaultSettingsRenderer, _super);
        function DefaultSettingsRenderer(editor, preferencesModel, preferencesService, instantiationService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.preferencesModel = preferencesModel;
            _this.preferencesService = preferencesService;
            _this.instantiationService = instantiationService;
            _this._onUpdatePreference = new event_1.Emitter();
            _this.onUpdatePreference = _this._onUpdatePreference.event;
            _this._onFocusPreference = new event_1.Emitter();
            _this.onFocusPreference = _this._onFocusPreference.event;
            _this._onClearFocusPreference = new event_1.Emitter();
            _this.onClearFocusPreference = _this._onClearFocusPreference.event;
            _this.settingHighlighter = _this._register(instantiationService.createInstance(SettingHighlighter, editor, _this._onFocusPreference, _this._onClearFocusPreference));
            _this.settingsHeaderRenderer = _this._register(instantiationService.createInstance(DefaultSettingsHeaderRenderer, editor));
            _this.settingsGroupTitleRenderer = _this._register(instantiationService.createInstance(SettingsGroupTitleRenderer, editor));
            _this.filteredMatchesRenderer = _this._register(instantiationService.createInstance(FilteredMatchesRenderer, editor));
            _this.editSettingActionRenderer = _this._register(instantiationService.createInstance(EditSettingRenderer, editor, preferencesModel, _this.settingHighlighter));
            _this.bracesHidingRenderer = _this._register(instantiationService.createInstance(BracesHidingRenderer, editor, preferencesModel));
            _this.hiddenAreasRenderer = _this._register(instantiationService.createInstance(HiddenAreasRenderer, editor, [_this.settingsGroupTitleRenderer, _this.filteredMatchesRenderer, _this.bracesHidingRenderer]));
            _this._register(_this.editSettingActionRenderer.onUpdateSetting(function (e) { return _this._onUpdatePreference.fire(e); }));
            _this._register(_this.settingsGroupTitleRenderer.onHiddenAreasChanged(function () { return _this.hiddenAreasRenderer.render(); }));
            _this._register(preferencesModel.onDidChangeGroups(function () { return _this.render(); }));
            return _this;
        }
        DefaultSettingsRenderer.prototype.getAssociatedPreferencesModel = function () {
            return this._associatedPreferencesModel;
        };
        DefaultSettingsRenderer.prototype.setAssociatedPreferencesModel = function (associatedPreferencesModel) {
            this._associatedPreferencesModel = associatedPreferencesModel;
            this.editSettingActionRenderer.associatedPreferencesModel = associatedPreferencesModel;
        };
        DefaultSettingsRenderer.prototype.render = function () {
            this.settingsGroupTitleRenderer.render(this.preferencesModel.settingsGroups);
            this.editSettingActionRenderer.render(this.preferencesModel.settingsGroups, this._associatedPreferencesModel);
            this.settingHighlighter.clear(true);
            this.bracesHidingRenderer.render(null, this.preferencesModel.settingsGroups);
            this.settingsGroupTitleRenderer.showGroup(0);
            this.hiddenAreasRenderer.render();
        };
        DefaultSettingsRenderer.prototype.filterPreferences = function (filterResult) {
            this.filterResult = filterResult;
            if (filterResult) {
                this.filteredMatchesRenderer.render(filterResult, this.preferencesModel.settingsGroups);
                this.settingsGroupTitleRenderer.render(null);
                this.settingsHeaderRenderer.render(filterResult);
                this.settingHighlighter.clear(true);
                this.bracesHidingRenderer.render(filterResult, this.preferencesModel.settingsGroups);
                this.editSettingActionRenderer.render(filterResult.filteredGroups, this._associatedPreferencesModel);
            }
            else {
                this.settingHighlighter.clear(true);
                this.filteredMatchesRenderer.render(null, this.preferencesModel.settingsGroups);
                this.settingsHeaderRenderer.render(null);
                this.settingsGroupTitleRenderer.render(this.preferencesModel.settingsGroups);
                this.settingsGroupTitleRenderer.showGroup(0);
                this.bracesHidingRenderer.render(null, this.preferencesModel.settingsGroups);
                this.editSettingActionRenderer.render(this.preferencesModel.settingsGroups, this._associatedPreferencesModel);
            }
            this.hiddenAreasRenderer.render();
        };
        DefaultSettingsRenderer.prototype.focusPreference = function (s) {
            var setting = this.getSetting(s);
            if (setting) {
                this.settingsGroupTitleRenderer.showSetting(setting);
                this.settingHighlighter.highlight(setting, true);
            }
            else {
                this.settingHighlighter.clear(true);
            }
        };
        DefaultSettingsRenderer.prototype.getSetting = function (setting) {
            var key = setting.key, overrideOf = setting.overrideOf;
            if (overrideOf) {
                var setting_2 = this.getSetting(overrideOf);
                for (var _i = 0, _a = setting_2.overrides; _i < _a.length; _i++) {
                    var override = _a[_i];
                    if (override.key === key) {
                        return override;
                    }
                }
                return null;
            }
            var settingsGroups = this.filterResult ? this.filterResult.filteredGroups : this.preferencesModel.settingsGroups;
            return this.getPreference(key, settingsGroups);
        };
        DefaultSettingsRenderer.prototype.getPreference = function (key, settingsGroups) {
            for (var _i = 0, settingsGroups_1 = settingsGroups; _i < settingsGroups_1.length; _i++) {
                var group = settingsGroups_1[_i];
                for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                    var section = _b[_a];
                    for (var _c = 0, _d = section.settings; _c < _d.length; _c++) {
                        var setting = _d[_c];
                        if (setting.key === key) {
                            return setting;
                        }
                    }
                }
            }
            return null;
        };
        DefaultSettingsRenderer.prototype.clearFocus = function (setting) {
            this.settingHighlighter.clear(true);
        };
        DefaultSettingsRenderer.prototype.updatePreference = function (key, value, source) {
        };
        DefaultSettingsRenderer.prototype.editPreference = function (setting) {
            return this.editSettingActionRenderer.activateOnSetting(setting);
        };
        DefaultSettingsRenderer = __decorate([
            __param(2, preferences_1.IPreferencesService),
            __param(3, instantiation_1.IInstantiationService)
        ], DefaultSettingsRenderer);
        return DefaultSettingsRenderer;
    }(lifecycle_1.Disposable));
    exports.DefaultSettingsRenderer = DefaultSettingsRenderer;
    var BracesHidingRenderer = /** @class */ (function (_super) {
        __extends(BracesHidingRenderer, _super);
        function BracesHidingRenderer(editor) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            return _this;
        }
        BracesHidingRenderer.prototype.render = function (result, settingsGroups) {
            this._result = result;
            this._settingsGroups = settingsGroups;
        };
        Object.defineProperty(BracesHidingRenderer.prototype, "hiddenAreas", {
            get: function () {
                // Opening square brace
                var hiddenAreas = [
                    {
                        startLineNumber: 1,
                        startColumn: 1,
                        endLineNumber: 2,
                        endColumn: 1
                    }
                ];
                var hideBraces = function (group, hideExtraLine) {
                    // Opening curly brace
                    hiddenAreas.push({
                        startLineNumber: group.range.startLineNumber - 3,
                        startColumn: 1,
                        endLineNumber: group.range.startLineNumber - (hideExtraLine ? 1 : 3),
                        endColumn: 1
                    });
                    // Closing curly brace
                    hiddenAreas.push({
                        startLineNumber: group.range.endLineNumber + 1,
                        startColumn: 1,
                        endLineNumber: group.range.endLineNumber + 4,
                        endColumn: 1
                    });
                };
                this._settingsGroups.forEach(function (g) { return hideBraces(g); });
                if (this._result) {
                    this._result.filteredGroups.forEach(function (g, i) { return hideBraces(g, true); });
                }
                // Closing square brace
                var lineCount = this.editor.getModel().getLineCount();
                hiddenAreas.push({
                    startLineNumber: lineCount,
                    startColumn: 1,
                    endLineNumber: lineCount,
                    endColumn: 1
                });
                return hiddenAreas;
            },
            enumerable: true,
            configurable: true
        });
        return BracesHidingRenderer;
    }(lifecycle_1.Disposable));
    exports.BracesHidingRenderer = BracesHidingRenderer;
    var DefaultSettingsHeaderRenderer = /** @class */ (function (_super) {
        __extends(DefaultSettingsHeaderRenderer, _super);
        function DefaultSettingsHeaderRenderer(editor) {
            var _this = _super.call(this) || this;
            _this.settingsHeaderWidget = _this._register(new preferencesWidgets_1.DefaultSettingsHeaderWidget(editor, ''));
            _this.onClick = _this.settingsHeaderWidget.onClick;
            return _this;
        }
        DefaultSettingsHeaderRenderer.prototype.render = function (filterResult) {
            var hasSettings = !filterResult || filterResult.filteredGroups.length > 0;
            this.settingsHeaderWidget.toggleMessage(hasSettings);
        };
        return DefaultSettingsHeaderRenderer;
    }(lifecycle_1.Disposable));
    var SettingsGroupTitleRenderer = /** @class */ (function (_super) {
        __extends(SettingsGroupTitleRenderer, _super);
        function SettingsGroupTitleRenderer(editor, instantiationService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.instantiationService = instantiationService;
            _this._onHiddenAreasChanged = new event_1.Emitter();
            _this.hiddenGroups = [];
            _this.disposables = [];
            return _this;
        }
        Object.defineProperty(SettingsGroupTitleRenderer.prototype, "onHiddenAreasChanged", {
            get: function () { return this._onHiddenAreasChanged.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsGroupTitleRenderer.prototype, "hiddenAreas", {
            get: function () {
                var hiddenAreas = [];
                for (var _i = 0, _a = this.hiddenGroups; _i < _a.length; _i++) {
                    var group = _a[_i];
                    hiddenAreas.push(group.range);
                }
                return hiddenAreas;
            },
            enumerable: true,
            configurable: true
        });
        SettingsGroupTitleRenderer.prototype.render = function (settingsGroups) {
            var _this = this;
            this.disposeWidgets();
            if (!settingsGroups) {
                return;
            }
            this.settingsGroups = settingsGroups.slice();
            this.settingsGroupTitleWidgets = [];
            var _loop_1 = function (group) {
                if (group.sections.every(function (sect) { return sect.settings.length === 0; })) {
                    return "continue";
                }
                var settingsGroupTitleWidget = this_1.instantiationService.createInstance(preferencesWidgets_1.SettingsGroupTitleWidget, this_1.editor, group);
                settingsGroupTitleWidget.render();
                this_1.settingsGroupTitleWidgets.push(settingsGroupTitleWidget);
                this_1.disposables.push(settingsGroupTitleWidget);
                this_1.disposables.push(settingsGroupTitleWidget.onToggled(function (collapsed) { return _this.onToggled(collapsed, settingsGroupTitleWidget.settingsGroup); }));
            };
            var this_1 = this;
            for (var _i = 0, _a = this.settingsGroups.slice().reverse(); _i < _a.length; _i++) {
                var group = _a[_i];
                _loop_1(group);
            }
            this.settingsGroupTitleWidgets.reverse();
        };
        SettingsGroupTitleRenderer.prototype.showGroup = function (groupIdx) {
            var shownGroup = this.settingsGroupTitleWidgets[groupIdx].settingsGroup;
            this.hiddenGroups = this.settingsGroups.filter(function (g) { return g !== shownGroup; });
            for (var _i = 0, _a = this.settingsGroupTitleWidgets.filter(function (widget) { return widget.settingsGroup !== shownGroup; }); _i < _a.length; _i++) {
                var groupTitleWidget = _a[_i];
                groupTitleWidget.toggleCollapse(true);
            }
            this._onHiddenAreasChanged.fire();
        };
        SettingsGroupTitleRenderer.prototype.showSetting = function (setting) {
            var settingsGroupTitleWidget = this.settingsGroupTitleWidgets.filter(function (widget) { return range_1.Range.containsRange(widget.settingsGroup.range, setting.range); })[0];
            if (settingsGroupTitleWidget && settingsGroupTitleWidget.isCollapsed()) {
                settingsGroupTitleWidget.toggleCollapse(false);
                this.hiddenGroups.splice(this.hiddenGroups.indexOf(settingsGroupTitleWidget.settingsGroup), 1);
                this._onHiddenAreasChanged.fire();
            }
        };
        SettingsGroupTitleRenderer.prototype.onToggled = function (collapsed, group) {
            var index = this.hiddenGroups.indexOf(group);
            if (collapsed) {
                var currentPosition = this.editor.getPosition();
                if (group.range.startLineNumber <= currentPosition.lineNumber && group.range.endLineNumber >= currentPosition.lineNumber) {
                    this.editor.setPosition({ lineNumber: group.range.startLineNumber - 1, column: 1 });
                }
                this.hiddenGroups.push(group);
            }
            else {
                this.hiddenGroups.splice(index, 1);
            }
            this._onHiddenAreasChanged.fire();
        };
        SettingsGroupTitleRenderer.prototype.disposeWidgets = function () {
            this.hiddenGroups = [];
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        SettingsGroupTitleRenderer.prototype.dispose = function () {
            this.disposeWidgets();
            _super.prototype.dispose.call(this);
        };
        SettingsGroupTitleRenderer = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], SettingsGroupTitleRenderer);
        return SettingsGroupTitleRenderer;
    }(lifecycle_1.Disposable));
    exports.SettingsGroupTitleRenderer = SettingsGroupTitleRenderer;
    var HiddenAreasRenderer = /** @class */ (function (_super) {
        __extends(HiddenAreasRenderer, _super);
        function HiddenAreasRenderer(editor, hiddenAreasProviders) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.hiddenAreasProviders = hiddenAreasProviders;
            return _this;
        }
        HiddenAreasRenderer.prototype.render = function () {
            var ranges = [];
            for (var _i = 0, _a = this.hiddenAreasProviders; _i < _a.length; _i++) {
                var hiddenAreaProvider = _a[_i];
                ranges.push.apply(ranges, hiddenAreaProvider.hiddenAreas);
            }
            this.editor.setHiddenAreas(ranges);
        };
        HiddenAreasRenderer.prototype.dispose = function () {
            this.editor.setHiddenAreas([]);
            _super.prototype.dispose.call(this);
        };
        return HiddenAreasRenderer;
    }(lifecycle_1.Disposable));
    exports.HiddenAreasRenderer = HiddenAreasRenderer;
    var FilteredMatchesRenderer = /** @class */ (function (_super) {
        __extends(FilteredMatchesRenderer, _super);
        function FilteredMatchesRenderer(editor) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.decorationIds = [];
            _this.hiddenAreas = [];
            return _this;
        }
        FilteredMatchesRenderer.prototype.render = function (result, allSettingsGroups) {
            var _this = this;
            var model = this.editor.getModel();
            this.hiddenAreas = [];
            if (result) {
                this.hiddenAreas = this.computeHiddenRanges(result.filteredGroups, result.allGroups, model);
                this.decorationIds = this.editor.deltaDecorations(this.decorationIds, result.matches.map(function (match) { return _this.createDecoration(match, model); }));
            }
            else {
                this.hiddenAreas = this.computeHiddenRanges(null, allSettingsGroups, model);
                this.decorationIds = this.editor.deltaDecorations(this.decorationIds, []);
            }
        };
        FilteredMatchesRenderer.prototype.createDecoration = function (range, model) {
            return {
                range: range,
                options: FilteredMatchesRenderer._FIND_MATCH
            };
        };
        FilteredMatchesRenderer.prototype.computeHiddenRanges = function (filteredGroups, allSettingsGroups, model) {
            // Hide the contents of hidden groups
            var notMatchesRanges = [];
            if (filteredGroups) {
                allSettingsGroups.forEach(function (group, i) {
                    notMatchesRanges.push({
                        startLineNumber: group.range.startLineNumber - 1,
                        startColumn: group.range.startColumn,
                        endLineNumber: group.range.endLineNumber,
                        endColumn: group.range.endColumn
                    });
                });
            }
            return notMatchesRanges;
        };
        FilteredMatchesRenderer.prototype.dispose = function () {
            this.decorationIds = this.editor.deltaDecorations(this.decorationIds, []);
            _super.prototype.dispose.call(this);
        };
        FilteredMatchesRenderer._FIND_MATCH = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'findMatch'
        });
        return FilteredMatchesRenderer;
    }(lifecycle_1.Disposable));
    exports.FilteredMatchesRenderer = FilteredMatchesRenderer;
    var HighlightMatchesRenderer = /** @class */ (function (_super) {
        __extends(HighlightMatchesRenderer, _super);
        function HighlightMatchesRenderer(editor) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.decorationIds = [];
            return _this;
        }
        HighlightMatchesRenderer.prototype.render = function (matches) {
            var _this = this;
            var model = this.editor.getModel();
            this.decorationIds = this.editor.deltaDecorations(this.decorationIds, matches.map(function (match) { return _this.createDecoration(match, model); }));
        };
        HighlightMatchesRenderer.prototype.createDecoration = function (range, model) {
            return {
                range: range,
                options: HighlightMatchesRenderer._FIND_MATCH
            };
        };
        HighlightMatchesRenderer.prototype.dispose = function () {
            this.decorationIds = this.editor.deltaDecorations(this.decorationIds, []);
            _super.prototype.dispose.call(this);
        };
        HighlightMatchesRenderer._FIND_MATCH = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'findMatch'
        });
        return HighlightMatchesRenderer;
    }(lifecycle_1.Disposable));
    exports.HighlightMatchesRenderer = HighlightMatchesRenderer;
    var EditSettingRenderer = /** @class */ (function (_super) {
        __extends(EditSettingRenderer, _super);
        function EditSettingRenderer(editor, masterSettingsModel, settingHighlighter, instantiationService, contextMenuService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.masterSettingsModel = masterSettingsModel;
            _this.settingHighlighter = settingHighlighter;
            _this.instantiationService = instantiationService;
            _this.contextMenuService = contextMenuService;
            _this.settingsGroups = [];
            _this._onUpdateSetting = new event_1.Emitter();
            _this.onUpdateSetting = _this._onUpdateSetting.event;
            _this.editPreferenceWidgetForCursorPosition = _this._register(_this.instantiationService.createInstance(preferencesWidgets_1.EditPreferenceWidget, editor));
            _this.editPreferenceWidgetForMouseMove = _this._register(_this.instantiationService.createInstance(preferencesWidgets_1.EditPreferenceWidget, editor));
            _this.toggleEditPreferencesForMouseMoveDelayer = new async_1.Delayer(75);
            _this._register(_this.editPreferenceWidgetForCursorPosition.onClick(function (e) { return _this.onEditSettingClicked(_this.editPreferenceWidgetForCursorPosition, e); }));
            _this._register(_this.editPreferenceWidgetForMouseMove.onClick(function (e) { return _this.onEditSettingClicked(_this.editPreferenceWidgetForMouseMove, e); }));
            _this._register(_this.editor.onDidChangeCursorPosition(function (positionChangeEvent) { return _this.onPositionChanged(positionChangeEvent); }));
            _this._register(_this.editor.onMouseMove(function (mouseMoveEvent) { return _this.onMouseMoved(mouseMoveEvent); }));
            _this._register(_this.editor.onDidChangeConfiguration(function () { return _this.onConfigurationChanged(); }));
            return _this;
        }
        EditSettingRenderer.prototype.render = function (settingsGroups, associatedPreferencesModel) {
            this.editPreferenceWidgetForCursorPosition.hide();
            this.editPreferenceWidgetForMouseMove.hide();
            this.settingsGroups = settingsGroups;
            this.associatedPreferencesModel = associatedPreferencesModel;
            var settings = this.getSettings(this.editor.getPosition().lineNumber);
            if (settings.length) {
                this.showEditPreferencesWidget(this.editPreferenceWidgetForCursorPosition, settings);
            }
        };
        EditSettingRenderer.prototype.isDefaultSettings = function () {
            return this.masterSettingsModel instanceof preferencesModels_1.DefaultSettingsEditorModel;
        };
        EditSettingRenderer.prototype.onConfigurationChanged = function () {
            if (!this.editor.getConfiguration().viewInfo.glyphMargin) {
                this.editPreferenceWidgetForCursorPosition.hide();
                this.editPreferenceWidgetForMouseMove.hide();
            }
        };
        EditSettingRenderer.prototype.onPositionChanged = function (positionChangeEvent) {
            this.editPreferenceWidgetForMouseMove.hide();
            var settings = this.getSettings(positionChangeEvent.position.lineNumber);
            if (settings.length) {
                this.showEditPreferencesWidget(this.editPreferenceWidgetForCursorPosition, settings);
            }
            else {
                this.editPreferenceWidgetForCursorPosition.hide();
            }
        };
        EditSettingRenderer.prototype.onMouseMoved = function (mouseMoveEvent) {
            var _this = this;
            var editPreferenceWidget = this.getEditPreferenceWidgetUnderMouse(mouseMoveEvent);
            if (editPreferenceWidget) {
                this.onMouseOver(editPreferenceWidget);
                return;
            }
            this.settingHighlighter.clear();
            this.toggleEditPreferencesForMouseMoveDelayer.trigger(function () { return _this.toggleEditPreferenceWidgetForMouseMove(mouseMoveEvent); });
        };
        EditSettingRenderer.prototype.getEditPreferenceWidgetUnderMouse = function (mouseMoveEvent) {
            if (mouseMoveEvent.target.type === editorBrowser_1.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                var line = mouseMoveEvent.target.position.lineNumber;
                if (this.editPreferenceWidgetForMouseMove.getLine() === line && this.editPreferenceWidgetForMouseMove.isVisible()) {
                    return this.editPreferenceWidgetForMouseMove;
                }
                if (this.editPreferenceWidgetForCursorPosition.getLine() === line && this.editPreferenceWidgetForCursorPosition.isVisible()) {
                    return this.editPreferenceWidgetForCursorPosition;
                }
            }
            return null;
        };
        EditSettingRenderer.prototype.toggleEditPreferenceWidgetForMouseMove = function (mouseMoveEvent) {
            var settings = mouseMoveEvent.target.position ? this.getSettings(mouseMoveEvent.target.position.lineNumber) : null;
            if (settings && settings.length) {
                this.showEditPreferencesWidget(this.editPreferenceWidgetForMouseMove, settings);
            }
            else {
                this.editPreferenceWidgetForMouseMove.hide();
            }
        };
        EditSettingRenderer.prototype.showEditPreferencesWidget = function (editPreferencesWidget, settings) {
            var line = settings[0].valueRange.startLineNumber;
            if (this.editor.getConfiguration().viewInfo.glyphMargin && this.marginFreeFromOtherDecorations(line)) {
                editPreferencesWidget.show(line, nls.localize('editTtile', "Edit"), settings);
                var editPreferenceWidgetToHide = editPreferencesWidget === this.editPreferenceWidgetForCursorPosition ? this.editPreferenceWidgetForMouseMove : this.editPreferenceWidgetForCursorPosition;
                editPreferenceWidgetToHide.hide();
            }
        };
        EditSettingRenderer.prototype.marginFreeFromOtherDecorations = function (line) {
            var decorations = this.editor.getLineDecorations(line);
            if (decorations) {
                for (var _i = 0, decorations_1 = decorations; _i < decorations_1.length; _i++) {
                    var options = decorations_1[_i].options;
                    if (options.glyphMarginClassName && options.glyphMarginClassName.indexOf(preferencesWidgets_1.EditPreferenceWidget.GLYPH_MARGIN_CLASS_NAME) === -1) {
                        return false;
                    }
                }
            }
            return true;
        };
        EditSettingRenderer.prototype.getSettings = function (lineNumber) {
            var _this = this;
            var configurationMap = this.getConfigurationsMap();
            return this.getSettingsAtLineNumber(lineNumber).filter(function (setting) {
                var configurationNode = configurationMap[setting.key];
                if (configurationNode) {
                    if (_this.isDefaultSettings()) {
                        if (setting.key === 'launch') {
                            // Do not show because of https://github.com/Microsoft/vscode/issues/32593
                            return false;
                        }
                        return true;
                    }
                    if (configurationNode.type === 'boolean' || configurationNode.enum) {
                        if (_this.masterSettingsModel.configurationTarget !== 3 /* WORKSPACE_FOLDER */) {
                            return true;
                        }
                        if (configurationNode.scope === 3 /* RESOURCE */) {
                            return true;
                        }
                    }
                }
                return false;
            });
        };
        EditSettingRenderer.prototype.getSettingsAtLineNumber = function (lineNumber) {
            // index of setting, across all groups/sections
            var index = 0;
            var settings = [];
            for (var _i = 0, _a = this.settingsGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                if (group.range.startLineNumber > lineNumber) {
                    break;
                }
                if (lineNumber >= group.range.startLineNumber && lineNumber <= group.range.endLineNumber) {
                    for (var _b = 0, _c = group.sections; _b < _c.length; _b++) {
                        var section = _c[_b];
                        for (var _d = 0, _e = section.settings; _d < _e.length; _d++) {
                            var setting = _e[_d];
                            if (setting.range.startLineNumber > lineNumber) {
                                break;
                            }
                            if (lineNumber >= setting.range.startLineNumber && lineNumber <= setting.range.endLineNumber) {
                                if (!this.isDefaultSettings() && setting.overrides.length) {
                                    // Only one level because override settings cannot have override settings
                                    for (var _f = 0, _g = setting.overrides; _f < _g.length; _f++) {
                                        var overrideSetting = _g[_f];
                                        if (lineNumber >= overrideSetting.range.startLineNumber && lineNumber <= overrideSetting.range.endLineNumber) {
                                            settings.push(__assign({}, overrideSetting, { index: index, groupId: group.id }));
                                        }
                                    }
                                }
                                else {
                                    settings.push(__assign({}, setting, { index: index, groupId: group.id }));
                                }
                            }
                            index++;
                        }
                    }
                }
            }
            return settings;
        };
        EditSettingRenderer.prototype.onMouseOver = function (editPreferenceWidget) {
            this.settingHighlighter.highlight(editPreferenceWidget.preferences[0]);
        };
        EditSettingRenderer.prototype.onEditSettingClicked = function (editPreferenceWidget, e) {
            var _this = this;
            var anchor = { x: e.event.posx, y: e.event.posy + 10 };
            var actions = this.getSettings(editPreferenceWidget.getLine()).length === 1 ? this.getActions(editPreferenceWidget.preferences[0], this.getConfigurationsMap()[editPreferenceWidget.preferences[0].key])
                : editPreferenceWidget.preferences.map(function (setting) { return new contextmenu_1.ContextSubMenu(setting.key, _this.getActions(setting, _this.getConfigurationsMap()[setting.key])); });
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () { return winjs_base_1.TPromise.wrap(actions); }
            });
        };
        EditSettingRenderer.prototype.activateOnSetting = function (setting) {
            var _this = this;
            var startLine = setting.keyRange.startLineNumber;
            var settings = this.getSettings(startLine);
            if (!settings.length) {
                return false;
            }
            this.editPreferenceWidgetForMouseMove.show(startLine, '', settings);
            var actions = this.getActions(this.editPreferenceWidgetForMouseMove.preferences[0], this.getConfigurationsMap()[this.editPreferenceWidgetForMouseMove.preferences[0].key]);
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return _this.toAbsoluteCoords(new position_1.Position(startLine, 1)); },
                getActions: function () { return winjs_base_1.TPromise.wrap(actions); }
            });
            return true;
        };
        EditSettingRenderer.prototype.toAbsoluteCoords = function (position) {
            var positionCoords = this.editor.getScrolledVisiblePosition(position);
            var editorCoords = dom_1.getDomNodePagePosition(this.editor.getDomNode());
            var x = editorCoords.left + positionCoords.left;
            var y = editorCoords.top + positionCoords.top + positionCoords.height;
            return { x: x, y: y + 10 };
        };
        EditSettingRenderer.prototype.getConfigurationsMap = function () {
            return platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        };
        EditSettingRenderer.prototype.getActions = function (setting, jsonSchema) {
            var _this = this;
            if (jsonSchema.type === 'boolean') {
                return [{
                        id: 'truthyValue',
                        label: 'true',
                        enabled: true,
                        run: function () { return _this.updateSetting(setting.key, true, setting); }
                    }, {
                        id: 'falsyValue',
                        label: 'false',
                        enabled: true,
                        run: function () { return _this.updateSetting(setting.key, false, setting); }
                    }];
            }
            if (jsonSchema.enum) {
                return jsonSchema.enum.map(function (value) {
                    return {
                        id: value,
                        label: JSON.stringify(value),
                        enabled: true,
                        run: function () { return _this.updateSetting(setting.key, value, setting); }
                    };
                });
            }
            return this.getDefaultActions(setting);
        };
        EditSettingRenderer.prototype.getDefaultActions = function (setting) {
            var _this = this;
            if (this.isDefaultSettings()) {
                var settingInOtherModel = this.associatedPreferencesModel.getPreference(setting.key);
                return [{
                        id: 'setDefaultValue',
                        label: settingInOtherModel ? nls.localize('replaceDefaultValue', "Replace in Settings") : nls.localize('copyDefaultValue', "Copy to Settings"),
                        enabled: true,
                        run: function () { return _this.updateSetting(setting.key, setting.value, setting); }
                    }];
            }
            return [];
        };
        EditSettingRenderer.prototype.updateSetting = function (key, value, source) {
            this._onUpdateSetting.fire({ key: key, value: value, source: source });
        };
        EditSettingRenderer = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, contextView_1.IContextMenuService)
        ], EditSettingRenderer);
        return EditSettingRenderer;
    }(lifecycle_1.Disposable));
    var SettingHighlighter = /** @class */ (function (_super) {
        __extends(SettingHighlighter, _super);
        function SettingHighlighter(editor, focusEventEmitter, clearFocusEventEmitter, instantiationService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.focusEventEmitter = focusEventEmitter;
            _this.clearFocusEventEmitter = clearFocusEventEmitter;
            _this.fixedHighlighter = _this._register(instantiationService.createInstance(rangeDecorations_1.RangeHighlightDecorations));
            _this.volatileHighlighter = _this._register(instantiationService.createInstance(rangeDecorations_1.RangeHighlightDecorations));
            _this.fixedHighlighter.onHighlghtRemoved(function () { return _this.clearFocusEventEmitter.fire(_this.highlightedSetting); });
            _this.volatileHighlighter.onHighlghtRemoved(function () { return _this.clearFocusEventEmitter.fire(_this.highlightedSetting); });
            return _this;
        }
        SettingHighlighter.prototype.highlight = function (setting, fix) {
            if (fix === void 0) { fix = false; }
            this.highlightedSetting = setting;
            this.volatileHighlighter.removeHighlightRange();
            this.fixedHighlighter.removeHighlightRange();
            var highlighter = fix ? this.fixedHighlighter : this.volatileHighlighter;
            highlighter.highlightRange({
                range: setting.valueRange,
                resource: this.editor.getModel().uri
            }, this.editor);
            this.editor.revealLineInCenterIfOutsideViewport(setting.valueRange.startLineNumber, 0 /* Smooth */);
            this.focusEventEmitter.fire(setting);
        };
        SettingHighlighter.prototype.clear = function (fix) {
            if (fix === void 0) { fix = false; }
            this.volatileHighlighter.removeHighlightRange();
            if (fix) {
                this.fixedHighlighter.removeHighlightRange();
            }
            this.clearFocusEventEmitter.fire(this.highlightedSetting);
        };
        SettingHighlighter = __decorate([
            __param(3, instantiation_1.IInstantiationService)
        ], SettingHighlighter);
        return SettingHighlighter;
    }(lifecycle_1.Disposable));
    var WorkspaceConfigurationRenderer = /** @class */ (function (_super) {
        __extends(WorkspaceConfigurationRenderer, _super);
        function WorkspaceConfigurationRenderer(editor, workspaceSettingsEditorModel, workspaceContextService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.workspaceSettingsEditorModel = workspaceSettingsEditorModel;
            _this.workspaceContextService = workspaceContextService;
            _this.decorationIds = [];
            _this.renderingDelayer = new async_1.Delayer(200);
            _this._register(_this.editor.getModel().onDidChangeContent(function () { return _this.renderingDelayer.trigger(function () { return _this.render(_this.associatedSettingsEditorModel); }); }));
            return _this;
        }
        WorkspaceConfigurationRenderer.prototype.render = function (associatedSettingsEditorModel) {
            var _this = this;
            this.associatedSettingsEditorModel = associatedSettingsEditorModel;
            // Dim other configurations in workspace configuration file only in the context of Settings Editor
            if (this.associatedSettingsEditorModel && this.workspaceContextService.getWorkbenchState() === 3 /* WORKSPACE */ && this.workspaceSettingsEditorModel instanceof preferencesModels_1.WorkspaceConfigurationEditorModel) {
                var ranges = [];
                for (var _i = 0, _a = this.workspaceSettingsEditorModel.configurationGroups; _i < _a.length; _i++) {
                    var settingsGroup = _a[_i];
                    for (var _b = 0, _c = settingsGroup.sections; _b < _c.length; _b++) {
                        var section = _c[_b];
                        for (var _d = 0, _e = section.settings; _d < _e.length; _d++) {
                            var setting = _e[_d];
                            if (setting.key !== 'settings') {
                                ranges.push({
                                    startLineNumber: setting.keyRange.startLineNumber,
                                    startColumn: setting.keyRange.startColumn - 1,
                                    endLineNumber: setting.valueRange.endLineNumber,
                                    endColumn: setting.valueRange.endColumn
                                });
                            }
                        }
                    }
                }
                this.decorationIds = this.editor.deltaDecorations(this.decorationIds, ranges.map(function (range) { return _this.createDecoration(range, _this.editor.getModel()); }));
            }
        };
        WorkspaceConfigurationRenderer.prototype.createDecoration = function (range, model) {
            return {
                range: range,
                options: WorkspaceConfigurationRenderer._DIM_CONFIGURATION_
            };
        };
        WorkspaceConfigurationRenderer.prototype.dispose = function () {
            this.decorationIds = this.editor.deltaDecorations(this.decorationIds, []);
            _super.prototype.dispose.call(this);
        };
        WorkspaceConfigurationRenderer._DIM_CONFIGURATION_ = textModel_1.ModelDecorationOptions.register({
            stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            inlineClassName: 'dim-configuration'
        });
        WorkspaceConfigurationRenderer = __decorate([
            __param(2, workspace_1.IWorkspaceContextService)
        ], WorkspaceConfigurationRenderer);
        return WorkspaceConfigurationRenderer;
    }(lifecycle_1.Disposable));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[361/*vs/workbench/services/preferences/browser/preferencesService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,77/*vs/base/common/json*/,4/*vs/base/common/lifecycle*/,26/*vs/base/common/network*/,38/*vs/base/common/objects*/,22/*vs/base/common/strings*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,45/*vs/editor/browser/editorBrowser*/,89/*vs/editor/common/core/editOperation*/,135/*vs/editor/common/core/position*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,66/*vs/editor/common/services/resolverService*/,2/*vs/nls*/,43/*vs/platform/environment/common/environment*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,59/*vs/platform/label/common/label*/,28/*vs/platform/notification/common/notification*/,32/*vs/platform/telemetry/common/telemetry*/,20/*vs/platform/workspace/common/workspace*/,153/*vs/workbench/services/configuration/common/configuration*/,154/*vs/workbench/services/configuration/common/jsonEditing*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,61/*vs/workbench/services/preferences/common/preferences*/,205/*vs/workbench/services/preferences/common/preferencesEditorInput*/,162/*vs/workbench/services/preferences/common/preferencesModels*/]), function (require, exports, event_1, json_1, lifecycle_1, network, objects_1, strings, uri_1, winjs_base_1, editorBrowser_1, editOperation_1, position_1, modelService_1, modeService_1, resolverService_1, nls, environment_1, files_1, instantiation_1, keybinding_1, label_1, notification_1, telemetry_1, workspace_1, configuration_1, jsonEditing_1, editorService_1, editorGroupsService_1, preferences_1, preferencesEditorInput_1, preferencesModels_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var emptyEditableSettingsContent = '{\n}';
    var PreferencesService = /** @class */ (function (_super) {
        __extends(PreferencesService, _super);
        function PreferencesService(editorService, editorGroupService, fileService, configurationService, notificationService, contextService, instantiationService, environmentService, telemetryService, textModelResolverService, keybindingService, modelService, jsonEditingService, modeService, labelService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.fileService = fileService;
            _this.configurationService = configurationService;
            _this.notificationService = notificationService;
            _this.contextService = contextService;
            _this.instantiationService = instantiationService;
            _this.environmentService = environmentService;
            _this.telemetryService = telemetryService;
            _this.textModelResolverService = textModelResolverService;
            _this.modelService = modelService;
            _this.jsonEditingService = jsonEditingService;
            _this.modeService = modeService;
            _this.labelService = labelService;
            _this.lastOpenedSettingsInput = null;
            _this._onDispose = new event_1.Emitter();
            _this._defaultUserSettingsUriCounter = 0;
            _this._defaultWorkspaceSettingsUriCounter = 0;
            _this._defaultFolderSettingsUriCounter = 0;
            _this.defaultKeybindingsResource = uri_1.URI.from({ scheme: network.Schemas.vscode, authority: 'defaultsettings', path: '/keybindings.json' });
            _this.defaultSettingsRawResource = uri_1.URI.from({ scheme: network.Schemas.vscode, authority: 'defaultsettings', path: '/defaultSettings.json' });
            // The default keybindings.json updates based on keyboard layouts, so here we make sure
            // if a model has been given out we update it accordingly.
            keybindingService.onDidUpdateKeybindings(function () {
                var model = modelService.getModel(_this.defaultKeybindingsResource);
                if (!model) {
                    // model has not been given out => nothing to do
                    return;
                }
                modelService.updateModel(model, preferencesModels_1.defaultKeybindingsContents(keybindingService));
            });
            return _this;
        }
        Object.defineProperty(PreferencesService.prototype, "userSettingsResource", {
            get: function () {
                return this.getEditableSettingsURI(1 /* USER */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesService.prototype, "workspaceSettingsResource", {
            get: function () {
                return this.getEditableSettingsURI(2 /* WORKSPACE */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesService.prototype, "settingsEditor2Input", {
            get: function () {
                return this.instantiationService.createInstance(preferencesEditorInput_1.SettingsEditor2Input);
            },
            enumerable: true,
            configurable: true
        });
        PreferencesService.prototype.getFolderSettingsResource = function (resource) {
            return this.getEditableSettingsURI(3 /* WORKSPACE_FOLDER */, resource);
        };
        PreferencesService.prototype.resolveModel = function (uri) {
            var _this = this;
            if (this.isDefaultSettingsResource(uri)) {
                var target_1 = this.getConfigurationTargetFromDefaultSettingsResource(uri);
                var mode = this.modeService.getOrCreateMode('jsonc');
                var model = this._register(this.modelService.createModel('', mode, uri));
                var defaultSettings_1;
                this.configurationService.onDidChangeConfiguration(function (e) {
                    if (e.source === 4 /* DEFAULT */) {
                        var model_1 = _this.modelService.getModel(uri);
                        if (!model_1) {
                            // model has not been given out => nothing to do
                            return;
                        }
                        defaultSettings_1 = _this.getDefaultSettings(target_1);
                        _this.modelService.updateModel(model_1, defaultSettings_1.getContent(true));
                        defaultSettings_1._onDidChange.fire();
                    }
                });
                // Check if Default settings is already created and updated in above promise
                if (!defaultSettings_1) {
                    defaultSettings_1 = this.getDefaultSettings(target_1);
                    this.modelService.updateModel(model, defaultSettings_1.getContent(true));
                }
                return winjs_base_1.TPromise.as(model);
            }
            if (this.defaultSettingsRawResource.toString() === uri.toString()) {
                var defaultSettings = this.getDefaultSettings(1 /* USER */);
                var mode = this.modeService.getOrCreateMode('jsonc');
                var model = this._register(this.modelService.createModel(defaultSettings.raw, mode, uri));
                return winjs_base_1.TPromise.as(model);
            }
            if (this.defaultKeybindingsResource.toString() === uri.toString()) {
                var defaultKeybindingsEditorModel = this.instantiationService.createInstance(preferencesModels_1.DefaultKeybindingsEditorModel, uri);
                var mode = this.modeService.getOrCreateMode('jsonc');
                var model = this._register(this.modelService.createModel(defaultKeybindingsEditorModel.content, mode, uri));
                return winjs_base_1.TPromise.as(model);
            }
            return winjs_base_1.TPromise.as(null);
        };
        PreferencesService.prototype.createPreferencesEditorModel = function (uri) {
            if (this.isDefaultSettingsResource(uri)) {
                return this.createDefaultSettingsEditorModel(uri);
            }
            if (this.getEditableSettingsURI(1 /* USER */).toString() === uri.toString()) {
                return this.createEditableSettingsEditorModel(1 /* USER */, uri);
            }
            var workspaceSettingsUri = this.getEditableSettingsURI(2 /* WORKSPACE */);
            if (workspaceSettingsUri && workspaceSettingsUri.toString() === uri.toString()) {
                return this.createEditableSettingsEditorModel(2 /* WORKSPACE */, workspaceSettingsUri);
            }
            if (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */) {
                return this.createEditableSettingsEditorModel(3 /* WORKSPACE_FOLDER */, uri);
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        PreferencesService.prototype.openRawDefaultSettings = function () {
            return this.editorService.openEditor({ resource: this.defaultSettingsRawResource });
        };
        PreferencesService.prototype.openRawUserSettings = function () {
            return this.editorService.openEditor({ resource: this.userSettingsResource });
        };
        PreferencesService.prototype.openSettings = function (jsonEditor) {
            jsonEditor = typeof jsonEditor === 'undefined' ?
                this.configurationService.getValue('workbench.settings.editor') === 'json' :
                jsonEditor;
            if (!jsonEditor) {
                return this.openSettings2();
            }
            var editorInput = this.getActiveSettingsEditorInput() || this.lastOpenedSettingsInput;
            var resource = editorInput ? editorInput.master.getResource() : this.userSettingsResource;
            var target = this.getConfigurationTargetFromSettingsResource(resource);
            return this.openOrSwitchSettings(target, resource);
        };
        PreferencesService.prototype.openSettings2 = function () {
            var _this = this;
            var input = this.settingsEditor2Input;
            return this.editorGroupService.activeGroup.openEditor(input)
                .then(function () { return _this.editorGroupService.activeGroup.activeControl; });
        };
        PreferencesService.prototype.openGlobalSettings = function (jsonEditor, options, group) {
            jsonEditor = typeof jsonEditor === 'undefined' ?
                this.configurationService.getValue('workbench.settings.editor') === 'json' :
                jsonEditor;
            return jsonEditor ?
                this.openOrSwitchSettings(1 /* USER */, this.userSettingsResource, options, group) :
                this.openOrSwitchSettings2(1 /* USER */, undefined, options, group);
        };
        PreferencesService.prototype.openWorkspaceSettings = function (jsonEditor, options, group) {
            jsonEditor = typeof jsonEditor === 'undefined' ?
                this.configurationService.getValue('workbench.settings.editor') === 'json' :
                jsonEditor;
            if (this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
                this.notificationService.info(nls.localize('openFolderFirst', "Open a folder first to create workspace settings"));
                return winjs_base_1.TPromise.as(null);
            }
            return jsonEditor ?
                this.openOrSwitchSettings(2 /* WORKSPACE */, this.workspaceSettingsResource, options, group) :
                this.openOrSwitchSettings2(2 /* WORKSPACE */, undefined, options, group);
        };
        PreferencesService.prototype.openFolderSettings = function (folder, jsonEditor, options, group) {
            jsonEditor = typeof jsonEditor === 'undefined' ?
                this.configurationService.getValue('workbench.settings.editor') === 'json' :
                jsonEditor;
            return jsonEditor ?
                this.openOrSwitchSettings(3 /* WORKSPACE_FOLDER */, this.getEditableSettingsURI(3 /* WORKSPACE_FOLDER */, folder), options, group) :
                this.openOrSwitchSettings2(3 /* WORKSPACE_FOLDER */, folder, options, group);
        };
        PreferencesService.prototype.switchSettings = function (target, resource, jsonEditor) {
            if (!jsonEditor) {
                return this.doOpenSettings2(target, resource).then(function () { return null; });
            }
            var activeControl = this.editorService.activeControl;
            if (activeControl && activeControl.input instanceof preferencesEditorInput_1.PreferencesEditorInput) {
                return this.doSwitchSettings(target, resource, activeControl.input, activeControl.group).then(function () { return null; });
            }
            else {
                return this.doOpenSettings(target, resource).then(function () { return null; });
            }
        };
        PreferencesService.prototype.openGlobalKeybindingSettings = function (textual) {
            var _this = this;
            /* __GDPR__
                "openKeybindings" : {
                    "textual" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                }
            */
            this.telemetryService.publicLog('openKeybindings', { textual: textual });
            if (textual) {
                var emptyContents = '// ' + nls.localize('emptyKeybindingsHeader', "Place your key bindings in this file to overwrite the defaults") + '\n[\n]';
                var editableKeybindings_1 = uri_1.URI.file(this.environmentService.appKeybindingsPath);
                var openDefaultKeybindings_1 = !!this.configurationService.getValue('workbench.settings.openDefaultKeybindings');
                // Create as needed and open in editor
                return this.createIfNotExists(editableKeybindings_1, emptyContents).then(function () {
                    if (openDefaultKeybindings_1) {
                        var activeEditorGroup = _this.editorGroupService.activeGroup;
                        var sideEditorGroup = _this.editorGroupService.addGroup(activeEditorGroup.id, 3 /* RIGHT */);
                        return winjs_base_1.TPromise.join([
                            _this.editorService.openEditor({ resource: _this.defaultKeybindingsResource, options: { pinned: true, preserveFocus: true }, label: nls.localize('defaultKeybindings', "Default Keybindings"), description: '' }),
                            _this.editorService.openEditor({ resource: editableKeybindings_1, options: { pinned: true } }, sideEditorGroup.id)
                        ]).then(function (editors) { return void 0; });
                    }
                    else {
                        return _this.editorService.openEditor({ resource: editableKeybindings_1, options: { pinned: true } }).then(function () { return void 0; });
                    }
                });
            }
            return this.editorService.openEditor(this.instantiationService.createInstance(preferencesEditorInput_1.KeybindingsEditorInput), { pinned: true }).then(function () { return null; });
        };
        PreferencesService.prototype.openDefaultKeybindingsFile = function () {
            return this.editorService.openEditor({ resource: this.defaultKeybindingsResource, label: nls.localize('defaultKeybindings', "Default Keybindings") });
        };
        PreferencesService.prototype.configureSettingsForLanguage = function (language) {
            var _this = this;
            this.openGlobalSettings()
                .then(function (editor) { return _this.createPreferencesEditorModel(_this.userSettingsResource)
                .then(function (settingsModel) {
                var codeEditor = editorBrowser_1.getCodeEditor(editor.getControl());
                if (codeEditor) {
                    _this.getPosition(language, settingsModel, codeEditor)
                        .then(function (position) {
                        if (codeEditor) {
                            codeEditor.setPosition(position);
                            codeEditor.focus();
                        }
                    });
                }
            }); });
        };
        PreferencesService.prototype.openOrSwitchSettings = function (configurationTarget, resource, options, group) {
            if (group === void 0) { group = this.editorGroupService.activeGroup; }
            var editorInput = this.getActiveSettingsEditorInput(group);
            if (editorInput && editorInput.master.getResource().fsPath !== resource.fsPath) {
                return this.doSwitchSettings(configurationTarget, resource, editorInput, group, options);
            }
            return this.doOpenSettings(configurationTarget, resource, options, group);
        };
        PreferencesService.prototype.openOrSwitchSettings2 = function (configurationTarget, folderUri, options, group) {
            if (group === void 0) { group = this.editorGroupService.activeGroup; }
            return this.doOpenSettings2(configurationTarget, folderUri, options, group);
        };
        PreferencesService.prototype.doOpenSettings = function (configurationTarget, resource, options, group) {
            var _this = this;
            var openDefaultSettings = !!this.configurationService.getValue(preferences_1.DEFAULT_SETTINGS_EDITOR_SETTING);
            return this.getOrCreateEditableSettingsEditorInput(configurationTarget, resource)
                .then(function (editableSettingsEditorInput) {
                if (!options) {
                    options = { pinned: true };
                }
                else {
                    options = objects_1.assign(options, { pinned: true });
                }
                if (openDefaultSettings) {
                    var defaultPreferencesEditorInput = _this.instantiationService.createInstance(preferencesEditorInput_1.DefaultPreferencesEditorInput, _this.getDefaultSettingsResource(configurationTarget));
                    var preferencesEditorInput = new preferencesEditorInput_1.PreferencesEditorInput(_this.getPreferencesEditorInputName(configurationTarget, resource), editableSettingsEditorInput.getDescription(), defaultPreferencesEditorInput, editableSettingsEditorInput);
                    _this.lastOpenedSettingsInput = preferencesEditorInput;
                    return _this.editorService.openEditor(preferencesEditorInput, preferences_1.SettingsEditorOptions.create(options), group);
                }
                return _this.editorService.openEditor(editableSettingsEditorInput, preferences_1.SettingsEditorOptions.create(options), group);
            });
        };
        PreferencesService.prototype.createSettings2EditorModel = function () {
            return this.instantiationService.createInstance(preferencesModels_1.Settings2EditorModel, this.getDefaultSettings(1 /* USER */));
        };
        PreferencesService.prototype.doOpenSettings2 = function (target, folderUri, options, group) {
            var input = this.settingsEditor2Input;
            var settingsOptions = __assign({}, options, { target: target,
                folderUri: folderUri });
            return this.editorService.openEditor(input, preferences_1.SettingsEditorOptions.create(settingsOptions), group);
        };
        PreferencesService.prototype.doSwitchSettings = function (target, resource, input, group, options) {
            var _this = this;
            return this.getOrCreateEditableSettingsEditorInput(target, this.getEditableSettingsURI(target, resource))
                .then(function (toInput) {
                return group.openEditor(input).then(function () {
                    var replaceWith = new preferencesEditorInput_1.PreferencesEditorInput(_this.getPreferencesEditorInputName(target, resource), toInput.getDescription(), _this.instantiationService.createInstance(preferencesEditorInput_1.DefaultPreferencesEditorInput, _this.getDefaultSettingsResource(target)), toInput);
                    return group.replaceEditors([{
                            editor: input,
                            replacement: replaceWith,
                            options: preferences_1.SettingsEditorOptions.create(options)
                        }]).then(function () {
                        _this.lastOpenedSettingsInput = replaceWith;
                        return group.activeControl;
                    });
                });
            });
        };
        PreferencesService.prototype.getActiveSettingsEditorInput = function (group) {
            if (group === void 0) { group = this.editorGroupService.activeGroup; }
            return group.editors.filter(function (e) { return e instanceof preferencesEditorInput_1.PreferencesEditorInput; })[0];
        };
        PreferencesService.prototype.getConfigurationTargetFromSettingsResource = function (resource) {
            if (this.userSettingsResource.toString() === resource.toString()) {
                return 1 /* USER */;
            }
            var workspaceSettingsResource = this.workspaceSettingsResource;
            if (workspaceSettingsResource && workspaceSettingsResource.toString() === resource.toString()) {
                return 2 /* WORKSPACE */;
            }
            var folder = this.contextService.getWorkspaceFolder(resource);
            if (folder) {
                return 3 /* WORKSPACE_FOLDER */;
            }
            return 1 /* USER */;
        };
        PreferencesService.prototype.getConfigurationTargetFromDefaultSettingsResource = function (uri) {
            return this.isDefaultWorkspaceSettingsResource(uri) ? 2 /* WORKSPACE */ : this.isDefaultFolderSettingsResource(uri) ? 3 /* WORKSPACE_FOLDER */ : 1 /* USER */;
        };
        PreferencesService.prototype.isDefaultSettingsResource = function (uri) {
            return this.isDefaultUserSettingsResource(uri) || this.isDefaultWorkspaceSettingsResource(uri) || this.isDefaultFolderSettingsResource(uri);
        };
        PreferencesService.prototype.isDefaultUserSettingsResource = function (uri) {
            return uri.authority === 'defaultsettings' && uri.scheme === network.Schemas.vscode && !!uri.path.match(/\/(\d+\/)?settings\.json$/);
        };
        PreferencesService.prototype.isDefaultWorkspaceSettingsResource = function (uri) {
            return uri.authority === 'defaultsettings' && uri.scheme === network.Schemas.vscode && !!uri.path.match(/\/(\d+\/)?workspaceSettings\.json$/);
        };
        PreferencesService.prototype.isDefaultFolderSettingsResource = function (uri) {
            return uri.authority === 'defaultsettings' && uri.scheme === network.Schemas.vscode && !!uri.path.match(/\/(\d+\/)?resourceSettings\.json$/);
        };
        PreferencesService.prototype.getDefaultSettingsResource = function (configurationTarget) {
            switch (configurationTarget) {
                case 2 /* WORKSPACE */:
                    return uri_1.URI.from({ scheme: network.Schemas.vscode, authority: 'defaultsettings', path: "/" + this._defaultWorkspaceSettingsUriCounter++ + "/workspaceSettings.json" });
                case 3 /* WORKSPACE_FOLDER */:
                    return uri_1.URI.from({ scheme: network.Schemas.vscode, authority: 'defaultsettings', path: "/" + this._defaultFolderSettingsUriCounter++ + "/resourceSettings.json" });
            }
            return uri_1.URI.from({ scheme: network.Schemas.vscode, authority: 'defaultsettings', path: "/" + this._defaultUserSettingsUriCounter++ + "/settings.json" });
        };
        PreferencesService.prototype.getPreferencesEditorInputName = function (target, resource) {
            var name = preferences_1.getSettingsTargetName(target, resource, this.contextService);
            return target === 3 /* WORKSPACE_FOLDER */ ? nls.localize('folderSettingsName', "{0} (Folder Settings)", name) : name;
        };
        PreferencesService.prototype.getOrCreateEditableSettingsEditorInput = function (target, resource) {
            var _this = this;
            return this.createSettingsIfNotExists(target, resource)
                .then(function () { return _this.editorService.createInput({ resource: resource }); });
        };
        PreferencesService.prototype.createEditableSettingsEditorModel = function (configurationTarget, resource) {
            var _this = this;
            var settingsUri = this.getEditableSettingsURI(configurationTarget, resource);
            if (settingsUri) {
                var workspace = this.contextService.getWorkspace();
                if (workspace.configuration && workspace.configuration.toString() === settingsUri.toString()) {
                    return this.textModelResolverService.createModelReference(settingsUri)
                        .then(function (reference) { return _this.instantiationService.createInstance(preferencesModels_1.WorkspaceConfigurationEditorModel, reference, configurationTarget); });
                }
                return this.textModelResolverService.createModelReference(settingsUri)
                    .then(function (reference) { return _this.instantiationService.createInstance(preferencesModels_1.SettingsEditorModel, reference, configurationTarget); });
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        PreferencesService.prototype.createDefaultSettingsEditorModel = function (defaultSettingsUri) {
            var _this = this;
            return this.textModelResolverService.createModelReference(defaultSettingsUri)
                .then(function (reference) {
                var target = _this.getConfigurationTargetFromDefaultSettingsResource(defaultSettingsUri);
                return _this.instantiationService.createInstance(preferencesModels_1.DefaultSettingsEditorModel, defaultSettingsUri, reference, _this.getDefaultSettings(target));
            });
        };
        PreferencesService.prototype.getDefaultSettings = function (target) {
            if (target === 2 /* WORKSPACE */) {
                if (!this._defaultWorkspaceSettingsContentModel) {
                    this._defaultWorkspaceSettingsContentModel = new preferencesModels_1.DefaultSettings(this.getMostCommonlyUsedSettings(), target);
                }
                return this._defaultWorkspaceSettingsContentModel;
            }
            if (target === 3 /* WORKSPACE_FOLDER */) {
                if (!this._defaultFolderSettingsContentModel) {
                    this._defaultFolderSettingsContentModel = new preferencesModels_1.DefaultSettings(this.getMostCommonlyUsedSettings(), target);
                }
                return this._defaultFolderSettingsContentModel;
            }
            if (!this._defaultUserSettingsContentModel) {
                this._defaultUserSettingsContentModel = new preferencesModels_1.DefaultSettings(this.getMostCommonlyUsedSettings(), target);
            }
            return this._defaultUserSettingsContentModel;
        };
        PreferencesService.prototype.getEditableSettingsURI = function (configurationTarget, resource) {
            switch (configurationTarget) {
                case 1 /* USER */:
                    return uri_1.URI.file(this.environmentService.appSettingsPath);
                case 2 /* WORKSPACE */:
                    if (this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
                        return null;
                    }
                    var workspace = this.contextService.getWorkspace();
                    return workspace.configuration || workspace.folders[0].toResource(preferences_1.FOLDER_SETTINGS_PATH);
                case 3 /* WORKSPACE_FOLDER */:
                    var folder = this.contextService.getWorkspaceFolder(resource);
                    return folder ? folder.toResource(preferences_1.FOLDER_SETTINGS_PATH) : null;
            }
            return null;
        };
        PreferencesService.prototype.createSettingsIfNotExists = function (target, resource) {
            var _this = this;
            if (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ && target === 2 /* WORKSPACE */) {
                return this.fileService.resolveContent(this.contextService.getWorkspace().configuration)
                    .then(function (content) {
                    if (Object.keys(json_1.parse(content.value)).indexOf('settings') === -1) {
                        return _this.jsonEditingService.write(resource, { key: 'settings', value: {} }, true).then(null, function () { });
                    }
                    return null;
                });
            }
            return this.createIfNotExists(resource, emptyEditableSettingsContent).then(function () { });
        };
        PreferencesService.prototype.createIfNotExists = function (resource, contents) {
            var _this = this;
            return this.fileService.resolveContent(resource, { acceptTextOnly: true }).then(null, function (error) {
                if (error.fileOperationResult === 2 /* FILE_NOT_FOUND */) {
                    return _this.fileService.updateContent(resource, contents).then(null, function (error) {
                        return winjs_base_1.TPromise.wrapError(new Error(nls.localize('fail.createSettings', "Unable to create '{0}' ({1}).", _this.labelService.getUriLabel(resource, { relative: true }), error)));
                    });
                }
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        PreferencesService.prototype.getMostCommonlyUsedSettings = function () {
            return [
                'files.autoSave',
                'editor.fontSize',
                'editor.fontFamily',
                'editor.tabSize',
                'editor.renderWhitespace',
                'editor.cursorStyle',
                'editor.multiCursorModifier',
                'editor.insertSpaces',
                'editor.wordWrap',
                'files.exclude',
                'files.associations'
            ];
        };
        PreferencesService.prototype.getPosition = function (language, settingsModel, codeEditor) {
            var _this = this;
            var languageKey = "[" + language + "]";
            var setting = settingsModel.getPreference(languageKey);
            var model = codeEditor.getModel();
            var configuration = this.configurationService.getValue();
            var eol = configuration.files && configuration.files.eol;
            if (setting) {
                if (setting.overrides.length) {
                    var lastSetting = setting.overrides[setting.overrides.length - 1];
                    var content = void 0;
                    if (lastSetting.valueRange.endLineNumber === setting.range.endLineNumber) {
                        content = ',' + eol + this.spaces(2, configuration.editor) + eol + this.spaces(1, configuration.editor);
                    }
                    else {
                        content = ',' + eol + this.spaces(2, configuration.editor);
                    }
                    var editOperation = editOperation_1.EditOperation.insert(new position_1.Position(lastSetting.valueRange.endLineNumber, lastSetting.valueRange.endColumn), content);
                    model.pushEditOperations([], [editOperation], function () { return []; });
                    return winjs_base_1.TPromise.as({ lineNumber: lastSetting.valueRange.endLineNumber + 1, column: model.getLineMaxColumn(lastSetting.valueRange.endLineNumber + 1) });
                }
                return winjs_base_1.TPromise.as({ lineNumber: setting.valueRange.startLineNumber, column: setting.valueRange.startColumn + 1 });
            }
            return this.configurationService.updateValue(languageKey, {}, 1 /* USER */)
                .then(function () {
                setting = settingsModel.getPreference(languageKey);
                var content = eol + _this.spaces(2, configuration.editor) + eol + _this.spaces(1, configuration.editor);
                var editOperation = editOperation_1.EditOperation.insert(new position_1.Position(setting.valueRange.endLineNumber, setting.valueRange.endColumn - 1), content);
                model.pushEditOperations([], [editOperation], function () { return []; });
                var lineNumber = setting.valueRange.endLineNumber + 1;
                settingsModel.dispose();
                return { lineNumber: lineNumber, column: model.getLineMaxColumn(lineNumber) };
            });
        };
        PreferencesService.prototype.spaces = function (count, _a) {
            var tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            return insertSpaces ? strings.repeat(' ', tabSize * count) : strings.repeat('\t', count);
        };
        PreferencesService.prototype.dispose = function () {
            this._onDispose.fire();
            _super.prototype.dispose.call(this);
        };
        PreferencesService = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, editorGroupsService_1.IEditorGroupsService),
            __param(2, files_1.IFileService),
            __param(3, configuration_1.IWorkspaceConfigurationService),
            __param(4, notification_1.INotificationService),
            __param(5, workspace_1.IWorkspaceContextService),
            __param(6, instantiation_1.IInstantiationService),
            __param(7, environment_1.IEnvironmentService),
            __param(8, telemetry_1.ITelemetryService),
            __param(9, resolverService_1.ITextModelService),
            __param(10, keybinding_1.IKeybindingService),
            __param(11, modelService_1.IModelService),
            __param(12, jsonEditing_1.IJSONEditingService),
            __param(13, modeService_1.IModeService),
            __param(14, label_1.ILabelService)
        ], PreferencesService);
        return PreferencesService;
    }(lifecycle_1.Disposable));
    exports.PreferencesService = PreferencesService;
});

define(__m[207/*vs/workbench/services/progress/common/progress*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IProgressService2 = instantiation_1.createDecorator('progressService2');
});










define(__m[363/*vs/workbench/services/search/node/searchHistoryService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,44/*vs/platform/storage/common/storage*/]), function (require, exports, event_1, storage_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchHistoryService = /** @class */ (function () {
        function SearchHistoryService(storageService) {
            this.storageService = storageService;
            this._onDidClearHistory = new event_1.Emitter();
            this.onDidClearHistory = this._onDidClearHistory.event;
        }
        SearchHistoryService.prototype.clearHistory = function () {
            this.storageService.remove(SearchHistoryService.SEARCH_HISTORY_KEY, 1 /* WORKSPACE */);
            this._onDidClearHistory.fire();
        };
        SearchHistoryService.prototype.load = function () {
            var result;
            var raw = this.storageService.get(SearchHistoryService.SEARCH_HISTORY_KEY, 1 /* WORKSPACE */);
            if (raw) {
                try {
                    result = JSON.parse(raw);
                }
                catch (e) {
                    // Invalid data
                }
            }
            return result || {};
        };
        SearchHistoryService.prototype.save = function (history) {
            this.storageService.store(SearchHistoryService.SEARCH_HISTORY_KEY, JSON.stringify(history), 1 /* WORKSPACE */);
        };
        SearchHistoryService.SEARCH_HISTORY_KEY = 'workbench.search.history';
        SearchHistoryService = __decorate([
            __param(0, storage_1.IStorageService)
        ], SearchHistoryService);
        return SearchHistoryService;
    }());
    exports.SearchHistoryService = SearchHistoryService;
});

define(__m[27/*vs/workbench/services/textfile/common/textfiles*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, instantiation_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextFileModelChangeEvent = /** @class */ (function () {
        function TextFileModelChangeEvent(model, kind) {
            this._resource = model.getResource();
            this._kind = kind;
        }
        Object.defineProperty(TextFileModelChangeEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileModelChangeEvent.prototype, "kind", {
            get: function () {
                return this._kind;
            },
            enumerable: true,
            configurable: true
        });
        return TextFileModelChangeEvent;
    }());
    exports.TextFileModelChangeEvent = TextFileModelChangeEvent;
    exports.TEXT_FILE_SERVICE_ID = 'textFileService';
    exports.AutoSaveContext = new contextkey_1.RawContextKey('config.files.autoSave', undefined);
    exports.ITextFileService = instantiation_1.createDecorator(exports.TEXT_FILE_SERVICE_ID);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[149/*vs/workbench/browser/parts/editor/textEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,38/*vs/base/common/objects*/,29/*vs/base/common/types*/,212/*vs/editor/browser/widget/codeEditorWidget*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,44/*vs/platform/storage/common/storage*/,3/*vs/platform/instantiation/common/instantiation*/,32/*vs/platform/telemetry/common/telemetry*/,14/*vs/platform/theme/common/themeService*/,27/*vs/workbench/services/textfile/common/textfiles*/,88/*vs/editor/common/services/resourceConfiguration*/,45/*vs/editor/browser/editorBrowser*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,42/*vs/platform/windows/common/windows*/]), function (require, exports, nls, objects, types, codeEditorWidget_1, baseEditor_1, storage_1, instantiation_1, telemetry_1, themeService_1, textfiles_1, resourceConfiguration_1, editorBrowser_1, editorGroupsService_1, editorService_1, windows_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TEXT_EDITOR_VIEW_STATE_PREFERENCE_KEY = 'textEditorViewState';
    /**
     * The base class of editors that leverage the text editor for the editing experience. This class is only intended to
     * be subclassed and not instantiated.
     */
    var BaseTextEditor = /** @class */ (function (_super) {
        __extends(BaseTextEditor, _super);
        function BaseTextEditor(id, telemetryService, _instantiationService, storageService, _configurationService, themeService, _textFileService, editorService, editorGroupService, windowService) {
            var _this = _super.call(this, id, telemetryService, themeService) || this;
            _this._instantiationService = _instantiationService;
            _this._configurationService = _configurationService;
            _this.themeService = themeService;
            _this._textFileService = _textFileService;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.windowService = windowService;
            _this.editorMemento = _this.getEditorMemento(storageService, editorGroupService, TEXT_EDITOR_VIEW_STATE_PREFERENCE_KEY, 100);
            _this._register(_this.configurationService.onDidChangeConfiguration(function (e) { return _this.handleConfigurationChangeEvent(_this.configurationService.getValue(_this.getResource())); }));
            return _this;
        }
        Object.defineProperty(BaseTextEditor.prototype, "instantiationService", {
            get: function () {
                return this._instantiationService;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTextEditor.prototype, "configurationService", {
            get: function () {
                return this._configurationService;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseTextEditor.prototype, "textFileService", {
            get: function () {
                return this._textFileService;
            },
            enumerable: true,
            configurable: true
        });
        BaseTextEditor.prototype.handleConfigurationChangeEvent = function (configuration) {
            if (this.isVisible()) {
                this.updateEditorConfiguration(configuration);
            }
            else {
                this.hasPendingConfigurationChange = true;
            }
        };
        BaseTextEditor.prototype.consumePendingConfigurationChangeEvent = function () {
            if (this.hasPendingConfigurationChange) {
                this.updateEditorConfiguration();
                this.hasPendingConfigurationChange = false;
            }
        };
        BaseTextEditor.prototype.computeConfiguration = function (configuration) {
            // Specific editor options always overwrite user configuration
            var editorConfiguration = types.isObject(configuration.editor) ? objects.deepClone(configuration.editor) : Object.create(null);
            objects.assign(editorConfiguration, this.getConfigurationOverrides());
            // ARIA label
            editorConfiguration.ariaLabel = this.computeAriaLabel();
            return editorConfiguration;
        };
        BaseTextEditor.prototype.computeAriaLabel = function () {
            var ariaLabel = this.getAriaLabel();
            // Apply group information to help identify in which group we are
            if (ariaLabel) {
                if (this.group) {
                    ariaLabel = nls.localize('editorLabelWithGroup', "{0}, {1}.", ariaLabel, this.group.label);
                }
            }
            return ariaLabel;
        };
        BaseTextEditor.prototype.getConfigurationOverrides = function () {
            var overrides = {};
            objects.assign(overrides, {
                overviewRulerLanes: 3,
                lineNumbersMinChars: 3,
                fixedOverflowWidgets: true
            });
            return overrides;
        };
        BaseTextEditor.prototype.createEditor = function (parent) {
            var _this = this;
            // Editor for Text
            this._editorContainer = parent;
            this.editorControl = this._register(this.createEditorControl(parent, this.computeConfiguration(this.configurationService.getValue(this.getResource()))));
            // Model & Language changes
            var codeEditor = editorBrowser_1.getCodeEditor(this.editorControl);
            if (codeEditor) {
                this._register(codeEditor.onDidChangeModelLanguage(function (e) { return _this.updateEditorConfiguration(); }));
                this._register(codeEditor.onDidChangeModel(function (e) { return _this.updateEditorConfiguration(); }));
            }
            // Application & Editor focus change to respect auto save settings
            if (editorBrowser_1.isCodeEditor(this.editorControl)) {
                this._register(this.editorControl.onDidBlurEditorWidget(function () { return _this.onEditorFocusLost(); }));
            }
            else if (editorBrowser_1.isDiffEditor(this.editorControl)) {
                this._register(this.editorControl.getOriginalEditor().onDidBlurEditorWidget(function () { return _this.onEditorFocusLost(); }));
                this._register(this.editorControl.getModifiedEditor().onDidBlurEditorWidget(function () { return _this.onEditorFocusLost(); }));
            }
            this._register(this.editorService.onDidActiveEditorChange(function () { return _this.onEditorFocusLost(); }));
            this._register(this.windowService.onDidChangeFocus(function (focused) { return _this.onWindowFocusChange(focused); }));
        };
        BaseTextEditor.prototype.onEditorFocusLost = function () {
            this.maybeTriggerSaveAll(3 /* FOCUS_CHANGE */);
        };
        BaseTextEditor.prototype.onWindowFocusChange = function (focused) {
            if (!focused) {
                this.maybeTriggerSaveAll(4 /* WINDOW_CHANGE */);
            }
        };
        BaseTextEditor.prototype.maybeTriggerSaveAll = function (reason) {
            var mode = this.textFileService.getAutoSaveMode();
            //Determineifweneedtosaveall.Incaseofawindowfocuschangewealsosaveifautosavemode
            //isconfiguredtobeON_FOCUS_CHANGE(editorfocuschange)
            if ((reason === 4 /* WINDOW_CHANGE */ && (mode === 3 /* ON_FOCUS_CHANGE */ || mode === 4 /* ON_WINDOW_CHANGE */)) ||
                (reason === 3 /* FOCUS_CHANGE */ && mode === 3 /* ON_FOCUS_CHANGE */)) {
                if (this.textFileService.isDirty()) {
                    this.textFileService.saveAll(void 0, { reason: reason });
                }
            }
        };
        /**
         * This method creates and returns the text editor control to be used. Subclasses can override to
         * provide their own editor control that should be used (e.g. a DiffEditor).
         *
         * The passed in configuration object should be passed to the editor control when creating it.
         */
        BaseTextEditor.prototype.createEditorControl = function (parent, configuration) {
            // Use a getter for the instantiation service since some subclasses might use scoped instantiation services
            return this.instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, parent, configuration, {});
        };
        BaseTextEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            return _super.prototype.setInput.call(this, input, options, token).then(function () {
                // Update editor options after having set the input. We do this because there can be
                // editor input specific options (e.g. an ARIA label depending on the input showing)
                _this.updateEditorConfiguration();
                _this._editorContainer.setAttribute('aria-label', _this.computeAriaLabel());
            });
        };
        BaseTextEditor.prototype.setEditorVisible = function (visible, group) {
            // Pass on to Editor
            if (visible) {
                this.consumePendingConfigurationChangeEvent();
                this.editorControl.onVisible();
            }
            else {
                this.editorControl.onHide();
            }
            _super.prototype.setEditorVisible.call(this, visible, group);
        };
        BaseTextEditor.prototype.focus = function () {
            this.editorControl.focus();
        };
        BaseTextEditor.prototype.layout = function (dimension) {
            // Pass on to Editor
            this.editorControl.layout(dimension);
        };
        BaseTextEditor.prototype.getControl = function () {
            return this.editorControl;
        };
        /**
         * Saves the text editor view state for the given resource.
         */
        BaseTextEditor.prototype.saveTextEditorViewState = function (resource) {
            var editorViewState = this.retrieveTextEditorViewState(resource);
            if (!editorViewState) {
                return;
            }
            this.editorMemento.saveState(this.group, resource, editorViewState);
        };
        BaseTextEditor.prototype.retrieveTextEditorViewState = function (resource) {
            var control = this.getControl();
            var model = control.getModel();
            if (!model) {
                return null; // view state always needs a model
            }
            var modelUri = model.uri;
            if (!modelUri) {
                return null; // model URI is needed to make sure we save the view state correctly
            }
            if (modelUri.toString() !== resource.toString()) {
                return null; // prevent saving view state for a model that is not the expected one
            }
            return control.saveViewState();
        };
        /**
         * Clears the text editor view state for the given resources.
         */
        BaseTextEditor.prototype.clearTextEditorViewState = function (resources, group) {
            var _this = this;
            resources.forEach(function (resource) {
                _this.editorMemento.clearState(resource, group);
            });
        };
        /**
         * Loads the text editor view state for the given resource and returns it.
         */
        BaseTextEditor.prototype.loadTextEditorViewState = function (resource) {
            return this.editorMemento.loadState(this.group, resource);
        };
        BaseTextEditor.prototype.updateEditorConfiguration = function (configuration) {
            if (configuration === void 0) { configuration = this.configurationService.getValue(this.getResource()); }
            if (!this.editorControl) {
                return;
            }
            var editorConfiguration = this.computeConfiguration(configuration);
            // Try to figure out the actual editor options that changed from the last time we updated the editor.
            // We do this so that we are not overwriting some dynamic editor settings (e.g. word wrap) that might
            // have been applied to the editor directly.
            var editorSettingsToApply = editorConfiguration;
            if (this.lastAppliedEditorOptions) {
                editorSettingsToApply = objects.distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
            }
            if (Object.keys(editorSettingsToApply).length > 0) {
                this.lastAppliedEditorOptions = editorConfiguration;
                this.editorControl.updateOptions(editorSettingsToApply);
            }
        };
        BaseTextEditor.prototype.getResource = function () {
            var codeEditor = editorBrowser_1.getCodeEditor(this.editorControl);
            if (codeEditor) {
                var model = codeEditor.getModel();
                if (model) {
                    return model.uri;
                }
            }
            if (this.input) {
                return this.input.getResource();
            }
            return null;
        };
        BaseTextEditor.prototype.dispose = function () {
            this.lastAppliedEditorOptions = void 0;
            _super.prototype.dispose.call(this);
        };
        BaseTextEditor = __decorate([
            __param(1, telemetry_1.ITelemetryService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, storage_1.IStorageService),
            __param(4, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(5, themeService_1.IThemeService),
            __param(6, textfiles_1.ITextFileService),
            __param(7, editorService_1.IEditorService),
            __param(8, editorGroupsService_1.IEditorGroupsService),
            __param(9, windows_1.IWindowService)
        ], BaseTextEditor);
        return BaseTextEditor;
    }(baseEditor_1.BaseEditor));
    exports.BaseTextEditor = BaseTextEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[210/*vs/workbench/browser/parts/editor/textDiffEditor*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,38/*vs/base/common/objects*/,29/*vs/base/common/types*/,149/*vs/workbench/browser/parts/editor/textEditor*/,13/*vs/workbench/common/editor*/,93/*vs/workbench/common/editor/resourceEditorInput*/,110/*vs/workbench/common/editor/diffEditorInput*/,367/*vs/editor/browser/widget/diffNavigator*/,446/*vs/editor/browser/widget/diffEditorWidget*/,187/*vs/workbench/common/editor/textDiffEditorModel*/,32/*vs/platform/telemetry/common/telemetry*/,44/*vs/platform/storage/common/storage*/,88/*vs/editor/common/services/resourceConfiguration*/,3/*vs/platform/instantiation/common/instantiation*/,14/*vs/platform/theme/common/themeService*/,27/*vs/workbench/services/textfile/common/textfiles*/,4/*vs/base/common/lifecycle*/,9/*vs/platform/registry/common/platform*/,12/*vs/base/common/uri*/,6/*vs/base/common/event*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,42/*vs/platform/windows/common/windows*/]), function (require, exports, winjs_base_1, nls, objects, types, textEditor_1, editor_1, resourceEditorInput_1, diffEditorInput_1, diffNavigator_1, diffEditorWidget_1, textDiffEditorModel_1, telemetry_1, storage_1, resourceConfiguration_1, instantiation_1, themeService_1, textfiles_1, lifecycle_1, platform_1, uri_1, event_1, editorGroupsService_1, editorService_1, baseEditor_1, windows_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The text editor that leverages the diff text editor for the editing experience.
     */
    var TextDiffEditor = /** @class */ (function (_super) {
        __extends(TextDiffEditor, _super);
        function TextDiffEditor(telemetryService, instantiationService, storageService, configurationService, editorService, themeService, editorGroupService, textFileService, windowService) {
            var _this = _super.call(this, TextDiffEditor.ID, telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorService, editorGroupService, windowService) || this;
            _this.diffNavigatorDisposables = [];
            return _this;
        }
        TextDiffEditor.prototype.getEditorMemento = function (storageService, editorGroupService, key, limit) {
            if (limit === void 0) { limit = 10; }
            return new baseEditor_1.EditorMemento(this.getId(), key, Object.create(null), limit, editorGroupService); // do not persist in storage as diff editors are never persisted
        };
        TextDiffEditor.prototype.getTitle = function () {
            if (this.input) {
                return this.input.getName();
            }
            return nls.localize('textDiffEditor', "Text Diff Editor");
        };
        TextDiffEditor.prototype.createEditorControl = function (parent, configuration) {
            return this.instantiationService.createInstance(diffEditorWidget_1.DiffEditorWidget, parent, configuration);
        };
        TextDiffEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            // Dispose previous diff navigator
            this.diffNavigatorDisposables = lifecycle_1.dispose(this.diffNavigatorDisposables);
            // Remember view settings if input changes
            this.saveTextDiffEditorViewState(this.input);
            // Set input and resolve
            return _super.prototype.setInput.call(this, input, options, token).then(function () {
                return input.resolve().then(function (resolvedModel) {
                    // Check for cancellation
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    // Assert Model Instance
                    if (!(resolvedModel instanceof textDiffEditorModel_1.TextDiffEditorModel) && _this.openAsBinary(input, options)) {
                        return void 0;
                    }
                    // Set Editor Model
                    var diffEditor = _this.getControl();
                    var resolvedDiffEditorModel = resolvedModel;
                    diffEditor.setModel(resolvedDiffEditorModel.textDiffEditorModel);
                    // Apply Options from TextOptions
                    var optionsGotApplied = false;
                    if (options && types.isFunction(options.apply)) {
                        optionsGotApplied = options.apply(diffEditor, 1 /* Immediate */);
                    }
                    // Otherwise restore View State
                    var hasPreviousViewState = false;
                    if (!optionsGotApplied) {
                        hasPreviousViewState = _this.restoreTextDiffEditorViewState(input);
                    }
                    // Diff navigator
                    _this.diffNavigator = new diffNavigator_1.DiffNavigator(diffEditor, {
                        alwaysRevealFirst: !optionsGotApplied && !hasPreviousViewState // only reveal first change if we had no options or viewstate
                    });
                    _this.diffNavigatorDisposables.push(_this.diffNavigator);
                    // Readonly flag
                    diffEditor.updateOptions({ readOnly: resolvedDiffEditorModel.isReadonly() });
                }, function (error) {
                    // In case we tried to open a file and the response indicates that this is not a text file, fallback to binary diff.
                    if (_this.isFileBinaryError(error) && _this.openAsBinary(input, options)) {
                        return null;
                    }
                    // Otherwise make sure the error bubbles up
                    return winjs_base_1.TPromise.wrapError(error);
                });
            });
        };
        TextDiffEditor.prototype.setOptions = function (options) {
            var textOptions = options;
            if (textOptions && types.isFunction(textOptions.apply)) {
                textOptions.apply(this.getControl(), 0 /* Smooth */);
            }
        };
        TextDiffEditor.prototype.restoreTextDiffEditorViewState = function (input) {
            if (input instanceof diffEditorInput_1.DiffEditorInput) {
                var resource = this.toDiffEditorViewStateResource(input);
                if (resource) {
                    var viewState = this.loadTextEditorViewState(resource);
                    if (viewState) {
                        this.getControl().restoreViewState(viewState);
                        return true;
                    }
                }
            }
            return false;
        };
        TextDiffEditor.prototype.openAsBinary = function (input, options) {
            if (input instanceof diffEditorInput_1.DiffEditorInput) {
                var originalInput = input.originalInput;
                var modifiedInput = input.modifiedInput;
                var binaryDiffInput = new diffEditorInput_1.DiffEditorInput(input.getName(), input.getDescription(), originalInput, modifiedInput, true);
                // Forward binary flag to input if supported
                var fileInputFactory = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).getFileInputFactory();
                if (fileInputFactory.isFileInput(originalInput)) {
                    originalInput.setForceOpenAsBinary();
                }
                if (fileInputFactory.isFileInput(modifiedInput)) {
                    modifiedInput.setForceOpenAsBinary();
                }
                this.editorService.openEditor(binaryDiffInput, options, this.group);
                return true;
            }
            return false;
        };
        TextDiffEditor.prototype.computeConfiguration = function (configuration) {
            var editorConfiguration = _super.prototype.computeConfiguration.call(this, configuration);
            // Handle diff editor specially by merging in diffEditor configuration
            if (types.isObject(configuration.diffEditor)) {
                objects.mixin(editorConfiguration, configuration.diffEditor);
            }
            return editorConfiguration;
        };
        TextDiffEditor.prototype.getConfigurationOverrides = function () {
            var options = _super.prototype.getConfigurationOverrides.call(this);
            options.readOnly = this.isReadOnly();
            options.lineDecorationsWidth = '2ch';
            return options;
        };
        TextDiffEditor.prototype.getAriaLabel = function () {
            var ariaLabel;
            var inputName = this.input && this.input.getName();
            if (this.isReadOnly()) {
                ariaLabel = inputName ? nls.localize('readonlyEditorWithInputAriaLabel', "{0}. Readonly text compare editor.", inputName) : nls.localize('readonlyEditorAriaLabel', "Readonly text compare editor.");
            }
            else {
                ariaLabel = inputName ? nls.localize('editableEditorWithInputAriaLabel', "{0}. Text file compare editor.", inputName) : nls.localize('editableEditorAriaLabel', "Text file compare editor.");
            }
            return ariaLabel;
        };
        TextDiffEditor.prototype.isReadOnly = function () {
            var input = this.input;
            if (input instanceof diffEditorInput_1.DiffEditorInput) {
                var modifiedInput = input.modifiedInput;
                return modifiedInput instanceof resourceEditorInput_1.ResourceEditorInput;
            }
            return false;
        };
        TextDiffEditor.prototype.isFileBinaryError = function (error) {
            var _this = this;
            if (types.isArray(error)) {
                var errors = error;
                return errors.some(function (e) { return _this.isFileBinaryError(e); });
            }
            return error.fileOperationResult === 0 /* FILE_IS_BINARY */;
        };
        TextDiffEditor.prototype.clearInput = function () {
            // Dispose previous diff navigator
            this.diffNavigatorDisposables = lifecycle_1.dispose(this.diffNavigatorDisposables);
            // Keep editor view state in settings to restore when coming back
            this.saveTextDiffEditorViewState(this.input);
            // Clear Model
            this.getControl().setModel(null);
            // Pass to super
            _super.prototype.clearInput.call(this);
        };
        TextDiffEditor.prototype.getDiffNavigator = function () {
            return this.diffNavigator;
        };
        TextDiffEditor.prototype.getControl = function () {
            return _super.prototype.getControl.call(this);
        };
        TextDiffEditor.prototype.loadTextEditorViewState = function (resource) {
            return _super.prototype.loadTextEditorViewState.call(this, resource); // overridden for text diff editor support
        };
        TextDiffEditor.prototype.saveTextDiffEditorViewState = function (input) {
            var _this = this;
            if (!(input instanceof diffEditorInput_1.DiffEditorInput)) {
                return; // only supported for diff editor inputs
            }
            var resource = this.toDiffEditorViewStateResource(input);
            if (!resource) {
                return; // unable to retrieve input resource
            }
            // Clear view state if input is disposed
            if (input.isDisposed()) {
                _super.prototype.clearTextEditorViewState.call(this, [resource]);
            }
            // Otherwise save it
            else {
                _super.prototype.saveTextEditorViewState.call(this, resource);
                // Make sure to clean up when the input gets disposed
                event_1.once(input.onDispose)(function () {
                    _super.prototype.clearTextEditorViewState.call(_this, [resource]);
                });
            }
        };
        TextDiffEditor.prototype.retrieveTextEditorViewState = function (resource) {
            return this.retrieveTextDiffEditorViewState(resource); // overridden for text diff editor support
        };
        TextDiffEditor.prototype.retrieveTextDiffEditorViewState = function (resource) {
            var control = this.getControl();
            var model = control.getModel();
            if (!model || !model.modified || !model.original) {
                return null; // view state always needs a model
            }
            var modelUri = this.toDiffEditorViewStateResource(model);
            if (!modelUri) {
                return null; // model URI is needed to make sure we save the view state correctly
            }
            if (modelUri.toString() !== resource.toString()) {
                return null; // prevent saving view state for a model that is not the expected one
            }
            return control.saveViewState();
        };
        TextDiffEditor.prototype.toDiffEditorViewStateResource = function (modelOrInput) {
            var original;
            var modified;
            if (modelOrInput instanceof diffEditorInput_1.DiffEditorInput) {
                original = modelOrInput.originalInput.getResource();
                modified = modelOrInput.modifiedInput.getResource();
            }
            else {
                original = modelOrInput.original.uri;
                modified = modelOrInput.modified.uri;
            }
            if (!original || !modified) {
                return null;
            }
            // create a URI that is the Base64 concatenation of original + modified resource
            return uri_1.URI.from({ scheme: 'diff', path: "" + btoa(original.toString()) + btoa(modified.toString()) });
        };
        TextDiffEditor.prototype.dispose = function () {
            this.diffNavigatorDisposables = lifecycle_1.dispose(this.diffNavigatorDisposables);
            _super.prototype.dispose.call(this);
        };
        TextDiffEditor.ID = editor_1.TEXT_DIFF_EDITOR_ID;
        TextDiffEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, storage_1.IStorageService),
            __param(3, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(4, editorService_1.IEditorService),
            __param(5, themeService_1.IThemeService),
            __param(6, editorGroupsService_1.IEditorGroupsService),
            __param(7, textfiles_1.ITextFileService),
            __param(8, windows_1.IWindowService)
        ], TextDiffEditor);
        return TextDiffEditor;
    }(textEditor_1.BaseTextEditor));
    exports.TextDiffEditor = TextDiffEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[104/*vs/workbench/browser/parts/editor/editorCommands*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,29/*vs/base/common/types*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,13/*vs/workbench/common/editor*/,11/*vs/workbench/services/editor/common/editorService*/,114/*vs/editor/common/editorContextKeys*/,210/*vs/workbench/browser/parts/editor/textDiffEditor*/,65/*vs/base/common/keyCodes*/,5/*vs/base/common/winjs.base*/,12/*vs/base/common/uri*/,46/*vs/platform/quickOpen/common/quickOpen*/,51/*vs/platform/list/browser/listService*/,240/*vs/base/browser/ui/list/listWidget*/,19/*vs/base/common/arrays*/,33/*vs/workbench/services/group/common/editorGroupsService*/,10/*vs/platform/contextkey/common/contextkey*/,7/*vs/platform/configuration/common/configuration*/,37/*vs/platform/commands/common/commands*/,23/*vs/platform/actions/common/actions*/,28/*vs/platform/notification/common/notification*/]), function (require, exports, nls, types, keybindingsRegistry_1, editor_1, editorService_1, editorContextKeys_1, textDiffEditor_1, keyCodes_1, winjs_base_1, uri_1, quickOpen_1, listService_1, listWidget_1, arrays_1, editorGroupsService_1, contextkey_1, configuration_1, commands_1, actions_1, notification_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CLOSE_SAVED_EDITORS_COMMAND_ID = 'workbench.action.closeUnmodifiedEditors';
    exports.CLOSE_EDITORS_IN_GROUP_COMMAND_ID = 'workbench.action.closeEditorsInGroup';
    exports.CLOSE_EDITORS_AND_GROUP_COMMAND_ID = 'workbench.action.closeEditorsAndGroup';
    exports.CLOSE_EDITORS_TO_THE_RIGHT_COMMAND_ID = 'workbench.action.closeEditorsToTheRight';
    exports.CLOSE_EDITOR_COMMAND_ID = 'workbench.action.closeActiveEditor';
    exports.CLOSE_EDITOR_GROUP_COMMAND_ID = 'workbench.action.closeGroup';
    exports.CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID = 'workbench.action.closeOtherEditors';
    exports.MOVE_ACTIVE_EDITOR_COMMAND_ID = 'moveActiveEditor';
    exports.LAYOUT_EDITOR_GROUPS_COMMAND_ID = 'layoutEditorGroups';
    exports.KEEP_EDITOR_COMMAND_ID = 'workbench.action.keepEditor';
    exports.SHOW_EDITORS_IN_GROUP = 'workbench.action.showEditorsInGroup';
    exports.TOGGLE_DIFF_SIDE_BY_SIDE = 'toggle.diff.renderSideBySide';
    exports.GOTO_NEXT_CHANGE = 'workbench.action.compareEditor.nextChange';
    exports.GOTO_PREVIOUS_CHANGE = 'workbench.action.compareEditor.previousChange';
    exports.TOGGLE_DIFF_IGNORE_TRIM_WHITESPACE = 'toggle.diff.ignoreTrimWhitespace';
    exports.SPLIT_EDITOR_UP = 'workbench.action.splitEditorUp';
    exports.SPLIT_EDITOR_DOWN = 'workbench.action.splitEditorDown';
    exports.SPLIT_EDITOR_LEFT = 'workbench.action.splitEditorLeft';
    exports.SPLIT_EDITOR_RIGHT = 'workbench.action.splitEditorRight';
    exports.NAVIGATE_ALL_EDITORS_GROUP_PREFIX = 'edt ';
    exports.NAVIGATE_IN_ACTIVE_GROUP_PREFIX = 'edt active ';
    exports.OPEN_EDITOR_AT_INDEX_COMMAND_ID = 'workbench.action.openEditorAtIndex';
    var isActiveEditorMoveArg = function (arg) {
        if (!types.isObject(arg)) {
            return false;
        }
        if (!types.isString(arg.to)) {
            return false;
        }
        if (!types.isUndefined(arg.by) && !types.isString(arg.by)) {
            return false;
        }
        if (!types.isUndefined(arg.value) && !types.isNumber(arg.value)) {
            return false;
        }
        return true;
    };
    function registerActiveEditorMoveCommand() {
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.MOVE_ACTIVE_EDITOR_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: editorContextKeys_1.EditorContextKeys.editorTextFocus,
            primary: null,
            handler: function (accessor, args) { return moveActiveEditor(args, accessor); },
            description: {
                description: nls.localize('editorCommand.activeEditorMove.description', "Move the active editor by tabs or groups"),
                args: [
                    {
                        name: nls.localize('editorCommand.activeEditorMove.arg.name', "Active editor move argument"),
                        description: nls.localize('editorCommand.activeEditorMove.arg.description', "Argument Properties:\n\t* 'to': String value providing where to move.\n\t* 'by': String value providing the unit for move (by tab or by group).\n\t* 'value': Number value providing how many positions or an absolute position to move."),
                        constraint: isActiveEditorMoveArg
                    }
                ]
            }
        });
    }
    function moveActiveEditor(args, accessor) {
        if (args === void 0) { args = Object.create(null); }
        args.to = args.to || 'right';
        args.by = args.by || 'tab';
        args.value = typeof args.value === 'number' ? args.value : 1;
        var activeControl = accessor.get(editorService_1.IEditorService).activeControl;
        if (activeControl) {
            switch (args.by) {
                case 'tab':
                    return moveActiveTab(args, activeControl, accessor);
                case 'group':
                    return moveActiveEditorToGroup(args, activeControl, accessor);
            }
        }
    }
    function moveActiveTab(args, control, accessor) {
        var group = control.group;
        var index = group.getIndexOfEditor(control.input);
        switch (args.to) {
            case 'first':
                index = 0;
                break;
            case 'last':
                index = group.count - 1;
                break;
            case 'left':
                index = index - args.value;
                break;
            case 'right':
                index = index + args.value;
                break;
            case 'center':
                index = Math.round(group.count / 2) - 1;
                break;
            case 'position':
                index = args.value - 1;
                break;
        }
        index = index < 0 ? 0 : index >= group.count ? group.count - 1 : index;
        group.moveEditor(control.input, group, { index: index });
    }
    function moveActiveEditorToGroup(args, control, accessor) {
        var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
        var configurationService = accessor.get(configuration_1.IConfigurationService);
        var sourceGroup = control.group;
        var targetGroup;
        switch (args.to) {
            case 'left':
                targetGroup = editorGroupService.findGroup({ direction: 2 /* LEFT */ }, sourceGroup);
                if (!targetGroup) {
                    targetGroup = editorGroupService.addGroup(sourceGroup, 2 /* LEFT */);
                }
                break;
            case 'right':
                targetGroup = editorGroupService.findGroup({ direction: 3 /* RIGHT */ }, sourceGroup);
                if (!targetGroup) {
                    targetGroup = editorGroupService.addGroup(sourceGroup, 3 /* RIGHT */);
                }
                break;
            case 'up':
                targetGroup = editorGroupService.findGroup({ direction: 0 /* UP */ }, sourceGroup);
                if (!targetGroup) {
                    targetGroup = editorGroupService.addGroup(sourceGroup, 0 /* UP */);
                }
                break;
            case 'down':
                targetGroup = editorGroupService.findGroup({ direction: 1 /* DOWN */ }, sourceGroup);
                if (!targetGroup) {
                    targetGroup = editorGroupService.addGroup(sourceGroup, 1 /* DOWN */);
                }
                break;
            case 'first':
                targetGroup = editorGroupService.findGroup({ location: 0 /* FIRST */ }, sourceGroup);
                break;
            case 'last':
                targetGroup = editorGroupService.findGroup({ location: 1 /* LAST */ }, sourceGroup);
                break;
            case 'previous':
                targetGroup = editorGroupService.findGroup({ location: 3 /* PREVIOUS */ }, sourceGroup);
                break;
            case 'next':
                targetGroup = editorGroupService.findGroup({ location: 2 /* NEXT */ }, sourceGroup);
                if (!targetGroup) {
                    targetGroup = editorGroupService.addGroup(sourceGroup, editorGroupsService_1.preferredSideBySideGroupDirection(configurationService));
                }
                break;
            case 'center':
                targetGroup = editorGroupService.getGroups(2 /* GRID_APPEARANCE */)[(editorGroupService.count / 2) - 1];
                break;
            case 'position':
                targetGroup = editorGroupService.getGroups(2 /* GRID_APPEARANCE */)[args.value - 1];
                break;
        }
        if (targetGroup) {
            sourceGroup.moveEditor(control.input, targetGroup);
            targetGroup.focus();
        }
    }
    function registerEditorGroupsLayoutCommand() {
        commands_1.CommandsRegistry.registerCommand(exports.LAYOUT_EDITOR_GROUPS_COMMAND_ID, function (accessor, args) {
            if (!args || typeof args !== 'object') {
                return;
            }
            var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
            editorGroupService.applyLayout(args);
        });
    }
    function mergeAllGroups(editorGroupService) {
        var target = editorGroupService.activeGroup;
        editorGroupService.getGroups(1 /* MOST_RECENTLY_ACTIVE */).forEach(function (group) {
            if (group === target) {
                return; // keep target
            }
            editorGroupService.mergeGroup(group, target);
        });
    }
    exports.mergeAllGroups = mergeAllGroups;
    function registerDiffEditorCommands() {
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.GOTO_NEXT_CHANGE,
            weight: 200 /* WorkbenchContrib */,
            when: editor_1.TextCompareEditorVisibleContext,
            primary: 512 /* Alt */ | 63 /* F5 */,
            handler: function (accessor) { return navigateInDiffEditor(accessor, true); }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.GOTO_PREVIOUS_CHANGE,
            weight: 200 /* WorkbenchContrib */,
            when: editor_1.TextCompareEditorVisibleContext,
            primary: 512 /* Alt */ | 1024 /* Shift */ | 63 /* F5 */,
            handler: function (accessor) { return navigateInDiffEditor(accessor, false); }
        });
        function navigateInDiffEditor(accessor, next) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var candidates = [editorService.activeControl].concat(editorService.visibleControls).filter(function (e) { return e instanceof textDiffEditor_1.TextDiffEditor; });
            if (candidates.length > 0) {
                next ? candidates[0].getDiffNavigator().next() : candidates[0].getDiffNavigator().previous();
            }
        }
        function toggleDiffSideBySide(accessor) {
            var configurationService = accessor.get(configuration_1.IConfigurationService);
            var newValue = !configurationService.getValue('diffEditor.renderSideBySide');
            configurationService.updateValue('diffEditor.renderSideBySide', newValue, 1 /* USER */);
        }
        function toggleDiffIgnoreTrimWhitespace(accessor) {
            var configurationService = accessor.get(configuration_1.IConfigurationService);
            var newValue = !configurationService.getValue('diffEditor.ignoreTrimWhitespace');
            configurationService.updateValue('diffEditor.ignoreTrimWhitespace', newValue, 1 /* USER */);
        }
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.TOGGLE_DIFF_SIDE_BY_SIDE,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: void 0,
            handler: function (accessor) { return toggleDiffSideBySide(accessor); }
        });
        // TODO@Ben remove me after a while
        commands_1.CommandsRegistry.registerCommand('toggle.diff.editorMode', function (accessor) {
            toggleDiffSideBySide(accessor);
            accessor.get(notification_1.INotificationService).warn(nls.localize('diffCommandDeprecation', "Command 'toggle.diff.editorMode' has been deprecated. Please use '{0}' instead.", exports.TOGGLE_DIFF_SIDE_BY_SIDE));
        });
        actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
            command: {
                id: exports.TOGGLE_DIFF_SIDE_BY_SIDE,
                title: {
                    value: nls.localize('toggleInlineView', "Toggle Inline View"),
                    original: 'Compare: Toggle Inline View'
                },
                category: nls.localize('compare', "Compare")
            },
            when: contextkey_1.ContextKeyExpr.has('textCompareEditorActive')
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.TOGGLE_DIFF_IGNORE_TRIM_WHITESPACE,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: void 0,
            handler: function (accessor) { return toggleDiffIgnoreTrimWhitespace(accessor); }
        });
    }
    function registerOpenEditorAtIndexCommands() {
        var openEditorAtIndex = function (accessor, editorIndex) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var activeControl = editorService.activeControl;
            if (activeControl) {
                var editor = activeControl.group.getEditor(editorIndex);
                if (editor) {
                    editorService.openEditor(editor);
                }
            }
        };
        // This command takes in the editor index number to open as an argument
        commands_1.CommandsRegistry.registerCommand({
            id: exports.OPEN_EDITOR_AT_INDEX_COMMAND_ID,
            handler: openEditorAtIndex
        });
        var _loop_1 = function (i) {
            var editorIndex = i;
            var visibleIndex = i + 1;
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
                id: exports.OPEN_EDITOR_AT_INDEX_COMMAND_ID + visibleIndex,
                weight: 200 /* WorkbenchContrib */,
                when: void 0,
                primary: 512 /* Alt */ | toKeyCode(visibleIndex),
                mac: { primary: 256 /* WinCtrl */ | toKeyCode(visibleIndex) },
                handler: function (accessor) { return openEditorAtIndex(accessor, editorIndex); }
            });
        };
        // Keybindings to focus a specific index in the tab folder if tabs are enabled
        for (var i = 0; i < 9; i++) {
            _loop_1(i);
        }
        function toKeyCode(index) {
            switch (index) {
                case 0: return 21 /* KEY_0 */;
                case 1: return 22 /* KEY_1 */;
                case 2: return 23 /* KEY_2 */;
                case 3: return 24 /* KEY_3 */;
                case 4: return 25 /* KEY_4 */;
                case 5: return 26 /* KEY_5 */;
                case 6: return 27 /* KEY_6 */;
                case 7: return 28 /* KEY_7 */;
                case 8: return 29 /* KEY_8 */;
                case 9: return 30 /* KEY_9 */;
            }
            return void 0;
        }
    }
    function registerFocusEditorGroupAtIndexCommands() {
        var _loop_2 = function (groupIndex) {
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
                id: toCommandId(groupIndex),
                weight: 200 /* WorkbenchContrib */,
                when: void 0,
                primary: 2048 /* CtrlCmd */ | toKeyCode(groupIndex),
                handler: function (accessor) {
                    var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                    var configurationService = accessor.get(configuration_1.IConfigurationService);
                    // To keep backwards compatibility (pre-grid), allow to focus a group
                    // that does not exist as long as it is the next group after the last
                    // opened group. Otherwise we return.
                    if (groupIndex > editorGroupService.count) {
                        return;
                    }
                    // Group exists: just focus
                    var groups = editorGroupService.getGroups(2 /* GRID_APPEARANCE */);
                    if (groups[groupIndex]) {
                        return groups[groupIndex].focus();
                    }
                    // Group does not exist: create new by splitting the active one of the last group
                    var direction = editorGroupsService_1.preferredSideBySideGroupDirection(configurationService);
                    var lastGroup = editorGroupService.findGroup({ location: 1 /* LAST */ });
                    var newGroup = editorGroupService.addGroup(lastGroup, direction);
                    // Focus
                    newGroup.focus();
                }
            });
        };
        // Keybindings to focus a specific group (2-8) in the editor area
        for (var groupIndex = 1; groupIndex < 8; groupIndex++) {
            _loop_2(groupIndex);
        }
        function toCommandId(index) {
            switch (index) {
                case 1: return 'workbench.action.focusSecondEditorGroup';
                case 2: return 'workbench.action.focusThirdEditorGroup';
                case 3: return 'workbench.action.focusFourthEditorGroup';
                case 4: return 'workbench.action.focusFifthEditorGroup';
                case 5: return 'workbench.action.focusSixthEditorGroup';
                case 6: return 'workbench.action.focusSeventhEditorGroup';
                case 7: return 'workbench.action.focusEighthEditorGroup';
            }
            return void 0;
        }
        function toKeyCode(index) {
            switch (index) {
                case 1: return 23 /* KEY_2 */;
                case 2: return 24 /* KEY_3 */;
                case 3: return 25 /* KEY_4 */;
                case 4: return 26 /* KEY_5 */;
                case 5: return 27 /* KEY_6 */;
                case 6: return 28 /* KEY_7 */;
                case 7: return 29 /* KEY_8 */;
            }
            return void 0;
        }
    }
    function splitEditor(editorGroupService, direction, context) {
        var sourceGroup;
        if (context && typeof context.groupId === 'number') {
            sourceGroup = editorGroupService.getGroup(context.groupId);
        }
        else {
            sourceGroup = editorGroupService.activeGroup;
        }
        // Add group
        var newGroup = editorGroupService.addGroup(sourceGroup, direction);
        // Split editor (if it can be split)
        var editorToCopy;
        if (context && typeof context.editorIndex === 'number') {
            editorToCopy = sourceGroup.getEditor(context.editorIndex);
        }
        else {
            editorToCopy = sourceGroup.activeEditor;
        }
        if (editorToCopy && editorToCopy.supportsSplitEditor()) {
            sourceGroup.copyEditor(editorToCopy, newGroup);
        }
        // Focus
        newGroup.focus();
    }
    exports.splitEditor = splitEditor;
    function registerSplitEditorCommands() {
        [
            { id: exports.SPLIT_EDITOR_UP, direction: 0 /* UP */ },
            { id: exports.SPLIT_EDITOR_DOWN, direction: 1 /* DOWN */ },
            { id: exports.SPLIT_EDITOR_LEFT, direction: 2 /* LEFT */ },
            { id: exports.SPLIT_EDITOR_RIGHT, direction: 3 /* RIGHT */ }
        ].forEach(function (_a) {
            var id = _a.id, direction = _a.direction;
            commands_1.CommandsRegistry.registerCommand(id, function (accessor, resourceOrContext, context) {
                splitEditor(accessor.get(editorGroupsService_1.IEditorGroupsService), direction, getCommandsContext(resourceOrContext, context));
            });
        });
    }
    function registerCloseEditorCommands() {
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_SAVED_EDITORS_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 51 /* KEY_U */),
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var contexts = getMultiSelectedEditorContexts(getCommandsContext(resourceOrContext, context), accessor.get(listService_1.IListService), editorGroupService);
                var activeGroup = editorGroupService.activeGroup;
                if (contexts.length === 0) {
                    contexts.push({ groupId: activeGroup.id }); // active group as fallback
                }
                return Promise.all(arrays_1.distinct(contexts.map(function (c) { return c.groupId; })).map(function (groupId) {
                    return editorGroupService.getGroup(groupId).closeEditors({ savedOnly: true });
                }));
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_EDITORS_IN_GROUP_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            // CODESANDBOX CHANGE
            primary: keyCodes_1.KeyChord(256 /* WinCtrl */ | 41 /* KEY_K */, 53 /* KEY_W */),
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var contexts = getMultiSelectedEditorContexts(getCommandsContext(resourceOrContext, context), accessor.get(listService_1.IListService), editorGroupService);
                var distinctGroupIds = arrays_1.distinct(contexts.map(function (c) { return c.groupId; }));
                if (distinctGroupIds.length === 0) {
                    distinctGroupIds.push(editorGroupService.activeGroup.id);
                }
                return Promise.all(distinctGroupIds.map(function (groupId) {
                    return editorGroupService.getGroup(groupId).closeAllEditors();
                }));
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_EDITOR_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            // CODESANDBOX CHANGE
            primary: 256 /* WinCtrl */ | 53 /* KEY_W */,
            win: { primary: 2048 /* CtrlCmd */ | 62 /* F4 */, secondary: [2048 /* CtrlCmd */ | 53 /* KEY_W */] },
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var contexts = getMultiSelectedEditorContexts(getCommandsContext(resourceOrContext, context), accessor.get(listService_1.IListService), editorGroupService);
                var activeGroup = editorGroupService.activeGroup;
                if (contexts.length === 0 && activeGroup.activeEditor) {
                    contexts.push({ groupId: activeGroup.id, editorIndex: activeGroup.getIndexOfEditor(activeGroup.activeEditor) }); // active editor as fallback
                }
                var groupIds = arrays_1.distinct(contexts.map(function (context) { return context.groupId; }));
                return Promise.all(groupIds.map(function (groupId) {
                    var group = editorGroupService.getGroup(groupId);
                    var editors = contexts
                        .filter(function (context) { return context.groupId === groupId; })
                        .map(function (context) { return typeof context.editorIndex === 'number' ? group.getEditor(context.editorIndex) : group.activeEditor; });
                    return group.closeEditors(editors);
                }));
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_EDITOR_GROUP_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: contextkey_1.ContextKeyExpr.and(editor_1.ActiveEditorGroupEmptyContext, editor_1.MultipleEditorGroupsContext),
            // CODESANDBOX CHANGE
            primary: 256 /* WinCtrl */ | 53 /* KEY_W */,
            win: { primary: 2048 /* CtrlCmd */ | 62 /* F4 */, secondary: [2048 /* CtrlCmd */ | 53 /* KEY_W */] },
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var commandsContext = getCommandsContext(resourceOrContext, context);
                var group;
                if (commandsContext && typeof commandsContext.groupId === 'number') {
                    group = editorGroupService.getGroup(commandsContext.groupId);
                }
                else {
                    group = editorGroupService.activeGroup;
                }
                editorGroupService.removeGroup(group);
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: void 0,
            mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 50 /* KEY_T */ },
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var contexts = getMultiSelectedEditorContexts(getCommandsContext(resourceOrContext, context), accessor.get(listService_1.IListService), editorGroupService);
                var activeGroup = editorGroupService.activeGroup;
                if (contexts.length === 0 && activeGroup.activeEditor) {
                    contexts.push({ groupId: activeGroup.id, editorIndex: activeGroup.getIndexOfEditor(activeGroup.activeEditor) }); // active editor as fallback
                }
                var groupIds = arrays_1.distinct(contexts.map(function (context) { return context.groupId; }));
                return Promise.all(groupIds.map(function (groupId) {
                    var group = editorGroupService.getGroup(groupId);
                    var editors = contexts
                        .filter(function (context) { return context.groupId === groupId; })
                        .map(function (context) { return typeof context.editorIndex === 'number' ? group.getEditor(context.editorIndex) : group.activeEditor; });
                    var editorsToClose = group.editors.filter(function (e) { return editors.indexOf(e) === -1; });
                    return group.closeEditors(editorsToClose);
                }));
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.CLOSE_EDITORS_TO_THE_RIGHT_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: void 0,
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var _a = resolveCommandsContext(editorGroupService, getCommandsContext(resourceOrContext, context)), group = _a.group, editor = _a.editor;
                if (group && editor) {
                    return group.closeEditors({ direction: 1 /* RIGHT */, except: editor });
                }
                return winjs_base_1.TPromise.as(false);
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.KEEP_EDITOR_COMMAND_ID,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 3 /* Enter */),
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var _a = resolveCommandsContext(editorGroupService, getCommandsContext(resourceOrContext, context)), group = _a.group, editor = _a.editor;
                if (group && editor) {
                    return group.pinEditor(editor);
                }
                return winjs_base_1.TPromise.as(false);
            }
        });
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: exports.SHOW_EDITORS_IN_GROUP,
            weight: 200 /* WorkbenchContrib */,
            when: void 0,
            primary: void 0,
            handler: function (accessor, resourceOrContext, context) {
                var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
                var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
                if (editorGroupService.count <= 1) {
                    return quickOpenService.show(exports.NAVIGATE_ALL_EDITORS_GROUP_PREFIX);
                }
                var commandsContext = getCommandsContext(resourceOrContext, context);
                if (commandsContext && typeof commandsContext.groupId === 'number') {
                    editorGroupService.activateGroup(editorGroupService.getGroup(commandsContext.groupId)); // we need the group to be active
                }
                return quickOpenService.show(exports.NAVIGATE_IN_ACTIVE_GROUP_PREFIX);
            }
        });
        commands_1.CommandsRegistry.registerCommand(exports.CLOSE_EDITORS_AND_GROUP_COMMAND_ID, function (accessor, resourceOrContext, context) {
            var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var group = resolveCommandsContext(editorGroupService, getCommandsContext(resourceOrContext, context)).group;
            if (group) {
                return group.closeAllEditors().then(function () {
                    if (group.count === 0 && editorGroupService.getGroup(group.id) /* could be gone by now */) {
                        editorGroupService.removeGroup(group); // only remove group if it is now empty
                    }
                });
            }
            return void 0;
        });
    }
    function getCommandsContext(resourceOrContext, context) {
        if (uri_1.URI.isUri(resourceOrContext)) {
            return context;
        }
        if (resourceOrContext && typeof resourceOrContext.groupId === 'number') {
            return resourceOrContext;
        }
        if (context && typeof context.groupId === 'number') {
            return context;
        }
        return void 0;
    }
    function resolveCommandsContext(editorGroupService, context) {
        // Resolve from context
        var group = context && typeof context.groupId === 'number' ? editorGroupService.getGroup(context.groupId) : undefined;
        var editor = group && typeof context.editorIndex === 'number' ? group.getEditor(context.editorIndex) : undefined;
        var control = group ? group.activeControl : undefined;
        // Fallback to active group as needed
        if (!group) {
            group = editorGroupService.activeGroup;
            editor = group.activeEditor;
            control = group.activeControl;
        }
        return { group: group, editor: editor, control: control };
    }
    function getMultiSelectedEditorContexts(editorContext, listService, editorGroupService) {
        // First check for a focused list to return the selected items from
        var list = listService.lastFocusedList;
        if (list instanceof listWidget_1.List && list.isDOMFocused()) {
            var elementToContext = function (element) {
                if (isEditorGroup(element)) {
                    return { groupId: element.id, editorIndex: void 0 };
                }
                return { groupId: element.groupId, editorIndex: editorGroupService.getGroup(element.groupId).getIndexOfEditor(element.editor) };
            };
            var onlyEditorGroupAndEditor = function (e) { return isEditorGroup(e) || isEditorIdentifier(e); };
            var focusedElements = list.getFocusedElements().filter(onlyEditorGroupAndEditor);
            var focus_1 = editorContext ? editorContext : focusedElements.length ? focusedElements.map(elementToContext)[0] : void 0; // need to take into account when editor context is { group: group }
            if (focus_1) {
                var selection = list.getSelectedElements().filter(onlyEditorGroupAndEditor);
                // Only respect selection if it contains focused element
                if (selection && selection.some(function (s) { return isEditorGroup(s) ? s.id === focus_1.groupId : s.groupId === focus_1.groupId && editorGroupService.getGroup(s.groupId).getIndexOfEditor(s.editor) === focus_1.editorIndex; })) {
                    return selection.map(elementToContext);
                }
                return [focus_1];
            }
        }
        // Otherwise go with passed in context
        return !!editorContext ? [editorContext] : [];
    }
    exports.getMultiSelectedEditorContexts = getMultiSelectedEditorContexts;
    function isEditorGroup(thing) {
        var group = thing;
        return group && typeof group.id === 'number' && Array.isArray(group.editors);
    }
    function isEditorIdentifier(thing) {
        var identifier = thing;
        return identifier && typeof identifier.groupId === 'number';
    }
    function setup() {
        registerActiveEditorMoveCommand();
        registerEditorGroupsLayoutCommand();
        registerDiffEditorCommands();
        registerOpenEditorAtIndexCommands();
        registerCloseEditorCommands();
        registerFocusEditorGroupAtIndexCommands();
        registerSplitEditorCommands();
    }
    exports.setup = setup;
});























define(__m[164/*vs/workbench/browser/parts/editor/editorActions*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,15/*vs/base/common/actions*/,38/*vs/base/common/objects*/,13/*vs/workbench/common/editor*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,46/*vs/platform/quickOpen/common/quickOpen*/,49/*vs/workbench/services/part/common/partService*/,124/*vs/workbench/services/history/common/history*/,31/*vs/platform/keybinding/common/keybinding*/,37/*vs/platform/commands/common/commands*/,27/*vs/workbench/services/textfile/common/textfiles*/,42/*vs/platform/windows/common/windows*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,7/*vs/platform/configuration/common/configuration*/,4/*vs/base/common/lifecycle*/]), function (require, exports, winjs_base_1, nls, actions_1, objects_1, editor_1, quickOpenModel_1, quickopen_1, quickOpen_1, partService_1, history_1, keybinding_1, commands_1, textfiles_1, windows_1, editorCommands_1, editorGroupsService_1, editorService_1, configuration_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExecuteCommandAction = /** @class */ (function (_super) {
        __extends(ExecuteCommandAction, _super);
        function ExecuteCommandAction(id, label, commandId, commandService, commandArgs) {
            var _this = _super.call(this, id, label) || this;
            _this.commandId = commandId;
            _this.commandService = commandService;
            _this.commandArgs = commandArgs;
            return _this;
        }
        ExecuteCommandAction.prototype.run = function () {
            return this.commandService.executeCommand(this.commandId, this.commandArgs);
        };
        return ExecuteCommandAction;
    }(actions_1.Action));
    exports.ExecuteCommandAction = ExecuteCommandAction;
    var BaseSplitEditorAction = /** @class */ (function (_super) {
        __extends(BaseSplitEditorAction, _super);
        function BaseSplitEditorAction(id, label, editorGroupService, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            _this.configurationService = configurationService;
            _this.toDispose = [];
            _this.direction = _this.getDirection();
            _this.registerListeners();
            return _this;
        }
        BaseSplitEditorAction.prototype.getDirection = function () {
            return editorGroupsService_1.preferredSideBySideGroupDirection(this.configurationService);
        };
        BaseSplitEditorAction.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('workbench.editor.openSideBySideDirection')) {
                    _this.direction = editorGroupsService_1.preferredSideBySideGroupDirection(_this.configurationService);
                }
            }));
        };
        BaseSplitEditorAction.prototype.run = function (context) {
            editorCommands_1.splitEditor(this.editorGroupService, this.direction, context);
            return winjs_base_1.TPromise.as(true);
        };
        BaseSplitEditorAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        return BaseSplitEditorAction;
    }(actions_1.Action));
    exports.BaseSplitEditorAction = BaseSplitEditorAction;
    var SplitEditorAction = /** @class */ (function (_super) {
        __extends(SplitEditorAction, _super);
        function SplitEditorAction(id, label, editorGroupService, configurationService) {
            return _super.call(this, id, label, editorGroupService, configurationService) || this;
        }
        SplitEditorAction.ID = 'workbench.action.splitEditor';
        SplitEditorAction.LABEL = nls.localize('splitEditor', "Split Editor");
        SplitEditorAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, configuration_1.IConfigurationService)
        ], SplitEditorAction);
        return SplitEditorAction;
    }(BaseSplitEditorAction));
    exports.SplitEditorAction = SplitEditorAction;
    var SplitEditorOrthogonalAction = /** @class */ (function (_super) {
        __extends(SplitEditorOrthogonalAction, _super);
        function SplitEditorOrthogonalAction(id, label, editorGroupService, configurationService) {
            return _super.call(this, id, label, editorGroupService, configurationService) || this;
        }
        SplitEditorOrthogonalAction.prototype.getDirection = function () {
            var direction = editorGroupsService_1.preferredSideBySideGroupDirection(this.configurationService);
            return direction === 3 /* RIGHT */ ? 1 /* DOWN */ : 3 /* RIGHT */;
        };
        SplitEditorOrthogonalAction.ID = 'workbench.action.splitEditorOrthogonal';
        SplitEditorOrthogonalAction.LABEL = nls.localize('splitEditorOrthogonal', "Split Editor Orthogonal");
        SplitEditorOrthogonalAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, configuration_1.IConfigurationService)
        ], SplitEditorOrthogonalAction);
        return SplitEditorOrthogonalAction;
    }(BaseSplitEditorAction));
    exports.SplitEditorOrthogonalAction = SplitEditorOrthogonalAction;
    var SplitEditorLeftAction = /** @class */ (function (_super) {
        __extends(SplitEditorLeftAction, _super);
        function SplitEditorLeftAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.SPLIT_EDITOR_LEFT, commandService) || this;
        }
        SplitEditorLeftAction.ID = editorCommands_1.SPLIT_EDITOR_LEFT;
        SplitEditorLeftAction.LABEL = nls.localize('splitEditorGroupLeft', "Split Editor Left");
        SplitEditorLeftAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], SplitEditorLeftAction);
        return SplitEditorLeftAction;
    }(ExecuteCommandAction));
    exports.SplitEditorLeftAction = SplitEditorLeftAction;
    var SplitEditorRightAction = /** @class */ (function (_super) {
        __extends(SplitEditorRightAction, _super);
        function SplitEditorRightAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.SPLIT_EDITOR_RIGHT, commandService) || this;
        }
        SplitEditorRightAction.ID = editorCommands_1.SPLIT_EDITOR_RIGHT;
        SplitEditorRightAction.LABEL = nls.localize('splitEditorGroupRight', "Split Editor Right");
        SplitEditorRightAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], SplitEditorRightAction);
        return SplitEditorRightAction;
    }(ExecuteCommandAction));
    exports.SplitEditorRightAction = SplitEditorRightAction;
    var SplitEditorUpAction = /** @class */ (function (_super) {
        __extends(SplitEditorUpAction, _super);
        function SplitEditorUpAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.SPLIT_EDITOR_UP, commandService) || this;
        }
        SplitEditorUpAction.ID = editorCommands_1.SPLIT_EDITOR_UP;
        SplitEditorUpAction.LABEL = nls.localize('splitEditorGroupUp', "Split Editor Up");
        SplitEditorUpAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], SplitEditorUpAction);
        return SplitEditorUpAction;
    }(ExecuteCommandAction));
    exports.SplitEditorUpAction = SplitEditorUpAction;
    var SplitEditorDownAction = /** @class */ (function (_super) {
        __extends(SplitEditorDownAction, _super);
        function SplitEditorDownAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.SPLIT_EDITOR_DOWN, commandService) || this;
        }
        SplitEditorDownAction.ID = editorCommands_1.SPLIT_EDITOR_DOWN;
        SplitEditorDownAction.LABEL = nls.localize('splitEditorGroupDown', "Split Editor Down");
        SplitEditorDownAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], SplitEditorDownAction);
        return SplitEditorDownAction;
    }(ExecuteCommandAction));
    exports.SplitEditorDownAction = SplitEditorDownAction;
    var JoinTwoGroupsAction = /** @class */ (function (_super) {
        __extends(JoinTwoGroupsAction, _super);
        function JoinTwoGroupsAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        JoinTwoGroupsAction.prototype.run = function (context) {
            var sourceGroup;
            if (context && typeof context.groupId === 'number') {
                sourceGroup = this.editorGroupService.getGroup(context.groupId);
            }
            else {
                sourceGroup = this.editorGroupService.activeGroup;
            }
            var targetGroupDirections = [3 /* RIGHT */, 1 /* DOWN */, 2 /* LEFT */, 0 /* UP */];
            for (var i = 0; i < targetGroupDirections.length; i++) {
                var targetGroup = this.editorGroupService.findGroup({ direction: targetGroupDirections[i] }, sourceGroup);
                if (targetGroup && sourceGroup !== targetGroup) {
                    this.editorGroupService.mergeGroup(sourceGroup, targetGroup);
                    return winjs_base_1.TPromise.as(true);
                }
            }
            return winjs_base_1.TPromise.as(true);
        };
        JoinTwoGroupsAction.ID = 'workbench.action.joinTwoGroups';
        JoinTwoGroupsAction.LABEL = nls.localize('joinTwoGroups', "Join Editor Group with Next Group");
        JoinTwoGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], JoinTwoGroupsAction);
        return JoinTwoGroupsAction;
    }(actions_1.Action));
    exports.JoinTwoGroupsAction = JoinTwoGroupsAction;
    var JoinAllGroupsAction = /** @class */ (function (_super) {
        __extends(JoinAllGroupsAction, _super);
        function JoinAllGroupsAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        JoinAllGroupsAction.prototype.run = function (context) {
            editorCommands_1.mergeAllGroups(this.editorGroupService);
            return winjs_base_1.TPromise.as(true);
        };
        JoinAllGroupsAction.ID = 'workbench.action.joinAllGroups';
        JoinAllGroupsAction.LABEL = nls.localize('joinAllGroups', "Join All Editor Groups");
        JoinAllGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], JoinAllGroupsAction);
        return JoinAllGroupsAction;
    }(actions_1.Action));
    exports.JoinAllGroupsAction = JoinAllGroupsAction;
    var NavigateBetweenGroupsAction = /** @class */ (function (_super) {
        __extends(NavigateBetweenGroupsAction, _super);
        function NavigateBetweenGroupsAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        NavigateBetweenGroupsAction.prototype.run = function () {
            var nextGroup = this.editorGroupService.findGroup({ location: 2 /* NEXT */ }, this.editorGroupService.activeGroup, true);
            nextGroup.focus();
            return winjs_base_1.TPromise.as(true);
        };
        NavigateBetweenGroupsAction.ID = 'workbench.action.navigateEditorGroups';
        NavigateBetweenGroupsAction.LABEL = nls.localize('navigateEditorGroups', "Navigate Between Editor Groups");
        NavigateBetweenGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], NavigateBetweenGroupsAction);
        return NavigateBetweenGroupsAction;
    }(actions_1.Action));
    exports.NavigateBetweenGroupsAction = NavigateBetweenGroupsAction;
    var FocusActiveGroupAction = /** @class */ (function (_super) {
        __extends(FocusActiveGroupAction, _super);
        function FocusActiveGroupAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        FocusActiveGroupAction.prototype.run = function () {
            this.editorGroupService.activeGroup.focus();
            return winjs_base_1.TPromise.as(true);
        };
        FocusActiveGroupAction.ID = 'workbench.action.focusActiveEditorGroup';
        FocusActiveGroupAction.LABEL = nls.localize('focusActiveEditorGroup', "Focus Active Editor Group");
        FocusActiveGroupAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusActiveGroupAction);
        return FocusActiveGroupAction;
    }(actions_1.Action));
    exports.FocusActiveGroupAction = FocusActiveGroupAction;
    var BaseFocusGroupAction = /** @class */ (function (_super) {
        __extends(BaseFocusGroupAction, _super);
        function BaseFocusGroupAction(id, label, scope, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.scope = scope;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        BaseFocusGroupAction.prototype.run = function () {
            var group = this.editorGroupService.findGroup(this.scope, this.editorGroupService.activeGroup, true);
            if (group) {
                group.focus();
            }
            return winjs_base_1.TPromise.as(true);
        };
        BaseFocusGroupAction = __decorate([
            __param(3, editorGroupsService_1.IEditorGroupsService)
        ], BaseFocusGroupAction);
        return BaseFocusGroupAction;
    }(actions_1.Action));
    exports.BaseFocusGroupAction = BaseFocusGroupAction;
    var FocusFirstGroupAction = /** @class */ (function (_super) {
        __extends(FocusFirstGroupAction, _super);
        function FocusFirstGroupAction(id, label, editorGroupService) {
            return _super.call(this, id, label, { location: 0 /* FIRST */ }, editorGroupService) || this;
        }
        FocusFirstGroupAction.ID = 'workbench.action.focusFirstEditorGroup';
        FocusFirstGroupAction.LABEL = nls.localize('focusFirstEditorGroup', "Focus First Editor Group");
        FocusFirstGroupAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusFirstGroupAction);
        return FocusFirstGroupAction;
    }(BaseFocusGroupAction));
    exports.FocusFirstGroupAction = FocusFirstGroupAction;
    var FocusLastGroupAction = /** @class */ (function (_super) {
        __extends(FocusLastGroupAction, _super);
        function FocusLastGroupAction(id, label, editorGroupService) {
            return _super.call(this, id, label, { location: 1 /* LAST */ }, editorGroupService) || this;
        }
        FocusLastGroupAction.ID = 'workbench.action.focusLastEditorGroup';
        FocusLastGroupAction.LABEL = nls.localize('focusLastEditorGroup', "Focus Last Editor Group");
        FocusLastGroupAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusLastGroupAction);
        return FocusLastGroupAction;
    }(BaseFocusGroupAction));
    exports.FocusLastGroupAction = FocusLastGroupAction;
    var FocusNextGroup = /** @class */ (function (_super) {
        __extends(FocusNextGroup, _super);
        function FocusNextGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { location: 2 /* NEXT */ }, editorGroupService) || this;
        }
        FocusNextGroup.ID = 'workbench.action.focusNextGroup';
        FocusNextGroup.LABEL = nls.localize('focusNextGroup', "Focus Next Editor Group");
        FocusNextGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusNextGroup);
        return FocusNextGroup;
    }(BaseFocusGroupAction));
    exports.FocusNextGroup = FocusNextGroup;
    var FocusPreviousGroup = /** @class */ (function (_super) {
        __extends(FocusPreviousGroup, _super);
        function FocusPreviousGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { location: 3 /* PREVIOUS */ }, editorGroupService) || this;
        }
        FocusPreviousGroup.ID = 'workbench.action.focusPreviousGroup';
        FocusPreviousGroup.LABEL = nls.localize('focusPreviousGroup', "Focus Previous Editor Group");
        FocusPreviousGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusPreviousGroup);
        return FocusPreviousGroup;
    }(BaseFocusGroupAction));
    exports.FocusPreviousGroup = FocusPreviousGroup;
    var FocusLeftGroup = /** @class */ (function (_super) {
        __extends(FocusLeftGroup, _super);
        function FocusLeftGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { direction: 2 /* LEFT */ }, editorGroupService) || this;
        }
        FocusLeftGroup.ID = 'workbench.action.focusLeftGroup';
        FocusLeftGroup.LABEL = nls.localize('focusLeftGroup', "Focus Left Editor Group");
        FocusLeftGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusLeftGroup);
        return FocusLeftGroup;
    }(BaseFocusGroupAction));
    exports.FocusLeftGroup = FocusLeftGroup;
    var FocusRightGroup = /** @class */ (function (_super) {
        __extends(FocusRightGroup, _super);
        function FocusRightGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { direction: 3 /* RIGHT */ }, editorGroupService) || this;
        }
        FocusRightGroup.ID = 'workbench.action.focusRightGroup';
        FocusRightGroup.LABEL = nls.localize('focusRightGroup', "Focus Right Editor Group");
        FocusRightGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusRightGroup);
        return FocusRightGroup;
    }(BaseFocusGroupAction));
    exports.FocusRightGroup = FocusRightGroup;
    var FocusAboveGroup = /** @class */ (function (_super) {
        __extends(FocusAboveGroup, _super);
        function FocusAboveGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { direction: 0 /* UP */ }, editorGroupService) || this;
        }
        FocusAboveGroup.ID = 'workbench.action.focusAboveGroup';
        FocusAboveGroup.LABEL = nls.localize('focusAboveGroup', "Focus Above Editor Group");
        FocusAboveGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusAboveGroup);
        return FocusAboveGroup;
    }(BaseFocusGroupAction));
    exports.FocusAboveGroup = FocusAboveGroup;
    var FocusBelowGroup = /** @class */ (function (_super) {
        __extends(FocusBelowGroup, _super);
        function FocusBelowGroup(id, label, editorGroupService) {
            return _super.call(this, id, label, { direction: 1 /* DOWN */ }, editorGroupService) || this;
        }
        FocusBelowGroup.ID = 'workbench.action.focusBelowGroup';
        FocusBelowGroup.LABEL = nls.localize('focusBelowGroup', "Focus Below Editor Group");
        FocusBelowGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], FocusBelowGroup);
        return FocusBelowGroup;
    }(BaseFocusGroupAction));
    exports.FocusBelowGroup = FocusBelowGroup;
    var OpenToSideFromQuickOpenAction = /** @class */ (function (_super) {
        __extends(OpenToSideFromQuickOpenAction, _super);
        function OpenToSideFromQuickOpenAction(editorService, configurationService) {
            var _this = _super.call(this, OpenToSideFromQuickOpenAction.OPEN_TO_SIDE_ID, OpenToSideFromQuickOpenAction.OPEN_TO_SIDE_LABEL) || this;
            _this.editorService = editorService;
            _this.configurationService = configurationService;
            _this.updateClass();
            return _this;
        }
        OpenToSideFromQuickOpenAction.prototype.updateClass = function () {
            var preferredDirection = editorGroupsService_1.preferredSideBySideGroupDirection(this.configurationService);
            this.class = (preferredDirection === 3 /* RIGHT */) ? 'quick-open-sidebyside-vertical' : 'quick-open-sidebyside-horizontal';
        };
        OpenToSideFromQuickOpenAction.prototype.run = function (context) {
            var entry = toEditorQuickOpenEntry(context);
            if (entry) {
                var input = entry.getInput();
                if (input instanceof editor_1.EditorInput) {
                    return this.editorService.openEditor(input, entry.getOptions(), editorService_1.SIDE_GROUP);
                }
                var resourceInput = input;
                resourceInput.options = objects_1.mixin(resourceInput.options, entry.getOptions());
                return this.editorService.openEditor(resourceInput, editorService_1.SIDE_GROUP);
            }
            return winjs_base_1.TPromise.as(false);
        };
        OpenToSideFromQuickOpenAction.OPEN_TO_SIDE_ID = 'workbench.action.openToSide';
        OpenToSideFromQuickOpenAction.OPEN_TO_SIDE_LABEL = nls.localize('openToSide', "Open to the Side");
        OpenToSideFromQuickOpenAction = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, configuration_1.IConfigurationService)
        ], OpenToSideFromQuickOpenAction);
        return OpenToSideFromQuickOpenAction;
    }(actions_1.Action));
    exports.OpenToSideFromQuickOpenAction = OpenToSideFromQuickOpenAction;
    function toEditorQuickOpenEntry(element) {
        // QuickOpenEntryGroup
        if (element instanceof quickOpenModel_1.QuickOpenEntryGroup) {
            var group = element;
            if (group.getEntry()) {
                element = group.getEntry();
            }
        }
        // EditorQuickOpenEntry or EditorQuickOpenEntryGroup both implement IEditorQuickOpenEntry
        if (element instanceof quickopen_1.EditorQuickOpenEntry || element instanceof quickopen_1.EditorQuickOpenEntryGroup) {
            return element;
        }
        return null;
    }
    exports.toEditorQuickOpenEntry = toEditorQuickOpenEntry;
    var CloseEditorAction = /** @class */ (function (_super) {
        __extends(CloseEditorAction, _super);
        function CloseEditorAction(id, label, commandService) {
            var _this = _super.call(this, id, label, 'close-editor-action') || this;
            _this.commandService = commandService;
            return _this;
        }
        CloseEditorAction.prototype.run = function (context) {
            return this.commandService.executeCommand(editorCommands_1.CLOSE_EDITOR_COMMAND_ID, void 0, context);
        };
        CloseEditorAction.ID = 'workbench.action.closeActiveEditor';
        CloseEditorAction.LABEL = nls.localize('closeEditor', "Close Editor");
        CloseEditorAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], CloseEditorAction);
        return CloseEditorAction;
    }(actions_1.Action));
    exports.CloseEditorAction = CloseEditorAction;
    var CloseOneEditorAction = /** @class */ (function (_super) {
        __extends(CloseOneEditorAction, _super);
        function CloseOneEditorAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label, 'close-editor-action') || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        CloseOneEditorAction.prototype.run = function (context) {
            var group;
            var editorIndex;
            if (context) {
                group = this.editorGroupService.getGroup(context.groupId);
                if (group) {
                    editorIndex = context.editorIndex; // only allow editor at index if group is valid
                }
            }
            if (!group) {
                group = this.editorGroupService.activeGroup;
            }
            // Close specific editor in group
            if (typeof editorIndex === 'number') {
                var editorAtIndex = group.getEditor(editorIndex);
                if (editorAtIndex) {
                    return group.closeEditor(editorAtIndex);
                }
            }
            // Otherwise close active editor in group
            if (group.activeEditor) {
                return group.closeEditor(group.activeEditor);
            }
            return winjs_base_1.TPromise.as(false);
        };
        CloseOneEditorAction.ID = 'workbench.action.closeActiveEditor';
        CloseOneEditorAction.LABEL = nls.localize('closeOneEditor', "Close");
        CloseOneEditorAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], CloseOneEditorAction);
        return CloseOneEditorAction;
    }(actions_1.Action));
    exports.CloseOneEditorAction = CloseOneEditorAction;
    var RevertAndCloseEditorAction = /** @class */ (function (_super) {
        __extends(RevertAndCloseEditorAction, _super);
        function RevertAndCloseEditorAction(id, label, editorService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            return _this;
        }
        RevertAndCloseEditorAction.prototype.run = function () {
            var activeControl = this.editorService.activeControl;
            if (activeControl) {
                var editor_2 = activeControl.input;
                var group_1 = activeControl.group;
                // first try a normal revert where the contents of the editor are restored
                return editor_2.revert().then(function () { return group_1.closeEditor(editor_2); }, function (error) {
                    // if that fails, since we are about to close the editor, we accept that
                    // the editor cannot be reverted and instead do a soft revert that just
                    // enables us to close the editor. With this, a user can always close a
                    // dirty editor even when reverting fails.
                    return editor_2.revert({ soft: true }).then(function () { return group_1.closeEditor(editor_2); });
                });
            }
            return winjs_base_1.TPromise.as(false);
        };
        RevertAndCloseEditorAction.ID = 'workbench.action.revertAndCloseActiveEditor';
        RevertAndCloseEditorAction.LABEL = nls.localize('revertAndCloseActiveEditor', "Revert and Close Editor");
        RevertAndCloseEditorAction = __decorate([
            __param(2, editorService_1.IEditorService)
        ], RevertAndCloseEditorAction);
        return RevertAndCloseEditorAction;
    }(actions_1.Action));
    exports.RevertAndCloseEditorAction = RevertAndCloseEditorAction;
    var CloseLeftEditorsInGroupAction = /** @class */ (function (_super) {
        __extends(CloseLeftEditorsInGroupAction, _super);
        function CloseLeftEditorsInGroupAction(id, label, editorService, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        CloseLeftEditorsInGroupAction.prototype.run = function (context) {
            var _a = getTarget(this.editorService, this.editorGroupService, context), group = _a.group, editor = _a.editor;
            if (group && editor) {
                return group.closeEditors({ direction: 0 /* LEFT */, except: editor });
            }
            return winjs_base_1.TPromise.as(false);
        };
        CloseLeftEditorsInGroupAction.ID = 'workbench.action.closeEditorsToTheLeft';
        CloseLeftEditorsInGroupAction.LABEL = nls.localize('closeEditorsToTheLeft', "Close Editors to the Left in Group");
        CloseLeftEditorsInGroupAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, editorGroupsService_1.IEditorGroupsService)
        ], CloseLeftEditorsInGroupAction);
        return CloseLeftEditorsInGroupAction;
    }(actions_1.Action));
    exports.CloseLeftEditorsInGroupAction = CloseLeftEditorsInGroupAction;
    function getTarget(editorService, editorGroupService, context) {
        if (context) {
            return { editor: context.editor, group: editorGroupService.getGroup(context.groupId) };
        }
        // Fallback to active group
        return { group: editorGroupService.activeGroup, editor: editorGroupService.activeGroup.activeEditor };
    }
    var BaseCloseAllAction = /** @class */ (function (_super) {
        __extends(BaseCloseAllAction, _super);
        function BaseCloseAllAction(id, label, clazz, textFileService, editorGroupService) {
            var _this = _super.call(this, id, label, clazz) || this;
            _this.textFileService = textFileService;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        Object.defineProperty(BaseCloseAllAction.prototype, "groupsToClose", {
            get: function () {
                var groupsToClose = [];
                // Close editors in reverse order of their grid appearance so that the editor
                // group that is the first (top-left) remains. This helps to keep view state
                // for editors around that have been opened in this visually first group.
                var groups = this.editorGroupService.getGroups(2 /* GRID_APPEARANCE */);
                for (var i = groups.length - 1; i >= 0; i--) {
                    groupsToClose.push(groups[i]);
                }
                return groupsToClose;
            },
            enumerable: true,
            configurable: true
        });
        BaseCloseAllAction.prototype.run = function () {
            var _this = this;
            // Just close all if there are no or one dirty editor
            if (this.textFileService.getDirty().length < 2) {
                return this.doCloseAll();
            }
            // Otherwise ask for combined confirmation
            return this.textFileService.confirmSave().then(function (confirm) {
                if (confirm === 2 /* CANCEL */) {
                    return void 0;
                }
                var saveOrRevertPromise;
                if (confirm === 1 /* DONT_SAVE */) {
                    saveOrRevertPromise = _this.textFileService.revertAll(null, { soft: true }).then(function () { return true; });
                }
                else {
                    saveOrRevertPromise = _this.textFileService.saveAll(true).then(function (res) { return res.results.every(function (r) { return r.success; }); });
                }
                return saveOrRevertPromise.then(function (success) {
                    if (success) {
                        return _this.doCloseAll();
                    }
                    return void 0;
                });
            });
        };
        return BaseCloseAllAction;
    }(actions_1.Action));
    exports.BaseCloseAllAction = BaseCloseAllAction;
    var CloseAllEditorsAction = /** @class */ (function (_super) {
        __extends(CloseAllEditorsAction, _super);
        function CloseAllEditorsAction(id, label, textFileService, editorGroupService) {
            return _super.call(this, id, label, 'action-close-all-files', textFileService, editorGroupService) || this;
        }
        CloseAllEditorsAction.prototype.doCloseAll = function () {
            return Promise.all(this.groupsToClose.map(function (g) { return g.closeAllEditors(); }));
        };
        CloseAllEditorsAction.ID = 'workbench.action.closeAllEditors';
        CloseAllEditorsAction.LABEL = nls.localize('closeAllEditors', "Close All Editors");
        CloseAllEditorsAction = __decorate([
            __param(2, textfiles_1.ITextFileService),
            __param(3, editorGroupsService_1.IEditorGroupsService)
        ], CloseAllEditorsAction);
        return CloseAllEditorsAction;
    }(BaseCloseAllAction));
    exports.CloseAllEditorsAction = CloseAllEditorsAction;
    var CloseAllEditorGroupsAction = /** @class */ (function (_super) {
        __extends(CloseAllEditorGroupsAction, _super);
        function CloseAllEditorGroupsAction(id, label, textFileService, editorGroupService) {
            return _super.call(this, id, label, void 0, textFileService, editorGroupService) || this;
        }
        CloseAllEditorGroupsAction.prototype.doCloseAll = function () {
            var _this = this;
            return Promise.all(this.groupsToClose.map(function (g) { return g.closeAllEditors(); })).then(function () {
                _this.groupsToClose.forEach(function (group) { return _this.editorGroupService.removeGroup(group); });
            });
        };
        CloseAllEditorGroupsAction.ID = 'workbench.action.closeAllGroups';
        CloseAllEditorGroupsAction.LABEL = nls.localize('closeAllGroups', "Close All Editor Groups");
        CloseAllEditorGroupsAction = __decorate([
            __param(2, textfiles_1.ITextFileService),
            __param(3, editorGroupsService_1.IEditorGroupsService)
        ], CloseAllEditorGroupsAction);
        return CloseAllEditorGroupsAction;
    }(BaseCloseAllAction));
    exports.CloseAllEditorGroupsAction = CloseAllEditorGroupsAction;
    var CloseEditorsInOtherGroupsAction = /** @class */ (function (_super) {
        __extends(CloseEditorsInOtherGroupsAction, _super);
        function CloseEditorsInOtherGroupsAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        CloseEditorsInOtherGroupsAction.prototype.run = function (context) {
            var groupToSkip = context ? this.editorGroupService.getGroup(context.groupId) : this.editorGroupService.activeGroup;
            return Promise.all(this.editorGroupService.getGroups(1 /* MOST_RECENTLY_ACTIVE */).map(function (g) {
                if (g.id === groupToSkip.id) {
                    return winjs_base_1.TPromise.as(null);
                }
                return g.closeAllEditors();
            }));
        };
        CloseEditorsInOtherGroupsAction.ID = 'workbench.action.closeEditorsInOtherGroups';
        CloseEditorsInOtherGroupsAction.LABEL = nls.localize('closeEditorsInOtherGroups', "Close Editors in Other Groups");
        CloseEditorsInOtherGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], CloseEditorsInOtherGroupsAction);
        return CloseEditorsInOtherGroupsAction;
    }(actions_1.Action));
    exports.CloseEditorsInOtherGroupsAction = CloseEditorsInOtherGroupsAction;
    var CloseEditorInAllGroupsAction = /** @class */ (function (_super) {
        __extends(CloseEditorInAllGroupsAction, _super);
        function CloseEditorInAllGroupsAction(id, label, editorGroupService, editorService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            _this.editorService = editorService;
            return _this;
        }
        CloseEditorInAllGroupsAction.prototype.run = function () {
            var activeEditor = this.editorService.activeEditor;
            if (activeEditor) {
                return Promise.all(this.editorGroupService.getGroups(1 /* MOST_RECENTLY_ACTIVE */).map(function (g) { return g.closeEditor(activeEditor); }));
            }
            return winjs_base_1.TPromise.as(null);
        };
        CloseEditorInAllGroupsAction.ID = 'workbench.action.closeEditorInAllGroups';
        CloseEditorInAllGroupsAction.LABEL = nls.localize('closeEditorInAllGroups', "Close Editor in All Groups");
        CloseEditorInAllGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], CloseEditorInAllGroupsAction);
        return CloseEditorInAllGroupsAction;
    }(actions_1.Action));
    exports.CloseEditorInAllGroupsAction = CloseEditorInAllGroupsAction;
    var BaseMoveGroupAction = /** @class */ (function (_super) {
        __extends(BaseMoveGroupAction, _super);
        function BaseMoveGroupAction(id, label, direction, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.direction = direction;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        BaseMoveGroupAction.prototype.run = function (context) {
            var sourceGroup;
            if (context && typeof context.groupId === 'number') {
                sourceGroup = this.editorGroupService.getGroup(context.groupId);
            }
            else {
                sourceGroup = this.editorGroupService.activeGroup;
            }
            var targetGroup = this.findTargetGroup(sourceGroup);
            if (targetGroup) {
                this.editorGroupService.moveGroup(sourceGroup, targetGroup, this.direction);
            }
            return winjs_base_1.TPromise.as(true);
        };
        BaseMoveGroupAction.prototype.findTargetGroup = function (sourceGroup) {
            var targetNeighbours = [this.direction];
            // Allow the target group to be in alternative locations to support more
            // scenarios of moving the group to the taret location.
            // Helps for https://github.com/Microsoft/vscode/issues/50741
            switch (this.direction) {
                case 2 /* LEFT */:
                case 3 /* RIGHT */:
                    targetNeighbours.push(0 /* UP */, 1 /* DOWN */);
                    break;
                case 0 /* UP */:
                case 1 /* DOWN */:
                    targetNeighbours.push(2 /* LEFT */, 3 /* RIGHT */);
                    break;
            }
            for (var i = 0; i < targetNeighbours.length; i++) {
                var targetNeighbour = this.editorGroupService.findGroup({ direction: targetNeighbours[i] }, sourceGroup);
                if (targetNeighbour) {
                    return targetNeighbour;
                }
            }
            return void 0;
        };
        return BaseMoveGroupAction;
    }(actions_1.Action));
    exports.BaseMoveGroupAction = BaseMoveGroupAction;
    var MoveGroupLeftAction = /** @class */ (function (_super) {
        __extends(MoveGroupLeftAction, _super);
        function MoveGroupLeftAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 2 /* LEFT */, editorGroupService) || this;
        }
        MoveGroupLeftAction.ID = 'workbench.action.moveActiveEditorGroupLeft';
        MoveGroupLeftAction.LABEL = nls.localize('moveActiveGroupLeft', "Move Editor Group Left");
        MoveGroupLeftAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], MoveGroupLeftAction);
        return MoveGroupLeftAction;
    }(BaseMoveGroupAction));
    exports.MoveGroupLeftAction = MoveGroupLeftAction;
    var MoveGroupRightAction = /** @class */ (function (_super) {
        __extends(MoveGroupRightAction, _super);
        function MoveGroupRightAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 3 /* RIGHT */, editorGroupService) || this;
        }
        MoveGroupRightAction.ID = 'workbench.action.moveActiveEditorGroupRight';
        MoveGroupRightAction.LABEL = nls.localize('moveActiveGroupRight', "Move Editor Group Right");
        MoveGroupRightAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], MoveGroupRightAction);
        return MoveGroupRightAction;
    }(BaseMoveGroupAction));
    exports.MoveGroupRightAction = MoveGroupRightAction;
    var MoveGroupUpAction = /** @class */ (function (_super) {
        __extends(MoveGroupUpAction, _super);
        function MoveGroupUpAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 0 /* UP */, editorGroupService) || this;
        }
        MoveGroupUpAction.ID = 'workbench.action.moveActiveEditorGroupUp';
        MoveGroupUpAction.LABEL = nls.localize('moveActiveGroupUp', "Move Editor Group Up");
        MoveGroupUpAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], MoveGroupUpAction);
        return MoveGroupUpAction;
    }(BaseMoveGroupAction));
    exports.MoveGroupUpAction = MoveGroupUpAction;
    var MoveGroupDownAction = /** @class */ (function (_super) {
        __extends(MoveGroupDownAction, _super);
        function MoveGroupDownAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 1 /* DOWN */, editorGroupService) || this;
        }
        MoveGroupDownAction.ID = 'workbench.action.moveActiveEditorGroupDown';
        MoveGroupDownAction.LABEL = nls.localize('moveActiveGroupDown', "Move Editor Group Down");
        MoveGroupDownAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], MoveGroupDownAction);
        return MoveGroupDownAction;
    }(BaseMoveGroupAction));
    exports.MoveGroupDownAction = MoveGroupDownAction;
    var MinimizeOtherGroupsAction = /** @class */ (function (_super) {
        __extends(MinimizeOtherGroupsAction, _super);
        function MinimizeOtherGroupsAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        MinimizeOtherGroupsAction.prototype.run = function () {
            this.editorGroupService.arrangeGroups(0 /* MINIMIZE_OTHERS */);
            return winjs_base_1.TPromise.as(false);
        };
        MinimizeOtherGroupsAction.ID = 'workbench.action.minimizeOtherEditors';
        MinimizeOtherGroupsAction.LABEL = nls.localize('minimizeOtherEditorGroups', "Maximize Editor Group");
        MinimizeOtherGroupsAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], MinimizeOtherGroupsAction);
        return MinimizeOtherGroupsAction;
    }(actions_1.Action));
    exports.MinimizeOtherGroupsAction = MinimizeOtherGroupsAction;
    var ResetGroupSizesAction = /** @class */ (function (_super) {
        __extends(ResetGroupSizesAction, _super);
        function ResetGroupSizesAction(id, label, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        ResetGroupSizesAction.prototype.run = function () {
            this.editorGroupService.arrangeGroups(1 /* EVEN */);
            return winjs_base_1.TPromise.as(false);
        };
        ResetGroupSizesAction.ID = 'workbench.action.evenEditorWidths';
        ResetGroupSizesAction.LABEL = nls.localize('evenEditorGroups', "Reset Editor Group Sizes");
        ResetGroupSizesAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], ResetGroupSizesAction);
        return ResetGroupSizesAction;
    }(actions_1.Action));
    exports.ResetGroupSizesAction = ResetGroupSizesAction;
    var MaximizeGroupAction = /** @class */ (function (_super) {
        __extends(MaximizeGroupAction, _super);
        function MaximizeGroupAction(id, label, editorService, editorGroupService, partService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.partService = partService;
            return _this;
        }
        MaximizeGroupAction.prototype.run = function () {
            if (this.editorService.activeEditor) {
                this.editorGroupService.arrangeGroups(0 /* MINIMIZE_OTHERS */);
                return this.partService.setSideBarHidden(true);
            }
            return winjs_base_1.TPromise.as(false);
        };
        MaximizeGroupAction.ID = 'workbench.action.maximizeEditor';
        MaximizeGroupAction.LABEL = nls.localize('maximizeEditor', "Maximize Editor Group and Hide Sidebar");
        MaximizeGroupAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, editorGroupsService_1.IEditorGroupsService),
            __param(4, partService_1.IPartService)
        ], MaximizeGroupAction);
        return MaximizeGroupAction;
    }(actions_1.Action));
    exports.MaximizeGroupAction = MaximizeGroupAction;
    var BaseNavigateEditorAction = /** @class */ (function (_super) {
        __extends(BaseNavigateEditorAction, _super);
        function BaseNavigateEditorAction(id, label, editorGroupService, editorService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorGroupService = editorGroupService;
            _this.editorService = editorService;
            return _this;
        }
        BaseNavigateEditorAction.prototype.run = function () {
            var result = this.navigate();
            if (!result) {
                return winjs_base_1.TPromise.as(false);
            }
            var groupId = result.groupId, editor = result.editor;
            if (!editor) {
                return winjs_base_1.TPromise.as(false);
            }
            var group = this.editorGroupService.getGroup(groupId);
            return group.openEditor(editor);
        };
        return BaseNavigateEditorAction;
    }(actions_1.Action));
    exports.BaseNavigateEditorAction = BaseNavigateEditorAction;
    var OpenNextEditor = /** @class */ (function (_super) {
        __extends(OpenNextEditor, _super);
        function OpenNextEditor(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenNextEditor.prototype.navigate = function () {
            // Navigate in active group if possible
            var activeGroup = this.editorGroupService.activeGroup;
            var activeGroupEditors = activeGroup.getEditors(1 /* SEQUENTIAL */);
            var activeEditorIndex = activeGroupEditors.indexOf(activeGroup.activeEditor);
            if (activeEditorIndex + 1 < activeGroupEditors.length) {
                return { editor: activeGroupEditors[activeEditorIndex + 1], groupId: activeGroup.id };
            }
            // Otherwise try in next group
            var nextGroup = this.editorGroupService.findGroup({ location: 2 /* NEXT */ }, this.editorGroupService.activeGroup, true);
            if (nextGroup) {
                var previousGroupEditors = nextGroup.getEditors(1 /* SEQUENTIAL */);
                return { editor: previousGroupEditors[0], groupId: nextGroup.id };
            }
            return void 0;
        };
        OpenNextEditor.ID = 'workbench.action.nextEditor';
        OpenNextEditor.LABEL = nls.localize('openNextEditor', "Open Next Editor");
        OpenNextEditor = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenNextEditor);
        return OpenNextEditor;
    }(BaseNavigateEditorAction));
    exports.OpenNextEditor = OpenNextEditor;
    var OpenPreviousEditor = /** @class */ (function (_super) {
        __extends(OpenPreviousEditor, _super);
        function OpenPreviousEditor(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenPreviousEditor.prototype.navigate = function () {
            // Navigate in active group if possible
            var activeGroup = this.editorGroupService.activeGroup;
            var activeGroupEditors = activeGroup.getEditors(1 /* SEQUENTIAL */);
            var activeEditorIndex = activeGroupEditors.indexOf(activeGroup.activeEditor);
            if (activeEditorIndex > 0) {
                return { editor: activeGroupEditors[activeEditorIndex - 1], groupId: activeGroup.id };
            }
            // Otherwise try in previous group
            var previousGroup = this.editorGroupService.findGroup({ location: 3 /* PREVIOUS */ }, this.editorGroupService.activeGroup, true);
            if (previousGroup) {
                var previousGroupEditors = previousGroup.getEditors(1 /* SEQUENTIAL */);
                return { editor: previousGroupEditors[previousGroupEditors.length - 1], groupId: previousGroup.id };
            }
            return void 0;
        };
        OpenPreviousEditor.ID = 'workbench.action.previousEditor';
        OpenPreviousEditor.LABEL = nls.localize('openPreviousEditor', "Open Previous Editor");
        OpenPreviousEditor = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenPreviousEditor);
        return OpenPreviousEditor;
    }(BaseNavigateEditorAction));
    exports.OpenPreviousEditor = OpenPreviousEditor;
    var OpenNextEditorInGroup = /** @class */ (function (_super) {
        __extends(OpenNextEditorInGroup, _super);
        function OpenNextEditorInGroup(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenNextEditorInGroup.prototype.navigate = function () {
            var group = this.editorGroupService.activeGroup;
            var editors = group.getEditors(1 /* SEQUENTIAL */);
            var index = editors.indexOf(group.activeEditor);
            return { editor: index + 1 < editors.length ? editors[index + 1] : editors[0], groupId: group.id };
        };
        OpenNextEditorInGroup.ID = 'workbench.action.nextEditorInGroup';
        OpenNextEditorInGroup.LABEL = nls.localize('nextEditorInGroup', "Open Next Editor in Group");
        OpenNextEditorInGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenNextEditorInGroup);
        return OpenNextEditorInGroup;
    }(BaseNavigateEditorAction));
    exports.OpenNextEditorInGroup = OpenNextEditorInGroup;
    var OpenPreviousEditorInGroup = /** @class */ (function (_super) {
        __extends(OpenPreviousEditorInGroup, _super);
        function OpenPreviousEditorInGroup(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenPreviousEditorInGroup.prototype.navigate = function () {
            var group = this.editorGroupService.activeGroup;
            var editors = group.getEditors(1 /* SEQUENTIAL */);
            var index = editors.indexOf(group.activeEditor);
            return { editor: index > 0 ? editors[index - 1] : editors[editors.length - 1], groupId: group.id };
        };
        OpenPreviousEditorInGroup.ID = 'workbench.action.previousEditorInGroup';
        OpenPreviousEditorInGroup.LABEL = nls.localize('openPreviousEditorInGroup', "Open Previous Editor in Group");
        OpenPreviousEditorInGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenPreviousEditorInGroup);
        return OpenPreviousEditorInGroup;
    }(BaseNavigateEditorAction));
    exports.OpenPreviousEditorInGroup = OpenPreviousEditorInGroup;
    var OpenFirstEditorInGroup = /** @class */ (function (_super) {
        __extends(OpenFirstEditorInGroup, _super);
        function OpenFirstEditorInGroup(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenFirstEditorInGroup.prototype.navigate = function () {
            var group = this.editorGroupService.activeGroup;
            var editors = group.getEditors(1 /* SEQUENTIAL */);
            return { editor: editors[0], groupId: group.id };
        };
        OpenFirstEditorInGroup.ID = 'workbench.action.firstEditorInGroup';
        OpenFirstEditorInGroup.LABEL = nls.localize('firstEditorInGroup', "Open First Editor in Group");
        OpenFirstEditorInGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenFirstEditorInGroup);
        return OpenFirstEditorInGroup;
    }(BaseNavigateEditorAction));
    exports.OpenFirstEditorInGroup = OpenFirstEditorInGroup;
    var OpenLastEditorInGroup = /** @class */ (function (_super) {
        __extends(OpenLastEditorInGroup, _super);
        function OpenLastEditorInGroup(id, label, editorGroupService, editorService) {
            return _super.call(this, id, label, editorGroupService, editorService) || this;
        }
        OpenLastEditorInGroup.prototype.navigate = function () {
            var group = this.editorGroupService.activeGroup;
            var editors = group.getEditors(1 /* SEQUENTIAL */);
            return { editor: editors[editors.length - 1], groupId: group.id };
        };
        OpenLastEditorInGroup.ID = 'workbench.action.lastEditorInGroup';
        OpenLastEditorInGroup.LABEL = nls.localize('lastEditorInGroup', "Open Last Editor in Group");
        OpenLastEditorInGroup = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService),
            __param(3, editorService_1.IEditorService)
        ], OpenLastEditorInGroup);
        return OpenLastEditorInGroup;
    }(BaseNavigateEditorAction));
    exports.OpenLastEditorInGroup = OpenLastEditorInGroup;
    var NavigateForwardAction = /** @class */ (function (_super) {
        __extends(NavigateForwardAction, _super);
        function NavigateForwardAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        NavigateForwardAction.prototype.run = function () {
            this.historyService.forward();
            return winjs_base_1.TPromise.as(null);
        };
        NavigateForwardAction.ID = 'workbench.action.navigateForward';
        NavigateForwardAction.LABEL = nls.localize('navigateNext', "Go Forward");
        NavigateForwardAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], NavigateForwardAction);
        return NavigateForwardAction;
    }(actions_1.Action));
    exports.NavigateForwardAction = NavigateForwardAction;
    var NavigateBackwardsAction = /** @class */ (function (_super) {
        __extends(NavigateBackwardsAction, _super);
        function NavigateBackwardsAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        NavigateBackwardsAction.prototype.run = function () {
            this.historyService.back();
            return winjs_base_1.TPromise.as(null);
        };
        NavigateBackwardsAction.ID = 'workbench.action.navigateBack';
        NavigateBackwardsAction.LABEL = nls.localize('navigatePrevious', "Go Back");
        NavigateBackwardsAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], NavigateBackwardsAction);
        return NavigateBackwardsAction;
    }(actions_1.Action));
    exports.NavigateBackwardsAction = NavigateBackwardsAction;
    var NavigateToLastEditLocationAction = /** @class */ (function (_super) {
        __extends(NavigateToLastEditLocationAction, _super);
        function NavigateToLastEditLocationAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        NavigateToLastEditLocationAction.prototype.run = function () {
            this.historyService.openLastEditLocation();
            return winjs_base_1.TPromise.as(null);
        };
        NavigateToLastEditLocationAction.ID = 'workbench.action.navigateToLastEditLocation';
        NavigateToLastEditLocationAction.LABEL = nls.localize('navigateToLastEditLocation', "Go to Last Edit Location");
        NavigateToLastEditLocationAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], NavigateToLastEditLocationAction);
        return NavigateToLastEditLocationAction;
    }(actions_1.Action));
    exports.NavigateToLastEditLocationAction = NavigateToLastEditLocationAction;
    var NavigateLastAction = /** @class */ (function (_super) {
        __extends(NavigateLastAction, _super);
        function NavigateLastAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        NavigateLastAction.prototype.run = function () {
            this.historyService.last();
            return winjs_base_1.TPromise.as(null);
        };
        NavigateLastAction.ID = 'workbench.action.navigateLast';
        NavigateLastAction.LABEL = nls.localize('navigateLast', "Go Last");
        NavigateLastAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], NavigateLastAction);
        return NavigateLastAction;
    }(actions_1.Action));
    exports.NavigateLastAction = NavigateLastAction;
    var ReopenClosedEditorAction = /** @class */ (function (_super) {
        __extends(ReopenClosedEditorAction, _super);
        function ReopenClosedEditorAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        ReopenClosedEditorAction.prototype.run = function () {
            this.historyService.reopenLastClosedEditor();
            return winjs_base_1.TPromise.as(false);
        };
        ReopenClosedEditorAction.ID = 'workbench.action.reopenClosedEditor';
        ReopenClosedEditorAction.LABEL = nls.localize('reopenClosedEditor', "Reopen Closed Editor");
        ReopenClosedEditorAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], ReopenClosedEditorAction);
        return ReopenClosedEditorAction;
    }(actions_1.Action));
    exports.ReopenClosedEditorAction = ReopenClosedEditorAction;
    var ClearRecentFilesAction = /** @class */ (function (_super) {
        __extends(ClearRecentFilesAction, _super);
        function ClearRecentFilesAction(id, label, windowsService, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.windowsService = windowsService;
            _this.historyService = historyService;
            return _this;
        }
        ClearRecentFilesAction.prototype.run = function () {
            // Clear global recently opened
            this.windowsService.clearRecentlyOpened();
            // Clear workspace specific recently opened
            this.historyService.clearRecentlyOpened();
            return winjs_base_1.TPromise.as(false);
        };
        ClearRecentFilesAction.ID = 'workbench.action.clearRecentFiles';
        ClearRecentFilesAction.LABEL = nls.localize('clearRecentFiles', "Clear Recently Opened");
        ClearRecentFilesAction = __decorate([
            __param(2, windows_1.IWindowsService),
            __param(3, history_1.IHistoryService)
        ], ClearRecentFilesAction);
        return ClearRecentFilesAction;
    }(actions_1.Action));
    exports.ClearRecentFilesAction = ClearRecentFilesAction;
    var ShowEditorsInActiveGroupAction = /** @class */ (function (_super) {
        __extends(ShowEditorsInActiveGroupAction, _super);
        function ShowEditorsInActiveGroupAction(actionId, actionLabel, quickOpenService) {
            return _super.call(this, actionId, actionLabel, editorCommands_1.NAVIGATE_IN_ACTIVE_GROUP_PREFIX, quickOpenService) || this;
        }
        ShowEditorsInActiveGroupAction.ID = 'workbench.action.showEditorsInActiveGroup';
        ShowEditorsInActiveGroupAction.LABEL = nls.localize('showEditorsInActiveGroup', "Show Editors in Active Group");
        ShowEditorsInActiveGroupAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService)
        ], ShowEditorsInActiveGroupAction);
        return ShowEditorsInActiveGroupAction;
    }(quickopen_1.QuickOpenAction));
    exports.ShowEditorsInActiveGroupAction = ShowEditorsInActiveGroupAction;
    var ShowAllEditorsAction = /** @class */ (function (_super) {
        __extends(ShowAllEditorsAction, _super);
        function ShowAllEditorsAction(actionId, actionLabel, quickOpenService) {
            return _super.call(this, actionId, actionLabel, editorCommands_1.NAVIGATE_ALL_EDITORS_GROUP_PREFIX, quickOpenService) || this;
        }
        ShowAllEditorsAction.ID = 'workbench.action.showAllEditors';
        ShowAllEditorsAction.LABEL = nls.localize('showAllEditors', "Show All Editors");
        ShowAllEditorsAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService)
        ], ShowAllEditorsAction);
        return ShowAllEditorsAction;
    }(quickopen_1.QuickOpenAction));
    exports.ShowAllEditorsAction = ShowAllEditorsAction;
    var BaseQuickOpenEditorInGroupAction = /** @class */ (function (_super) {
        __extends(BaseQuickOpenEditorInGroupAction, _super);
        function BaseQuickOpenEditorInGroupAction(id, label, quickOpenService, keybindingService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.keybindingService = keybindingService;
            return _this;
        }
        BaseQuickOpenEditorInGroupAction.prototype.run = function () {
            var keys = this.keybindingService.lookupKeybindings(this.id);
            this.quickOpenService.show(editorCommands_1.NAVIGATE_IN_ACTIVE_GROUP_PREFIX, { quickNavigateConfiguration: { keybindings: keys } });
            return winjs_base_1.TPromise.as(true);
        };
        BaseQuickOpenEditorInGroupAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, keybinding_1.IKeybindingService)
        ], BaseQuickOpenEditorInGroupAction);
        return BaseQuickOpenEditorInGroupAction;
    }(actions_1.Action));
    exports.BaseQuickOpenEditorInGroupAction = BaseQuickOpenEditorInGroupAction;
    var OpenPreviousRecentlyUsedEditorInGroupAction = /** @class */ (function (_super) {
        __extends(OpenPreviousRecentlyUsedEditorInGroupAction, _super);
        function OpenPreviousRecentlyUsedEditorInGroupAction(id, label, quickOpenService, keybindingService) {
            return _super.call(this, id, label, quickOpenService, keybindingService) || this;
        }
        OpenPreviousRecentlyUsedEditorInGroupAction.ID = 'workbench.action.openPreviousRecentlyUsedEditorInGroup';
        OpenPreviousRecentlyUsedEditorInGroupAction.LABEL = nls.localize('openPreviousRecentlyUsedEditorInGroup', "Open Previous Recently Used Editor in Group");
        OpenPreviousRecentlyUsedEditorInGroupAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, keybinding_1.IKeybindingService)
        ], OpenPreviousRecentlyUsedEditorInGroupAction);
        return OpenPreviousRecentlyUsedEditorInGroupAction;
    }(BaseQuickOpenEditorInGroupAction));
    exports.OpenPreviousRecentlyUsedEditorInGroupAction = OpenPreviousRecentlyUsedEditorInGroupAction;
    var OpenNextRecentlyUsedEditorInGroupAction = /** @class */ (function (_super) {
        __extends(OpenNextRecentlyUsedEditorInGroupAction, _super);
        function OpenNextRecentlyUsedEditorInGroupAction(id, label, quickOpenService, keybindingService) {
            return _super.call(this, id, label, quickOpenService, keybindingService) || this;
        }
        OpenNextRecentlyUsedEditorInGroupAction.ID = 'workbench.action.openNextRecentlyUsedEditorInGroup';
        OpenNextRecentlyUsedEditorInGroupAction.LABEL = nls.localize('openNextRecentlyUsedEditorInGroup', "Open Next Recently Used Editor in Group");
        OpenNextRecentlyUsedEditorInGroupAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, keybinding_1.IKeybindingService)
        ], OpenNextRecentlyUsedEditorInGroupAction);
        return OpenNextRecentlyUsedEditorInGroupAction;
    }(BaseQuickOpenEditorInGroupAction));
    exports.OpenNextRecentlyUsedEditorInGroupAction = OpenNextRecentlyUsedEditorInGroupAction;
    var OpenPreviousEditorFromHistoryAction = /** @class */ (function (_super) {
        __extends(OpenPreviousEditorFromHistoryAction, _super);
        function OpenPreviousEditorFromHistoryAction(id, label, quickOpenService, keybindingService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.keybindingService = keybindingService;
            return _this;
        }
        OpenPreviousEditorFromHistoryAction.prototype.run = function () {
            var keys = this.keybindingService.lookupKeybindings(this.id);
            this.quickOpenService.show(null, { quickNavigateConfiguration: { keybindings: keys } });
            return winjs_base_1.TPromise.as(true);
        };
        OpenPreviousEditorFromHistoryAction.ID = 'workbench.action.openPreviousEditorFromHistory';
        OpenPreviousEditorFromHistoryAction.LABEL = nls.localize('navigateEditorHistoryByInput', "Open Previous Editor from History");
        OpenPreviousEditorFromHistoryAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, keybinding_1.IKeybindingService)
        ], OpenPreviousEditorFromHistoryAction);
        return OpenPreviousEditorFromHistoryAction;
    }(actions_1.Action));
    exports.OpenPreviousEditorFromHistoryAction = OpenPreviousEditorFromHistoryAction;
    var OpenNextRecentlyUsedEditorAction = /** @class */ (function (_super) {
        __extends(OpenNextRecentlyUsedEditorAction, _super);
        function OpenNextRecentlyUsedEditorAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        OpenNextRecentlyUsedEditorAction.prototype.run = function () {
            this.historyService.forward(true);
            return winjs_base_1.TPromise.as(null);
        };
        OpenNextRecentlyUsedEditorAction.ID = 'workbench.action.openNextRecentlyUsedEditor';
        OpenNextRecentlyUsedEditorAction.LABEL = nls.localize('openNextRecentlyUsedEditor', "Open Next Recently Used Editor");
        OpenNextRecentlyUsedEditorAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], OpenNextRecentlyUsedEditorAction);
        return OpenNextRecentlyUsedEditorAction;
    }(actions_1.Action));
    exports.OpenNextRecentlyUsedEditorAction = OpenNextRecentlyUsedEditorAction;
    var OpenPreviousRecentlyUsedEditorAction = /** @class */ (function (_super) {
        __extends(OpenPreviousRecentlyUsedEditorAction, _super);
        function OpenPreviousRecentlyUsedEditorAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        OpenPreviousRecentlyUsedEditorAction.prototype.run = function () {
            this.historyService.back(true);
            return winjs_base_1.TPromise.as(null);
        };
        OpenPreviousRecentlyUsedEditorAction.ID = 'workbench.action.openPreviousRecentlyUsedEditor';
        OpenPreviousRecentlyUsedEditorAction.LABEL = nls.localize('openPreviousRecentlyUsedEditor', "Open Previous Recently Used Editor");
        OpenPreviousRecentlyUsedEditorAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], OpenPreviousRecentlyUsedEditorAction);
        return OpenPreviousRecentlyUsedEditorAction;
    }(actions_1.Action));
    exports.OpenPreviousRecentlyUsedEditorAction = OpenPreviousRecentlyUsedEditorAction;
    var ClearEditorHistoryAction = /** @class */ (function (_super) {
        __extends(ClearEditorHistoryAction, _super);
        function ClearEditorHistoryAction(id, label, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.historyService = historyService;
            return _this;
        }
        ClearEditorHistoryAction.prototype.run = function () {
            // Editor history
            this.historyService.clear();
            return winjs_base_1.TPromise.as(true);
        };
        ClearEditorHistoryAction.ID = 'workbench.action.clearEditorHistory';
        ClearEditorHistoryAction.LABEL = nls.localize('clearEditorHistory', "Clear Editor History");
        ClearEditorHistoryAction = __decorate([
            __param(2, history_1.IHistoryService)
        ], ClearEditorHistoryAction);
        return ClearEditorHistoryAction;
    }(actions_1.Action));
    exports.ClearEditorHistoryAction = ClearEditorHistoryAction;
    var MoveEditorLeftInGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorLeftInGroupAction, _super);
        function MoveEditorLeftInGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'left' }) || this;
        }
        MoveEditorLeftInGroupAction.ID = 'workbench.action.moveEditorLeftInGroup';
        MoveEditorLeftInGroupAction.LABEL = nls.localize('moveEditorLeft', "Move Editor Left");
        MoveEditorLeftInGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorLeftInGroupAction);
        return MoveEditorLeftInGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorLeftInGroupAction = MoveEditorLeftInGroupAction;
    var MoveEditorRightInGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorRightInGroupAction, _super);
        function MoveEditorRightInGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'right' }) || this;
        }
        MoveEditorRightInGroupAction.ID = 'workbench.action.moveEditorRightInGroup';
        MoveEditorRightInGroupAction.LABEL = nls.localize('moveEditorRight', "Move Editor Right");
        MoveEditorRightInGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorRightInGroupAction);
        return MoveEditorRightInGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorRightInGroupAction = MoveEditorRightInGroupAction;
    var MoveEditorToPreviousGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToPreviousGroupAction, _super);
        function MoveEditorToPreviousGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'previous', by: 'group' }) || this;
        }
        MoveEditorToPreviousGroupAction.ID = 'workbench.action.moveEditorToPreviousGroup';
        MoveEditorToPreviousGroupAction.LABEL = nls.localize('moveEditorToPreviousGroup', "Move Editor into Previous Group");
        MoveEditorToPreviousGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToPreviousGroupAction);
        return MoveEditorToPreviousGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToPreviousGroupAction = MoveEditorToPreviousGroupAction;
    var MoveEditorToNextGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToNextGroupAction, _super);
        function MoveEditorToNextGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'next', by: 'group' }) || this;
        }
        MoveEditorToNextGroupAction.ID = 'workbench.action.moveEditorToNextGroup';
        MoveEditorToNextGroupAction.LABEL = nls.localize('moveEditorToNextGroup', "Move Editor into Next Group");
        MoveEditorToNextGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToNextGroupAction);
        return MoveEditorToNextGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToNextGroupAction = MoveEditorToNextGroupAction;
    var MoveEditorToAboveGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToAboveGroupAction, _super);
        function MoveEditorToAboveGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'up', by: 'group' }) || this;
        }
        MoveEditorToAboveGroupAction.ID = 'workbench.action.moveEditorToAboveGroup';
        MoveEditorToAboveGroupAction.LABEL = nls.localize('moveEditorToAboveGroup', "Move Editor into Above Group");
        MoveEditorToAboveGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToAboveGroupAction);
        return MoveEditorToAboveGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToAboveGroupAction = MoveEditorToAboveGroupAction;
    var MoveEditorToBelowGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToBelowGroupAction, _super);
        function MoveEditorToBelowGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'down', by: 'group' }) || this;
        }
        MoveEditorToBelowGroupAction.ID = 'workbench.action.moveEditorToBelowGroup';
        MoveEditorToBelowGroupAction.LABEL = nls.localize('moveEditorToBelowGroup', "Move Editor into Below Group");
        MoveEditorToBelowGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToBelowGroupAction);
        return MoveEditorToBelowGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToBelowGroupAction = MoveEditorToBelowGroupAction;
    var MoveEditorToLeftGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToLeftGroupAction, _super);
        function MoveEditorToLeftGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'left', by: 'group' }) || this;
        }
        MoveEditorToLeftGroupAction.ID = 'workbench.action.moveEditorToLeftGroup';
        MoveEditorToLeftGroupAction.LABEL = nls.localize('moveEditorToLeftGroup', "Move Editor into Left Group");
        MoveEditorToLeftGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToLeftGroupAction);
        return MoveEditorToLeftGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToLeftGroupAction = MoveEditorToLeftGroupAction;
    var MoveEditorToRightGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToRightGroupAction, _super);
        function MoveEditorToRightGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'right', by: 'group' }) || this;
        }
        MoveEditorToRightGroupAction.ID = 'workbench.action.moveEditorToRightGroup';
        MoveEditorToRightGroupAction.LABEL = nls.localize('moveEditorToRightGroup', "Move Editor into Right Group");
        MoveEditorToRightGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToRightGroupAction);
        return MoveEditorToRightGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToRightGroupAction = MoveEditorToRightGroupAction;
    var MoveEditorToFirstGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToFirstGroupAction, _super);
        function MoveEditorToFirstGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'first', by: 'group' }) || this;
        }
        MoveEditorToFirstGroupAction.ID = 'workbench.action.moveEditorToFirstGroup';
        MoveEditorToFirstGroupAction.LABEL = nls.localize('moveEditorToFirstGroup', "Move Editor into First Group");
        MoveEditorToFirstGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToFirstGroupAction);
        return MoveEditorToFirstGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToFirstGroupAction = MoveEditorToFirstGroupAction;
    var MoveEditorToLastGroupAction = /** @class */ (function (_super) {
        __extends(MoveEditorToLastGroupAction, _super);
        function MoveEditorToLastGroupAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.MOVE_ACTIVE_EDITOR_COMMAND_ID, commandService, { to: 'last', by: 'group' }) || this;
        }
        MoveEditorToLastGroupAction.ID = 'workbench.action.moveEditorToLastGroup';
        MoveEditorToLastGroupAction.LABEL = nls.localize('moveEditorToLastGroup', "Move Editor into Last Group");
        MoveEditorToLastGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], MoveEditorToLastGroupAction);
        return MoveEditorToLastGroupAction;
    }(ExecuteCommandAction));
    exports.MoveEditorToLastGroupAction = MoveEditorToLastGroupAction;
    var EditorLayoutSingleAction = /** @class */ (function (_super) {
        __extends(EditorLayoutSingleAction, _super);
        function EditorLayoutSingleAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}] }) || this;
        }
        EditorLayoutSingleAction.ID = 'workbench.action.editorLayoutSingle';
        EditorLayoutSingleAction.LABEL = nls.localize('editorLayoutSingle', "Single Column Editor Layout");
        EditorLayoutSingleAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutSingleAction);
        return EditorLayoutSingleAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutSingleAction = EditorLayoutSingleAction;
    var EditorLayoutTwoColumnsAction = /** @class */ (function (_super) {
        __extends(EditorLayoutTwoColumnsAction, _super);
        function EditorLayoutTwoColumnsAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, {}], orientation: 0 /* HORIZONTAL */ }) || this;
        }
        EditorLayoutTwoColumnsAction.ID = 'workbench.action.editorLayoutTwoColumns';
        EditorLayoutTwoColumnsAction.LABEL = nls.localize('editorLayoutTwoColumns', "Two Columns Editor Layout");
        EditorLayoutTwoColumnsAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutTwoColumnsAction);
        return EditorLayoutTwoColumnsAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutTwoColumnsAction = EditorLayoutTwoColumnsAction;
    var EditorLayoutThreeColumnsAction = /** @class */ (function (_super) {
        __extends(EditorLayoutThreeColumnsAction, _super);
        function EditorLayoutThreeColumnsAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, {}, {}], orientation: 0 /* HORIZONTAL */ }) || this;
        }
        EditorLayoutThreeColumnsAction.ID = 'workbench.action.editorLayoutThreeColumns';
        EditorLayoutThreeColumnsAction.LABEL = nls.localize('editorLayoutThreeColumns', "Three Columns Editor Layout");
        EditorLayoutThreeColumnsAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutThreeColumnsAction);
        return EditorLayoutThreeColumnsAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutThreeColumnsAction = EditorLayoutThreeColumnsAction;
    var EditorLayoutTwoRowsAction = /** @class */ (function (_super) {
        __extends(EditorLayoutTwoRowsAction, _super);
        function EditorLayoutTwoRowsAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, {}], orientation: 1 /* VERTICAL */ }) || this;
        }
        EditorLayoutTwoRowsAction.ID = 'workbench.action.editorLayoutTwoRows';
        EditorLayoutTwoRowsAction.LABEL = nls.localize('editorLayoutTwoRows', "Two Rows Editor Layout");
        EditorLayoutTwoRowsAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutTwoRowsAction);
        return EditorLayoutTwoRowsAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutTwoRowsAction = EditorLayoutTwoRowsAction;
    var EditorLayoutThreeRowsAction = /** @class */ (function (_super) {
        __extends(EditorLayoutThreeRowsAction, _super);
        function EditorLayoutThreeRowsAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, {}, {}], orientation: 1 /* VERTICAL */ }) || this;
        }
        EditorLayoutThreeRowsAction.ID = 'workbench.action.editorLayoutThreeRows';
        EditorLayoutThreeRowsAction.LABEL = nls.localize('editorLayoutThreeRows', "Three Rows Editor Layout");
        EditorLayoutThreeRowsAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutThreeRowsAction);
        return EditorLayoutThreeRowsAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutThreeRowsAction = EditorLayoutThreeRowsAction;
    var EditorLayoutTwoByTwoGridAction = /** @class */ (function (_super) {
        __extends(EditorLayoutTwoByTwoGridAction, _super);
        function EditorLayoutTwoByTwoGridAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{ groups: [{}, {}] }, { groups: [{}, {}] }] }) || this;
        }
        EditorLayoutTwoByTwoGridAction.ID = 'workbench.action.editorLayoutTwoByTwoGrid';
        EditorLayoutTwoByTwoGridAction.LABEL = nls.localize('editorLayoutTwoByTwoGrid', "Grid Editor Layout (2x2)");
        EditorLayoutTwoByTwoGridAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutTwoByTwoGridAction);
        return EditorLayoutTwoByTwoGridAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutTwoByTwoGridAction = EditorLayoutTwoByTwoGridAction;
    var EditorLayoutTwoColumnsBottomAction = /** @class */ (function (_super) {
        __extends(EditorLayoutTwoColumnsBottomAction, _super);
        function EditorLayoutTwoColumnsBottomAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, { groups: [{}, {}] }], orientation: 1 /* VERTICAL */ }) || this;
        }
        EditorLayoutTwoColumnsBottomAction.ID = 'workbench.action.editorLayoutTwoColumnsBottom';
        EditorLayoutTwoColumnsBottomAction.LABEL = nls.localize('editorLayoutTwoColumnsBottom', "Two Columns Bottom Editor Layout");
        EditorLayoutTwoColumnsBottomAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutTwoColumnsBottomAction);
        return EditorLayoutTwoColumnsBottomAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutTwoColumnsBottomAction = EditorLayoutTwoColumnsBottomAction;
    var EditorLayoutTwoRowsRightAction = /** @class */ (function (_super) {
        __extends(EditorLayoutTwoRowsRightAction, _super);
        function EditorLayoutTwoRowsRightAction(id, label, commandService) {
            return _super.call(this, id, label, editorCommands_1.LAYOUT_EDITOR_GROUPS_COMMAND_ID, commandService, { groups: [{}, { groups: [{}, {}] }], orientation: 0 /* HORIZONTAL */ }) || this;
        }
        EditorLayoutTwoRowsRightAction.ID = 'workbench.action.editorLayoutTwoRowsRight';
        EditorLayoutTwoRowsRightAction.LABEL = nls.localize('editorLayoutTwoRowsRight', "Two Rows Right Editor Layout");
        EditorLayoutTwoRowsRightAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], EditorLayoutTwoRowsRightAction);
        return EditorLayoutTwoRowsRightAction;
    }(ExecuteCommandAction));
    exports.EditorLayoutTwoRowsRightAction = EditorLayoutTwoRowsRightAction;
    var BaseCreateEditorGroupAction = /** @class */ (function (_super) {
        __extends(BaseCreateEditorGroupAction, _super);
        function BaseCreateEditorGroupAction(id, label, direction, editorGroupService) {
            var _this = _super.call(this, id, label) || this;
            _this.direction = direction;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        BaseCreateEditorGroupAction.prototype.run = function () {
            this.editorGroupService.addGroup(this.editorGroupService.activeGroup, this.direction, { activate: true });
            return winjs_base_1.TPromise.as(true);
        };
        return BaseCreateEditorGroupAction;
    }(actions_1.Action));
    exports.BaseCreateEditorGroupAction = BaseCreateEditorGroupAction;
    var NewEditorGroupLeftAction = /** @class */ (function (_super) {
        __extends(NewEditorGroupLeftAction, _super);
        function NewEditorGroupLeftAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 2 /* LEFT */, editorGroupService) || this;
        }
        NewEditorGroupLeftAction.ID = 'workbench.action.newGroupLeft';
        NewEditorGroupLeftAction.LABEL = nls.localize('newEditorLeft', "New Editor Group to the Left");
        NewEditorGroupLeftAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], NewEditorGroupLeftAction);
        return NewEditorGroupLeftAction;
    }(BaseCreateEditorGroupAction));
    exports.NewEditorGroupLeftAction = NewEditorGroupLeftAction;
    var NewEditorGroupRightAction = /** @class */ (function (_super) {
        __extends(NewEditorGroupRightAction, _super);
        function NewEditorGroupRightAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 3 /* RIGHT */, editorGroupService) || this;
        }
        NewEditorGroupRightAction.ID = 'workbench.action.newGroupRight';
        NewEditorGroupRightAction.LABEL = nls.localize('newEditorRight', "New Editor Group to the Right");
        NewEditorGroupRightAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], NewEditorGroupRightAction);
        return NewEditorGroupRightAction;
    }(BaseCreateEditorGroupAction));
    exports.NewEditorGroupRightAction = NewEditorGroupRightAction;
    var NewEditorGroupAboveAction = /** @class */ (function (_super) {
        __extends(NewEditorGroupAboveAction, _super);
        function NewEditorGroupAboveAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 0 /* UP */, editorGroupService) || this;
        }
        NewEditorGroupAboveAction.ID = 'workbench.action.newGroupAbove';
        NewEditorGroupAboveAction.LABEL = nls.localize('newEditorAbove', "New Editor Group Above");
        NewEditorGroupAboveAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], NewEditorGroupAboveAction);
        return NewEditorGroupAboveAction;
    }(BaseCreateEditorGroupAction));
    exports.NewEditorGroupAboveAction = NewEditorGroupAboveAction;
    var NewEditorGroupBelowAction = /** @class */ (function (_super) {
        __extends(NewEditorGroupBelowAction, _super);
        function NewEditorGroupBelowAction(id, label, editorGroupService) {
            return _super.call(this, id, label, 1 /* DOWN */, editorGroupService) || this;
        }
        NewEditorGroupBelowAction.ID = 'workbench.action.newGroupBelow';
        NewEditorGroupBelowAction.LABEL = nls.localize('newEditorBelow', "New Editor Group Below");
        NewEditorGroupBelowAction = __decorate([
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], NewEditorGroupBelowAction);
        return NewEditorGroupBelowAction;
    }(BaseCreateEditorGroupAction));
    exports.NewEditorGroupBelowAction = NewEditorGroupBelowAction;
});























define(__m[128/*vs/workbench/common/editor/untitledEditorInput*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,131/*vs/base/common/mime*/,146/*vs/base/common/decorators*/,152/*vs/editor/common/modes/modesRegistry*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,13/*vs/workbench/common/editor*/,272/*vs/workbench/common/editor/untitledEditorModel*/,3/*vs/platform/instantiation/common/instantiation*/,6/*vs/base/common/event*/,27/*vs/workbench/services/textfile/common/textfiles*/,189/*vs/platform/telemetry/common/telemetryUtils*/,94/*vs/workbench/services/hash/common/hashService*/,59/*vs/platform/label/common/label*/]), function (require, exports, winjs_base_1, mime_1, decorators_1, modesRegistry_1, paths, resources, editor_1, untitledEditorModel_1, instantiation_1, event_1, textfiles_1, telemetryUtils_1, hashService_1, label_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor input to be used for untitled text buffers.
     */
    var UntitledEditorInput = /** @class */ (function (_super) {
        __extends(UntitledEditorInput, _super);
        function UntitledEditorInput(resource, hasAssociatedFilePath, modeId, initialValue, preferredEncoding, instantiationService, textFileService, hashService, labelService) {
            var _this = _super.call(this) || this;
            _this.resource = resource;
            _this.modeId = modeId;
            _this.initialValue = initialValue;
            _this.preferredEncoding = preferredEncoding;
            _this.instantiationService = instantiationService;
            _this.textFileService = textFileService;
            _this.hashService = hashService;
            _this.labelService = labelService;
            _this._onDidModelChangeContent = _this._register(new event_1.Emitter());
            _this._onDidModelChangeEncoding = _this._register(new event_1.Emitter());
            _this._hasAssociatedFilePath = hasAssociatedFilePath;
            return _this;
        }
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeContent", {
            get: function () { return this._onDidModelChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "onDidModelChangeEncoding", {
            get: function () { return this._onDidModelChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "hasAssociatedFilePath", {
            get: function () {
                return this._hasAssociatedFilePath;
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getTypeId = function () {
            return UntitledEditorInput.ID;
        };
        UntitledEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        UntitledEditorInput.prototype.getModeId = function () {
            if (this.cachedModel) {
                return this.cachedModel.getModeId();
            }
            return this.modeId;
        };
        UntitledEditorInput.prototype.getName = function () {
            return this.hasAssociatedFilePath ? resources.basenameOrAuthority(this.resource) : this.resource.path;
        };
        Object.defineProperty(UntitledEditorInput.prototype, "shortDescription", {
            get: function () {
                return paths.basename(this.labelService.getUriLabel(resources.dirname(this.resource)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "mediumDescription", {
            get: function () {
                return this.labelService.getUriLabel(resources.dirname(this.resource), { relative: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "longDescription", {
            get: function () {
                return this.labelService.getUriLabel(resources.dirname(this.resource));
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getDescription = function (verbosity) {
            if (verbosity === void 0) { verbosity = 1 /* MEDIUM */; }
            if (!this.hasAssociatedFilePath) {
                return null;
            }
            var description;
            switch (verbosity) {
                case 0 /* SHORT */:
                    description = this.shortDescription;
                    break;
                case 2 /* LONG */:
                    description = this.longDescription;
                    break;
                case 1 /* MEDIUM */:
                default:
                    description = this.mediumDescription;
                    break;
            }
            return description;
        };
        Object.defineProperty(UntitledEditorInput.prototype, "shortTitle", {
            get: function () {
                return this.getName();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "mediumTitle", {
            get: function () {
                return this.labelService.getUriLabel(this.resource, { relative: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorInput.prototype, "longTitle", {
            get: function () {
                return this.labelService.getUriLabel(this.resource);
            },
            enumerable: true,
            configurable: true
        });
        UntitledEditorInput.prototype.getTitle = function (verbosity) {
            if (!this.hasAssociatedFilePath) {
                return this.getName();
            }
            var title;
            switch (verbosity) {
                case 0 /* SHORT */:
                    title = this.shortTitle;
                    break;
                case 1 /* MEDIUM */:
                    title = this.mediumTitle;
                    break;
                case 2 /* LONG */:
                    title = this.longTitle;
                    break;
            }
            return title;
        };
        UntitledEditorInput.prototype.isDirty = function () {
            if (this.cachedModel) {
                return this.cachedModel.isDirty();
            }
            // A disposed input is never dirty, even if it was restored from backup
            if (this.isDisposed()) {
                return false;
            }
            // untitled files with an associated path or associated resource
            return this.hasAssociatedFilePath;
        };
        UntitledEditorInput.prototype.confirmSave = function () {
            return this.textFileService.confirmSave([this.resource]);
        };
        UntitledEditorInput.prototype.save = function () {
            return this.textFileService.save(this.resource);
        };
        UntitledEditorInput.prototype.revert = function () {
            if (this.cachedModel) {
                this.cachedModel.revert();
            }
            this.dispose(); // a reverted untitled editor is no longer valid, so we dispose it
            return winjs_base_1.TPromise.as(true);
        };
        UntitledEditorInput.prototype.suggestFileName = function () {
            if (!this.hasAssociatedFilePath) {
                if (this.cachedModel) {
                    var modeId = this.cachedModel.getModeId();
                    if (modeId !== modesRegistry_1.PLAINTEXT_MODE_ID) { // do not suggest when the mode ID is simple plain text
                        return mime_1.suggestFilename(modeId, this.getName());
                    }
                }
            }
            return this.getName();
        };
        UntitledEditorInput.prototype.getEncoding = function () {
            if (this.cachedModel) {
                return this.cachedModel.getEncoding();
            }
            return this.preferredEncoding;
        };
        UntitledEditorInput.prototype.setEncoding = function (encoding, mode /* ignored, we only have Encode */) {
            this.preferredEncoding = encoding;
            if (this.cachedModel) {
                this.cachedModel.setEncoding(encoding);
            }
        };
        UntitledEditorInput.prototype.resolve = function () {
            // Join a model resolve if we have had one before
            if (this.modelResolve) {
                return this.modelResolve;
            }
            // Otherwise Create Model and load
            this.cachedModel = this.createModel();
            this.modelResolve = this.cachedModel.load();
            return this.modelResolve;
        };
        UntitledEditorInput.prototype.createModel = function () {
            var _this = this;
            var model = this._register(this.instantiationService.createInstance(untitledEditorModel_1.UntitledEditorModel, this.modeId, this.resource, this.hasAssociatedFilePath, this.initialValue, this.preferredEncoding));
            // re-emit some events from the model
            this._register(model.onDidChangeContent(function () { return _this._onDidModelChangeContent.fire(); }));
            this._register(model.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
            this._register(model.onDidChangeEncoding(function () { return _this._onDidModelChangeEncoding.fire(); }));
            return model;
        };
        UntitledEditorInput.prototype.getTelemetryDescriptor = function () {
            var _this = this;
            var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
            descriptor['resource'] = telemetryUtils_1.telemetryURIDescriptor(this.getResource(), function (path) { return _this.hashService.createSHA1(path); });
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "resource": { "${inline}": [ "${URIDescriptor}" ] }
                }
            */
            return descriptor;
        };
        UntitledEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput instanceof UntitledEditorInput) {
                var otherUntitledEditorInput = otherInput;
                // Otherwise compare by properties
                return otherUntitledEditorInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        UntitledEditorInput.prototype.dispose = function () {
            this.modelResolve = void 0;
            _super.prototype.dispose.call(this);
        };
        UntitledEditorInput.ID = 'workbench.editors.untitledEditorInput';
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "shortDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "mediumDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "longDescription", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "shortTitle", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "mediumTitle", null);
        __decorate([
            decorators_1.memoize
        ], UntitledEditorInput.prototype, "longTitle", null);
        UntitledEditorInput = __decorate([
            __param(5, instantiation_1.IInstantiationService),
            __param(6, textfiles_1.ITextFileService),
            __param(7, hashService_1.IHashService),
            __param(8, label_1.ILabelService)
        ], UntitledEditorInput);
        return UntitledEditorInput;
    }(editor_1.EditorInput));
    exports.UntitledEditorInput = UntitledEditorInput;
});























define(__m[372/*vs/workbench/browser/parts/editor/textResourceEditor*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,29/*vs/base/common/types*/,93/*vs/workbench/common/editor/resourceEditorInput*/,116/*vs/workbench/common/editor/textEditorModel*/,128/*vs/workbench/common/editor/untitledEditorInput*/,149/*vs/workbench/browser/parts/editor/textEditor*/,32/*vs/platform/telemetry/common/telemetry*/,44/*vs/platform/storage/common/storage*/,88/*vs/editor/common/services/resourceConfiguration*/,3/*vs/platform/instantiation/common/instantiation*/,14/*vs/platform/theme/common/themeService*/,27/*vs/workbench/services/textfile/common/textfiles*/,6/*vs/base/common/event*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,42/*vs/platform/windows/common/windows*/]), function (require, exports, winjs_base_1, nls, types, resourceEditorInput_1, textEditorModel_1, untitledEditorInput_1, textEditor_1, telemetry_1, storage_1, resourceConfiguration_1, instantiation_1, themeService_1, textfiles_1, event_1, editorGroupsService_1, editorService_1, windows_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An editor implementation that is capable of showing the contents of resource inputs. Uses
     * the TextEditor widget to show the contents.
     */
    var AbstractTextResourceEditor = /** @class */ (function (_super) {
        __extends(AbstractTextResourceEditor, _super);
        function AbstractTextResourceEditor(id, telemetryService, instantiationService, storageService, configurationService, themeService, editorGroupService, textFileService, editorService, windowService) {
            return _super.call(this, id, telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorService, editorGroupService, windowService) || this;
        }
        AbstractTextResourceEditor.prototype.getTitle = function () {
            if (this.input) {
                return this.input.getName();
            }
            return nls.localize('textEditor', "Text Editor");
        };
        AbstractTextResourceEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            // Remember view settings if input changes
            this.saveTextResourceEditorViewState(this.input);
            // Set input and resolve
            return _super.prototype.setInput.call(this, input, options, token).then(function () {
                return input.resolve().then(function (resolvedModel) {
                    // Check for cancellation
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    // Assert Model instance
                    if (!(resolvedModel instanceof textEditorModel_1.BaseTextEditorModel)) {
                        return winjs_base_1.TPromise.wrapError(new Error('Unable to open file as text'));
                    }
                    // Set Editor Model
                    var textEditor = _this.getControl();
                    var textEditorModel = resolvedModel.textEditorModel;
                    textEditor.setModel(textEditorModel);
                    // Apply Options from TextOptions
                    var optionsGotApplied = false;
                    var textOptions = options;
                    if (textOptions && types.isFunction(textOptions.apply)) {
                        optionsGotApplied = textOptions.apply(textEditor, 1 /* Immediate */);
                    }
                    // Otherwise restore View State
                    if (!optionsGotApplied) {
                        _this.restoreTextResourceEditorViewState(input);
                    }
                    return void 0;
                });
            });
        };
        AbstractTextResourceEditor.prototype.restoreTextResourceEditorViewState = function (input) {
            if (input instanceof untitledEditorInput_1.UntitledEditorInput || input instanceof resourceEditorInput_1.ResourceEditorInput) {
                var viewState = this.loadTextEditorViewState(input.getResource());
                if (viewState) {
                    this.getControl().restoreViewState(viewState);
                }
            }
        };
        AbstractTextResourceEditor.prototype.setOptions = function (options) {
            var textOptions = options;
            if (textOptions && types.isFunction(textOptions.apply)) {
                textOptions.apply(this.getControl(), 0 /* Smooth */);
            }
        };
        AbstractTextResourceEditor.prototype.getConfigurationOverrides = function () {
            var options = _super.prototype.getConfigurationOverrides.call(this);
            options.readOnly = !(this.input instanceof untitledEditorInput_1.UntitledEditorInput); // all resource editors are readonly except for the untitled one;
            return options;
        };
        AbstractTextResourceEditor.prototype.getAriaLabel = function () {
            var input = this.input;
            var isReadonly = !(this.input instanceof untitledEditorInput_1.UntitledEditorInput);
            var ariaLabel;
            var inputName = input && input.getName();
            if (isReadonly) {
                ariaLabel = inputName ? nls.localize('readonlyEditorWithInputAriaLabel', "{0}. Readonly text editor.", inputName) : nls.localize('readonlyEditorAriaLabel', "Readonly text editor.");
            }
            else {
                ariaLabel = inputName ? nls.localize('untitledFileEditorWithInputAriaLabel', "{0}. Untitled file text editor.", inputName) : nls.localize('untitledFileEditorAriaLabel', "Untitled file text editor.");
            }
            return ariaLabel;
        };
        /**
         * Reveals the last line of this editor if it has a model set.
         * When smart is true only scroll if the cursor is currently on the last line of the output panel.
         * This allows users to click on the output panel to stop scrolling when they see something of interest.
         * To resume, they should scroll to the end of the output panel again.
         */
        AbstractTextResourceEditor.prototype.revealLastLine = function (smart) {
            var codeEditor = this.getControl();
            var model = codeEditor.getModel();
            if (model) {
                var lastLine = model.getLineCount();
                if (!smart || codeEditor.getPosition().lineNumber === lastLine) {
                    codeEditor.revealPosition({ lineNumber: lastLine, column: model.getLineMaxColumn(lastLine) }, 0 /* Smooth */);
                }
            }
        };
        AbstractTextResourceEditor.prototype.clearInput = function () {
            // Keep editor view state in settings to restore when coming back
            this.saveTextResourceEditorViewState(this.input);
            // Clear Model
            this.getControl().setModel(null);
            _super.prototype.clearInput.call(this);
        };
        AbstractTextResourceEditor.prototype.shutdown = function () {
            // Save View State (only for untitled)
            if (this.input instanceof untitledEditorInput_1.UntitledEditorInput) {
                this.saveTextResourceEditorViewState(this.input);
            }
            // Call Super
            _super.prototype.shutdown.call(this);
        };
        AbstractTextResourceEditor.prototype.saveTextResourceEditorViewState = function (input) {
            var _this = this;
            if (!(input instanceof untitledEditorInput_1.UntitledEditorInput) && !(input instanceof resourceEditorInput_1.ResourceEditorInput)) {
                return; // only enabled for untitled and resource inputs
            }
            var resource = input.getResource();
            // Clear view state if input is disposed
            if (input.isDisposed()) {
                _super.prototype.clearTextEditorViewState.call(this, [resource]);
            }
            // Otherwise save it
            else {
                _super.prototype.saveTextEditorViewState.call(this, resource);
                // Make sure to clean up when the input gets disposed
                event_1.once(input.onDispose)(function () {
                    _super.prototype.clearTextEditorViewState.call(_this, [resource]);
                });
            }
        };
        AbstractTextResourceEditor = __decorate([
            __param(1, telemetry_1.ITelemetryService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, storage_1.IStorageService),
            __param(4, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(5, themeService_1.IThemeService),
            __param(6, editorGroupsService_1.IEditorGroupsService),
            __param(7, textfiles_1.ITextFileService),
            __param(8, editorService_1.IEditorService),
            __param(9, windows_1.IWindowService)
        ], AbstractTextResourceEditor);
        return AbstractTextResourceEditor;
    }(textEditor_1.BaseTextEditor));
    exports.AbstractTextResourceEditor = AbstractTextResourceEditor;
    var TextResourceEditor = /** @class */ (function (_super) {
        __extends(TextResourceEditor, _super);
        function TextResourceEditor(telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorService, editorGroupService, windowService) {
            return _super.call(this, TextResourceEditor.ID, telemetryService, instantiationService, storageService, configurationService, themeService, editorGroupService, textFileService, editorService, windowService) || this;
        }
        TextResourceEditor.ID = 'workbench.editors.textResourceEditor';
        TextResourceEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, storage_1.IStorageService),
            __param(3, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(4, themeService_1.IThemeService),
            __param(5, textfiles_1.ITextFileService),
            __param(6, editorService_1.IEditorService),
            __param(7, editorGroupsService_1.IEditorGroupsService),
            __param(8, windows_1.IWindowService)
        ], TextResourceEditor);
        return TextResourceEditor;
    }(AbstractTextResourceEditor));
    exports.TextResourceEditor = TextResourceEditor;
});










define(__m[57/*vs/workbench/parts/files/common/files*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,16/*vs/platform/files/common/files*/,91/*vs/workbench/parts/files/common/explorerModel*/,10/*vs/platform/contextkey/common/contextkey*/,4/*vs/base/common/lifecycle*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,27/*vs/workbench/services/textfile/common/textfiles*/,445/*vs/platform/workbench/common/contextkeys*/,9/*vs/platform/registry/common/platform*/,108/*vs/workbench/common/views*/]), function (require, exports, uri_1, files_1, explorerModel_1, contextkey_1, lifecycle_1, modelService_1, modeService_1, textfiles_1, contextkeys_1, platform_1, views_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Explorer viewlet id.
     */
    exports.VIEWLET_ID = 'workbench.view.explorer';
    /**
     * Explorer viewlet container.
     */
    exports.VIEW_CONTAINER = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).registerViewContainer(exports.VIEWLET_ID);
    /**
     * Context Keys to use with keybindings for the Explorer and Open Editors view
     */
    var explorerViewletVisibleId = 'explorerViewletVisible';
    var filesExplorerFocusId = 'filesExplorerFocus';
    var openEditorsVisibleId = 'openEditorsVisible';
    var openEditorsFocusId = 'openEditorsFocus';
    var explorerViewletFocusId = 'explorerViewletFocus';
    var explorerResourceIsFolderId = 'explorerResourceIsFolder';
    var explorerResourceReadonly = 'explorerResourceReadonly';
    var explorerResourceIsRootId = 'explorerResourceIsRoot';
    exports.ExplorerViewletVisibleContext = new contextkey_1.RawContextKey(explorerViewletVisibleId, true);
    exports.ExplorerFolderContext = new contextkey_1.RawContextKey(explorerResourceIsFolderId, false);
    exports.ExplorerResourceReadonlyContext = new contextkey_1.RawContextKey(explorerResourceReadonly, false);
    exports.ExplorerResourceNotReadonlyContext = exports.ExplorerResourceReadonlyContext.toNegated();
    exports.ExplorerRootContext = new contextkey_1.RawContextKey(explorerResourceIsRootId, false);
    exports.FilesExplorerFocusedContext = new contextkey_1.RawContextKey(filesExplorerFocusId, true);
    exports.OpenEditorsVisibleContext = new contextkey_1.RawContextKey(openEditorsVisibleId, false);
    exports.OpenEditorsFocusedContext = new contextkey_1.RawContextKey(openEditorsFocusId, true);
    exports.ExplorerFocusedContext = new contextkey_1.RawContextKey(explorerViewletFocusId, true);
    exports.OpenEditorsVisibleCondition = contextkey_1.ContextKeyExpr.has(openEditorsVisibleId);
    exports.FilesExplorerFocusCondition = contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.has(explorerViewletVisibleId), contextkey_1.ContextKeyExpr.has(filesExplorerFocusId), contextkey_1.ContextKeyExpr.not(contextkeys_1.InputFocusedContextKey));
    exports.ExplorerFocusCondition = contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.has(explorerViewletVisibleId), contextkey_1.ContextKeyExpr.has(explorerViewletFocusId), contextkey_1.ContextKeyExpr.not(contextkeys_1.InputFocusedContextKey));
    /**
     * Preferences editor id.
     */
    exports.PREFERENCES_EDITOR_ID = 'workbench.editor.preferencesEditor';
    /**
     * Text file editor id.
     */
    exports.TEXT_FILE_EDITOR_ID = 'workbench.editors.files.textFileEditor';
    /**
     * File editor input id.
     */
    exports.FILE_EDITOR_INPUT_ID = 'workbench.editors.files.fileEditorInput';
    /**
     * Binary file editor id.
     */
    exports.BINARY_FILE_EDITOR_ID = 'workbench.editors.files.binaryFileEditor';
    /**
     * Helper to get an explorer item from an object.
     */
    function explorerItemToFileResource(obj) {
        if (obj instanceof explorerModel_1.ExplorerItem) {
            var stat = obj;
            return {
                resource: stat.resource,
                isDirectory: stat.isDirectory
            };
        }
        if (obj instanceof explorerModel_1.OpenEditor) {
            var editor = obj;
            var resource = editor.getResource();
            if (resource) {
                return {
                    resource: resource
                };
            }
        }
        return null;
    }
    exports.explorerItemToFileResource = explorerItemToFileResource;
    exports.SortOrderConfiguration = {
        DEFAULT: 'default',
        MIXED: 'mixed',
        FILES_FIRST: 'filesFirst',
        TYPE: 'type',
        MODIFIED: 'modified'
    };
    var FileOnDiskContentProvider = /** @class */ (function () {
        function FileOnDiskContentProvider(textFileService, fileService, modeService, modelService) {
            this.textFileService = textFileService;
            this.fileService = fileService;
            this.modeService = modeService;
            this.modelService = modelService;
        }
        FileOnDiskContentProvider.prototype.provideTextContent = function (resource) {
            var _this = this;
            var fileOnDiskResource = uri_1.URI.file(resource.fsPath);
            // Make sure our file from disk is resolved up to date
            return this.resolveEditorModel(resource).then(function (codeEditorModel) {
                // Make sure to keep contents on disk up to date when it changes
                if (!_this.fileWatcher) {
                    _this.fileWatcher = _this.fileService.onFileChanges(function (changes) {
                        if (changes.contains(fileOnDiskResource, 0 /* UPDATED */)) {
                            _this.resolveEditorModel(resource, false /* do not create if missing */); // update model when resource changes
                        }
                    });
                    var disposeListener_1 = codeEditorModel.onWillDispose(function () {
                        disposeListener_1.dispose();
                        _this.fileWatcher = lifecycle_1.dispose(_this.fileWatcher);
                    });
                }
                return codeEditorModel;
            });
        };
        FileOnDiskContentProvider.prototype.resolveEditorModel = function (resource, createAsNeeded) {
            var _this = this;
            if (createAsNeeded === void 0) { createAsNeeded = true; }
            var fileOnDiskResource = uri_1.URI.file(resource.fsPath);
            return this.textFileService.resolveTextContent(fileOnDiskResource).then(function (content) {
                var codeEditorModel = _this.modelService.getModel(resource);
                if (codeEditorModel) {
                    _this.modelService.updateModel(codeEditorModel, content.value);
                }
                else if (createAsNeeded) {
                    var fileOnDiskModel = _this.modelService.getModel(fileOnDiskResource);
                    var mode = void 0;
                    if (fileOnDiskModel) {
                        mode = _this.modeService.getOrCreateMode(fileOnDiskModel.getModeId());
                    }
                    else {
                        mode = _this.modeService.getOrCreateModeByFilepathOrFirstLine(fileOnDiskResource.fsPath);
                    }
                    codeEditorModel = _this.modelService.createModel(content.value, mode, resource);
                }
                return codeEditorModel;
            });
        };
        FileOnDiskContentProvider.prototype.dispose = function () {
            this.fileWatcher = lifecycle_1.dispose(this.fileWatcher);
        };
        FileOnDiskContentProvider = __decorate([
            __param(0, textfiles_1.ITextFileService),
            __param(1, files_1.IFileService),
            __param(2, modeService_1.IModeService),
            __param(3, modelService_1.IModelService)
        ], FileOnDiskContentProvider);
        return FileOnDiskContentProvider;
    }());
    exports.FileOnDiskContentProvider = FileOnDiskContentProvider;
});























define(__m[125/*vs/workbench/parts/files/common/editors/fileEditorInput*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,146/*vs/base/common/decorators*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,13/*vs/workbench/common/editor*/,127/*vs/workbench/common/editor/binaryEditorModel*/,27/*vs/workbench/services/textfile/common/textfiles*/,3/*vs/platform/instantiation/common/instantiation*/,189/*vs/platform/telemetry/common/telemetryUtils*/,66/*vs/editor/common/services/resolverService*/,94/*vs/workbench/services/hash/common/hashService*/,57/*vs/workbench/parts/files/common/files*/,59/*vs/platform/label/common/label*/]), function (require, exports, nls_1, decorators_1, paths, resources, editor_1, binaryEditorModel_1, textfiles_1, instantiation_1, telemetryUtils_1, resolverService_1, hashService_1, files_1, label_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A file editor input is the input type for the file editor of file system resources.
     */
    var FileEditorInput = /** @class */ (function (_super) {
        __extends(FileEditorInput, _super);
        /**
         * An editor input who's contents are retrieved from file services.
         */
        function FileEditorInput(resource, preferredEncoding, instantiationService, textFileService, textModelResolverService, hashService, labelService) {
            var _this = _super.call(this) || this;
            _this.resource = resource;
            _this.instantiationService = instantiationService;
            _this.textFileService = textFileService;
            _this.textModelResolverService = textModelResolverService;
            _this.hashService = hashService;
            _this.labelService = labelService;
            _this.setPreferredEncoding(preferredEncoding);
            _this.registerListeners();
            return _this;
        }
        FileEditorInput.prototype.registerListeners = function () {
            var _this = this;
            // Model changes
            this._register(this.textFileService.models.onModelDirty(function (e) { return _this.onDirtyStateChange(e); }));
            this._register(this.textFileService.models.onModelSaveError(function (e) { return _this.onDirtyStateChange(e); }));
            this._register(this.textFileService.models.onModelSaved(function (e) { return _this.onDirtyStateChange(e); }));
            this._register(this.textFileService.models.onModelReverted(function (e) { return _this.onDirtyStateChange(e); }));
            this._register(this.textFileService.models.onModelOrphanedChanged(function (e) { return _this.onModelOrphanedChanged(e); }));
        };
        FileEditorInput.prototype.onDirtyStateChange = function (e) {
            if (e.resource.toString() === this.resource.toString()) {
                this._onDidChangeDirty.fire();
            }
        };
        FileEditorInput.prototype.onModelOrphanedChanged = function (e) {
            if (e.resource.toString() === this.resource.toString()) {
                this._onDidChangeLabel.fire();
            }
        };
        FileEditorInput.prototype.getResource = function () {
            return this.resource;
        };
        FileEditorInput.prototype.getEncoding = function () {
            var textModel = this.textFileService.models.get(this.resource);
            if (textModel) {
                return textModel.getEncoding();
            }
            return this.preferredEncoding;
        };
        FileEditorInput.prototype.getPreferredEncoding = function () {
            return this.preferredEncoding;
        };
        FileEditorInput.prototype.setEncoding = function (encoding, mode) {
            this.preferredEncoding = encoding;
            var textModel = this.textFileService.models.get(this.resource);
            if (textModel) {
                textModel.setEncoding(encoding, mode);
            }
        };
        FileEditorInput.prototype.setPreferredEncoding = function (encoding) {
            this.preferredEncoding = encoding;
            if (encoding) {
                this.forceOpenAsText = true; // encoding is a good hint to open the file as text
            }
        };
        FileEditorInput.prototype.setForceOpenAsText = function () {
            this.forceOpenAsText = true;
            this.forceOpenAsBinary = false;
        };
        FileEditorInput.prototype.setForceOpenAsBinary = function () {
            this.forceOpenAsBinary = true;
            this.forceOpenAsText = false;
        };
        FileEditorInput.prototype.getTypeId = function () {
            return files_1.FILE_EDITOR_INPUT_ID;
        };
        FileEditorInput.prototype.getName = function () {
            if (!this.name) {
                this.name = resources.basenameOrAuthority(this.resource);
            }
            return this.decorateLabel(this.name);
        };
        Object.defineProperty(FileEditorInput.prototype, "shortDescription", {
            get: function () {
                return paths.basename(this.labelService.getUriLabel(resources.dirname(this.resource)));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileEditorInput.prototype, "mediumDescription", {
            get: function () {
                return this.labelService.getUriLabel(resources.dirname(this.resource), { relative: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileEditorInput.prototype, "longDescription", {
            get: function () {
                return this.labelService.getUriLabel(resources.dirname(this.resource), { relative: true });
            },
            enumerable: true,
            configurable: true
        });
        FileEditorInput.prototype.getDescription = function (verbosity) {
            if (verbosity === void 0) { verbosity = 1 /* MEDIUM */; }
            var description;
            switch (verbosity) {
                case 0 /* SHORT */:
                    description = this.shortDescription;
                    break;
                case 2 /* LONG */:
                    description = this.longDescription;
                    break;
                case 1 /* MEDIUM */:
                default:
                    description = this.mediumDescription;
                    break;
            }
            return description;
        };
        Object.defineProperty(FileEditorInput.prototype, "shortTitle", {
            get: function () {
                return this.getName();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileEditorInput.prototype, "mediumTitle", {
            get: function () {
                return this.labelService.getUriLabel(this.resource, { relative: true });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileEditorInput.prototype, "longTitle", {
            get: function () {
                return this.labelService.getUriLabel(this.resource);
            },
            enumerable: true,
            configurable: true
        });
        FileEditorInput.prototype.getTitle = function (verbosity) {
            var title;
            switch (verbosity) {
                case 0 /* SHORT */:
                    title = this.shortTitle;
                    break;
                case 1 /* MEDIUM */:
                    title = this.mediumTitle;
                    break;
                case 2 /* LONG */:
                    title = this.longTitle;
                    break;
            }
            return this.decorateLabel(title);
        };
        FileEditorInput.prototype.decorateLabel = function (label) {
            var model = this.textFileService.models.get(this.resource);
            if (model && model.hasState(4 /* ORPHAN */)) {
                return nls_1.localize('orphanedFile', "{0} (deleted from disk)", label);
            }
            if (model && model.isReadonly()) {
                return nls_1.localize('readonlyFile', "{0} (read-only)", label);
            }
            return label;
        };
        FileEditorInput.prototype.isDirty = function () {
            var model = this.textFileService.models.get(this.resource);
            if (!model) {
                return false;
            }
            if (model.hasState(3 /* CONFLICT */) || model.hasState(5 /* ERROR */)) {
                return true; // always indicate dirty state if we are in conflict or error state
            }
            if (this.textFileService.getAutoSaveMode() === 1 /* AFTER_SHORT_DELAY */) {
                return false; // fast auto save enabled so we do not declare dirty
            }
            return model.isDirty();
        };
        FileEditorInput.prototype.confirmSave = function () {
            return this.textFileService.confirmSave([this.resource]);
        };
        FileEditorInput.prototype.save = function () {
            return this.textFileService.save(this.resource);
        };
        FileEditorInput.prototype.revert = function (options) {
            return this.textFileService.revert(this.resource, options);
        };
        FileEditorInput.prototype.getPreferredEditorId = function (candidates) {
            return this.forceOpenAsBinary ? files_1.BINARY_FILE_EDITOR_ID : files_1.TEXT_FILE_EDITOR_ID;
        };
        FileEditorInput.prototype.resolve = function () {
            // Resolve as binary
            if (this.forceOpenAsBinary) {
                return this.doResolveAsBinary();
            }
            // Resolve as text
            return this.doResolveAsText();
        };
        FileEditorInput.prototype.doResolveAsText = function () {
            var _this = this;
            // Resolve as text
            return this.textFileService.models.loadOrCreate(this.resource, {
                encoding: this.preferredEncoding,
                reload: { async: true },
                allowBinary: this.forceOpenAsText,
                reason: 1 /* EDITOR */
            }).then(function (model) {
                // This is a bit ugly, because we first resolve the model and then resolve a model reference. the reason being that binary
                // or very large files do not resolve to a text file model but should be opened as binary files without text. First calling into
                // loadOrCreate ensures we are not creating model references for these kind of resources.
                // In addition we have a bit of payload to take into account (encoding, reload) that the text resolver does not handle yet.
                if (!_this.textModelReference) {
                    _this.textModelReference = _this.textModelResolverService.createModelReference(_this.resource);
                }
                return _this.textModelReference.then(function (ref) { return ref.object; });
            }, function (error) {
                // In case of an error that indicates that the file is binary or too large, just return with the binary editor model
                if (error.fileOperationResult === 0 /* FILE_IS_BINARY */ || error.fileOperationResult === 8 /* FILE_TOO_LARGE */) {
                    return _this.doResolveAsBinary();
                }
                // Bubble any other error up
                return Promise.reject(error);
            });
        };
        FileEditorInput.prototype.doResolveAsBinary = function () {
            return this.instantiationService.createInstance(binaryEditorModel_1.BinaryEditorModel, this.resource, this.getName()).load().then(function (m) { return m; });
        };
        FileEditorInput.prototype.isResolved = function () {
            return !!this.textFileService.models.get(this.resource);
        };
        FileEditorInput.prototype.getTelemetryDescriptor = function () {
            var _this = this;
            var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
            descriptor['resource'] = telemetryUtils_1.telemetryURIDescriptor(this.getResource(), function (path) { return _this.hashService.createSHA1(path); });
            /* __GDPR__FRAGMENT__
                "EditorTelemetryDescriptor" : {
                    "resource": { "${inline}": [ "${URIDescriptor}" ] }
                }
            */
            return descriptor;
        };
        FileEditorInput.prototype.dispose = function () {
            // Model reference
            if (this.textModelReference) {
                this.textModelReference.then(function (ref) { return ref.dispose(); });
                this.textModelReference = null;
            }
            _super.prototype.dispose.call(this);
        };
        FileEditorInput.prototype.matches = function (otherInput) {
            if (_super.prototype.matches.call(this, otherInput) === true) {
                return true;
            }
            if (otherInput) {
                return otherInput instanceof FileEditorInput && otherInput.resource.toString() === this.resource.toString();
            }
            return false;
        };
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "shortDescription", null);
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "mediumDescription", null);
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "longDescription", null);
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "shortTitle", null);
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "mediumTitle", null);
        __decorate([
            decorators_1.memoize
        ], FileEditorInput.prototype, "longTitle", null);
        FileEditorInput = __decorate([
            __param(2, instantiation_1.IInstantiationService),
            __param(3, textfiles_1.ITextFileService),
            __param(4, resolverService_1.ITextModelService),
            __param(5, hashService_1.IHashService),
            __param(6, label_1.ILabelService)
        ], FileEditorInput);
        return FileEditorInput;
    }(editor_1.EditorInput));
    exports.FileEditorInput = FileEditorInput;
});























define(__m[376/*vs/workbench/parts/files/browser/editors/binaryFileEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,157/*vs/workbench/browser/parts/editor/binaryEditor*/,32/*vs/platform/telemetry/common/telemetry*/,14/*vs/platform/theme/common/themeService*/,42/*vs/platform/windows/common/windows*/,125/*vs/workbench/parts/files/common/editors/fileEditorInput*/,57/*vs/workbench/parts/files/common/files*/,16/*vs/platform/files/common/files*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, nls, binaryEditor_1, telemetry_1, themeService_1, windows_1, fileEditorInput_1, files_1, files_2, editorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An implementation of editor for binary files like images.
     */
    var BinaryFileEditor = /** @class */ (function (_super) {
        __extends(BinaryFileEditor, _super);
        function BinaryFileEditor(telemetryService, themeService, fileService, windowsService, editorService) {
            var _this = _super.call(this, BinaryFileEditor.ID, {
                openInternal: function (input, options) { return _this.openInternal(input, options); },
                openExternal: function (resource) { return _this.openExternal(resource); }
            }, telemetryService, themeService, fileService) || this;
            _this.windowsService = windowsService;
            _this.editorService = editorService;
            return _this;
        }
        BinaryFileEditor.prototype.openInternal = function (input, options) {
            if (input instanceof fileEditorInput_1.FileEditorInput) {
                input.setForceOpenAsText();
                this.editorService.openEditor(input, options, this.group);
            }
        };
        BinaryFileEditor.prototype.openExternal = function (resource) {
            var _this = this;
            this.windowsService.openExternal(resource.toString()).then(function (didOpen) {
                if (!didOpen) {
                    return _this.windowsService.showItemInFolder(resource.fsPath);
                }
                return void 0;
            });
        };
        BinaryFileEditor.prototype.getTitle = function () {
            return this.input ? this.input.getName() : nls.localize('binaryFileEditor', "Binary File Viewer");
        };
        BinaryFileEditor.ID = files_1.BINARY_FILE_EDITOR_ID;
        BinaryFileEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, themeService_1.IThemeService),
            __param(2, files_2.IFileService),
            __param(3, windows_1.IWindowsService),
            __param(4, editorService_1.IEditorService)
        ], BinaryFileEditor);
        return BinaryFileEditor;
    }(binaryEditor_1.BaseBinaryResourceEditor));
    exports.BinaryFileEditor = BinaryFileEditor;
});























define(__m[377/*vs/workbench/parts/files/browser/editors/fileEditorTracker*/], __M([0/*require*/,1/*exports*/,35/*vs/base/common/resources*/,13/*vs/workbench/common/editor*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,125/*vs/workbench/parts/files/common/editors/fileEditorInput*/,63/*vs/platform/lifecycle/common/lifecycle*/,4/*vs/base/common/lifecycle*/,19/*vs/base/common/arrays*/,43/*vs/platform/environment/common/environment*/,7/*vs/platform/configuration/common/configuration*/,18/*vs/base/common/platform*/,39/*vs/base/common/map*/,20/*vs/platform/workspace/common/workspace*/,45/*vs/editor/browser/editorBrowser*/,158/*vs/workbench/browser/parts/editor/sideBySideEditor*/,42/*vs/platform/windows/common/windows*/,57/*vs/workbench/parts/files/common/files*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,17/*vs/base/common/async*/,25/*vs/base/common/errors*/]), function (require, exports, resources, editor_1, textfiles_1, files_1, fileEditorInput_1, lifecycle_1, lifecycle_2, arrays_1, environment_1, configuration_1, platform_1, map_1, workspace_1, editorBrowser_1, sideBySideEditor_1, windows_1, files_2, editorService_1, editorGroupsService_1, async_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileEditorTracker = /** @class */ (function (_super) {
        __extends(FileEditorTracker, _super);
        function FileEditorTracker(editorService, textFileService, lifecycleService, editorGroupService, fileService, environmentService, configurationService, contextService, windowService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.textFileService = textFileService;
            _this.lifecycleService = lifecycleService;
            _this.editorGroupService = editorGroupService;
            _this.fileService = fileService;
            _this.environmentService = environmentService;
            _this.configurationService = configurationService;
            _this.contextService = contextService;
            _this.windowService = windowService;
            _this.modelLoadQueue = new async_1.ResourceQueue();
            _this.activeOutOfWorkspaceWatchers = new map_1.ResourceMap();
            _this.onConfigurationUpdated(configurationService.getValue());
            _this.registerListeners();
            return _this;
        }
        FileEditorTracker.prototype.registerListeners = function () {
            var _this = this;
            // Update editors from operation changes
            this._register(this.fileService.onAfterOperation(function (e) { return _this.onFileOperation(e); }));
            // Update editors from disk changes
            this._register(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));
            // Editor changing
            this._register(this.editorService.onDidVisibleEditorsChange(function () { return _this.handleOutOfWorkspaceWatchers(); }));
            // Update visible editors when focus is gained
            this._register(this.windowService.onDidChangeFocus(function (e) { return _this.onWindowFocusChange(e); }));
            // Lifecycle
            this.lifecycleService.onShutdown(this.dispose, this);
            // Configuration
            this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(_this.configurationService.getValue()); }));
        };
        FileEditorTracker.prototype.onConfigurationUpdated = function (configuration) {
            if (configuration.workbench && configuration.workbench.editor && typeof configuration.workbench.editor.closeOnFileDelete === 'boolean') {
                this.closeOnFileDelete = configuration.workbench.editor.closeOnFileDelete;
            }
            else {
                this.closeOnFileDelete = false; // default
            }
        };
        FileEditorTracker.prototype.onWindowFocusChange = function (focused) {
            var _this = this;
            if (focused) {
                // the window got focus and we use this as a hint that files might have been changed outside
                // of this window. since file events can be unreliable, we queue a load for models that
                // are visible in any editor. since this is a fast operation in the case nothing has changed,
                // we tolerate the additional work.
                arrays_1.distinct(this.editorService.visibleEditors
                    .map(function (editorInput) {
                    var resource = editor_1.toResource(editorInput, { supportSideBySide: true });
                    return resource ? _this.textFileService.models.get(resource) : void 0;
                })
                    .filter(function (model) { return model && !model.isDirty(); }), function (m) { return m.getResource().toString(); }).forEach(function (model) { return _this.queueModelLoad(model); });
            }
        };
        // Note: there is some duplication with the other file event handler below. Since we cannot always rely on the disk events
        // carrying all necessary data in all environments, we also use the file operation events to make sure operations are handled.
        // In any case there is no guarantee if the local event is fired first or the disk one. Thus, code must handle the case
        // that the event ordering is random as well as might not carry all information needed.
        FileEditorTracker.prototype.onFileOperation = function (e) {
            // Handle moves specially when file is opened
            if (e.operation === 2 /* MOVE */) {
                this.handleMovedFileInOpenedEditors(e.resource, e.target.resource);
            }
            // Handle deletes
            if (e.operation === 1 /* DELETE */ || e.operation === 2 /* MOVE */) {
                this.handleDeletes(e.resource, false, e.target ? e.target.resource : void 0);
            }
        };
        FileEditorTracker.prototype.onFileChanges = function (e) {
            // Handle updates
            if (e.gotAdded() || e.gotUpdated()) {
                this.handleUpdates(e);
            }
            // Handle deletes
            if (e.gotDeleted()) {
                this.handleDeletes(e, true);
            }
        };
        FileEditorTracker.prototype.handleDeletes = function (arg1, isExternal, movedTo) {
            var _this = this;
            var nonDirtyFileEditors = this.getOpenedFileEditors(false /* non-dirty only */);
            nonDirtyFileEditors.forEach(function (editor) {
                var resource = editor.getResource();
                // Handle deletes in opened editors depending on:
                // - the user has not disabled the setting closeOnFileDelete
                // - the file change is local or external
                // - the input is not resolved (we need to dispose because we cannot restore otherwise since we do not have the contents)
                if (_this.closeOnFileDelete || !isExternal || !editor.isResolved()) {
                    // Do NOT close any opened editor that matches the resource path (either equal or being parent) of the
                    // resource we move to (movedTo). Otherwise we would close a resource that has been renamed to the same
                    // path but different casing.
                    if (movedTo && resources.isEqualOrParent(resource, movedTo)) {
                        return;
                    }
                    var matches = false;
                    if (arg1 instanceof files_1.FileChangesEvent) {
                        matches = arg1.contains(resource, 2 /* DELETED */);
                    }
                    else {
                        matches = resources.isEqualOrParent(resource, arg1);
                    }
                    if (!matches) {
                        return;
                    }
                    // We have received reports of users seeing delete events even though the file still
                    // exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).
                    // Since we do not want to close an editor without reason, we have to check if the
                    // file is really gone and not just a faulty file event.
                    // This only applies to external file events, so we need to check for the isExternal
                    // flag.
                    var checkExists = void 0;
                    if (isExternal) {
                        checkExists = async_1.timeout(100).then(function () { return _this.fileService.existsFile(resource); });
                    }
                    else {
                        checkExists = Promise.resolve(false);
                    }
                    checkExists.then(function (exists) {
                        if (!exists && !editor.isDisposed()) {
                            editor.dispose();
                        }
                        else if (_this.environmentService.verbose) {
                            console.warn("File exists even though we received a delete event: " + resource.toString());
                        }
                    });
                }
            });
        };
        FileEditorTracker.prototype.getOpenedFileEditors = function (dirtyState) {
            var editors = [];
            this.editorService.editors.forEach(function (editor) {
                if (editor instanceof fileEditorInput_1.FileEditorInput) {
                    if (!!editor.isDirty() === dirtyState) {
                        editors.push(editor);
                    }
                }
                else if (editor instanceof editor_1.SideBySideEditorInput) {
                    var master = editor.master;
                    var details = editor.details;
                    if (master instanceof fileEditorInput_1.FileEditorInput) {
                        if (!!master.isDirty() === dirtyState) {
                            editors.push(master);
                        }
                    }
                    if (details instanceof fileEditorInput_1.FileEditorInput) {
                        if (!!details.isDirty() === dirtyState) {
                            editors.push(details);
                        }
                    }
                }
            });
            return editors;
        };
        FileEditorTracker.prototype.handleMovedFileInOpenedEditors = function (oldResource, newResource) {
            var _this = this;
            this.editorGroupService.groups.forEach(function (group) {
                group.editors.forEach(function (editor) {
                    if (editor instanceof fileEditorInput_1.FileEditorInput) {
                        var resource = editor.getResource();
                        // Update Editor if file (or any parent of the input) got renamed or moved
                        if (resources.isEqualOrParent(resource, oldResource)) {
                            var reopenFileResource = void 0;
                            if (oldResource.toString() === resource.toString()) {
                                reopenFileResource = newResource; // file got moved
                            }
                            else {
                                var index = _this.getIndexOfPath(resource.path, oldResource.path);
                                reopenFileResource = resources.joinPath(newResource, resource.path.substr(index + oldResource.path.length + 1)); // parent folder got moved
                            }
                            _this.editorService.replaceEditors([{
                                    editor: { resource: resource },
                                    replacement: {
                                        resource: reopenFileResource,
                                        options: {
                                            preserveFocus: true,
                                            pinned: group.isPinned(editor),
                                            index: group.getIndexOfEditor(editor),
                                            inactive: !group.isActive(editor),
                                            viewState: _this.getViewStateFor(oldResource, group)
                                        }
                                    },
                                }], group);
                        }
                    }
                });
            });
        };
        FileEditorTracker.prototype.getIndexOfPath = function (path, candidate) {
            if (candidate.length > path.length) {
                return -1;
            }
            if (path === candidate) {
                return 0;
            }
            if (!platform_1.isLinux /* ignore case */) {
                path = path.toLowerCase();
                candidate = candidate.toLowerCase();
            }
            return path.indexOf(candidate);
        };
        FileEditorTracker.prototype.getViewStateFor = function (resource, group) {
            var editors = this.editorService.visibleControls;
            for (var i = 0; i < editors.length; i++) {
                var editor = editors[i];
                if (editor && editor.input && editor.group === group) {
                    var editorResource = editor.input.getResource();
                    if (editorResource && resource.toString() === editorResource.toString()) {
                        var control = editor.getControl();
                        if (editorBrowser_1.isCodeEditor(control)) {
                            return control.saveViewState();
                        }
                    }
                }
            }
            return void 0;
        };
        FileEditorTracker.prototype.handleUpdates = function (e) {
            // Handle updates to text models
            this.handleUpdatesToTextModels(e);
            // Handle updates to visible binary editors
            this.handleUpdatesToVisibleBinaryEditors(e);
        };
        FileEditorTracker.prototype.handleUpdatesToTextModels = function (e) {
            var _this = this;
            // Collect distinct (saved) models to update.
            //
            // Note: we also consider the added event because it could be that a file was added
            // and updated right after.
            arrays_1.distinct(e.getUpdated().concat(e.getAdded()).map(function (u) { return _this.textFileService.models.get(u.resource); })
                .filter(function (model) { return model && !model.isDirty(); }), function (m) { return m.getResource().toString(); })
                .forEach(function (model) { return _this.queueModelLoad(model); });
        };
        FileEditorTracker.prototype.queueModelLoad = function (model) {
            // Load model to update (use a queue to prevent accumulation of loads
            // when the load actually takes long. At most we only want the queue
            // to have a size of 2 (1 running load and 1 queued load).
            var queue = this.modelLoadQueue.queueFor(model.getResource());
            if (queue.size <= 1) {
                queue.queue(function () { return model.load().then(null, errors_1.onUnexpectedError); });
            }
        };
        FileEditorTracker.prototype.handleUpdatesToVisibleBinaryEditors = function (e) {
            var _this = this;
            var editors = this.editorService.visibleControls;
            editors.forEach(function (editor) {
                var resource = editor_1.toResource(editor.input, { supportSideBySide: true });
                // Support side-by-side binary editors too
                var isBinaryEditor = false;
                if (editor instanceof sideBySideEditor_1.SideBySideEditor) {
                    isBinaryEditor = editor.getMasterEditor().getId() === files_2.BINARY_FILE_EDITOR_ID;
                }
                else {
                    isBinaryEditor = editor.getId() === files_2.BINARY_FILE_EDITOR_ID;
                }
                // Binary editor that should reload from event
                if (resource && isBinaryEditor && (e.contains(resource, 0 /* UPDATED */) || e.contains(resource, 1 /* ADDED */))) {
                    _this.editorService.openEditor(editor.input, { forceReload: true, preserveFocus: true }, editor.group);
                }
            });
        };
        FileEditorTracker.prototype.handleOutOfWorkspaceWatchers = function () {
            var _this = this;
            var visibleOutOfWorkspacePaths = new map_1.ResourceMap();
            this.editorService.visibleEditors.map(function (editorInput) {
                return editor_1.toResource(editorInput, { supportSideBySide: true });
            }).filter(function (resource) {
                return !!resource && _this.fileService.canHandleResource(resource) && !_this.contextService.isInsideWorkspace(resource);
            }).forEach(function (resource) {
                visibleOutOfWorkspacePaths.set(resource, resource);
            });
            // Handle no longer visible out of workspace resources
            this.activeOutOfWorkspaceWatchers.forEach(function (resource) {
                if (!visibleOutOfWorkspacePaths.get(resource)) {
                    _this.fileService.unwatchFileChanges(resource);
                    _this.activeOutOfWorkspaceWatchers.delete(resource);
                }
            });
            // Handle newly visible out of workspace resources
            visibleOutOfWorkspacePaths.forEach(function (resource) {
                if (!_this.activeOutOfWorkspaceWatchers.get(resource)) {
                    _this.fileService.watchFileChanges(resource);
                    _this.activeOutOfWorkspaceWatchers.set(resource, resource);
                }
            });
        };
        FileEditorTracker.prototype.dispose = function () {
            var _this = this;
            _super.prototype.dispose.call(this);
            // Dispose watchers if any
            this.activeOutOfWorkspaceWatchers.forEach(function (resource) { return _this.fileService.unwatchFileChanges(resource); });
            this.activeOutOfWorkspaceWatchers.clear();
        };
        FileEditorTracker = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, textfiles_1.ITextFileService),
            __param(2, lifecycle_1.ILifecycleService),
            __param(3, editorGroupsService_1.IEditorGroupsService),
            __param(4, files_1.IFileService),
            __param(5, environment_1.IEnvironmentService),
            __param(6, configuration_1.IConfigurationService),
            __param(7, workspace_1.IWorkspaceContextService),
            __param(8, windows_1.IWindowService)
        ], FileEditorTracker);
        return FileEditorTracker;
    }(lifecycle_2.Disposable));
    exports.FileEditorTracker = FileEditorTracker;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

























































define(__m[216/*vs/workbench/parts/preferences/browser/preferencesEditor*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,101/*vs/base/browser/ui/splitview/splitview*/,95/*vs/base/browser/ui/widget*/,19/*vs/base/common/arrays*/,17/*vs/base/common/async*/,55/*vs/base/common/cancellation*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,444/*vs/base/common/iterator*/,4/*vs/base/common/lifecycle*/,22/*vs/base/common/strings*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,56/*vs/editor/browser/editorExtensions*/,212/*vs/editor/browser/widget/codeEditorWidget*/,88/*vs/editor/common/services/resourceConfiguration*/,380/*vs/editor/contrib/find/findController*/,443/*vs/editor/contrib/folding/folding*/,442/*vs/editor/contrib/message/messageController*/,441/*vs/editor/contrib/multicursor/multicursor*/,2/*vs/nls*/,10/*vs/platform/contextkey/common/contextkey*/,3/*vs/platform/instantiation/common/instantiation*/,86/*vs/platform/log/common/log*/,99/*vs/platform/progress/common/progress*/,9/*vs/platform/registry/common/platform*/,44/*vs/platform/storage/common/storage*/,32/*vs/platform/telemetry/common/telemetry*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,20/*vs/platform/workspace/common/workspace*/,105/*vs/workbench/browser/editor*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,149/*vs/workbench/browser/parts/editor/textEditor*/,57/*vs/workbench/parts/files/common/files*/,360/*vs/workbench/parts/preferences/browser/preferencesRenderers*/,144/*vs/workbench/parts/preferences/browser/preferencesWidgets*/,109/*vs/workbench/parts/preferences/common/preferences*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,61/*vs/workbench/services/preferences/common/preferences*/,162/*vs/workbench/services/preferences/common/preferencesModels*/,27/*vs/workbench/services/textfile/common/textfiles*/,42/*vs/platform/windows/common/windows*/]), function (require, exports, DOM, splitview_1, widget_1, arrays, async_1, cancellation_1, errors_1, event_1, iterator_1, lifecycle_1, strings, uri_1, winjs_base_1, editorExtensions_1, codeEditorWidget_1, resourceConfiguration_1, findController_1, folding_1, messageController_1, multicursor_1, nls, contextkey_1, instantiation_1, log_1, progress_1, platform_1, storage_1, telemetry_1, colorRegistry_1, styler_1, themeService_1, workspace_1, editor_1, baseEditor_1, textEditor_1, files_1, preferencesRenderers_1, preferencesWidgets_1, preferences_1, editorService_1, editorGroupsService_1, preferences_2, preferencesModels_1, textfiles_1, windows_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PreferencesEditor = /** @class */ (function (_super) {
        __extends(PreferencesEditor, _super);
        function PreferencesEditor(preferencesService, telemetryService, editorService, contextKeyService, instantiationService, themeService, progressService) {
            var _this = _super.call(this, PreferencesEditor.ID, telemetryService, themeService) || this;
            _this.preferencesService = preferencesService;
            _this.editorService = editorService;
            _this.contextKeyService = contextKeyService;
            _this.instantiationService = instantiationService;
            _this.progressService = progressService;
            _this.lastFocusedWidget = null;
            _this.minimumHeight = 260;
            _this._onDidCreateWidget = new event_1.Emitter();
            _this.onDidSizeConstraintsChange = _this._onDidCreateWidget.event;
            _this.defaultSettingsEditorContextKey = preferences_1.CONTEXT_SETTINGS_EDITOR.bindTo(_this.contextKeyService);
            _this.searchFocusContextKey = preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS.bindTo(_this.contextKeyService);
            _this.delayedFilterLogging = new async_1.Delayer(1000);
            _this.localSearchDelayer = new async_1.Delayer(100);
            _this.remoteSearchThrottle = new async_1.ThrottledDelayer(200);
            return _this;
        }
        Object.defineProperty(PreferencesEditor.prototype, "minimumWidth", {
            get: function () { return this.sideBySidePreferencesWidget ? this.sideBySidePreferencesWidget.minimumWidth : 0; },
            // these setters need to exist because this extends from BaseEditor
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesEditor.prototype, "maximumWidth", {
            get: function () { return this.sideBySidePreferencesWidget ? this.sideBySidePreferencesWidget.maximumWidth : Number.POSITIVE_INFINITY; },
            set: function (value) { },
            enumerable: true,
            configurable: true
        });
        PreferencesEditor.prototype.createEditor = function (parent) {
            var _this = this;
            DOM.addClass(parent, 'preferences-editor');
            this.headerContainer = DOM.append(parent, DOM.$('.preferences-header'));
            this.searchWidget = this._register(this.instantiationService.createInstance(preferencesWidgets_1.SearchWidget, this.headerContainer, {
                ariaLabel: nls.localize('SearchSettingsWidget.AriaLabel', "Search settings"),
                placeholder: nls.localize('SearchSettingsWidget.Placeholder', "Search Settings"),
                focusKey: this.searchFocusContextKey,
                showResultCount: true,
                ariaLive: 'assertive'
            }));
            this._register(this.searchWidget.onDidChange(function (value) { return _this.onInputChanged(); }));
            this._register(this.searchWidget.onFocus(function () { return _this.lastFocusedWidget = _this.searchWidget; }));
            this.lastFocusedWidget = this.searchWidget;
            var editorsContainer = DOM.append(parent, DOM.$('.preferences-editors-container'));
            this.sideBySidePreferencesWidget = this._register(this.instantiationService.createInstance(SideBySidePreferencesWidget, editorsContainer));
            this._onDidCreateWidget.fire();
            this._register(this.sideBySidePreferencesWidget.onFocus(function () { return _this.lastFocusedWidget = _this.sideBySidePreferencesWidget; }));
            this._register(this.sideBySidePreferencesWidget.onDidSettingsTargetChange(function (target) { return _this.switchSettings(target); }));
            this.preferencesRenderers = this._register(this.instantiationService.createInstance(PreferencesRenderersController));
            this._register(this.preferencesRenderers.onDidFilterResultsCountChange(function (count) { return _this.showSearchResultsMessage(count); }));
        };
        PreferencesEditor.prototype.clearSearchResults = function () {
            if (this.searchWidget) {
                this.searchWidget.clear();
            }
        };
        PreferencesEditor.prototype.focusNextResult = function () {
            if (this.preferencesRenderers) {
                this.preferencesRenderers.focusNextPreference(true);
            }
        };
        PreferencesEditor.prototype.focusPreviousResult = function () {
            if (this.preferencesRenderers) {
                this.preferencesRenderers.focusNextPreference(false);
            }
        };
        PreferencesEditor.prototype.editFocusedPreference = function () {
            this.preferencesRenderers.editFocusedPreference();
        };
        PreferencesEditor.prototype.setInput = function (newInput, options, token) {
            var _this = this;
            this.defaultSettingsEditorContextKey.set(true);
            if (options && options.query) {
                this.focusSearch(options.query);
            }
            return _super.prototype.setInput.call(this, newInput, options, token).then(function () { return _this.updateInput(newInput, options, token); });
        };
        PreferencesEditor.prototype.layout = function (dimension) {
            this.searchWidget.layout(dimension);
            var headerHeight = DOM.getTotalHeight(this.headerContainer);
            this.sideBySidePreferencesWidget.layout(new DOM.Dimension(dimension.width, dimension.height - headerHeight));
        };
        PreferencesEditor.prototype.getControl = function () {
            return this.sideBySidePreferencesWidget.getControl();
        };
        PreferencesEditor.prototype.focus = function () {
            if (this.lastFocusedWidget) {
                this.lastFocusedWidget.focus();
            }
        };
        PreferencesEditor.prototype.focusSearch = function (filter) {
            if (filter) {
                this.searchWidget.setValue(filter);
            }
            this.searchWidget.focus();
        };
        PreferencesEditor.prototype.focusSettingsFileEditor = function () {
            if (this.sideBySidePreferencesWidget) {
                this.sideBySidePreferencesWidget.focus();
            }
        };
        PreferencesEditor.prototype.clearInput = function () {
            this.defaultSettingsEditorContextKey.set(false);
            this.sideBySidePreferencesWidget.clearInput();
            this.preferencesRenderers.onHidden();
            _super.prototype.clearInput.call(this);
        };
        PreferencesEditor.prototype.setEditorVisible = function (visible, group) {
            this.sideBySidePreferencesWidget.setEditorVisible(visible, group);
            _super.prototype.setEditorVisible.call(this, visible, group);
        };
        PreferencesEditor.prototype.updateInput = function (newInput, options, token) {
            var _this = this;
            return this.sideBySidePreferencesWidget.setInput(newInput.details, newInput.master, options, token).then(function (_a) {
                var defaultPreferencesRenderer = _a.defaultPreferencesRenderer, editablePreferencesRenderer = _a.editablePreferencesRenderer;
                if (token.isCancellationRequested) {
                    return void 0;
                }
                _this.preferencesRenderers.defaultPreferencesRenderer = defaultPreferencesRenderer;
                _this.preferencesRenderers.editablePreferencesRenderer = editablePreferencesRenderer;
                _this.onInputChanged();
            });
        };
        PreferencesEditor.prototype.onInputChanged = function () {
            var _this = this;
            var query = this.searchWidget.getValue().trim();
            this.delayedFilterLogging.cancel();
            this.triggerSearch(query)
                .then(function () {
                var result = _this.preferencesRenderers.lastFilterResult;
                if (result) {
                    _this.delayedFilterLogging.trigger(function () { return _this.reportFilteringUsed(query, _this.preferencesRenderers.lastFilterResult); });
                }
            });
        };
        PreferencesEditor.prototype.triggerSearch = function (query) {
            var _this = this;
            if (query) {
                return winjs_base_1.TPromise.join([
                    this.localSearchDelayer.trigger(function () { return _this.preferencesRenderers.localFilterPreferences(query).then(function () { }); }),
                    this.remoteSearchThrottle.trigger(function () { return winjs_base_1.TPromise.wrap(_this.progressService.showWhile(_this.preferencesRenderers.remoteSearchPreferences(query), 500)); })
                ]);
            }
            else {
                // When clearing the input, update immediately to clear it
                this.localSearchDelayer.cancel();
                this.preferencesRenderers.localFilterPreferences(query);
                this.remoteSearchThrottle.cancel();
                return this.preferencesRenderers.remoteSearchPreferences(query);
            }
        };
        PreferencesEditor.prototype.switchSettings = function (target) {
            var _this = this;
            // Focus the editor if this editor is not active editor
            if (this.editorService.activeControl !== this) {
                this.focus();
            }
            var promise = this.input && this.input.isDirty() ? this.input.save() : winjs_base_1.TPromise.as(true);
            promise.then(function (value) {
                if (target === 1 /* USER */) {
                    _this.preferencesService.switchSettings(1 /* USER */, _this.preferencesService.userSettingsResource, true);
                }
                else if (target === 2 /* WORKSPACE */) {
                    _this.preferencesService.switchSettings(2 /* WORKSPACE */, _this.preferencesService.workspaceSettingsResource, true);
                }
                else if (target instanceof uri_1.URI) {
                    _this.preferencesService.switchSettings(3 /* WORKSPACE_FOLDER */, target, true);
                }
            });
        };
        PreferencesEditor.prototype.showSearchResultsMessage = function (count) {
            var countValue = count.count;
            if (count.target) {
                this.sideBySidePreferencesWidget.setResultCount(count.target, count.count);
            }
            else if (this.searchWidget.getValue()) {
                if (countValue === 0) {
                    this.searchWidget.showMessage(nls.localize('noSettingsFound', "No Results"), countValue);
                }
                else if (countValue === 1) {
                    this.searchWidget.showMessage(nls.localize('oneSettingFound', "1 Setting Found"), countValue);
                }
                else {
                    this.searchWidget.showMessage(nls.localize('settingsFound', "{0} Settings Found", countValue), countValue);
                }
            }
            else {
                this.searchWidget.showMessage(nls.localize('totalSettingsMessage', "Total {0} Settings", countValue), countValue);
            }
        };
        PreferencesEditor.prototype._countById = function (settingsGroups) {
            var result = {};
            for (var _i = 0, settingsGroups_1 = settingsGroups; _i < settingsGroups_1.length; _i++) {
                var group = settingsGroups_1[_i];
                var i = 0;
                for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                    var section = _b[_a];
                    i += section.settings.length;
                }
                result[group.id] = i;
            }
            return result;
        };
        PreferencesEditor.prototype.reportFilteringUsed = function (filter, filterResult) {
            if (filter && filter !== this._lastReportedFilter) {
                var metadata_1 = filterResult && filterResult.metadata;
                var counts = filterResult && this._countById(filterResult.filteredGroups);
                var durations_1;
                if (metadata_1) {
                    durations_1 = Object.create(null);
                    Object.keys(metadata_1).forEach(function (key) { return durations_1[key] = metadata_1[key].duration; });
                }
                var data = {
                    filter: filter,
                    durations: durations_1,
                    counts: counts,
                    requestCount: metadata_1 && metadata_1['nlpResult'] && metadata_1['nlpResult'].requestCount
                };
                /* __GDPR__
                    "defaultSettings.filter" : {
                        "filter": { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                        "durations.nlpresult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                        "counts.nlpresult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                        "durations.filterresult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                        "counts.filterresult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                        "requestCount" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                    }
                */
                this.telemetryService.publicLog('defaultSettings.filter', data);
                this._lastReportedFilter = filter;
            }
        };
        PreferencesEditor.prototype.dispose = function () {
            this._onDidCreateWidget.dispose();
            _super.prototype.dispose.call(this);
        };
        PreferencesEditor.ID = files_1.PREFERENCES_EDITOR_ID;
        PreferencesEditor = __decorate([
            __param(0, preferences_2.IPreferencesService),
            __param(1, telemetry_1.ITelemetryService),
            __param(2, editorService_1.IEditorService),
            __param(3, contextkey_1.IContextKeyService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, themeService_1.IThemeService),
            __param(6, progress_1.IProgressService)
        ], PreferencesEditor);
        return PreferencesEditor;
    }(baseEditor_1.BaseEditor));
    exports.PreferencesEditor = PreferencesEditor;
    var SettingsNavigator = /** @class */ (function (_super) {
        __extends(SettingsNavigator, _super);
        function SettingsNavigator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SettingsNavigator.prototype.next = function () {
            return _super.prototype.next.call(this) || _super.prototype.first.call(this);
        };
        SettingsNavigator.prototype.previous = function () {
            return _super.prototype.previous.call(this) || _super.prototype.last.call(this);
        };
        SettingsNavigator.prototype.reset = function () {
            this.index = this.start - 1;
        };
        return SettingsNavigator;
    }(iterator_1.ArrayNavigator));
    var PreferencesRenderersController = /** @class */ (function (_super) {
        __extends(PreferencesRenderersController, _super);
        function PreferencesRenderersController(preferencesSearchService, telemetryService, preferencesService, workspaceContextService, logService) {
            var _this = _super.call(this) || this;
            _this.preferencesSearchService = preferencesSearchService;
            _this.telemetryService = telemetryService;
            _this.preferencesService = preferencesService;
            _this.workspaceContextService = workspaceContextService;
            _this.logService = logService;
            _this._defaultPreferencesRendererDisposables = [];
            _this._editablePreferencesRendererDisposables = [];
            _this._prefsModelsForSearch = new Map();
            _this._onDidFilterResultsCountChange = _this._register(new event_1.Emitter());
            _this.onDidFilterResultsCountChange = _this._onDidFilterResultsCountChange.event;
            return _this;
        }
        Object.defineProperty(PreferencesRenderersController.prototype, "lastFilterResult", {
            get: function () {
                return this._lastFilterResult;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesRenderersController.prototype, "defaultPreferencesRenderer", {
            get: function () {
                return this._defaultPreferencesRenderer;
            },
            set: function (defaultPreferencesRenderer) {
                var _this = this;
                if (this._defaultPreferencesRenderer !== defaultPreferencesRenderer) {
                    this._defaultPreferencesRenderer = defaultPreferencesRenderer;
                    this._defaultPreferencesRendererDisposables = lifecycle_1.dispose(this._defaultPreferencesRendererDisposables);
                    if (this._defaultPreferencesRenderer) {
                        this._defaultPreferencesRenderer.onUpdatePreference(function (_a) {
                            var key = _a.key, value = _a.value, source = _a.source;
                            _this._editablePreferencesRenderer.updatePreference(key, value, source);
                            _this._updatePreference(key, value, source);
                        }, this, this._defaultPreferencesRendererDisposables);
                        this._defaultPreferencesRenderer.onFocusPreference(function (preference) { return _this._focusPreference(preference, _this._editablePreferencesRenderer); }, this, this._defaultPreferencesRendererDisposables);
                        this._defaultPreferencesRenderer.onClearFocusPreference(function (preference) { return _this._clearFocus(preference, _this._editablePreferencesRenderer); }, this, this._defaultPreferencesRendererDisposables);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreferencesRenderersController.prototype, "editablePreferencesRenderer", {
            get: function () {
                return this._editablePreferencesRenderer;
            },
            set: function (editableSettingsRenderer) {
                var _this = this;
                if (this._editablePreferencesRenderer !== editableSettingsRenderer) {
                    this._editablePreferencesRenderer = editableSettingsRenderer;
                    this._editablePreferencesRendererDisposables = lifecycle_1.dispose(this._editablePreferencesRendererDisposables);
                    if (this._editablePreferencesRenderer) {
                        this._editablePreferencesRenderer.preferencesModel
                            .onDidChangeGroups(this._onEditableContentDidChange, this, this._editablePreferencesRendererDisposables);
                        this._editablePreferencesRenderer.onUpdatePreference(function (_a) {
                            var key = _a.key, value = _a.value, source = _a.source;
                            return _this._updatePreference(key, value, source, true);
                        }, this, this._defaultPreferencesRendererDisposables);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        PreferencesRenderersController.prototype._onEditableContentDidChange = function () {
            return __awaiter(this, void 0, void 0, function () {
                var foundExactMatch;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.localFilterPreferences(this._lastQuery, true)];
                        case 1:
                            foundExactMatch = _a.sent();
                            if (!!foundExactMatch) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.remoteSearchPreferences(this._lastQuery, true)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        PreferencesRenderersController.prototype.onHidden = function () {
            this._prefsModelsForSearch.forEach(function (model) { return model.dispose(); });
            this._prefsModelsForSearch = new Map();
        };
        PreferencesRenderersController.prototype.remoteSearchPreferences = function (query, updateCurrentResults) {
            var _this = this;
            if (this.lastFilterResult && this.lastFilterResult.exactMatch) {
                // Skip and clear remote search
                query = '';
            }
            if (this._remoteFilterCancelToken) {
                this._remoteFilterCancelToken.cancel();
                this._remoteFilterCancelToken.dispose();
                this._remoteFilterCancelToken = null;
            }
            this._currentRemoteSearchProvider = (updateCurrentResults && this._currentRemoteSearchProvider) || this.preferencesSearchService.getRemoteSearchProvider(query);
            this._remoteFilterCancelToken = new cancellation_1.CancellationTokenSource();
            return this.filterOrSearchPreferences(query, this._currentRemoteSearchProvider, 'nlpResult', nls.localize('nlpResult', "Natural Language Results"), 1, this._remoteFilterCancelToken.token, updateCurrentResults).then(function () {
                if (_this._remoteFilterCancelToken) {
                    _this._remoteFilterCancelToken.dispose();
                    _this._remoteFilterCancelToken = null;
                }
            }, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return null;
                }
                else {
                    errors_1.onUnexpectedError(err);
                }
            });
        };
        PreferencesRenderersController.prototype.localFilterPreferences = function (query, updateCurrentResults) {
            if (this._settingsNavigator) {
                this._settingsNavigator.reset();
            }
            this._currentLocalSearchProvider = (updateCurrentResults && this._currentLocalSearchProvider) || this.preferencesSearchService.getLocalSearchProvider(query);
            return this.filterOrSearchPreferences(query, this._currentLocalSearchProvider, 'filterResult', nls.localize('filterResult', "Filtered Results"), 0, undefined, updateCurrentResults);
        };
        PreferencesRenderersController.prototype.filterOrSearchPreferences = function (query, searchProvider, groupId, groupLabel, groupOrder, token, editableContentOnly) {
            var _this = this;
            this._lastQuery = query;
            var filterPs = [this._filterOrSearchPreferences(query, this.editablePreferencesRenderer, searchProvider, groupId, groupLabel, groupOrder, token)];
            if (!editableContentOnly) {
                filterPs.push(this._filterOrSearchPreferences(query, this.defaultPreferencesRenderer, searchProvider, groupId, groupLabel, groupOrder, token));
                filterPs.push(this.searchAllSettingsTargets(query, searchProvider, groupId, groupLabel, groupOrder, token).then(function () { return null; }));
            }
            return winjs_base_1.TPromise.join(filterPs).then(function (results) {
                var editableFilterResult = results[0], defaultFilterResult = results[1];
                if (!defaultFilterResult && editableContentOnly) {
                    defaultFilterResult = _this.lastFilterResult;
                }
                _this.consolidateAndUpdate(defaultFilterResult, editableFilterResult);
                _this._lastFilterResult = defaultFilterResult;
                return defaultFilterResult && defaultFilterResult.exactMatch;
            });
        };
        PreferencesRenderersController.prototype.searchAllSettingsTargets = function (query, searchProvider, groupId, groupLabel, groupOrder, token) {
            var searchPs = [
                this.searchSettingsTarget(query, searchProvider, 2 /* WORKSPACE */, groupId, groupLabel, groupOrder, token),
                this.searchSettingsTarget(query, searchProvider, 1 /* USER */, groupId, groupLabel, groupOrder, token)
            ];
            for (var _i = 0, _a = this.workspaceContextService.getWorkspace().folders; _i < _a.length; _i++) {
                var folder = _a[_i];
                var folderSettingsResource = this.preferencesService.getFolderSettingsResource(folder.uri);
                searchPs.push(this.searchSettingsTarget(query, searchProvider, folderSettingsResource, groupId, groupLabel, groupOrder, token));
            }
            return winjs_base_1.TPromise.join(searchPs).then(function () { });
        };
        PreferencesRenderersController.prototype.searchSettingsTarget = function (query, provider, target, groupId, groupLabel, groupOrder, token) {
            var _this = this;
            if (!query) {
                // Don't open the other settings targets when query is empty
                this._onDidFilterResultsCountChange.fire({ target: target, count: 0 });
                return Promise.resolve(null);
            }
            return this.getPreferencesEditorModel(target).then(function (model) {
                return model && _this._filterOrSearchPreferencesModel('', model, provider, groupId, groupLabel, groupOrder, token);
            }).then(function (result) {
                var count = result ? _this._flatten(result.filteredGroups).length : 0;
                _this._onDidFilterResultsCountChange.fire({ target: target, count: count });
            }, function (err) {
                if (!errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                return null;
            });
        };
        PreferencesRenderersController.prototype.getPreferencesEditorModel = function (target) {
            return __awaiter(this, void 0, void 0, function () {
                var resource, targetKey, model, _a, e_1;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            resource = target === 1 /* USER */ ? this.preferencesService.userSettingsResource :
                                target === 2 /* WORKSPACE */ ? this.preferencesService.workspaceSettingsResource :
                                    target;
                            if (!resource) {
                                return [2 /*return*/, null];
                            }
                            targetKey = resource.toString();
                            if (!!this._prefsModelsForSearch.has(targetKey)) return [3 /*break*/, 4];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            _a = this._register;
                            return [4 /*yield*/, this.preferencesService.createPreferencesEditorModel(resource)];
                        case 2:
                            model = _a.apply(this, [_b.sent()]);
                            this._prefsModelsForSearch.set(targetKey, model);
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _b.sent();
                            // Will throw when the settings file doesn't exist.
                            return [2 /*return*/, null];
                        case 4: return [2 /*return*/, this._prefsModelsForSearch.get(targetKey)];
                    }
                });
            });
        };
        PreferencesRenderersController.prototype.focusNextPreference = function (forward) {
            if (forward === void 0) { forward = true; }
            if (!this._settingsNavigator) {
                return;
            }
            var setting = forward ? this._settingsNavigator.next() : this._settingsNavigator.previous();
            this._focusPreference(setting, this._defaultPreferencesRenderer);
            this._focusPreference(setting, this._editablePreferencesRenderer);
        };
        PreferencesRenderersController.prototype.editFocusedPreference = function () {
            if (!this._settingsNavigator || !this._settingsNavigator.current()) {
                return;
            }
            var setting = this._settingsNavigator.current();
            var shownInEditableRenderer = this._editablePreferencesRenderer.editPreference(setting);
            if (!shownInEditableRenderer) {
                this.defaultPreferencesRenderer.editPreference(setting);
            }
        };
        PreferencesRenderersController.prototype._filterOrSearchPreferences = function (filter, preferencesRenderer, provider, groupId, groupLabel, groupOrder, token) {
            if (!preferencesRenderer) {
                return winjs_base_1.TPromise.wrap(null);
            }
            var model = preferencesRenderer.preferencesModel;
            return this._filterOrSearchPreferencesModel(filter, model, provider, groupId, groupLabel, groupOrder, token).then(function (filterResult) {
                preferencesRenderer.filterPreferences(filterResult);
                return filterResult;
            });
        };
        PreferencesRenderersController.prototype._filterOrSearchPreferencesModel = function (filter, model, provider, groupId, groupLabel, groupOrder, token) {
            var _this = this;
            var searchP = provider ? provider.searchModel(model, token) : winjs_base_1.TPromise.wrap(null);
            return searchP
                .then(null, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                else {
                    /* __GDPR__
                        "defaultSettings.searchError" : {
                            "message": { "classification": "CallstackOrException", "purpose": "FeatureInsight" },
                            "filter": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                        }
                    */
                    var message = errors_1.getErrorMessage(err).trim();
                    if (message && message !== 'Error') {
                        // "Error" = any generic network error
                        _this.telemetryService.publicLog('defaultSettings.searchError', { message: message, filter: filter });
                        _this.logService.info('Setting search error: ' + message);
                    }
                    return null;
                }
            })
                .then(function (searchResult) {
                if (token && token.isCancellationRequested) {
                    searchResult = null;
                }
                var filterResult = searchResult ?
                    model.updateResultGroup(groupId, {
                        id: groupId,
                        label: groupLabel,
                        result: searchResult,
                        order: groupOrder
                    }) :
                    model.updateResultGroup(groupId, null);
                if (filterResult) {
                    filterResult.query = filter;
                    filterResult.exactMatch = searchResult && searchResult.exactMatch;
                }
                return filterResult;
            });
        };
        PreferencesRenderersController.prototype.consolidateAndUpdate = function (defaultFilterResult, editableFilterResult) {
            var defaultPreferencesFilteredGroups = defaultFilterResult ? defaultFilterResult.filteredGroups : this._getAllPreferences(this._defaultPreferencesRenderer);
            var editablePreferencesFilteredGroups = editableFilterResult ? editableFilterResult.filteredGroups : this._getAllPreferences(this._editablePreferencesRenderer);
            var consolidatedSettings = this._consolidateSettings(editablePreferencesFilteredGroups, defaultPreferencesFilteredGroups);
            // Maintain the current navigation position when updating SettingsNavigator
            var current = this._settingsNavigator && this._settingsNavigator.current();
            var navigatorSettings = this._lastQuery ? consolidatedSettings : [];
            var currentIndex = current ?
                arrays.firstIndex(navigatorSettings, function (s) { return s.key === current.key; }) :
                -1;
            this._settingsNavigator = new SettingsNavigator(navigatorSettings, Math.max(currentIndex, 0));
            if (currentIndex >= 0) {
                this._settingsNavigator.next();
                var newCurrent = this._settingsNavigator.current();
                this._focusPreference(newCurrent, this._defaultPreferencesRenderer);
                this._focusPreference(newCurrent, this._editablePreferencesRenderer);
            }
            var totalCount = consolidatedSettings.length;
            this._onDidFilterResultsCountChange.fire({ count: totalCount });
        };
        PreferencesRenderersController.prototype._getAllPreferences = function (preferencesRenderer) {
            return preferencesRenderer ? preferencesRenderer.preferencesModel.settingsGroups : [];
        };
        PreferencesRenderersController.prototype._focusPreference = function (preference, preferencesRenderer) {
            if (preference && preferencesRenderer) {
                preferencesRenderer.focusPreference(preference);
            }
        };
        PreferencesRenderersController.prototype._clearFocus = function (preference, preferencesRenderer) {
            if (preference && preferencesRenderer) {
                preferencesRenderer.clearFocus(preference);
            }
        };
        PreferencesRenderersController.prototype._updatePreference = function (key, value, source, fromEditableSettings) {
            var data = {
                userConfigurationKeys: [key]
            };
            if (this.lastFilterResult) {
                data['query'] = this.lastFilterResult.query;
                data['editableSide'] = !!fromEditableSettings;
                var nlpMetadata_1 = this.lastFilterResult.metadata && this.lastFilterResult.metadata['nlpResult'];
                if (nlpMetadata_1) {
                    var sortedKeys = Object.keys(nlpMetadata_1.scoredResults).sort(function (a, b) { return nlpMetadata_1.scoredResults[b].score - nlpMetadata_1.scoredResults[a].score; });
                    var suffix_1 = '##' + key;
                    data['nlpIndex'] = arrays.firstIndex(sortedKeys, function (key) { return strings.endsWith(key, suffix_1); });
                }
                var settingLocation = this._findSetting(this.lastFilterResult, key);
                if (settingLocation) {
                    data['groupId'] = this.lastFilterResult.filteredGroups[settingLocation.groupIdx].id;
                    data['displayIdx'] = settingLocation.overallSettingIdx;
                }
            }
            /* __GDPR__
                "defaultSettingsActions.copySetting" : {
                    "userConfigurationKeys" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "query" : { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                    "nlpIndex" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "groupId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "displayIdx" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "editableSide" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                }
            */
            this.telemetryService.publicLog('defaultSettingsActions.copySetting', data);
        };
        PreferencesRenderersController.prototype._findSetting = function (filterResult, key) {
            var overallSettingIdx = 0;
            for (var groupIdx = 0; groupIdx < filterResult.filteredGroups.length; groupIdx++) {
                var group = filterResult.filteredGroups[groupIdx];
                for (var settingIdx = 0; settingIdx < group.sections[0].settings.length; settingIdx++) {
                    var setting = group.sections[0].settings[settingIdx];
                    if (key === setting.key) {
                        return { groupIdx: groupIdx, settingIdx: settingIdx, overallSettingIdx: overallSettingIdx };
                    }
                    overallSettingIdx++;
                }
            }
            return null;
        };
        PreferencesRenderersController.prototype._consolidateSettings = function (editableSettingsGroups, defaultSettingsGroups) {
            var defaultSettings = this._flatten(defaultSettingsGroups);
            var editableSettings = this._flatten(editableSettingsGroups).filter(function (secondarySetting) { return defaultSettings.every(function (primarySetting) { return primarySetting.key !== secondarySetting.key; }); });
            return defaultSettings.concat(editableSettings);
        };
        PreferencesRenderersController.prototype._flatten = function (settingsGroups) {
            var settings = [];
            for (var _i = 0, settingsGroups_2 = settingsGroups; _i < settingsGroups_2.length; _i++) {
                var group = settingsGroups_2[_i];
                for (var _a = 0, _b = group.sections; _a < _b.length; _a++) {
                    var section = _b[_a];
                    settings.push.apply(settings, section.settings);
                }
            }
            return settings;
        };
        PreferencesRenderersController.prototype.dispose = function () {
            lifecycle_1.dispose(this._defaultPreferencesRendererDisposables);
            lifecycle_1.dispose(this._editablePreferencesRendererDisposables);
            _super.prototype.dispose.call(this);
        };
        PreferencesRenderersController = __decorate([
            __param(0, preferences_1.IPreferencesSearchService),
            __param(1, telemetry_1.ITelemetryService),
            __param(2, preferences_2.IPreferencesService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, log_1.ILogService)
        ], PreferencesRenderersController);
        return PreferencesRenderersController;
    }(lifecycle_1.Disposable));
    var SideBySidePreferencesWidget = /** @class */ (function (_super) {
        __extends(SideBySidePreferencesWidget, _super);
        function SideBySidePreferencesWidget(parentElement, instantiationService, themeService, workspaceContextService, preferencesService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.themeService = themeService;
            _this.workspaceContextService = workspaceContextService;
            _this.preferencesService = preferencesService;
            _this.dimension = new DOM.Dimension(0, 0);
            _this._onFocus = new event_1.Emitter();
            _this.onFocus = _this._onFocus.event;
            _this._onDidSettingsTargetChange = new event_1.Emitter();
            _this.onDidSettingsTargetChange = _this._onDidSettingsTargetChange.event;
            DOM.addClass(parentElement, 'side-by-side-preferences-editor');
            _this.splitview = new splitview_1.SplitView(parentElement, { orientation: 1 /* HORIZONTAL */ });
            _this._register(_this.splitview);
            _this._register(_this.splitview.onDidSashReset(function () { return _this.splitview.distributeViewSizes(); }));
            _this.defaultPreferencesEditorContainer = DOM.$('.default-preferences-editor-container');
            var defaultPreferencesHeaderContainer = DOM.append(_this.defaultPreferencesEditorContainer, DOM.$('.preferences-header-container'));
            _this.defaultPreferencesHeader = DOM.append(defaultPreferencesHeaderContainer, DOM.$('div.default-preferences-header'));
            _this.defaultPreferencesHeader.textContent = nls.localize('defaultSettings', "Default Settings");
            _this.defaultPreferencesEditor = _this._register(_this.instantiationService.createInstance(DefaultPreferencesEditor));
            _this.defaultPreferencesEditor.create(_this.defaultPreferencesEditorContainer);
            _this.defaultPreferencesEditor.getControl().onDidFocusEditorWidget(function () { return _this.lastFocusedEditor = _this.defaultPreferencesEditor; });
            _this.splitview.addView({
                element: _this.defaultPreferencesEditorContainer,
                layout: function (size) { return _this.defaultPreferencesEditor.layout(new DOM.Dimension(size, _this.dimension.height - 34 /* height of header container */)); },
                minimumSize: 220,
                maximumSize: Number.POSITIVE_INFINITY,
                onDidChange: event_1.Event.None
            }, splitview_1.Sizing.Distribute);
            _this.editablePreferencesEditorContainer = DOM.$('.editable-preferences-editor-container');
            var editablePreferencesHeaderContainer = DOM.append(_this.editablePreferencesEditorContainer, DOM.$('.preferences-header-container'));
            _this.settingsTargetsWidget = _this._register(_this.instantiationService.createInstance(preferencesWidgets_1.SettingsTargetsWidget, editablePreferencesHeaderContainer));
            _this._register(_this.settingsTargetsWidget.onDidTargetChange(function (target) { return _this._onDidSettingsTargetChange.fire(target); }));
            _this._register(styler_1.attachStylerCallback(_this.themeService, { scrollbarShadow: colorRegistry_1.scrollbarShadow }, function (colors) {
                var shadow = colors.scrollbarShadow ? colors.scrollbarShadow.toString() : null;
                if (shadow) {
                    _this.editablePreferencesEditorContainer.style.boxShadow = "-6px 0 5px -5px " + shadow;
                }
                else {
                    _this.editablePreferencesEditorContainer.style.boxShadow = null;
                }
            }));
            _this.splitview.addView({
                element: _this.editablePreferencesEditorContainer,
                layout: function (size) { return _this.editablePreferencesEditor && _this.editablePreferencesEditor.layout(new DOM.Dimension(size, _this.dimension.height - 34 /* height of header container */)); },
                minimumSize: 220,
                maximumSize: Number.POSITIVE_INFINITY,
                onDidChange: event_1.Event.None
            }, splitview_1.Sizing.Distribute);
            var focusTracker = _this._register(DOM.trackFocus(parentElement));
            _this._register(focusTracker.onDidFocus(function () { return _this._onFocus.fire(); }));
            return _this;
        }
        Object.defineProperty(SideBySidePreferencesWidget.prototype, "minimumWidth", {
            get: function () { return this.splitview.minimumSize; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SideBySidePreferencesWidget.prototype, "maximumWidth", {
            get: function () { return this.splitview.maximumSize; },
            enumerable: true,
            configurable: true
        });
        SideBySidePreferencesWidget.prototype.setInput = function (defaultPreferencesEditorInput, editablePreferencesEditorInput, options, token) {
            var _this = this;
            this.getOrCreateEditablePreferencesEditor(editablePreferencesEditorInput);
            this.settingsTargetsWidget.settingsTarget = this.getSettingsTarget(editablePreferencesEditorInput.getResource());
            return winjs_base_1.TPromise.join([
                this.updateInput(this.defaultPreferencesEditor, defaultPreferencesEditorInput, DefaultSettingsEditorContribution.ID, editablePreferencesEditorInput.getResource(), options, token),
                this.updateInput(this.editablePreferencesEditor, editablePreferencesEditorInput, SettingsEditorContribution.ID, defaultPreferencesEditorInput.getResource(), options, token)
            ])
                .then(function (_a) {
                var defaultPreferencesRenderer = _a[0], editablePreferencesRenderer = _a[1];
                if (token.isCancellationRequested) {
                    return {};
                }
                _this.defaultPreferencesHeader.textContent = defaultPreferencesRenderer && _this.getDefaultPreferencesHeaderText(defaultPreferencesRenderer.preferencesModel.target);
                return { defaultPreferencesRenderer: defaultPreferencesRenderer, editablePreferencesRenderer: editablePreferencesRenderer };
            });
        };
        SideBySidePreferencesWidget.prototype.getDefaultPreferencesHeaderText = function (target) {
            switch (target) {
                case 1 /* USER */:
                    return nls.localize('defaultUserSettings', "Default User Settings");
                case 2 /* WORKSPACE */:
                    return nls.localize('defaultWorkspaceSettings', "Default Workspace Settings");
                case 3 /* WORKSPACE_FOLDER */:
                    return nls.localize('defaultFolderSettings', "Default Folder Settings");
            }
            return '';
        };
        SideBySidePreferencesWidget.prototype.setResultCount = function (settingsTarget, count) {
            this.settingsTargetsWidget.setResultCount(settingsTarget, count);
        };
        SideBySidePreferencesWidget.prototype.layout = function (dimension) {
            if (dimension === void 0) { dimension = this.dimension; }
            this.dimension = dimension;
            this.splitview.layout(dimension.width);
        };
        SideBySidePreferencesWidget.prototype.focus = function () {
            if (this.lastFocusedEditor) {
                this.lastFocusedEditor.focus();
            }
        };
        SideBySidePreferencesWidget.prototype.getControl = function () {
            return this.editablePreferencesEditor ? this.editablePreferencesEditor.getControl() : null;
        };
        SideBySidePreferencesWidget.prototype.clearInput = function () {
            if (this.defaultPreferencesEditor) {
                this.defaultPreferencesEditor.clearInput();
            }
            if (this.editablePreferencesEditor) {
                this.editablePreferencesEditor.clearInput();
            }
        };
        SideBySidePreferencesWidget.prototype.setEditorVisible = function (visible, group) {
            this.isVisible = visible;
            this.group = group;
            if (this.defaultPreferencesEditor) {
                this.defaultPreferencesEditor.setVisible(this.isVisible, this.group);
            }
            if (this.editablePreferencesEditor) {
                this.editablePreferencesEditor.setVisible(this.isVisible, this.group);
            }
        };
        SideBySidePreferencesWidget.prototype.getOrCreateEditablePreferencesEditor = function (editorInput) {
            var _this = this;
            if (this.editablePreferencesEditor) {
                return this.editablePreferencesEditor;
            }
            var descriptor = platform_1.Registry.as(editor_1.Extensions.Editors).getEditor(editorInput);
            var editor = descriptor.instantiate(this.instantiationService);
            this.editablePreferencesEditor = editor;
            this.editablePreferencesEditor.create(this.editablePreferencesEditorContainer);
            this.editablePreferencesEditor.setVisible(this.isVisible, this.group);
            this.editablePreferencesEditor.getControl().onDidFocusEditorWidget(function () { return _this.lastFocusedEditor = _this.editablePreferencesEditor; });
            this.lastFocusedEditor = this.editablePreferencesEditor;
            this.layout();
            return editor;
        };
        SideBySidePreferencesWidget.prototype.updateInput = function (editor, input, editorContributionId, associatedPreferencesModelUri, options, token) {
            return editor.setInput(input, options, token)
                .then(function () {
                if (token.isCancellationRequested) {
                    return void 0;
                }
                return editor.getControl().getContribution(editorContributionId).updatePreferencesRenderer(associatedPreferencesModelUri);
            });
        };
        SideBySidePreferencesWidget.prototype.getSettingsTarget = function (resource) {
            if (this.preferencesService.userSettingsResource.toString() === resource.toString()) {
                return 1 /* USER */;
            }
            var workspaceSettingsResource = this.preferencesService.workspaceSettingsResource;
            if (workspaceSettingsResource && workspaceSettingsResource.toString() === resource.toString()) {
                return 2 /* WORKSPACE */;
            }
            var folder = this.workspaceContextService.getWorkspaceFolder(resource);
            if (folder) {
                return folder.uri;
            }
            return 1 /* USER */;
        };
        SideBySidePreferencesWidget.prototype.disposeEditors = function () {
            if (this.defaultPreferencesEditor) {
                this.defaultPreferencesEditor.dispose();
                this.defaultPreferencesEditor = null;
            }
            if (this.editablePreferencesEditor) {
                this.editablePreferencesEditor.dispose();
                this.editablePreferencesEditor = null;
            }
        };
        SideBySidePreferencesWidget.prototype.dispose = function () {
            this.disposeEditors();
            _super.prototype.dispose.call(this);
        };
        SideBySidePreferencesWidget = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, themeService_1.IThemeService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, preferences_2.IPreferencesService)
        ], SideBySidePreferencesWidget);
        return SideBySidePreferencesWidget;
    }(widget_1.Widget));
    var DefaultPreferencesEditor = /** @class */ (function (_super) {
        __extends(DefaultPreferencesEditor, _super);
        function DefaultPreferencesEditor(telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorGroupService, editorService, windowService) {
            return _super.call(this, DefaultPreferencesEditor.ID, telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorService, editorGroupService, windowService) || this;
        }
        DefaultPreferencesEditor._getContributions = function () {
            var skipContributions = [folding_1.FoldingController.prototype, multicursor_1.SelectionHighlighter.prototype, findController_1.FindController.prototype];
            var contributions = editorExtensions_1.EditorExtensionsRegistry.getEditorContributions().filter(function (c) { return skipContributions.indexOf(c.prototype) === -1; });
            contributions.push(DefaultSettingsEditorContribution);
            return contributions;
        };
        DefaultPreferencesEditor.prototype.createEditorControl = function (parent, configuration) {
            var _this = this;
            var editor = this.instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, parent, configuration, { contributions: DefaultPreferencesEditor._getContributions() });
            // Inform user about editor being readonly if user starts type
            this._register(editor.onDidType(function () { return _this.showReadonlyHint(editor); }));
            this._register(editor.onDidPaste(function () { return _this.showReadonlyHint(editor); }));
            return editor;
        };
        DefaultPreferencesEditor.prototype.showReadonlyHint = function (editor) {
            var messageController = messageController_1.MessageController.get(editor);
            if (!messageController.isVisible()) {
                messageController.showMessage(nls.localize('defaultEditorReadonly', "Edit in the right hand side editor to override defaults."), editor.getSelection().getPosition());
            }
        };
        DefaultPreferencesEditor.prototype.getConfigurationOverrides = function () {
            var options = _super.prototype.getConfigurationOverrides.call(this);
            options.readOnly = true;
            if (this.input) {
                options.lineNumbers = 'off';
                options.renderLineHighlight = 'none';
                options.scrollBeyondLastLine = false;
                options.folding = false;
                options.renderWhitespace = 'none';
                options.wordWrap = 'on';
                options.renderIndentGuides = false;
                options.rulers = [];
                options.glyphMargin = true;
                options.minimap = {
                    enabled: false
                };
            }
            return options;
        };
        DefaultPreferencesEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            return _super.prototype.setInput.call(this, input, options, token)
                .then(function () { return _this.input.resolve()
                .then(function (editorModel) {
                if (token.isCancellationRequested) {
                    return void 0;
                }
                return editorModel.load();
            })
                .then(function (editorModel) {
                if (token.isCancellationRequested) {
                    return void 0;
                }
                _this.getControl().setModel(editorModel.textEditorModel);
            }); });
        };
        DefaultPreferencesEditor.prototype.clearInput = function () {
            // Clear Model
            this.getControl().setModel(null);
            // Pass to super
            _super.prototype.clearInput.call(this);
        };
        DefaultPreferencesEditor.prototype.layout = function (dimension) {
            this.getControl().layout(dimension);
        };
        DefaultPreferencesEditor.prototype.getAriaLabel = function () {
            return nls.localize('preferencesAriaLabel', "Default preferences. Readonly text editor.");
        };
        DefaultPreferencesEditor.ID = 'workbench.editor.defaultPreferences';
        DefaultPreferencesEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, storage_1.IStorageService),
            __param(3, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(4, themeService_1.IThemeService),
            __param(5, textfiles_1.ITextFileService),
            __param(6, editorGroupsService_1.IEditorGroupsService),
            __param(7, editorService_1.IEditorService),
            __param(8, windows_1.IWindowService)
        ], DefaultPreferencesEditor);
        return DefaultPreferencesEditor;
    }(textEditor_1.BaseTextEditor));
    exports.DefaultPreferencesEditor = DefaultPreferencesEditor;
    var AbstractSettingsEditorContribution = /** @class */ (function (_super) {
        __extends(AbstractSettingsEditorContribution, _super);
        function AbstractSettingsEditorContribution(editor, instantiationService, preferencesService, workspaceContextService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.instantiationService = instantiationService;
            _this.preferencesService = preferencesService;
            _this.workspaceContextService = workspaceContextService;
            _this._register(_this.editor.onDidChangeModel(function () { return _this._onModelChanged(); }));
            return _this;
        }
        AbstractSettingsEditorContribution.prototype.updatePreferencesRenderer = function (associatedPreferencesModelUri) {
            var _this = this;
            if (!this.preferencesRendererCreationPromise) {
                this.preferencesRendererCreationPromise = this._createPreferencesRenderer();
            }
            if (this.preferencesRendererCreationPromise) {
                return this._hasAssociatedPreferencesModelChanged(associatedPreferencesModelUri)
                    .then(function (changed) { return changed ? _this._updatePreferencesRenderer(associatedPreferencesModelUri) : _this.preferencesRendererCreationPromise; });
            }
            return winjs_base_1.TPromise.as(null);
        };
        AbstractSettingsEditorContribution.prototype._onModelChanged = function () {
            var model = this.editor.getModel();
            this.disposePreferencesRenderer();
            if (model) {
                this.preferencesRendererCreationPromise = this._createPreferencesRenderer();
            }
        };
        AbstractSettingsEditorContribution.prototype._hasAssociatedPreferencesModelChanged = function (associatedPreferencesModelUri) {
            return this.preferencesRendererCreationPromise.then(function (preferencesRenderer) {
                return !(preferencesRenderer && preferencesRenderer.getAssociatedPreferencesModel() && preferencesRenderer.getAssociatedPreferencesModel().uri.toString() === associatedPreferencesModelUri.toString());
            });
        };
        AbstractSettingsEditorContribution.prototype._updatePreferencesRenderer = function (associatedPreferencesModelUri) {
            var _this = this;
            return this.preferencesService.createPreferencesEditorModel(associatedPreferencesModelUri)
                .then(function (associatedPreferencesEditorModel) {
                return _this.preferencesRendererCreationPromise.then(function (preferencesRenderer) {
                    if (preferencesRenderer) {
                        var associatedPreferencesModel = preferencesRenderer.getAssociatedPreferencesModel();
                        if (associatedPreferencesModel) {
                            associatedPreferencesModel.dispose();
                        }
                        preferencesRenderer.setAssociatedPreferencesModel(associatedPreferencesEditorModel);
                    }
                    return preferencesRenderer;
                });
            });
        };
        AbstractSettingsEditorContribution.prototype.disposePreferencesRenderer = function () {
            if (this.preferencesRendererCreationPromise) {
                this.preferencesRendererCreationPromise.then(function (preferencesRenderer) {
                    if (preferencesRenderer) {
                        var associatedPreferencesModel = preferencesRenderer.getAssociatedPreferencesModel();
                        if (associatedPreferencesModel) {
                            associatedPreferencesModel.dispose();
                        }
                        preferencesRenderer.preferencesModel.dispose();
                        preferencesRenderer.dispose();
                    }
                });
                this.preferencesRendererCreationPromise = winjs_base_1.TPromise.as(null);
            }
        };
        AbstractSettingsEditorContribution.prototype.dispose = function () {
            this.disposePreferencesRenderer();
            _super.prototype.dispose.call(this);
        };
        AbstractSettingsEditorContribution = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, preferences_2.IPreferencesService),
            __param(3, workspace_1.IWorkspaceContextService)
        ], AbstractSettingsEditorContribution);
        return AbstractSettingsEditorContribution;
    }(lifecycle_1.Disposable));
    var DefaultSettingsEditorContribution = /** @class */ (function (_super) {
        __extends(DefaultSettingsEditorContribution, _super);
        function DefaultSettingsEditorContribution() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultSettingsEditorContribution.prototype.getId = function () {
            return DefaultSettingsEditorContribution.ID;
        };
        DefaultSettingsEditorContribution.prototype._createPreferencesRenderer = function () {
            var _this = this;
            return this.preferencesService.createPreferencesEditorModel(this.editor.getModel().uri)
                .then(function (editorModel) {
                if (editorModel instanceof preferencesModels_1.DefaultSettingsEditorModel && _this.editor.getModel()) {
                    var preferencesRenderer = _this.instantiationService.createInstance(preferencesRenderers_1.DefaultSettingsRenderer, _this.editor, editorModel);
                    preferencesRenderer.render();
                    return preferencesRenderer;
                }
                return null;
            });
        };
        DefaultSettingsEditorContribution.ID = 'editor.contrib.defaultsettings';
        return DefaultSettingsEditorContribution;
    }(AbstractSettingsEditorContribution));
    var SettingsEditorContribution = /** @class */ (function (_super) {
        __extends(SettingsEditorContribution, _super);
        function SettingsEditorContribution(editor, instantiationService, preferencesService, workspaceContextService) {
            var _this = _super.call(this, editor, instantiationService, preferencesService, workspaceContextService) || this;
            _this._register(_this.workspaceContextService.onDidChangeWorkbenchState(function () { return _this._onModelChanged(); }));
            return _this;
        }
        SettingsEditorContribution.prototype.getId = function () {
            return SettingsEditorContribution.ID;
        };
        SettingsEditorContribution.prototype._createPreferencesRenderer = function () {
            var _this = this;
            if (this.isSettingsModel()) {
                return this.preferencesService.createPreferencesEditorModel(this.editor.getModel().uri)
                    .then(function (settingsModel) {
                    if (settingsModel instanceof preferencesModels_1.SettingsEditorModel && _this.editor.getModel()) {
                        switch (settingsModel.configurationTarget) {
                            case 1 /* USER */:
                                return _this.instantiationService.createInstance(preferencesRenderers_1.UserSettingsRenderer, _this.editor, settingsModel);
                            case 2 /* WORKSPACE */:
                                return _this.instantiationService.createInstance(preferencesRenderers_1.WorkspaceSettingsRenderer, _this.editor, settingsModel);
                            case 3 /* WORKSPACE_FOLDER */:
                                return _this.instantiationService.createInstance(preferencesRenderers_1.FolderSettingsRenderer, _this.editor, settingsModel);
                        }
                    }
                    return null;
                })
                    .then(function (preferencesRenderer) {
                    if (preferencesRenderer) {
                        preferencesRenderer.render();
                    }
                    return preferencesRenderer;
                });
            }
            return null;
        };
        SettingsEditorContribution.prototype.isSettingsModel = function () {
            var model = this.editor.getModel();
            if (!model) {
                return false;
            }
            if (this.preferencesService.userSettingsResource && this.preferencesService.userSettingsResource.toString() === model.uri.toString()) {
                return true;
            }
            if (this.preferencesService.workspaceSettingsResource && this.preferencesService.workspaceSettingsResource.toString() === model.uri.toString()) {
                return true;
            }
            for (var _i = 0, _a = this.workspaceContextService.getWorkspace().folders; _i < _a.length; _i++) {
                var folder = _a[_i];
                var folderSettingsResource = this.preferencesService.getFolderSettingsResource(folder.uri);
                if (folderSettingsResource && folderSettingsResource.toString() === model.uri.toString()) {
                    return true;
                }
            }
            return false;
        };
        SettingsEditorContribution.ID = 'editor.contrib.settings';
        SettingsEditorContribution = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, preferences_2.IPreferencesService),
            __param(3, workspace_1.IWorkspaceContextService)
        ], SettingsEditorContribution);
        return SettingsEditorContribution;
    }(AbstractSettingsEditorContribution));
    editorExtensions_1.registerEditorContribution(SettingsEditorContribution);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[384/*vs/workbench/parts/preferences/electron-browser/settingsEditor2*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,50/*vs/base/browser/ui/actionbar/actionbar*/,133/*vs/base/browser/ui/toolbar/toolbar*/,15/*vs/base/common/actions*/,19/*vs/base/common/arrays*/,29/*vs/base/common/types*/,17/*vs/base/common/async*/,55/*vs/base/common/cancellation*/,118/*vs/base/common/collections*/,25/*vs/base/common/errors*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,296/*vs/base/parts/tree/browser/treeUtils*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,43/*vs/platform/environment/common/environment*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,86/*vs/platform/log/common/log*/,28/*vs/platform/notification/common/notification*/,44/*vs/platform/storage/common/storage*/,32/*vs/platform/telemetry/common/telemetry*/,30/*vs/platform/theme/common/colorRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,399/*vs/workbench/parts/codeEditor/electron-browser/suggestEnabledInput*/,216/*vs/workbench/parts/preferences/browser/preferencesEditor*/,144/*vs/workbench/parts/preferences/browser/preferencesWidgets*/,193/*vs/workbench/parts/preferences/browser/settingsLayout*/,202/*vs/workbench/parts/preferences/browser/settingsTree*/,161/*vs/workbench/parts/preferences/browser/settingsTreeModels*/,151/*vs/workbench/parts/preferences/browser/settingsWidgets*/,356/*vs/workbench/parts/preferences/browser/tocTree*/,109/*vs/workbench/parts/preferences/common/preferences*/,61/*vs/workbench/services/preferences/common/preferences*/,273/*vs/css!vs/workbench/parts/preferences/electron-browser/media/settingsEditor2*/]), function (require, exports, DOM, actionbar_1, toolbar_1, actions_1, arrays, types_1, async_1, cancellation_1, collections, errors_1, uri_1, winjs_base_1, treeUtils_1, nls_1, configuration_1, contextkey_1, contextView_1, environment_1, instantiation_1, keybinding_1, log_1, notification_1, storage_1, telemetry_1, colorRegistry_1, styler_1, themeService_1, baseEditor_1, suggestEnabledInput_1, preferencesEditor_1, preferencesWidgets_1, settingsLayout_1, settingsTree_1, settingsTreeModels_1, settingsWidgets_1, tocTree_1, preferences_1, preferences_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = DOM.$;
    var SettingsEditor2 = /** @class */ (function (_super) {
        __extends(SettingsEditor2, _super);
        function SettingsEditor2(telemetryService, configurationService, themeService, preferencesService, instantiationService, preferencesSearchService, logService, environmentService, contextKeyService, contextMenuService, storageService, notificationService, keybindingService) {
            var _this = _super.call(this, SettingsEditor2.ID, telemetryService, themeService) || this;
            _this.configurationService = configurationService;
            _this.preferencesService = preferencesService;
            _this.instantiationService = instantiationService;
            _this.preferencesSearchService = preferencesSearchService;
            _this.logService = logService;
            _this.environmentService = environmentService;
            _this.contextMenuService = contextMenuService;
            _this.storageService = storageService;
            _this.notificationService = notificationService;
            _this.keybindingService = keybindingService;
            _this.delayedFilterLogging = new async_1.Delayer(1000);
            _this.localSearchDelayer = new async_1.Delayer(300);
            _this.remoteSearchThrottle = new async_1.ThrottledDelayer(200);
            _this.viewState = { settingsTarget: 1 /* USER */ };
            _this.delayRefreshOnLayout = new async_1.Delayer(100);
            _this.settingFastUpdateDelayer = new async_1.Delayer(SettingsEditor2.SETTING_UPDATE_FAST_DEBOUNCE);
            _this.settingSlowUpdateDelayer = new async_1.Delayer(SettingsEditor2.SETTING_UPDATE_SLOW_DEBOUNCE);
            _this.inSettingsEditorContextKey = preferences_1.CONTEXT_SETTINGS_EDITOR.bindTo(contextKeyService);
            _this.searchFocusContextKey = preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS.bindTo(contextKeyService);
            _this.tocRowFocused = preferences_1.CONTEXT_TOC_ROW_FOCUS.bindTo(contextKeyService);
            _this.scheduledRefreshes = new Map();
            _this._register(configurationService.onDidChangeConfiguration(function (e) {
                if (e.source !== 4 /* DEFAULT */) {
                    _this.onConfigUpdate(e.affectedKeys);
                }
            }));
            return _this;
        }
        SettingsEditor2.shouldSettingUpdateFast = function (type) {
            if (types_1.isArray(type)) {
                // nullable integer/number or complex
                return false;
            }
            return type === preferences_2.SettingValueType.Enum || type === preferences_2.SettingValueType.Complex;
        };
        Object.defineProperty(SettingsEditor2.prototype, "currentSettingsModel", {
            get: function () {
                return this.searchResultModel || this.settingsTreeModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsEditor2.prototype, "searchResultModel", {
            get: function () {
                return this._searchResultModel;
            },
            set: function (value) {
                this._searchResultModel = value;
                DOM.toggleClass(this.rootElement, 'search-mode', !!this._searchResultModel);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SettingsEditor2.prototype, "currentSettingsContextMenuKeyBindingLabel", {
            get: function () {
                return this.keybindingService.lookupKeybinding(preferences_1.SETTINGS_EDITOR_COMMAND_SHOW_CONTEXT_MENU).getAriaLabel();
            },
            enumerable: true,
            configurable: true
        });
        SettingsEditor2.prototype.createEditor = function (parent) {
            parent.setAttribute('tabindex', '-1');
            this.rootElement = DOM.append(parent, $('.settings-editor'));
            this.createHeader(this.rootElement);
            this.createBody(this.rootElement);
            this.updateStyles();
        };
        SettingsEditor2.prototype.setInput = function (input, options, token) {
            var _this = this;
            this.inSettingsEditorContextKey.set(true);
            return _super.prototype.setInput.call(this, input, options, token)
                .then(function () { return new Promise(process.nextTick); }) // Force setInput to be async
                .then(function () {
                if (!options) {
                    if (!_this.viewState.settingsTarget) {
                        // Persist?
                        options = preferences_2.SettingsEditorOptions.create({ target: 1 /* USER */ });
                    }
                }
                else if (!options.target) {
                    options.target = 1 /* USER */;
                }
                _this._setOptions(options);
                _this.render(token);
            })
                .then(function () {
                // Init TOC selection
                _this.updateTreeScrollSync();
            });
        };
        SettingsEditor2.prototype.setOptions = function (options) {
            _super.prototype.setOptions.call(this, options);
            this._setOptions(options);
        };
        SettingsEditor2.prototype._setOptions = function (options) {
            if (!options) {
                return;
            }
            if (options.query) {
                this.searchWidget.setValue(options.query);
            }
            var target = options.folderUri || options.target;
            this.settingsTargetsWidget.settingsTarget = target;
            this.viewState.settingsTarget = target;
        };
        SettingsEditor2.prototype.clearInput = function () {
            this.inSettingsEditorContextKey.set(false);
            _super.prototype.clearInput.call(this);
        };
        SettingsEditor2.prototype.layout = function (dimension) {
            var _this = this;
            var firstEl = this.settingsTree.getFirstVisibleElement();
            var firstElTop = this.settingsTree.getRelativeTop(firstEl);
            this.layoutTrees(dimension);
            var innerWidth = dimension.width - 24 * 2; // 24px padding on left and right
            var monacoWidth = (innerWidth > 1000 ? 1000 : innerWidth) - 10;
            this.searchWidget.layout({ height: 20, width: monacoWidth });
            DOM.toggleClass(this.rootElement, 'narrow', dimension.width < 600);
            // #56185
            if (dimension.width !== this.lastLayedoutWidth) {
                this.lastLayedoutWidth = dimension.width;
                this.delayRefreshOnLayout.trigger(function () {
                    _this.renderTree(undefined, true).then(function () {
                        _this.settingsTree.reveal(firstEl, firstElTop);
                    });
                });
            }
        };
        SettingsEditor2.prototype.focus = function () {
            if (this.lastFocusedSettingElement) {
                var elements = this.settingsTreeRenderer.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), this.lastFocusedSettingElement);
                if (elements.length) {
                    var control = elements[0].querySelector(settingsTree_1.SettingsRenderer.CONTROL_SELECTOR);
                    if (control) {
                        control.focus();
                        return;
                    }
                }
            }
            this.focusSearch();
        };
        SettingsEditor2.prototype.focusSettings = function () {
            // Update ARIA global labels
            var labelElement = this.settingsAriaExtraLabelsContainer.querySelector('#settings_aria_more_actions_shortcut_label');
            if (labelElement) {
                var settingsContextMenuShortcut = this.currentSettingsContextMenuKeyBindingLabel;
                if (settingsContextMenuShortcut) {
                    labelElement.setAttribute('aria-label', nls_1.localize('settingsContextMenuAriaShortcut', "For more actions, Press {0}.", settingsContextMenuShortcut));
                }
            }
            var firstFocusable = this.settingsTree.getHTMLElement().querySelector(settingsTree_1.SettingsRenderer.CONTROL_SELECTOR);
            if (firstFocusable) {
                firstFocusable.focus();
            }
        };
        SettingsEditor2.prototype.showContextMenu = function () {
            var settingDOMElement = this.settingsTreeRenderer.getSettingDOMElementForDOMElement(this.getActiveElementInSettingsTree());
            if (!settingDOMElement) {
                return;
            }
            var focusedKey = this.settingsTreeRenderer.getKeyForDOMElementInSetting(settingDOMElement);
            if (!focusedKey) {
                return;
            }
            var elements = this.currentSettingsModel.getElementsByName(focusedKey);
            if (elements && elements[0]) {
                this.settingsTreeRenderer.showContextMenu(elements[0], settingDOMElement);
            }
        };
        SettingsEditor2.prototype.focusSearch = function (filter, selectAll) {
            if (selectAll === void 0) { selectAll = true; }
            if (filter && this.searchWidget) {
                this.searchWidget.setValue(filter);
            }
            this.searchWidget.focus(selectAll);
        };
        SettingsEditor2.prototype.clearSearchResults = function () {
            this.searchWidget.setValue('');
        };
        SettingsEditor2.prototype.createHeader = function (parent) {
            var _this = this;
            this.headerContainer = DOM.append(parent, $('.settings-header'));
            var searchContainer = DOM.append(this.headerContainer, $('.search-container'));
            var searchBoxLabel = nls_1.localize('SearchSettings.AriaLabel', "Search settings");
            this.searchWidget = this._register(this.instantiationService.createInstance(suggestEnabledInput_1.SuggestEnabledInput, SettingsEditor2.ID + ".searchbox", searchContainer, {
                triggerCharacters: ['@'],
                provideResults: function (query) {
                    return SettingsEditor2.SUGGESTIONS.filter(function (tag) { return query.indexOf(tag) === -1; }).map(function (tag) { return tag + ' '; });
                }
            }, searchBoxLabel, 'settingseditor:searchinput' + SettingsEditor2.NUM_INSTANCES++, {
                placeholderText: searchBoxLabel,
                focusContextKey: this.searchFocusContextKey,
            }));
            this._register(suggestEnabledInput_1.attachSuggestEnabledInputBoxStyler(this.searchWidget, this.themeService, {
                inputBorder: settingsWidgets_1.settingsTextInputBorder
            }));
            this.countElement = DOM.append(searchContainer, DOM.$('.settings-count-widget'));
            this._register(styler_1.attachStylerCallback(this.themeService, { badgeBackground: colorRegistry_1.badgeBackground, contrastBorder: colorRegistry_1.contrastBorder, badgeForeground: colorRegistry_1.badgeForeground }, function (colors) {
                var background = colors.badgeBackground ? colors.badgeBackground.toString() : null;
                var border = colors.contrastBorder ? colors.contrastBorder.toString() : null;
                _this.countElement.style.backgroundColor = background;
                _this.countElement.style.color = colors.badgeForeground.toString();
                _this.countElement.style.borderWidth = border ? '1px' : null;
                _this.countElement.style.borderStyle = border ? 'solid' : null;
                _this.countElement.style.borderColor = border;
            }));
            this._register(this.searchWidget.onInputDidChange(function () { return _this.onSearchInputChanged(); }));
            var headerControlsContainer = DOM.append(this.headerContainer, $('.settings-header-controls'));
            var targetWidgetContainer = DOM.append(headerControlsContainer, $('.settings-target-container'));
            this.settingsTargetsWidget = this._register(this.instantiationService.createInstance(preferencesWidgets_1.SettingsTargetsWidget, targetWidgetContainer));
            this.settingsTargetsWidget.settingsTarget = 1 /* USER */;
            this.settingsTargetsWidget.onDidTargetChange(function (target) { return _this.onDidSettingsTargetChange(target); });
            this.createHeaderControls(headerControlsContainer);
        };
        SettingsEditor2.prototype.onDidSettingsTargetChange = function (target) {
            this.viewState.settingsTarget = target;
            // TODO Instead of rebuilding the whole model, refresh and uncache the inspected setting value
            this.onConfigUpdate(undefined, true);
        };
        SettingsEditor2.prototype.createHeaderControls = function (parent) {
            var _this = this;
            var headerControlsContainerRight = DOM.append(parent, $('.settings-header-controls-right'));
            this.toolbar = this._register(new toolbar_1.ToolBar(headerControlsContainerRight, this.contextMenuService, {
                ariaLabel: nls_1.localize('settingsToolbarLabel', "Settings Editor Actions"),
                actionRunner: this.actionRunner
            }));
            var actions = [
                this.instantiationService.createInstance(FilterByTagAction, nls_1.localize('filterModifiedLabel', "Show modified settings"), settingsTreeModels_1.MODIFIED_SETTING_TAG, this)
            ];
            if (this.environmentService.appQuality !== 'stable') {
                actions.push(this.instantiationService.createInstance(FilterByTagAction, nls_1.localize('filterOnlineServicesLabel', "Show settings for online services"), settingsTreeModels_1.ONLINE_SERVICES_SETTING_TAG, this));
                actions.push(new actionbar_1.Separator());
            }
            actions.push(new actions_1.Action('settings.openSettingsJson', nls_1.localize('openSettingsJsonLabel', "Open settings.json"), undefined, undefined, function () {
                return _this.openSettingsFile().then(function (editor) {
                    var currentQuery = settingsTreeModels_1.parseQuery(_this.searchWidget.getValue());
                    if (editor instanceof preferencesEditor_1.PreferencesEditor && currentQuery) {
                        editor.focusSearch(currentQuery.query);
                    }
                });
            }));
            this.toolbar.setActions([], actions)();
            this.toolbar.context = { target: this.settingsTargetsWidget.settingsTarget };
        };
        SettingsEditor2.prototype.onDidClickSetting = function (evt, recursed) {
            var _this = this;
            var elements = this.currentSettingsModel.getElementsByName(evt.targetKey);
            if (elements && elements[0]) {
                var sourceTop = this.settingsTree.getRelativeTop(evt.source);
                if (sourceTop < 0) {
                    // e.g. clicked a searched element, now the search has been cleared
                    sourceTop = .5;
                }
                this.settingsTree.reveal(elements[0], sourceTop);
                var domElements = this.settingsTreeRenderer.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), evt.targetKey);
                if (domElements && domElements[0]) {
                    var control = domElements[0].querySelector(settingsTree_1.SettingsRenderer.CONTROL_SELECTOR);
                    if (control) {
                        control.focus();
                    }
                }
            }
            else if (!recursed) {
                var p = this.triggerSearch('');
                p.then(function () {
                    _this.searchWidget.setValue('');
                    _this.onDidClickSetting(evt, true);
                });
            }
        };
        SettingsEditor2.prototype.openSettingsFile = function (query) {
            var currentSettingsTarget = this.settingsTargetsWidget.settingsTarget;
            var options = { query: query };
            if (currentSettingsTarget === 1 /* USER */) {
                return this.preferencesService.openGlobalSettings(true, options);
            }
            else if (currentSettingsTarget === 2 /* WORKSPACE */) {
                return this.preferencesService.openWorkspaceSettings(true, options);
            }
            else {
                return this.preferencesService.openFolderSettings(currentSettingsTarget, true, options);
            }
        };
        SettingsEditor2.prototype.createBody = function (parent) {
            var _this = this;
            var bodyContainer = DOM.append(parent, $('.settings-body'));
            this.noResultsMessage = DOM.append(bodyContainer, $('.no-results'));
            this.noResultsMessage.innerText = nls_1.localize('noResults', "No Settings Found");
            this._register(styler_1.attachStylerCallback(this.themeService, { editorForeground: colorRegistry_1.editorForeground }, function (colors) {
                _this.noResultsMessage.style.color = colors.editorForeground ? colors.editorForeground.toString() : null;
            }));
            this.createTOC(bodyContainer);
            this.createFocusSink(bodyContainer, function (e) {
                if (DOM.findParentWithClass(e.relatedTarget, 'settings-editor-tree')) {
                    if (_this.settingsTree.getScrollPosition() > 0) {
                        var firstElement = _this.settingsTree.getFirstVisibleElement();
                        _this.settingsTree.reveal(firstElement, 0.1);
                        return true;
                    }
                }
                else {
                    var firstControl = _this.settingsTree.getHTMLElement().querySelector(settingsTree_1.SettingsRenderer.CONTROL_SELECTOR);
                    if (firstControl) {
                        firstControl.focus();
                    }
                }
                return false;
            }, 'settings list focus helper');
            this.createSettingsTree(bodyContainer);
            this.createFocusSink(bodyContainer, function (e) {
                if (DOM.findParentWithClass(e.relatedTarget, 'settings-editor-tree')) {
                    if (_this.settingsTree.getScrollPosition() < 1) {
                        var lastElement = _this.settingsTree.getLastVisibleElement();
                        _this.settingsTree.reveal(lastElement, 0.9);
                        return true;
                    }
                }
                return false;
            }, 'settings list focus helper');
        };
        SettingsEditor2.prototype.createFocusSink = function (container, callback, label) {
            var listFocusSink = DOM.append(container, $('.settings-tree-focus-sink'));
            listFocusSink.setAttribute('aria-label', label);
            listFocusSink.tabIndex = 0;
            this._register(DOM.addDisposableListener(listFocusSink, 'focus', function (e) {
                if (e.relatedTarget && callback(e)) {
                    e.relatedTarget.focus();
                }
            }));
            return listFocusSink;
        };
        SettingsEditor2.prototype.createTOC = function (parent) {
            var _this = this;
            this.tocTreeModel = new tocTree_1.TOCTreeModel(this.viewState);
            this.tocTreeContainer = DOM.append(parent, $('.settings-toc-container'));
            var tocRenderer = this.instantiationService.createInstance(tocTree_1.TOCRenderer);
            this.tocTree = this._register(this.instantiationService.createInstance(tocTree_1.TOCTree, DOM.append(this.tocTreeContainer, $('.settings-toc-wrapper')), this.viewState, {
                renderer: tocRenderer
            }));
            this._register(this.tocTree.onDidChangeFocus(function (e) {
                var element = e.focus;
                if (_this.searchResultModel) {
                    _this.viewState.filterToCategory = element;
                    _this.renderTree();
                }
                if (element && (!e.payload || !e.payload.fromScroll)) {
                    var refreshP = winjs_base_1.TPromise.wrap(null);
                    if (_this.settingsTreeDataSource.pageTo(element.index, true)) {
                        refreshP = _this.renderTree();
                    }
                    refreshP.then(function () { return _this.settingsTree.reveal(element, 0); });
                }
            }));
            this._register(this.tocTree.onDidFocus(function () {
                _this.tocRowFocused.set(true);
            }));
            this._register(this.tocTree.onDidBlur(function () {
                _this.tocRowFocused.set(false);
            }));
        };
        SettingsEditor2.prototype.createSettingsTree = function (parent) {
            var _this = this;
            this.settingsTreeContainer = DOM.append(parent, $('.settings-tree-container'));
            // Add  ARIA extra labels div
            this.settingsAriaExtraLabelsContainer = DOM.append(this.settingsTreeContainer, $('.settings-aria-extra-labels'));
            this.settingsAriaExtraLabelsContainer.id = 'settings_aria_extra_labels';
            // Add global labels here
            var labelDiv = DOM.append(this.settingsAriaExtraLabelsContainer, $('.settings-aria-extra-label'));
            labelDiv.id = 'settings_aria_more_actions_shortcut_label';
            labelDiv.setAttribute('aria-label', '');
            this.settingsTreeRenderer = this.instantiationService.createInstance(settingsTree_1.SettingsRenderer, this.settingsTreeContainer);
            this._register(this.settingsTreeRenderer.onDidChangeSetting(function (e) { return _this.onDidChangeSetting(e.key, e.value, e.type); }));
            this._register(this.settingsTreeRenderer.onDidOpenSettings(function (settingKey) {
                _this.openSettingsFile(settingKey);
            }));
            this._register(this.settingsTreeRenderer.onDidClickSettingLink(function (settingName) { return _this.onDidClickSetting(settingName); }));
            this._register(this.settingsTreeRenderer.onDidFocusSetting(function (element) {
                _this.lastFocusedSettingElement = element.setting.key;
                _this.settingsTree.reveal(element);
            }));
            this.settingsTreeDataSource = this.instantiationService.createInstance(settingsTree_1.SimplePagedDataSource, this.instantiationService.createInstance(settingsTree_1.SettingsDataSource, this.viewState));
            this.settingsTree = this._register(this.instantiationService.createInstance(settingsTree_1.SettingsTree, this.settingsTreeContainer, this.viewState, {
                renderer: this.settingsTreeRenderer,
                dataSource: this.settingsTreeDataSource
            }));
            this.settingsTree.getHTMLElement().attributes.removeNamedItem('tabindex');
            // Have to redefine role of the tree widget to form for input elements
            // TODO:CDL make this an option for tree
            this.settingsTree.getHTMLElement().setAttribute('role', 'form');
            this._register(this.settingsTree.onDidScroll(function () {
                _this.updateTreeScrollSync();
            }));
        };
        SettingsEditor2.prototype.notifyNoSaveNeeded = function (force) {
            if (force === void 0) { force = true; }
            if (force || !this.storageService.getBoolean('hasNotifiedOfSettingsAutosave', 0 /* GLOBAL */, false)) {
                this.storageService.store('hasNotifiedOfSettingsAutosave', true, 0 /* GLOBAL */);
                this.notificationService.info(nls_1.localize('settingsNoSaveNeeded', "Your changes are automatically saved as you edit."));
            }
        };
        SettingsEditor2.prototype.onDidChangeSetting = function (key, value, type) {
            var _this = this;
            this.notifyNoSaveNeeded(false);
            if (this.pendingSettingUpdate && this.pendingSettingUpdate.key !== key) {
                this.updateChangedSetting(key, value);
            }
            this.pendingSettingUpdate = { key: key, value: value };
            if (SettingsEditor2.shouldSettingUpdateFast(type)) {
                this.settingFastUpdateDelayer.trigger(function () { return _this.updateChangedSetting(key, value); });
            }
            else {
                this.settingSlowUpdateDelayer.trigger(function () { return _this.updateChangedSetting(key, value); });
            }
        };
        SettingsEditor2.prototype.updateTreeScrollSync = function () {
            this.settingsTreeRenderer.cancelSuggesters();
            if (this.searchResultModel) {
                return;
            }
            if (!this.tocTree.getInput()) {
                return;
            }
            this.updateTreePagingByScroll();
            var elementToSync = this.settingsTree.getFirstVisibleElement();
            var element = elementToSync instanceof settingsTreeModels_1.SettingsTreeSettingElement ? elementToSync.parent :
                elementToSync instanceof settingsTreeModels_1.SettingsTreeGroupElement ? elementToSync :
                    null;
            if (element && this.tocTree.getSelection()[0] !== element) {
                this.tocTree.reveal(element);
                var elementTop = this.tocTree.getRelativeTop(element);
                treeUtils_1.collapseAll(this.tocTree, element);
                if (elementTop < 0 || elementTop > 1) {
                    this.tocTree.reveal(element);
                }
                else {
                    this.tocTree.reveal(element, elementTop);
                }
                this.tocTree.expand(element);
                this.tocTree.setSelection([element]);
                this.tocTree.setFocus(element, { fromScroll: true });
            }
        };
        SettingsEditor2.prototype.updateTreePagingByScroll = function () {
            var lastVisibleElement = this.settingsTree.getLastVisibleElement();
            if (lastVisibleElement && this.settingsTreeDataSource.pageTo(lastVisibleElement.index)) {
                this.renderTree();
            }
        };
        SettingsEditor2.prototype.updateChangedSetting = function (key, value) {
            var _this = this;
            // ConfigurationService displays the error if this fails.
            // Force a render afterwards because onDidConfigurationUpdate doesn't fire if the update doesn't result in an effective setting value change
            var settingsTarget = this.settingsTargetsWidget.settingsTarget;
            var resource = uri_1.URI.isUri(settingsTarget) ? settingsTarget : undefined;
            var configurationTarget = (resource ? 3 /* WORKSPACE_FOLDER */ : settingsTarget);
            var overrides = { resource: resource };
            var isManualReset = value === undefined;
            // If the user is changing the value back to the default, do a 'reset' instead
            var inspected = this.configurationService.inspect(key, overrides);
            if (inspected.default === value) {
                value = undefined;
            }
            return this.configurationService.updateValue(key, value, overrides, configurationTarget)
                .then(function () { return _this.renderTree(key, isManualReset); })
                .then(function () {
                var reportModifiedProps = {
                    key: key,
                    query: _this.searchWidget.getValue(),
                    searchResults: _this.searchResultModel && _this.searchResultModel.getUniqueResults(),
                    rawResults: _this.searchResultModel && _this.searchResultModel.getRawResults(),
                    showConfiguredOnly: _this.viewState.tagFilters && _this.viewState.tagFilters.has(settingsTreeModels_1.MODIFIED_SETTING_TAG),
                    isReset: typeof value === 'undefined',
                    settingsTarget: _this.settingsTargetsWidget.settingsTarget
                };
                return _this.reportModifiedSetting(reportModifiedProps);
            });
        };
        SettingsEditor2.prototype.reportModifiedSetting = function (props) {
            this.pendingSettingUpdate = null;
            var remoteResult = props.searchResults && props.searchResults[1 /* Remote */];
            var localResult = props.searchResults && props.searchResults[0 /* Local */];
            var groupId = undefined;
            var nlpIndex = undefined;
            var displayIndex = undefined;
            if (props.searchResults) {
                var localIndex = arrays.firstIndex(localResult.filterMatches, function (m) { return m.setting.key === props.key; });
                groupId = localIndex >= 0 ?
                    'local' :
                    'remote';
                displayIndex = localIndex >= 0 ?
                    localIndex :
                    remoteResult && (arrays.firstIndex(remoteResult.filterMatches, function (m) { return m.setting.key === props.key; }) + localResult.filterMatches.length);
                if (this.searchResultModel) {
                    var rawResults = this.searchResultModel.getRawResults();
                    if (rawResults[1 /* Remote */]) {
                        var _nlpIndex = arrays.firstIndex(rawResults[1 /* Remote */].filterMatches, function (m) { return m.setting.key === props.key; });
                        nlpIndex = _nlpIndex >= 0 ? _nlpIndex : undefined;
                    }
                }
            }
            var reportedTarget = props.settingsTarget === 1 /* USER */ ? 'user' :
                props.settingsTarget === 2 /* WORKSPACE */ ? 'workspace' :
                    'folder';
            var data = {
                key: props.key,
                query: props.query,
                groupId: groupId,
                nlpIndex: nlpIndex,
                displayIndex: displayIndex,
                showConfiguredOnly: props.showConfiguredOnly,
                isReset: props.isReset,
                target: reportedTarget
            };
            /* __GDPR__
                "settingsEditor.settingModified" : {
                    "key" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "query" : { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                    "groupId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "nlpIndex" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "displayIndex" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "showConfiguredOnly" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "isReset" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "target" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('settingsEditor.settingModified', data);
            var data2 = {
                key: props.key,
                groupId: groupId,
                nlpIndex: nlpIndex,
                displayIndex: displayIndex,
                showConfiguredOnly: props.showConfiguredOnly,
                isReset: props.isReset,
                target: reportedTarget
            };
            /* __GDPR__
                "settingsEditor.settingModified<NUMBER>" : {
                    "key" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "groupId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "nlpIndex" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "displayIndex" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "showConfiguredOnly" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "isReset" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "target" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('settingsEditor.settingModified2', data2);
        };
        SettingsEditor2.prototype.render = function (token) {
            var _this = this;
            if (this.input) {
                return this.input.resolve()
                    .then(function (model) {
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    _this._register(model.onDidChangeGroups(function () { return _this.onConfigUpdate(); }));
                    _this.defaultSettingsEditorModel = model;
                    return _this.onConfigUpdate();
                });
            }
            return winjs_base_1.TPromise.as(null);
        };
        SettingsEditor2.prototype.onSearchModeToggled = function () {
            DOM.removeClass(this.rootElement, 'no-toc-search');
            if (this.configurationService.getValue('workbench.settings.settingsSearchTocBehavior') === 'hide') {
                DOM.toggleClass(this.rootElement, 'no-toc-search', !!this.searchResultModel);
            }
            if (this.searchResultModel) {
                this.settingsTreeDataSource.pageTo(Number.MAX_VALUE);
            }
            else {
                this.settingsTreeDataSource.reset();
            }
        };
        SettingsEditor2.prototype.scheduleRefresh = function (element, key) {
            var _this = this;
            if (key === void 0) { key = ''; }
            if (key && this.scheduledRefreshes.has(key)) {
                return;
            }
            if (!key) {
                this.scheduledRefreshes.forEach(function (r) { return r.dispose(); });
                this.scheduledRefreshes.clear();
            }
            var scheduledRefreshTracker = DOM.trackFocus(element);
            this.scheduledRefreshes.set(key, scheduledRefreshTracker);
            scheduledRefreshTracker.onDidBlur(function () {
                scheduledRefreshTracker.dispose();
                _this.scheduledRefreshes.delete(key);
                _this.onConfigUpdate([key]);
            });
        };
        SettingsEditor2.prototype.onConfigUpdate = function (keys, forceRefresh) {
            if (forceRefresh === void 0) { forceRefresh = false; }
            if (keys && this.settingsTreeModel) {
                return this.updateElementsByKey(keys);
            }
            var groups = this.defaultSettingsEditorModel.settingsGroups.slice(1); // Without commonlyUsed
            var dividedGroups = collections.groupBy(groups, function (g) { return g.contributedByExtension ? 'extension' : 'core'; });
            var settingsResult = settingsTree_1.resolveSettingsTree(settingsLayout_1.tocData, dividedGroups.core);
            var resolvedSettingsRoot = settingsResult.tree;
            // Warn for settings not included in layout
            if (settingsResult.leftoverSettings.size && !this.hasWarnedMissingSettings) {
                var settingKeyList_1 = [];
                settingsResult.leftoverSettings.forEach(function (s) {
                    settingKeyList_1.push(s.key);
                });
                this.logService.warn("SettingsEditor2: Settings not included in settingsLayout.ts: " + settingKeyList_1.join(', '));
                this.hasWarnedMissingSettings = true;
            }
            var commonlyUsed = settingsTree_1.resolveSettingsTree(settingsLayout_1.commonlyUsedData, dividedGroups.core);
            resolvedSettingsRoot.children.unshift(commonlyUsed.tree);
            resolvedSettingsRoot.children.push(settingsTree_1.resolveExtensionsSettings(dividedGroups.extension || []));
            if (this.searchResultModel) {
                this.searchResultModel.updateChildren();
            }
            if (this.settingsTreeModel) {
                this.settingsTreeModel.update(resolvedSettingsRoot);
                return this.renderTree(undefined, forceRefresh);
            }
            else {
                this.settingsTreeModel = this.instantiationService.createInstance(settingsTreeModels_1.SettingsTreeModel, this.viewState);
                this.settingsTreeModel.update(resolvedSettingsRoot);
                this.settingsTree.setInput(this.settingsTreeModel.root);
                this.tocTreeModel.settingsTreeRoot = this.settingsTreeModel.root;
                if (this.tocTree.getInput()) {
                    this.tocTree.refresh();
                }
                else {
                    this.tocTree.setInput(this.tocTreeModel);
                }
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        SettingsEditor2.prototype.updateElementsByKey = function (keys) {
            var _this = this;
            if (keys.length) {
                if (this.searchResultModel) {
                    keys.forEach(function (key) { return _this.searchResultModel.updateElementsByName(key); });
                }
                if (this.settingsTreeModel) {
                    keys.forEach(function (key) { return _this.settingsTreeModel.updateElementsByName(key); });
                }
                return winjs_base_1.TPromise.join(keys.map(function (key) { return _this.renderTree(key); }))
                    .then(function () { });
            }
            else {
                return this.renderTree();
            }
        };
        SettingsEditor2.prototype.getActiveElementInSettingsTree = function () {
            return (document.activeElement && DOM.isAncestor(document.activeElement, this.settingsTree.getHTMLElement())) ?
                document.activeElement :
                null;
        };
        SettingsEditor2.prototype.renderTree = function (key, force) {
            var _this = this;
            if (force === void 0) { force = false; }
            if (!force && key && this.scheduledRefreshes.has(key)) {
                this.updateModifiedLabelForKey(key);
                return winjs_base_1.TPromise.wrap(null);
            }
            // If a setting control is currently focused, schedule a refresh for later
            var focusedSetting = this.settingsTreeRenderer.getSettingDOMElementForDOMElement(this.getActiveElementInSettingsTree());
            if (focusedSetting && !force) {
                // If a single setting is being refreshed, it's ok to refresh now if that is not the focused setting
                if (key) {
                    var focusedKey = focusedSetting.getAttribute(settingsTree_1.SettingsRenderer.SETTING_KEY_ATTR);
                    if (focusedKey === key &&
                        !DOM.hasClass(focusedSetting, 'setting-item-exclude')) { // update `exclude`s live, as they have a separate "submit edit" step built in before this
                        this.updateModifiedLabelForKey(key);
                        this.scheduleRefresh(focusedSetting, key);
                        return winjs_base_1.TPromise.wrap(null);
                    }
                }
                else {
                    this.scheduleRefresh(focusedSetting);
                    return winjs_base_1.TPromise.wrap(null);
                }
            }
            var refreshP;
            if (key) {
                var elements = this.currentSettingsModel.getElementsByName(key);
                if (elements && elements.length) {
                    // TODO https://github.com/Microsoft/vscode/issues/57360
                    // refreshP = TPromise.join(elements.map(e => this.settingsTree.refresh(e)));
                    refreshP = this.settingsTree.refresh();
                }
                else {
                    // Refresh requested for a key that we don't know about
                    return winjs_base_1.TPromise.wrap(null);
                }
            }
            else {
                refreshP = this.settingsTree.refresh();
            }
            return refreshP.then(function () {
                _this.tocTreeModel.update();
                _this.renderResultCountMessages();
                // if (this.searchResultModel) {
                // 	expandAll(this.tocTree);
                // }
                return _this.tocTree.refresh();
            }).then(function () { });
        };
        SettingsEditor2.prototype.updateModifiedLabelForKey = function (key) {
            var dataElements = this.currentSettingsModel.getElementsByName(key);
            var isModified = dataElements && dataElements[0] && dataElements[0].isConfigured; // all elements are either configured or not
            var elements = this.settingsTreeRenderer.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), key);
            if (elements && elements[0]) {
                DOM.toggleClass(elements[0], 'is-configured', isModified);
            }
        };
        SettingsEditor2.prototype.onSearchInputChanged = function () {
            var _this = this;
            var query = this.searchWidget.getValue().trim();
            this.delayedFilterLogging.cancel();
            this.triggerSearch(query.replace(//g, ' ')).then(function () {
                if (query && _this.searchResultModel) {
                    _this.delayedFilterLogging.trigger(function () { return _this.reportFilteringUsed(query, _this.searchResultModel.getUniqueResults()); });
                }
            });
        };
        SettingsEditor2.prototype.parseSettingFromJSON = function (query) {
            var match = query.match(/"([a-zA-Z.]+)": /);
            return match && match[1];
        };
        SettingsEditor2.prototype.triggerSearch = function (query) {
            var _this = this;
            this.viewState.tagFilters = new Set();
            if (query) {
                var parsedQuery = settingsTreeModels_1.parseQuery(query);
                query = parsedQuery.query;
                parsedQuery.tags.forEach(function (tag) { return _this.viewState.tagFilters.add(tag); });
            }
            if (query && query !== '@') {
                query = this.parseSettingFromJSON(query) || query;
                return this.triggerFilterPreferences(query);
            }
            else {
                if (this.viewState.tagFilters && this.viewState.tagFilters.size) {
                    this.searchResultModel = this.createFilterModel();
                }
                else {
                    this.searchResultModel = null;
                }
                this.localSearchDelayer.cancel();
                this.remoteSearchThrottle.cancel();
                if (this.searchInProgress) {
                    this.searchInProgress.cancel();
                    this.searchInProgress.dispose();
                    this.searchInProgress = null;
                }
                this.viewState.filterToCategory = null;
                this.tocTreeModel.currentSearchModel = this.searchResultModel;
                this.tocTree.refresh();
                this.onSearchModeToggled();
                if (this.searchResultModel) {
                    // Added a filter model
                    this.tocTree.setSelection([]);
                    treeUtils_1.expandAll(this.tocTree);
                    return this.settingsTree.setInput(this.searchResultModel.root).then(function () {
                        _this.renderResultCountMessages();
                    });
                }
                else {
                    // Leaving search mode
                    treeUtils_1.collapseAll(this.tocTree);
                    return this.settingsTree.setInput(this.settingsTreeModel.root).then(function () { return _this.renderResultCountMessages(); });
                }
            }
        };
        /**
         * Return a fake SearchResultModel which can hold a flat list of all settings, to be filtered (@modified etc)
         */
        SettingsEditor2.prototype.createFilterModel = function () {
            var filterModel = this.instantiationService.createInstance(settingsTreeModels_1.SearchResultModel, this.viewState);
            var fullResult = {
                filterMatches: []
            };
            for (var _i = 0, _a = this.defaultSettingsEditorModel.settingsGroups.slice(1); _i < _a.length; _i++) {
                var g = _a[_i];
                for (var _b = 0, _c = g.sections; _b < _c.length; _b++) {
                    var sect = _c[_b];
                    for (var _d = 0, _e = sect.settings; _d < _e.length; _d++) {
                        var setting = _e[_d];
                        fullResult.filterMatches.push({ setting: setting, matches: [], score: 0 });
                    }
                }
            }
            filterModel.setResult(0, fullResult);
            return filterModel;
        };
        SettingsEditor2.prototype.reportFilteringUsed = function (query, results) {
            var nlpResult = results[1 /* Remote */];
            var nlpMetadata = nlpResult && nlpResult.metadata;
            var durations = {};
            durations['nlpResult'] = nlpMetadata && nlpMetadata.duration;
            // Count unique results
            var counts = {};
            var filterResult = results[0 /* Local */];
            if (filterResult) {
                counts['filterResult'] = filterResult.filterMatches.length;
            }
            if (nlpResult) {
                counts['nlpResult'] = nlpResult.filterMatches.length;
            }
            var requestCount = nlpMetadata && nlpMetadata.requestCount;
            var data = {
                query: query,
                durations: durations,
                counts: counts,
                requestCount: requestCount
            };
            /* __GDPR__
                "settingsEditor.filter" : {
                    "query": { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                    "durations.nlpResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "counts.nlpResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "counts.filterResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "requestCount" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                }
            */
            this.telemetryService.publicLog('settingsEditor.filter', data);
            var data2 = {
                durations: durations,
                counts: counts,
                requestCount: requestCount
            };
            /* __GDPR__
                "settingsEditor.filter<NUMBER>" : {
                    "durations.nlpResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "counts.nlpResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "counts.filterResult" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "requestCount" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                }
            */
            this.telemetryService.publicLog('settingsEditor.filter2', data2);
        };
        SettingsEditor2.prototype.triggerFilterPreferences = function (query) {
            var _this = this;
            if (this.searchInProgress) {
                this.searchInProgress.cancel();
                this.searchInProgress = null;
            }
            // Trigger the local search. If it didn't find an exact match, trigger the remote search.
            var searchInProgress = this.searchInProgress = new cancellation_1.CancellationTokenSource();
            return this.localSearchDelayer.trigger(function () {
                if (searchInProgress && !searchInProgress.token.isCancellationRequested) {
                    return _this.localFilterPreferences(query).then(function (result) {
                        if (!result.exactMatch) {
                            _this.remoteSearchThrottle.trigger(function () {
                                return searchInProgress && !searchInProgress.token.isCancellationRequested ?
                                    _this.remoteSearchPreferences(query, _this.searchInProgress.token) :
                                    winjs_base_1.TPromise.wrap(null);
                            });
                        }
                    });
                }
                else {
                    return winjs_base_1.TPromise.wrap(null);
                }
            });
        };
        SettingsEditor2.prototype.localFilterPreferences = function (query, token) {
            var localSearchProvider = this.preferencesSearchService.getLocalSearchProvider(query);
            return this.filterOrSearchPreferences(query, 0 /* Local */, localSearchProvider, token);
        };
        SettingsEditor2.prototype.remoteSearchPreferences = function (query, token) {
            var _this = this;
            var remoteSearchProvider = this.preferencesSearchService.getRemoteSearchProvider(query);
            var newExtSearchProvider = this.preferencesSearchService.getRemoteSearchProvider(query, true);
            return winjs_base_1.TPromise.join([
                this.filterOrSearchPreferences(query, 1 /* Remote */, remoteSearchProvider, token),
                this.filterOrSearchPreferences(query, 2 /* NewExtensions */, newExtSearchProvider, token)
            ]).then(function () {
                _this.renderResultCountMessages();
            });
        };
        SettingsEditor2.prototype.filterOrSearchPreferences = function (query, type, searchProvider, token) {
            var _this = this;
            return this._filterOrSearchPreferencesModel(query, this.defaultSettingsEditorModel, searchProvider, token).then(function (result) {
                if (token && token.isCancellationRequested) {
                    // Handle cancellation like this because cancellation is lost inside the search provider due to async/await
                    return null;
                }
                if (!_this.searchResultModel) {
                    _this.searchResultModel = _this.instantiationService.createInstance(settingsTreeModels_1.SearchResultModel, _this.viewState);
                    _this.searchResultModel.setResult(type, result);
                    _this.tocTreeModel.currentSearchModel = _this.searchResultModel;
                    _this.onSearchModeToggled();
                    _this.settingsTree.setInput(_this.searchResultModel.root);
                }
                else {
                    _this.searchResultModel.setResult(type, result);
                    _this.tocTreeModel.update();
                }
                _this.tocTree.setSelection([]);
                _this.viewState.filterToCategory = null;
                treeUtils_1.expandAll(_this.tocTree);
                return _this.renderTree().then(function () { return result; });
            });
        };
        SettingsEditor2.prototype.renderResultCountMessages = function () {
            if (!this.settingsTree.getInput()) {
                return;
            }
            if (this.tocTreeModel && this.tocTreeModel.settingsTreeRoot) {
                var count = this.tocTreeModel.settingsTreeRoot.count;
                switch (count) {
                    case 0:
                        this.countElement.innerText = nls_1.localize('noResults', "No Settings Found");
                        break;
                    case 1:
                        this.countElement.innerText = nls_1.localize('oneResult', "1 Setting Found");
                        break;
                    default: this.countElement.innerText = nls_1.localize('moreThanOneResult', "{0} Settings Found", count);
                }
                this.countElement.style.display = 'block';
                this.noResultsMessage.style.display = count === 0 ? 'block' : 'none';
            }
        };
        SettingsEditor2.prototype._filterOrSearchPreferencesModel = function (filter, model, provider, token) {
            var _this = this;
            var searchP = provider ? provider.searchModel(model, token) : winjs_base_1.TPromise.wrap(null);
            return searchP
                .then(null, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
                else {
                    /* __GDPR__
                        "settingsEditor.searchError" : {
                            "message": { "classification": "CallstackOrException", "purpose": "FeatureInsight" },
                            "filter": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                        }
                    */
                    var message = errors_1.getErrorMessage(err).trim();
                    if (message && message !== 'Error') {
                        // "Error" = any generic network error
                        _this.telemetryService.publicLog('settingsEditor.searchError', { message: message, filter: filter });
                        _this.logService.info('Setting search error: ' + message);
                    }
                    return null;
                }
            });
        };
        SettingsEditor2.prototype.layoutTrees = function (dimension) {
            var listHeight = dimension.height - (76 + 11 /* header height + padding*/);
            var settingsTreeHeight = listHeight - 14;
            this.settingsTreeContainer.style.height = settingsTreeHeight + "px";
            this.settingsTree.layout(settingsTreeHeight, 800);
            var tocTreeHeight = listHeight - 16;
            this.tocTreeContainer.style.height = tocTreeHeight + "px";
            this.tocTree.layout(tocTreeHeight, 175);
            this.settingsTreeRenderer.updateWidth(dimension.width);
        };
        SettingsEditor2.ID = 'workbench.editor.settings2';
        SettingsEditor2.NUM_INSTANCES = 0;
        SettingsEditor2.SETTING_UPDATE_FAST_DEBOUNCE = 200;
        SettingsEditor2.SETTING_UPDATE_SLOW_DEBOUNCE = 1000;
        SettingsEditor2.SUGGESTIONS = [
            '@modified', '@tag:usesOnlineServices'
        ];
        SettingsEditor2 = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, themeService_1.IThemeService),
            __param(3, preferences_2.IPreferencesService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, preferences_1.IPreferencesSearchService),
            __param(6, log_1.ILogService),
            __param(7, environment_1.IEnvironmentService),
            __param(8, contextkey_1.IContextKeyService),
            __param(9, contextView_1.IContextMenuService),
            __param(10, storage_1.IStorageService),
            __param(11, notification_1.INotificationService),
            __param(12, keybinding_1.IKeybindingService)
        ], SettingsEditor2);
        return SettingsEditor2;
    }(baseEditor_1.BaseEditor));
    exports.SettingsEditor2 = SettingsEditor2;
    var FilterByTagAction = /** @class */ (function (_super) {
        __extends(FilterByTagAction, _super);
        function FilterByTagAction(label, tag, settingsEditor) {
            var _this = _super.call(this, FilterByTagAction.ID, label, 'toggle-filter-tag') || this;
            _this.tag = tag;
            _this.settingsEditor = settingsEditor;
            return _this;
        }
        FilterByTagAction.prototype.run = function () {
            this.settingsEditor.focusSearch(this.tag === settingsTreeModels_1.MODIFIED_SETTING_TAG ? "@" + this.tag + " " : "@tag:" + this.tag + " ", false);
            return winjs_base_1.TPromise.as(null);
        };
        FilterByTagAction.ID = 'settings.filterByTag';
        return FilterByTagAction;
    }(actions_1.Action));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[385/*vs/workbench/parts/search/browser/replaceService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,25/*vs/base/common/errors*/,5/*vs/base/common/winjs.base*/,26/*vs/base/common/network*/,4/*vs/base/common/lifecycle*/,119/*vs/workbench/parts/search/common/replace*/,11/*vs/workbench/services/editor/common/editorService*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,106/*vs/workbench/parts/search/common/searchModel*/,66/*vs/editor/common/services/resolverService*/,3/*vs/platform/instantiation/common/instantiation*/,73/*vs/editor/common/model/textModel*/,27/*vs/workbench/services/textfile/common/textfiles*/,386/*vs/editor/browser/services/bulkEditService*/,48/*vs/editor/common/core/range*/,89/*vs/editor/common/core/editOperation*/,19/*vs/base/common/arrays*/]), function (require, exports, nls, errors, winjs_base_1, network, lifecycle_1, replace_1, editorService_1, modelService_1, modeService_1, searchModel_1, resolverService_1, instantiation_1, textModel_1, textfiles_1, bulkEditService_1, range_1, editOperation_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var REPLACE_PREVIEW = 'replacePreview';
    var toReplaceResource = function (fileResource) {
        return fileResource.with({ scheme: network.Schemas.internal, fragment: REPLACE_PREVIEW, query: JSON.stringify({ scheme: fileResource.scheme }) });
    };
    var toFileResource = function (replaceResource) {
        return replaceResource.with({ scheme: JSON.parse(replaceResource.query)['scheme'], fragment: '', query: '' });
    };
    var ReplacePreviewContentProvider = /** @class */ (function () {
        function ReplacePreviewContentProvider(instantiationService, textModelResolverService) {
            this.instantiationService = instantiationService;
            this.textModelResolverService = textModelResolverService;
            this.textModelResolverService.registerTextModelContentProvider(network.Schemas.internal, this);
        }
        ReplacePreviewContentProvider.prototype.provideTextContent = function (uri) {
            if (uri.fragment === REPLACE_PREVIEW) {
                return this.instantiationService.createInstance(ReplacePreviewModel).resolve(uri);
            }
            return null;
        };
        ReplacePreviewContentProvider = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, resolverService_1.ITextModelService)
        ], ReplacePreviewContentProvider);
        return ReplacePreviewContentProvider;
    }());
    exports.ReplacePreviewContentProvider = ReplacePreviewContentProvider;
    var ReplacePreviewModel = /** @class */ (function (_super) {
        __extends(ReplacePreviewModel, _super);
        function ReplacePreviewModel(modelService, modeService, textModelResolverService, replaceService, searchWorkbenchService) {
            var _this = _super.call(this) || this;
            _this.modelService = modelService;
            _this.modeService = modeService;
            _this.textModelResolverService = textModelResolverService;
            _this.replaceService = replaceService;
            _this.searchWorkbenchService = searchWorkbenchService;
            return _this;
        }
        ReplacePreviewModel.prototype.resolve = function (replacePreviewUri) {
            var _this = this;
            var fileResource = toFileResource(replacePreviewUri);
            var fileMatch = this.searchWorkbenchService.searchModel.searchResult.matches().filter(function (match) { return match.resource().toString() === fileResource.toString(); })[0];
            return this.textModelResolverService.createModelReference(fileResource).then(function (ref) {
                ref = _this._register(ref);
                var sourceModel = ref.object.textEditorModel;
                var sourceModelModeId = sourceModel.getLanguageIdentifier().language;
                var replacePreviewModel = _this.modelService.createModel(textModel_1.createTextBufferFactoryFromSnapshot(sourceModel.createSnapshot()), _this.modeService.getOrCreateMode(sourceModelModeId), replacePreviewUri);
                _this._register(fileMatch.onChange(function (modelChange) { return _this.update(sourceModel, replacePreviewModel, fileMatch, modelChange); }));
                _this._register(_this.searchWorkbenchService.searchModel.onReplaceTermChanged(function () { return _this.update(sourceModel, replacePreviewModel, fileMatch); }));
                _this._register(fileMatch.onDispose(function () { return replacePreviewModel.dispose(); })); // TODO@Sandeep we should not dispose a model directly but rather the reference (depends on https://github.com/Microsoft/vscode/issues/17073)
                _this._register(replacePreviewModel.onWillDispose(function () { return _this.dispose(); }));
                _this._register(sourceModel.onWillDispose(function () { return _this.dispose(); }));
                return replacePreviewModel;
            });
        };
        ReplacePreviewModel.prototype.update = function (sourceModel, replacePreviewModel, fileMatch, override) {
            if (override === void 0) { override = false; }
            if (!sourceModel.isDisposed() && !replacePreviewModel.isDisposed()) {
                this.replaceService.updateReplacePreview(fileMatch, override);
            }
        };
        ReplacePreviewModel = __decorate([
            __param(0, modelService_1.IModelService),
            __param(1, modeService_1.IModeService),
            __param(2, resolverService_1.ITextModelService),
            __param(3, replace_1.IReplaceService),
            __param(4, searchModel_1.ISearchWorkbenchService)
        ], ReplacePreviewModel);
        return ReplacePreviewModel;
    }(lifecycle_1.Disposable));
    var ReplaceService = /** @class */ (function () {
        function ReplaceService(textFileService, editorService, textModelResolverService, bulkEditorService) {
            this.textFileService = textFileService;
            this.editorService = editorService;
            this.textModelResolverService = textModelResolverService;
            this.bulkEditorService = bulkEditorService;
        }
        ReplaceService.prototype.replace = function (arg, progress, resource) {
            var _this = this;
            if (progress === void 0) { progress = null; }
            if (resource === void 0) { resource = null; }
            var edits = this.createEdits(arg, resource);
            return this.bulkEditorService.apply({ edits: edits }, { progress: progress }).then(function () { return _this.textFileService.saveAll(edits.map(function (e) { return e.resource; })); });
        };
        ReplaceService.prototype.openReplacePreview = function (element, preserveFocus, sideBySide, pinned) {
            var _this = this;
            var fileMatch = element instanceof searchModel_1.Match ? element.parent() : element;
            return this.editorService.openEditor({
                leftResource: fileMatch.resource(),
                rightResource: toReplaceResource(fileMatch.resource()),
                label: nls.localize('fileReplaceChanges', "{0}  {1} (Replace Preview)", fileMatch.name(), fileMatch.name()),
                options: {
                    preserveFocus: preserveFocus,
                    pinned: pinned,
                    revealIfVisible: true
                }
            }).then(function (editor) {
                var disposable = fileMatch.onDispose(function () {
                    if (editor && editor.input) {
                        editor.input.dispose();
                    }
                    disposable.dispose();
                });
                _this.updateReplacePreview(fileMatch).then(function () {
                    var editorControl = editor.getControl();
                    if (element instanceof searchModel_1.Match) {
                        editorControl.revealLineInCenter(element.range().startLineNumber, 1 /* Immediate */);
                    }
                });
            }, errors.onUnexpectedError);
        };
        ReplaceService.prototype.updateReplacePreview = function (fileMatch, override) {
            var _this = this;
            if (override === void 0) { override = false; }
            var replacePreviewUri = toReplaceResource(fileMatch.resource());
            return winjs_base_1.TPromise.join([this.textModelResolverService.createModelReference(fileMatch.resource()), this.textModelResolverService.createModelReference(replacePreviewUri)])
                .then(function (_a) {
                var sourceModelRef = _a[0], replaceModelRef = _a[1];
                var sourceModel = sourceModelRef.object.textEditorModel;
                var replaceModel = replaceModelRef.object.textEditorModel;
                var returnValue = winjs_base_1.TPromise.wrap(null);
                // If model is disposed do not update
                if (sourceModel && replaceModel) {
                    if (override) {
                        replaceModel.setValue(sourceModel.getValue());
                    }
                    else {
                        replaceModel.undo();
                    }
                    _this.applyEditsToPreview(fileMatch, replaceModel);
                }
                return returnValue.then(function () {
                    sourceModelRef.dispose();
                    replaceModelRef.dispose();
                });
            });
        };
        ReplaceService.prototype.applyEditsToPreview = function (fileMatch, replaceModel) {
            var resourceEdits = this.createEdits(fileMatch, replaceModel.uri);
            var modelEdits = [];
            for (var _i = 0, resourceEdits_1 = resourceEdits; _i < resourceEdits_1.length; _i++) {
                var resourceEdit = resourceEdits_1[_i];
                for (var _a = 0, _b = resourceEdit.edits; _a < _b.length; _a++) {
                    var edit = _b[_a];
                    var range = range_1.Range.lift(edit.range);
                    modelEdits.push(editOperation_1.EditOperation.replaceMove(range, edit.text));
                }
            }
            replaceModel.pushEditOperations([], arrays_1.mergeSort(modelEdits, function (a, b) { return range_1.Range.compareRangesUsingStarts(a.range, b.range); }), function () { return []; });
        };
        ReplaceService.prototype.createEdits = function (arg, resource) {
            var _this = this;
            if (resource === void 0) { resource = null; }
            var edits = [];
            if (arg instanceof searchModel_1.Match) {
                var match = arg;
                edits.push(this.createEdit(match, match.replaceString, resource));
            }
            if (arg instanceof searchModel_1.FileMatch) {
                arg = [arg];
            }
            if (arg instanceof Array) {
                arg.forEach(function (element) {
                    var fileMatch = element;
                    if (fileMatch.count() > 0) {
                        edits.push.apply(edits, fileMatch.matches().map(function (match) { return _this.createEdit(match, match.replaceString, resource); }));
                    }
                });
            }
            return edits;
        };
        ReplaceService.prototype.createEdit = function (match, text, resource) {
            if (resource === void 0) { resource = null; }
            var fileMatch = match.parent();
            var resourceEdit = {
                resource: resource !== null ? resource : fileMatch.resource(),
                edits: [{
                        range: match.range(),
                        text: text
                    }]
            };
            return resourceEdit;
        };
        ReplaceService = __decorate([
            __param(0, textfiles_1.ITextFileService),
            __param(1, editorService_1.IEditorService),
            __param(2, resolverService_1.ITextModelService),
            __param(3, bulkEditService_1.IBulkEditService)
        ], ReplaceService);
        return ReplaceService;
    }());
    exports.ReplaceService = ReplaceService;
});

define(__m[387/*vs/workbench/parts/search/browser/replaceContributions*/], __M([0/*require*/,1/*exports*/,80/*vs/platform/instantiation/common/extensions*/,119/*vs/workbench/parts/search/common/replace*/,385/*vs/workbench/parts/search/browser/replaceService*/,9/*vs/platform/registry/common/platform*/,107/*vs/workbench/common/contributions*/]), function (require, exports, extensions_1, replace_1, replaceService_1, platform_1, contributions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function registerContributions() {
        extensions_1.registerSingleton(replace_1.IReplaceService, replaceService_1.ReplaceService);
        platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(replaceService_1.ReplacePreviewContentProvider, 1 /* Starting */);
    }
    exports.registerContributions = registerContributions;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[388/*vs/workbench/services/configuration/node/jsonEditingService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,77/*vs/base/common/json*/,440/*vs/base/node/encoding*/,22/*vs/base/common/strings*/,234/*vs/base/common/jsonEdit*/,17/*vs/base/common/async*/,89/*vs/editor/common/core/editOperation*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,66/*vs/editor/common/services/resolverService*/,154/*vs/workbench/services/configuration/common/jsonEditing*/]), function (require, exports, nls, winjs_base_1, json, encoding, strings, jsonEdit_1, async_1, editOperation_1, range_1, selection_1, textfiles_1, files_1, resolverService_1, jsonEditing_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var JSONEditingService = /** @class */ (function () {
        function JSONEditingService(fileService, textModelResolverService, textFileService) {
            this.fileService = fileService;
            this.textModelResolverService = textModelResolverService;
            this.textFileService = textFileService;
            this.queue = new async_1.Queue();
        }
        JSONEditingService.prototype.write = function (resource, value, save) {
            var _this = this;
            return this.queue.queue(function () { return _this.doWriteConfiguration(resource, value, save); }); // queue up writes to prevent race conditions
        };
        JSONEditingService.prototype.doWriteConfiguration = function (resource, value, save) {
            var _this = this;
            return this.resolveAndValidate(resource, save)
                .then(function (reference) { return _this.writeToBuffer(reference.object.textEditorModel, value)
                .then(function () { return reference.dispose(); }); });
        };
        JSONEditingService.prototype.writeToBuffer = function (model, value) {
            var edit = this.getEdits(model, value)[0];
            if (this.applyEditsToBuffer(edit, model)) {
                return this.textFileService.save(model.uri);
            }
            return winjs_base_1.TPromise.as(null);
        };
        JSONEditingService.prototype.applyEditsToBuffer = function (edit, model) {
            var startPosition = model.getPositionAt(edit.offset);
            var endPosition = model.getPositionAt(edit.offset + edit.length);
            var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
            var currentText = model.getValueInRange(range);
            if (edit.content !== currentText) {
                var editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
                model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], function () { return []; });
                return true;
            }
            return false;
        };
        JSONEditingService.prototype.getEdits = function (model, configurationValue) {
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var eol = model.getEOL();
            var key = configurationValue.key, value = configurationValue.value;
            // Without key, the entire settings file is being replaced, so we just use JSON.stringify
            if (!key) {
                var content = JSON.stringify(value, null, insertSpaces ? strings.repeat(' ', tabSize) : '\t');
                return [{
                        content: content,
                        length: content.length,
                        offset: 0
                    }];
            }
            return jsonEdit_1.setProperty(model.getValue(), [key], value, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol });
        };
        JSONEditingService.prototype.resolveModelReference = function (resource) {
            var _this = this;
            return this.fileService.existsFile(resource)
                .then(function (exists) {
                var result = exists ? winjs_base_1.TPromise.as(null) : _this.fileService.updateContent(resource, '{}', { encoding: encoding.UTF8 });
                return result.then(function () { return _this.textModelResolverService.createModelReference(resource); });
            });
        };
        JSONEditingService.prototype.hasParseErrors = function (model) {
            var parseErrors = [];
            json.parse(model.getValue(), parseErrors);
            return parseErrors.length > 0;
        };
        JSONEditingService.prototype.resolveAndValidate = function (resource, checkDirty) {
            var _this = this;
            return this.resolveModelReference(resource)
                .then(function (reference) {
                var model = reference.object.textEditorModel;
                if (_this.hasParseErrors(model)) {
                    return _this.wrapError(1 /* ERROR_INVALID_FILE */);
                }
                // Target cannot be dirty if not writing into buffer
                if (checkDirty && _this.textFileService.isDirty(resource)) {
                    return _this.wrapError(0 /* ERROR_FILE_DIRTY */);
                }
                return reference;
            });
        };
        JSONEditingService.prototype.wrapError = function (code) {
            var message = this.toErrorMessage(code);
            return winjs_base_1.TPromise.wrapError(new jsonEditing_1.JSONEditingError(message, code));
        };
        JSONEditingService.prototype.toErrorMessage = function (error) {
            switch (error) {
                // User issues
                case 1 /* ERROR_INVALID_FILE */: {
                    return nls.localize('errorInvalidFile', "Unable to write into the file. Please open the file to correct errors/warnings in the file and try again.");
                }
                case 0 /* ERROR_FILE_DIRTY */: {
                    return nls.localize('errorFileDirty', "Unable to write into the file because the file is dirty. Please save the file and try again.");
                }
            }
        };
        JSONEditingService = __decorate([
            __param(0, files_1.IFileService),
            __param(1, resolverService_1.ITextModelService),
            __param(2, textfiles_1.ITextFileService)
        ], JSONEditingService);
        return JSONEditingService;
    }());
    exports.JSONEditingService = JSONEditingService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[218/*vs/workbench/services/keybinding/common/keybindingEditing*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,12/*vs/base/common/uri*/,5/*vs/base/common/winjs.base*/,29/*vs/base/common/types*/,17/*vs/base/common/async*/,4/*vs/base/common/lifecycle*/,77/*vs/base/common/json*/,234/*vs/base/common/jsonEdit*/,10/*vs/platform/contextkey/common/contextkey*/,7/*vs/platform/configuration/common/configuration*/,89/*vs/editor/common/core/editOperation*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,43/*vs/platform/environment/common/environment*/,66/*vs/editor/common/services/resolverService*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, nls_1, uri_1, winjs_base_1, types_1, async_1, lifecycle_1, json, jsonEdit_1, contextkey_1, configuration_1, editOperation_1, range_1, selection_1, environment_1, resolverService_1, textfiles_1, files_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IKeybindingEditingService = instantiation_1.createDecorator('keybindingEditingService');
    var KeybindingsEditingService = /** @class */ (function (_super) {
        __extends(KeybindingsEditingService, _super);
        function KeybindingsEditingService(textModelResolverService, textFileService, fileService, configurationService, environmentService) {
            var _this = _super.call(this) || this;
            _this.textModelResolverService = textModelResolverService;
            _this.textFileService = textFileService;
            _this.fileService = fileService;
            _this.configurationService = configurationService;
            _this.environmentService = environmentService;
            _this.resource = uri_1.URI.file(_this.environmentService.appKeybindingsPath);
            _this.queue = new async_1.Queue();
            return _this;
        }
        KeybindingsEditingService.prototype.editKeybinding = function (key, keybindingItem) {
            var _this = this;
            return this.queue.queue(function () { return _this.doEditKeybinding(key, keybindingItem); }); // queue up writes to prevent race conditions
        };
        KeybindingsEditingService.prototype.resetKeybinding = function (keybindingItem) {
            var _this = this;
            return this.queue.queue(function () { return _this.doResetKeybinding(keybindingItem); }); // queue up writes to prevent race conditions
        };
        KeybindingsEditingService.prototype.removeKeybinding = function (keybindingItem) {
            var _this = this;
            return this.queue.queue(function () { return _this.doRemoveKeybinding(keybindingItem); }); // queue up writes to prevent race conditions
        };
        KeybindingsEditingService.prototype.doEditKeybinding = function (key, keybindingItem) {
            var _this = this;
            return this.resolveAndValidate()
                .then(function (reference) {
                var model = reference.object.textEditorModel;
                var userKeybindingEntries = json.parse(model.getValue());
                var userKeybindingEntryIndex = _this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
                _this.updateKeybinding(key, keybindingItem, model, userKeybindingEntryIndex);
                if (keybindingItem.isDefault && keybindingItem.resolvedKeybinding) {
                    _this.removeDefaultKeybinding(keybindingItem, model);
                }
                return _this.save().then(function () { return reference.dispose(); });
            });
        };
        KeybindingsEditingService.prototype.doRemoveKeybinding = function (keybindingItem) {
            var _this = this;
            return this.resolveAndValidate()
                .then(function (reference) {
                var model = reference.object.textEditorModel;
                if (keybindingItem.isDefault) {
                    _this.removeDefaultKeybinding(keybindingItem, model);
                }
                else {
                    _this.removeUserKeybinding(keybindingItem, model);
                }
                return _this.save().then(function () { return reference.dispose(); });
            });
        };
        KeybindingsEditingService.prototype.doResetKeybinding = function (keybindingItem) {
            var _this = this;
            return this.resolveAndValidate()
                .then(function (reference) {
                var model = reference.object.textEditorModel;
                if (!keybindingItem.isDefault) {
                    _this.removeUserKeybinding(keybindingItem, model);
                    _this.removeUnassignedDefaultKeybinding(keybindingItem, model);
                }
                return _this.save().then(function () { return reference.dispose(); });
            });
        };
        KeybindingsEditingService.prototype.save = function () {
            return this.textFileService.save(this.resource);
        };
        KeybindingsEditingService.prototype.updateKeybinding = function (newKey, keybindingItem, model, userKeybindingEntryIndex) {
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var eol = model.getEOL();
            if (userKeybindingEntryIndex !== -1) {
                // Update the keybinding with new key
                this.applyEditsToBuffer(jsonEdit_1.setProperty(model.getValue(), [userKeybindingEntryIndex, 'key'], newKey, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol })[0], model);
            }
            else {
                // Add the new keybinding with new key
                this.applyEditsToBuffer(jsonEdit_1.setProperty(model.getValue(), [-1], this.asObject(newKey, keybindingItem.command, keybindingItem.when, false), { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol })[0], model);
            }
        };
        KeybindingsEditingService.prototype.removeUserKeybinding = function (keybindingItem, model) {
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var eol = model.getEOL();
            var userKeybindingEntries = json.parse(model.getValue());
            var userKeybindingEntryIndex = this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
            if (userKeybindingEntryIndex !== -1) {
                this.applyEditsToBuffer(jsonEdit_1.setProperty(model.getValue(), [userKeybindingEntryIndex], void 0, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol })[0], model);
            }
        };
        KeybindingsEditingService.prototype.removeDefaultKeybinding = function (keybindingItem, model) {
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var eol = model.getEOL();
            this.applyEditsToBuffer(jsonEdit_1.setProperty(model.getValue(), [-1], this.asObject(keybindingItem.resolvedKeybinding.getUserSettingsLabel(), keybindingItem.command, keybindingItem.when, true), { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol })[0], model);
        };
        KeybindingsEditingService.prototype.removeUnassignedDefaultKeybinding = function (keybindingItem, model) {
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var eol = model.getEOL();
            var userKeybindingEntries = json.parse(model.getValue());
            var indices = this.findUnassignedDefaultKeybindingEntryIndex(keybindingItem, userKeybindingEntries).reverse();
            for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                var index = indices_1[_i];
                this.applyEditsToBuffer(jsonEdit_1.setProperty(model.getValue(), [index], void 0, { tabSize: tabSize, insertSpaces: insertSpaces, eol: eol })[0], model);
            }
        };
        KeybindingsEditingService.prototype.findUserKeybindingEntryIndex = function (keybindingItem, userKeybindingEntries) {
            for (var index = 0; index < userKeybindingEntries.length; index++) {
                var keybinding = userKeybindingEntries[index];
                if (keybinding.command === keybindingItem.command) {
                    if (!keybinding.when && !keybindingItem.when) {
                        return index;
                    }
                    if (keybinding.when && keybindingItem.when) {
                        if (contextkey_1.ContextKeyExpr.deserialize(keybinding.when).serialize() === keybindingItem.when.serialize()) {
                            return index;
                        }
                    }
                }
            }
            return -1;
        };
        KeybindingsEditingService.prototype.findUnassignedDefaultKeybindingEntryIndex = function (keybindingItem, userKeybindingEntries) {
            var indices = [];
            for (var index = 0; index < userKeybindingEntries.length; index++) {
                if (userKeybindingEntries[index].command === "-" + keybindingItem.command) {
                    indices.push(index);
                }
            }
            return indices;
        };
        KeybindingsEditingService.prototype.asObject = function (key, command, when, negate) {
            var object = { key: key };
            object['command'] = negate ? "-" + command : command;
            if (when) {
                object['when'] = when.serialize();
            }
            return object;
        };
        KeybindingsEditingService.prototype.applyEditsToBuffer = function (edit, model) {
            var startPosition = model.getPositionAt(edit.offset);
            var endPosition = model.getPositionAt(edit.offset + edit.length);
            var range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
            var currentText = model.getValueInRange(range);
            var editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
            model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], function () { return []; });
        };
        KeybindingsEditingService.prototype.resolveModelReference = function () {
            var _this = this;
            return this.fileService.existsFile(this.resource)
                .then(function (exists) {
                var EOL = _this.configurationService.getValue('files', { overrideIdentifier: 'json' })['eol'];
                var result = exists ? winjs_base_1.TPromise.as(null) : _this.fileService.updateContent(_this.resource, _this.getEmptyContent(EOL), { encoding: 'utf8' });
                return result.then(function () { return _this.textModelResolverService.createModelReference(_this.resource); });
            });
        };
        KeybindingsEditingService.prototype.resolveAndValidate = function () {
            var _this = this;
            // Target cannot be dirty if not writing into buffer
            if (this.textFileService.isDirty(this.resource)) {
                return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('errorKeybindingsFileDirty', "Unable to write because the keybindings configuration file is dirty. Please save it first and then try again.")));
            }
            return this.resolveModelReference()
                .then(function (reference) {
                var model = reference.object.textEditorModel;
                var EOL = model.getEOL();
                if (model.getValue()) {
                    var parsed = _this.parse(model);
                    if (parsed.parseErrors.length) {
                        return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('parseErrors', "Unable to write to the keybindings configuration file. Please open it to correct errors/warnings in the file and try again.")));
                    }
                    if (parsed.result) {
                        if (!types_1.isArray(parsed.result)) {
                            return winjs_base_1.TPromise.wrapError(new Error(nls_1.localize('errorInvalidConfiguration', "Unable to write to the keybindings configuration file. It has an object which is not of type Array. Please open the file to clean up and try again.")));
                        }
                    }
                    else {
                        var content = EOL + '[]';
                        _this.applyEditsToBuffer({ content: content, length: content.length, offset: model.getValue().length }, model);
                    }
                }
                else {
                    var content = _this.getEmptyContent(EOL);
                    _this.applyEditsToBuffer({ content: content, length: content.length, offset: 0 }, model);
                }
                return reference;
            });
        };
        KeybindingsEditingService.prototype.parse = function (model) {
            var parseErrors = [];
            var result = json.parse(model.getValue(), parseErrors);
            return { result: result, parseErrors: parseErrors };
        };
        KeybindingsEditingService.prototype.getEmptyContent = function (EOL) {
            return '// ' + nls_1.localize('emptyKeybindingsHeader', "Place your key bindings in this file to overwrite the defaults") + EOL + '[]';
        };
        KeybindingsEditingService = __decorate([
            __param(0, resolverService_1.ITextModelService),
            __param(1, textfiles_1.ITextFileService),
            __param(2, files_1.IFileService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, environment_1.IEnvironmentService)
        ], KeybindingsEditingService);
        return KeybindingsEditingService;
    }(lifecycle_1.Disposable));
    exports.KeybindingsEditingService = KeybindingsEditingService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[391/*vs/workbench/parts/preferences/browser/keybindingsEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,17/*vs/base/common/async*/,8/*vs/base/browser/dom*/,18/*vs/base/common/platform*/,4/*vs/base/common/lifecycle*/,225/*vs/base/browser/ui/checkbox/checkbox*/,208/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,236/*vs/base/browser/ui/keybindingLabel/keybindingLabel*/,15/*vs/base/common/actions*/,50/*vs/base/browser/ui/actionbar/actionbar*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,32/*vs/platform/telemetry/common/telemetry*/,79/*vs/platform/clipboard/common/clipboardService*/,199/*vs/workbench/services/preferences/common/keybindingsEditorModel*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,169/*vs/workbench/parts/preferences/browser/keybindingWidgets*/,109/*vs/workbench/parts/preferences/common/preferences*/,34/*vs/platform/contextview/browser/contextView*/,218/*vs/workbench/services/keybinding/common/keybindingEditing*/,14/*vs/platform/theme/common/themeService*/,10/*vs/platform/contextkey/common/contextkey*/,68/*vs/base/browser/keyboardEvent*/,30/*vs/platform/theme/common/colorRegistry*/,11/*vs/workbench/services/editor/common/editorService*/,56/*vs/editor/browser/editorExtensions*/,51/*vs/platform/list/browser/listService*/,28/*vs/platform/notification/common/notification*/,55/*vs/base/common/cancellation*/,40/*vs/platform/theme/common/styler*/,262/*vs/css!vs/workbench/parts/preferences/browser/media/keybindingsEditor*/]), function (require, exports, nls_1, winjs_base_1, async_1, DOM, platform_1, lifecycle_1, checkbox_1, highlightedLabel_1, keybindingLabel_1, actions_1, actionbar_1, baseEditor_1, telemetry_1, clipboardService_1, keybindingsEditorModel_1, instantiation_1, keybinding_1, keybindingWidgets_1, preferences_1, contextView_1, keybindingEditing_1, themeService_1, contextkey_1, keyboardEvent_1, colorRegistry_1, editorService_1, editorExtensions_1, listService_1, notification_1, cancellation_1, styler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = DOM.$;
    var KeybindingsEditor = /** @class */ (function (_super) {
        __extends(KeybindingsEditor, _super);
        function KeybindingsEditor(telemetryService, themeService, keybindingsService, contextMenuService, keybindingEditingService, contextKeyService, notificationService, clipboardService, instantiationService, editorService) {
            var _this = _super.call(this, KeybindingsEditor.ID, telemetryService, themeService) || this;
            _this.keybindingsService = keybindingsService;
            _this.contextMenuService = contextMenuService;
            _this.keybindingEditingService = keybindingEditingService;
            _this.contextKeyService = contextKeyService;
            _this.notificationService = notificationService;
            _this.clipboardService = clipboardService;
            _this.instantiationService = instantiationService;
            _this.editorService = editorService;
            _this.latestEmptyFilters = [];
            _this.delayedFiltering = new async_1.Delayer(300);
            _this._register(keybindingsService.onDidUpdateKeybindings(function () { return _this.render(false, cancellation_1.CancellationToken.None); }));
            _this.keybindingsEditorContextKey = preferences_1.CONTEXT_KEYBINDINGS_EDITOR.bindTo(_this.contextKeyService);
            _this.searchFocusContextKey = preferences_1.CONTEXT_KEYBINDINGS_SEARCH_FOCUS.bindTo(_this.contextKeyService);
            _this.searchValueContextKey = preferences_1.CONTEXT_KEYBINDINGS_SEARCH_VALUE.bindTo(_this.contextKeyService);
            _this.keybindingFocusContextKey = preferences_1.CONTEXT_KEYBINDING_FOCUS.bindTo(_this.contextKeyService);
            _this.delayedFilterLogging = new async_1.Delayer(1000);
            return _this;
        }
        KeybindingsEditor.prototype.createEditor = function (parent) {
            var _this = this;
            var keybindingsEditorElement = DOM.append(parent, $('div', { class: 'keybindings-editor' }));
            this.createAriaLabelElement(keybindingsEditorElement);
            this.createOverlayContainer(keybindingsEditorElement);
            this.createHeader(keybindingsEditorElement);
            this.createBody(keybindingsEditorElement);
            var focusTracker = this._register(DOM.trackFocus(parent));
            this._register(focusTracker.onDidFocus(function () { return _this.keybindingsEditorContextKey.set(true); }));
            this._register(focusTracker.onDidBlur(function () { return _this.keybindingsEditorContextKey.reset(); }));
        };
        KeybindingsEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            return _super.prototype.setInput.call(this, input, options, token)
                .then(function () { return _this.render(options && options.preserveFocus, token); });
        };
        KeybindingsEditor.prototype.clearInput = function () {
            _super.prototype.clearInput.call(this);
            this.keybindingsEditorContextKey.reset();
            this.keybindingFocusContextKey.reset();
        };
        KeybindingsEditor.prototype.layout = function (dimension) {
            this.dimension = dimension;
            this.layoutSearchWidget(dimension);
            this.overlayContainer.style.width = dimension.width + 'px';
            this.overlayContainer.style.height = dimension.height + 'px';
            this.defineKeybindingWidget.layout(this.dimension);
            this.layoutKebindingsList();
        };
        KeybindingsEditor.prototype.focus = function () {
            var activeKeybindingEntry = this.activeKeybindingEntry;
            if (activeKeybindingEntry) {
                this.selectEntry(activeKeybindingEntry);
            }
            else {
                this.searchWidget.focus();
            }
        };
        Object.defineProperty(KeybindingsEditor.prototype, "activeKeybindingEntry", {
            get: function () {
                var focusedElement = this.keybindingsList.getFocusedElements()[0];
                return focusedElement && focusedElement.templateId === keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID ? focusedElement : null;
            },
            enumerable: true,
            configurable: true
        });
        KeybindingsEditor.prototype.defineKeybinding = function (keybindingEntry) {
            var _this = this;
            this.selectEntry(keybindingEntry);
            this.showOverlayContainer();
            return this.defineKeybindingWidget.define().then(function (key) {
                if (key) {
                    var currentKey = keybindingEntry.keybindingItem.keybinding ? keybindingEntry.keybindingItem.keybinding.getUserSettingsLabel() : '';
                    if (currentKey !== key) {
                        _this.reportKeybindingAction(preferences_1.KEYBINDINGS_EDITOR_COMMAND_DEFINE, keybindingEntry.keybindingItem.command, key);
                        return _this.keybindingEditingService.editKeybinding(key, keybindingEntry.keybindingItem.keybindingItem)
                            .then(function () {
                            if (!keybindingEntry.keybindingItem.keybinding) { // reveal only if keybinding was added to unassinged. Because the entry will be placed in different position after rendering
                                _this.unAssignedKeybindingItemToRevealAndFocus = keybindingEntry;
                            }
                        });
                    }
                }
                return null;
            }).then(function () {
                _this.hideOverlayContainer();
                _this.selectEntry(keybindingEntry);
            }, function (error) {
                _this.hideOverlayContainer();
                _this.onKeybindingEditingError(error);
                _this.selectEntry(keybindingEntry);
                return error;
            });
        };
        KeybindingsEditor.prototype.removeKeybinding = function (keybindingEntry) {
            var _this = this;
            this.selectEntry(keybindingEntry);
            if (keybindingEntry.keybindingItem.keybinding) { // This should be a pre-condition
                this.reportKeybindingAction(preferences_1.KEYBINDINGS_EDITOR_COMMAND_REMOVE, keybindingEntry.keybindingItem.command, keybindingEntry.keybindingItem.keybinding);
                return this.keybindingEditingService.removeKeybinding(keybindingEntry.keybindingItem.keybindingItem)
                    .then(function () { return _this.focus(); }, function (error) {
                    _this.onKeybindingEditingError(error);
                    _this.selectEntry(keybindingEntry);
                });
            }
            return winjs_base_1.TPromise.as(null);
        };
        KeybindingsEditor.prototype.resetKeybinding = function (keybindingEntry) {
            var _this = this;
            this.selectEntry(keybindingEntry);
            this.reportKeybindingAction(preferences_1.KEYBINDINGS_EDITOR_COMMAND_RESET, keybindingEntry.keybindingItem.command, keybindingEntry.keybindingItem.keybinding);
            return this.keybindingEditingService.resetKeybinding(keybindingEntry.keybindingItem.keybindingItem)
                .then(function () {
                if (!keybindingEntry.keybindingItem.keybinding) { // reveal only if keybinding was added to unassinged. Because the entry will be placed in different position after rendering
                    _this.unAssignedKeybindingItemToRevealAndFocus = keybindingEntry;
                }
                _this.selectEntry(keybindingEntry);
            }, function (error) {
                _this.onKeybindingEditingError(error);
                _this.selectEntry(keybindingEntry);
            });
        };
        KeybindingsEditor.prototype.copyKeybinding = function (keybinding) {
            this.selectEntry(keybinding);
            this.reportKeybindingAction(preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY, keybinding.keybindingItem.command, keybinding.keybindingItem.keybinding);
            var userFriendlyKeybinding = {
                key: keybinding.keybindingItem.keybinding ? keybinding.keybindingItem.keybinding.getUserSettingsLabel() : '',
                command: keybinding.keybindingItem.command
            };
            if (keybinding.keybindingItem.when) {
                userFriendlyKeybinding.when = keybinding.keybindingItem.when;
            }
            this.clipboardService.writeText(JSON.stringify(userFriendlyKeybinding, null, '  '));
            return winjs_base_1.TPromise.as(null);
        };
        KeybindingsEditor.prototype.copyKeybindingCommand = function (keybinding) {
            this.selectEntry(keybinding);
            this.reportKeybindingAction(preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY_COMMAND, keybinding.keybindingItem.command, keybinding.keybindingItem.keybinding);
            this.clipboardService.writeText(keybinding.keybindingItem.command);
            return winjs_base_1.TPromise.as(null);
        };
        KeybindingsEditor.prototype.focusSearch = function () {
            this.searchWidget.focus();
        };
        KeybindingsEditor.prototype.search = function (filter) {
            this.focusSearch();
            this.searchWidget.setValue(filter);
        };
        KeybindingsEditor.prototype.clearSearchResults = function () {
            this.searchWidget.clear();
        };
        KeybindingsEditor.prototype.showSimilarKeybindings = function (keybindingEntry) {
            var value = "\"" + keybindingEntry.keybindingItem.keybinding.getAriaLabel() + "\"";
            if (value !== this.searchWidget.getValue()) {
                this.searchWidget.setValue(value);
            }
            return winjs_base_1.TPromise.as(null);
        };
        KeybindingsEditor.prototype.createAriaLabelElement = function (parent) {
            this.ariaLabelElement = DOM.append(parent, DOM.$(''));
            this.ariaLabelElement.setAttribute('id', 'keybindings-editor-aria-label-element');
            this.ariaLabelElement.setAttribute('aria-live', 'assertive');
        };
        KeybindingsEditor.prototype.createOverlayContainer = function (parent) {
            var _this = this;
            this.overlayContainer = DOM.append(parent, $('.overlay-container'));
            this.overlayContainer.style.position = 'absolute';
            this.overlayContainer.style.zIndex = '10';
            this.defineKeybindingWidget = this._register(this.instantiationService.createInstance(keybindingWidgets_1.DefineKeybindingWidget, this.overlayContainer));
            this._register(this.defineKeybindingWidget.onDidChange(function (keybindingStr) { return _this.defineKeybindingWidget.printExisting(_this.keybindingsEditorModel.fetch("\"" + keybindingStr + "\"").length); }));
            this._register(this.defineKeybindingWidget.onShowExistingKeybidings(function (keybindingStr) { return _this.searchWidget.setValue("\"" + keybindingStr + "\""); }));
            this.hideOverlayContainer();
        };
        KeybindingsEditor.prototype.showOverlayContainer = function () {
            this.overlayContainer.style.display = 'block';
        };
        KeybindingsEditor.prototype.hideOverlayContainer = function () {
            this.overlayContainer.style.display = 'none';
        };
        KeybindingsEditor.prototype.createHeader = function (parent) {
            var _this = this;
            this.headerContainer = DOM.append(parent, $('.keybindings-header'));
            var fullTextSearchPlaceholder = nls_1.localize('SearchKeybindings.FullTextSearchPlaceholder', "Type to search in keybindings");
            var keybindingsSearchPlaceholder = nls_1.localize('SearchKeybindings.KeybindingsSearchPlaceholder', "Recording Keys. Press Escape to exit");
            var searchContainer = DOM.append(this.headerContainer, $('.search-container'));
            this.searchWidget = this._register(this.instantiationService.createInstance(keybindingWidgets_1.KeybindingsSearchWidget, searchContainer, {
                ariaLabel: fullTextSearchPlaceholder,
                placeholder: fullTextSearchPlaceholder,
                focusKey: this.searchFocusContextKey,
                ariaLabelledBy: 'keybindings-editor-aria-label-element',
                recordEnter: true
            }));
            this._register(this.searchWidget.onDidChange(function (searchValue) {
                _this.searchValueContextKey.set(!!searchValue);
                _this.delayedFiltering.trigger(function () { return _this.filterKeybindings(); });
            }));
            this._register(this.searchWidget.onEscape(function () { return _this.recordKeysAction.checked = false; }));
            var actionsContainer = DOM.append(searchContainer, DOM.$('.keybindings-search-actions-container'));
            var recordingBadge = this.createRecordingBadge(actionsContainer);
            var sortByPrecedenceActionKeybinding = this.keybindingsService.lookupKeybinding(preferences_1.KEYBINDINGS_EDITOR_COMMAND_SORTBY_PRECEDENCE);
            var sortByPrecedenceActionLabel = nls_1.localize('sortByPrecedeneLabel', "Sort by Precedence");
            this.sortByPrecedenceAction = new actions_1.Action('keybindings.editor.sortByPrecedence', sortByPrecedenceActionKeybinding ? nls_1.localize('sortByPrecedeneLabelWithKeybinding', "{0} ({1})", sortByPrecedenceActionLabel, sortByPrecedenceActionKeybinding.getLabel()) : sortByPrecedenceActionLabel, 'sort-by-precedence');
            this.sortByPrecedenceAction.checked = false;
            this._register(this.sortByPrecedenceAction.onDidChange(function (e) {
                if (e.checked !== void 0) {
                    _this.renderKeybindingsEntries(false);
                }
            }));
            var recordKeysActionKeybinding = this.keybindingsService.lookupKeybinding(preferences_1.KEYBINDINGS_EDITOR_COMMAND_RECORD_SEARCH_KEYS);
            var recordKeysActionLabel = nls_1.localize('recordKeysLabel', "Record Keys");
            this.recordKeysAction = new actions_1.Action(preferences_1.KEYBINDINGS_EDITOR_COMMAND_RECORD_SEARCH_KEYS, recordKeysActionKeybinding ? nls_1.localize('recordKeysLabelWithKeybinding', "{0} ({1})", recordKeysActionLabel, recordKeysActionKeybinding.getLabel()) : recordKeysActionLabel, 'octicon octicon-keyboard');
            this.recordKeysAction.checked = false;
            this._register(this.recordKeysAction.onDidChange(function (e) {
                if (e.checked !== void 0) {
                    DOM.toggleClass(recordingBadge, 'disabled', !e.checked);
                    if (e.checked) {
                        _this.searchWidget.inputBox.setPlaceHolder(keybindingsSearchPlaceholder);
                        _this.searchWidget.inputBox.setAriaLabel(keybindingsSearchPlaceholder);
                        _this.searchWidget.startRecordingKeys();
                        _this.searchWidget.focus();
                    }
                    else {
                        _this.searchWidget.inputBox.setPlaceHolder(fullTextSearchPlaceholder);
                        _this.searchWidget.inputBox.setAriaLabel(fullTextSearchPlaceholder);
                        _this.searchWidget.stopRecordingKeys();
                        _this.searchWidget.focus();
                    }
                }
            }));
            this.actionBar = this._register(new actionbar_1.ActionBar(actionsContainer, {
                animated: false,
                actionItemProvider: function (action) {
                    if (action.id === _this.sortByPrecedenceAction.id) {
                        return new checkbox_1.CheckboxActionItem(null, action);
                    }
                    if (action.id === _this.recordKeysAction.id) {
                        return new checkbox_1.CheckboxActionItem(null, action);
                    }
                    return null;
                }
            }));
            this.actionBar.push([this.recordKeysAction, this.sortByPrecedenceAction]);
        };
        KeybindingsEditor.prototype.createRecordingBadge = function (container) {
            var recordingBadge = DOM.append(container, DOM.$('.recording-badge.disabled'));
            recordingBadge.textContent = nls_1.localize('recording', "Recording Keys");
            this._register(styler_1.attachStylerCallback(this.themeService, { badgeBackground: colorRegistry_1.badgeBackground, contrastBorder: colorRegistry_1.contrastBorder, badgeForeground: colorRegistry_1.badgeForeground }, function (colors) {
                var background = colors.badgeBackground ? colors.badgeBackground.toString() : null;
                var border = colors.contrastBorder ? colors.contrastBorder.toString() : null;
                var color = colors.badgeForeground ? colors.badgeForeground.toString() : null;
                recordingBadge.style.backgroundColor = background;
                recordingBadge.style.borderWidth = border ? '1px' : null;
                recordingBadge.style.borderStyle = border ? 'solid' : null;
                recordingBadge.style.borderColor = border;
                recordingBadge.style.color = color ? color.toString() : null;
            }));
            return recordingBadge;
        };
        KeybindingsEditor.prototype.layoutSearchWidget = function (dimension) {
            this.searchWidget.layout(dimension);
            DOM.toggleClass(this.headerContainer, 'small', dimension.width < 400);
            this.searchWidget.inputBox.inputElement.style.paddingRight = '60px';
            if (dimension.width > 400 && this.recordKeysAction.checked) {
                this.searchWidget.inputBox.inputElement.style.paddingRight = '180px';
            }
        };
        KeybindingsEditor.prototype.createBody = function (parent) {
            var bodyContainer = DOM.append(parent, $('.keybindings-body'));
            this.createList(bodyContainer);
        };
        KeybindingsEditor.prototype.createList = function (parent) {
            var _this = this;
            this.keybindingsListContainer = DOM.append(parent, $('.keybindings-list-container'));
            this.keybindingsList = this._register(this.instantiationService.createInstance(listService_1.WorkbenchList, this.keybindingsListContainer, new Delegate(), [new KeybindingHeaderRenderer(), new KeybindingItemRenderer(this, this.keybindingsService)], { identityProvider: function (e) { return e.id; }, mouseSupport: true, ariaLabel: nls_1.localize('keybindingsLabel', "Keybindings") }));
            this._register(this.keybindingsList.onContextMenu(function (e) { return _this.onContextMenu(e); }));
            this._register(this.keybindingsList.onFocusChange(function (e) { return _this.onFocusChange(e); }));
            this._register(this.keybindingsList.onDidFocus(function () {
                DOM.addClass(_this.keybindingsList.getHTMLElement(), 'focused');
            }));
            this._register(this.keybindingsList.onDidBlur(function () {
                DOM.removeClass(_this.keybindingsList.getHTMLElement(), 'focused');
                _this.keybindingFocusContextKey.reset();
            }));
            this._register(this.keybindingsList.onMouseDblClick(function () { return _this.defineKeybinding(_this.activeKeybindingEntry); }));
            this._register(this.keybindingsList.onKeyDown(function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                if (event.keyCode === 3 /* Enter */) {
                    var keybindingEntry = _this.activeKeybindingEntry;
                    if (keybindingEntry) {
                        _this.defineKeybinding(_this.activeKeybindingEntry);
                    }
                    e.stopPropagation();
                }
            }));
        };
        KeybindingsEditor.prototype.render = function (preserveFocus, token) {
            var _this = this;
            if (this.input) {
                return this.input.resolve()
                    .then(function (keybindingsModel) {
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    _this.keybindingsEditorModel = keybindingsModel;
                    var editorActionsLabels = editorExtensions_1.EditorExtensionsRegistry.getEditorActions().reduce(function (editorActions, editorAction) {
                        editorActions[editorAction.id] = editorAction.label;
                        return editorActions;
                    }, {});
                    return _this.keybindingsEditorModel.resolve(editorActionsLabels);
                })
                    .then(function () {
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    _this.renderKeybindingsEntries(false, preserveFocus);
                });
            }
            return winjs_base_1.TPromise.as(null);
        };
        KeybindingsEditor.prototype.filterKeybindings = function () {
            var _this = this;
            this.renderKeybindingsEntries(this.searchWidget.hasFocus());
            this.delayedFilterLogging.trigger(function () { return _this.reportFilteringUsed(_this.searchWidget.getValue()); });
        };
        KeybindingsEditor.prototype.renderKeybindingsEntries = function (reset, preserveFocus) {
            if (this.keybindingsEditorModel) {
                var filter = this.searchWidget.getValue();
                var keybindingsEntries = this.keybindingsEditorModel.fetch(filter, this.sortByPrecedenceAction.checked);
                this.ariaLabelElement.setAttribute('aria-label', this.getAriaLabel(keybindingsEntries));
                if (keybindingsEntries.length === 0) {
                    this.latestEmptyFilters.push(filter);
                }
                var currentSelectedIndex = this.keybindingsList.getSelection()[0];
                this.listEntries = [{ id: 'keybinding-header-entry', templateId: keybindingsEditorModel_1.KEYBINDING_HEADER_TEMPLATE_ID }].concat(keybindingsEntries);
                this.keybindingsList.splice(0, this.keybindingsList.length, this.listEntries);
                this.layoutKebindingsList();
                if (reset) {
                    this.keybindingsList.setSelection([]);
                    this.keybindingsList.setFocus([]);
                }
                else {
                    if (this.unAssignedKeybindingItemToRevealAndFocus) {
                        var index = this.getNewIndexOfUnassignedKeybinding(this.unAssignedKeybindingItemToRevealAndFocus);
                        if (index !== -1) {
                            this.keybindingsList.reveal(index, 0.2);
                            this.selectEntry(index);
                        }
                        this.unAssignedKeybindingItemToRevealAndFocus = null;
                    }
                    else if (currentSelectedIndex !== -1 && currentSelectedIndex < this.listEntries.length) {
                        this.selectEntry(currentSelectedIndex);
                    }
                    else if (this.editorService.activeControl === this && !preserveFocus) {
                        this.focus();
                    }
                }
            }
        };
        KeybindingsEditor.prototype.getAriaLabel = function (keybindingsEntries) {
            if (this.sortByPrecedenceAction.checked) {
                return nls_1.localize('show sorted keybindings', "Showing {0} Keybindings in precedence order", keybindingsEntries.length);
            }
            else {
                return nls_1.localize('show keybindings', "Showing {0} Keybindings in alphabetical order", keybindingsEntries.length);
            }
        };
        KeybindingsEditor.prototype.layoutKebindingsList = function () {
            var listHeight = this.dimension.height - (DOM.getDomNodePagePosition(this.headerContainer).height + 12 /*padding*/);
            this.keybindingsListContainer.style.height = listHeight + "px";
            this.keybindingsList.layout(listHeight);
        };
        KeybindingsEditor.prototype.getIndexOf = function (listEntry) {
            var index = this.listEntries.indexOf(listEntry);
            if (index === -1) {
                for (var i = 0; i < this.listEntries.length; i++) {
                    if (this.listEntries[i].id === listEntry.id) {
                        return i;
                    }
                }
            }
            return index;
        };
        KeybindingsEditor.prototype.getNewIndexOfUnassignedKeybinding = function (unassignedKeybinding) {
            for (var index = 0; index < this.listEntries.length; index++) {
                var entry = this.listEntries[index];
                if (entry.templateId === keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID) {
                    var keybindingItemEntry = entry;
                    if (keybindingItemEntry.keybindingItem.command === unassignedKeybinding.keybindingItem.command) {
                        return index;
                    }
                }
            }
            return -1;
        };
        KeybindingsEditor.prototype.selectEntry = function (keybindingItemEntry) {
            var index = typeof keybindingItemEntry === 'number' ? keybindingItemEntry : this.getIndexOf(keybindingItemEntry);
            if (index !== -1) {
                this.keybindingsList.getHTMLElement().focus();
                this.keybindingsList.setFocus([index]);
                this.keybindingsList.setSelection([index]);
            }
        };
        KeybindingsEditor.prototype.focusKeybindings = function () {
            this.keybindingsList.getHTMLElement().focus();
            var currentFocusIndices = this.keybindingsList.getFocus();
            this.keybindingsList.setFocus([currentFocusIndices.length ? currentFocusIndices[0] : 0]);
        };
        KeybindingsEditor.prototype.recordSearchKeys = function () {
            this.recordKeysAction.checked = true;
        };
        KeybindingsEditor.prototype.toggleSortByPrecedence = function () {
            this.sortByPrecedenceAction.checked = !this.sortByPrecedenceAction.checked;
        };
        KeybindingsEditor.prototype.onContextMenu = function (e) {
            var _this = this;
            if (e.element.templateId === keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID) {
                this.selectEntry(e.element);
                this.contextMenuService.showContextMenu({
                    getAnchor: function () { return e.anchor; },
                    getActions: function () { return winjs_base_1.TPromise.as([
                        _this.createCopyAction(e.element),
                        _this.createCopyCommandAction(e.element),
                        new actionbar_1.Separator(),
                        _this.createDefineAction(e.element),
                        _this.createRemoveAction(e.element),
                        _this.createResetAction(e.element),
                        new actionbar_1.Separator(),
                        _this.createShowConflictsAction(e.element)
                    ]); }
                });
            }
        };
        KeybindingsEditor.prototype.onFocusChange = function (e) {
            this.keybindingFocusContextKey.reset();
            var element = e.elements[0];
            if (!element) {
                return;
            }
            if (element.templateId === keybindingsEditorModel_1.KEYBINDING_HEADER_TEMPLATE_ID) {
                this.keybindingsList.focusNext();
                return;
            }
            if (element.templateId === keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID) {
                this.keybindingFocusContextKey.set(true);
            }
        };
        KeybindingsEditor.prototype.createDefineAction = function (keybindingItemEntry) {
            var _this = this;
            return {
                label: keybindingItemEntry.keybindingItem.keybinding ? nls_1.localize('changeLabel', "Change Keybinding") : nls_1.localize('addLabel', "Add Keybinding"),
                enabled: true,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_DEFINE,
                run: function () { return _this.defineKeybinding(keybindingItemEntry); }
            };
        };
        KeybindingsEditor.prototype.createRemoveAction = function (keybindingItem) {
            var _this = this;
            return {
                label: nls_1.localize('removeLabel', "Remove Keybinding"),
                enabled: !!keybindingItem.keybindingItem.keybinding,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_REMOVE,
                run: function () { return _this.removeKeybinding(keybindingItem); }
            };
        };
        KeybindingsEditor.prototype.createResetAction = function (keybindingItem) {
            var _this = this;
            return {
                label: nls_1.localize('resetLabel', "Reset Keybinding"),
                enabled: !keybindingItem.keybindingItem.keybindingItem.isDefault,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_RESET,
                run: function () { return _this.resetKeybinding(keybindingItem); }
            };
        };
        KeybindingsEditor.prototype.createShowConflictsAction = function (keybindingItem) {
            var _this = this;
            return {
                label: nls_1.localize('showSameKeybindings', "Show Same Keybindings"),
                enabled: !!keybindingItem.keybindingItem.keybinding,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_SHOW_SIMILAR,
                run: function () { return _this.showSimilarKeybindings(keybindingItem); }
            };
        };
        KeybindingsEditor.prototype.createCopyAction = function (keybindingItem) {
            var _this = this;
            return {
                label: nls_1.localize('copyLabel', "Copy"),
                enabled: true,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY,
                run: function () { return _this.copyKeybinding(keybindingItem); }
            };
        };
        KeybindingsEditor.prototype.createCopyCommandAction = function (keybinding) {
            var _this = this;
            return {
                label: nls_1.localize('copyCommandLabel', "Copy Command"),
                enabled: true,
                id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY_COMMAND,
                run: function () { return _this.copyKeybindingCommand(keybinding); }
            };
        };
        KeybindingsEditor.prototype.reportFilteringUsed = function (filter) {
            if (filter) {
                var data = {
                    filter: filter,
                    emptyFilters: this.getLatestEmptyFiltersForTelemetry()
                };
                this.latestEmptyFilters = [];
                /* __GDPR__
                    "keybindings.filter" : {
                        "filter": { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                        "emptyFilters" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                this.telemetryService.publicLog('keybindings.filter', data);
            }
        };
        /**
         * Put a rough limit on the size of the telemetry data, since otherwise it could be an unbounded large amount
         * of data. 8192 is the max size of a property value. This is rough since that probably includes ""s, etc.
         */
        KeybindingsEditor.prototype.getLatestEmptyFiltersForTelemetry = function () {
            var cumulativeSize = 0;
            return this.latestEmptyFilters.filter(function (filterText) { return (cumulativeSize += filterText.length) <= 8192; });
        };
        KeybindingsEditor.prototype.reportKeybindingAction = function (action, command, keybinding) {
            // __GDPR__TODO__ Need to move off dynamic event names and properties as they cannot be registered statically
            this.telemetryService.publicLog(action, { command: command, keybinding: keybinding ? (typeof keybinding === 'string' ? keybinding : keybinding.getUserSettingsLabel()) : '' });
        };
        KeybindingsEditor.prototype.onKeybindingEditingError = function (error) {
            this.notificationService.error(typeof error === 'string' ? error : nls_1.localize('error', "Error '{0}' while editing the keybinding. Please open 'keybindings.json' file and check for errors.", "" + error));
        };
        KeybindingsEditor.ID = 'workbench.editor.keybindings';
        KeybindingsEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, themeService_1.IThemeService),
            __param(2, keybinding_1.IKeybindingService),
            __param(3, contextView_1.IContextMenuService),
            __param(4, keybindingEditing_1.IKeybindingEditingService),
            __param(5, contextkey_1.IContextKeyService),
            __param(6, notification_1.INotificationService),
            __param(7, clipboardService_1.IClipboardService),
            __param(8, instantiation_1.IInstantiationService),
            __param(9, editorService_1.IEditorService)
        ], KeybindingsEditor);
        return KeybindingsEditor;
    }(baseEditor_1.BaseEditor));
    exports.KeybindingsEditor = KeybindingsEditor;
    var Delegate = /** @class */ (function () {
        function Delegate() {
        }
        Delegate.prototype.getHeight = function (element) {
            if (element.templateId === keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID) {
                var commandIdMatched = element.keybindingItem.commandLabel && element.commandIdMatches;
                var commandDefaultLabelMatched = !!element.commandDefaultLabelMatches;
                if (commandIdMatched && commandDefaultLabelMatched) {
                    return 60;
                }
                if (commandIdMatched || commandDefaultLabelMatched) {
                    return 40;
                }
            }
            if (element.templateId === keybindingsEditorModel_1.KEYBINDING_HEADER_TEMPLATE_ID) {
                return 30;
            }
            return 24;
        };
        Delegate.prototype.getTemplateId = function (element) {
            return element.templateId;
        };
        return Delegate;
    }());
    var KeybindingHeaderRenderer = /** @class */ (function () {
        function KeybindingHeaderRenderer() {
        }
        Object.defineProperty(KeybindingHeaderRenderer.prototype, "templateId", {
            get: function () { return keybindingsEditorModel_1.KEYBINDING_HEADER_TEMPLATE_ID; },
            enumerable: true,
            configurable: true
        });
        KeybindingHeaderRenderer.prototype.renderTemplate = function (container) {
            DOM.addClass(container, 'keybindings-list-header');
            DOM.append(container, $('.header.actions'), $('.header.command', null, nls_1.localize('command', "Command")), $('.header.keybinding', null, nls_1.localize('keybinding', "Keybinding")), $('.header.source', null, nls_1.localize('source', "Source")), $('.header.when', null, nls_1.localize('when', "When")));
            return {};
        };
        KeybindingHeaderRenderer.prototype.renderElement = function (entry, index, template) {
        };
        KeybindingHeaderRenderer.prototype.disposeElement = function () {
        };
        KeybindingHeaderRenderer.prototype.disposeTemplate = function (template) {
        };
        return KeybindingHeaderRenderer;
    }());
    var KeybindingItemRenderer = /** @class */ (function () {
        function KeybindingItemRenderer(keybindingsEditor, keybindingsService) {
            this.keybindingsEditor = keybindingsEditor;
            this.keybindingsService = keybindingsService;
        }
        Object.defineProperty(KeybindingItemRenderer.prototype, "templateId", {
            get: function () { return keybindingsEditorModel_1.KEYBINDING_ENTRY_TEMPLATE_ID; },
            enumerable: true,
            configurable: true
        });
        KeybindingItemRenderer.prototype.renderTemplate = function (container) {
            DOM.addClass(container, 'keybinding-item');
            var actions = new ActionsColumn(container, this.keybindingsEditor, this.keybindingsService);
            var command = new CommandColumn(container, this.keybindingsEditor);
            var keybinding = new KeybindingColumn(container, this.keybindingsEditor);
            var source = new SourceColumn(container, this.keybindingsEditor);
            var when = new WhenColumn(container, this.keybindingsEditor);
            container.setAttribute('aria-labelledby', [command.id, keybinding.id, source.id, when.id].join(' '));
            return {
                parent: container,
                actions: actions,
                command: command,
                keybinding: keybinding,
                source: source,
                when: when
            };
        };
        KeybindingItemRenderer.prototype.renderElement = function (keybindingEntry, index, template) {
            DOM.toggleClass(template.parent, 'odd', index % 2 === 1);
            template.actions.render(keybindingEntry);
            template.command.render(keybindingEntry);
            template.keybinding.render(keybindingEntry);
            template.source.render(keybindingEntry);
            template.when.render(keybindingEntry);
        };
        KeybindingItemRenderer.prototype.disposeElement = function () { };
        KeybindingItemRenderer.prototype.disposeTemplate = function (template) {
            template.actions.dispose();
        };
        return KeybindingItemRenderer;
    }());
    var Column = /** @class */ (function () {
        function Column(parent, keybindingsEditor) {
            this.parent = parent;
            this.keybindingsEditor = keybindingsEditor;
            this.element = this.create(parent);
            this.id = this.element.getAttribute('id');
        }
        Column.COUNTER = 0;
        return Column;
    }());
    var ActionsColumn = /** @class */ (function (_super) {
        __extends(ActionsColumn, _super);
        function ActionsColumn(parent, keybindingsEditor, keybindingsService) {
            var _this = _super.call(this, parent, keybindingsEditor) || this;
            _this.keybindingsService = keybindingsService;
            return _this;
        }
        ActionsColumn.prototype.create = function (parent) {
            var actionsContainer = DOM.append(parent, $('.column.actions', { id: 'actions_' + ++Column.COUNTER }));
            this.actionBar = new actionbar_1.ActionBar(actionsContainer, { animated: false });
            return actionsContainer;
        };
        ActionsColumn.prototype.render = function (keybindingItemEntry) {
            this.actionBar.clear();
            var actions = [];
            if (keybindingItemEntry.keybindingItem.keybinding) {
                actions.push(this.createEditAction(keybindingItemEntry));
            }
            else {
                actions.push(this.createAddAction(keybindingItemEntry));
            }
            this.actionBar.push(actions, { icon: true });
        };
        ActionsColumn.prototype.createEditAction = function (keybindingItemEntry) {
            var _this = this;
            var keybinding = this.keybindingsService.lookupKeybinding(preferences_1.KEYBINDINGS_EDITOR_COMMAND_DEFINE);
            return {
                class: 'edit',
                enabled: true,
                id: 'editKeybinding',
                tooltip: keybinding ? nls_1.localize('editKeybindingLabelWithKey', "Change Keybinding {0}", "(" + keybinding.getLabel() + ")") : nls_1.localize('editKeybindingLabel', "Change Keybinding"),
                run: function () { return _this.keybindingsEditor.defineKeybinding(keybindingItemEntry); }
            };
        };
        ActionsColumn.prototype.createAddAction = function (keybindingItemEntry) {
            var _this = this;
            var keybinding = this.keybindingsService.lookupKeybinding(preferences_1.KEYBINDINGS_EDITOR_COMMAND_DEFINE);
            return {
                class: 'add',
                enabled: true,
                id: 'addKeybinding',
                tooltip: keybinding ? nls_1.localize('addKeybindingLabelWithKey', "Add Keybinding {0}", "(" + keybinding.getLabel() + ")") : nls_1.localize('addKeybindingLabel', "Add Keybinding"),
                run: function () { return _this.keybindingsEditor.defineKeybinding(keybindingItemEntry); }
            };
        };
        ActionsColumn.prototype.dispose = function () {
            this.actionBar = lifecycle_1.dispose(this.actionBar);
        };
        return ActionsColumn;
    }(Column));
    var CommandColumn = /** @class */ (function (_super) {
        __extends(CommandColumn, _super);
        function CommandColumn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CommandColumn.prototype.create = function (parent) {
            this.commandColumn = DOM.append(parent, $('.column.command', { id: 'command_' + ++Column.COUNTER }));
            return this.commandColumn;
        };
        CommandColumn.prototype.render = function (keybindingItemEntry) {
            DOM.clearNode(this.commandColumn);
            var keybindingItem = keybindingItemEntry.keybindingItem;
            var commandIdMatched = !!(keybindingItem.commandLabel && keybindingItemEntry.commandIdMatches);
            var commandDefaultLabelMatched = !!keybindingItemEntry.commandDefaultLabelMatches;
            DOM.toggleClass(this.commandColumn, 'vertical-align-column', commandIdMatched || commandDefaultLabelMatched);
            this.commandColumn.setAttribute('aria-label', this.getAriaLabel(keybindingItemEntry));
            var commandLabel;
            if (keybindingItem.commandLabel) {
                commandLabel = new highlightedLabel_1.HighlightedLabel(this.commandColumn);
                commandLabel.set(keybindingItem.commandLabel, keybindingItemEntry.commandLabelMatches);
            }
            if (keybindingItemEntry.commandDefaultLabelMatches) {
                commandLabel = new highlightedLabel_1.HighlightedLabel(DOM.append(this.commandColumn, $('.command-default-label')));
                commandLabel.set(keybindingItem.commandDefaultLabel, keybindingItemEntry.commandDefaultLabelMatches);
            }
            if (keybindingItemEntry.commandIdMatches || !keybindingItem.commandLabel) {
                commandLabel = new highlightedLabel_1.HighlightedLabel(DOM.append(this.commandColumn, $('.code')));
                commandLabel.set(keybindingItem.command, keybindingItemEntry.commandIdMatches);
            }
            if (commandLabel) {
                commandLabel.element.title = keybindingItem.commandLabel ? nls_1.localize('title', "{0} ({1})", keybindingItem.commandLabel, keybindingItem.command) : keybindingItem.command;
            }
        };
        CommandColumn.prototype.getAriaLabel = function (keybindingItemEntry) {
            return nls_1.localize('commandAriaLabel', "Command is {0}.", keybindingItemEntry.keybindingItem.commandLabel ? keybindingItemEntry.keybindingItem.commandLabel : keybindingItemEntry.keybindingItem.command);
        };
        return CommandColumn;
    }(Column));
    var KeybindingColumn = /** @class */ (function (_super) {
        __extends(KeybindingColumn, _super);
        function KeybindingColumn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        KeybindingColumn.prototype.create = function (parent) {
            this.keybindingColumn = DOM.append(parent, $('.column.keybinding', { id: 'keybinding_' + ++Column.COUNTER }));
            return this.keybindingColumn;
        };
        KeybindingColumn.prototype.render = function (keybindingItemEntry) {
            DOM.clearNode(this.keybindingColumn);
            this.keybindingColumn.setAttribute('aria-label', this.getAriaLabel(keybindingItemEntry));
            if (keybindingItemEntry.keybindingItem.keybinding) {
                new keybindingLabel_1.KeybindingLabel(this.keybindingColumn, platform_1.OS).set(keybindingItemEntry.keybindingItem.keybinding, keybindingItemEntry.keybindingMatches);
            }
        };
        KeybindingColumn.prototype.getAriaLabel = function (keybindingItemEntry) {
            return keybindingItemEntry.keybindingItem.keybinding ? nls_1.localize('keybindingAriaLabel', "Keybinding is {0}.", keybindingItemEntry.keybindingItem.keybinding.getAriaLabel()) : nls_1.localize('noKeybinding', "No Keybinding assigned.");
        };
        return KeybindingColumn;
    }(Column));
    var SourceColumn = /** @class */ (function (_super) {
        __extends(SourceColumn, _super);
        function SourceColumn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SourceColumn.prototype.create = function (parent) {
            this.sourceColumn = DOM.append(parent, $('.column.source', { id: 'source_' + ++Column.COUNTER }));
            return this.sourceColumn;
        };
        SourceColumn.prototype.render = function (keybindingItemEntry) {
            DOM.clearNode(this.sourceColumn);
            this.sourceColumn.setAttribute('aria-label', this.getAriaLabel(keybindingItemEntry));
            new highlightedLabel_1.HighlightedLabel(this.sourceColumn).set(keybindingItemEntry.keybindingItem.source, keybindingItemEntry.sourceMatches);
        };
        SourceColumn.prototype.getAriaLabel = function (keybindingItemEntry) {
            return nls_1.localize('sourceAriaLabel', "Source is {0}.", keybindingItemEntry.keybindingItem.source);
        };
        return SourceColumn;
    }(Column));
    var WhenColumn = /** @class */ (function (_super) {
        __extends(WhenColumn, _super);
        function WhenColumn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WhenColumn.prototype.create = function (parent) {
            var column = DOM.append(parent, $('.column.when'));
            this.whenColumn = DOM.append(column, $('div', { id: 'when_' + ++Column.COUNTER }));
            return this.whenColumn;
        };
        WhenColumn.prototype.render = function (keybindingItemEntry) {
            DOM.clearNode(this.whenColumn);
            this.whenColumn.setAttribute('aria-label', this.getAriaLabel(keybindingItemEntry));
            DOM.toggleClass(this.whenColumn, 'code', !!keybindingItemEntry.keybindingItem.when);
            DOM.toggleClass(this.whenColumn, 'empty', !keybindingItemEntry.keybindingItem.when);
            if (keybindingItemEntry.keybindingItem.when) {
                var whenLabel = new highlightedLabel_1.HighlightedLabel(this.whenColumn);
                whenLabel.set(keybindingItemEntry.keybindingItem.when, keybindingItemEntry.whenMatches);
                this.whenColumn.title = keybindingItemEntry.keybindingItem.when;
                whenLabel.element.title = keybindingItemEntry.keybindingItem.when;
            }
            else {
                this.whenColumn.textContent = '';
            }
        };
        WhenColumn.prototype.getAriaLabel = function (keybindingItemEntry) {
            return keybindingItemEntry.keybindingItem.when ? nls_1.localize('whenAriaLabel', "When is {0}.", keybindingItemEntry.keybindingItem.when) : nls_1.localize('noWhen', "No when context.");
        };
        return WhenColumn;
    }(Column));
    themeService_1.registerThemingParticipant(function (theme, collector) {
        var listHighlightForegroundColor = theme.getColor(colorRegistry_1.listHighlightForeground);
        if (listHighlightForegroundColor) {
            collector.addRule(".keybindings-editor > .keybindings-body > .keybindings-list-container .monaco-list-row > .column .highlight { color: " + listHighlightForegroundColor + "; }");
        }
    });
});























define(__m[123/*vs/workbench/services/textfile/common/textFileEditorModel*/], __M([0/*require*/,1/*exports*/,24/*vs/base/common/paths*/,2/*vs/nls*/,6/*vs/base/common/event*/,5/*vs/base/common/winjs.base*/,131/*vs/base/common/mime*/,98/*vs/base/common/errorMessage*/,12/*vs/base/common/uri*/,29/*vs/base/common/types*/,20/*vs/platform/workspace/common/workspace*/,43/*vs/platform/environment/common/environment*/,27/*vs/workbench/services/textfile/common/textfiles*/,116/*vs/workbench/common/editor/textEditorModel*/,113/*vs/workbench/services/backup/common/backup*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/,32/*vs/platform/telemetry/common/telemetry*/,17/*vs/base/common/async*/,94/*vs/workbench/services/hash/common/hashService*/,73/*vs/editor/common/model/textModel*/,28/*vs/platform/notification/common/notification*/,18/*vs/base/common/platform*/,4/*vs/base/common/lifecycle*/,86/*vs/platform/log/common/log*/,35/*vs/base/common/resources*/]), function (require, exports, path, nls, event_1, winjs_base_1, mime_1, errorMessage_1, uri_1, types_1, workspace_1, environment_1, textfiles_1, textEditorModel_1, backup_1, files_1, instantiation_1, modeService_1, modelService_1, telemetry_1, async_1, hashService_1, textModel_1, notification_1, platform_1, lifecycle_1, log_1, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The text file editor model listens to changes to its underlying code editor model and saves these changes through the file service back to the disk.
     */
    var TextFileEditorModel = /** @class */ (function (_super) {
        __extends(TextFileEditorModel, _super);
        function TextFileEditorModel(resource, preferredEncoding, notificationService, modeService, modelService, fileService, instantiationService, telemetryService, textFileService, backupFileService, environmentService, contextService, hashService, logService) {
            var _this = _super.call(this, modelService, modeService) || this;
            _this.notificationService = notificationService;
            _this.fileService = fileService;
            _this.instantiationService = instantiationService;
            _this.telemetryService = telemetryService;
            _this.textFileService = textFileService;
            _this.backupFileService = backupFileService;
            _this.environmentService = environmentService;
            _this.contextService = contextService;
            _this.hashService = hashService;
            _this.logService = logService;
            _this._onDidContentChange = _this._register(new event_1.Emitter());
            _this._onDidStateChange = _this._register(new event_1.Emitter());
            _this.resource = resource;
            _this.preferredEncoding = preferredEncoding;
            _this.inOrphanMode = false;
            _this.dirty = false;
            _this.versionId = 0;
            _this.lastSaveAttemptTime = 0;
            _this.saveSequentializer = new SaveSequentializer();
            _this.contentChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidContentChange.fire(6 /* CONTENT_CHANGE */); }, TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY));
            _this.orphanedChangeEventScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this._onDidStateChange.fire(7 /* ORPHANED_CHANGE */); }, TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY));
            _this.updateAutoSaveConfiguration(textFileService.getAutoSaveConfiguration());
            _this.registerListeners();
            return _this;
        }
        TextFileEditorModel.setSaveErrorHandler = function (handler) { TextFileEditorModel.saveErrorHandler = handler; };
        TextFileEditorModel.setSaveParticipant = function (handler) { TextFileEditorModel.saveParticipant = handler; };
        Object.defineProperty(TextFileEditorModel.prototype, "onDidContentChange", {
            get: function () { return this._onDidContentChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModel.prototype, "onDidStateChange", {
            get: function () { return this._onDidStateChange.event; },
            enumerable: true,
            configurable: true
        });
        TextFileEditorModel.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));
            this._register(this.textFileService.onAutoSaveConfigurationChange(function (config) { return _this.updateAutoSaveConfiguration(config); }));
            this._register(this.textFileService.onFilesAssociationChange(function (e) { return _this.onFilesAssociationChange(); }));
            this._register(this.onDidStateChange(function (e) { return _this.onStateChange(e); }));
        };
        TextFileEditorModel.prototype.onStateChange = function (e) {
            if (e === 4 /* REVERTED */) {
                // Cancel any content change event promises as they are no longer valid.
                this.contentChangeEventScheduler.cancel();
                // Refire state change reverted events as content change events
                this._onDidContentChange.fire(4 /* REVERTED */);
            }
        };
        TextFileEditorModel.prototype.onFileChanges = function (e) {
            var _this = this;
            var fileEventImpactsModel = false;
            var newInOrphanModeGuess;
            // If we are currently orphaned, we check if the model file was added back
            if (this.inOrphanMode) {
                var modelFileAdded = e.contains(this.resource, 1 /* ADDED */);
                if (modelFileAdded) {
                    newInOrphanModeGuess = false;
                    fileEventImpactsModel = true;
                }
            }
            // Otherwise we check if the model file was deleted
            else {
                var modelFileDeleted = e.contains(this.resource, 2 /* DELETED */);
                if (modelFileDeleted) {
                    newInOrphanModeGuess = true;
                    fileEventImpactsModel = true;
                }
            }
            if (fileEventImpactsModel && this.inOrphanMode !== newInOrphanModeGuess) {
                var checkOrphanedPromise = void 0;
                if (newInOrphanModeGuess) {
                    // We have received reports of users seeing delete events even though the file still
                    // exists (network shares issue: https://github.com/Microsoft/vscode/issues/13665).
                    // Since we do not want to mark the model as orphaned, we have to check if the
                    // file is really gone and not just a faulty file event.
                    checkOrphanedPromise = async_1.timeout(100).then(function () {
                        if (_this.disposed) {
                            return true;
                        }
                        return _this.fileService.existsFile(_this.resource).then(function (exists) { return !exists; });
                    });
                }
                else {
                    checkOrphanedPromise = Promise.resolve(false);
                }
                checkOrphanedPromise.then(function (newInOrphanModeValidated) {
                    if (_this.inOrphanMode !== newInOrphanModeValidated && !_this.disposed) {
                        _this.setOrphaned(newInOrphanModeValidated);
                    }
                });
            }
        };
        TextFileEditorModel.prototype.setOrphaned = function (orphaned) {
            if (this.inOrphanMode !== orphaned) {
                this.inOrphanMode = orphaned;
                this.orphanedChangeEventScheduler.schedule();
            }
        };
        TextFileEditorModel.prototype.updateAutoSaveConfiguration = function (config) {
            var autoSaveAfterMilliesEnabled = (typeof config.autoSaveDelay === 'number') && config.autoSaveDelay > 0;
            this.autoSaveAfterMilliesEnabled = autoSaveAfterMilliesEnabled;
            this.autoSaveAfterMillies = autoSaveAfterMilliesEnabled ? config.autoSaveDelay : void 0;
        };
        TextFileEditorModel.prototype.onFilesAssociationChange = function () {
            if (!this.textEditorModel) {
                return;
            }
            var firstLineText = this.getFirstLineText(this.textEditorModel);
            var mode = this.getOrCreateMode(this.modeService, void 0, firstLineText);
            this.modelService.setMode(this.textEditorModel, mode);
        };
        TextFileEditorModel.prototype.getVersionId = function () {
            return this.versionId;
        };
        TextFileEditorModel.prototype.revert = function (soft) {
            var _this = this;
            if (!this.isResolved()) {
                return winjs_base_1.TPromise.wrap(null);
            }
            // Cancel any running auto-save
            this.cancelPendingAutoSave();
            // Unset flags
            var undo = this.setDirty(false);
            var loadPromise;
            if (soft) {
                loadPromise = winjs_base_1.TPromise.as(this);
            }
            else {
                loadPromise = this.load({ forceReadFromDisk: true });
            }
            return loadPromise.then(function () {
                // Emit file change event
                _this._onDidStateChange.fire(4 /* REVERTED */);
            }, function (error) {
                // Set flags back to previous values, we are still dirty if revert failed
                undo();
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        TextFileEditorModel.prototype.load = function (options) {
            this.logService.trace('load() - enter', this.resource);
            // It is very important to not reload the model when the model is dirty.
            // We also only want to reload the model from the disk if no save is pending
            // to avoid data loss.
            if (this.dirty || this.saveSequentializer.hasPendingSave()) {
                this.logService.trace('load() - exit - without loading because model is dirty or being saved', this.resource);
                return winjs_base_1.TPromise.as(this);
            }
            // Only for new models we support to load from backup
            if (!this.textEditorModel && !this.createTextEditorModelPromise) {
                return this.loadFromBackup(options);
            }
            // Otherwise load from file resource
            return this.loadFromFile(options);
        };
        TextFileEditorModel.prototype.loadFromBackup = function (options) {
            var _this = this;
            return this.backupFileService.loadBackupResource(this.resource).then(function (backup) {
                // Make sure meanwhile someone else did not suceed or start loading
                if (_this.createTextEditorModelPromise || _this.textEditorModel) {
                    return _this.createTextEditorModelPromise || winjs_base_1.TPromise.as(_this);
                }
                // If we have a backup, continue loading with it
                if (!!backup) {
                    var content = {
                        resource: _this.resource,
                        name: path.basename(_this.resource.fsPath),
                        mtime: Date.now(),
                        etag: void 0,
                        value: textModel_1.createTextBufferFactory(''),
                        encoding: _this.fileService.encoding.getWriteEncoding(_this.resource, _this.preferredEncoding),
                        isReadonly: false
                    };
                    return _this.loadWithContent(content, options, backup);
                }
                // Otherwise load from file
                return _this.loadFromFile(options);
            });
        };
        TextFileEditorModel.prototype.loadFromFile = function (options) {
            var _this = this;
            var forceReadFromDisk = options && options.forceReadFromDisk;
            var allowBinary = this.isResolved() /* always allow if we resolved previously */ || (options && options.allowBinary);
            // Decide on etag
            var etag;
            if (forceReadFromDisk) {
                etag = void 0; // reset ETag if we enforce to read from disk
            }
            else if (this.lastResolvedDiskStat) {
                etag = this.lastResolvedDiskStat.etag; // otherwise respect etag to support caching
            }
            // Ensure to track the versionId before doing a long running operation
            // to make sure the model was not changed in the meantime which would
            // indicate that the user or program has made edits. If we would ignore
            // this, we could potentially loose the changes that were made because
            // after resolving the content we update the model and reset the dirty
            // flag.
            var currentVersionId = this.versionId;
            // Resolve Content
            return this.textFileService
                .resolveTextContent(this.resource, { acceptTextOnly: !allowBinary, etag: etag, encoding: this.preferredEncoding })
                .then(function (content) {
                // Clear orphaned state when loading was successful
                _this.setOrphaned(false);
                // Guard against the model having changed in the meantime
                if (currentVersionId === _this.versionId) {
                    return _this.loadWithContent(content, options);
                }
                return _this;
            }, function (error) {
                var result = error.fileOperationResult;
                // Apply orphaned state based on error code
                _this.setOrphaned(result === 2 /* FILE_NOT_FOUND */);
                // NotModified status is expected and can be handled gracefully
                if (result === 3 /* FILE_NOT_MODIFIED_SINCE */) {
                    // Guard against the model having changed in the meantime
                    if (currentVersionId === _this.versionId) {
                        _this.setDirty(false); // Ensure we are not tracking a stale state
                    }
                    return winjs_base_1.TPromise.as(_this);
                }
                // Ignore when a model has been resolved once and the file was deleted meanwhile. Since
                // we already have the model loaded, we can return to this state and update the orphaned
                // flag to indicate that this model has no version on disk anymore.
                if (_this.isResolved() && result === 2 /* FILE_NOT_FOUND */) {
                    return winjs_base_1.TPromise.as(_this);
                }
                // Otherwise bubble up the error
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        TextFileEditorModel.prototype.loadWithContent = function (content, options, backup) {
            var _this = this;
            return this.doLoadWithContent(content, backup).then(function (model) {
                // Telemetry: We log the fileGet telemetry event after the model has been loaded to ensure a good mimetype
                var settingsType = _this.getTypeIfSettings();
                if (settingsType) {
                    /* __GDPR__
                        "settingsRead" : {
                            "settingsType": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                        }
                    */
                    _this.telemetryService.publicLog('settingsRead', { settingsType: settingsType }); // Do not log read to user settings.json and .vscode folder as a fileGet event as it ruins our JSON usage data
                }
                else {
                    /* __GDPR__
                        "fileGet" : {
                            "${include}": [
                                "${FileTelemetryData}"
                            ]
                        }
                    */
                    _this.telemetryService.publicLog('fileGet', _this.getTelemetryData(options && options.reason ? options.reason : 3 /* OTHER */));
                }
                return model;
            });
        };
        TextFileEditorModel.prototype.doLoadWithContent = function (content, backup) {
            this.logService.trace('load() - resolved content', this.resource);
            // Update our resolved disk stat model
            this.updateLastResolvedDiskStat({
                resource: this.resource,
                name: content.name,
                mtime: content.mtime,
                etag: content.etag,
                isDirectory: false,
                isSymbolicLink: false,
                children: void 0,
                isReadonly: content.isReadonly
            });
            // Keep the original encoding to not loose it when saving
            var oldEncoding = this.contentEncoding;
            this.contentEncoding = content.encoding;
            // Handle events if encoding changed
            if (this.preferredEncoding) {
                this.updatePreferredEncoding(this.contentEncoding); // make sure to reflect the real encoding of the file (never out of sync)
            }
            else if (oldEncoding !== this.contentEncoding) {
                this._onDidStateChange.fire(5 /* ENCODING */);
            }
            // Update Existing Model
            if (this.textEditorModel) {
                return this.doUpdateTextModel(content.value);
            }
            // Join an existing request to create the editor model to avoid race conditions
            else if (this.createTextEditorModelPromise) {
                this.logService.trace('load() - join existing text editor model promise', this.resource);
                return this.createTextEditorModelPromise;
            }
            // Create New Model
            return this.doCreateTextModel(content.resource, content.value, backup);
        };
        TextFileEditorModel.prototype.doUpdateTextModel = function (value) {
            this.logService.trace('load() - updated text editor model', this.resource);
            // Ensure we are not tracking a stale state
            this.setDirty(false);
            // Update model value in a block that ignores model content change events
            this.blockModelContentChange = true;
            try {
                this.updateTextEditorModel(value);
            }
            finally {
                this.blockModelContentChange = false;
            }
            // Ensure we track the latest saved version ID given that the contents changed
            this.updateSavedVersionId();
            return winjs_base_1.TPromise.as(this);
        };
        TextFileEditorModel.prototype.doCreateTextModel = function (resource, value, backup) {
            var _this = this;
            this.logService.trace('load() - created text editor model', this.resource);
            this.createTextEditorModelPromise = this.doLoadBackup(backup).then(function (backupContent) {
                var hasBackupContent = !!backupContent;
                return _this.createTextEditorModel(hasBackupContent ? backupContent : value, resource).then(function () {
                    _this.createTextEditorModelPromise = null;
                    // We restored a backup so we have to set the model as being dirty
                    // We also want to trigger auto save if it is enabled to simulate the exact same behaviour
                    // you would get if manually making the model dirty (fixes https://github.com/Microsoft/vscode/issues/16977)
                    if (hasBackupContent) {
                        _this.makeDirty();
                        if (_this.autoSaveAfterMilliesEnabled) {
                            _this.doAutoSave(_this.versionId);
                        }
                    }
                    // Ensure we are not tracking a stale state
                    else {
                        _this.setDirty(false);
                    }
                    // Model Listeners
                    _this.installModelListeners();
                    return _this;
                }, function (error) {
                    _this.createTextEditorModelPromise = null;
                    return winjs_base_1.TPromise.wrapError(error);
                });
            });
            return this.createTextEditorModelPromise;
        };
        TextFileEditorModel.prototype.installModelListeners = function () {
            // See https://github.com/Microsoft/vscode/issues/30189
            // This code has been extracted to a different method because it caused a memory leak
            // where `value` was captured in the content change listener closure scope.
            var _this = this;
            // Content Change
            this._register(this.textEditorModel.onDidChangeContent(function () { return _this.onModelContentChanged(); }));
        };
        TextFileEditorModel.prototype.doLoadBackup = function (backup) {
            if (!backup) {
                return winjs_base_1.TPromise.as(null);
            }
            return this.backupFileService.resolveBackupContent(backup).then(function (backupContent) { return backupContent; }, function (error) { return null; } /* ignore errors */);
        };
        TextFileEditorModel.prototype.getOrCreateMode = function (modeService, preferredModeIds, firstLineText) {
            return modeService.getOrCreateModeByFilepathOrFirstLine(this.resource.fsPath, firstLineText);
        };
        TextFileEditorModel.prototype.onModelContentChanged = function () {
            this.logService.trace("onModelContentChanged() - enter", this.resource);
            // In any case increment the version id because it tracks the textual content state of the model at all times
            this.versionId++;
            this.logService.trace("onModelContentChanged() - new versionId " + this.versionId, this.resource);
            // Ignore if blocking model changes
            if (this.blockModelContentChange) {
                return;
            }
            // The contents changed as a matter of Undo and the version reached matches the saved one
            // In this case we clear the dirty flag and emit a SAVED event to indicate this state.
            // Note: we currently only do this check when auto-save is turned off because there you see
            // a dirty indicator that you want to get rid of when undoing to the saved version.
            if (!this.autoSaveAfterMilliesEnabled && this.textEditorModel.getAlternativeVersionId() === this.bufferSavedVersionId) {
                this.logService.trace('onModelContentChanged() - model content changed back to last saved version', this.resource);
                // Clear flags
                var wasDirty = this.dirty;
                this.setDirty(false);
                // Emit event
                if (wasDirty) {
                    this._onDidStateChange.fire(4 /* REVERTED */);
                }
                return;
            }
            this.logService.trace('onModelContentChanged() - model content changed and marked as dirty', this.resource);
            // Mark as dirty
            this.makeDirty();
            // Start auto save process unless we are in conflict resolution mode and unless it is disabled
            if (this.autoSaveAfterMilliesEnabled) {
                if (!this.inConflictMode) {
                    this.doAutoSave(this.versionId);
                }
                else {
                    this.logService.trace('makeDirty() - prevented save because we are in conflict resolution mode', this.resource);
                }
            }
            // Handle content change events
            this.contentChangeEventScheduler.schedule();
        };
        TextFileEditorModel.prototype.makeDirty = function () {
            // Track dirty state and version id
            var wasDirty = this.dirty;
            this.setDirty(true);
            // Emit as Event if we turned dirty
            if (!wasDirty) {
                this._onDidStateChange.fire(0 /* DIRTY */);
            }
        };
        TextFileEditorModel.prototype.doAutoSave = function (versionId) {
            var _this = this;
            this.logService.trace("doAutoSave() - enter for versionId " + versionId, this.resource);
            // Cancel any currently running auto saves to make this the one that succeeds
            this.cancelPendingAutoSave();
            // Create new save timer and store it for disposal as needed
            var handle = setTimeout(function () {
                // Only trigger save if the version id has not changed meanwhile
                if (versionId === _this.versionId) {
                    _this.doSave(versionId, { reason: 2 /* AUTO */ }); // Very important here to not return the promise because if the timeout promise is canceled it will bubble up the error otherwise - do not change
                }
            }, this.autoSaveAfterMillies);
            this.autoSaveDisposable = lifecycle_1.toDisposable(function () { return clearTimeout(handle); });
        };
        TextFileEditorModel.prototype.cancelPendingAutoSave = function () {
            if (this.autoSaveDisposable) {
                this.autoSaveDisposable.dispose();
                this.autoSaveDisposable = void 0;
            }
        };
        TextFileEditorModel.prototype.save = function (options) {
            if (options === void 0) { options = Object.create(null); }
            if (!this.isResolved()) {
                return winjs_base_1.TPromise.wrap(null);
            }
            this.logService.trace('save() - enter', this.resource);
            // Cancel any currently running auto saves to make this the one that succeeds
            this.cancelPendingAutoSave();
            return this.doSave(this.versionId, options);
        };
        TextFileEditorModel.prototype.doSave = function (versionId, options) {
            var _this = this;
            if (types_1.isUndefinedOrNull(options.reason)) {
                options.reason = 1 /* EXPLICIT */;
            }
            this.logService.trace("doSave(" + versionId + ") - enter with versionId ' + versionId", this.resource);
            // Lookup any running pending save for this versionId and return it if found
            //
            // Scenario: user invoked the save action multiple times quickly for the same contents
            //           while the save was not yet finished to disk
            //
            if (this.saveSequentializer.hasPendingSave(versionId)) {
                this.logService.trace("doSave(" + versionId + ") - exit - found a pending save for versionId " + versionId, this.resource);
                return this.saveSequentializer.pendingSave;
            }
            // Return early if not dirty (unless forced) or version changed meanwhile
            //
            // Scenario A: user invoked save action even though the model is not dirty
            // Scenario B: auto save was triggered for a certain change by the user but meanwhile the user changed
            //             the contents and the version for which auto save was started is no longer the latest.
            //             Thus we avoid spawning multiple auto saves and only take the latest.
            //
            if ((!options.force && !this.dirty) || versionId !== this.versionId) {
                this.logService.trace("doSave(" + versionId + ") - exit - because not dirty and/or versionId is different (this.isDirty: " + this.dirty + ", this.versionId: " + this.versionId + ")", this.resource);
                return winjs_base_1.TPromise.wrap(null);
            }
            // Return if currently saving by storing this save request as the next save that should happen.
            // Never ever must 2 saves execute at the same time because this can lead to dirty writes and race conditions.
            //
            // Scenario A: auto save was triggered and is currently busy saving to disk. this takes long enough that another auto save
            //             kicks in.
            // Scenario B: save is very slow (e.g. network share) and the user manages to change the buffer and trigger another save
            //             while the first save has not returned yet.
            //
            if (this.saveSequentializer.hasPendingSave()) {
                this.logService.trace("doSave(" + versionId + ") - exit - because busy saving", this.resource);
                // Register this as the next upcoming save and return
                return this.saveSequentializer.setNext(function () { return _this.doSave(_this.versionId /* make sure to use latest version id here */, options); });
            }
            // Push all edit operations to the undo stack so that the user has a chance to
            // Ctrl+Z back to the saved version. We only do this when auto-save is turned off
            if (!this.autoSaveAfterMilliesEnabled) {
                this.textEditorModel.pushStackElement();
            }
            // A save participant can still change the model now and since we are so close to saving
            // we do not want to trigger another auto save or similar, so we block this
            // In addition we update our version right after in case it changed because of a model change
            // Save participants can also be skipped through API.
            var saveParticipantPromise = winjs_base_1.TPromise.as(versionId);
            if (TextFileEditorModel.saveParticipant && !options.skipSaveParticipants) {
                var onCompleteOrError = function () {
                    _this.blockModelContentChange = false;
                    return _this.versionId;
                };
                saveParticipantPromise = winjs_base_1.TPromise.as(undefined).then(function () {
                    _this.blockModelContentChange = true;
                    return TextFileEditorModel.saveParticipant.participate(_this, { reason: options.reason });
                }).then(onCompleteOrError, onCompleteOrError);
            }
            // mark the save participant as current pending save operation
            return this.saveSequentializer.setPending(versionId, saveParticipantPromise.then(function (newVersionId) {
                // We have to protect against being disposed at this point. It could be that the save() operation
                // was triggerd followed by a dispose() operation right after without waiting. Typically we cannot
                // be disposed if we are dirty, but if we are not dirty, save() and dispose() can still be triggered
                // one after the other without waiting for the save() to complete. If we are disposed(), we risk
                // saving contents to disk that are stale (see https://github.com/Microsoft/vscode/issues/50942).
                // To fix this issue, we will not store the contents to disk when we got disposed.
                if (_this.disposed) {
                    return void 0;
                }
                // Under certain conditions we do a short-cut of flushing contents to disk when we can assume that
                // the file has not changed and as such was not dirty before.
                // The conditions are all of:
                // - a forced, explicit save (Ctrl+S)
                // - the model is not dirty (otherwise we know there are changed which needs to go to the file)
                // - the model is not in orphan mode (because in that case we know the file does not exist on disk)
                // - the model version did not change due to save participants running
                if (options.force && !_this.dirty && !_this.inOrphanMode && options.reason === 1 /* EXPLICIT */ && versionId === newVersionId) {
                    return _this.doTouch(newVersionId);
                }
                // update versionId with its new value (if pre-save changes happened)
                versionId = newVersionId;
                // Clear error flag since we are trying to save again
                _this.inErrorMode = false;
                // Remember when this model was saved last
                _this.lastSaveAttemptTime = Date.now();
                // Save to Disk
                // mark the save operation as currently pending with the versionId (it might have changed from a save participant triggering)
                _this.logService.trace("doSave(" + versionId + ") - before updateContent()", _this.resource);
                return _this.saveSequentializer.setPending(newVersionId, _this.fileService.updateContent(_this.lastResolvedDiskStat.resource, _this.createSnapshot(), {
                    overwriteReadonly: options.overwriteReadonly,
                    overwriteEncoding: options.overwriteEncoding,
                    mtime: _this.lastResolvedDiskStat.mtime,
                    encoding: _this.getEncoding(),
                    etag: _this.lastResolvedDiskStat.etag,
                    writeElevated: options.writeElevated
                }).then(function (stat) {
                    _this.logService.trace("doSave(" + versionId + ") - after updateContent()", _this.resource);
                    // Telemetry
                    var settingsType = _this.getTypeIfSettings();
                    if (settingsType) {
                        /* __GDPR__
                            "settingsWritten" : {
                                "settingsType": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                            }
                        */
                        _this.telemetryService.publicLog('settingsWritten', { settingsType: settingsType }); // Do not log write to user settings.json and .vscode folder as a filePUT event as it ruins our JSON usage data
                    }
                    else {
                        /* __GDPR__
                            "filePUT" : {
                                "${include}": [
                                    "${FileTelemetryData}"
                                ]
                            }
                        */
                        _this.telemetryService.publicLog('filePUT', _this.getTelemetryData(options.reason));
                    }
                    // Update dirty state unless model has changed meanwhile
                    if (versionId === _this.versionId) {
                        _this.logService.trace("doSave(" + versionId + ") - setting dirty to false because versionId did not change", _this.resource);
                        _this.setDirty(false);
                    }
                    else {
                        _this.logService.trace("doSave(" + versionId + ") - not setting dirty to false because versionId did change meanwhile", _this.resource);
                    }
                    // Updated resolved stat with updated stat
                    _this.updateLastResolvedDiskStat(stat);
                    // Cancel any content change event promises as they are no longer valid
                    _this.contentChangeEventScheduler.cancel();
                    // Emit File Saved Event
                    _this._onDidStateChange.fire(3 /* SAVED */);
                }, function (error) {
                    if (!error) {
                        error = new Error('Unknown Save Error'); // TODO@remote we should never get null as error (https://github.com/Microsoft/vscode/issues/55051)
                    }
                    _this.logService.error("doSave(" + versionId + ") - exit - resulted in a save error: " + error.toString(), _this.resource);
                    // Flag as error state in the model
                    _this.inErrorMode = true;
                    // Look out for a save conflict
                    if (error.fileOperationResult === 4 /* FILE_MODIFIED_SINCE */) {
                        _this.inConflictMode = true;
                    }
                    // Show to user
                    _this.onSaveError(error);
                    // Emit as event
                    _this._onDidStateChange.fire(2 /* SAVE_ERROR */);
                }));
            }));
        };
        TextFileEditorModel.prototype.getTypeIfSettings = function () {
            if (path.extname(this.resource.fsPath) !== '.json') {
                return '';
            }
            // Check for global settings file
            if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appSettingsPath), !platform_1.isLinux)) {
                return 'global-settings';
            }
            // Check for keybindings file
            if (resources_1.isEqual(this.resource, uri_1.URI.file(this.environmentService.appKeybindingsPath), !platform_1.isLinux)) {
                return 'keybindings';
            }
            // Check for locale file
            if (resources_1.isEqual(this.resource, uri_1.URI.file(path.join(this.environmentService.appSettingsHome, 'locale.json')), !platform_1.isLinux)) {
                return 'locale';
            }
            // Check for snippets
            if (resources_1.isEqualOrParent(this.resource, uri_1.URI.file(path.join(this.environmentService.appSettingsHome, 'snippets')))) {
                return 'snippets';
            }
            // Check for workspace settings file
            var folders = this.contextService.getWorkspace().folders;
            for (var i = 0; i < folders.length; i++) {
                if (resources_1.isEqualOrParent(this.resource, folders[i].toResource('.vscode'))) {
                    var filename = path.basename(this.resource.fsPath);
                    if (TextFileEditorModel.WHITELIST_WORKSPACE_JSON.indexOf(filename) > -1) {
                        return ".vscode/" + filename;
                    }
                }
            }
            return '';
        };
        TextFileEditorModel.prototype.getTelemetryData = function (reason) {
            var ext = path.extname(this.resource.fsPath);
            var fileName = path.basename(this.resource.fsPath);
            var telemetryData = {
                mimeType: mime_1.guessMimeTypes(this.resource.fsPath).join(', '),
                ext: ext,
                path: this.hashService.createSHA1(this.resource.fsPath),
                reason: reason
            };
            if (ext === '.json' && TextFileEditorModel.WHITELIST_JSON.indexOf(fileName) > -1) {
                telemetryData['whitelistedjson'] = fileName;
            }
            /* __GDPR__FRAGMENT__
                "FileTelemetryData" : {
                    "mimeType" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "ext": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "path": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "reason": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "whitelistedjson": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            return telemetryData;
        };
        TextFileEditorModel.prototype.doTouch = function (versionId) {
            var _this = this;
            return this.saveSequentializer.setPending(versionId, this.fileService.updateContent(this.lastResolvedDiskStat.resource, this.createSnapshot(), {
                mtime: this.lastResolvedDiskStat.mtime,
                encoding: this.getEncoding(),
                etag: this.lastResolvedDiskStat.etag
            }).then(function (stat) {
                // Updated resolved stat with updated stat since touching it might have changed mtime
                _this.updateLastResolvedDiskStat(stat);
            }, function () { return void 0; } /* gracefully ignore errors if just touching */));
        };
        TextFileEditorModel.prototype.setDirty = function (dirty) {
            var _this = this;
            var wasDirty = this.dirty;
            var wasInConflictMode = this.inConflictMode;
            var wasInErrorMode = this.inErrorMode;
            var oldBufferSavedVersionId = this.bufferSavedVersionId;
            if (!dirty) {
                this.dirty = false;
                this.inConflictMode = false;
                this.inErrorMode = false;
                this.updateSavedVersionId();
            }
            else {
                this.dirty = true;
            }
            // Return function to revert this call
            return function () {
                _this.dirty = wasDirty;
                _this.inConflictMode = wasInConflictMode;
                _this.inErrorMode = wasInErrorMode;
                _this.bufferSavedVersionId = oldBufferSavedVersionId;
            };
        };
        TextFileEditorModel.prototype.updateSavedVersionId = function () {
            // we remember the models alternate version id to remember when the version
            // of the model matches with the saved version on disk. we need to keep this
            // in order to find out if the model changed back to a saved version (e.g.
            // when undoing long enough to reach to a version that is saved and then to
            // clear the dirty flag)
            if (this.textEditorModel) {
                this.bufferSavedVersionId = this.textEditorModel.getAlternativeVersionId();
            }
        };
        TextFileEditorModel.prototype.updateLastResolvedDiskStat = function (newVersionOnDiskStat) {
            // First resolve - just take
            if (!this.lastResolvedDiskStat) {
                this.lastResolvedDiskStat = newVersionOnDiskStat;
            }
            // Subsequent resolve - make sure that we only assign it if the mtime is equal or has advanced.
            // This prevents race conditions from loading and saving. If a save comes in late after a revert
            // was called, the mtime could be out of sync.
            else if (this.lastResolvedDiskStat.mtime <= newVersionOnDiskStat.mtime) {
                this.lastResolvedDiskStat = newVersionOnDiskStat;
            }
        };
        TextFileEditorModel.prototype.onSaveError = function (error) {
            // Prepare handler
            if (!TextFileEditorModel.saveErrorHandler) {
                TextFileEditorModel.setSaveErrorHandler(this.instantiationService.createInstance(DefaultSaveErrorHandler));
            }
            // Handle
            TextFileEditorModel.saveErrorHandler.onSaveError(error, this);
        };
        TextFileEditorModel.prototype.isDirty = function () {
            return this.dirty;
        };
        TextFileEditorModel.prototype.getLastSaveAttemptTime = function () {
            return this.lastSaveAttemptTime;
        };
        TextFileEditorModel.prototype.getETag = function () {
            return this.lastResolvedDiskStat ? this.lastResolvedDiskStat.etag : null;
        };
        TextFileEditorModel.prototype.hasState = function (state) {
            switch (state) {
                case 3 /* CONFLICT */:
                    return this.inConflictMode;
                case 1 /* DIRTY */:
                    return this.dirty;
                case 5 /* ERROR */:
                    return this.inErrorMode;
                case 4 /* ORPHAN */:
                    return this.inOrphanMode;
                case 2 /* PENDING_SAVE */:
                    return this.saveSequentializer.hasPendingSave();
                case 0 /* SAVED */:
                    return !this.dirty;
            }
        };
        TextFileEditorModel.prototype.getEncoding = function () {
            return this.preferredEncoding || this.contentEncoding;
        };
        TextFileEditorModel.prototype.setEncoding = function (encoding, mode) {
            if (!this.isNewEncoding(encoding)) {
                return; // return early if the encoding is already the same
            }
            // Encode: Save with encoding
            if (mode === 0 /* Encode */) {
                this.updatePreferredEncoding(encoding);
                // Save
                if (!this.isDirty()) {
                    this.versionId++; // needs to increment because we change the model potentially
                    this.makeDirty();
                }
                if (!this.inConflictMode) {
                    this.save({ overwriteEncoding: true });
                }
            }
            // Decode: Load with encoding
            else {
                if (this.isDirty()) {
                    this.notificationService.info(nls.localize('saveFileFirst', "The file is dirty. Please save it first before reopening it with another encoding."));
                    return;
                }
                this.updatePreferredEncoding(encoding);
                // Load
                this.load({
                    forceReadFromDisk: true // because encoding has changed
                });
            }
        };
        TextFileEditorModel.prototype.updatePreferredEncoding = function (encoding) {
            if (!this.isNewEncoding(encoding)) {
                return;
            }
            this.preferredEncoding = encoding;
            // Emit
            this._onDidStateChange.fire(5 /* ENCODING */);
        };
        TextFileEditorModel.prototype.isNewEncoding = function (encoding) {
            if (this.preferredEncoding === encoding) {
                return false; // return early if the encoding is already the same
            }
            if (!this.preferredEncoding && this.contentEncoding === encoding) {
                return false; // also return if we don't have a preferred encoding but the content encoding is already the same
            }
            return true;
        };
        TextFileEditorModel.prototype.isResolved = function () {
            return !types_1.isUndefinedOrNull(this.lastResolvedDiskStat);
        };
        TextFileEditorModel.prototype.isReadonly = function () {
            return this.lastResolvedDiskStat && this.lastResolvedDiskStat.isReadonly;
        };
        TextFileEditorModel.prototype.isDisposed = function () {
            return this.disposed;
        };
        TextFileEditorModel.prototype.getResource = function () {
            return this.resource;
        };
        TextFileEditorModel.prototype.getStat = function () {
            return this.lastResolvedDiskStat;
        };
        TextFileEditorModel.prototype.dispose = function () {
            this.disposed = true;
            this.inConflictMode = false;
            this.inOrphanMode = false;
            this.inErrorMode = false;
            this.createTextEditorModelPromise = null;
            this.cancelPendingAutoSave();
            _super.prototype.dispose.call(this);
        };
        TextFileEditorModel.DEFAULT_CONTENT_CHANGE_BUFFER_DELAY = files_1.CONTENT_CHANGE_EVENT_BUFFER_DELAY;
        TextFileEditorModel.DEFAULT_ORPHANED_CHANGE_BUFFER_DELAY = 100;
        TextFileEditorModel.WHITELIST_JSON = ['package.json', 'package-lock.json', 'tsconfig.json', 'jsconfig.json', 'bower.json', '.eslintrc.json', 'tslint.json', 'composer.json'];
        TextFileEditorModel.WHITELIST_WORKSPACE_JSON = ['settings.json', 'extensions.json', 'tasks.json', 'launch.json'];
        TextFileEditorModel = __decorate([
            __param(2, notification_1.INotificationService),
            __param(3, modeService_1.IModeService),
            __param(4, modelService_1.IModelService),
            __param(5, files_1.IFileService),
            __param(6, instantiation_1.IInstantiationService),
            __param(7, telemetry_1.ITelemetryService),
            __param(8, textfiles_1.ITextFileService),
            __param(9, backup_1.IBackupFileService),
            __param(10, environment_1.IEnvironmentService),
            __param(11, workspace_1.IWorkspaceContextService),
            __param(12, hashService_1.IHashService),
            __param(13, log_1.ILogService)
        ], TextFileEditorModel);
        return TextFileEditorModel;
    }(textEditorModel_1.BaseTextEditorModel));
    exports.TextFileEditorModel = TextFileEditorModel;
    var SaveSequentializer = /** @class */ (function () {
        function SaveSequentializer() {
        }
        SaveSequentializer.prototype.hasPendingSave = function (versionId) {
            if (!this._pendingSave) {
                return false;
            }
            if (typeof versionId === 'number') {
                return this._pendingSave.versionId === versionId;
            }
            return !!this._pendingSave;
        };
        Object.defineProperty(SaveSequentializer.prototype, "pendingSave", {
            get: function () {
                return this._pendingSave ? this._pendingSave.promise : void 0;
            },
            enumerable: true,
            configurable: true
        });
        SaveSequentializer.prototype.setPending = function (versionId, promise) {
            var _this = this;
            this._pendingSave = { versionId: versionId, promise: promise };
            promise.then(function () { return _this.donePending(versionId); }, function () { return _this.donePending(versionId); });
            return promise;
        };
        SaveSequentializer.prototype.donePending = function (versionId) {
            if (this._pendingSave && versionId === this._pendingSave.versionId) {
                // only set pending to done if the promise finished that is associated with that versionId
                this._pendingSave = void 0;
                // schedule the next save now that we are free if we have any
                this.triggerNextSave();
            }
        };
        SaveSequentializer.prototype.triggerNextSave = function () {
            if (this._nextSave) {
                var saveOperation = this._nextSave;
                this._nextSave = void 0;
                // Run next save and complete on the associated promise
                saveOperation.run().then(saveOperation.promiseValue, saveOperation.promiseError);
            }
        };
        SaveSequentializer.prototype.setNext = function (run) {
            // this is our first next save, so we create associated promise with it
            // so that we can return a promise that completes when the save operation
            // has completed.
            if (!this._nextSave) {
                var promiseValue_1;
                var promiseError_1;
                var promise = new winjs_base_1.TPromise(function (c, e) {
                    promiseValue_1 = c;
                    promiseError_1 = e;
                });
                this._nextSave = {
                    run: run,
                    promise: promise,
                    promiseValue: promiseValue_1,
                    promiseError: promiseError_1
                };
            }
            // we have a previous next save, just overwrite it
            else {
                this._nextSave.run = run;
            }
            return this._nextSave.promise;
        };
        return SaveSequentializer;
    }());
    exports.SaveSequentializer = SaveSequentializer;
    var DefaultSaveErrorHandler = /** @class */ (function () {
        function DefaultSaveErrorHandler(notificationService) {
            this.notificationService = notificationService;
        }
        DefaultSaveErrorHandler.prototype.onSaveError = function (error, model) {
            this.notificationService.error(nls.localize('genericSaveError', "Failed to save '{0}': {1}", path.basename(model.getResource().fsPath), errorMessage_1.toErrorMessage(error, false)));
        };
        DefaultSaveErrorHandler = __decorate([
            __param(0, notification_1.INotificationService)
        ], DefaultSaveErrorHandler);
        return DefaultSaveErrorHandler;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












































define(__m[393/*vs/codesandbox/services/codesandbox/saveParticipant*/], __M([0/*require*/,1/*exports*/,17/*vs/base/common/async*/,22/*vs/base/common/strings*/,96/*vs/editor/browser/services/codeEditorService*/,3/*vs/platform/instantiation/common/instantiation*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,135/*vs/editor/common/core/position*/,439/*vs/editor/common/commands/trimTrailingWhitespaceCommand*/,438/*vs/editor/contrib/format/format*/,437/*vs/editor/contrib/format/formattingEdit*/,7/*vs/platform/configuration/common/configuration*/,123/*vs/workbench/services/textfile/common/textFileEditorModel*/,89/*vs/editor/common/core/editOperation*/,397/*vs/editor/common/services/editorWorkerService*/,207/*vs/workbench/services/progress/common/progress*/,2/*vs/nls*/,19/*vs/base/common/arrays*/,86/*vs/platform/log/common/log*/,136/*vs/editor/contrib/snippet/snippetController2*/,37/*vs/platform/commands/common/commands*/,436/*vs/editor/contrib/codeAction/codeActionTrigger*/,435/*vs/editor/contrib/codeAction/codeActionCommands*/,434/*vs/editor/contrib/codeAction/codeAction*/,386/*vs/editor/browser/services/bulkEditService*/,55/*vs/base/common/cancellation*/]), function (require, exports, async_1, strings, codeEditorService_1, instantiation_1, range_1, selection_1, position_1, trimTrailingWhitespaceCommand_1, format_1, formattingEdit_1, configuration_1, textFileEditorModel_1, editOperation_1, editorWorkerService_1, progress_1, nls_1, arrays_1, log_1, snippetController2_1, commands_1, codeActionTrigger_1, codeActionCommands_1, codeAction_1, bulkEditService_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TrimWhitespaceParticipant = /** @class */ (function () {
        function TrimWhitespaceParticipant(configurationService, codeEditorService) {
            this.configurationService = configurationService;
            this.codeEditorService = codeEditorService;
            // Nothing
        }
        TrimWhitespaceParticipant.prototype.participate = function (model, env) {
            if (this.configurationService.getValue('files.trimTrailingWhitespace', {
                overrideIdentifier: model.textEditorModel.getLanguageIdentifier()
                    .language,
                resource: model.getResource(),
            })) {
                this.doTrimTrailingWhitespace(model.textEditorModel, env.reason === 2 /* AUTO */);
            }
        };
        TrimWhitespaceParticipant.prototype.doTrimTrailingWhitespace = function (model, isAutoSaved) {
            var prevSelection = [];
            var cursors = [];
            var editor = findEditor(model, this.codeEditorService);
            if (editor) {
                // Find `prevSelection` in any case do ensure a good undo stack when pushing the edit
                // Collect active cursors in `cursors` only if `isAutoSaved` to avoid having the cursors jump
                prevSelection = editor.getSelections();
                if (isAutoSaved) {
                    cursors = prevSelection.map(function (s) { return s.getPosition(); });
                    var snippetsRange = snippetController2_1.SnippetController2.get(editor).getSessionEnclosingRange();
                    if (snippetsRange) {
                        for (var lineNumber = snippetsRange.startLineNumber; lineNumber <= snippetsRange.endLineNumber; lineNumber++) {
                            cursors.push(new position_1.Position(lineNumber, model.getLineMaxColumn(lineNumber)));
                        }
                    }
                }
            }
            var ops = trimTrailingWhitespaceCommand_1.trimTrailingWhitespace(model, cursors);
            if (!ops.length) {
                return; // Nothing to do
            }
            model.pushEditOperations(prevSelection, ops, function (edits) { return prevSelection; });
        };
        TrimWhitespaceParticipant = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, codeEditorService_1.ICodeEditorService)
        ], TrimWhitespaceParticipant);
        return TrimWhitespaceParticipant;
    }());
    function findEditor(model, codeEditorService) {
        var candidate = null;
        if (model.isAttachedToEditor()) {
            for (var _i = 0, _a = codeEditorService.listCodeEditors(); _i < _a.length; _i++) {
                var editor = _a[_i];
                if (editor.getModel() === model) {
                    if (editor.hasTextFocus()) {
                        return editor; // favour focused editor if there are multiple
                    }
                    candidate = editor;
                }
            }
        }
        return candidate;
    }
    var FinalNewLineParticipant = /** @class */ (function () {
        function FinalNewLineParticipant(configurationService, codeEditorService) {
            this.configurationService = configurationService;
            this.codeEditorService = codeEditorService;
            // Nothing
        }
        FinalNewLineParticipant.prototype.participate = function (model, env) {
            if (this.configurationService.getValue('files.insertFinalNewline', {
                overrideIdentifier: model.textEditorModel.getLanguageIdentifier()
                    .language,
                resource: model.getResource(),
            })) {
                this.doInsertFinalNewLine(model.textEditorModel);
            }
        };
        FinalNewLineParticipant.prototype.doInsertFinalNewLine = function (model) {
            var lineCount = model.getLineCount();
            var lastLine = model.getLineContent(lineCount);
            var lastLineIsEmptyOrWhitespace = strings.lastNonWhitespaceIndex(lastLine) === -1;
            if (!lineCount || lastLineIsEmptyOrWhitespace) {
                return;
            }
            var prevSelection = [];
            var editor = findEditor(model, this.codeEditorService);
            if (editor) {
                prevSelection = editor.getSelections();
            }
            model.pushEditOperations(prevSelection, [
                editOperation_1.EditOperation.insert(new position_1.Position(lineCount, model.getLineMaxColumn(lineCount)), model.getEOL()),
            ], function (edits) { return prevSelection; });
            if (editor) {
                editor.setSelections(prevSelection);
            }
        };
        FinalNewLineParticipant = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, codeEditorService_1.ICodeEditorService)
        ], FinalNewLineParticipant);
        return FinalNewLineParticipant;
    }());
    exports.FinalNewLineParticipant = FinalNewLineParticipant;
    var TrimFinalNewLinesParticipant = /** @class */ (function () {
        function TrimFinalNewLinesParticipant(configurationService, codeEditorService) {
            this.configurationService = configurationService;
            this.codeEditorService = codeEditorService;
            // Nothing
        }
        TrimFinalNewLinesParticipant.prototype.participate = function (model, env) {
            if (this.configurationService.getValue('files.trimFinalNewlines', {
                overrideIdentifier: model.textEditorModel.getLanguageIdentifier()
                    .language,
                resource: model.getResource(),
            })) {
                this.doTrimFinalNewLines(model.textEditorModel, env.reason === 2 /* AUTO */);
            }
        };
        /**
           * returns 0 if the entire file is empty or whitespace only
           */
        TrimFinalNewLinesParticipant.prototype.findLastLineWithContent = function (model) {
            for (var lineNumber = model.getLineCount(); lineNumber >= 1; lineNumber--) {
                var lineContent = model.getLineContent(lineNumber);
                if (strings.lastNonWhitespaceIndex(lineContent) !== -1) {
                    // this line has content
                    return lineNumber;
                }
            }
            // no line has content
            return 0;
        };
        TrimFinalNewLinesParticipant.prototype.doTrimFinalNewLines = function (model, isAutoSaved) {
            var lineCount = model.getLineCount();
            // Do not insert new line if file does not end with new line
            if (lineCount === 1) {
                return;
            }
            var prevSelection = [];
            var cannotTouchLineNumber = 0;
            var editor = findEditor(model, this.codeEditorService);
            if (editor) {
                prevSelection = editor.getSelections();
                if (isAutoSaved) {
                    for (var i = 0, len = prevSelection.length; i < len; i++) {
                        var positionLineNumber = prevSelection[i].positionLineNumber;
                        if (positionLineNumber > cannotTouchLineNumber) {
                            cannotTouchLineNumber = positionLineNumber;
                        }
                    }
                }
            }
            var lastLineNumberWithContent = this.findLastLineWithContent(model);
            var deleteFromLineNumber = Math.max(lastLineNumberWithContent + 1, cannotTouchLineNumber + 1);
            var deletionRange = model.validateRange(new range_1.Range(deleteFromLineNumber, 1, lineCount, model.getLineMaxColumn(lineCount)));
            if (deletionRange.isEmpty()) {
                return;
            }
            model.pushEditOperations(prevSelection, [editOperation_1.EditOperation.delete(deletionRange)], function (edits) { return prevSelection; });
            if (editor) {
                editor.setSelections(prevSelection);
            }
        };
        TrimFinalNewLinesParticipant = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, codeEditorService_1.ICodeEditorService)
        ], TrimFinalNewLinesParticipant);
        return TrimFinalNewLinesParticipant;
    }());
    exports.TrimFinalNewLinesParticipant = TrimFinalNewLinesParticipant;
    var FormatOnSaveParticipant = /** @class */ (function () {
        function FormatOnSaveParticipant(_editorService, _editorWorkerService, _configurationService) {
            this._editorService = _editorService;
            this._editorWorkerService = _editorWorkerService;
            this._configurationService = _configurationService;
            // Nothing
        }
        FormatOnSaveParticipant.prototype.participate = function (editorModel, env) {
            var _this = this;
            var model = editorModel.textEditorModel;
            if (env.reason === 2 /* AUTO */ ||
                !this._configurationService.getValue('editor.formatOnSave', {
                    overrideIdentifier: model.getLanguageIdentifier().language,
                    resource: editorModel.getResource(),
                })) {
                return undefined;
            }
            var versionNow = model.getVersionId();
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            var timeout = this._configurationService.getValue('editor.formatOnSaveTimeout', {
                overrideIdentifier: model.getLanguageIdentifier().language,
                resource: editorModel.getResource(),
            });
            return new Promise(function (resolve, reject) {
                var source = new cancellation_1.CancellationTokenSource();
                var request = format_1.getDocumentFormattingEdits(model, { tabSize: tabSize, insertSpaces: insertSpaces }, source.token);
                setTimeout(function () {
                    reject(nls_1.localize('timeout.formatOnSave', 'Aborted format on save after {0}ms', timeout));
                    source.cancel();
                }, timeout);
                request
                    .then(function (edits) {
                    return _this._editorWorkerService.computeMoreMinimalEdits(model.uri, edits);
                })
                    .then(resolve, function (err) {
                    if (!(err instanceof Error) || err.name !== format_1.NoProviderError.Name) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }).then(function (edits) {
                if (!arrays_1.isFalsyOrEmpty(edits) && versionNow === model.getVersionId()) {
                    var editor = findEditor(model, _this._editorService);
                    if (editor) {
                        _this._editsWithEditor(editor, edits);
                    }
                    else {
                        _this._editWithModel(model, edits);
                    }
                }
            });
        };
        FormatOnSaveParticipant.prototype._editsWithEditor = function (editor, edits) {
            formattingEdit_1.FormattingEdit.execute(editor, edits);
        };
        FormatOnSaveParticipant.prototype._editWithModel = function (model, edits) {
            var range = edits[0].range;
            var initialSelection = new selection_1.Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
            model.pushEditOperations([initialSelection], edits.map(FormatOnSaveParticipant._asIdentEdit), function (undoEdits) {
                for (var _i = 0, undoEdits_1 = undoEdits; _i < undoEdits_1.length; _i++) {
                    var range_2 = undoEdits_1[_i].range;
                    if (range_1.Range.areIntersectingOrTouching(range_2, initialSelection)) {
                        return [
                            new selection_1.Selection(range_2.startLineNumber, range_2.startColumn, range_2.endLineNumber, range_2.endColumn),
                        ];
                    }
                }
                return undefined;
            });
        };
        FormatOnSaveParticipant._asIdentEdit = function (_a) {
            var text = _a.text, range = _a.range;
            return {
                text: text,
                range: range_1.Range.lift(range),
                forceMoveMarkers: true,
            };
        };
        FormatOnSaveParticipant = __decorate([
            __param(0, codeEditorService_1.ICodeEditorService),
            __param(1, editorWorkerService_1.IEditorWorkerService),
            __param(2, configuration_1.IConfigurationService)
        ], FormatOnSaveParticipant);
        return FormatOnSaveParticipant;
    }());
    var CodeActionOnParticipant = /** @class */ (function () {
        function CodeActionOnParticipant(_bulkEditService, _commandService, _configurationService) {
            this._bulkEditService = _bulkEditService;
            this._commandService = _commandService;
            this._configurationService = _configurationService;
        }
        CodeActionOnParticipant.prototype.participate = function (editorModel, env) {
            return __awaiter(this, void 0, void 0, function () {
                var model, settingsOverrides, setting, codeActionsOnSave, timeout;
                var _this = this;
                return __generator(this, function (_a) {
                    if (env.reason === 2 /* AUTO */) {
                        return [2 /*return*/, undefined];
                    }
                    model = editorModel.textEditorModel;
                    settingsOverrides = {
                        overrideIdentifier: model.getLanguageIdentifier().language,
                        resource: editorModel.getResource(),
                    };
                    setting = this._configurationService.getValue('editor.codeActionsOnSave', settingsOverrides);
                    if (!setting) {
                        return [2 /*return*/, undefined];
                    }
                    codeActionsOnSave = Object.keys(setting)
                        .filter(function (x) { return setting[x]; })
                        .map(function (x) { return new codeActionTrigger_1.CodeActionKind(x); });
                    if (!codeActionsOnSave.length) {
                        return [2 /*return*/, undefined];
                    }
                    timeout = this._configurationService.getValue('editor.codeActionsOnSaveTimeout', settingsOverrides);
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            setTimeout(function () {
                                return reject(nls_1.localize('codeActionsOnSave.didTimeout', 'Aborted codeActionsOnSave after {0}ms', timeout));
                            }, timeout);
                            _this.getActionsToRun(model, codeActionsOnSave).then(resolve);
                        }).then(function (actionsToRun) { return _this.applyCodeActions(actionsToRun); })];
                });
            });
        };
        CodeActionOnParticipant.prototype.applyCodeActions = function (actionsToRun) {
            return __awaiter(this, void 0, void 0, function () {
                var _i, actionsToRun_1, action;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _i = 0, actionsToRun_1 = actionsToRun;
                            _a.label = 1;
                        case 1:
                            if (!(_i < actionsToRun_1.length)) return [3 /*break*/, 4];
                            action = actionsToRun_1[_i];
                            return [4 /*yield*/, codeActionCommands_1.applyCodeAction(action, this._bulkEditService, this._commandService)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        CodeActionOnParticipant.prototype.getActionsToRun = function (model, codeActionsOnSave) {
            return __awaiter(this, void 0, void 0, function () {
                var actions, actionsToRun;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, codeAction_1.getCodeActions(model, model.getFullModelRange(), {
                                type: 'auto',
                                filter: { kind: codeActionTrigger_1.CodeActionKind.Source, includeSourceActions: true },
                            })];
                        case 1:
                            actions = _a.sent();
                            actionsToRun = actions.filter(function (returnedAction) {
                                return returnedAction.kind &&
                                    codeActionsOnSave.some(function (onSaveKind) {
                                        return onSaveKind.contains(returnedAction.kind);
                                    });
                            });
                            return [2 /*return*/, actionsToRun];
                    }
                });
            });
        };
        CodeActionOnParticipant = __decorate([
            __param(0, bulkEditService_1.IBulkEditService),
            __param(1, commands_1.ICommandService),
            __param(2, configuration_1.IConfigurationService)
        ], CodeActionOnParticipant);
        return CodeActionOnParticipant;
    }());
    // The save participant can change a model before its saved to support various scenarios like trimming trailing whitespace
    var SaveParticipant = /** @class */ (function () {
        function SaveParticipant(instantiationService, _progressService, _logService) {
            this._progressService = _progressService;
            this._logService = _logService;
            this._saveParticipants = new async_1.IdleValue(function () { return [
                instantiationService.createInstance(TrimWhitespaceParticipant),
                instantiationService.createInstance(CodeActionOnParticipant),
                instantiationService.createInstance(FormatOnSaveParticipant),
                instantiationService.createInstance(FinalNewLineParticipant),
                instantiationService.createInstance(TrimFinalNewLinesParticipant),
            ]; });
            // Hook into model
            textFileEditorModel_1.TextFileEditorModel.setSaveParticipant(this);
        }
        SaveParticipant.prototype.dispose = function () {
            textFileEditorModel_1.TextFileEditorModel.setSaveParticipant(undefined);
            this._saveParticipants.dispose();
        };
        SaveParticipant.prototype.participate = function (model, env) {
            var _this = this;
            return this._progressService.withProgress({ location: 10 /* Window */ }, function (progress) {
                progress.report({
                    message: nls_1.localize('saveParticipants', 'Running Save Participants...'),
                });
                var promiseFactory = _this._saveParticipants
                    .getValue()
                    .map(function (p) { return function () {
                    return Promise.resolve(p.participate(model, env));
                }; });
                return async_1.sequence(promiseFactory).then(function () { }, function (err) { return _this._logService.warn(err); });
            });
        };
        SaveParticipant = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, progress_1.IProgressService2),
            __param(2, log_1.ILogService)
        ], SaveParticipant);
        return SaveParticipant;
    }());
    exports.SaveParticipant = SaveParticipant;
});























define(__m[401/*vs/workbench/services/textfile/common/textFileEditorModelManager*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,5/*vs/base/common/winjs.base*/,123/*vs/workbench/services/textfile/common/textFileEditorModel*/,4/*vs/base/common/lifecycle*/,27/*vs/workbench/services/textfile/common/textfiles*/,63/*vs/platform/lifecycle/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/,39/*vs/base/common/map*/,25/*vs/base/common/errors*/]), function (require, exports, event_1, winjs_base_1, textFileEditorModel_1, lifecycle_1, textfiles_1, lifecycle_2, instantiation_1, map_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextFileEditorModelManager = /** @class */ (function (_super) {
        __extends(TextFileEditorModelManager, _super);
        function TextFileEditorModelManager(lifecycleService, instantiationService) {
            var _this = _super.call(this) || this;
            _this.lifecycleService = lifecycleService;
            _this.instantiationService = instantiationService;
            _this._onModelDisposed = _this._register(new event_1.Emitter());
            _this._onModelContentChanged = _this._register(new event_1.Emitter());
            _this._onModelDirty = _this._register(new event_1.Emitter());
            _this._onModelSaveError = _this._register(new event_1.Emitter());
            _this._onModelSaved = _this._register(new event_1.Emitter());
            _this._onModelReverted = _this._register(new event_1.Emitter());
            _this._onModelEncodingChanged = _this._register(new event_1.Emitter());
            _this._onModelOrphanedChanged = _this._register(new event_1.Emitter());
            _this.mapResourceToModel = new map_1.ResourceMap();
            _this.mapResourceToDisposeListener = new map_1.ResourceMap();
            _this.mapResourceToStateChangeListener = new map_1.ResourceMap();
            _this.mapResourceToModelContentChangeListener = new map_1.ResourceMap();
            _this.mapResourceToPendingModelLoaders = new map_1.ResourceMap();
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelDisposed", {
            get: function () { return this._onModelDisposed.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelContentChanged", {
            get: function () { return this._onModelContentChanged.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelDirty", {
            get: function () { return this._onModelDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaveError", {
            get: function () { return this._onModelSaveError.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelSaved", {
            get: function () { return this._onModelSaved.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelReverted", {
            get: function () { return this._onModelReverted.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelEncodingChanged", {
            get: function () { return this._onModelEncodingChanged.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelOrphanedChanged", {
            get: function () { return this._onModelOrphanedChanged.event; },
            enumerable: true,
            configurable: true
        });
        TextFileEditorModelManager.prototype.registerListeners = function () {
            // Lifecycle
            this.lifecycleService.onShutdown(this.dispose, this);
        };
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsDirty", {
            get: function () {
                if (!this._onModelsDirtyEvent) {
                    this._onModelsDirtyEvent = this.debounce(this.onModelDirty);
                }
                return this._onModelsDirtyEvent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsSaveError", {
            get: function () {
                if (!this._onModelsSaveError) {
                    this._onModelsSaveError = this.debounce(this.onModelSaveError);
                }
                return this._onModelsSaveError;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsSaved", {
            get: function () {
                if (!this._onModelsSaved) {
                    this._onModelsSaved = this.debounce(this.onModelSaved);
                }
                return this._onModelsSaved;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileEditorModelManager.prototype, "onModelsReverted", {
            get: function () {
                if (!this._onModelsReverted) {
                    this._onModelsReverted = this.debounce(this.onModelReverted);
                }
                return this._onModelsReverted;
            },
            enumerable: true,
            configurable: true
        });
        TextFileEditorModelManager.prototype.debounce = function (event) {
            return event_1.debounceEvent(event, function (prev, cur) {
                if (!prev) {
                    prev = [cur];
                }
                else {
                    prev.push(cur);
                }
                return prev;
            }, this.debounceDelay());
        };
        TextFileEditorModelManager.prototype.debounceDelay = function () {
            return 250;
        };
        TextFileEditorModelManager.prototype.get = function (resource) {
            return this.mapResourceToModel.get(resource);
        };
        TextFileEditorModelManager.prototype.loadOrCreate = function (resource, options) {
            var _this = this;
            // Return early if model is currently being loaded
            var pendingLoad = this.mapResourceToPendingModelLoaders.get(resource);
            if (pendingLoad) {
                return pendingLoad;
            }
            var modelPromise;
            // Model exists
            var model = this.get(resource);
            if (model) {
                if (options && options.reload) {
                    // async reload: trigger a reload but return immediately
                    if (options.reload.async) {
                        modelPromise = winjs_base_1.TPromise.as(model);
                        model.load(options).then(null, errors_1.onUnexpectedError);
                    }
                    // sync reload: do not return until model reloaded
                    else {
                        modelPromise = model.load(options);
                    }
                }
                else {
                    modelPromise = winjs_base_1.TPromise.as(model);
                }
            }
            // Model does not exist
            else {
                model = this.instantiationService.createInstance(textFileEditorModel_1.TextFileEditorModel, resource, options ? options.encoding : void 0);
                modelPromise = model.load(options);
                // Install state change listener
                this.mapResourceToStateChangeListener.set(resource, model.onDidStateChange(function (state) {
                    var event = new textfiles_1.TextFileModelChangeEvent(model, state);
                    switch (state) {
                        case 0 /* DIRTY */:
                            _this._onModelDirty.fire(event);
                            break;
                        case 2 /* SAVE_ERROR */:
                            _this._onModelSaveError.fire(event);
                            break;
                        case 3 /* SAVED */:
                            _this._onModelSaved.fire(event);
                            break;
                        case 4 /* REVERTED */:
                            _this._onModelReverted.fire(event);
                            break;
                        case 5 /* ENCODING */:
                            _this._onModelEncodingChanged.fire(event);
                            break;
                        case 7 /* ORPHANED_CHANGE */:
                            _this._onModelOrphanedChanged.fire(event);
                            break;
                    }
                }));
                // Install model content change listener
                this.mapResourceToModelContentChangeListener.set(resource, model.onDidContentChange(function (e) {
                    _this._onModelContentChanged.fire(new textfiles_1.TextFileModelChangeEvent(model, e));
                }));
            }
            // Store pending loads to avoid race conditions
            this.mapResourceToPendingModelLoaders.set(resource, modelPromise);
            return modelPromise.then(function (model) {
                // Make known to manager (if not already known)
                _this.add(resource, model);
                // Model can be dirty if a backup was restored, so we make sure to have this event delivered
                if (model.isDirty()) {
                    _this._onModelDirty.fire(new textfiles_1.TextFileModelChangeEvent(model, 0 /* DIRTY */));
                }
                // Remove from pending loads
                _this.mapResourceToPendingModelLoaders.delete(resource);
                return model;
            }, function (error) {
                // Free resources of this invalid model
                model.dispose();
                // Remove from pending loads
                _this.mapResourceToPendingModelLoaders.delete(resource);
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        TextFileEditorModelManager.prototype.getAll = function (resource, filter) {
            if (resource) {
                var res_1 = this.mapResourceToModel.get(resource);
                return res_1 ? [res_1] : [];
            }
            var res = [];
            this.mapResourceToModel.forEach(function (model) {
                if (!filter || filter(model)) {
                    res.push(model);
                }
            });
            return res;
        };
        TextFileEditorModelManager.prototype.add = function (resource, model) {
            var _this = this;
            var knownModel = this.mapResourceToModel.get(resource);
            if (knownModel === model) {
                return; // already cached
            }
            // dispose any previously stored dispose listener for this resource
            var disposeListener = this.mapResourceToDisposeListener.get(resource);
            if (disposeListener) {
                disposeListener.dispose();
            }
            // store in cache but remove when model gets disposed
            this.mapResourceToModel.set(resource, model);
            this.mapResourceToDisposeListener.set(resource, model.onDispose(function () {
                _this.remove(resource);
                _this._onModelDisposed.fire(resource);
            }));
        };
        TextFileEditorModelManager.prototype.remove = function (resource) {
            this.mapResourceToModel.delete(resource);
            var disposeListener = this.mapResourceToDisposeListener.get(resource);
            if (disposeListener) {
                lifecycle_1.dispose(disposeListener);
                this.mapResourceToDisposeListener.delete(resource);
            }
            var stateChangeListener = this.mapResourceToStateChangeListener.get(resource);
            if (stateChangeListener) {
                lifecycle_1.dispose(stateChangeListener);
                this.mapResourceToStateChangeListener.delete(resource);
            }
            var modelContentChangeListener = this.mapResourceToModelContentChangeListener.get(resource);
            if (modelContentChangeListener) {
                lifecycle_1.dispose(modelContentChangeListener);
                this.mapResourceToModelContentChangeListener.delete(resource);
            }
        };
        TextFileEditorModelManager.prototype.clear = function () {
            // model caches
            this.mapResourceToModel.clear();
            this.mapResourceToPendingModelLoaders.clear();
            // dispose dispose listeners
            this.mapResourceToDisposeListener.forEach(function (l) { return l.dispose(); });
            this.mapResourceToDisposeListener.clear();
            // dispose state change listeners
            this.mapResourceToStateChangeListener.forEach(function (l) { return l.dispose(); });
            this.mapResourceToStateChangeListener.clear();
            // dispose model content change listeners
            this.mapResourceToModelContentChangeListener.forEach(function (l) { return l.dispose(); });
            this.mapResourceToModelContentChangeListener.clear();
        };
        TextFileEditorModelManager.prototype.disposeModel = function (model) {
            if (!model) {
                return; // we need data!
            }
            if (model.isDisposed()) {
                return; // already disposed
            }
            if (this.mapResourceToPendingModelLoaders.has(model.getResource())) {
                return; // not yet loaded
            }
            if (model.isDirty()) {
                return; // not saved
            }
            model.dispose();
        };
        TextFileEditorModelManager = __decorate([
            __param(0, lifecycle_2.ILifecycleService),
            __param(1, instantiation_1.IInstantiationService)
        ], TextFileEditorModelManager);
        return TextFileEditorModelManager;
    }(lifecycle_1.Disposable));
    exports.TextFileEditorModelManager = TextFileEditorModelManager;
});

















































define(__m[402/*vs/workbench/services/textfile/common/textFileService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,12/*vs/base/common/uri*/,24/*vs/base/common/paths*/,25/*vs/base/common/errors*/,38/*vs/base/common/objects*/,6/*vs/base/common/event*/,18/*vs/base/common/platform*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,4/*vs/base/common/lifecycle*/,401/*vs/workbench/services/textfile/common/textFileEditorModelManager*/,39/*vs/base/common/map*/,26/*vs/base/common/network*/,73/*vs/editor/common/model/textModel*/,35/*vs/base/common/resources*/]), function (require, exports, nls, winjs_base_1, uri_1, paths, errors, objects, event_1, platform, textfiles_1, files_1, lifecycle_1, textFileEditorModelManager_1, map_1, network_1, textModel_1, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The workbench file service implementation implements the raw file service spec and adds additional methods on top.
     *
     * It also adds diagnostics and logging around file system operations.
     */
    var TextFileService = /** @class */ (function (_super) {
        __extends(TextFileService, _super);
        function TextFileService(lifecycleService, contextService, configurationService, fileService, untitledEditorService, instantiationService, notificationService, environmentService, backupFileService, windowsService, windowService, historyService, contextKeyService, modelService) {
            var _this = _super.call(this) || this;
            _this.lifecycleService = lifecycleService;
            _this.contextService = contextService;
            _this.configurationService = configurationService;
            _this.fileService = fileService;
            _this.untitledEditorService = untitledEditorService;
            _this.instantiationService = instantiationService;
            _this.notificationService = notificationService;
            _this.environmentService = environmentService;
            _this.backupFileService = backupFileService;
            _this.windowsService = windowsService;
            _this.windowService = windowService;
            _this.historyService = historyService;
            _this.modelService = modelService;
            _this._onAutoSaveConfigurationChange = _this._register(new event_1.Emitter());
            _this._onFilesAssociationChange = _this._register(new event_1.Emitter());
            _this._onWillMove = _this._register(new event_1.Emitter());
            _this._models = _this.instantiationService.createInstance(textFileEditorModelManager_1.TextFileEditorModelManager);
            _this.autoSaveContext = textfiles_1.AutoSaveContext.bindTo(contextKeyService);
            var configuration = _this.configurationService.getValue();
            _this.currentFilesAssociationConfig = configuration && configuration.files && configuration.files.associations;
            _this.onFilesConfigurationChange(configuration);
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(TextFileService.prototype, "onAutoSaveConfigurationChange", {
            get: function () { return this._onAutoSaveConfigurationChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileService.prototype, "onFilesAssociationChange", {
            get: function () { return this._onFilesAssociationChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileService.prototype, "onWillMove", {
            get: function () { return this._onWillMove.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextFileService.prototype, "models", {
            get: function () {
                return this._models;
            },
            enumerable: true,
            configurable: true
        });
        TextFileService.prototype.registerListeners = function () {
            var _this = this;
            // Lifecycle
            this.lifecycleService.onWillShutdown(function (event) { return event.veto(_this.beforeShutdown(event.reason)); });
            this.lifecycleService.onShutdown(this.dispose, this);
            // Files configuration changes
            this._register(this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('files')) {
                    _this.onFilesConfigurationChange(_this.configurationService.getValue());
                }
            }));
        };
        TextFileService.prototype.beforeShutdown = function (reason) {
            var _this = this;
            // Dirty files need treatment on shutdown
            var dirty = this.getDirty();
            if (dirty.length) {
                // If auto save is enabled, save all files and then check again for dirty files
                // We DO NOT run any save participant if we are in the shutdown phase for performance reasons
                var handleAutoSave = void 0;
                if (this.getAutoSaveMode() !== 0 /* OFF */) {
                    handleAutoSave = this.saveAll(false /* files only */, { skipSaveParticipants: true }).then(function () { return _this.getDirty(); });
                }
                else {
                    handleAutoSave = winjs_base_1.TPromise.as(dirty);
                }
                return handleAutoSave.then(function (dirty) {
                    // If we still have dirty files, we either have untitled ones or files that cannot be saved
                    // or auto save was not enabled and as such we did not save any dirty files to disk automatically
                    if (dirty.length) {
                        // If hot exit is enabled, backup dirty files and allow to exit without confirmation
                        if (_this.isHotExitEnabled) {
                            return _this.backupBeforeShutdown(dirty, _this.models, reason).then(function (result) {
                                if (result.didBackup) {
                                    return _this.noVeto({ cleanUpBackups: false }); // no veto and no backup cleanup (since backup was successful)
                                }
                                // since a backup did not happen, we have to confirm for the dirty files now
                                return _this.confirmBeforeShutdown();
                            }, function (errors) {
                                var firstError = errors[0];
                                _this.notificationService.error(nls.localize('files.backup.failSave', "Files that are dirty could not be written to the backup location (Error: {0}). Try saving your files first and then exit.", firstError.message));
                                return true; // veto, the backups failed
                            });
                        }
                        // Otherwise just confirm from the user what to do with the dirty files
                        return _this.confirmBeforeShutdown();
                    }
                    return void 0;
                });
            }
            // No dirty files: no veto
            return this.noVeto({ cleanUpBackups: true });
        };
        TextFileService.prototype.backupBeforeShutdown = function (dirtyToBackup, textFileEditorModelManager, reason) {
            var _this = this;
            return this.windowsService.getWindowCount().then(function (windowCount) {
                // When quit is requested skip the confirm callback and attempt to backup all workspaces.
                // When quit is not requested the confirm callback should be shown when the window being
                // closed is the only VS Code window open, except for on Mac where hot exit is only
                // ever activated when quit is requested.
                var doBackup;
                switch (reason) {
                    case 1 /* CLOSE */:
                        if (_this.contextService.getWorkbenchState() !== 1 /* EMPTY */ && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
                            doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured
                        }
                        else if (windowCount > 1 || platform.isMacintosh) {
                            doBackup = false; // do not backup if a window is closed that does not cause quitting of the application
                        }
                        else {
                            doBackup = true; // backup if last window is closed on win/linux where the application quits right after
                        }
                        break;
                    case 2 /* QUIT */:
                        doBackup = true; // backup because next start we restore all backups
                        break;
                    case 3 /* RELOAD */:
                        doBackup = true; // backup because after window reload, backups restore
                        break;
                    case 4 /* LOAD */:
                        if (_this.contextService.getWorkbenchState() !== 1 /* EMPTY */ && _this.configuredHotExit === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
                            doBackup = true; // backup if a folder is open and onExitAndWindowClose is configured
                        }
                        else {
                            doBackup = false; // do not backup because we are switching contexts
                        }
                        break;
                }
                if (!doBackup) {
                    return winjs_base_1.TPromise.as({ didBackup: false });
                }
                // Backup
                return _this.backupAll(dirtyToBackup, textFileEditorModelManager).then(function () { return { didBackup: true }; });
            });
        };
        TextFileService.prototype.backupAll = function (dirtyToBackup, textFileEditorModelManager) {
            var _this = this;
            // split up between files and untitled
            var filesToBackup = [];
            var untitledToBackup = [];
            dirtyToBackup.forEach(function (s) {
                if (_this.fileService.canHandleResource(s)) {
                    filesToBackup.push(textFileEditorModelManager.get(s));
                }
                else if (s.scheme === network_1.Schemas.untitled) {
                    untitledToBackup.push(s);
                }
            });
            return this.doBackupAll(filesToBackup, untitledToBackup);
        };
        TextFileService.prototype.doBackupAll = function (dirtyFileModels, untitledResources) {
            var _this = this;
            // Handle file resources first
            return winjs_base_1.TPromise.join(dirtyFileModels.map(function (model) { return _this.backupFileService.backupResource(model.getResource(), model.createSnapshot(), model.getVersionId()); })).then(function (results) {
                // Handle untitled resources
                var untitledModelPromises = untitledResources
                    .filter(function (untitled) { return _this.untitledEditorService.exists(untitled); })
                    .map(function (untitled) { return _this.untitledEditorService.loadOrCreate({ resource: untitled }); });
                return winjs_base_1.TPromise.join(untitledModelPromises).then(function (untitledModels) {
                    var untitledBackupPromises = untitledModels.map(function (model) {
                        return _this.backupFileService.backupResource(model.getResource(), model.createSnapshot(), model.getVersionId());
                    });
                    return winjs_base_1.TPromise.join(untitledBackupPromises).then(function () { return void 0; });
                });
            });
        };
        TextFileService.prototype.confirmBeforeShutdown = function () {
            var _this = this;
            return this.confirmSave().then(function (confirm) {
                // Save
                if (confirm === 0 /* SAVE */) {
                    return _this.saveAll(true /* includeUntitled */, { skipSaveParticipants: true }).then(function (result) {
                        if (result.results.some(function (r) { return !r.success; })) {
                            return true; // veto if some saves failed
                        }
                        return _this.noVeto({ cleanUpBackups: true });
                    });
                }
                // Don't Save
                else if (confirm === 1 /* DONT_SAVE */) {
                    // Make sure to revert untitled so that they do not restore
                    // see https://github.com/Microsoft/vscode/issues/29572
                    _this.untitledEditorService.revertAll();
                    return _this.noVeto({ cleanUpBackups: true });
                }
                // Cancel
                else if (confirm === 2 /* CANCEL */) {
                    return true; // veto
                }
                return void 0;
            });
        };
        TextFileService.prototype.noVeto = function (options) {
            if (!options.cleanUpBackups) {
                return false;
            }
            return this.cleanupBackupsBeforeShutdown().then(function () { return false; }, function () { return false; });
        };
        TextFileService.prototype.cleanupBackupsBeforeShutdown = function () {
            if (this.environmentService.isExtensionDevelopment) {
                return winjs_base_1.TPromise.as(void 0);
            }
            return this.backupFileService.discardAllWorkspaceBackups();
        };
        TextFileService.prototype.onFilesConfigurationChange = function (configuration) {
            var wasAutoSaveEnabled = (this.getAutoSaveMode() !== 0 /* OFF */);
            var autoSaveMode = (configuration && configuration.files && configuration.files.autoSave) || files_1.AutoSaveConfiguration.OFF;
            this.autoSaveContext.set(autoSaveMode);
            switch (autoSaveMode) {
                case files_1.AutoSaveConfiguration.AFTER_DELAY:
                    this.configuredAutoSaveDelay = configuration && configuration.files && configuration.files.autoSaveDelay;
                    this.configuredAutoSaveOnFocusChange = false;
                    this.configuredAutoSaveOnWindowChange = false;
                    break;
                case files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE:
                    this.configuredAutoSaveDelay = void 0;
                    this.configuredAutoSaveOnFocusChange = true;
                    this.configuredAutoSaveOnWindowChange = false;
                    break;
                case files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE:
                    this.configuredAutoSaveDelay = void 0;
                    this.configuredAutoSaveOnFocusChange = false;
                    this.configuredAutoSaveOnWindowChange = true;
                    break;
                default:
                    this.configuredAutoSaveDelay = void 0;
                    this.configuredAutoSaveOnFocusChange = false;
                    this.configuredAutoSaveOnWindowChange = false;
                    break;
            }
            // Emit as event
            this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
            // save all dirty when enabling auto save
            if (!wasAutoSaveEnabled && this.getAutoSaveMode() !== 0 /* OFF */) {
                this.saveAll();
            }
            // Check for change in files associations
            var filesAssociation = configuration && configuration.files && configuration.files.associations;
            if (!objects.equals(this.currentFilesAssociationConfig, filesAssociation)) {
                this.currentFilesAssociationConfig = filesAssociation;
                this._onFilesAssociationChange.fire();
            }
            // Hot exit
            var hotExitMode = configuration && configuration.files && configuration.files.hotExit;
            if (hotExitMode === files_1.HotExitConfiguration.OFF || hotExitMode === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
                this.configuredHotExit = hotExitMode;
            }
            else {
                this.configuredHotExit = files_1.HotExitConfiguration.ON_EXIT;
            }
        };
        TextFileService.prototype.getDirty = function (resources) {
            // Collect files
            var dirty = this.getDirtyFileModels(resources).map(function (m) { return m.getResource(); });
            // Add untitled ones
            dirty.push.apply(dirty, this.untitledEditorService.getDirty(resources));
            return dirty;
        };
        TextFileService.prototype.isDirty = function (resource) {
            // Check for dirty file
            if (this._models.getAll(resource).some(function (model) { return model.isDirty(); })) {
                return true;
            }
            // Check for dirty untitled
            return this.untitledEditorService.getDirty().some(function (dirty) { return !resource || dirty.toString() === resource.toString(); });
        };
        TextFileService.prototype.save = function (resource, options) {
            // Run a forced save if we detect the file is not dirty so that save participants can still run
            if (options && options.force && this.fileService.canHandleResource(resource) && !this.isDirty(resource)) {
                var model_1 = this._models.get(resource);
                if (model_1) {
                    if (!options) {
                        options = Object.create(null);
                    }
                    options.reason = 1 /* EXPLICIT */;
                    return model_1.save(options).then(function () { return !model_1.isDirty(); });
                }
            }
            return this.saveAll([resource], options).then(function (result) { return result.results.length === 1 && result.results[0].success; });
        };
        TextFileService.prototype.saveAll = function (arg1, options) {
            // get all dirty
            var toSave = [];
            if (Array.isArray(arg1)) {
                toSave = this.getDirty(arg1);
            }
            else {
                toSave = this.getDirty();
            }
            // split up between files and untitled
            var filesToSave = [];
            var untitledToSave = [];
            toSave.forEach(function (s) {
                if ((Array.isArray(arg1) || arg1 === true /* includeUntitled */) && s.scheme === network_1.Schemas.untitled) {
                    untitledToSave.push(s);
                }
                else {
                    filesToSave.push(s);
                }
            });
            return this.doSaveAll(filesToSave, untitledToSave, options);
        };
        TextFileService.prototype.doSaveAll = function (fileResources, untitledResources, options) {
            var _this = this;
            // Handle files first that can just be saved
            return this.doSaveAllFiles(fileResources, options).then(function (result) { return __awaiter(_this, void 0, void 0, function () {
                var targetsForUntitled, i, untitled, targetUri, targetPath, untitledSaveAsPromises;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            targetsForUntitled = [];
                            i = 0;
                            _a.label = 1;
                        case 1:
                            if (!(i < untitledResources.length)) return [3 /*break*/, 6];
                            untitled = untitledResources[i];
                            if (!this.untitledEditorService.exists(untitled)) return [3 /*break*/, 5];
                            targetUri = void 0;
                            if (!this.untitledEditorService.hasAssociatedFilePath(untitled)) return [3 /*break*/, 2];
                            targetUri = untitled.with({ scheme: network_1.Schemas.file });
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, this.promptForPath(untitled, this.suggestFileName(untitled))];
                        case 3:
                            targetPath = _a.sent();
                            if (!targetPath) {
                                return [2 /*return*/, winjs_base_1.TPromise.as({
                                        results: fileResources.concat(untitledResources).map(function (r) {
                                            return {
                                                source: r
                                            };
                                        })
                                    })];
                            }
                            targetUri = targetPath;
                            _a.label = 4;
                        case 4:
                            targetsForUntitled.push(targetUri);
                            _a.label = 5;
                        case 5:
                            i++;
                            return [3 /*break*/, 1];
                        case 6:
                            untitledSaveAsPromises = [];
                            targetsForUntitled.forEach(function (target, index) {
                                var untitledSaveAsPromise = _this.saveAs(untitledResources[index], target).then(function (uri) {
                                    result.results.push({
                                        source: untitledResources[index],
                                        target: uri,
                                        success: !!uri
                                    });
                                });
                                untitledSaveAsPromises.push(untitledSaveAsPromise);
                            });
                            return [2 /*return*/, winjs_base_1.TPromise.join(untitledSaveAsPromises).then(function () {
                                    return result;
                                })];
                    }
                });
            }); });
        };
        TextFileService.prototype.doSaveAllFiles = function (resources, options) {
            if (options === void 0) { options = Object.create(null); }
            var dirtyFileModels = this.getDirtyFileModels(Array.isArray(resources) ? resources : void 0 /* Save All */)
                .filter(function (model) {
                if ((model.hasState(3 /* CONFLICT */) || model.hasState(5 /* ERROR */)) && (options.reason === 2 /* AUTO */ || options.reason === 3 /* FOCUS_CHANGE */ || options.reason === 4 /* WINDOW_CHANGE */)) {
                    return false; // if model is in save conflict or error, do not save unless save reason is explicit or not provided at all
                }
                return true;
            });
            var mapResourceToResult = new map_1.ResourceMap();
            dirtyFileModels.forEach(function (m) {
                mapResourceToResult.set(m.getResource(), {
                    source: m.getResource()
                });
            });
            return winjs_base_1.TPromise.join(dirtyFileModels.map(function (model) {
                return model.save(options).then(function () {
                    if (!model.isDirty()) {
                        mapResourceToResult.get(model.getResource()).success = true;
                    }
                });
            })).then(function (r) {
                return {
                    results: mapResourceToResult.values()
                };
            });
        };
        TextFileService.prototype.getFileModels = function (arg1) {
            var _this = this;
            if (Array.isArray(arg1)) {
                var models_1 = [];
                arg1.forEach(function (resource) {
                    models_1.push.apply(models_1, _this.getFileModels(resource));
                });
                return models_1;
            }
            return this._models.getAll(arg1);
        };
        TextFileService.prototype.getDirtyFileModels = function (arg1) {
            return this.getFileModels(arg1).filter(function (model) { return model.isDirty(); });
        };
        TextFileService.prototype.saveAs = function (resource, target, options) {
            var _this = this;
            // Get to target resource
            var targetPromise;
            if (target) {
                targetPromise = winjs_base_1.TPromise.wrap(target);
            }
            else {
                var dialogPath = resource;
                if (resource.scheme === network_1.Schemas.untitled) {
                    dialogPath = this.suggestFileName(resource);
                }
                targetPromise = this.promptForPath(resource, dialogPath);
            }
            return targetPromise.then(function (target) {
                if (!target) {
                    return winjs_base_1.TPromise.as(null); // user canceled
                }
                // Just save if target is same as models own resource
                if (resource.toString() === target.toString()) {
                    return _this.save(resource, options).then(function () { return resource; });
                }
                // Do it
                return _this.doSaveAs(resource, target, options);
            });
        };
        TextFileService.prototype.doSaveAs = function (resource, target, options) {
            var _this = this;
            // Retrieve text model from provided resource if any
            var modelPromise = winjs_base_1.TPromise.as(null);
            if (this.fileService.canHandleResource(resource)) {
                modelPromise = winjs_base_1.TPromise.as(this._models.get(resource));
            }
            else if (resource.scheme === network_1.Schemas.untitled && this.untitledEditorService.exists(resource)) {
                modelPromise = this.untitledEditorService.loadOrCreate({ resource: resource });
            }
            return modelPromise.then(function (model) {
                // We have a model: Use it (can be null e.g. if this file is binary and not a text file or was never opened before)
                if (model) {
                    return _this.doSaveTextFileAs(model, resource, target, options);
                }
                // Otherwise we can only copy
                return _this.fileService.copyFile(resource, target);
            }).then(function () {
                // Revert the source
                return _this.revert(resource).then(function () {
                    // Done: return target
                    return target;
                });
            });
        };
        TextFileService.prototype.doSaveTextFileAs = function (sourceModel, resource, target, options) {
            var _this = this;
            var targetModelResolver;
            // Prefer an existing model if it is already loaded for the given target resource
            var targetModel = this.models.get(target);
            if (targetModel && targetModel.isResolved()) {
                targetModelResolver = winjs_base_1.TPromise.as(targetModel);
            }
            // Otherwise create the target file empty if it does not exist already and resolve it from there
            else {
                targetModelResolver = this.fileService.resolveFile(target).then(function (stat) { return stat; }, function () { return null; }).then(function (stat) { return stat || _this.fileService.updateContent(target, ''); }).then(function (stat) {
                    return _this.models.loadOrCreate(target);
                });
            }
            return targetModelResolver.then(function (targetModel) {
                // take over encoding and model value from source model
                targetModel.updatePreferredEncoding(sourceModel.getEncoding());
                _this.modelService.updateModel(targetModel.textEditorModel, textModel_1.createTextBufferFactoryFromSnapshot(sourceModel.createSnapshot()));
                // save model
                return targetModel.save(options);
            }, function (error) {
                // binary model: delete the file and run the operation again
                if (error.fileOperationResult === 0 /* FILE_IS_BINARY */ || error.fileOperationResult === 8 /* FILE_TOO_LARGE */) {
                    return _this.fileService.del(target).then(function () { return _this.doSaveTextFileAs(sourceModel, resource, target, options); });
                }
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        TextFileService.prototype.suggestFileName = function (untitledResource) {
            var untitledFileName = this.untitledEditorService.suggestFileName(untitledResource);
            var schemeFilter = network_1.Schemas.file;
            var lastActiveFile = this.historyService.getLastActiveFile(schemeFilter);
            if (lastActiveFile) {
                return resources_1.joinPath(lastActiveFile, untitledFileName);
            }
            var lastActiveFolder = this.historyService.getLastActiveWorkspaceRoot(schemeFilter);
            if (lastActiveFolder) {
                return resources_1.joinPath(lastActiveFolder, untitledFileName);
            }
            return uri_1.URI.file(untitledFileName);
        };
        TextFileService.prototype.revert = function (resource, options) {
            return this.revertAll([resource], options).then(function (result) { return result.results.length === 1 && result.results[0].success; });
        };
        TextFileService.prototype.revertAll = function (resources, options) {
            var _this = this;
            // Revert files first
            return this.doRevertAllFiles(resources, options).then(function (operation) {
                // Revert untitled
                var reverted = _this.untitledEditorService.revertAll(resources);
                reverted.forEach(function (res) { return operation.results.push({ source: res, success: true }); });
                return operation;
            });
        };
        TextFileService.prototype.doRevertAllFiles = function (resources, options) {
            var fileModels = options && options.force ? this.getFileModels(resources) : this.getDirtyFileModels(resources);
            var mapResourceToResult = new map_1.ResourceMap();
            fileModels.forEach(function (m) {
                mapResourceToResult.set(m.getResource(), {
                    source: m.getResource()
                });
            });
            return winjs_base_1.TPromise.join(fileModels.map(function (model) {
                return model.revert(options && options.soft).then(function () {
                    if (!model.isDirty()) {
                        mapResourceToResult.get(model.getResource()).success = true;
                    }
                }, function (error) {
                    // FileNotFound means the file got deleted meanwhile, so still record as successful revert
                    if (error.fileOperationResult === 2 /* FILE_NOT_FOUND */) {
                        mapResourceToResult.get(model.getResource()).success = true;
                    }
                    // Otherwise bubble up the error
                    else {
                        return winjs_base_1.TPromise.wrapError(error);
                    }
                    return void 0;
                });
            })).then(function (r) {
                return {
                    results: mapResourceToResult.values()
                };
            });
        };
        TextFileService.prototype.create = function (resource, contents, options) {
            var existingModel = this.models.get(resource);
            return this.fileService.createFile(resource, contents, options).then(function () {
                // If we had an existing model for the given resource, load
                // it again to make sure it is up to date with the contents
                // we just wrote into the underlying resource by calling
                // revert()
                if (existingModel && !existingModel.isDisposed()) {
                    return existingModel.revert();
                }
                return void 0;
            });
        };
        TextFileService.prototype.delete = function (resource, options) {
            var _this = this;
            var dirtyFiles = this.getDirty().filter(function (dirty) { return resources_1.isEqualOrParent(dirty, resource, !platform.isLinux /* ignorecase */); });
            return this.revertAll(dirtyFiles, { soft: true }).then(function () { return _this.fileService.del(resource, options); });
        };
        TextFileService.prototype.move = function (source, target, overwrite) {
            var _this = this;
            var waitForPromises = [];
            this._onWillMove.fire({
                oldResource: source,
                newResource: target,
                waitUntil: function (p) {
                    waitForPromises.push(winjs_base_1.TPromise.wrap(p).then(undefined, errors.onUnexpectedError));
                }
            });
            // prevent async waitUntil-calls
            Object.freeze(waitForPromises);
            return winjs_base_1.TPromise.join(waitForPromises).then(function () {
                // Handle target models if existing (if target URI is a folder, this can be multiple)
                var handleTargetModelPromise = winjs_base_1.TPromise.as(void 0);
                var dirtyTargetModels = _this.getDirtyFileModels().filter(function (model) { return resources_1.isEqualOrParent(model.getResource(), target, false /* do not ignorecase, see https://github.com/Microsoft/vscode/issues/56384 */); });
                if (dirtyTargetModels.length) {
                    handleTargetModelPromise = _this.revertAll(dirtyTargetModels.map(function (targetModel) { return targetModel.getResource(); }), { soft: true });
                }
                return handleTargetModelPromise.then(function () {
                    // Handle dirty source models if existing (if source URI is a folder, this can be multiple)
                    var handleDirtySourceModels;
                    var dirtySourceModels = _this.getDirtyFileModels().filter(function (model) { return resources_1.isEqualOrParent(model.getResource(), source, !platform.isLinux /* ignorecase */); });
                    var dirtyTargetModels = [];
                    if (dirtySourceModels.length) {
                        handleDirtySourceModels = winjs_base_1.TPromise.join(dirtySourceModels.map(function (sourceModel) {
                            var sourceModelResource = sourceModel.getResource();
                            var targetModelResource;
                            // If the source is the actual model, just use target as new resource
                            if (resources_1.isEqual(sourceModelResource, source, !platform.isLinux /* ignorecase */)) {
                                targetModelResource = target;
                            }
                            // Otherwise a parent folder of the source is being moved, so we need
                            // to compute the target resource based on that
                            else {
                                targetModelResource = sourceModelResource.with({ path: paths.join(target.path, sourceModelResource.path.substr(source.path.length + 1)) });
                            }
                            // Remember as dirty target model to load after the operation
                            dirtyTargetModels.push(targetModelResource);
                            // Backup dirty source model to the target resource it will become later
                            return _this.backupFileService.backupResource(targetModelResource, sourceModel.createSnapshot(), sourceModel.getVersionId());
                        }));
                    }
                    else {
                        handleDirtySourceModels = winjs_base_1.TPromise.as(void 0);
                    }
                    return handleDirtySourceModels.then(function () {
                        // Soft revert the dirty source files if any
                        return _this.revertAll(dirtySourceModels.map(function (dirtySourceModel) { return dirtySourceModel.getResource(); }), { soft: true }).then(function () {
                            // Rename to target
                            return _this.fileService.moveFile(source, target, overwrite).then(function () {
                                // Load models that were dirty before
                                return winjs_base_1.TPromise.join(dirtyTargetModels.map(function (dirtyTargetModel) { return _this.models.loadOrCreate(dirtyTargetModel); })).then(function () { return void 0; });
                            }, function (error) {
                                // In case of an error, discard any dirty target backups that were made
                                return winjs_base_1.TPromise.join(dirtyTargetModels.map(function (dirtyTargetModel) { return _this.backupFileService.discardResourceBackup(dirtyTargetModel); }))
                                    .then(function () { return winjs_base_1.TPromise.wrapError(error); });
                            });
                        });
                    });
                });
            });
        };
        TextFileService.prototype.getAutoSaveMode = function () {
            if (this.configuredAutoSaveOnFocusChange) {
                return 3 /* ON_FOCUS_CHANGE */;
            }
            if (this.configuredAutoSaveOnWindowChange) {
                return 4 /* ON_WINDOW_CHANGE */;
            }
            if (this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0) {
                return this.configuredAutoSaveDelay <= 1000 ? 1 /* AFTER_SHORT_DELAY */ : 2 /* AFTER_LONG_DELAY */;
            }
            return 0 /* OFF */;
        };
        TextFileService.prototype.getAutoSaveConfiguration = function () {
            return {
                autoSaveDelay: this.configuredAutoSaveDelay && this.configuredAutoSaveDelay > 0 ? this.configuredAutoSaveDelay : void 0,
                autoSaveFocusChange: this.configuredAutoSaveOnFocusChange,
                autoSaveApplicationChange: this.configuredAutoSaveOnWindowChange
            };
        };
        Object.defineProperty(TextFileService.prototype, "isHotExitEnabled", {
            get: function () {
                return !this.environmentService.isExtensionDevelopment && this.configuredHotExit !== files_1.HotExitConfiguration.OFF;
            },
            enumerable: true,
            configurable: true
        });
        TextFileService.prototype.dispose = function () {
            // Clear all caches
            this._models.clear();
            _super.prototype.dispose.call(this);
        };
        return TextFileService;
    }(lifecycle_1.Disposable));
    exports.TextFileService = TextFileService;
});

define(__m[222/*vs/workbench/services/themes/common/workbenchThemeService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkbenchThemeService = instantiation_1.createDecorator('themeService');
    exports.VS_LIGHT_THEME = 'vs';
    exports.VS_DARK_THEME = 'vs-dark';
    exports.VS_HC_THEME = 'hc-black';
    exports.HC_THEME_ID = 'Default High Contrast';
    exports.COLOR_THEME_SETTING = 'workbench.colorTheme';
    exports.DETECT_HC_SETTING = 'window.autoDetectHighContrast';
    exports.ICON_THEME_SETTING = 'workbench.iconTheme';
    exports.CUSTOM_WORKBENCH_COLORS_SETTING = 'workbench.colorCustomizations';
    exports.CUSTOM_EDITOR_COLORS_SETTING = 'editor.tokenColorCustomizations';
    exports.CUSTOM_EDITOR_SCOPE_COLORS_SETTING = 'textMateRules';
});























define(__m[52/*vs/workbench/services/untitled/common/untitledEditorService*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,3/*vs/platform/instantiation/common/instantiation*/,19/*vs/base/common/arrays*/,128/*vs/workbench/common/editor/untitledEditorInput*/,7/*vs/platform/configuration/common/configuration*/,6/*vs/base/common/event*/,39/*vs/base/common/map*/,26/*vs/base/common/network*/,4/*vs/base/common/lifecycle*/]), function (require, exports, uri_1, instantiation_1, arrays, untitledEditorInput_1, configuration_1, event_1, map_1, network_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IUntitledEditorService = instantiation_1.createDecorator('untitledEditorService');
    var UntitledEditorService = /** @class */ (function (_super) {
        __extends(UntitledEditorService, _super);
        function UntitledEditorService(instantiationService, configurationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.configurationService = configurationService;
            _this.mapResourceToInput = new map_1.ResourceMap();
            _this.mapResourceToAssociatedFilePath = new map_1.ResourceMap();
            _this._onDidChangeContent = _this._register(new event_1.Emitter());
            _this._onDidChangeDirty = _this._register(new event_1.Emitter());
            _this._onDidChangeEncoding = _this._register(new event_1.Emitter());
            _this._onDidDisposeModel = _this._register(new event_1.Emitter());
            return _this;
        }
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeContent", {
            get: function () { return this._onDidChangeContent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeDirty", {
            get: function () { return this._onDidChangeDirty.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidChangeEncoding", {
            get: function () { return this._onDidChangeEncoding.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UntitledEditorService.prototype, "onDidDisposeModel", {
            get: function () { return this._onDidDisposeModel.event; },
            enumerable: true,
            configurable: true
        });
        UntitledEditorService.prototype.get = function (resource) {
            return this.mapResourceToInput.get(resource);
        };
        UntitledEditorService.prototype.getAll = function (resources) {
            var _this = this;
            if (resources) {
                return arrays.coalesce(resources.map(function (r) { return _this.get(r); }));
            }
            return this.mapResourceToInput.values();
        };
        UntitledEditorService.prototype.exists = function (resource) {
            return this.mapResourceToInput.has(resource);
        };
        UntitledEditorService.prototype.revertAll = function (resources, force) {
            var reverted = [];
            var untitledInputs = this.getAll(resources);
            untitledInputs.forEach(function (input) {
                if (input) {
                    input.revert();
                    input.dispose();
                    reverted.push(input.getResource());
                }
            });
            return reverted;
        };
        UntitledEditorService.prototype.isDirty = function (resource) {
            var input = this.get(resource);
            return input && input.isDirty();
        };
        UntitledEditorService.prototype.getDirty = function (resources) {
            var _this = this;
            var inputs;
            if (resources) {
                inputs = resources.map(function (r) { return _this.get(r); }).filter(function (i) { return !!i; });
            }
            else {
                inputs = this.mapResourceToInput.values();
            }
            return inputs
                .filter(function (i) { return i.isDirty(); })
                .map(function (i) { return i.getResource(); });
        };
        UntitledEditorService.prototype.loadOrCreate = function (options) {
            if (options === void 0) { options = Object.create(null); }
            return this.createOrGet(options.resource, options.modeId, options.initialValue, options.encoding, options.useResourcePath).resolve();
        };
        UntitledEditorService.prototype.createOrGet = function (resource, modeId, initialValue, encoding, hasAssociatedFilePath) {
            if (hasAssociatedFilePath === void 0) { hasAssociatedFilePath = false; }
            if (resource) {
                // Massage resource if it comes with a file:// scheme
                if (resource.scheme === network_1.Schemas.file) {
                    hasAssociatedFilePath = true;
                    resource = resource.with({ scheme: network_1.Schemas.untitled }); // ensure we have the right scheme
                }
                if (hasAssociatedFilePath) {
                    this.mapResourceToAssociatedFilePath.set(resource, true); // remember for future lookups
                }
            }
            // Return existing instance if asked for it
            if (resource && this.mapResourceToInput.has(resource)) {
                return this.mapResourceToInput.get(resource);
            }
            // Create new otherwise
            return this.doCreate(resource, hasAssociatedFilePath, modeId, initialValue, encoding);
        };
        UntitledEditorService.prototype.doCreate = function (resource, hasAssociatedFilePath, modeId, initialValue, encoding) {
            var _this = this;
            if (!resource) {
                // Create new taking a resource URI that is not already taken
                var counter = this.mapResourceToInput.size + 1;
                do {
                    resource = uri_1.URI.from({ scheme: network_1.Schemas.untitled, path: "Untitled-" + counter });
                    counter++;
                } while (this.mapResourceToInput.has(resource));
            }
            // Look up default language from settings if any
            if (!modeId && !hasAssociatedFilePath) {
                var configuration = this.configurationService.getValue();
                if (configuration.files && configuration.files.defaultLanguage) {
                    modeId = configuration.files.defaultLanguage;
                }
            }
            var input = this.instantiationService.createInstance(untitledEditorInput_1.UntitledEditorInput, resource, hasAssociatedFilePath, modeId, initialValue, encoding);
            var contentListener = input.onDidModelChangeContent(function () {
                _this._onDidChangeContent.fire(resource);
            });
            var dirtyListener = input.onDidChangeDirty(function () {
                _this._onDidChangeDirty.fire(resource);
            });
            var encodingListener = input.onDidModelChangeEncoding(function () {
                _this._onDidChangeEncoding.fire(resource);
            });
            var disposeListener = input.onDispose(function () {
                _this._onDidDisposeModel.fire(resource);
            });
            // Remove from cache on dispose
            var onceDispose = event_1.once(input.onDispose);
            onceDispose(function () {
                _this.mapResourceToInput.delete(input.getResource());
                _this.mapResourceToAssociatedFilePath.delete(input.getResource());
                contentListener.dispose();
                dirtyListener.dispose();
                encodingListener.dispose();
                disposeListener.dispose();
            });
            // Add to cache
            this.mapResourceToInput.set(resource, input);
            return input;
        };
        UntitledEditorService.prototype.hasAssociatedFilePath = function (resource) {
            return this.mapResourceToAssociatedFilePath.has(resource);
        };
        UntitledEditorService.prototype.suggestFileName = function (resource) {
            var input = this.get(resource);
            return input ? input.suggestFileName() : void 0;
        };
        UntitledEditorService.prototype.getEncoding = function (resource) {
            var input = this.get(resource);
            return input ? input.getEncoding() : void 0;
        };
        UntitledEditorService = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, configuration_1.IConfigurationService)
        ], UntitledEditorService);
        return UntitledEditorService;
    }(lifecycle_1.Disposable));
    exports.UntitledEditorService = UntitledEditorService;
});























define(__m[405/*vs/codesandbox/searchService*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,5/*vs/base/common/winjs.base*/,26/*vs/base/common/network*/,38/*vs/base/common/objects*/,22/*vs/base/common/strings*/,71/*vs/platform/search/common/search*/,36/*vs/editor/common/services/modelService*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,43/*vs/platform/environment/common/environment*/,7/*vs/platform/configuration/common/configuration*/,39/*vs/base/common/map*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/,12/*vs/base/common/uri*/,106/*vs/workbench/parts/search/common/searchModel*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, lifecycle_1, winjs_base_1, network_1, objects, strings, search_1, modelService_1, untitledEditorService_1, environment_1, configuration_1, map_1, codesandbox_1, uri_1, searchModel_1, editorService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A service that enables to search for files or with in files.
     */
    var CodeSandboxSearchService = /** @class */ (function (_super) {
        __extends(CodeSandboxSearchService, _super);
        function CodeSandboxSearchService(codesandboxService, modelService, editorService, untitledEditorService, environmentService, configurationService) {
            var _this = _super.call(this) || this;
            _this.codesandboxService = codesandboxService;
            _this.modelService = modelService;
            _this.editorService = editorService;
            _this.untitledEditorService = untitledEditorService;
            _this.configurationService = configurationService;
            _this.fileSearchProviders = new Map();
            _this.textSearchProviders = new Map();
            _this.fileIndexProviders = new Map();
            _this.diskSearch = new DiskSearch();
            return _this;
        }
        CodeSandboxSearchService.prototype.search = function (query) {
            var localResults = this.getLocalResults(query);
            var modulesByPath = this.codesandboxService.getFilesByPath();
            return new winjs_base_1.TPromise(function (r) {
                return r({
                    results: Object.keys(modulesByPath).map(function (p) { return ({
                        resource: uri_1.URI.file(p),
                    }); }),
                });
            });
        };
        CodeSandboxSearchService.prototype.extendQuery = function (query) {
            var configuration = this.configurationService.getValue();
            // Configuration: Encoding
            if (!query.fileEncoding) {
                var fileEncoding = configuration && configuration.files && configuration.files.encoding;
                query.fileEncoding = fileEncoding;
            }
            // Configuration: File Excludes
            if (!query.disregardExcludeSettings) {
                var fileExcludes = objects.deepClone(configuration && configuration.files && configuration.files.exclude);
                if (fileExcludes) {
                    if (!query.excludePattern) {
                        query.excludePattern = fileExcludes;
                    }
                    else {
                        objects.mixin(query.excludePattern, fileExcludes, false /* no overwrite */);
                    }
                }
            }
        };
        CodeSandboxSearchService.prototype.clearCache = function (cacheKey) {
            var clearPs = [this.diskSearch].concat(map_1.values(this.fileIndexProviders)).map(function (provider) { return provider && provider.clearCache(cacheKey); });
            return winjs_base_1.TPromise.join(clearPs).then(function () { });
        };
        CodeSandboxSearchService.prototype.registerSearchResultProvider = function (scheme, type, provider) {
            var list;
            if (type === 0 /* file */) {
                list = this.fileSearchProviders;
            }
            else if (type === 2 /* text */) {
                list = this.textSearchProviders;
            }
            else if (type === 1 /* fileIndex */) {
                list = this.fileIndexProviders;
            }
            list.set(scheme, provider);
            return lifecycle_1.toDisposable(function () {
                list.delete(scheme);
            });
        };
        CodeSandboxSearchService.prototype.getLocalResults = function (query) {
            var _this = this;
            var localResults = new map_1.ResourceMap();
            if (query.type === 2 /* Text */) {
                var models = this.modelService.getModels();
                models.forEach(function (model) {
                    var resource = model.uri;
                    if (!resource) {
                        return;
                    }
                    if (!_this.editorService.isOpen({ resource: resource })) {
                        return;
                    }
                    // Support untitled files
                    if (resource.scheme === network_1.Schemas.untitled) {
                        if (!_this.untitledEditorService.exists(resource)) {
                            return;
                        }
                    }
                    else if (resource.scheme !== network_1.Schemas.file) {
                        // Don't support other resource schemes than files for now
                        // todo@remote
                        // why is that? we should search for resources from other
                        // schemes
                        return;
                    }
                    if (!_this.matches(resource, query)) {
                        return; // respect user filters
                    }
                    // Use editor API to find matches
                    var matches = model.findMatches(query.contentPattern.pattern, false, query.contentPattern.isRegExp, query.contentPattern.isCaseSensitive, query.contentPattern.isWordMatch
                        ? query.contentPattern.wordSeparators
                        : null, false, query.maxResults);
                    if (matches.length) {
                        var fileMatch_1 = new search_1.FileMatch(resource);
                        localResults.set(resource, fileMatch_1);
                        matches.forEach(function (match) {
                            fileMatch_1.matches.push(searchModel_1.editorMatchToTextSearchResult(match, model, query.previewOptions));
                        });
                    }
                    else {
                        localResults.set(resource, null);
                    }
                });
            }
            return localResults;
        };
        CodeSandboxSearchService.prototype.matches = function (resource, query) {
            // file pattern
            if (query.filePattern) {
                if (resource.scheme !== network_1.Schemas.file) {
                    return false; // if we match on file pattern, we have to ignore non file resources
                }
                if (!strings.fuzzyContains(resource.fsPath, strings.stripWildcards(query.filePattern).toLowerCase())) {
                    return false;
                }
            }
            // includes
            if (query.includePattern) {
                if (resource.scheme !== network_1.Schemas.file) {
                    return false; // if we match on file patterns, we have to ignore non file resources
                }
            }
            return search_1.pathIncludedInQuery(query, resource.fsPath);
        };
        CodeSandboxSearchService = __decorate([
            __param(0, codesandbox_1.ICodeSandboxService),
            __param(1, modelService_1.IModelService),
            __param(2, editorService_1.IEditorService),
            __param(3, untitledEditorService_1.IUntitledEditorService),
            __param(4, environment_1.IEnvironmentService),
            __param(5, configuration_1.IConfigurationService)
        ], CodeSandboxSearchService);
        return CodeSandboxSearchService;
    }(lifecycle_1.Disposable));
    exports.CodeSandboxSearchService = CodeSandboxSearchService;
    var DiskSearch = /** @class */ (function () {
        function DiskSearch() {
        }
        DiskSearch.prototype.search = function (query, onProgress) {
            var folderQueries = query.folderQueries || [];
            return new winjs_base_1.TPromise(function (re) {
                re({
                    results: [],
                    limitHit: false,
                });
            });
            // return TPromise.join(folderQueries.map(q => q.folder.scheme === Schemas.file && fs.exists(q.folder.fsPath)))
            // 	.then(exists => {
            // 		const existingFolders = folderQueries.filter((q, index) => exists[index]);
            // 		const rawSearch = this.rawSearchQuery(query, existingFolders);
            // 		let event: Event<ISerializedSearchProgressItem | ISerializedSearchComplete>;
            // 		if (query.type === QueryType.File) {
            // 			event = this.raw.fileSearch(rawSearch);
            // 		} else {
            // 			event = this.raw.textSearch(rawSearch);
            // 		}
            // 		return DiskSearch.collectResultsFromEvent(event, onProgress);
            // 	});
        };
        DiskSearch.prototype.clearCache = function (cacheKey) {
            return new winjs_base_1.TPromise(function (r) { return r(undefined); });
        };
        return DiskSearch;
    }());
    exports.DiskSearch = DiskSearch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[84/*vs/workbench/browser/dnd*/], __M([0/*require*/,1/*exports*/,160/*vs/platform/workspaces/common/workspaces*/,24/*vs/base/common/paths*/,16/*vs/platform/files/common/files*/,42/*vs/platform/windows/common/windows*/,12/*vs/base/common/uri*/,27/*vs/workbench/services/textfile/common/textfiles*/,113/*vs/workbench/services/backup/common/backup*/,26/*vs/base/common/network*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,72/*vs/editor/common/model*/,7/*vs/platform/configuration/common/configuration*/,165/*vs/base/browser/dnd*/,203/*vs/base/parts/tree/browser/treeDefaults*/,83/*vs/base/common/labels*/,131/*vs/base/common/mime*/,18/*vs/base/common/platform*/,19/*vs/base/common/arrays*/,3/*vs/platform/instantiation/common/instantiation*/,45/*vs/editor/browser/editorBrowser*/,35/*vs/base/common/resources*/,11/*vs/workbench/services/editor/common/editorService*/,4/*vs/base/common/lifecycle*/,8/*vs/base/browser/dom*/]), function (require, exports, workspaces_1, paths_1, files_1, windows_1, uri_1, textfiles_1, backup_1, network_1, untitledEditorService_1, model_1, configuration_1, dnd_1, treeDefaults_1, labels_1, mime_1, platform_1, arrays_1, instantiation_1, editorBrowser_1, resources_1, editorService_1, lifecycle_1, dom_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DraggedEditorIdentifier = /** @class */ (function () {
        function DraggedEditorIdentifier(_identifier) {
            this._identifier = _identifier;
        }
        Object.defineProperty(DraggedEditorIdentifier.prototype, "identifier", {
            get: function () {
                return this._identifier;
            },
            enumerable: true,
            configurable: true
        });
        return DraggedEditorIdentifier;
    }());
    exports.DraggedEditorIdentifier = DraggedEditorIdentifier;
    var DraggedEditorGroupIdentifier = /** @class */ (function () {
        function DraggedEditorGroupIdentifier(_identifier) {
            this._identifier = _identifier;
        }
        Object.defineProperty(DraggedEditorGroupIdentifier.prototype, "identifier", {
            get: function () {
                return this._identifier;
            },
            enumerable: true,
            configurable: true
        });
        return DraggedEditorGroupIdentifier;
    }());
    exports.DraggedEditorGroupIdentifier = DraggedEditorGroupIdentifier;
    exports.CodeDataTransfers = {
        EDITORS: 'CodeEditors',
        FILES: 'CodeFiles'
    };
    function extractResources(e, externalOnly) {
        var resources = [];
        if (e.dataTransfer.types.length > 0) {
            // Check for window-to-window DND
            if (!externalOnly) {
                // Data Transfer: Code Editors
                var rawEditorsData = e.dataTransfer.getData(exports.CodeDataTransfers.EDITORS);
                if (rawEditorsData) {
                    try {
                        var draggedEditors = JSON.parse(rawEditorsData);
                        draggedEditors.forEach(function (draggedEditor) {
                            resources.push({ resource: uri_1.URI.parse(draggedEditor.resource), backupResource: draggedEditor.backupResource ? uri_1.URI.parse(draggedEditor.backupResource) : void 0, viewState: draggedEditor.viewState, isExternal: false });
                        });
                    }
                    catch (error) {
                        // Invalid transfer
                    }
                }
                // Data Transfer: Resources
                else {
                    try {
                        var rawResourcesData = e.dataTransfer.getData(dnd_1.DataTransfers.RESOURCES);
                        if (rawResourcesData) {
                            var uriStrArray = JSON.parse(rawResourcesData);
                            resources.push.apply(resources, uriStrArray.map(function (uriStr) { return ({ resource: uri_1.URI.parse(uriStr), isExternal: false }); }));
                        }
                    }
                    catch (error) {
                        // Invalid transfer
                    }
                }
            }
            // Check for native file transfer
            if (e.dataTransfer && e.dataTransfer.files) {
                var _loop_1 = function (i) {
                    // @ts-ignore
                    var file = e.dataTransfer.files[i];
                    if (file && file.path && !resources.some(function (r) { return r.resource.fsPath === file.path; }) /* prevent duplicates */) {
                        try {
                            resources.push({ resource: uri_1.URI.file(file.path), isExternal: true });
                        }
                        catch (error) {
                            // Invalid URI
                        }
                    }
                };
                for (var i = 0; i < e.dataTransfer.files.length; i++) {
                    _loop_1(i);
                }
            }
            // Check for CodeFiles transfer
            var rawCodeFiles = e.dataTransfer.getData(exports.CodeDataTransfers.FILES);
            if (rawCodeFiles) {
                try {
                    var codeFiles = JSON.parse(rawCodeFiles);
                    codeFiles.forEach(function (codeFile) {
                        if (!resources.some(function (r) { return r.resource.fsPath === codeFile; }) /* prevent duplicates */) {
                            resources.push({ resource: uri_1.URI.file(codeFile), isExternal: true });
                        }
                    });
                }
                catch (error) {
                    // Invalid transfer
                }
            }
        }
        return resources;
    }
    exports.extractResources = extractResources;
    /**
     * Shared function across some components to handle drag & drop of resources. E.g. of folders and workspace files
     * to open them in the window instead of the editor or to handle dirty editors being dropped between instances of Code.
     */
    var ResourcesDropHandler = /** @class */ (function () {
        function ResourcesDropHandler(options, fileService, windowsService, windowService, workspacesService, textFileService, backupFileService, untitledEditorService, editorService, configurationService) {
            this.options = options;
            this.fileService = fileService;
            this.windowsService = windowsService;
            this.windowService = windowService;
            this.workspacesService = workspacesService;
            this.textFileService = textFileService;
            this.backupFileService = backupFileService;
            this.untitledEditorService = untitledEditorService;
            this.editorService = editorService;
            this.configurationService = configurationService;
        }
        ResourcesDropHandler.prototype.handleDrop = function (event, resolveTargetGroup, afterDrop, targetIndex) {
            var _this = this;
            var untitledOrFileResources = extractResources(event).filter(function (r) { return _this.fileService.canHandleResource(r.resource) || r.resource.scheme === network_1.Schemas.untitled; });
            if (!untitledOrFileResources.length) {
                return;
            }
            // Make the window active to handle the drop properly within
            this.windowService.focusWindow().then(function () {
                // Check for special things being dropped
                return _this.doHandleDrop(untitledOrFileResources).then(function (isWorkspaceOpening) {
                    if (isWorkspaceOpening) {
                        return void 0; // return early if the drop operation resulted in this window changing to a workspace
                    }
                    // Add external ones to recently open list unless dropped resource is a workspace
                    var filesToAddToHistory = untitledOrFileResources.filter(function (d) { return d.isExternal && d.resource.scheme === network_1.Schemas.file; }).map(function (d) { return d.resource; });
                    if (filesToAddToHistory.length) {
                        _this.windowsService.addRecentlyOpened(filesToAddToHistory);
                    }
                    var editors = untitledOrFileResources.map(function (untitledOrFileResource) { return ({
                        resource: untitledOrFileResource.resource,
                        options: {
                            pinned: true,
                            index: targetIndex,
                            viewState: untitledOrFileResource.viewState
                        }
                    }); });
                    // Open in Editor
                    var targetGroup = resolveTargetGroup();
                    return _this.editorService.openEditors(editors, targetGroup).then(function () {
                        // Finish with provided function
                        afterDrop(targetGroup);
                    });
                });
            });
        };
        ResourcesDropHandler.prototype.doHandleDrop = function (untitledOrFileResources) {
            var _this = this;
            // Check for dirty editors being dropped
            var resourcesWithBackups = untitledOrFileResources.filter(function (resource) { return !resource.isExternal && !!resource.backupResource; });
            if (resourcesWithBackups.length > 0) {
                return Promise.all(resourcesWithBackups.map(function (resourceWithBackup) { return _this.handleDirtyEditorDrop(resourceWithBackup); })).then(function () { return false; });
            }
            // Check for workspace file being dropped if we are allowed to do so
            if (this.options.allowWorkspaceOpen) {
                var externalFileOnDiskResources = untitledOrFileResources.filter(function (d) { return d.isExternal && d.resource.scheme === network_1.Schemas.file; }).map(function (d) { return d.resource; });
                if (externalFileOnDiskResources.length > 0) {
                    return this.handleWorkspaceFileDrop(externalFileOnDiskResources);
                }
            }
            return Promise.resolve(false);
        };
        ResourcesDropHandler.prototype.handleDirtyEditorDrop = function (droppedDirtyEditor) {
            var _this = this;
            // Untitled: always ensure that we open a new untitled for each file we drop
            if (droppedDirtyEditor.resource.scheme === network_1.Schemas.untitled) {
                droppedDirtyEditor.resource = this.untitledEditorService.createOrGet().getResource();
            }
            // Return early if the resource is already dirty in target or opened already
            if (this.textFileService.isDirty(droppedDirtyEditor.resource) || this.editorService.isOpen({ resource: droppedDirtyEditor.resource })) {
                return Promise.resolve(false);
            }
            // Resolve the contents of the dropped dirty resource from source
            return this.backupFileService.resolveBackupContent(droppedDirtyEditor.backupResource).then(function (content) {
                // Set the contents of to the resource to the target
                return _this.backupFileService.backupResource(droppedDirtyEditor.resource, content.create(_this.getDefaultEOL()).createSnapshot(true));
            }).then(function () { return false; }, function () { return false; } /* ignore any error */);
        };
        ResourcesDropHandler.prototype.getDefaultEOL = function () {
            var eol = this.configurationService.getValue('files.eol');
            if (eol === '\r\n') {
                return model_1.DefaultEndOfLine.CRLF;
            }
            return model_1.DefaultEndOfLine.LF;
        };
        ResourcesDropHandler.prototype.handleWorkspaceFileDrop = function (fileOnDiskResources) {
            var _this = this;
            var workspaceResources = {
                workspaces: [],
                folders: []
            };
            return Promise.all(fileOnDiskResources.map(function (fileOnDiskResource) {
                // Check for Workspace
                if (paths_1.extname(fileOnDiskResource.fsPath) === "." + workspaces_1.WORKSPACE_EXTENSION) {
                    workspaceResources.workspaces.push(fileOnDiskResource);
                    return void 0;
                }
                // Check for Folder
                return _this.fileService.resolveFile(fileOnDiskResource).then(function (stat) {
                    if (stat.isDirectory) {
                        workspaceResources.folders.push(stat.resource);
                    }
                }, function (error) { return void 0; });
            })).then(function (_) {
                var workspaces = workspaceResources.workspaces, folders = workspaceResources.folders;
                // Return early if no external resource is a folder or workspace
                if (workspaces.length === 0 && folders.length === 0) {
                    return false;
                }
                // Pass focus to window
                _this.windowService.focusWindow();
                var workspacesToOpen;
                // Open in separate windows if we drop workspaces or just one folder
                if (workspaces.length > 0 || folders.length === 1) {
                    workspacesToOpen = Promise.resolve(workspaces.concat(folders).map(function (resources) { return resources; }));
                }
                // Multiple folders: Create new workspace with folders and open
                else if (folders.length > 1) {
                    workspacesToOpen = _this.workspacesService.createWorkspace(folders.map(function (folder) { return ({ uri: folder }); })).then(function (workspace) { return [uri_1.URI.file(workspace.configPath)]; });
                }
                // Open
                workspacesToOpen.then(function (workspaces) {
                    _this.windowService.openWindow(workspaces, { forceReuseWindow: true });
                });
                return true;
            });
        };
        ResourcesDropHandler = __decorate([
            __param(1, files_1.IFileService),
            __param(2, windows_1.IWindowsService),
            __param(3, windows_1.IWindowService),
            __param(4, workspaces_1.IWorkspacesService),
            __param(5, textfiles_1.ITextFileService),
            __param(6, backup_1.IBackupFileService),
            __param(7, untitledEditorService_1.IUntitledEditorService),
            __param(8, editorService_1.IEditorService),
            __param(9, configuration_1.IConfigurationService)
        ], ResourcesDropHandler);
        return ResourcesDropHandler;
    }());
    exports.ResourcesDropHandler = ResourcesDropHandler;
    var SimpleFileResourceDragAndDrop = /** @class */ (function (_super) {
        __extends(SimpleFileResourceDragAndDrop, _super);
        function SimpleFileResourceDragAndDrop(toResource, instantiationService) {
            var _this = _super.call(this) || this;
            _this.toResource = toResource;
            _this.instantiationService = instantiationService;
            return _this;
        }
        SimpleFileResourceDragAndDrop.prototype.getDragURI = function (tree, obj) {
            var resource = this.toResource(obj);
            if (resource) {
                return resource.toString();
            }
            return void 0;
        };
        SimpleFileResourceDragAndDrop.prototype.getDragLabel = function (tree, elements) {
            if (elements.length > 1) {
                return String(elements.length);
            }
            var resource = this.toResource(elements[0]);
            if (resource) {
                return resources_1.basenameOrAuthority(resource);
            }
            return void 0;
        };
        SimpleFileResourceDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
            var _this = this;
            // Apply some datatransfer types to allow for dragging the element outside of the application
            var resources = data.getData().map(function (source) { return _this.toResource(source); });
            if (resources) {
                this.instantiationService.invokeFunction(fillResourceDataTransfers, arrays_1.coalesce(resources), originalEvent);
            }
        };
        SimpleFileResourceDragAndDrop = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], SimpleFileResourceDragAndDrop);
        return SimpleFileResourceDragAndDrop;
    }(treeDefaults_1.DefaultDragAndDrop));
    exports.SimpleFileResourceDragAndDrop = SimpleFileResourceDragAndDrop;
    function fillResourceDataTransfers(accessor, resources, event) {
        if (resources.length === 0) {
            return;
        }
        var sources = resources.map(function (obj) {
            if (uri_1.URI.isUri(obj)) {
                return { resource: obj, isDirectory: false /* assume resource is not a directory */ };
            }
            return obj;
        });
        var firstSource = sources[0];
        // Text: allows to paste into text-capable areas
        var lineDelimiter = platform_1.isWindows ? '\r\n' : '\n';
        event.dataTransfer.setData(dnd_1.DataTransfers.TEXT, sources.map(function (source) { return source.resource.scheme === network_1.Schemas.file ? paths_1.normalize(labels_1.normalizeDriveLetter(source.resource.fsPath), true) : source.resource.toString(); }).join(lineDelimiter));
        // Download URL: enables support to drag a tab as file to desktop (only single file supported)
        if (firstSource.resource.scheme === network_1.Schemas.file) {
            event.dataTransfer.setData(dnd_1.DataTransfers.DOWNLOAD_URL, [mime_1.MIME_BINARY, paths_1.basename(firstSource.resource.fsPath), firstSource.resource.toString()].join(':'));
        }
        // Resource URLs: allows to drop multiple resources to a target in VS Code (not directories)
        var files = sources.filter(function (s) { return !s.isDirectory; });
        if (files.length) {
            event.dataTransfer.setData(dnd_1.DataTransfers.RESOURCES, JSON.stringify(files.map(function (f) { return f.resource.toString(); })));
        }
        // Editors: enables cross window DND of tabs into the editor area
        var textFileService = accessor.get(textfiles_1.ITextFileService);
        var backupFileService = accessor.get(backup_1.IBackupFileService);
        var editorService = accessor.get(editorService_1.IEditorService);
        var draggedEditors = [];
        files.forEach(function (file) {
            // Try to find editor view state from the visible editors that match given resource
            var viewState;
            var textEditorWidgets = editorService.visibleTextEditorWidgets;
            for (var i = 0; i < textEditorWidgets.length; i++) {
                var textEditorWidget = textEditorWidgets[i];
                if (editorBrowser_1.isCodeEditor(textEditorWidget)) {
                    var model = textEditorWidget.getModel();
                    if (model && model.uri && model.uri.toString() === file.resource.toString()) {
                        viewState = textEditorWidget.saveViewState();
                        break;
                    }
                }
            }
            // Add as dragged editor
            draggedEditors.push({
                resource: file.resource.toString(),
                backupResource: textFileService.isDirty(file.resource) ? backupFileService.toBackupResource(file.resource).toString() : void 0,
                viewState: viewState
            });
        });
        if (draggedEditors.length) {
            event.dataTransfer.setData(exports.CodeDataTransfers.EDITORS, JSON.stringify(draggedEditors));
        }
    }
    exports.fillResourceDataTransfers = fillResourceDataTransfers;
    /**
     * A singleton to store transfer data during drag & drop operations that are only valid within the application.
     */
    var LocalSelectionTransfer = /** @class */ (function () {
        function LocalSelectionTransfer() {
            // protect against external instantiation
        }
        LocalSelectionTransfer.getInstance = function () {
            return LocalSelectionTransfer.INSTANCE;
        };
        LocalSelectionTransfer.prototype.hasData = function (proto) {
            return proto && proto === this.proto;
        };
        LocalSelectionTransfer.prototype.clearData = function (proto) {
            if (this.hasData(proto)) {
                this.proto = void 0;
                this.data = void 0;
            }
        };
        LocalSelectionTransfer.prototype.getData = function (proto) {
            if (this.hasData(proto)) {
                return this.data;
            }
            return void 0;
        };
        LocalSelectionTransfer.prototype.setData = function (data, proto) {
            if (proto) {
                this.data = data;
                this.proto = proto;
            }
        };
        LocalSelectionTransfer.INSTANCE = new LocalSelectionTransfer();
        return LocalSelectionTransfer;
    }());
    exports.LocalSelectionTransfer = LocalSelectionTransfer;
    var DragAndDropObserver = /** @class */ (function (_super) {
        __extends(DragAndDropObserver, _super);
        function DragAndDropObserver(element, callbacks) {
            var _this = _super.call(this) || this;
            _this.element = element;
            _this.callbacks = callbacks;
            // A helper to fix issues with repeated DRAG_ENTER / DRAG_LEAVE
            // calls see https://github.com/Microsoft/vscode/issues/14470
            // when the element has child elements where the events are fired
            // repeadedly.
            _this.counter = 0;
            _this.registerListeners();
            return _this;
        }
        DragAndDropObserver.prototype.registerListeners = function () {
            var _this = this;
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DRAG_ENTER, function (e) {
                _this.counter++;
                _this.callbacks.onDragEnter(e);
            }));
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DRAG_OVER, function (e) {
                // Do this to fix chrome behaviour
                e.preventDefault();
                e.stopPropagation();
                if (_this.callbacks.onDragOver) {
                    _this.callbacks.onDragOver(e);
                }
            }));
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DRAG_LEAVE, function (e) {
                _this.counter--;
                if (_this.counter === 0) {
                    _this.callbacks.onDragLeave(e);
                }
            }));
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DRAG_END, function (e) {
                _this.counter = 0;
                _this.callbacks.onDragEnd(e);
            }));
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DROP, function (e) {
                _this.counter = 0;
                _this.callbacks.onDrop(e);
            }));
        };
        return DragAndDropObserver;
    }(lifecycle_1.Disposable));
    exports.DragAndDropObserver = DragAndDropObserver;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[60/*vs/workbench/browser/labels*/], __M([0/*require*/,1/*exports*/,35/*vs/base/common/resources*/,194/*vs/base/browser/ui/iconLabel/iconLabel*/,70/*vs/workbench/services/extensions/common/extensions*/,41/*vs/editor/common/services/modeService*/,13/*vs/workbench/common/editor*/,152/*vs/editor/common/modes/modesRegistry*/,20/*vs/platform/workspace/common/workspace*/,7/*vs/platform/configuration/common/configuration*/,36/*vs/editor/common/services/modelService*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,155/*vs/workbench/services/decorations/browser/decorations*/,26/*vs/base/common/network*/,16/*vs/platform/files/common/files*/,14/*vs/platform/theme/common/themeService*/,6/*vs/base/common/event*/,82/*vs/workbench/common/resources*/,59/*vs/platform/label/common/label*/]), function (require, exports, resources, iconLabel_1, extensions_1, modeService_1, editor_1, modesRegistry_1, workspace_1, configuration_1, modelService_1, untitledEditorService_1, decorations_1, network_1, files_1, themeService_1, event_1, resources_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourceLabel = /** @class */ (function (_super) {
        __extends(ResourceLabel, _super);
        function ResourceLabel(container, options, extensionService, configurationService, modeService, modelService, decorationsService, themeService, labelService) {
            var _this = _super.call(this, container, options) || this;
            _this.extensionService = extensionService;
            _this.configurationService = configurationService;
            _this.modeService = modeService;
            _this.modelService = modelService;
            _this.decorationsService = decorationsService;
            _this.themeService = themeService;
            _this.labelService = labelService;
            _this._onDidRender = _this._register(new event_1.Emitter());
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(ResourceLabel.prototype, "onDidRender", {
            get: function () { return this._onDidRender.event; },
            enumerable: true,
            configurable: true
        });
        ResourceLabel.prototype.registerListeners = function () {
            var _this = this;
            // update when extensions are registered with potentially new languages
            this._register(this.extensionService.onDidRegisterExtensions(function () { return _this.render(true /* clear cache */); }));
            // react to model mode changes
            this._register(this.modelService.onModelModeChanged(function (e) { return _this.onModelModeChanged(e); }));
            // react to file decoration changes
            this._register(this.decorationsService.onDidChangeDecorations(this.onFileDecorationsChanges, this));
            // react to theme changes
            this._register(this.themeService.onThemeChange(function () { return _this.render(false); }));
            // react to files.associations changes
            this._register(this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration(files_1.FILES_ASSOCIATIONS_CONFIG)) {
                    _this.render(true /* clear cache */);
                }
            }));
        };
        ResourceLabel.prototype.onModelModeChanged = function (e) {
            if (!this.label || !this.label.resource) {
                return; // only update if label exists
            }
            if (!e.model.uri) {
                return; // we need the resource to compare
            }
            if (e.model.uri.scheme === network_1.Schemas.file && e.oldModeId === modesRegistry_1.PLAINTEXT_MODE_ID) { // todo@remote does this apply?
                return; // ignore transitions in files from no mode to specific mode because this happens each time a model is created
            }
            if (e.model.uri.toString() === this.label.resource.toString()) {
                if (this.lastKnownConfiguredLangId !== e.model.getLanguageIdentifier().language) {
                    this.render(true); // update if the language id of the model has changed from our last known state
                }
            }
        };
        ResourceLabel.prototype.onFileDecorationsChanges = function (e) {
            if (!this.options || !this.label || !this.label.resource) {
                return;
            }
            if (this.options.fileDecorations && e.affectsResource(this.label.resource)) {
                this.render(false);
            }
        };
        ResourceLabel.prototype.setLabel = function (label, options) {
            var hasResourceChanged = this.hasResourceChanged(label, options);
            this.label = label;
            this.options = options;
            if (hasResourceChanged) {
                this.computedPathLabel = void 0; // reset path label due to resource change
            }
            this.render(hasResourceChanged);
        };
        ResourceLabel.prototype.hasResourceChanged = function (label, options) {
            var newResource = label ? label.resource : void 0;
            var oldResource = this.label ? this.label.resource : void 0;
            var newFileKind = options ? options.fileKind : void 0;
            var oldFileKind = this.options ? this.options.fileKind : void 0;
            if (newFileKind !== oldFileKind) {
                return true; // same resource but different kind (file, folder)
            }
            if (newResource && this.computedPathLabel !== this.labelService.getUriLabel(newResource)) {
                return true;
            }
            if (newResource && oldResource) {
                return newResource.toString() !== oldResource.toString();
            }
            if (!newResource && !oldResource) {
                return false;
            }
            return true;
        };
        ResourceLabel.prototype.clear = function () {
            this.label = void 0;
            this.options = void 0;
            this.lastKnownConfiguredLangId = void 0;
            this.computedIconClasses = void 0;
            this.computedPathLabel = void 0;
            this.setValue();
        };
        ResourceLabel.prototype.render = function (clearIconCache) {
            var _a;
            if (this.label) {
                var configuredLangId = getConfiguredLangId(this.modelService, this.label.resource);
                if (this.lastKnownConfiguredLangId !== configuredLangId) {
                    clearIconCache = true;
                    this.lastKnownConfiguredLangId = configuredLangId;
                }
            }
            if (clearIconCache) {
                this.computedIconClasses = void 0;
            }
            if (!this.label) {
                return;
            }
            var iconLabelOptions = {
                title: '',
                italic: this.options && this.options.italic,
                matches: this.options && this.options.matches,
                extraClasses: []
            };
            var resource = this.label.resource;
            var label = this.label.name;
            if (this.options && typeof this.options.title === 'string') {
                iconLabelOptions.title = this.options.title;
            }
            else if (resource && resource.scheme !== network_1.Schemas.data /* do not accidentally inline Data URIs */) {
                if (!this.computedPathLabel) {
                    this.computedPathLabel = this.labelService.getUriLabel(resource);
                }
                iconLabelOptions.title = this.computedPathLabel;
            }
            if (this.options && !this.options.hideIcon) {
                if (!this.computedIconClasses) {
                    this.computedIconClasses = getIconClasses(this.modelService, this.modeService, resource, this.options && this.options.fileKind);
                }
                iconLabelOptions.extraClasses = this.computedIconClasses.slice(0);
            }
            if (this.options && this.options.extraClasses) {
                (_a = iconLabelOptions.extraClasses).push.apply(_a, this.options.extraClasses);
            }
            if (this.options && this.options.fileDecorations && resource) {
                var deco = this.decorationsService.getDecoration(resource, this.options.fileKind !== files_1.FileKind.FILE, this.options.fileDecorations.data);
                if (deco) {
                    if (deco.tooltip) {
                        iconLabelOptions.title = iconLabelOptions.title + " \u2022 " + deco.tooltip;
                    }
                    if (this.options.fileDecorations.colors) {
                        iconLabelOptions.extraClasses.push(deco.labelClassName);
                    }
                    if (this.options.fileDecorations.badges) {
                        iconLabelOptions.extraClasses.push(deco.badgeClassName);
                    }
                }
            }
            this.setValue(label, this.label.description, iconLabelOptions);
            this._onDidRender.fire();
        };
        ResourceLabel.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.label = void 0;
            this.options = void 0;
            this.lastKnownConfiguredLangId = void 0;
            this.computedIconClasses = void 0;
            this.computedPathLabel = void 0;
        };
        ResourceLabel = __decorate([
            __param(2, extensions_1.IExtensionService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, modeService_1.IModeService),
            __param(5, modelService_1.IModelService),
            __param(6, decorations_1.IDecorationsService),
            __param(7, themeService_1.IThemeService),
            __param(8, label_1.ILabelService)
        ], ResourceLabel);
        return ResourceLabel;
    }(iconLabel_1.IconLabel));
    exports.ResourceLabel = ResourceLabel;
    var EditorLabel = /** @class */ (function (_super) {
        __extends(EditorLabel, _super);
        function EditorLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EditorLabel.prototype.setEditor = function (editor, options) {
            this.setLabel({
                resource: editor_1.toResource(editor, { supportSideBySide: true }),
                name: editor.getName(),
                description: editor.getDescription()
            }, options);
        };
        return EditorLabel;
    }(ResourceLabel));
    exports.EditorLabel = EditorLabel;
    var FileLabel = /** @class */ (function (_super) {
        __extends(FileLabel, _super);
        function FileLabel(container, options, extensionService, contextService, configurationService, modeService, modelService, decorationsService, themeService, untitledEditorService, labelService) {
            var _this = _super.call(this, container, options, extensionService, configurationService, modeService, modelService, decorationsService, themeService, labelService) || this;
            _this.contextService = contextService;
            _this.untitledEditorService = untitledEditorService;
            return _this;
        }
        FileLabel.prototype.setFile = function (resource, options) {
            var hideLabel = options && options.hideLabel;
            var name;
            if (!hideLabel) {
                if (options && options.fileKind === files_1.FileKind.ROOT_FOLDER) {
                    var workspaceFolder = this.contextService.getWorkspaceFolder(resource);
                    if (workspaceFolder) {
                        name = workspaceFolder.name;
                    }
                }
                if (!name) {
                    name = resources.basenameOrAuthority(resource);
                }
            }
            var description;
            var hidePath = (options && options.hidePath) || (resource.scheme === network_1.Schemas.untitled && !this.untitledEditorService.hasAssociatedFilePath(resource));
            if (!hidePath) {
                description = this.labelService.getUriLabel(resources.dirname(resource), { relative: true });
            }
            this.setLabel({ resource: resource, name: name, description: description }, options);
        };
        FileLabel = __decorate([
            __param(2, extensions_1.IExtensionService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, modeService_1.IModeService),
            __param(6, modelService_1.IModelService),
            __param(7, decorations_1.IDecorationsService),
            __param(8, themeService_1.IThemeService),
            __param(9, untitledEditorService_1.IUntitledEditorService),
            __param(10, label_1.ILabelService)
        ], FileLabel);
        return FileLabel;
    }(ResourceLabel));
    exports.FileLabel = FileLabel;
    function getIconClasses(modelService, modeService, resource, fileKind) {
        // we always set these base classes even if we do not have a path
        var classes = fileKind === files_1.FileKind.ROOT_FOLDER ? ['rootfolder-icon'] : fileKind === files_1.FileKind.FOLDER ? ['folder-icon'] : ['file-icon'];
        if (resource) {
            // Get the path and name of the resource. For data-URIs, we need to parse specially
            var name_1;
            var path = void 0;
            if (resource.scheme === network_1.Schemas.data) {
                var metadata = resources_1.DataUri.parseMetaData(resource);
                name_1 = metadata.get(resources_1.DataUri.META_DATA_LABEL);
                path = name_1;
            }
            else {
                name_1 = cssEscape(resources.basenameOrAuthority(resource).toLowerCase());
                path = resource.path.toLowerCase();
            }
            // Folders
            if (fileKind === files_1.FileKind.FOLDER) {
                classes.push(name_1 + "-name-folder-icon");
            }
            // Files
            else {
                // Name & Extension(s)
                if (name_1) {
                    classes.push(name_1 + "-name-file-icon");
                    var dotSegments = name_1.split('.');
                    for (var i = 1; i < dotSegments.length; i++) {
                        classes.push(dotSegments.slice(i).join('.') + "-ext-file-icon"); // add each combination of all found extensions if more than one
                    }
                    classes.push("ext-file-icon"); // extra segment to increase file-ext score
                }
                // Configured Language
                var configuredLangId = getConfiguredLangId(modelService, resource);
                configuredLangId = configuredLangId || modeService.getModeIdByFilepathOrFirstLine(path);
                if (configuredLangId) {
                    classes.push(cssEscape(configuredLangId) + "-lang-file-icon");
                }
            }
        }
        return classes;
    }
    exports.getIconClasses = getIconClasses;
    function getConfiguredLangId(modelService, resource) {
        var configuredLangId;
        if (resource) {
            var model = modelService.getModel(resource);
            if (model) {
                var modeId = model.getLanguageIdentifier().language;
                if (modeId && modeId !== modesRegistry_1.PLAINTEXT_MODE_ID) {
                    configuredLangId = modeId; // only take if the mode is specific (aka no just plain text)
                }
            }
        }
        return configuredLangId;
    }
    function cssEscape(val) {
        return val.replace(/\s/g, '\\$&'); // make sure to not introduce CSS classes from files that contain whitespace
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[409/*vs/workbench/browser/parts/editor/breadcrumbsPicker*/], __M([0/*require*/,1/*exports*/,111/*vs/base/browser/browser*/,8/*vs/base/browser/dom*/,166/*vs/base/common/comparers*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,69/*vs/base/common/filters*/,142/*vs/base/common/glob*/,4/*vs/base/common/lifecycle*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,12/*vs/base/common/uri*/,126/*vs/editor/contrib/documentSymbols/outlineModel*/,256/*vs/editor/contrib/documentSymbols/outlineTree*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,51/*vs/platform/list/browser/listService*/,30/*vs/platform/theme/common/colorRegistry*/,20/*vs/platform/workspace/common/workspace*/,60/*vs/workbench/browser/labels*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,204/*vs/workbench/browser/parts/editor/breadcrumbsModel*/,222/*vs/workbench/services/themes/common/workbenchThemeService*/,213/*vs/css!vs/workbench/browser/parts/editor/media/breadcrumbscontrol*/]), function (require, exports, browser_1, dom, comparers_1, errors_1, event_1, filters_1, glob, lifecycle_1, paths_1, resources_1, uri_1, outlineModel_1, outlineTree_1, nls_1, configuration_1, files_1, instantiation_1, listService_1, colorRegistry_1, workspace_1, labels_1, breadcrumbs_1, breadcrumbsModel_1, workbenchThemeService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createBreadcrumbsPicker(instantiationService, parent, element) {
        var ctor = element instanceof breadcrumbsModel_1.FileElement ? BreadcrumbsFilePicker : BreadcrumbsOutlinePicker;
        return instantiationService.createInstance(ctor, parent);
    }
    exports.createBreadcrumbsPicker = createBreadcrumbsPicker;
    var BreadcrumbsPicker = /** @class */ (function () {
        function BreadcrumbsPicker(parent, _instantiationService, _themeService, _configurationService) {
            var _this = this;
            this._instantiationService = _instantiationService;
            this._themeService = _themeService;
            this._configurationService = _configurationService;
            this._disposables = new Array();
            this._onDidPickElement = new event_1.Emitter();
            this.onDidPickElement = this._onDidPickElement.event;
            this._onDidFocusElement = new event_1.Emitter();
            this.onDidFocusElement = this._onDidFocusElement.event;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-breadcrumbs-picker show-file-icons';
            parent.appendChild(this._domNode);
            this._focus = dom.trackFocus(this._domNode);
            this._focus.onDidBlur(function (_) { return _this._onDidPickElement.fire({ target: undefined, payload: undefined }); }, undefined, this._disposables);
            this._disposables.push(browser_1.onDidChangeZoomLevel(function (_) { return _this._onDidPickElement.fire({ target: undefined, payload: undefined }); }));
            var theme = this._themeService.getTheme();
            var color = theme.getColor(colorRegistry_1.breadcrumbsPickerBackground);
            this._arrow = document.createElement('div');
            this._arrow.className = 'arrow';
            this._arrow.style.borderColor = "transparent transparent " + color.toString();
            this._domNode.appendChild(this._arrow);
            this._treeContainer = document.createElement('div');
            this._treeContainer.style.background = color.toString();
            this._treeContainer.style.paddingTop = '2px';
            this._treeContainer.style.boxShadow = "0px 5px 8px " + this._themeService.getTheme().getColor(colorRegistry_1.widgetShadow);
            this._domNode.appendChild(this._treeContainer);
            var filterConfig = breadcrumbs_1.BreadcrumbsConfig.FilterOnType.bindTo(this._configurationService);
            this._disposables.push(filterConfig);
            var treeConifg = this._completeTreeConfiguration({ dataSource: undefined, renderer: undefined, highlighter: undefined });
            this._tree = this._instantiationService.createInstance(listService_1.HighlightingWorkbenchTree, this._treeContainer, treeConifg, { useShadows: false, filterOnType: filterConfig.getValue(), showTwistie: false, twistiePixels: 12 }, { placeholder: nls_1.localize('placeholder', "Find") });
            this._disposables.push(this._tree.onDidChangeSelection(function (e) {
                if (e.payload !== _this._tree) {
                    var target_1 = _this._getTargetFromEvent(e.selection[0], e.payload);
                    if (target_1) {
                        setTimeout(function (_) {
                            _this._onDidPickElement.fire({ target: target_1, payload: e.payload });
                        }, 0);
                    }
                }
            }));
            this._disposables.push(this._tree.onDidChangeFocus(function (e) {
                var target = _this._getTargetFromEvent(e.focus, e.payload);
                if (target) {
                    _this._onDidFocusElement.fire({ target: target, payload: e.payload });
                }
            }));
            this._disposables.push(this._tree.onDidStartFiltering(function () {
                _this._layoutInfo.inputHeight = 36;
                _this._layout();
            }));
            this._disposables.push(this._tree.onDidExpandItem(function () {
                _this._layout();
            }));
            this._disposables.push(this._tree.onDidCollapseItem(function () {
                _this._layout();
            }));
            // tree icon theme specials
            dom.addClass(this._treeContainer, 'file-icon-themable-tree');
            dom.addClass(this._treeContainer, 'show-file-icons');
            var onFileIconThemeChange = function (fileIconTheme) {
                dom.toggleClass(_this._treeContainer, 'align-icons-and-twisties', fileIconTheme.hasFileIcons && !fileIconTheme.hasFolderIcons);
                dom.toggleClass(_this._treeContainer, 'hide-arrows', fileIconTheme.hidesExplorerArrows === true);
            };
            this._disposables.push(_themeService.onDidFileIconThemeChange(onFileIconThemeChange));
            onFileIconThemeChange(_themeService.getFileIconTheme());
            this._domNode.focus();
        }
        BreadcrumbsPicker.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
            this._onDidPickElement.dispose();
            this._tree.dispose();
            this._focus.dispose();
        };
        BreadcrumbsPicker.prototype.setInput = function (input, maxHeight, width, arrowSize, arrowOffset) {
            var _this = this;
            var actualInput = this._getInput(input);
            this._tree.setInput(actualInput).then(function () {
                _this._layoutInfo = { maxHeight: maxHeight, width: width, arrowSize: arrowSize, arrowOffset: arrowOffset, inputHeight: 0 };
                _this._layout();
                // use proper selection, reveal
                var selection = _this._getInitialSelection(_this._tree, input);
                if (selection) {
                    return _this._tree.reveal(selection, .5).then(function () {
                        _this._tree.setSelection([selection], _this._tree);
                        _this._tree.setFocus(selection);
                        _this._tree.domFocus();
                    });
                }
                else {
                    _this._tree.focusFirst();
                    _this._tree.setSelection([_this._tree.getFocus()], _this._tree);
                    _this._tree.domFocus();
                    return Promise.resolve(null);
                }
            }, errors_1.onUnexpectedError);
        };
        BreadcrumbsPicker.prototype._layout = function (info) {
            if (info === void 0) { info = this._layoutInfo; }
            var count = 0;
            var nav = this._tree.getNavigator(undefined, false);
            while (nav.next() && count < 13) {
                count += 1;
            }
            var headerHeight = 2 * info.arrowSize;
            var treeHeight = Math.min(info.maxHeight - headerHeight, count * 22);
            var totalHeight = treeHeight + headerHeight;
            this._domNode.style.height = totalHeight + "px";
            this._domNode.style.width = info.width + "px";
            this._arrow.style.top = "-" + 2 * info.arrowSize + "px";
            this._arrow.style.borderWidth = info.arrowSize + "px";
            this._arrow.style.marginLeft = info.arrowOffset + "px";
            this._treeContainer.style.height = treeHeight + "px";
            this._treeContainer.style.width = info.width + "px";
            this._tree.layout();
            this._layoutInfo = info;
        };
        BreadcrumbsPicker = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, workbenchThemeService_1.IWorkbenchThemeService),
            __param(3, configuration_1.IConfigurationService)
        ], BreadcrumbsPicker);
        return BreadcrumbsPicker;
    }());
    exports.BreadcrumbsPicker = BreadcrumbsPicker;
    //#region - Files
    var FileDataSource = /** @class */ (function () {
        function FileDataSource(_fileService) {
            this._fileService = _fileService;
            this._parents = new WeakMap();
        }
        FileDataSource.prototype.getId = function (tree, element) {
            if (uri_1.URI.isUri(element)) {
                return element.toString();
            }
            else if (workspace_1.IWorkspace.isIWorkspace(element)) {
                return element.id;
            }
            else if (workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element)) {
                return element.uri.toString();
            }
            else {
                return element.resource.toString();
            }
        };
        FileDataSource.prototype.hasChildren = function (tree, element) {
            return uri_1.URI.isUri(element) || workspace_1.IWorkspace.isIWorkspace(element) || workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element) || element.isDirectory;
        };
        FileDataSource.prototype.getChildren = function (tree, element) {
            var _this = this;
            if (workspace_1.IWorkspace.isIWorkspace(element)) {
                return Promise.resolve(element.folders).then(function (folders) {
                    for (var _i = 0, folders_1 = folders; _i < folders_1.length; _i++) {
                        var child = folders_1[_i];
                        _this._parents.set(element, child);
                    }
                    return folders;
                });
            }
            var uri;
            if (workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element)) {
                uri = element.uri;
            }
            else if (uri_1.URI.isUri(element)) {
                uri = element;
            }
            else {
                uri = element.resource;
            }
            return this._fileService.resolveFile(uri).then(function (stat) {
                for (var _i = 0, _a = stat.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    _this._parents.set(stat, child);
                }
                return stat.children;
            });
        };
        FileDataSource.prototype.getParent = function (tree, element) {
            return Promise.resolve(this._parents.get(element));
        };
        FileDataSource = __decorate([
            __param(0, files_1.IFileService)
        ], FileDataSource);
        return FileDataSource;
    }());
    exports.FileDataSource = FileDataSource;
    var FileFilter = /** @class */ (function () {
        function FileFilter(_workspaceService, configService) {
            var _this = this;
            this._workspaceService = _workspaceService;
            this._cachedExpressions = new Map();
            this._disposables = [];
            var config = breadcrumbs_1.BreadcrumbsConfig.FileExcludes.bindTo(configService);
            var update = function () {
                _workspaceService.getWorkspace().folders.forEach(function (folder) {
                    var excludesConfig = config.getValue({ resource: folder.uri });
                    if (!excludesConfig) {
                        return;
                    }
                    // adjust patterns to be absolute in case they aren't
                    // free floating (**/)
                    var adjustedConfig = {};
                    for (var pattern in excludesConfig) {
                        if (typeof excludesConfig[pattern] !== 'boolean') {
                            continue;
                        }
                        var patternAbs = pattern.indexOf('**/') !== 0
                            ? paths_1.join(folder.uri.path, pattern)
                            : pattern;
                        adjustedConfig[patternAbs] = excludesConfig[pattern];
                    }
                    _this._cachedExpressions.set(folder.uri.toString(), glob.parse(adjustedConfig));
                });
            };
            update();
            this._disposables.push(config, config.onDidChange(update), _workspaceService.onDidChangeWorkspaceFolders(update));
        }
        FileFilter.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
        };
        FileFilter.prototype.isVisible = function (tree, element) {
            if (workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element)) {
                // not a file
                return true;
            }
            var folder = this._workspaceService.getWorkspaceFolder(element.resource);
            if (!folder || !this._cachedExpressions.has(folder.uri.toString())) {
                // no folder or no filer
                return true;
            }
            var expression = this._cachedExpressions.get(folder.uri.toString());
            return !expression(element.resource.path, resources_1.basename(element.resource));
        };
        FileFilter = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, configuration_1.IConfigurationService)
        ], FileFilter);
        return FileFilter;
    }());
    exports.FileFilter = FileFilter;
    var FileHighlighter = /** @class */ (function () {
        function FileHighlighter() {
        }
        FileHighlighter.prototype.getHighlightsStorageKey = function (element) {
            return workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element) ? element.uri.toString() : element.resource.toString();
        };
        FileHighlighter.prototype.getHighlights = function (tree, element, pattern) {
            return filters_1.fuzzyScore(pattern, element.name, undefined, true);
        };
        return FileHighlighter;
    }());
    exports.FileHighlighter = FileHighlighter;
    var FileRenderer = /** @class */ (function () {
        function FileRenderer(_instantiationService, _configService) {
            this._instantiationService = _instantiationService;
            this._configService = _configService;
        }
        FileRenderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        FileRenderer.prototype.getTemplateId = function (tree, element) {
            return 'FileStat';
        };
        FileRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            return this._instantiationService.createInstance(labels_1.FileLabel, container, { supportHighlights: true });
        };
        FileRenderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            var fileDecorations = this._configService.getValue('explorer.decorations');
            var resource;
            var fileKind;
            if (workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element)) {
                resource = element.uri;
                fileKind = files_1.FileKind.ROOT_FOLDER;
            }
            else {
                resource = element.resource;
                fileKind = element.isDirectory ? files_1.FileKind.FOLDER : files_1.FileKind.FILE;
            }
            templateData.setFile(resource, {
                fileKind: fileKind,
                hidePath: true,
                fileDecorations: fileDecorations,
                matches: filters_1.createMatches(tree.getHighlighterScore(element)),
                extraClasses: ['picker-item']
            });
        };
        FileRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            templateData.dispose();
        };
        FileRenderer = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, configuration_1.IConfigurationService)
        ], FileRenderer);
        return FileRenderer;
    }());
    exports.FileRenderer = FileRenderer;
    var FileSorter = /** @class */ (function () {
        function FileSorter() {
        }
        FileSorter.prototype.compare = function (tree, a, b) {
            if (workspace_1.IWorkspaceFolder.isIWorkspaceFolder(a) && workspace_1.IWorkspaceFolder.isIWorkspaceFolder(b)) {
                return a.index - b.index;
            }
            else {
                if (a.isDirectory === b.isDirectory) {
                    // same type -> compare on names
                    return comparers_1.compareFileNames(a.name, b.name);
                }
                else if (a.isDirectory) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
        };
        return FileSorter;
    }());
    exports.FileSorter = FileSorter;
    var BreadcrumbsFilePicker = /** @class */ (function (_super) {
        __extends(BreadcrumbsFilePicker, _super);
        function BreadcrumbsFilePicker(parent, instantiationService, themeService, configService, _workspaceService) {
            var _this = _super.call(this, parent, instantiationService, themeService, configService) || this;
            _this._workspaceService = _workspaceService;
            return _this;
        }
        BreadcrumbsFilePicker.prototype._getInput = function (input) {
            var _a = input, uri = _a.uri, kind = _a.kind;
            if (kind === files_1.FileKind.ROOT_FOLDER) {
                return this._workspaceService.getWorkspace();
            }
            else {
                return resources_1.dirname(uri);
            }
        };
        BreadcrumbsFilePicker.prototype._getInitialSelection = function (tree, input) {
            var uri = input.uri;
            var nav = tree.getNavigator();
            while (nav.next()) {
                var cur = nav.current();
                var candidate = workspace_1.IWorkspaceFolder.isIWorkspaceFolder(cur) ? cur.uri : cur.resource;
                if (resources_1.isEqual(uri, candidate)) {
                    return cur;
                }
            }
            return undefined;
        };
        BreadcrumbsFilePicker.prototype._completeTreeConfiguration = function (config) {
            // todo@joh reuse explorer implementations?
            var filter = this._instantiationService.createInstance(FileFilter);
            this._disposables.push(filter);
            config.dataSource = this._instantiationService.createInstance(FileDataSource);
            config.renderer = this._instantiationService.createInstance(FileRenderer);
            config.sorter = new FileSorter();
            config.highlighter = new FileHighlighter();
            config.filter = filter;
            return config;
        };
        BreadcrumbsFilePicker.prototype._getTargetFromEvent = function (element, _payload) {
            if (element && !workspace_1.IWorkspaceFolder.isIWorkspaceFolder(element) && !element.isDirectory) {
                return new breadcrumbsModel_1.FileElement(element.resource, files_1.FileKind.FILE);
            }
        };
        BreadcrumbsFilePicker = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, workbenchThemeService_1.IWorkbenchThemeService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, workspace_1.IWorkspaceContextService)
        ], BreadcrumbsFilePicker);
        return BreadcrumbsFilePicker;
    }(BreadcrumbsPicker));
    exports.BreadcrumbsFilePicker = BreadcrumbsFilePicker;
    //#endregion
    //#region - Symbols
    var OutlineHighlighter = /** @class */ (function () {
        function OutlineHighlighter() {
        }
        OutlineHighlighter.prototype.getHighlights = function (tree, element, pattern) {
            outlineModel_1.OutlineModel.get(element).updateMatches(pattern);
            return element.score;
        };
        return OutlineHighlighter;
    }());
    var BreadcrumbsOutlinePicker = /** @class */ (function (_super) {
        __extends(BreadcrumbsOutlinePicker, _super);
        function BreadcrumbsOutlinePicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BreadcrumbsOutlinePicker.prototype._getInput = function (input) {
            var element = input;
            var model = outlineModel_1.OutlineModel.get(element);
            model.updateMatches('');
            return model;
        };
        BreadcrumbsOutlinePicker.prototype._getInitialSelection = function (_tree, input) {
            return input instanceof outlineModel_1.OutlineModel ? undefined : input;
        };
        BreadcrumbsOutlinePicker.prototype._completeTreeConfiguration = function (config) {
            config.dataSource = this._instantiationService.createInstance(outlineTree_1.OutlineDataSource);
            config.renderer = this._instantiationService.createInstance(outlineTree_1.OutlineRenderer);
            config.sorter = new outlineTree_1.OutlineItemComparator();
            config.highlighter = new OutlineHighlighter();
            return config;
        };
        BreadcrumbsOutlinePicker.prototype._getTargetFromEvent = function (element, payload) {
            if (payload && payload.didClickOnTwistie) {
                return;
            }
            if (element instanceof outlineModel_1.OutlineElement) {
                return element;
            }
        };
        return BreadcrumbsOutlinePicker;
    }(BreadcrumbsPicker));
    exports.BreadcrumbsOutlinePicker = BreadcrumbsOutlinePicker;
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

























































define(__m[227/*vs/workbench/browser/parts/editor/breadcrumbsControl*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,137/*vs/base/browser/mouseEvent*/,313/*vs/base/browser/ui/breadcrumbs/breadcrumbsWidget*/,194/*vs/base/browser/ui/iconLabel/iconLabel*/,19/*vs/base/common/arrays*/,17/*vs/base/common/async*/,4/*vs/base/common/lifecycle*/,26/*vs/base/common/network*/,35/*vs/base/common/resources*/,12/*vs/base/common/uri*/,45/*vs/editor/browser/editorBrowser*/,48/*vs/editor/common/core/range*/,85/*vs/editor/common/modes*/,126/*vs/editor/contrib/documentSymbols/outlineModel*/,2/*vs/nls*/,23/*vs/platform/actions/common/actions*/,37/*vs/platform/commands/common/commands*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,51/*vs/platform/list/browser/listService*/,46/*vs/platform/quickOpen/common/quickOpen*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,20/*vs/platform/workspace/common/workspace*/,60/*vs/workbench/browser/labels*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,204/*vs/workbench/browser/parts/editor/breadcrumbsModel*/,409/*vs/workbench/browser/parts/editor/breadcrumbsPicker*/,13/*vs/workbench/common/editor*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,32/*vs/platform/telemetry/common/telemetry*/,96/*vs/editor/browser/services/codeEditorService*/,213/*vs/css!vs/workbench/browser/parts/editor/media/breadcrumbscontrol*/]), function (require, exports, dom, mouseEvent_1, breadcrumbsWidget_1, iconLabel_1, arrays_1, async_1, lifecycle_1, network_1, resources_1, uri_1, editorBrowser_1, range_1, modes_1, outlineModel_1, nls_1, actions_1, commands_1, configuration_1, contextkey_1, contextView_1, files_1, instantiation_1, keybindingsRegistry_1, listService_1, quickOpen_1, styler_1, themeService_1, workspace_1, labels_1, breadcrumbs_1, breadcrumbsModel_1, breadcrumbsPicker_1, editor_1, editorService_1, editorGroupsService_1, telemetry_1, codeEditorService_1) {
    'use strict';
    var _this = this;
    Object.defineProperty(exports, "__esModule", { value: true });
    var Item = /** @class */ (function (_super) {
        __extends(Item, _super);
        function Item(element, options, _instantiationService) {
            var _this = _super.call(this) || this;
            _this.element = element;
            _this.options = options;
            _this._instantiationService = _instantiationService;
            _this._disposables = [];
            return _this;
        }
        Item.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
        };
        Item.prototype.equals = function (other) {
            if (!(other instanceof Item)) {
                return false;
            }
            if (this.element instanceof breadcrumbsModel_1.FileElement && other.element instanceof breadcrumbsModel_1.FileElement) {
                return resources_1.isEqual(this.element.uri, other.element.uri);
            }
            if (this.element instanceof outlineModel_1.TreeElement && other.element instanceof outlineModel_1.TreeElement) {
                return this.element.id === other.element.id;
            }
            return false;
        };
        Item.prototype.render = function (container) {
            if (this.element instanceof breadcrumbsModel_1.FileElement) {
                // file/folder
                var label = this._instantiationService.createInstance(labels_1.FileLabel, container, {});
                label.setFile(this.element.uri, {
                    hidePath: true,
                    hideIcon: this.element.kind === files_1.FileKind.FOLDER || !this.options.showFileIcons,
                    fileKind: this.element.kind,
                    fileDecorations: { colors: this.options.showDecorationColors, badges: false },
                });
                dom.addClass(container, files_1.FileKind[this.element.kind].toLowerCase());
                this._disposables.push(label);
            }
            else if (this.element instanceof outlineModel_1.OutlineModel) {
                // has outline element but not in one
                var label = document.createElement('div');
                label.innerHTML = '&hellip;';
                label.className = 'hint-more';
                container.appendChild(label);
            }
            else if (this.element instanceof outlineModel_1.OutlineGroup) {
                // provider
                var label = new iconLabel_1.IconLabel(container);
                label.setValue(this.element.provider.displayName);
                this._disposables.push(label);
            }
            else if (this.element instanceof outlineModel_1.OutlineElement) {
                // symbol
                if (this.options.showSymbolIcons) {
                    var icon = document.createElement('div');
                    icon.className = modes_1.symbolKindToCssClass(this.element.symbol.kind);
                    container.appendChild(icon);
                    dom.addClass(container, 'shows-symbol-icon');
                }
                var label = new iconLabel_1.IconLabel(container);
                var title = this.element.symbol.name.replace(/\r|\n|\r\n/g, '\u23CE');
                label.setValue(title);
                this._disposables.push(label);
            }
        };
        Item = __decorate([
            __param(2, instantiation_1.IInstantiationService)
        ], Item);
        return Item;
    }(breadcrumbsWidget_1.BreadcrumbsItem));
    var BreadcrumbsControl = /** @class */ (function () {
        function BreadcrumbsControl(container, _options, _editorGroup, _contextKeyService, _contextViewService, _editorService, _codeEditorService, _workspaceService, _instantiationService, _themeService, _quickOpenService, _configurationService, _fileService, _telemetryService, breadcrumbsService) {
            this._options = _options;
            this._editorGroup = _editorGroup;
            this._contextKeyService = _contextKeyService;
            this._contextViewService = _contextViewService;
            this._editorService = _editorService;
            this._codeEditorService = _codeEditorService;
            this._workspaceService = _workspaceService;
            this._instantiationService = _instantiationService;
            this._themeService = _themeService;
            this._quickOpenService = _quickOpenService;
            this._configurationService = _configurationService;
            this._fileService = _fileService;
            this._telemetryService = _telemetryService;
            this._disposables = new Array();
            this._breadcrumbsDisposables = new Array();
            this._breadcrumbsPickerShowing = false;
            this.domNode = document.createElement('div');
            dom.addClass(this.domNode, 'breadcrumbs-control');
            dom.append(container, this.domNode);
            this._widget = new breadcrumbsWidget_1.BreadcrumbsWidget(this.domNode);
            this._widget.onDidSelectItem(this._onSelectEvent, this, this._disposables);
            this._widget.onDidFocusItem(this._onFocusEvent, this, this._disposables);
            this._widget.onDidChangeFocus(this._updateCkBreadcrumbsActive, this, this._disposables);
            this._disposables.push(styler_1.attachBreadcrumbsStyler(this._widget, this._themeService, { breadcrumbsBackground: _options.breadcrumbsBackground }));
            this._ckBreadcrumbsPossible = BreadcrumbsControl.CK_BreadcrumbsPossible.bindTo(this._contextKeyService);
            this._ckBreadcrumbsVisible = BreadcrumbsControl.CK_BreadcrumbsVisible.bindTo(this._contextKeyService);
            this._ckBreadcrumbsActive = BreadcrumbsControl.CK_BreadcrumbsActive.bindTo(this._contextKeyService);
            this._cfUseQuickPick = breadcrumbs_1.BreadcrumbsConfig.UseQuickPick.bindTo(_configurationService);
            this._disposables.push(breadcrumbsService.register(this._editorGroup.id, this._widget));
        }
        BreadcrumbsControl.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._breadcrumbsDisposables = lifecycle_1.dispose(this._breadcrumbsDisposables);
            this._ckBreadcrumbsPossible.reset();
            this._ckBreadcrumbsVisible.reset();
            this._ckBreadcrumbsActive.reset();
            this._cfUseQuickPick.dispose();
            this._widget.dispose();
            this.domNode.remove();
        };
        BreadcrumbsControl.prototype.layout = function (dim) {
            this._widget.layout(dim);
        };
        BreadcrumbsControl.prototype.isHidden = function () {
            return dom.hasClass(this.domNode, 'hidden');
        };
        BreadcrumbsControl.prototype.hide = function () {
            this._breadcrumbsDisposables = lifecycle_1.dispose(this._breadcrumbsDisposables);
            this._ckBreadcrumbsVisible.set(false);
            dom.toggleClass(this.domNode, 'hidden', true);
        };
        BreadcrumbsControl.prototype.update = function () {
            var _this = this;
            this._breadcrumbsDisposables = lifecycle_1.dispose(this._breadcrumbsDisposables);
            // honor diff editors and such
            var input = this._editorGroup.activeEditor;
            if (input instanceof editor_1.SideBySideEditorInput) {
                input = input.master;
            }
            if (!input || !input.getResource() || (input.getResource().scheme !== network_1.Schemas.untitled && !this._fileService.canHandleResource(input.getResource()))) {
                // cleanup and return when there is no input or when
                // we cannot handle this input
                this._ckBreadcrumbsPossible.set(false);
                if (!this.isHidden()) {
                    this.hide();
                    return true;
                }
                else {
                    return false;
                }
            }
            dom.toggleClass(this.domNode, 'hidden', false);
            this._ckBreadcrumbsVisible.set(true);
            this._ckBreadcrumbsPossible.set(true);
            var editor = this._getActiveCodeEditor();
            var model = new breadcrumbsModel_1.EditorBreadcrumbsModel(input.getResource(), editor, this._workspaceService, this._configurationService);
            dom.toggleClass(this.domNode, 'relative-path', model.isRelative());
            var updateBreadcrumbs = function () {
                var items = model.getElements().map(function (element) { return new Item(element, _this._options, _this._instantiationService); });
                _this._widget.setItems(items);
                _this._widget.reveal(items[items.length - 1]);
            };
            var listener = model.onDidUpdate(updateBreadcrumbs);
            updateBreadcrumbs();
            this._breadcrumbsDisposables = [model, listener];
            // close picker on hide/update
            this._breadcrumbsDisposables.push({
                dispose: function () {
                    if (_this._breadcrumbsPickerShowing) {
                        _this._contextViewService.hideContextView(_this);
                    }
                }
            });
            return true;
        };
        BreadcrumbsControl.prototype._getActiveCodeEditor = function () {
            var control = this._editorGroup.activeControl.getControl();
            var editor;
            if (editorBrowser_1.isCodeEditor(control)) {
                editor = control;
            }
            else if (editorBrowser_1.isDiffEditor(control)) {
                editor = control.getModifiedEditor();
            }
            return editor;
        };
        BreadcrumbsControl.prototype._onFocusEvent = function (event) {
            if (event.item && this._breadcrumbsPickerShowing) {
                return this._widget.setSelection(event.item);
            }
        };
        BreadcrumbsControl.prototype._onSelectEvent = function (event) {
            var _this = this;
            if (!event.item) {
                return;
            }
            var element = event.item.element;
            this._editorGroup.focus();
            /* __GDPR__
                "breadcrumbs/select" : {
                    "type": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this._telemetryService.publicLog('breadcrumbs/select', { type: element instanceof outlineModel_1.TreeElement ? 'symbol' : 'file' });
            var group = this._getEditorGroup(event.payload);
            if (group !== undefined) {
                // reveal the item
                this._widget.setFocused(undefined);
                this._widget.setSelection(undefined);
                this._revealInEditor(event, element, group);
                return;
            }
            if (this._cfUseQuickPick.getValue()) {
                // using quick pick
                this._widget.setFocused(undefined);
                this._widget.setSelection(undefined);
                this._quickOpenService.show(element instanceof outlineModel_1.TreeElement ? '@' : '');
                return;
            }
            // show picker
            var picker;
            var editor = this._getActiveCodeEditor();
            var editorDecorations = [];
            var editorViewState;
            this._contextViewService.showContextView({
                render: function (parent) {
                    picker = breadcrumbsPicker_1.createBreadcrumbsPicker(_this._instantiationService, parent, element);
                    var selectListener = picker.onDidPickElement(function (data) {
                        if (data.target) {
                            editorViewState = undefined;
                        }
                        _this._contextViewService.hideContextView(_this);
                        _this._revealInEditor(event, data.target, _this._getEditorGroup(data.payload && data.payload.originalEvent));
                        /* __GDPR__
                            "breadcrumbs/open" : {
                                "type": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                            }
                        */
                        _this._telemetryService.publicLog('breadcrumbs/open', { type: !data ? 'nothing' : data.target instanceof outlineModel_1.TreeElement ? 'symbol' : 'file' });
                    });
                    var focusListener = picker.onDidFocusElement(function (data) {
                        if (!editor || !(data.target instanceof outlineModel_1.OutlineElement)) {
                            return;
                        }
                        if (!editorViewState) {
                            editorViewState = editor.saveViewState();
                        }
                        var symbol = data.target.symbol;
                        editor.revealRangeInCenter(symbol.range, 0 /* Smooth */);
                        editorDecorations = editor.deltaDecorations(editorDecorations, [{
                                range: symbol.range,
                                options: {
                                    className: 'rangeHighlight',
                                    isWholeLine: true
                                }
                            }]);
                    });
                    _this._breadcrumbsPickerShowing = true;
                    _this._updateCkBreadcrumbsActive();
                    return lifecycle_1.combinedDisposable([selectListener, focusListener, picker]);
                },
                getAnchor: function () {
                    var maxInnerWidth = window.innerWidth - 8 /*a little less the full widget*/;
                    var maxHeight = Math.min(window.innerHeight * .7, 300);
                    var pickerWidth = Math.min(maxInnerWidth, Math.max(240, maxInnerWidth / 4.17));
                    var pickerArrowSize = 8;
                    var pickerArrowOffset;
                    var data = dom.getDomNodePagePosition(event.node.firstChild);
                    var y = data.top + data.height + pickerArrowSize;
                    if (y + maxHeight >= window.innerHeight) {
                        maxHeight = window.innerHeight - y - 30 /* room for shadow and status bar*/;
                    }
                    var x = data.left;
                    if (x + pickerWidth >= maxInnerWidth) {
                        x = maxInnerWidth - pickerWidth;
                    }
                    if (event.payload instanceof mouseEvent_1.StandardMouseEvent) {
                        var maxPickerArrowOffset = pickerWidth - 2 * pickerArrowSize;
                        pickerArrowOffset = event.payload.posx - x;
                        if (pickerArrowOffset > maxPickerArrowOffset) {
                            x = Math.min(maxInnerWidth - pickerWidth, x + pickerArrowOffset - maxPickerArrowOffset);
                            pickerArrowOffset = maxPickerArrowOffset;
                        }
                    }
                    else {
                        pickerArrowOffset = (data.left + (data.width * .3)) - x;
                    }
                    picker.setInput(element, maxHeight, pickerWidth, pickerArrowSize, Math.max(0, pickerArrowOffset));
                    return { x: x, y: y };
                },
                onHide: function (data) {
                    if (editor) {
                        editor.deltaDecorations(editorDecorations, []);
                        if (editorViewState) {
                            editor.restoreViewState(editorViewState);
                        }
                    }
                    _this._breadcrumbsPickerShowing = false;
                    _this._updateCkBreadcrumbsActive();
                    if (data === _this) {
                        _this._widget.setFocused(undefined);
                        _this._widget.setSelection(undefined);
                    }
                }
            });
        };
        BreadcrumbsControl.prototype._updateCkBreadcrumbsActive = function () {
            var value = this._widget.isDOMFocused() || this._breadcrumbsPickerShowing;
            this._ckBreadcrumbsActive.set(value);
        };
        BreadcrumbsControl.prototype._revealInEditor = function (event, element, group) {
            if (element instanceof breadcrumbsModel_1.FileElement) {
                if (element.kind === files_1.FileKind.FILE) {
                    // open file in any editor
                    this._editorService.openEditor({ resource: element.uri }, group);
                }
                else {
                    // show next picker
                    var items = this._widget.getItems();
                    var idx = items.indexOf(event.item);
                    this._widget.setFocused(items[idx + 1]);
                    this._widget.setSelection(items[idx + 1], BreadcrumbsControl.Payload_Pick);
                }
            }
            else if (element instanceof outlineModel_1.OutlineElement) {
                // open symbol in code editor
                var model = outlineModel_1.OutlineModel.get(element);
                this._codeEditorService.openCodeEditor({
                    resource: model.textModel.uri,
                    options: {
                        selection: range_1.Range.collapseToStart(element.symbol.selectionRange),
                        revealInCenterIfOutsideViewport: true
                    }
                }, this._getActiveCodeEditor(), group === editorService_1.SIDE_GROUP);
            }
        };
        BreadcrumbsControl.prototype._getEditorGroup = function (data) {
            if (data === BreadcrumbsControl.Payload_RevealAside || (data instanceof mouseEvent_1.StandardMouseEvent && data.altKey)) {
                return editorService_1.SIDE_GROUP;
            }
            else if (data === BreadcrumbsControl.Payload_Reveal || (data instanceof mouseEvent_1.StandardMouseEvent && data.metaKey)) {
                return editorService_1.ACTIVE_GROUP;
            }
            else {
                return undefined;
            }
        };
        BreadcrumbsControl.HEIGHT = 22;
        BreadcrumbsControl.Payload_Reveal = {};
        BreadcrumbsControl.Payload_RevealAside = {};
        BreadcrumbsControl.Payload_Pick = {};
        BreadcrumbsControl.CK_BreadcrumbsPossible = new contextkey_1.RawContextKey('breadcrumbsPossible', false);
        BreadcrumbsControl.CK_BreadcrumbsVisible = new contextkey_1.RawContextKey('breadcrumbsVisible', false);
        BreadcrumbsControl.CK_BreadcrumbsActive = new contextkey_1.RawContextKey('breadcrumbsActive', false);
        BreadcrumbsControl = __decorate([
            __param(3, contextkey_1.IContextKeyService),
            __param(4, contextView_1.IContextViewService),
            __param(5, editorService_1.IEditorService),
            __param(6, codeEditorService_1.ICodeEditorService),
            __param(7, workspace_1.IWorkspaceContextService),
            __param(8, instantiation_1.IInstantiationService),
            __param(9, themeService_1.IThemeService),
            __param(10, quickOpen_1.IQuickOpenService),
            __param(11, configuration_1.IConfigurationService),
            __param(12, files_1.IFileService),
            __param(13, telemetry_1.ITelemetryService),
            __param(14, breadcrumbs_1.IBreadcrumbsService)
        ], BreadcrumbsControl);
        return BreadcrumbsControl;
    }());
    exports.BreadcrumbsControl = BreadcrumbsControl;
    //#region commands
    // toggle command
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
        command: {
            id: 'breadcrumbs.toggle',
            title: { value: nls_1.localize('cmd.toggle', "Toggle Breadcrumbs"), original: 'Toggle Breadcrumbs' },
            category: nls_1.localize('cmd.category', "View")
        }
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {
        group: '5_editor',
        order: 99,
        command: {
            id: 'breadcrumbs.toggle',
            title: nls_1.localize('miToggleBreadcrumbs', "Toggle &&Breadcrumbs")
        }
    });
    commands_1.CommandsRegistry.registerCommand('breadcrumbs.toggle', function (accessor) {
        var config = accessor.get(configuration_1.IConfigurationService);
        var value = breadcrumbs_1.BreadcrumbsConfig.IsEnabled.bindTo(config).getValue();
        breadcrumbs_1.BreadcrumbsConfig.IsEnabled.bindTo(config).updateValue(!value);
    });
    // focus/focus-and-select
    function focusAndSelectHandler(accessor, select) {
        // find widget and focus/select
        var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
        var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
        var widget = breadcrumbs.getWidget(groups.activeGroup.id);
        if (widget) {
            var item = arrays_1.tail(widget.getItems());
            widget.setFocused(item);
            if (select) {
                widget.setSelection(item, BreadcrumbsControl.Payload_Pick);
            }
        }
    }
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
        command: {
            id: 'breadcrumbs.focusAndSelect',
            title: { value: nls_1.localize('cmd.focus', "Focus Breadcrumbs"), original: 'Focus Breadcrumbs' },
            precondition: BreadcrumbsControl.CK_BreadcrumbsVisible
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.focusAndSelect',
        weight: 200 /* WorkbenchContrib */,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 84 /* US_DOT */,
        when: BreadcrumbsControl.CK_BreadcrumbsPossible,
        handler: function (accessor) { return focusAndSelectHandler(accessor, true); }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.focus',
        weight: 200 /* WorkbenchContrib */,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 80 /* US_SEMICOLON */,
        when: BreadcrumbsControl.CK_BreadcrumbsPossible,
        handler: function (accessor) { return focusAndSelectHandler(accessor, false); }
    });
    // this commands is only enabled when breadcrumbs are
    // disabled which it then enables and focuses
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.toggleToOn',
        weight: 200 /* WorkbenchContrib */,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 84 /* US_DOT */,
        when: contextkey_1.ContextKeyExpr.not('config.breadcrumbs.enabled'),
        handler: function (accessor) { return __awaiter(_this, void 0, void 0, function () {
            var instant, config, isEnabled;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        instant = accessor.get(instantiation_1.IInstantiationService);
                        config = accessor.get(configuration_1.IConfigurationService);
                        isEnabled = breadcrumbs_1.BreadcrumbsConfig.IsEnabled.bindTo(config);
                        if (!!isEnabled.getValue()) return [3 /*break*/, 3];
                        return [4 /*yield*/, isEnabled.updateValue(true)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, async_1.timeout(50)];
                    case 2:
                        _a.sent(); // hacky - the widget might not be ready yet...
                        _a.label = 3;
                    case 3: return [2 /*return*/, instant.invokeFunction(focusAndSelectHandler, true)];
                }
            });
        }); }
    });
    // navigation
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.focusNext',
        weight: 200 /* WorkbenchContrib */,
        primary: 17 /* RightArrow */,
        secondary: [2048 /* CtrlCmd */ | 17 /* RightArrow */],
        mac: {
            primary: 17 /* RightArrow */,
            secondary: [512 /* Alt */ | 17 /* RightArrow */],
        },
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive),
        handler: function (accessor) {
            var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
            breadcrumbs.getWidget(groups.activeGroup.id).focusNext();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.focusPrevious',
        weight: 200 /* WorkbenchContrib */,
        primary: 15 /* LeftArrow */,
        secondary: [2048 /* CtrlCmd */ | 15 /* LeftArrow */],
        mac: {
            primary: 15 /* LeftArrow */,
            secondary: [512 /* Alt */ | 15 /* LeftArrow */],
        },
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive),
        handler: function (accessor) {
            var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
            breadcrumbs.getWidget(groups.activeGroup.id).focusPrev();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.selectFocused',
        weight: 200 /* WorkbenchContrib */,
        primary: 3 /* Enter */,
        secondary: [18 /* DownArrow */],
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive),
        handler: function (accessor) {
            var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
            var widget = breadcrumbs.getWidget(groups.activeGroup.id);
            widget.setSelection(widget.getFocused(), BreadcrumbsControl.Payload_Pick);
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.revealFocused',
        weight: 200 /* WorkbenchContrib */,
        primary: 10 /* Space */,
        secondary: [2048 /* CtrlCmd */ | 3 /* Enter */],
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive),
        handler: function (accessor) {
            var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
            var widget = breadcrumbs.getWidget(groups.activeGroup.id);
            widget.setSelection(widget.getFocused(), BreadcrumbsControl.Payload_Reveal);
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.selectEditor',
        weight: 200 /* WorkbenchContrib */ + 1,
        primary: 9 /* Escape */,
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive),
        handler: function (accessor) {
            var groups = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var breadcrumbs = accessor.get(breadcrumbs_1.IBreadcrumbsService);
            breadcrumbs.getWidget(groups.activeGroup.id).setFocused(undefined);
            breadcrumbs.getWidget(groups.activeGroup.id).setSelection(undefined);
            groups.activeGroup.activeControl.focus();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'breadcrumbs.revealFocusedFromTreeAside',
        weight: 200 /* WorkbenchContrib */,
        primary: 2048 /* CtrlCmd */ | 3 /* Enter */,
        when: contextkey_1.ContextKeyExpr.and(BreadcrumbsControl.CK_BreadcrumbsVisible, BreadcrumbsControl.CK_BreadcrumbsActive, listService_1.WorkbenchListFocusContextKey),
        handler: function (accessor) {
            var editors = accessor.get(editorService_1.IEditorService);
            var lists = accessor.get(listService_1.IListService);
            var element = lists.lastFocusedList.getFocus();
            if (element instanceof outlineModel_1.OutlineElement) {
                // open symbol in editor
                return editors.openEditor({
                    resource: outlineModel_1.OutlineModel.get(element).textModel.uri,
                    options: { selection: range_1.Range.collapseToStart(element.symbol.selectionRange) }
                }, editorService_1.SIDE_GROUP);
            }
            else if (uri_1.URI.isUri(element.resource)) {
                // open file in editor
                return editors.openEditor({
                    resource: element.resource,
                }, editorService_1.SIDE_GROUP);
            }
            else {
                // ignore
                return undefined;
            }
        }
    });
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[412/*vs/workbench/browser/parts/editor/editorDropTarget*/], __M([0/*require*/,1/*exports*/,84/*vs/workbench/browser/dnd*/,8/*vs/base/browser/dom*/,87/*vs/workbench/browser/parts/editor/editor*/,58/*vs/workbench/common/theme*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,13/*vs/workbench/common/editor*/,18/*vs/base/common/platform*/,4/*vs/base/common/lifecycle*/,3/*vs/platform/instantiation/common/instantiation*/,17/*vs/base/common/async*/,394/*vs/css!vs/workbench/browser/parts/editor/media/editordroptarget*/]), function (require, exports, dnd_1, dom_1, editor_1, theme_1, themeService_1, colorRegistry_1, editor_2, platform_1, lifecycle_1, instantiation_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DropOverlay = /** @class */ (function (_super) {
        __extends(DropOverlay, _super);
        function DropOverlay(accessor, groupView, themeService, instantiationService) {
            var _this = _super.call(this, themeService) || this;
            _this.accessor = accessor;
            _this.groupView = groupView;
            _this.instantiationService = instantiationService;
            _this.editorTransfer = dnd_1.LocalSelectionTransfer.getInstance();
            _this.groupTransfer = dnd_1.LocalSelectionTransfer.getInstance();
            _this.cleanupOverlayScheduler = _this._register(new async_1.RunOnceScheduler(function () { return _this.dispose(); }, 300));
            _this.create();
            return _this;
        }
        Object.defineProperty(DropOverlay.prototype, "disposed", {
            get: function () {
                return this._disposed;
            },
            enumerable: true,
            configurable: true
        });
        DropOverlay.prototype.create = function () {
            var _this = this;
            var overlayOffsetHeight = this.getOverlayOffsetHeight();
            // Container
            this.container = document.createElement('div');
            this.container.id = DropOverlay.OVERLAY_ID;
            this.container.style.top = overlayOffsetHeight + "px";
            // Parent
            this.groupView.element.appendChild(this.container);
            dom_1.addClass(this.groupView.element, 'dragged-over');
            this._register(lifecycle_1.toDisposable(function () {
                _this.groupView.element.removeChild(_this.container);
                dom_1.removeClass(_this.groupView.element, 'dragged-over');
            }));
            // Overlay
            this.overlay = document.createElement('div');
            dom_1.addClass(this.overlay, 'editor-group-overlay-indicator');
            this.container.appendChild(this.overlay);
            // Overlay Event Handling
            this.registerListeners();
            // Styles
            this.updateStyles();
        };
        DropOverlay.prototype.updateStyles = function () {
            // Overlay drop background
            this.overlay.style.backgroundColor = this.getColor(theme_1.EDITOR_DRAG_AND_DROP_BACKGROUND);
            // Overlay contrast border (if any)
            var activeContrastBorderColor = this.getColor(colorRegistry_1.activeContrastBorder);
            this.overlay.style.outlineColor = activeContrastBorderColor;
            this.overlay.style.outlineOffset = activeContrastBorderColor ? '-2px' : null;
            this.overlay.style.outlineStyle = activeContrastBorderColor ? 'dashed' : null;
            this.overlay.style.outlineWidth = activeContrastBorderColor ? '2px' : null;
        };
        DropOverlay.prototype.registerListeners = function () {
            var _this = this;
            this._register(new dnd_1.DragAndDropObserver(this.container, {
                onDragEnter: function (e) { return void 0; },
                onDragOver: function (e) {
                    var isDraggingGroup = _this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype);
                    var isDraggingEditor = _this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype);
                    // Update the dropEffect to "copy" if there is no local data to be dragged because
                    // in that case we can only copy the data into and not move it from its source
                    if (!isDraggingEditor && !isDraggingGroup) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                    // Find out if operation is valid
                    var isCopy = isDraggingGroup ? _this.isCopyOperation(e) : isDraggingEditor ? _this.isCopyOperation(e, _this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier) : true;
                    if (!isCopy) {
                        var sourceGroupView = _this.findSourceGroupView();
                        if (sourceGroupView === _this.groupView) {
                            if (isDraggingGroup || (isDraggingEditor && sourceGroupView.count < 2)) {
                                _this.hideOverlay();
                                return; // do not allow to drop group/editor on itself if this results in an empty group
                            }
                        }
                    }
                    // Position overlay
                    _this.positionOverlay(e.offsetX, e.offsetY, isDraggingGroup);
                    // Make sure to stop any running cleanup scheduler to remove the overlay
                    if (_this.cleanupOverlayScheduler.isScheduled()) {
                        _this.cleanupOverlayScheduler.cancel();
                    }
                },
                onDragLeave: function (e) { return _this.dispose(); },
                onDragEnd: function (e) { return _this.dispose(); },
                onDrop: function (e) {
                    dom_1.EventHelper.stop(e, true);
                    // Dispose overlay
                    _this.dispose();
                    // Handle drop if we have a valid operation
                    if (_this.currentDropOperation) {
                        _this.handleDrop(e, _this.currentDropOperation.splitDirection);
                    }
                }
            }));
            this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.MOUSE_OVER, function () {
                // Under some circumstances we have seen reports where the drop overlay is not being
                // cleaned up and as such the editor area remains under the overlay so that you cannot
                // type into the editor anymore. This seems related to using VMs and DND via host and
                // guest OS, though some users also saw it without VMs.
                // To protect against this issue we always destroy the overlay as soon as we detect a
                // mouse event over it. The delay is used to guarantee we are not interfering with the
                // actual DROP event that can also trigger a mouse over event.
                if (!_this.cleanupOverlayScheduler.isScheduled()) {
                    _this.cleanupOverlayScheduler.schedule();
                }
            }));
        };
        DropOverlay.prototype.findSourceGroupView = function () {
            // Check for group transfer
            if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {
                return this.accessor.getGroup(this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0].identifier);
            }
            // Check for editor transfer
            else if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                return this.accessor.getGroup(this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier.groupId);
            }
            return void 0;
        };
        DropOverlay.prototype.handleDrop = function (event, splitDirection) {
            var _this = this;
            // Determine target group
            var ensureTargetGroup = function () {
                var targetGroup;
                if (typeof splitDirection === 'number') {
                    targetGroup = _this.accessor.addGroup(_this.groupView, splitDirection);
                }
                else {
                    targetGroup = _this.groupView;
                }
                return targetGroup;
            };
            // Check for group transfer
            if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {
                var draggedEditorGroup = this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0].identifier;
                // Return if the drop is a no-op
                var sourceGroup = this.accessor.getGroup(draggedEditorGroup);
                if (typeof splitDirection !== 'number' && sourceGroup === this.groupView) {
                    return;
                }
                // Split to new group
                var targetGroup = void 0;
                if (typeof splitDirection === 'number') {
                    if (this.isCopyOperation(event)) {
                        targetGroup = this.accessor.copyGroup(sourceGroup, this.groupView, splitDirection);
                    }
                    else {
                        targetGroup = this.accessor.moveGroup(sourceGroup, this.groupView, splitDirection);
                    }
                }
                // Merge into existing group
                else {
                    if (this.isCopyOperation(event)) {
                        targetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView, { mode: 0 /* COPY_EDITORS */ });
                    }
                    else {
                        targetGroup = this.accessor.mergeGroup(sourceGroup, this.groupView);
                    }
                }
                this.accessor.activateGroup(targetGroup);
                this.groupTransfer.clearData(dnd_1.DraggedEditorGroupIdentifier.prototype);
            }
            // Check for editor transfer
            else if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                var draggedEditor = this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier;
                var targetGroup = ensureTargetGroup();
                // Return if the drop is a no-op
                var sourceGroup = this.accessor.getGroup(draggedEditor.groupId);
                if (sourceGroup === targetGroup) {
                    return;
                }
                // Open in target group
                var options = editor_1.getActiveTextEditorOptions(sourceGroup, draggedEditor.editor, editor_2.EditorOptions.create({ pinned: true }));
                targetGroup.openEditor(draggedEditor.editor, options);
                // Ensure target has focus
                targetGroup.focus();
                // Close in source group unless we copy
                var copyEditor = this.isCopyOperation(event, draggedEditor);
                if (!copyEditor) {
                    sourceGroup.closeEditor(draggedEditor.editor);
                }
                this.editorTransfer.clearData(dnd_1.DraggedEditorIdentifier.prototype);
            }
            // Check for URI transfer
            else {
                var dropHandler = this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: true /* open workspace instead of file if dropped */ });
                dropHandler.handleDrop(event, function () { return ensureTargetGroup(); }, function (targetGroup) { return targetGroup.focus(); });
            }
        };
        DropOverlay.prototype.isCopyOperation = function (e, draggedEditor) {
            if (draggedEditor && !draggedEditor.editor.supportsSplitEditor()) {
                return false;
            }
            return (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
        };
        DropOverlay.prototype.positionOverlay = function (mousePosX, mousePosY, isDraggingGroup) {
            var _this = this;
            var preferSplitVertically = this.accessor.partOptions.openSideBySideDirection === 'right';
            var editorControlWidth = this.groupView.element.clientWidth;
            var editorControlHeight = this.groupView.element.clientHeight - this.getOverlayOffsetHeight();
            var edgeWidthThresholdFactor;
            if (isDraggingGroup) {
                edgeWidthThresholdFactor = preferSplitVertically ? 0.3 : 0.1; // give larger threshold when dragging group depending on preferred split direction
            }
            else {
                edgeWidthThresholdFactor = 0.1; // 10% threshold to split if dragging editors
            }
            var edgeHeightThresholdFactor;
            if (isDraggingGroup) {
                edgeHeightThresholdFactor = preferSplitVertically ? 0.1 : 0.3; // give larger threshold when dragging group depending on preferred split direction
            }
            else {
                edgeHeightThresholdFactor = 0.1; // 10% threshold to split if dragging editors
            }
            var edgeWidthThreshold = editorControlWidth * edgeWidthThresholdFactor;
            var edgeHeightThreshold = editorControlHeight * edgeHeightThresholdFactor;
            var splitWidthThreshold = editorControlWidth / 3; // offer to split left/right at 33%
            var splitHeightThreshold = editorControlHeight / 3; // offer to split up/down at 33%
            // Enable to debug the drop threshold square
            // let child = this.overlay.children.item(0) as HTMLElement || this.overlay.appendChild(document.createElement('div'));
            // child.style.backgroundColor = 'red';
            // child.style.position = 'absolute';
            // child.style.width = (groupViewWidth - (2 * edgeWidthThreshold)) + 'px';
            // child.style.height = (groupViewHeight - (2 * edgeHeightThreshold)) + 'px';
            // child.style.left = edgeWidthThreshold + 'px';
            // child.style.top = edgeHeightThreshold + 'px';
            // No split if mouse is above certain threshold in the center of the view
            var splitDirection;
            if (mousePosX > edgeWidthThreshold && mousePosX < editorControlWidth - edgeWidthThreshold &&
                mousePosY > edgeHeightThreshold && mousePosY < editorControlHeight - edgeHeightThreshold) {
                splitDirection = void 0;
            }
            // Offer to split otherwise
            else {
                // User prefers to split vertically: offer a larger hitzone
                // for this direction like so:
                // ----------------------------------------------
                // |		|		SPLIT UP		|			|
                // | SPLIT 	|-----------------------|	SPLIT	|
                // |		|		  MERGE			|			|
                // | LEFT	|-----------------------|	RIGHT	|
                // |		|		SPLIT DOWN		|			|
                // ----------------------------------------------
                if (preferSplitVertically) {
                    if (mousePosX < splitWidthThreshold) {
                        splitDirection = 2 /* LEFT */;
                    }
                    else if (mousePosX > splitWidthThreshold * 2) {
                        splitDirection = 3 /* RIGHT */;
                    }
                    else if (mousePosY < editorControlHeight / 2) {
                        splitDirection = 0 /* UP */;
                    }
                    else {
                        splitDirection = 1 /* DOWN */;
                    }
                }
                // User prefers to split horizontally: offer a larger hitzone
                // for this direction like so:
                // ----------------------------------------------
                // |				SPLIT UP					|
                // |--------------------------------------------|
                // |  SPLIT LEFT  |	   MERGE	|  SPLIT RIGHT  |
                // |--------------------------------------------|
                // |				SPLIT DOWN					|
                // ----------------------------------------------
                else {
                    if (mousePosY < splitHeightThreshold) {
                        splitDirection = 0 /* UP */;
                    }
                    else if (mousePosY > splitHeightThreshold * 2) {
                        splitDirection = 1 /* DOWN */;
                    }
                    else if (mousePosX < editorControlWidth / 2) {
                        splitDirection = 2 /* LEFT */;
                    }
                    else {
                        splitDirection = 3 /* RIGHT */;
                    }
                }
            }
            // Draw overlay based on split direction
            switch (splitDirection) {
                case 0 /* UP */:
                    this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '50%' });
                    break;
                case 1 /* DOWN */:
                    this.doPositionOverlay({ top: '50%', left: '0', width: '100%', height: '50%' });
                    break;
                case 2 /* LEFT */:
                    this.doPositionOverlay({ top: '0', left: '0', width: '50%', height: '100%' });
                    break;
                case 3 /* RIGHT */:
                    this.doPositionOverlay({ top: '0', left: '50%', width: '50%', height: '100%' });
                    break;
                default:
                    this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });
            }
            // Make sure the overlay is visible now
            this.overlay.style.opacity = '1';
            // Enable transition after a timeout to prevent initial animation
            setTimeout(function () { return dom_1.addClass(_this.overlay, 'overlay-move-transition'); }, 0);
            // Remember as current split direction
            this.currentDropOperation = { splitDirection: splitDirection };
        };
        DropOverlay.prototype.doPositionOverlay = function (options) {
            // Container
            var offsetHeight = this.getOverlayOffsetHeight();
            if (offsetHeight) {
                this.container.style.height = "calc(100% - " + offsetHeight + "px)";
            }
            else {
                this.container.style.height = '100%';
            }
            // Overlay
            this.overlay.style.top = options.top;
            this.overlay.style.left = options.left;
            this.overlay.style.width = options.width;
            this.overlay.style.height = options.height;
        };
        DropOverlay.prototype.getOverlayOffsetHeight = function () {
            if (!this.groupView.isEmpty() && this.accessor.partOptions.showTabs) {
                return editor_1.EDITOR_TITLE_HEIGHT; // show overlay below title if group shows tabs
            }
            return 0;
        };
        DropOverlay.prototype.hideOverlay = function () {
            // Reset overlay
            this.doPositionOverlay({ top: '0', left: '0', width: '100%', height: '100%' });
            this.overlay.style.opacity = '0';
            dom_1.removeClass(this.overlay, 'overlay-move-transition');
            // Reset current operation
            this.currentDropOperation = void 0;
        };
        DropOverlay.prototype.contains = function (element) {
            return element === this.container || element === this.overlay;
        };
        DropOverlay.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._disposed = true;
        };
        DropOverlay.OVERLAY_ID = 'monaco-workbench-editor-drop-overlay';
        return DropOverlay;
    }(theme_1.Themable));
    var EditorDropTarget = /** @class */ (function (_super) {
        __extends(EditorDropTarget, _super);
        function EditorDropTarget(accessor, container, themeService, instantiationService) {
            var _this = _super.call(this, themeService) || this;
            _this.accessor = accessor;
            _this.container = container;
            _this.instantiationService = instantiationService;
            _this.counter = 0;
            _this.editorTransfer = dnd_1.LocalSelectionTransfer.getInstance();
            _this.groupTransfer = dnd_1.LocalSelectionTransfer.getInstance();
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(EditorDropTarget.prototype, "overlay", {
            get: function () {
                if (this._overlay && !this._overlay.disposed) {
                    return this._overlay;
                }
                return void 0;
            },
            enumerable: true,
            configurable: true
        });
        EditorDropTarget.prototype.registerListeners = function () {
            var _this = this;
            this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.DRAG_ENTER, function (e) { return _this.onDragEnter(e); }));
            this._register(dom_1.addDisposableListener(this.container, dom_1.EventType.DRAG_LEAVE, function () { return _this.onDragLeave(); }));
            [this.container, window].forEach(function (node) { return _this._register(dom_1.addDisposableListener(node, dom_1.EventType.DRAG_END, function () { return _this.onDragEnd(); })); });
        };
        EditorDropTarget.prototype.onDragEnter = function (event) {
            this.counter++;
            // Validate transfer
            if (!this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype) &&
                !this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype) &&
                !event.dataTransfer.types.length // see https://github.com/Microsoft/vscode/issues/25789
            ) {
                event.dataTransfer.dropEffect = 'none';
                return; // unsupported transfer
            }
            // Signal DND start
            this.updateContainer(true);
            var target = event.target;
            if (target) {
                // Somehow we managed to move the mouse quickly out of the current overlay, so destroy it
                if (this.overlay && !this.overlay.contains(target)) {
                    this.disposeOverlay();
                }
                // Create overlay over target
                if (!this.overlay) {
                    var targetGroupView = this.findTargetGroupView(target);
                    if (targetGroupView) {
                        this._overlay = new DropOverlay(this.accessor, targetGroupView, this.themeService, this.instantiationService);
                    }
                }
            }
        };
        EditorDropTarget.prototype.onDragLeave = function () {
            this.counter--;
            if (this.counter === 0) {
                this.updateContainer(false);
            }
        };
        EditorDropTarget.prototype.onDragEnd = function () {
            this.counter = 0;
            this.updateContainer(false);
            this.disposeOverlay();
        };
        EditorDropTarget.prototype.findTargetGroupView = function (child) {
            var groups = this.accessor.groups;
            for (var i = 0; i < groups.length; i++) {
                var groupView = groups[i];
                if (dom_1.isAncestor(child, groupView.element)) {
                    return groupView;
                }
            }
            return void 0;
        };
        EditorDropTarget.prototype.updateContainer = function (isDraggedOver) {
            dom_1.toggleClass(this.container, 'dragged-over', isDraggedOver);
        };
        EditorDropTarget.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.disposeOverlay();
        };
        EditorDropTarget.prototype.disposeOverlay = function () {
            if (this.overlay) {
                this.overlay.dispose();
                this._overlay = void 0;
            }
        };
        EditorDropTarget = __decorate([
            __param(2, themeService_1.IThemeService),
            __param(3, instantiation_1.IInstantiationService)
        ], EditorDropTarget);
        return EditorDropTarget;
    }(theme_1.Themable));
    exports.EditorDropTarget = EditorDropTarget;
});























define(__m[229/*vs/workbench/browser/parts/editor/editorPicker*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,41/*vs/editor/common/services/modeService*/,60/*vs/workbench/browser/labels*/,36/*vs/editor/common/services/modelService*/,53/*vs/workbench/browser/quickopen*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,3/*vs/platform/instantiation/common/instantiation*/,13/*vs/workbench/common/editor*/,132/*vs/base/parts/quickopen/common/quickOpenScorer*/,407/*vs/css!vs/workbench/browser/parts/editor/media/editorpicker*/]), function (require, exports, winjs_base_1, nls, quickOpenModel_1, modeService_1, labels_1, modelService_1, quickopen_1, editorService_1, editorGroupsService_1, instantiation_1, editor_1, quickOpenScorer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditorPickerEntry = /** @class */ (function (_super) {
        __extends(EditorPickerEntry, _super);
        function EditorPickerEntry(editor, _group, modeService, modelService) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this._group = _group;
            _this.modeService = modeService;
            _this.modelService = modelService;
            return _this;
        }
        EditorPickerEntry.prototype.getLabelOptions = function () {
            return {
                extraClasses: labels_1.getIconClasses(this.modelService, this.modeService, this.getResource()),
                italic: !this._group.isPinned(this.editor)
            };
        };
        EditorPickerEntry.prototype.getLabel = function () {
            return this.editor.getName();
        };
        EditorPickerEntry.prototype.getIcon = function () {
            return this.editor.isDirty() ? 'dirty' : '';
        };
        Object.defineProperty(EditorPickerEntry.prototype, "group", {
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        EditorPickerEntry.prototype.getResource = function () {
            return editor_1.toResource(this.editor, { supportSideBySide: true });
        };
        EditorPickerEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, editor group picker", this.getLabel());
        };
        EditorPickerEntry.prototype.getDescription = function () {
            return this.editor.getDescription();
        };
        EditorPickerEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                return this.runOpen(context);
            }
            return _super.prototype.run.call(this, mode, context);
        };
        EditorPickerEntry.prototype.runOpen = function (context) {
            this._group.openEditor(this.editor);
            return true;
        };
        EditorPickerEntry = __decorate([
            __param(2, modeService_1.IModeService),
            __param(3, modelService_1.IModelService)
        ], EditorPickerEntry);
        return EditorPickerEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.EditorPickerEntry = EditorPickerEntry;
    var BaseEditorPicker = /** @class */ (function (_super) {
        __extends(BaseEditorPicker, _super);
        function BaseEditorPicker(instantiationService, editorService, editorGroupService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.scorerCache = Object.create(null);
            return _this;
        }
        BaseEditorPicker.prototype.getResults = function (searchValue, token) {
            var _this = this;
            var editorEntries = this.getEditorEntries();
            if (!editorEntries.length) {
                return winjs_base_1.TPromise.as(null);
            }
            // Prepare search for scoring
            var query = quickOpenScorer_1.prepareQuery(searchValue);
            var entries = editorEntries.filter(function (e) {
                if (!query.value) {
                    return true;
                }
                var itemScore = quickOpenScorer_1.scoreItem(e, query, true, quickOpenModel_1.QuickOpenItemAccessor, _this.scorerCache);
                if (!itemScore.score) {
                    return false;
                }
                e.setHighlights(itemScore.labelMatch, itemScore.descriptionMatch);
                return true;
            });
            // Sorting
            if (query.value) {
                var groups_1 = this.editorGroupService.getGroups(2 /* GRID_APPEARANCE */);
                entries.sort(function (e1, e2) {
                    if (e1.group !== e2.group) {
                        return groups_1.indexOf(e1.group) - groups_1.indexOf(e2.group); // older groups first
                    }
                    return quickOpenScorer_1.compareItemsByScore(e1, e2, query, true, quickOpenModel_1.QuickOpenItemAccessor, _this.scorerCache);
                });
            }
            // Grouping (for more than one group)
            if (this.editorGroupService.count > 1) {
                var lastGroup_1;
                entries.forEach(function (e) {
                    if (!lastGroup_1 || lastGroup_1 !== e.group) {
                        e.setGroupLabel(e.group.label);
                        e.setShowBorder(!!lastGroup_1);
                        lastGroup_1 = e.group;
                    }
                });
            }
            return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel(entries));
        };
        BaseEditorPicker.prototype.onClose = function (canceled) {
            this.scorerCache = Object.create(null);
        };
        BaseEditorPicker = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, editorService_1.IEditorService),
            __param(2, editorGroupsService_1.IEditorGroupsService)
        ], BaseEditorPicker);
        return BaseEditorPicker;
    }(quickopen_1.QuickOpenHandler));
    exports.BaseEditorPicker = BaseEditorPicker;
    var ActiveEditorGroupPicker = /** @class */ (function (_super) {
        __extends(ActiveEditorGroupPicker, _super);
        function ActiveEditorGroupPicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActiveEditorGroupPicker.prototype.getEditorEntries = function () {
            var _this = this;
            return this.group.getEditors(0 /* MOST_RECENTLY_ACTIVE */).map(function (editor, index) { return _this.instantiationService.createInstance(EditorPickerEntry, editor, _this.group); });
        };
        Object.defineProperty(ActiveEditorGroupPicker.prototype, "group", {
            get: function () {
                return this.editorGroupService.activeGroup;
            },
            enumerable: true,
            configurable: true
        });
        ActiveEditorGroupPicker.prototype.getEmptyLabel = function (searchString) {
            if (searchString) {
                return nls.localize('noResultsFoundInGroup', "No matching opened editor found in group");
            }
            return nls.localize('noOpenedEditors', "List of opened editors is currently empty in group");
        };
        ActiveEditorGroupPicker.prototype.getAutoFocus = function (searchValue, context) {
            if (searchValue || !context.quickNavigateConfiguration) {
                return {
                    autoFocusFirstEntry: true
                };
            }
            var isShiftNavigate = (context.quickNavigateConfiguration && context.quickNavigateConfiguration.keybindings.some(function (k) {
                var _a = k.getParts(), firstPart = _a[0], chordPart = _a[1];
                if (chordPart) {
                    return false;
                }
                return firstPart.shiftKey;
            }));
            if (isShiftNavigate) {
                return {
                    autoFocusLastEntry: true
                };
            }
            var editors = this.group.count;
            return {
                autoFocusFirstEntry: editors === 1,
                autoFocusSecondEntry: editors > 1
            };
        };
        ActiveEditorGroupPicker.ID = 'workbench.picker.activeEditors';
        return ActiveEditorGroupPicker;
    }(BaseEditorPicker));
    exports.ActiveEditorGroupPicker = ActiveEditorGroupPicker;
    var AllEditorsPicker = /** @class */ (function (_super) {
        __extends(AllEditorsPicker, _super);
        function AllEditorsPicker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AllEditorsPicker.prototype.getEditorEntries = function () {
            var _this = this;
            var entries = [];
            this.editorGroupService.getGroups(2 /* GRID_APPEARANCE */).forEach(function (group) {
                group.editors.forEach(function (editor) {
                    entries.push(_this.instantiationService.createInstance(EditorPickerEntry, editor, group));
                });
            });
            return entries;
        };
        AllEditorsPicker.prototype.getEmptyLabel = function (searchString) {
            if (searchString) {
                return nls.localize('noResultsFound', "No matching opened editor found");
            }
            return nls.localize('noOpenedEditorsAllGroups', "List of opened editors is currently empty");
        };
        AllEditorsPicker.prototype.getAutoFocus = function (searchValue, context) {
            if (searchValue) {
                return {
                    autoFocusFirstEntry: true
                };
            }
            return _super.prototype.getAutoFocus.call(this, searchValue, context);
        };
        AllEditorsPicker.ID = 'workbench.picker.editors';
        return AllEditorsPicker;
    }(BaseEditorPicker));
    exports.AllEditorsPicker = AllEditorsPicker;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[414/*vs/workbench/browser/parts/editor/editorStatus*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,8/*vs/base/browser/dom*/,22/*vs/base/common/strings*/,24/*vs/base/common/paths*/,29/*vs/base/common/types*/,12/*vs/base/common/uri*/,15/*vs/base/common/actions*/,18/*vs/base/common/platform*/,111/*vs/base/browser/browser*/,128/*vs/workbench/common/editor/untitledEditorInput*/,13/*vs/workbench/common/editor*/,4/*vs/base/common/lifecycle*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,72/*vs/editor/common/model*/,433/*vs/editor/contrib/linesOperations/linesOperations*/,239/*vs/editor/contrib/indentation/indentation*/,157/*vs/workbench/browser/parts/editor/binaryEditor*/,174/*vs/workbench/browser/parts/editor/binaryDiffEditor*/,11/*vs/workbench/services/editor/common/editorService*/,46/*vs/platform/quickOpen/common/quickOpen*/,153/*vs/workbench/services/configuration/common/configuration*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/,48/*vs/editor/common/core/range*/,100/*vs/editor/common/core/selection*/,462/*vs/editor/common/config/commonEditorConfig*/,37/*vs/platform/commands/common/commands*/,122/*vs/platform/extensionManagement/common/extensionManagement*/,27/*vs/workbench/services/textfile/common/textfiles*/,88/*vs/editor/common/services/resourceConfiguration*/,38/*vs/base/common/objects*/,45/*vs/editor/browser/editorBrowser*/,26/*vs/base/common/network*/,61/*vs/workbench/services/preferences/common/preferences*/,62/*vs/platform/quickinput/common/quickInput*/,60/*vs/workbench/browser/labels*/,17/*vs/base/common/async*/,28/*vs/platform/notification/common/notification*/,6/*vs/base/common/event*/,418/*vs/css!vs/workbench/browser/parts/editor/media/editorstatus*/]), function (require, exports, nls, winjs_base_1, dom_1, strings, paths, types, uri_1, actions_1, platform_1, browser, untitledEditorInput_1, editor_1, lifecycle_1, untitledEditorService_1, model_1, linesOperations_1, indentation_1, binaryEditor_1, binaryDiffEditor_1, editorService_1, quickOpen_1, configuration_1, files_1, instantiation_1, modeService_1, modelService_1, range_1, selection_1, commonEditorConfig_1, commands_1, extensionManagement_1, textfiles_1, resourceConfiguration_1, objects_1, editorBrowser_1, network_1, preferences_1, quickInput_1, labels_1, async_1, notification_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SideBySideEditorEncodingSupport = /** @class */ (function () {
        function SideBySideEditorEncodingSupport(master, details) {
            this.master = master;
            this.details = details;
        }
        SideBySideEditorEncodingSupport.prototype.getEncoding = function () {
            return this.master.getEncoding(); // always report from modified (right hand) side
        };
        SideBySideEditorEncodingSupport.prototype.setEncoding = function (encoding, mode) {
            [this.master, this.details].forEach(function (s) { return s.setEncoding(encoding, mode); });
        };
        return SideBySideEditorEncodingSupport;
    }());
    function toEditorWithEncodingSupport(input) {
        // Untitled Editor
        if (input instanceof untitledEditorInput_1.UntitledEditorInput) {
            return input;
        }
        // Side by Side (diff) Editor
        if (input instanceof editor_1.SideBySideEditorInput) {
            var masterEncodingSupport = toEditorWithEncodingSupport(input.master);
            var detailsEncodingSupport = toEditorWithEncodingSupport(input.details);
            if (masterEncodingSupport && detailsEncodingSupport) {
                return new SideBySideEditorEncodingSupport(masterEncodingSupport, detailsEncodingSupport);
            }
            return masterEncodingSupport;
        }
        // File or Resource Editor
        var encodingSupport = input;
        if (types.areFunctions(encodingSupport.setEncoding, encodingSupport.getEncoding)) {
            return encodingSupport;
        }
        // Unsupported for any other editor
        return null;
    }
    var StateChange = /** @class */ (function () {
        function StateChange() {
            this.indentation = false;
            this.selectionStatus = false;
            this.mode = false;
            this.encoding = false;
            this.EOL = false;
            this.tabFocusMode = false;
            this.screenReaderMode = false;
            this.metadata = false;
        }
        StateChange.prototype.combine = function (other) {
            this.indentation = this.indentation || other.indentation;
            this.selectionStatus = this.selectionStatus || other.selectionStatus;
            this.mode = this.mode || other.mode;
            this.encoding = this.encoding || other.encoding;
            this.EOL = this.EOL || other.EOL;
            this.tabFocusMode = this.tabFocusMode || other.tabFocusMode;
            this.screenReaderMode = this.screenReaderMode || other.screenReaderMode;
            this.metadata = this.metadata || other.metadata;
        };
        return StateChange;
    }());
    var State = /** @class */ (function () {
        function State() {
            this._selectionStatus = null;
            this._mode = null;
            this._encoding = null;
            this._EOL = null;
            this._tabFocusMode = false;
            this._screenReaderMode = false;
            this._metadata = null;
        }
        Object.defineProperty(State.prototype, "selectionStatus", {
            get: function () { return this._selectionStatus; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "mode", {
            get: function () { return this._mode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "encoding", {
            get: function () { return this._encoding; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "EOL", {
            get: function () { return this._EOL; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "indentation", {
            get: function () { return this._indentation; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "tabFocusMode", {
            get: function () { return this._tabFocusMode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "screenReaderMode", {
            get: function () { return this._screenReaderMode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(State.prototype, "metadata", {
            get: function () { return this._metadata; },
            enumerable: true,
            configurable: true
        });
        State.prototype.update = function (update) {
            var e = new StateChange();
            var somethingChanged = false;
            if (typeof update.selectionStatus !== 'undefined') {
                if (this._selectionStatus !== update.selectionStatus) {
                    this._selectionStatus = update.selectionStatus;
                    somethingChanged = true;
                    e.selectionStatus = true;
                }
            }
            if (typeof update.indentation !== 'undefined') {
                if (this._indentation !== update.indentation) {
                    this._indentation = update.indentation;
                    somethingChanged = true;
                    e.indentation = true;
                }
            }
            if (typeof update.mode !== 'undefined') {
                if (this._mode !== update.mode) {
                    this._mode = update.mode;
                    somethingChanged = true;
                    e.mode = true;
                }
            }
            if (typeof update.encoding !== 'undefined') {
                if (this._encoding !== update.encoding) {
                    this._encoding = update.encoding;
                    somethingChanged = true;
                    e.encoding = true;
                }
            }
            if (typeof update.EOL !== 'undefined') {
                if (this._EOL !== update.EOL) {
                    this._EOL = update.EOL;
                    somethingChanged = true;
                    e.EOL = true;
                }
            }
            if (typeof update.tabFocusMode !== 'undefined') {
                if (this._tabFocusMode !== update.tabFocusMode) {
                    this._tabFocusMode = update.tabFocusMode;
                    somethingChanged = true;
                    e.tabFocusMode = true;
                }
            }
            if (typeof update.screenReaderMode !== 'undefined') {
                if (this._screenReaderMode !== update.screenReaderMode) {
                    this._screenReaderMode = update.screenReaderMode;
                    somethingChanged = true;
                    e.screenReaderMode = true;
                }
            }
            if (typeof update.metadata !== 'undefined') {
                if (this._metadata !== update.metadata) {
                    this._metadata = update.metadata;
                    somethingChanged = true;
                    e.metadata = true;
                }
            }
            if (somethingChanged) {
                return e;
            }
            return null;
        };
        return State;
    }());
    var nlsSingleSelectionRange = nls.localize('singleSelectionRange', "Ln {0}, Col {1} ({2} selected)");
    var nlsSingleSelection = nls.localize('singleSelection', "Ln {0}, Col {1}");
    var nlsMultiSelectionRange = nls.localize('multiSelectionRange', "{0} selections ({1} characters selected)");
    var nlsMultiSelection = nls.localize('multiSelection', "{0} selections");
    var nlsEOLLF = nls.localize('endOfLineLineFeed', "LF");
    var nlsEOLCRLF = nls.localize('endOfLineCarriageReturnLineFeed', "CRLF");
    var nlsTabFocusMode = nls.localize('tabFocusModeEnabled', "Tab Moves Focus");
    var nlsScreenReaderDetected = nls.localize('screenReaderDetected', "Screen Reader Optimized");
    var nlsScreenReaderDetectedTitle = nls.localize('screenReaderDetectedExtra', "If you are not using a Screen Reader, please change the setting `editor.accessibilitySupport` to \"off\".");
    function setDisplay(el, desiredValue) {
        if (el.style.display !== desiredValue) {
            el.style.display = desiredValue;
        }
    }
    function show(el) {
        setDisplay(el, '');
    }
    function hide(el) {
        setDisplay(el, 'none');
    }
    var EditorStatus = /** @class */ (function () {
        function EditorStatus(editorService, quickOpenService, instantiationService, untitledEditorService, modeService, textFileService, configurationService, notificationService) {
            this.editorService = editorService;
            this.quickOpenService = quickOpenService;
            this.instantiationService = instantiationService;
            this.untitledEditorService = untitledEditorService;
            this.modeService = modeService;
            this.textFileService = textFileService;
            this.configurationService = configurationService;
            this.notificationService = notificationService;
            this._promptedScreenReader = false;
            this.toDispose = [];
            this.activeEditorListeners = [];
            this.state = new State();
        }
        EditorStatus.prototype.render = function (container) {
            var _this = this;
            this.element = dom_1.append(container, dom_1.$('.editor-statusbar-item'));
            this.tabFocusModeElement = dom_1.append(this.element, dom_1.$('a.editor-status-tabfocusmode.status-bar-info'));
            this.tabFocusModeElement.title = nls.localize('disableTabMode', "Disable Accessibility Mode");
            this.tabFocusModeElement.onclick = function () { return _this.onTabFocusModeClick(); };
            this.tabFocusModeElement.textContent = nlsTabFocusMode;
            hide(this.tabFocusModeElement);
            this.screenRedearModeElement = dom_1.append(this.element, dom_1.$('a.editor-status-screenreadermode.status-bar-info'));
            this.screenRedearModeElement.textContent = nlsScreenReaderDetected;
            this.screenRedearModeElement.title = nlsScreenReaderDetectedTitle;
            this.screenRedearModeElement.onclick = function () { return _this.onScreenReaderModeClick(); };
            hide(this.screenRedearModeElement);
            this.selectionElement = dom_1.append(this.element, dom_1.$('a.editor-status-selection'));
            this.selectionElement.title = nls.localize('gotoLine', "Go to Line");
            this.selectionElement.onclick = function () { return _this.onSelectionClick(); };
            hide(this.selectionElement);
            this.indentationElement = dom_1.append(this.element, dom_1.$('a.editor-status-indentation'));
            this.indentationElement.title = nls.localize('selectIndentation', "Select Indentation");
            this.indentationElement.onclick = function () { return _this.onIndentationClick(); };
            hide(this.indentationElement);
            this.encodingElement = dom_1.append(this.element, dom_1.$('a.editor-status-encoding'));
            this.encodingElement.title = nls.localize('selectEncoding', "Select Encoding");
            this.encodingElement.onclick = function () { return _this.onEncodingClick(); };
            hide(this.encodingElement);
            this.eolElement = dom_1.append(this.element, dom_1.$('a.editor-status-eol'));
            this.eolElement.title = nls.localize('selectEOL', "Select End of Line Sequence");
            this.eolElement.onclick = function () { return _this.onEOLClick(); };
            hide(this.eolElement);
            this.modeElement = dom_1.append(this.element, dom_1.$('a.editor-status-mode'));
            this.modeElement.title = nls.localize('selectLanguageMode', "Select Language Mode");
            this.modeElement.onclick = function () { return _this.onModeClick(); };
            hide(this.modeElement);
            this.metadataElement = dom_1.append(this.element, dom_1.$('span.editor-status-metadata'));
            this.metadataElement.title = nls.localize('fileInfo', "File Information");
            hide(this.metadataElement);
            this.delayedRender = null;
            this.toRender = null;
            this.toDispose.push({
                dispose: function () {
                    if (_this.delayedRender) {
                        _this.delayedRender.dispose();
                        _this.delayedRender = null;
                    }
                }
            }, this.editorService.onDidActiveEditorChange(function () { return _this.updateStatusBar(); }), this.untitledEditorService.onDidChangeEncoding(function (r) { return _this.onResourceEncodingChange(r); }), this.textFileService.models.onModelEncodingChanged(function (e) { return _this.onResourceEncodingChange(e.resource); }), commonEditorConfig_1.TabFocus.onDidChangeTabFocus(function (e) { return _this.onTabFocusModeChange(); }));
            return lifecycle_1.combinedDisposable(this.toDispose);
        };
        EditorStatus.prototype.updateState = function (update) {
            var _this = this;
            var changed = this.state.update(update);
            if (!changed) {
                // Nothing really changed
                return;
            }
            if (!this.toRender) {
                this.toRender = changed;
                this.delayedRender = dom_1.runAtThisOrScheduleAtNextAnimationFrame(function () {
                    _this.delayedRender = null;
                    var toRender = _this.toRender;
                    _this.toRender = null;
                    _this._renderNow(toRender);
                });
            }
            else {
                this.toRender.combine(changed);
            }
        };
        EditorStatus.prototype._renderNow = function (changed) {
            if (changed.tabFocusMode) {
                if (this.state.tabFocusMode && this.state.tabFocusMode === true) {
                    show(this.tabFocusModeElement);
                }
                else {
                    hide(this.tabFocusModeElement);
                }
            }
            if (changed.screenReaderMode) {
                if (this.state.screenReaderMode && this.state.screenReaderMode === true) {
                    show(this.screenRedearModeElement);
                }
                else {
                    hide(this.screenRedearModeElement);
                }
            }
            if (changed.indentation) {
                if (this.state.indentation) {
                    this.indentationElement.textContent = this.state.indentation;
                    show(this.indentationElement);
                }
                else {
                    hide(this.indentationElement);
                }
            }
            if (changed.selectionStatus) {
                if (this.state.selectionStatus && !this.state.screenReaderMode) {
                    this.selectionElement.textContent = this.state.selectionStatus;
                    show(this.selectionElement);
                }
                else {
                    hide(this.selectionElement);
                }
            }
            if (changed.encoding) {
                if (this.state.encoding) {
                    this.encodingElement.textContent = this.state.encoding;
                    show(this.encodingElement);
                }
                else {
                    hide(this.encodingElement);
                }
            }
            if (changed.EOL) {
                if (this.state.EOL) {
                    this.eolElement.textContent = this.state.EOL === '\r\n' ? nlsEOLCRLF : nlsEOLLF;
                    show(this.eolElement);
                }
                else {
                    hide(this.eolElement);
                }
            }
            if (changed.mode) {
                if (this.state.mode) {
                    this.modeElement.textContent = this.state.mode;
                    show(this.modeElement);
                }
                else {
                    hide(this.modeElement);
                }
            }
            if (changed.metadata) {
                if (this.state.metadata) {
                    this.metadataElement.textContent = this.state.metadata;
                    show(this.metadataElement);
                }
                else {
                    hide(this.metadataElement);
                }
            }
        };
        EditorStatus.prototype.getSelectionLabel = function (info) {
            if (!info || !info.selections) {
                return null;
            }
            if (info.selections.length === 1) {
                if (info.charactersSelected) {
                    return strings.format(nlsSingleSelectionRange, info.selections[0].positionLineNumber, info.selections[0].positionColumn, info.charactersSelected);
                }
                return strings.format(nlsSingleSelection, info.selections[0].positionLineNumber, info.selections[0].positionColumn);
            }
            if (info.charactersSelected) {
                return strings.format(nlsMultiSelectionRange, info.selections.length, info.charactersSelected);
            }
            if (info.selections.length > 0) {
                return strings.format(nlsMultiSelection, info.selections.length);
            }
            return null;
        };
        EditorStatus.prototype.onModeClick = function () {
            var action = this.instantiationService.createInstance(ChangeModeAction, ChangeModeAction.ID, ChangeModeAction.LABEL);
            action.run();
            action.dispose();
        };
        EditorStatus.prototype.onIndentationClick = function () {
            var action = this.instantiationService.createInstance(ChangeIndentationAction, ChangeIndentationAction.ID, ChangeIndentationAction.LABEL);
            action.run();
            action.dispose();
        };
        EditorStatus.prototype.onScreenReaderModeClick = function () {
            var _this = this;
            if (!this.screenReaderNotification) {
                this.screenReaderNotification = this.notificationService.prompt(notification_1.Severity.Info, nls.localize('screenReaderDetectedExplanation.question', "Are you using a screen reader to operate VS Code?"), [{
                        label: nls.localize('screenReaderDetectedExplanation.answerYes', "Yes"),
                        run: function () {
                            _this.configurationService.updateValue('editor.accessibilitySupport', 'on', 1 /* USER */);
                        }
                    }, {
                        label: nls.localize('screenReaderDetectedExplanation.answerNo', "No"),
                        run: function () {
                            _this.configurationService.updateValue('editor.accessibilitySupport', 'off', 1 /* USER */);
                        }
                    }]);
                event_1.once(this.screenReaderNotification.onDidClose)(function () {
                    _this.screenReaderNotification = null;
                });
            }
        };
        EditorStatus.prototype.onSelectionClick = function () {
            this.quickOpenService.show(':'); // "Go to line"
        };
        EditorStatus.prototype.onEOLClick = function () {
            var action = this.instantiationService.createInstance(ChangeEOLAction, ChangeEOLAction.ID, ChangeEOLAction.LABEL);
            action.run();
            action.dispose();
        };
        EditorStatus.prototype.onEncodingClick = function () {
            var action = this.instantiationService.createInstance(ChangeEncodingAction, ChangeEncodingAction.ID, ChangeEncodingAction.LABEL);
            action.run();
            action.dispose();
        };
        EditorStatus.prototype.onTabFocusModeClick = function () {
            commonEditorConfig_1.TabFocus.setTabFocusMode(false);
        };
        EditorStatus.prototype.updateStatusBar = function () {
            var _this = this;
            var activeControl = this.editorService.activeControl;
            var activeCodeEditor = activeControl ? editorBrowser_1.getCodeEditor(activeControl.getControl()) : void 0;
            // Update all states
            this.onScreenReaderModeChange(activeCodeEditor);
            this.onSelectionChange(activeCodeEditor);
            this.onModeChange(activeCodeEditor);
            this.onEOLChange(activeCodeEditor);
            this.onEncodingChange(activeControl);
            this.onIndentationChange(activeCodeEditor);
            this.onMetadataChange(activeControl);
            // Dispose old active editor listeners
            lifecycle_1.dispose(this.activeEditorListeners);
            // Attach new listeners to active editor
            if (activeCodeEditor) {
                // Hook Listener for Configuration changes
                this.activeEditorListeners.push(activeCodeEditor.onDidChangeConfiguration(function (event) {
                    if (event.accessibilitySupport) {
                        _this.onScreenReaderModeChange(activeCodeEditor);
                    }
                }));
                // Hook Listener for Selection changes
                this.activeEditorListeners.push(activeCodeEditor.onDidChangeCursorPosition(function (event) {
                    _this.onSelectionChange(activeCodeEditor);
                }));
                // Hook Listener for mode changes
                this.activeEditorListeners.push(activeCodeEditor.onDidChangeModelLanguage(function (event) {
                    _this.onModeChange(activeCodeEditor);
                }));
                // Hook Listener for content changes
                this.activeEditorListeners.push(activeCodeEditor.onDidChangeModelContent(function (e) {
                    _this.onEOLChange(activeCodeEditor);
                    var selections = activeCodeEditor.getSelections();
                    var _loop_1 = function (i) {
                        if (selections.some(function (selection) { return range_1.Range.areIntersecting(selection, e.changes[i].range); })) {
                            _this.onSelectionChange(activeCodeEditor);
                            return "break";
                        }
                    };
                    for (var i = 0; i < e.changes.length; i++) {
                        var state_1 = _loop_1(i);
                        if (state_1 === "break")
                            break;
                    }
                }));
                // Hook Listener for content options changes
                this.activeEditorListeners.push(activeCodeEditor.onDidChangeModelOptions(function (event) {
                    _this.onIndentationChange(activeCodeEditor);
                }));
            }
            // Handle binary editors
            else if (activeControl instanceof binaryEditor_1.BaseBinaryResourceEditor || activeControl instanceof binaryDiffEditor_1.BinaryResourceDiffEditor) {
                var binaryEditors = [];
                if (activeControl instanceof binaryDiffEditor_1.BinaryResourceDiffEditor) {
                    var details = activeControl.getDetailsEditor();
                    if (details instanceof binaryEditor_1.BaseBinaryResourceEditor) {
                        binaryEditors.push(details);
                    }
                    var master = activeControl.getMasterEditor();
                    if (master instanceof binaryEditor_1.BaseBinaryResourceEditor) {
                        binaryEditors.push(master);
                    }
                }
                else {
                    binaryEditors.push(activeControl);
                }
                binaryEditors.forEach(function (editor) {
                    _this.activeEditorListeners.push(editor.onMetadataChanged(function (metadata) {
                        _this.onMetadataChange(activeControl);
                    }));
                });
            }
        };
        EditorStatus.prototype.onModeChange = function (editorWidget) {
            var info = { mode: null };
            // We only support text based editors
            if (editorWidget) {
                var textModel = editorWidget.getModel();
                if (textModel) {
                    // Compute mode
                    var modeId = textModel.getLanguageIdentifier().language;
                    info = { mode: this.modeService.getLanguageName(modeId) };
                }
            }
            this.updateState(info);
        };
        EditorStatus.prototype.onIndentationChange = function (editorWidget) {
            var update = { indentation: null };
            if (editorWidget) {
                var model = editorWidget.getModel();
                if (model) {
                    var modelOpts = model.getOptions();
                    update.indentation = (modelOpts.insertSpaces
                        ? nls.localize('spacesSize', "Spaces: {0}", modelOpts.tabSize)
                        : nls.localize({ key: 'tabSize', comment: ['Tab corresponds to the tab key'] }, "Tab Size: {0}", modelOpts.tabSize));
                }
            }
            this.updateState(update);
        };
        EditorStatus.prototype.onMetadataChange = function (editor) {
            var update = { metadata: null };
            if (editor instanceof binaryEditor_1.BaseBinaryResourceEditor || editor instanceof binaryDiffEditor_1.BinaryResourceDiffEditor) {
                update.metadata = editor.getMetadata();
            }
            this.updateState(update);
        };
        EditorStatus.prototype.onScreenReaderModeChange = function (editorWidget) {
            var _this = this;
            var screenReaderMode = false;
            // We only support text based editors
            if (editorWidget) {
                var screenReaderDetected = (browser.getAccessibilitySupport() === 2 /* Enabled */);
                if (screenReaderDetected) {
                    var screenReaderConfiguration = this.configurationService.getValue('editor').accessibilitySupport;
                    if (screenReaderConfiguration === 'auto') {
                        // show explanation
                        if (!this._promptedScreenReader) {
                            this._promptedScreenReader = true;
                            setTimeout(function () {
                                _this.onScreenReaderModeClick();
                            }, 100);
                        }
                    }
                }
                screenReaderMode = (editorWidget.getConfiguration().accessibilitySupport === 2 /* Enabled */);
            }
            if (screenReaderMode === false && this.screenReaderNotification) {
                this.screenReaderNotification.close();
            }
            this.updateState({ screenReaderMode: screenReaderMode });
        };
        EditorStatus.prototype.onSelectionChange = function (editorWidget) {
            var info = {};
            // We only support text based editors
            if (editorWidget) {
                // Compute selection(s)
                info.selections = editorWidget.getSelections() || [];
                // Compute selection length
                info.charactersSelected = 0;
                var textModel_1 = editorWidget.getModel();
                if (textModel_1) {
                    info.selections.forEach(function (selection) {
                        info.charactersSelected += textModel_1.getValueLengthInRange(selection);
                    });
                }
                // Compute the visible column for one selection. This will properly handle tabs and their configured widths
                if (info.selections.length === 1) {
                    var visibleColumn = editorWidget.getVisibleColumnFromPosition(editorWidget.getPosition());
                    var selectionClone = info.selections[0].clone(); // do not modify the original position we got from the editor
                    selectionClone = new selection_1.Selection(selectionClone.selectionStartLineNumber, selectionClone.selectionStartColumn, selectionClone.positionLineNumber, visibleColumn);
                    info.selections[0] = selectionClone;
                }
            }
            this.updateState({ selectionStatus: this.getSelectionLabel(info) });
        };
        EditorStatus.prototype.onEOLChange = function (editorWidget) {
            var info = { EOL: null };
            if (editorWidget && !editorWidget.getConfiguration().readOnly) {
                var codeEditorModel = editorWidget.getModel();
                if (codeEditorModel) {
                    info.EOL = codeEditorModel.getEOL();
                }
            }
            this.updateState(info);
        };
        EditorStatus.prototype.onEncodingChange = function (e) {
            if (e && !this.isActiveEditor(e)) {
                return;
            }
            var info = { encoding: null };
            // We only support text based editors
            if (e && (editorBrowser_1.isCodeEditor(e.getControl()) || editorBrowser_1.isDiffEditor(e.getControl()))) {
                var encodingSupport = toEditorWithEncodingSupport(e.input);
                if (encodingSupport) {
                    var rawEncoding = encodingSupport.getEncoding();
                    var encodingInfo = files_1.SUPPORTED_ENCODINGS[rawEncoding];
                    if (encodingInfo) {
                        info.encoding = encodingInfo.labelShort; // if we have a label, take it from there
                    }
                    else {
                        info.encoding = rawEncoding; // otherwise use it raw
                    }
                }
            }
            this.updateState(info);
        };
        EditorStatus.prototype.onResourceEncodingChange = function (resource) {
            var activeControl = this.editorService.activeControl;
            if (activeControl) {
                var activeResource = editor_1.toResource(activeControl.input, { supportSideBySide: true });
                if (activeResource && activeResource.toString() === resource.toString()) {
                    return this.onEncodingChange(activeControl); // only update if the encoding changed for the active resource
                }
            }
        };
        EditorStatus.prototype.onTabFocusModeChange = function () {
            var info = { tabFocusMode: commonEditorConfig_1.TabFocus.getTabFocusMode() };
            this.updateState(info);
        };
        EditorStatus.prototype.isActiveEditor = function (control) {
            var activeControl = this.editorService.activeControl;
            return activeControl && activeControl === control;
        };
        EditorStatus = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, quickOpen_1.IQuickOpenService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, untitledEditorService_1.IUntitledEditorService),
            __param(4, modeService_1.IModeService),
            __param(5, textfiles_1.ITextFileService),
            __param(6, configuration_1.IWorkspaceConfigurationService),
            __param(7, notification_1.INotificationService)
        ], EditorStatus);
        return EditorStatus;
    }());
    exports.EditorStatus = EditorStatus;
    function isWritableCodeEditor(codeEditor) {
        if (!codeEditor) {
            return false;
        }
        var config = codeEditor.getConfiguration();
        return (!config.readOnly);
    }
    function isWritableBaseEditor(e) {
        return e && isWritableCodeEditor(editorBrowser_1.getCodeEditor(e.getControl()));
    }
    var ShowLanguageExtensionsAction = /** @class */ (function (_super) {
        __extends(ShowLanguageExtensionsAction, _super);
        function ShowLanguageExtensionsAction(fileExtension, commandService, galleryService) {
            var _this = _super.call(this, ShowLanguageExtensionsAction.ID, nls.localize('showLanguageExtensions', "Search Marketplace Extensions for '{0}'...", fileExtension)) || this;
            _this.fileExtension = fileExtension;
            _this.commandService = commandService;
            _this.enabled = galleryService.isEnabled();
            return _this;
        }
        ShowLanguageExtensionsAction.prototype.run = function () {
            return this.commandService.executeCommand('workbench.extensions.action.showExtensionsForLanguage', this.fileExtension).then(function () { return void 0; });
        };
        ShowLanguageExtensionsAction.ID = 'workbench.action.showLanguageExtensions';
        ShowLanguageExtensionsAction = __decorate([
            __param(1, commands_1.ICommandService),
            __param(2, extensionManagement_1.IExtensionGalleryService)
        ], ShowLanguageExtensionsAction);
        return ShowLanguageExtensionsAction;
    }(actions_1.Action));
    exports.ShowLanguageExtensionsAction = ShowLanguageExtensionsAction;
    var ChangeModeAction = /** @class */ (function (_super) {
        __extends(ChangeModeAction, _super);
        function ChangeModeAction(actionId, actionLabel, modeService, modelService, editorService, configurationService, quickInputService, preferencesService, instantiationService, untitledEditorService) {
            var _this = _super.call(this, actionId, actionLabel) || this;
            _this.modeService = modeService;
            _this.modelService = modelService;
            _this.editorService = editorService;
            _this.configurationService = configurationService;
            _this.quickInputService = quickInputService;
            _this.preferencesService = preferencesService;
            _this.instantiationService = instantiationService;
            _this.untitledEditorService = untitledEditorService;
            return _this;
        }
        ChangeModeAction.prototype.run = function () {
            var _this = this;
            var activeTextEditorWidget = editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget);
            if (!activeTextEditorWidget) {
                return this.quickInputService.pick([{ label: nls.localize('noEditor', "No text editor active at this time") }]);
            }
            var textModel = activeTextEditorWidget.getModel();
            var resource = editor_1.toResource(this.editorService.activeEditor, { supportSideBySide: true });
            var hasLanguageSupport = !!resource;
            if (resource.scheme === network_1.Schemas.untitled && !this.untitledEditorService.hasAssociatedFilePath(resource)) {
                hasLanguageSupport = false; // no configuration for untitled resources (e.g. "Untitled-1")
            }
            // Compute mode
            var currentModeId;
            var modeId;
            if (textModel) {
                modeId = textModel.getLanguageIdentifier().language;
                currentModeId = this.modeService.getLanguageName(modeId);
            }
            // All languages are valid picks
            var languages = this.modeService.getRegisteredLanguageNames();
            var picks = languages.sort().map(function (lang, index) {
                var description;
                if (currentModeId === lang) {
                    description = nls.localize('languageDescription', "({0}) - Configured Language", _this.modeService.getModeIdForLanguageName(lang.toLowerCase()));
                }
                else {
                    description = nls.localize('languageDescriptionConfigured', "({0})", _this.modeService.getModeIdForLanguageName(lang.toLowerCase()));
                }
                // construct a fake resource to be able to show nice icons if any
                var fakeResource;
                var extensions = _this.modeService.getExtensions(lang);
                if (extensions && extensions.length) {
                    fakeResource = uri_1.URI.file(extensions[0]);
                }
                else {
                    var filenames = _this.modeService.getFilenames(lang);
                    if (filenames && filenames.length) {
                        fakeResource = uri_1.URI.file(filenames[0]);
                    }
                }
                return {
                    label: lang,
                    iconClasses: labels_1.getIconClasses(_this.modelService, _this.modeService, fakeResource),
                    description: description
                };
            });
            if (hasLanguageSupport) {
                picks.unshift({ type: 'separator', label: nls.localize('languagesPicks', "languages (identifier)") });
            }
            // Offer action to configure via settings
            var configureModeAssociations;
            var configureModeSettings;
            var galleryAction;
            if (hasLanguageSupport) {
                var ext = paths.extname(resource.fsPath) || paths.basename(resource.fsPath);
                galleryAction = this.instantiationService.createInstance(ShowLanguageExtensionsAction, ext);
                if (galleryAction.enabled) {
                    picks.unshift(galleryAction);
                }
                configureModeSettings = { label: nls.localize('configureModeSettings', "Configure '{0}' language based settings...", currentModeId) };
                picks.unshift(configureModeSettings);
                configureModeAssociations = { label: nls.localize('configureAssociationsExt', "Configure File Association for '{0}'...", ext) };
                picks.unshift(configureModeAssociations);
            }
            // Offer to "Auto Detect"
            var autoDetectMode = {
                label: nls.localize('autoDetect', "Auto Detect")
            };
            if (hasLanguageSupport) {
                picks.unshift(autoDetectMode);
            }
            return this.quickInputService.pick(picks, { placeHolder: nls.localize('pickLanguage', "Select Language Mode"), matchOnDescription: true }).then(function (pick) {
                if (!pick) {
                    return;
                }
                if (pick === galleryAction) {
                    galleryAction.run();
                    return;
                }
                // User decided to permanently configure associations, return right after
                if (pick === configureModeAssociations) {
                    _this.configureFileAssociation(resource);
                    return;
                }
                // User decided to configure settings for current language
                if (pick === configureModeSettings) {
                    _this.preferencesService.configureSettingsForLanguage(modeId);
                    return;
                }
                // Change mode for active editor
                var activeEditor = _this.editorService.activeEditor;
                var activeTextEditorWidget = _this.editorService.activeTextEditorWidget;
                var models = [];
                if (editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {
                    var codeEditorModel = activeTextEditorWidget.getModel();
                    if (codeEditorModel) {
                        models.push(codeEditorModel);
                    }
                }
                else if (editorBrowser_1.isDiffEditor(activeTextEditorWidget)) {
                    var diffEditorModel = activeTextEditorWidget.getModel();
                    if (diffEditorModel) {
                        if (diffEditorModel.original) {
                            models.push(diffEditorModel.original);
                        }
                        if (diffEditorModel.modified) {
                            models.push(diffEditorModel.modified);
                        }
                    }
                }
                // Find mode
                var mode;
                if (pick === autoDetectMode) {
                    mode = _this.modeService.getOrCreateModeByFilepathOrFirstLine(editor_1.toResource(activeEditor, { supportSideBySide: true }).fsPath, textModel.getLineContent(1));
                }
                else {
                    mode = _this.modeService.getOrCreateModeByLanguageName(pick.label);
                }
                // Change mode
                models.forEach(function (textModel) {
                    _this.modelService.setMode(textModel, mode);
                });
            });
        };
        ChangeModeAction.prototype.configureFileAssociation = function (resource) {
            var _this = this;
            var extension = paths.extname(resource.fsPath);
            var basename = paths.basename(resource.fsPath);
            var currentAssociation = this.modeService.getModeIdByFilepathOrFirstLine(basename);
            var languages = this.modeService.getRegisteredLanguageNames();
            var picks = languages.sort().map(function (lang, index) {
                var id = _this.modeService.getModeIdForLanguageName(lang.toLowerCase());
                return {
                    id: id,
                    label: lang,
                    description: (id === currentAssociation) ? nls.localize('currentAssociation', "Current Association") : void 0
                };
            });
            setTimeout(function () {
                _this.quickInputService.pick(picks, { placeHolder: nls.localize('pickLanguageToConfigure', "Select Language Mode to Associate with '{0}'", extension || basename) }).then(function (language) {
                    if (language) {
                        var fileAssociationsConfig = _this.configurationService.inspect(files_1.FILES_ASSOCIATIONS_CONFIG);
                        var associationKey = void 0;
                        if (extension && basename[0] !== '.') {
                            associationKey = "*" + extension; // only use "*.ext" if the file path is in the form of <name>.<ext>
                        }
                        else {
                            associationKey = basename; // otherwise use the basename (e.g. .gitignore, Dockerfile)
                        }
                        // If the association is already being made in the workspace, make sure to target workspace settings
                        var target = 1 /* USER */;
                        if (fileAssociationsConfig.workspace && !!fileAssociationsConfig.workspace[associationKey]) {
                            target = 2 /* WORKSPACE */;
                        }
                        // Make sure to write into the value of the target and not the merged value from USER and WORKSPACE config
                        var currentAssociations = objects_1.deepClone((target === 2 /* WORKSPACE */) ? fileAssociationsConfig.workspace : fileAssociationsConfig.user);
                        if (!currentAssociations) {
                            currentAssociations = Object.create(null);
                        }
                        currentAssociations[associationKey] = language.id;
                        _this.configurationService.updateValue(files_1.FILES_ASSOCIATIONS_CONFIG, currentAssociations, target);
                    }
                });
            }, 50 /* quick open is sensitive to being opened so soon after another */);
        };
        ChangeModeAction.ID = 'workbench.action.editor.changeLanguageMode';
        ChangeModeAction.LABEL = nls.localize('changeMode', "Change Language Mode");
        ChangeModeAction = __decorate([
            __param(2, modeService_1.IModeService),
            __param(3, modelService_1.IModelService),
            __param(4, editorService_1.IEditorService),
            __param(5, configuration_1.IWorkspaceConfigurationService),
            __param(6, quickInput_1.IQuickInputService),
            __param(7, preferences_1.IPreferencesService),
            __param(8, instantiation_1.IInstantiationService),
            __param(9, untitledEditorService_1.IUntitledEditorService)
        ], ChangeModeAction);
        return ChangeModeAction;
    }(actions_1.Action));
    exports.ChangeModeAction = ChangeModeAction;
    var ChangeIndentationAction = /** @class */ (function (_super) {
        __extends(ChangeIndentationAction, _super);
        function ChangeIndentationAction(actionId, actionLabel, editorService, quickInputService) {
            var _this = _super.call(this, actionId, actionLabel) || this;
            _this.editorService = editorService;
            _this.quickInputService = quickInputService;
            return _this;
        }
        ChangeIndentationAction.prototype.run = function () {
            var activeTextEditorWidget = editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget);
            if (!activeTextEditorWidget) {
                return this.quickInputService.pick([{ label: nls.localize('noEditor', "No text editor active at this time") }]);
            }
            if (!isWritableCodeEditor(activeTextEditorWidget)) {
                return this.quickInputService.pick([{ label: nls.localize('noWritableCodeEditor', "The active code editor is read-only.") }]);
            }
            var picks = [
                activeTextEditorWidget.getAction(indentation_1.IndentUsingSpaces.ID),
                activeTextEditorWidget.getAction(indentation_1.IndentUsingTabs.ID),
                activeTextEditorWidget.getAction(indentation_1.DetectIndentation.ID),
                activeTextEditorWidget.getAction(indentation_1.IndentationToSpacesAction.ID),
                activeTextEditorWidget.getAction(indentation_1.IndentationToTabsAction.ID),
                activeTextEditorWidget.getAction(linesOperations_1.TrimTrailingWhitespaceAction.ID)
            ].map(function (a) {
                return {
                    id: a.id,
                    label: a.label,
                    detail: (platform_1.language === platform_1.LANGUAGE_DEFAULT) ? null : a.alias,
                    run: function () {
                        activeTextEditorWidget.focus();
                        a.run();
                    }
                };
            });
            picks.splice(3, 0, { type: 'separator', label: nls.localize('indentConvert', "convert file") });
            picks.unshift({ type: 'separator', label: nls.localize('indentView', "change view") });
            return this.quickInputService.pick(picks, { placeHolder: nls.localize('pickAction', "Select Action"), matchOnDetail: true }).then(function (action) { return action && action.run(); });
        };
        ChangeIndentationAction.ID = 'workbench.action.editor.changeIndentation';
        ChangeIndentationAction.LABEL = nls.localize('changeIndentation', "Change Indentation");
        ChangeIndentationAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, quickInput_1.IQuickInputService)
        ], ChangeIndentationAction);
        return ChangeIndentationAction;
    }(actions_1.Action));
    var ChangeEOLAction = /** @class */ (function (_super) {
        __extends(ChangeEOLAction, _super);
        function ChangeEOLAction(actionId, actionLabel, editorService, quickInputService) {
            var _this = _super.call(this, actionId, actionLabel) || this;
            _this.editorService = editorService;
            _this.quickInputService = quickInputService;
            return _this;
        }
        ChangeEOLAction.prototype.run = function () {
            var _this = this;
            var activeTextEditorWidget = editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget);
            if (!activeTextEditorWidget) {
                return this.quickInputService.pick([{ label: nls.localize('noEditor', "No text editor active at this time") }]);
            }
            if (!isWritableCodeEditor(activeTextEditorWidget)) {
                return this.quickInputService.pick([{ label: nls.localize('noWritableCodeEditor', "The active code editor is read-only.") }]);
            }
            var textModel = activeTextEditorWidget.getModel();
            var EOLOptions = [
                { label: nlsEOLLF, eol: model_1.EndOfLineSequence.LF },
                { label: nlsEOLCRLF, eol: model_1.EndOfLineSequence.CRLF },
            ];
            var selectedIndex = (textModel && textModel.getEOL() === '\n') ? 0 : 1;
            return this.quickInputService.pick(EOLOptions, { placeHolder: nls.localize('pickEndOfLine', "Select End of Line Sequence"), activeItem: EOLOptions[selectedIndex] }).then(function (eol) {
                if (eol) {
                    var activeCodeEditor = editorBrowser_1.getCodeEditor(_this.editorService.activeTextEditorWidget);
                    if (activeCodeEditor && isWritableCodeEditor(activeCodeEditor)) {
                        var textModel_2 = activeCodeEditor.getModel();
                        textModel_2.pushEOL(eol.eol);
                    }
                }
            });
        };
        ChangeEOLAction.ID = 'workbench.action.editor.changeEOL';
        ChangeEOLAction.LABEL = nls.localize('changeEndOfLine', "Change End of Line Sequence");
        ChangeEOLAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, quickInput_1.IQuickInputService)
        ], ChangeEOLAction);
        return ChangeEOLAction;
    }(actions_1.Action));
    exports.ChangeEOLAction = ChangeEOLAction;
    var ChangeEncodingAction = /** @class */ (function (_super) {
        __extends(ChangeEncodingAction, _super);
        function ChangeEncodingAction(actionId, actionLabel, editorService, quickInputService, textResourceConfigurationService, fileService) {
            var _this = _super.call(this, actionId, actionLabel) || this;
            _this.editorService = editorService;
            _this.quickInputService = quickInputService;
            _this.textResourceConfigurationService = textResourceConfigurationService;
            _this.fileService = fileService;
            return _this;
        }
        ChangeEncodingAction.prototype.run = function () {
            var _this = this;
            if (!editorBrowser_1.getCodeEditor(this.editorService.activeTextEditorWidget)) {
                return this.quickInputService.pick([{ label: nls.localize('noEditor', "No text editor active at this time") }]);
            }
            var activeControl = this.editorService.activeControl;
            var encodingSupport = toEditorWithEncodingSupport(activeControl.input);
            if (!encodingSupport) {
                return this.quickInputService.pick([{ label: nls.localize('noFileEditor', "No file active at this time") }]);
            }
            var pickActionPromise;
            var saveWithEncodingPick;
            var reopenWithEncodingPick;
            if (platform_1.language === platform_1.LANGUAGE_DEFAULT) {
                saveWithEncodingPick = { label: nls.localize('saveWithEncoding', "Save with Encoding") };
                reopenWithEncodingPick = { label: nls.localize('reopenWithEncoding', "Reopen with Encoding") };
            }
            else {
                saveWithEncodingPick = { label: nls.localize('saveWithEncoding', "Save with Encoding"), detail: 'Save with Encoding', };
                reopenWithEncodingPick = { label: nls.localize('reopenWithEncoding', "Reopen with Encoding"), detail: 'Reopen with Encoding' };
            }
            if (encodingSupport instanceof untitledEditorInput_1.UntitledEditorInput) {
                pickActionPromise = winjs_base_1.TPromise.as(saveWithEncodingPick);
            }
            else if (!isWritableBaseEditor(activeControl)) {
                pickActionPromise = winjs_base_1.TPromise.as(reopenWithEncodingPick);
            }
            else {
                pickActionPromise = this.quickInputService.pick([reopenWithEncodingPick, saveWithEncodingPick], { placeHolder: nls.localize('pickAction', "Select Action"), matchOnDetail: true });
            }
            return pickActionPromise.then(function (action) {
                if (!action) {
                    return void 0;
                }
                var resource = editor_1.toResource(activeControl.input, { supportSideBySide: true });
                return async_1.timeout(50 /* quick open is sensitive to being opened so soon after another */)
                    .then(function () {
                    if (!resource || !_this.fileService.canHandleResource(resource)) {
                        return winjs_base_1.TPromise.as(null); // encoding detection only possible for resources the file service can handle
                    }
                    return _this.fileService.resolveContent(resource, { autoGuessEncoding: true, acceptTextOnly: true }).then(function (content) { return content.encoding; }, function (err) { return null; });
                })
                    .then(function (guessedEncoding) {
                    var isReopenWithEncoding = (action === reopenWithEncodingPick);
                    var configuredEncoding = _this.textResourceConfigurationService.getValue(resource, 'files.encoding');
                    var directMatchIndex;
                    var aliasMatchIndex;
                    // All encodings are valid picks
                    var picks = Object.keys(files_1.SUPPORTED_ENCODINGS)
                        .sort(function (k1, k2) {
                        if (k1 === configuredEncoding) {
                            return -1;
                        }
                        else if (k2 === configuredEncoding) {
                            return 1;
                        }
                        return files_1.SUPPORTED_ENCODINGS[k1].order - files_1.SUPPORTED_ENCODINGS[k2].order;
                    })
                        .filter(function (k) {
                        if (k === guessedEncoding && guessedEncoding !== configuredEncoding) {
                            return false; // do not show encoding if it is the guessed encoding that does not match the configured
                        }
                        return !isReopenWithEncoding || !files_1.SUPPORTED_ENCODINGS[k].encodeOnly; // hide those that can only be used for encoding if we are about to decode
                    })
                        .map(function (key, index) {
                        if (key === encodingSupport.getEncoding()) {
                            directMatchIndex = index;
                        }
                        else if (files_1.SUPPORTED_ENCODINGS[key].alias === encodingSupport.getEncoding()) {
                            aliasMatchIndex = index;
                        }
                        return { id: key, label: files_1.SUPPORTED_ENCODINGS[key].labelLong, description: key };
                    });
                    // If we have a guessed encoding, show it first unless it matches the configured encoding
                    if (guessedEncoding && configuredEncoding !== guessedEncoding && files_1.SUPPORTED_ENCODINGS[guessedEncoding]) {
                        picks.unshift({ type: 'separator' });
                        picks.unshift({ id: guessedEncoding, label: files_1.SUPPORTED_ENCODINGS[guessedEncoding].labelLong, description: nls.localize('guessedEncoding', "Guessed from content") });
                    }
                    var items = picks.filter(function (p) { return p.type !== 'separator'; });
                    return _this.quickInputService.pick(picks, {
                        placeHolder: isReopenWithEncoding ? nls.localize('pickEncodingForReopen', "Select File Encoding to Reopen File") : nls.localize('pickEncodingForSave', "Select File Encoding to Save with"),
                        activeItem: items[typeof directMatchIndex === 'number' ? directMatchIndex : typeof aliasMatchIndex === 'number' ? aliasMatchIndex : -1]
                    }).then(function (encoding) {
                        if (encoding) {
                            activeControl = _this.editorService.activeControl;
                            encodingSupport = toEditorWithEncodingSupport(activeControl.input);
                            if (encodingSupport && encodingSupport.getEncoding() !== encoding.id) {
                                encodingSupport.setEncoding(encoding.id, isReopenWithEncoding ? 1 /* Decode */ : 0 /* Encode */); // Set new encoding
                            }
                        }
                    });
                });
            });
        };
        ChangeEncodingAction.ID = 'workbench.action.editor.changeEncoding';
        ChangeEncodingAction.LABEL = nls.localize('changeEncoding', "Change File Encoding");
        ChangeEncodingAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, quickInput_1.IQuickInputService),
            __param(4, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(5, files_1.IFileService)
        ], ChangeEncodingAction);
        return ChangeEncodingAction;
    }(actions_1.Action));
    exports.ChangeEncodingAction = ChangeEncodingAction;
});























define(__m[417/*vs/workbench/browser/parts/editor/editor.contribution*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,2/*vs/nls*/,12/*vs/base/common/uri*/,53/*vs/workbench/browser/quickopen*/,191/*vs/workbench/browser/parts/statusbar/statusbar*/,105/*vs/workbench/browser/editor*/,13/*vs/workbench/common/editor*/,372/*vs/workbench/browser/parts/editor/textResourceEditor*/,158/*vs/workbench/browser/parts/editor/sideBySideEditor*/,110/*vs/workbench/common/editor/diffEditorInput*/,128/*vs/workbench/common/editor/untitledEditorInput*/,93/*vs/workbench/common/editor/resourceEditorInput*/,3/*vs/platform/instantiation/common/instantiation*/,210/*vs/workbench/browser/parts/editor/textDiffEditor*/,27/*vs/workbench/services/textfile/common/textfiles*/,174/*vs/workbench/browser/parts/editor/binaryDiffEditor*/,414/*vs/workbench/browser/parts/editor/editorStatus*/,47/*vs/workbench/common/actions*/,112/*vs/workbench/browser/actions*/,23/*vs/platform/actions/common/actions*/,120/*vs/platform/instantiation/common/descriptors*/,65/*vs/base/common/keyCodes*/,164/*vs/workbench/browser/parts/editor/editorActions*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,11/*vs/workbench/services/editor/common/editorService*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,10/*vs/platform/contextkey/common/contextkey*/,18/*vs/base/common/platform*/,229/*vs/workbench/browser/parts/editor/editorPicker*/,26/*vs/base/common/network*/,56/*vs/editor/browser/editorExtensions*/,200/*vs/workbench/browser/parts/editor/editorWidgets*/]), function (require, exports, platform_1, nls, uri_1, quickopen_1, statusbar_1, editor_1, editor_2, textResourceEditor_1, sideBySideEditor_1, diffEditorInput_1, untitledEditorInput_1, resourceEditorInput_1, instantiation_1, textDiffEditor_1, textfiles_1, binaryDiffEditor_1, editorStatus_1, actions_1, actions_2, actions_3, descriptors_1, keyCodes_1, editorActions_1, editorCommands, editorService_1, quickopen_2, keybindingsRegistry_1, contextkey_1, platform_2, editorPicker_1, network_1, editorExtensions_1, editorWidgets_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Register String Editor
    platform_1.Registry.as(editor_1.Extensions.Editors).registerEditor(new editor_1.EditorDescriptor(textResourceEditor_1.TextResourceEditor, textResourceEditor_1.TextResourceEditor.ID, nls.localize('textEditor', "Text Editor")), [
        new descriptors_1.SyncDescriptor(untitledEditorInput_1.UntitledEditorInput),
        new descriptors_1.SyncDescriptor(resourceEditorInput_1.ResourceEditorInput)
    ]);
    // Register Text Diff Editor
    platform_1.Registry.as(editor_1.Extensions.Editors).registerEditor(new editor_1.EditorDescriptor(textDiffEditor_1.TextDiffEditor, textDiffEditor_1.TextDiffEditor.ID, nls.localize('textDiffEditor', "Text Diff Editor")), [
        new descriptors_1.SyncDescriptor(diffEditorInput_1.DiffEditorInput)
    ]);
    // Register Binary Resource Diff Editor
    platform_1.Registry.as(editor_1.Extensions.Editors).registerEditor(new editor_1.EditorDescriptor(binaryDiffEditor_1.BinaryResourceDiffEditor, binaryDiffEditor_1.BinaryResourceDiffEditor.ID, nls.localize('binaryDiffEditor', "Binary Diff Editor")), [
        new descriptors_1.SyncDescriptor(diffEditorInput_1.DiffEditorInput)
    ]);
    platform_1.Registry.as(editor_1.Extensions.Editors).registerEditor(new editor_1.EditorDescriptor(sideBySideEditor_1.SideBySideEditor, sideBySideEditor_1.SideBySideEditor.ID, nls.localize('sideBySideEditor', "Side by Side Editor")), [
        new descriptors_1.SyncDescriptor(editor_2.SideBySideEditorInput)
    ]);
    // Register Editor Input Factory
    var UntitledEditorInputFactory = /** @class */ (function () {
        function UntitledEditorInputFactory(textFileService) {
            this.textFileService = textFileService;
        }
        UntitledEditorInputFactory.prototype.serialize = function (editorInput) {
            if (!this.textFileService.isHotExitEnabled) {
                return null; // never restore untitled unless hot exit is enabled
            }
            var untitledEditorInput = editorInput;
            var resource = untitledEditorInput.getResource();
            if (untitledEditorInput.hasAssociatedFilePath) {
                resource = resource.with({ scheme: network_1.Schemas.file }); // untitled with associated file path use the file schema
            }
            var serialized = {
                resource: resource.toString(),
                resourceJSON: resource.toJSON(),
                modeId: untitledEditorInput.getModeId(),
                encoding: untitledEditorInput.getEncoding()
            };
            return JSON.stringify(serialized);
        };
        UntitledEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            return instantiationService.invokeFunction(function (accessor) {
                var deserialized = JSON.parse(serializedEditorInput);
                var resource = !!deserialized.resourceJSON ? uri_1.URI.revive(deserialized.resourceJSON) : uri_1.URI.parse(deserialized.resource);
                var filePath = resource.scheme === network_1.Schemas.file ? resource.fsPath : void 0;
                var language = deserialized.modeId;
                var encoding = deserialized.encoding;
                return accessor.get(editorService_1.IEditorService).createInput({ resource: resource, filePath: filePath, language: language, encoding: encoding });
            });
        };
        UntitledEditorInputFactory = __decorate([
            __param(0, textfiles_1.ITextFileService)
        ], UntitledEditorInputFactory);
        return UntitledEditorInputFactory;
    }());
    platform_1.Registry.as(editor_2.Extensions.EditorInputFactories).registerEditorInputFactory(untitledEditorInput_1.UntitledEditorInput.ID, UntitledEditorInputFactory);
    // Register Side by Side Editor Input Factory
    var SideBySideEditorInputFactory = /** @class */ (function () {
        function SideBySideEditorInputFactory() {
        }
        SideBySideEditorInputFactory.prototype.serialize = function (editorInput) {
            var input = editorInput;
            if (input.details && input.master) {
                var registry_1 = platform_1.Registry.as(editor_2.Extensions.EditorInputFactories);
                var detailsInputFactory = registry_1.getEditorInputFactory(input.details.getTypeId());
                var masterInputFactory = registry_1.getEditorInputFactory(input.master.getTypeId());
                if (detailsInputFactory && masterInputFactory) {
                    var detailsSerialized = detailsInputFactory.serialize(input.details);
                    var masterSerialized = masterInputFactory.serialize(input.master);
                    if (detailsSerialized && masterSerialized) {
                        return JSON.stringify({
                            name: input.getName(),
                            description: input.getDescription(),
                            detailsSerialized: detailsSerialized,
                            masterSerialized: masterSerialized,
                            detailsTypeId: input.details.getTypeId(),
                            masterTypeId: input.master.getTypeId()
                        });
                    }
                }
            }
            return null;
        };
        SideBySideEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            var deserialized = JSON.parse(serializedEditorInput);
            var registry = platform_1.Registry.as(editor_2.Extensions.EditorInputFactories);
            var detailsInputFactory = registry.getEditorInputFactory(deserialized.detailsTypeId);
            var masterInputFactory = registry.getEditorInputFactory(deserialized.masterTypeId);
            if (detailsInputFactory && masterInputFactory) {
                var detailsInput = detailsInputFactory.deserialize(instantiationService, deserialized.detailsSerialized);
                var masterInput = masterInputFactory.deserialize(instantiationService, deserialized.masterSerialized);
                if (detailsInput && masterInput) {
                    return new editor_2.SideBySideEditorInput(deserialized.name, deserialized.description, detailsInput, masterInput);
                }
            }
            return null;
        };
        return SideBySideEditorInputFactory;
    }());
    platform_1.Registry.as(editor_2.Extensions.EditorInputFactories).registerEditorInputFactory(editor_2.SideBySideEditorInput.ID, SideBySideEditorInputFactory);
    // Register Editor Contributions
    editorExtensions_1.registerEditorContribution(editorWidgets_1.OpenWorkspaceButtonContribution);
    // Register Editor Status
    var statusBar = platform_1.Registry.as(statusbar_1.Extensions.Statusbar);
    statusBar.registerStatusbarItem(new statusbar_1.StatusbarItemDescriptor(editorStatus_1.EditorStatus, 1 /* RIGHT */, 100 /* towards the left of the right hand side */));
    // Register Status Actions
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorStatus_1.ChangeModeAction, editorStatus_1.ChangeModeAction.ID, editorStatus_1.ChangeModeAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 43 /* KEY_M */) }), 'Change Language Mode');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorStatus_1.ChangeEOLAction, editorStatus_1.ChangeEOLAction.ID, editorStatus_1.ChangeEOLAction.LABEL), 'Change End of Line Sequence');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorStatus_1.ChangeEncodingAction, editorStatus_1.ChangeEncodingAction.ID, editorStatus_1.ChangeEncodingAction.LABEL), 'Change File Encoding');
    var QuickOpenActionContributor = /** @class */ (function (_super) {
        __extends(QuickOpenActionContributor, _super);
        function QuickOpenActionContributor(instantiationService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            return _this;
        }
        QuickOpenActionContributor.prototype.hasActions = function (context) {
            var entry = this.getEntry(context);
            return !!entry;
        };
        QuickOpenActionContributor.prototype.getActions = function (context) {
            var actions = [];
            var entry = this.getEntry(context);
            if (entry) {
                if (!this.openToSideActionInstance) {
                    this.openToSideActionInstance = this.instantiationService.createInstance(editorActions_1.OpenToSideFromQuickOpenAction);
                }
                else {
                    this.openToSideActionInstance.updateClass();
                }
                actions.push(this.openToSideActionInstance);
            }
            return actions;
        };
        QuickOpenActionContributor.prototype.getEntry = function (context) {
            if (!context || !context.element) {
                return null;
            }
            return editorActions_1.toEditorQuickOpenEntry(context.element);
        };
        QuickOpenActionContributor = __decorate([
            __param(0, instantiation_1.IInstantiationService)
        ], QuickOpenActionContributor);
        return QuickOpenActionContributor;
    }(actions_2.ActionBarContributor));
    exports.QuickOpenActionContributor = QuickOpenActionContributor;
    var actionBarRegistry = platform_1.Registry.as(actions_2.Extensions.Actionbar);
    actionBarRegistry.registerActionBarContributor(actions_2.Scope.VIEWER, QuickOpenActionContributor);
    var editorPickerContextKey = 'inEditorsPicker';
    var editorPickerContext = contextkey_1.ContextKeyExpr.and(quickopen_2.inQuickOpenContext, contextkey_1.ContextKeyExpr.has(editorPickerContextKey));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(editorPicker_1.ActiveEditorGroupPicker, editorPicker_1.ActiveEditorGroupPicker.ID, editorCommands.NAVIGATE_IN_ACTIVE_GROUP_PREFIX, editorPickerContextKey, [
        {
            prefix: editorCommands.NAVIGATE_IN_ACTIVE_GROUP_PREFIX,
            needsEditor: false,
            description: nls.localize('groupOnePicker', "Show Editors in Active Group")
        }
    ]));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(editorPicker_1.AllEditorsPicker, editorPicker_1.AllEditorsPicker.ID, editorCommands.NAVIGATE_ALL_EDITORS_GROUP_PREFIX, editorPickerContextKey, [
        {
            prefix: editorCommands.NAVIGATE_ALL_EDITORS_GROUP_PREFIX,
            needsEditor: false,
            description: nls.localize('allEditorsPicker', "Show All Opened Editors")
        }
    ]));
    // Register Editor Actions
    var category = nls.localize('view', "View");
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenNextEditorInGroup, editorActions_1.OpenNextEditorInGroup.ID, editorActions_1.OpenNextEditorInGroup.LABEL), 'View: Open Next Editor in Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenPreviousEditorInGroup, editorActions_1.OpenPreviousEditorInGroup.ID, editorActions_1.OpenPreviousEditorInGroup.LABEL), 'View: Open Previous Editor in Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenLastEditorInGroup, editorActions_1.OpenLastEditorInGroup.ID, editorActions_1.OpenLastEditorInGroup.LABEL, { primary: 512 /* Alt */ | 21 /* KEY_0 */, secondary: [2048 /* CtrlCmd */ | 30 /* KEY_9 */], mac: { primary: 256 /* WinCtrl */ | 21 /* KEY_0 */, secondary: [2048 /* CtrlCmd */ | 30 /* KEY_9 */] } }), 'View: Open Last Editor in Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenFirstEditorInGroup, editorActions_1.OpenFirstEditorInGroup.ID, editorActions_1.OpenFirstEditorInGroup.LABEL), 'View: Open First Editor in Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenNextRecentlyUsedEditorAction, editorActions_1.OpenNextRecentlyUsedEditorAction.ID, editorActions_1.OpenNextRecentlyUsedEditorAction.LABEL), 'View: Open Next Recently Used Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenPreviousRecentlyUsedEditorAction, editorActions_1.OpenPreviousRecentlyUsedEditorAction.ID, editorActions_1.OpenPreviousRecentlyUsedEditorAction.LABEL), 'View: Open Previous Recently Used Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ShowAllEditorsAction, editorActions_1.ShowAllEditorsAction.ID, editorActions_1.ShowAllEditorsAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 46 /* KEY_P */), mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 2 /* Tab */ } }), 'View: Show All Editors', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ShowEditorsInActiveGroupAction, editorActions_1.ShowEditorsInActiveGroupAction.ID, editorActions_1.ShowEditorsInActiveGroupAction.LABEL), 'View: Show Editors in Active Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenNextEditor, editorActions_1.OpenNextEditor.ID, editorActions_1.OpenNextEditor.LABEL, { primary: 2048 /* CtrlCmd */ | 12 /* PageDown */, mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 17 /* RightArrow */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 89 /* US_CLOSE_SQUARE_BRACKET */] } }), 'View: Open Next Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenPreviousEditor, editorActions_1.OpenPreviousEditor.ID, editorActions_1.OpenPreviousEditor.LABEL, { primary: 2048 /* CtrlCmd */ | 11 /* PageUp */, mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 15 /* LeftArrow */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 87 /* US_OPEN_SQUARE_BRACKET */] } }), 'View: Open Previous Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ReopenClosedEditorAction, editorActions_1.ReopenClosedEditorAction.ID, editorActions_1.ReopenClosedEditorAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 50 /* KEY_T */ }), 'View: Reopen Closed Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ClearRecentFilesAction, editorActions_1.ClearRecentFilesAction.ID, editorActions_1.ClearRecentFilesAction.LABEL), 'File: Clear Recently Opened', nls.localize('file', "File"));
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.CloseAllEditorsAction, editorActions_1.CloseAllEditorsAction.ID, editorActions_1.CloseAllEditorsAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 53 /* KEY_W */) }), 'View: Close All Editors', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.CloseAllEditorGroupsAction, editorActions_1.CloseAllEditorGroupsAction.ID, editorActions_1.CloseAllEditorGroupsAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 1024 /* Shift */ | 53 /* KEY_W */) }), 'View: Close All Editor Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.CloseLeftEditorsInGroupAction, editorActions_1.CloseLeftEditorsInGroupAction.ID, editorActions_1.CloseLeftEditorsInGroupAction.LABEL), 'View: Close Editors in Group to the Left', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.CloseEditorsInOtherGroupsAction, editorActions_1.CloseEditorsInOtherGroupsAction.ID, editorActions_1.CloseEditorsInOtherGroupsAction.LABEL), 'View: Close Editors in Other Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.CloseEditorInAllGroupsAction, editorActions_1.CloseEditorInAllGroupsAction.ID, editorActions_1.CloseEditorInAllGroupsAction.LABEL), 'View: Close Editor in All Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorAction, editorActions_1.SplitEditorAction.ID, editorActions_1.SplitEditorAction.LABEL, { primary: 2048 /* CtrlCmd */ | 88 /* US_BACKSLASH */ }), 'View: Split Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorOrthogonalAction, editorActions_1.SplitEditorOrthogonalAction.ID, editorActions_1.SplitEditorOrthogonalAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 88 /* US_BACKSLASH */) }), 'View: Split Editor Orthogonal', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorLeftAction, editorActions_1.SplitEditorLeftAction.ID, editorActions_1.SplitEditorLeftAction.LABEL), 'View: Split Editor Left', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorRightAction, editorActions_1.SplitEditorRightAction.ID, editorActions_1.SplitEditorRightAction.LABEL), 'View: Split Editor Right', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorUpAction, editorActions_1.SplitEditorUpAction.ID, editorActions_1.SplitEditorUpAction.LABEL), 'Split Editor Up', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.SplitEditorDownAction, editorActions_1.SplitEditorDownAction.ID, editorActions_1.SplitEditorDownAction.LABEL), 'View: Split Editor Down', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.JoinTwoGroupsAction, editorActions_1.JoinTwoGroupsAction.ID, editorActions_1.JoinTwoGroupsAction.LABEL), 'View: Join Editors of Two Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.JoinAllGroupsAction, editorActions_1.JoinAllGroupsAction.ID, editorActions_1.JoinAllGroupsAction.LABEL), 'View: Join Editors of All Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NavigateBetweenGroupsAction, editorActions_1.NavigateBetweenGroupsAction.ID, editorActions_1.NavigateBetweenGroupsAction.LABEL), 'View: Navigate Between Editor Groups', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ResetGroupSizesAction, editorActions_1.ResetGroupSizesAction.ID, editorActions_1.ResetGroupSizesAction.LABEL), 'View: Reset Editor Group Sizes', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MaximizeGroupAction, editorActions_1.MaximizeGroupAction.ID, editorActions_1.MaximizeGroupAction.LABEL), 'View: Maximize Editor Group and Hide Sidebar', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MinimizeOtherGroupsAction, editorActions_1.MinimizeOtherGroupsAction.ID, editorActions_1.MinimizeOtherGroupsAction.LABEL), 'View: Maximize Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorLeftInGroupAction, editorActions_1.MoveEditorLeftInGroupAction.ID, editorActions_1.MoveEditorLeftInGroupAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 11 /* PageUp */, mac: { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 1024 /* Shift */ | 15 /* LeftArrow */) } }), 'View: Move Editor Left', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorRightInGroupAction, editorActions_1.MoveEditorRightInGroupAction.ID, editorActions_1.MoveEditorRightInGroupAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 12 /* PageDown */, mac: { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 1024 /* Shift */ | 17 /* RightArrow */) } }), 'View: Move Editor Right', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveGroupLeftAction, editorActions_1.MoveGroupLeftAction.ID, editorActions_1.MoveGroupLeftAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 15 /* LeftArrow */) }), 'View: Move Editor Group Left', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveGroupRightAction, editorActions_1.MoveGroupRightAction.ID, editorActions_1.MoveGroupRightAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 17 /* RightArrow */) }), 'View: Move Editor Group Right', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveGroupUpAction, editorActions_1.MoveGroupUpAction.ID, editorActions_1.MoveGroupUpAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 16 /* UpArrow */) }), 'View: Move Editor Group Up', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveGroupDownAction, editorActions_1.MoveGroupDownAction.ID, editorActions_1.MoveGroupDownAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 18 /* DownArrow */) }), 'View: Move Editor Group Down', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToPreviousGroupAction, editorActions_1.MoveEditorToPreviousGroupAction.ID, editorActions_1.MoveEditorToPreviousGroupAction.LABEL, { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 15 /* LeftArrow */, mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 15 /* LeftArrow */ } }), 'View: Move Editor into Previous Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToNextGroupAction, editorActions_1.MoveEditorToNextGroupAction.ID, editorActions_1.MoveEditorToNextGroupAction.LABEL, { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 17 /* RightArrow */, mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 17 /* RightArrow */ } }), 'View: Move Editor into Next Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToFirstGroupAction, editorActions_1.MoveEditorToFirstGroupAction.ID, editorActions_1.MoveEditorToFirstGroupAction.LABEL, { primary: 1024 /* Shift */ | 512 /* Alt */ | 22 /* KEY_1 */, mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 22 /* KEY_1 */ } }), 'View: Move Editor into First Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToLastGroupAction, editorActions_1.MoveEditorToLastGroupAction.ID, editorActions_1.MoveEditorToLastGroupAction.LABEL, { primary: 1024 /* Shift */ | 512 /* Alt */ | 30 /* KEY_9 */, mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 30 /* KEY_9 */ } }), 'View: Move Editor into Last Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToLeftGroupAction, editorActions_1.MoveEditorToLeftGroupAction.ID, editorActions_1.MoveEditorToLeftGroupAction.LABEL), 'View: Move Editor into Left Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToRightGroupAction, editorActions_1.MoveEditorToRightGroupAction.ID, editorActions_1.MoveEditorToRightGroupAction.LABEL), 'View: Move Editor into Right Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToAboveGroupAction, editorActions_1.MoveEditorToAboveGroupAction.ID, editorActions_1.MoveEditorToAboveGroupAction.LABEL), 'View: Move Editor into Above Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.MoveEditorToBelowGroupAction, editorActions_1.MoveEditorToBelowGroupAction.ID, editorActions_1.MoveEditorToBelowGroupAction.LABEL), 'View: Move Editor into Below Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusActiveGroupAction, editorActions_1.FocusActiveGroupAction.ID, editorActions_1.FocusActiveGroupAction.LABEL), 'View: Focus Active Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusFirstGroupAction, editorActions_1.FocusFirstGroupAction.ID, editorActions_1.FocusFirstGroupAction.LABEL, { primary: 2048 /* CtrlCmd */ | 22 /* KEY_1 */ }), 'View: Focus First Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusLastGroupAction, editorActions_1.FocusLastGroupAction.ID, editorActions_1.FocusLastGroupAction.LABEL), 'View: Focus Last Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusPreviousGroup, editorActions_1.FocusPreviousGroup.ID, editorActions_1.FocusPreviousGroup.LABEL), 'View: Focus Previous Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusNextGroup, editorActions_1.FocusNextGroup.ID, editorActions_1.FocusNextGroup.LABEL), 'View: Focus Next Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusLeftGroup, editorActions_1.FocusLeftGroup.ID, editorActions_1.FocusLeftGroup.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 15 /* LeftArrow */) }), 'View: Focus Left Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusRightGroup, editorActions_1.FocusRightGroup.ID, editorActions_1.FocusRightGroup.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 17 /* RightArrow */) }), 'View: Focus Right Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusAboveGroup, editorActions_1.FocusAboveGroup.ID, editorActions_1.FocusAboveGroup.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 16 /* UpArrow */) }), 'View: Focus Above Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.FocusBelowGroup, editorActions_1.FocusBelowGroup.ID, editorActions_1.FocusBelowGroup.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 18 /* DownArrow */) }), 'View: Focus Below Editor Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NewEditorGroupLeftAction, editorActions_1.NewEditorGroupLeftAction.ID, editorActions_1.NewEditorGroupLeftAction.LABEL), 'View: New Editor Group to the Left', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NewEditorGroupRightAction, editorActions_1.NewEditorGroupRightAction.ID, editorActions_1.NewEditorGroupRightAction.LABEL), 'View: New Editor Group to the Right', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NewEditorGroupAboveAction, editorActions_1.NewEditorGroupAboveAction.ID, editorActions_1.NewEditorGroupAboveAction.LABEL), 'View: New Editor Group Above', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NewEditorGroupBelowAction, editorActions_1.NewEditorGroupBelowAction.ID, editorActions_1.NewEditorGroupBelowAction.LABEL), 'View: New Editor Group Below', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NavigateForwardAction, editorActions_1.NavigateForwardAction.ID, editorActions_1.NavigateForwardAction.LABEL, { primary: null, win: { primary: 512 /* Alt */ | 17 /* RightArrow */ }, mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 83 /* US_MINUS */ }, linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 83 /* US_MINUS */ } }), 'Go Forward');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NavigateBackwardsAction, editorActions_1.NavigateBackwardsAction.ID, editorActions_1.NavigateBackwardsAction.LABEL, { primary: null, win: { primary: 512 /* Alt */ | 15 /* LeftArrow */ }, mac: { primary: 256 /* WinCtrl */ | 83 /* US_MINUS */ }, linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 83 /* US_MINUS */ } }), 'Go Back');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NavigateToLastEditLocationAction, editorActions_1.NavigateToLastEditLocationAction.ID, editorActions_1.NavigateToLastEditLocationAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 47 /* KEY_Q */) }), 'Go to Last Edit Location');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.NavigateLastAction, editorActions_1.NavigateLastAction.ID, editorActions_1.NavigateLastAction.LABEL), 'Go Last');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenPreviousEditorFromHistoryAction, editorActions_1.OpenPreviousEditorFromHistoryAction.ID, editorActions_1.OpenPreviousEditorFromHistoryAction.LABEL), 'Open Previous Editor from History');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.ClearEditorHistoryAction, editorActions_1.ClearEditorHistoryAction.ID, editorActions_1.ClearEditorHistoryAction.LABEL), 'Clear Editor History');
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.RevertAndCloseEditorAction, editorActions_1.RevertAndCloseEditorAction.ID, editorActions_1.RevertAndCloseEditorAction.LABEL), 'View: Revert and Close Editor', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutSingleAction, editorActions_1.EditorLayoutSingleAction.ID, editorActions_1.EditorLayoutSingleAction.LABEL), 'View: Single Column Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutTwoColumnsAction, editorActions_1.EditorLayoutTwoColumnsAction.ID, editorActions_1.EditorLayoutTwoColumnsAction.LABEL), 'View: Two Columns Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutThreeColumnsAction, editorActions_1.EditorLayoutThreeColumnsAction.ID, editorActions_1.EditorLayoutThreeColumnsAction.LABEL), 'View: Three Columns Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutTwoRowsAction, editorActions_1.EditorLayoutTwoRowsAction.ID, editorActions_1.EditorLayoutTwoRowsAction.LABEL), 'View: Two Rows Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutThreeRowsAction, editorActions_1.EditorLayoutThreeRowsAction.ID, editorActions_1.EditorLayoutThreeRowsAction.LABEL), 'View: Three Rows Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutTwoByTwoGridAction, editorActions_1.EditorLayoutTwoByTwoGridAction.ID, editorActions_1.EditorLayoutTwoByTwoGridAction.LABEL), 'View: Grid Editor Layout (2x2)', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutTwoRowsRightAction, editorActions_1.EditorLayoutTwoRowsRightAction.ID, editorActions_1.EditorLayoutTwoRowsRightAction.LABEL), 'View: Two Rows Right Editor Layout', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.EditorLayoutTwoColumnsBottomAction, editorActions_1.EditorLayoutTwoColumnsBottomAction.ID, editorActions_1.EditorLayoutTwoColumnsBottomAction.LABEL), 'View: Two Columns Bottom Editor Layout', category);
    // Register Editor Picker Actions including quick navigate support
    var openNextEditorKeybinding = { primary: 2048 /* CtrlCmd */ | 2 /* Tab */, mac: { primary: 256 /* WinCtrl */ | 2 /* Tab */ } };
    var openPreviousEditorKeybinding = { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 2 /* Tab */, mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 2 /* Tab */ } };
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenNextRecentlyUsedEditorInGroupAction, editorActions_1.OpenNextRecentlyUsedEditorInGroupAction.ID, editorActions_1.OpenNextRecentlyUsedEditorInGroupAction.LABEL, openNextEditorKeybinding), 'View: Open Next Recently Used Editor in Group', category);
    registry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(editorActions_1.OpenPreviousRecentlyUsedEditorInGroupAction, editorActions_1.OpenPreviousRecentlyUsedEditorInGroupAction.ID, editorActions_1.OpenPreviousRecentlyUsedEditorInGroupAction.LABEL, openPreviousEditorKeybinding), 'View: Open Previous Recently Used Editor in Group', category);
    var quickOpenNavigateNextInEditorPickerId = 'workbench.action.quickOpenNavigateNextInEditorPicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigateNextInEditorPickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_2.getQuickNavigateHandler(quickOpenNavigateNextInEditorPickerId, true),
        when: editorPickerContext,
        primary: openNextEditorKeybinding.primary,
        mac: openNextEditorKeybinding.mac
    });
    var quickOpenNavigatePreviousInEditorPickerId = 'workbench.action.quickOpenNavigatePreviousInEditorPicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigatePreviousInEditorPickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_2.getQuickNavigateHandler(quickOpenNavigatePreviousInEditorPickerId, false),
        when: editorPickerContext,
        primary: openPreviousEditorKeybinding.primary,
        mac: openPreviousEditorKeybinding.mac
    });
    // Editor Commands
    editorCommands.setup();
    // Touch Bar
    if (platform_2.isMacintosh) {
        actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.TouchBarContext, {
            command: { id: editorActions_1.NavigateBackwardsAction.ID, title: editorActions_1.NavigateBackwardsAction.LABEL, iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/browser/parts/editor/media/back-tb.png')) } },
            group: 'navigation'
        });
        actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.TouchBarContext, {
            command: { id: editorActions_1.NavigateForwardAction.ID, title: editorActions_1.NavigateForwardAction.LABEL, iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/browser/parts/editor/media/forward-tb.png')) } },
            group: 'navigation'
        });
    }
    // Empty Editor Group Context Menu
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EmptyEditorGroupContext, { command: { id: editorCommands.SPLIT_EDITOR_UP, title: nls.localize('splitUp', "Split Up") }, group: '2_split', order: 10 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EmptyEditorGroupContext, { command: { id: editorCommands.SPLIT_EDITOR_DOWN, title: nls.localize('splitDown', "Split Down") }, group: '2_split', order: 20 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EmptyEditorGroupContext, { command: { id: editorCommands.SPLIT_EDITOR_LEFT, title: nls.localize('splitLeft', "Split Left") }, group: '2_split', order: 30 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EmptyEditorGroupContext, { command: { id: editorCommands.SPLIT_EDITOR_RIGHT, title: nls.localize('splitRight', "Split Right") }, group: '2_split', order: 40 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EmptyEditorGroupContext, { command: { id: editorCommands.CLOSE_EDITOR_GROUP_COMMAND_ID, title: nls.localize('close', "Close") }, group: '3_close', order: 10, when: contextkey_1.ContextKeyExpr.has('multipleEditorGroups') });
    // Editor Title Context Menu
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.CLOSE_EDITOR_COMMAND_ID, title: nls.localize('close', "Close") }, group: '1_close', order: 10 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID, title: nls.localize('closeOthers', "Close Others") }, group: '1_close', order: 20 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.CLOSE_EDITORS_TO_THE_RIGHT_COMMAND_ID, title: nls.localize('closeRight', "Close to the Right") }, group: '1_close', order: 30, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.showTabs') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.CLOSE_SAVED_EDITORS_COMMAND_ID, title: nls.localize('closeAllSaved', "Close Saved") }, group: '1_close', order: 40 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.CLOSE_EDITORS_IN_GROUP_COMMAND_ID, title: nls.localize('closeAll', "Close All") }, group: '1_close', order: 50 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.KEEP_EDITOR_COMMAND_ID, title: nls.localize('keepOpen', "Keep Open") }, group: '3_preview', order: 10, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.enablePreview') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.SPLIT_EDITOR_UP, title: nls.localize('splitUp', "Split Up") }, group: '5_split', order: 10 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.SPLIT_EDITOR_DOWN, title: nls.localize('splitDown', "Split Down") }, group: '5_split', order: 20 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.SPLIT_EDITOR_LEFT, title: nls.localize('splitLeft', "Split Left") }, group: '5_split', order: 30 });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitleContext, { command: { id: editorCommands.SPLIT_EDITOR_RIGHT, title: nls.localize('splitRight', "Split Right") }, group: '5_split', order: 40 });
    // Editor Title Menu
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitle, { command: { id: editorCommands.TOGGLE_DIFF_SIDE_BY_SIDE, title: nls.localize('toggleSideBySideView', "Toggle Side By Side View") }, group: '1_diff', order: 10, when: contextkey_1.ContextKeyExpr.has('isInDiffEditor') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitle, { command: { id: editorCommands.SHOW_EDITORS_IN_GROUP, title: nls.localize('showOpenedEditors', "Show Opened Editors") }, group: '3_open', order: 10, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.showTabs') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitle, { command: { id: editorCommands.CLOSE_EDITORS_IN_GROUP_COMMAND_ID, title: nls.localize('closeAll', "Close All") }, group: '5_close', order: 10, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.showTabs') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitle, { command: { id: editorCommands.CLOSE_SAVED_EDITORS_COMMAND_ID, title: nls.localize('closeAllSaved', "Close Saved") }, group: '5_close', order: 20, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.showTabs') });
    function appendEditorToolItem(primary, when, order, alternative) {
        var item = {
            command: {
                id: primary.id,
                title: primary.title,
                iconLocation: {
                    dark: uri_1.URI.parse(require.toUrl("vs/workbench/browser/parts/editor/media/" + primary.iconDark)),
                    light: uri_1.URI.parse(require.toUrl("vs/workbench/browser/parts/editor/media/" + primary.iconLight))
                }
            },
            group: 'navigation',
            when: when,
            order: order
        };
        if (alternative) {
            item.alt = {
                id: alternative.id,
                title: alternative.title,
                iconLocation: {
                    dark: uri_1.URI.parse(require.toUrl("vs/workbench/browser/parts/editor/media/" + alternative.iconDark)),
                    light: uri_1.URI.parse(require.toUrl("vs/workbench/browser/parts/editor/media/" + alternative.iconLight))
                }
            };
        }
        actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.EditorTitle, item);
    }
    // Editor Title Menu: Split Editor
    appendEditorToolItem({
        id: editorActions_1.SplitEditorAction.ID,
        title: nls.localize('splitEditorRight', "Split Editor Right"),
        iconDark: 'split-editor-horizontal-inverse.svg',
        iconLight: 'split-editor-horizontal.svg'
    }, contextkey_1.ContextKeyExpr.not('splitEditorsVertically'), 100000, // towards the end
    {
        id: editorCommands.SPLIT_EDITOR_DOWN,
        title: nls.localize('splitEditorDown', "Split Editor Down"),
        iconDark: 'split-editor-vertical-inverse.svg',
        iconLight: 'split-editor-vertical.svg'
    });
    appendEditorToolItem({
        id: editorActions_1.SplitEditorAction.ID,
        title: nls.localize('splitEditorDown', "Split Editor Down"),
        iconDark: 'split-editor-vertical-inverse.svg',
        iconLight: 'split-editor-vertical.svg'
    }, contextkey_1.ContextKeyExpr.has('splitEditorsVertically'), 100000, // towards the end
    {
        id: editorCommands.SPLIT_EDITOR_RIGHT,
        title: nls.localize('splitEditorRight', "Split Editor Right"),
        iconDark: 'split-editor-horizontal-inverse.svg',
        iconLight: 'split-editor-horizontal.svg'
    });
    // Editor Title Menu: Close Group (tabs disabled)
    appendEditorToolItem({
        id: editorCommands.CLOSE_EDITOR_COMMAND_ID,
        title: nls.localize('close', "Close"),
        iconDark: 'close-big-inverse-alt.svg',
        iconLight: 'close-big-alt.svg'
    }, contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not('config.workbench.editor.showTabs'), contextkey_1.ContextKeyExpr.not('groupActiveEditorDirty')), 1000000, // towards the far end
    {
        id: editorCommands.CLOSE_EDITORS_IN_GROUP_COMMAND_ID,
        title: nls.localize('closeAll', "Close All"),
        iconDark: 'closeall-editors-inverse.svg',
        iconLight: 'closeall-editors.svg'
    });
    appendEditorToolItem({
        id: editorCommands.CLOSE_EDITOR_COMMAND_ID,
        title: nls.localize('close', "Close"),
        iconDark: 'close-dirty-inverse-alt.svg',
        iconLight: 'close-dirty-alt.svg'
    }, contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not('config.workbench.editor.showTabs'), contextkey_1.ContextKeyExpr.has('groupActiveEditorDirty')), 1000000, // towards the far end
    {
        id: editorCommands.CLOSE_EDITORS_IN_GROUP_COMMAND_ID,
        title: nls.localize('closeAll', "Close All"),
        iconDark: 'closeall-editors-inverse.svg',
        iconLight: 'closeall-editors.svg'
    });
    // Diff Editor Title Menu: Previous Change
    appendEditorToolItem({
        id: editorCommands.GOTO_PREVIOUS_CHANGE,
        title: nls.localize('navigate.prev.label', "Previous Change"),
        iconDark: 'previous-diff-inverse.svg',
        iconLight: 'previous-diff.svg'
    }, editor_2.TextCompareEditorActiveContext, 10);
    // Diff Editor Title Menu: Next Change
    appendEditorToolItem({
        id: editorCommands.GOTO_NEXT_CHANGE,
        title: nls.localize('navigate.next.label', "Next Change"),
        iconDark: 'next-diff-inverse.svg',
        iconLight: 'next-diff.svg'
    }, editor_2.TextCompareEditorActiveContext, 11);
    // Diff Editor Title Menu: Toggle Ignore Trim Whitespace (Enabled)
    appendEditorToolItem({
        id: editorCommands.TOGGLE_DIFF_IGNORE_TRIM_WHITESPACE,
        title: nls.localize('ignoreTrimWhitespace.label', "Ignore Trim Whitespace"),
        iconDark: 'paragraph-inverse.svg',
        iconLight: 'paragraph.svg'
    }, contextkey_1.ContextKeyExpr.and(editor_2.TextCompareEditorActiveContext, contextkey_1.ContextKeyExpr.notEquals('config.diffEditor.ignoreTrimWhitespace', true)), 20);
    // Diff Editor Title Menu: Toggle Ignore Trim Whitespace (Disabled)
    appendEditorToolItem({
        id: editorCommands.TOGGLE_DIFF_IGNORE_TRIM_WHITESPACE,
        title: nls.localize('showTrimWhitespace.label', "Show Trim Whitespace"),
        iconDark: 'paragraph-disabled-inverse.svg',
        iconLight: 'paragraph-disabled.svg'
    }, contextkey_1.ContextKeyExpr.and(editor_2.TextCompareEditorActiveContext, contextkey_1.ContextKeyExpr.notEquals('config.diffEditor.ignoreTrimWhitespace', false)), 20);
    // Editor Commands for Command Palette
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.CommandPalette, { command: { id: editorCommands.KEEP_EDITOR_COMMAND_ID, title: { value: nls.localize('keepEditor', "Keep Editor"), original: 'View: Keep Editor' }, category: category }, when: contextkey_1.ContextKeyExpr.has('config.workbench.editor.enablePreview') });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.CommandPalette, { command: { id: editorCommands.CLOSE_EDITORS_IN_GROUP_COMMAND_ID, title: { value: nls.localize('closeEditorsInGroup', "Close All Editors in Group"), original: 'View: Close All Editors in Group' }, category: category } });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.CommandPalette, { command: { id: editorCommands.CLOSE_SAVED_EDITORS_COMMAND_ID, title: { value: nls.localize('closeSavedEditors', "Close Saved Editors in Group"), original: 'View: Close Saved Editors in Group' }, category: category } });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.CommandPalette, { command: { id: editorCommands.CLOSE_OTHER_EDITORS_IN_GROUP_COMMAND_ID, title: { value: nls.localize('closeOtherEditors', "Close Other Editors in Group"), original: 'View: Close Other Editors in Group' }, category: category } });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.CommandPalette, { command: { id: editorCommands.CLOSE_EDITORS_TO_THE_RIGHT_COMMAND_ID, title: { value: nls.localize('closeRightEditors', "Close Editors to the Right in Group"), original: 'View: Close Editors to the Right in Group' }, category: category } });
    // File menu
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarRecentMenu, {
        group: '1_editor',
        command: {
            id: editorActions_1.ReopenClosedEditorAction.ID,
            title: nls.localize({ key: 'miReopenClosedEditor', comment: ['&& denotes a mnemonic'] }, "&&Reopen Closed Editor")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarRecentMenu, {
        group: 'z_clear',
        command: {
            id: editorActions_1.ClearRecentFilesAction.ID,
            title: nls.localize({ key: 'miClearRecentOpen', comment: ['&& denotes a mnemonic'] }, "&&Clear Recently Opened")
        },
        order: 1
    });
    // Layout menu
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarViewMenu, {
        group: '2_appearance',
        title: nls.localize({ key: 'miEditorLayout', comment: ['&& denotes a mnemonic'] }, "Editor &&Layout"),
        submenu: actions_3.MenuId.MenubarLayoutMenu,
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '1_split',
        command: {
            id: editorCommands.SPLIT_EDITOR_UP,
            title: nls.localize({ key: 'miSplitEditorUp', comment: ['&& denotes a mnemonic'] }, "Split &&Up")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '1_split',
        command: {
            id: editorCommands.SPLIT_EDITOR_DOWN,
            title: nls.localize({ key: 'miSplitEditorDown', comment: ['&& denotes a mnemonic'] }, "Split &&Down")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '1_split',
        command: {
            id: editorCommands.SPLIT_EDITOR_LEFT,
            title: nls.localize({ key: 'miSplitEditorLeft', comment: ['&& denotes a mnemonic'] }, "Split &&Left")
        },
        order: 3
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '1_split',
        command: {
            id: editorCommands.SPLIT_EDITOR_RIGHT,
            title: nls.localize({ key: 'miSplitEditorRight', comment: ['&& denotes a mnemonic'] }, "Split &&Right")
        },
        order: 4
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutSingleAction.ID,
            title: nls.localize({ key: 'miSingleColumnEditorLayout', comment: ['&& denotes a mnemonic'] }, "&&Single")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutTwoColumnsAction.ID,
            title: nls.localize({ key: 'miTwoColumnsEditorLayout', comment: ['&& denotes a mnemonic'] }, "&&Two Columns")
        },
        order: 3
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutThreeColumnsAction.ID,
            title: nls.localize({ key: 'miThreeColumnsEditorLayout', comment: ['&& denotes a mnemonic'] }, "T&&hree Columns")
        },
        order: 4
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutTwoRowsAction.ID,
            title: nls.localize({ key: 'miTwoRowsEditorLayout', comment: ['&& denotes a mnemonic'] }, "T&&wo Rows")
        },
        order: 5
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutThreeRowsAction.ID,
            title: nls.localize({ key: 'miThreeRowsEditorLayout', comment: ['&& denotes a mnemonic'] }, "Three &&Rows")
        },
        order: 6
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutTwoByTwoGridAction.ID,
            title: nls.localize({ key: 'miTwoByTwoGridEditorLayout', comment: ['&& denotes a mnemonic'] }, "&&Grid (2x2)")
        },
        order: 7
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutTwoRowsRightAction.ID,
            title: nls.localize({ key: 'miTwoRowsRightEditorLayout', comment: ['&& denotes a mnemonic'] }, "Two R&&ows Right")
        },
        order: 8
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarLayoutMenu, {
        group: '2_layouts',
        command: {
            id: editorActions_1.EditorLayoutTwoColumnsBottomAction.ID,
            title: nls.localize({ key: 'miTwoColumnsBottomEditorLayout', comment: ['&& denotes a mnemonic'] }, "Two &&Columns Bottom")
        },
        order: 9
    });
    // Main Menu Bar Contributions:
    // Forward/Back
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarGoMenu, {
        group: '1_fwd_back',
        command: {
            id: 'workbench.action.navigateBack',
            title: nls.localize({ key: 'miBack', comment: ['&& denotes a mnemonic'] }, "&&Back"),
            precondition: contextkey_1.ContextKeyExpr.has('canNavigateBack')
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarGoMenu, {
        group: '1_fwd_back',
        command: {
            id: 'workbench.action.navigateForward',
            title: nls.localize({ key: 'miForward', comment: ['&& denotes a mnemonic'] }, "&&Forward"),
            precondition: contextkey_1.ContextKeyExpr.has('canNavigateForward')
        },
        order: 2
    });
    // Switch Editor
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchEditorMenu, {
        group: '1_any',
        command: {
            id: 'workbench.action.nextEditor',
            title: nls.localize({ key: 'miNextEditor', comment: ['&& denotes a mnemonic'] }, "&&Next Editor")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchEditorMenu, {
        group: '1_any',
        command: {
            id: 'workbench.action.previousEditor',
            title: nls.localize({ key: 'miPreviousEditor', comment: ['&& denotes a mnemonic'] }, "&&Previous Editor")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchEditorMenu, {
        group: '2_used',
        command: {
            id: 'workbench.action.openNextRecentlyUsedEditorInGroup',
            title: nls.localize({ key: 'miNextEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Used Editor in Group")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchEditorMenu, {
        group: '2_used',
        command: {
            id: 'workbench.action.openPreviousRecentlyUsedEditorInGroup',
            title: nls.localize({ key: 'miPreviousEditorInGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Used Editor in Group")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarGoMenu, {
        group: '2_switch',
        title: nls.localize({ key: 'miSwitchEditor', comment: ['&& denotes a mnemonic'] }, "Switch &&Editor"),
        submenu: actions_3.MenuId.MenubarSwitchEditorMenu,
        order: 1
    });
    // Switch Group
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '1_focus_index',
        command: {
            id: 'workbench.action.focusFirstEditorGroup',
            title: nls.localize({ key: 'miFocusFirstGroup', comment: ['&& denotes a mnemonic'] }, "Group &&1")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '1_focus_index',
        command: {
            id: 'workbench.action.focusSecondEditorGroup',
            title: nls.localize({ key: 'miFocusSecondGroup', comment: ['&& denotes a mnemonic'] }, "Group &&2")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '1_focus_index',
        command: {
            id: 'workbench.action.focusThirdEditorGroup',
            title: nls.localize({ key: 'miFocusThirdGroup', comment: ['&& denotes a mnemonic'] }, "Group &&3")
        },
        order: 3
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '1_focus_index',
        command: {
            id: 'workbench.action.focusFourthEditorGroup',
            title: nls.localize({ key: 'miFocusFourthGroup', comment: ['&& denotes a mnemonic'] }, "Group &&4")
        },
        order: 4
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '1_focus_index',
        command: {
            id: 'workbench.action.focusFifthEditorGroup',
            title: nls.localize({ key: 'miFocusFifthGroup', comment: ['&& denotes a mnemonic'] }, "Group &&5")
        },
        order: 5
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '2_next_prev',
        command: {
            id: 'workbench.action.focusNextGroup',
            title: nls.localize({ key: 'miNextGroup', comment: ['&& denotes a mnemonic'] }, "&&Next Group")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '2_next_prev',
        command: {
            id: 'workbench.action.focusPreviousGroup',
            title: nls.localize({ key: 'miPreviousGroup', comment: ['&& denotes a mnemonic'] }, "&&Previous Group")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '3_directional',
        command: {
            id: 'workbench.action.focusLeftGroup',
            title: nls.localize({ key: 'miFocusLeftGroup', comment: ['&& denotes a mnemonic'] }, "Group &&Left")
        },
        order: 1
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '3_directional',
        command: {
            id: 'workbench.action.focusRightGroup',
            title: nls.localize({ key: 'miFocusRightGroup', comment: ['&& denotes a mnemonic'] }, "Group &&Right")
        },
        order: 2
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '3_directional',
        command: {
            id: 'workbench.action.focusAboveGroup',
            title: nls.localize({ key: 'miFocusAboveGroup', comment: ['&& denotes a mnemonic'] }, "Group &&Above")
        },
        order: 3
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarSwitchGroupMenu, {
        group: '3_directional',
        command: {
            id: 'workbench.action.focusBelowGroup',
            title: nls.localize({ key: 'miFocusBelowGroup', comment: ['&& denotes a mnemonic'] }, "Group &&Below")
        },
        order: 4
    });
    actions_3.MenuRegistry.appendMenuItem(actions_3.MenuId.MenubarGoMenu, {
        group: '2_switch',
        title: nls.localize({ key: 'miSwitchGroup', comment: ['&& denotes a mnemonic'] }, "Switch &&Group"),
        submenu: actions_3.MenuId.MenubarSwitchGroupMenu,
        order: 2
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[232/*vs/workbench/browser/parts/editor/titleControl*/], __M([0/*require*/,1/*exports*/,165/*vs/base/browser/dnd*/,8/*vs/base/browser/dom*/,137/*vs/base/browser/mouseEvent*/,133/*vs/base/browser/ui/toolbar/toolbar*/,19/*vs/base/common/arrays*/,4/*vs/base/common/lifecycle*/,45/*vs/editor/browser/editorBrowser*/,2/*vs/nls*/,115/*vs/platform/actions/browser/menuItemActionItem*/,23/*vs/platform/actions/common/actions*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,28/*vs/platform/notification/common/notification*/,46/*vs/platform/quickOpen/common/quickOpen*/,32/*vs/platform/telemetry/common/telemetry*/,30/*vs/platform/theme/common/colorRegistry*/,14/*vs/platform/theme/common/themeService*/,112/*vs/workbench/browser/actions*/,84/*vs/workbench/browser/dnd*/,74/*vs/workbench/browser/parts/editor/baseEditor*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,227/*vs/workbench/browser/parts/editor/breadcrumbsControl*/,87/*vs/workbench/browser/parts/editor/editor*/,13/*vs/workbench/common/editor*/,82/*vs/workbench/common/resources*/,58/*vs/workbench/common/theme*/,70/*vs/workbench/services/extensions/common/extensions*/,244/*vs/css!vs/workbench/browser/parts/editor/media/titlecontrol*/]), function (require, exports, dnd_1, dom_1, mouseEvent_1, toolbar_1, arrays, lifecycle_1, editorBrowser_1, nls_1, menuItemActionItem_1, actions_1, configuration_1, contextkey_1, contextView_1, instantiation_1, keybinding_1, notification_1, quickOpen_1, telemetry_1, colorRegistry_1, themeService_1, actions_2, dnd_2, baseEditor_1, breadcrumbs_1, breadcrumbsControl_1, editor_1, editor_2, resources_1, theme_1, extensions_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TitleControl = /** @class */ (function (_super) {
        __extends(TitleControl, _super);
        function TitleControl(parent, accessor, group, contextMenuService, instantiationService, contextKeyService, keybindingService, telemetryService, notificationService, menuService, quickOpenService, themeService, extensionService, configurationService) {
            var _this = _super.call(this, themeService) || this;
            _this.accessor = accessor;
            _this.group = group;
            _this.contextMenuService = contextMenuService;
            _this.instantiationService = instantiationService;
            _this.contextKeyService = contextKeyService;
            _this.keybindingService = keybindingService;
            _this.telemetryService = telemetryService;
            _this.notificationService = notificationService;
            _this.menuService = menuService;
            _this.quickOpenService = quickOpenService;
            _this.extensionService = extensionService;
            _this.configurationService = configurationService;
            _this.groupTransfer = dnd_2.LocalSelectionTransfer.getInstance();
            _this.editorTransfer = dnd_2.LocalSelectionTransfer.getInstance();
            _this.currentPrimaryEditorActionIds = [];
            _this.currentSecondaryEditorActionIds = [];
            _this.editorToolBarMenuDisposables = [];
            _this.resourceContext = instantiationService.createInstance(resources_1.ResourceContextKey);
            _this.contextMenu = _this._register(_this.menuService.createMenu(actions_1.MenuId.EditorTitleContext, _this.contextKeyService));
            _this.create(parent);
            _this.registerListeners();
            return _this;
        }
        TitleControl.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.extensionService.onDidRegisterExtensions(function () { return _this.updateEditorActionsToolbar(); }));
        };
        TitleControl.prototype.createBreadcrumbsControl = function (container, options) {
            var _this = this;
            var config = this._register(breadcrumbs_1.BreadcrumbsConfig.IsEnabled.bindTo(this.configurationService));
            this._register(config.onDidChange(function () {
                var value = config.getValue();
                if (!value && _this.breadcrumbsControl) {
                    _this.breadcrumbsControl.dispose();
                    _this.breadcrumbsControl = undefined;
                    _this.handleBreadcrumbsEnablementChange();
                }
                else if (value && !_this.breadcrumbsControl) {
                    _this.breadcrumbsControl = _this.instantiationService.createInstance(breadcrumbsControl_1.BreadcrumbsControl, container, options, _this.group);
                    _this.breadcrumbsControl.update();
                    _this.handleBreadcrumbsEnablementChange();
                }
            }));
            if (config.getValue()) {
                this.breadcrumbsControl = this.instantiationService.createInstance(breadcrumbsControl_1.BreadcrumbsControl, container, options, this.group);
            }
        };
        TitleControl.prototype.createEditorActionsToolBar = function (container) {
            var _this = this;
            var context = { groupId: this.group.id };
            this.editorActionsToolbar = this._register(new toolbar_1.ToolBar(container, this.contextMenuService, {
                actionItemProvider: function (action) { return _this.actionItemProvider(action); },
                orientation: 0 /* HORIZONTAL */,
                ariaLabel: nls_1.localize('araLabelEditorActions', "Editor actions"),
                getKeyBinding: function (action) { return _this.getKeybinding(action); },
                actionRunner: this._register(new editor_2.EditorCommandsContextActionRunner(context))
            }));
            // Context
            this.editorActionsToolbar.context = context;
            // Action Run Handling
            this._register(this.editorActionsToolbar.actionRunner.onDidRun(function (e) {
                // Notify for Error
                _this.notificationService.error(e.error);
                // Log in telemetry
                if (_this.telemetryService) {
                    /* __GDPR__
                        "workbenchActionExecuted" : {
                            "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                            "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                        }
                    */
                    _this.telemetryService.publicLog('workbenchActionExecuted', { id: e.action.id, from: 'editorPart' });
                }
            }));
        };
        TitleControl.prototype.actionItemProvider = function (action) {
            var activeControl = this.group.activeControl;
            // Check Active Editor
            var actionItem;
            if (activeControl instanceof baseEditor_1.BaseEditor) {
                actionItem = activeControl.getActionItem(action);
            }
            // Check extensions
            if (!actionItem) {
                actionItem = menuItemActionItem_1.createActionItem(action, this.keybindingService, this.notificationService, this.contextMenuService);
            }
            return actionItem;
        };
        TitleControl.prototype.updateEditorActionsToolbar = function () {
            // Update Editor Actions Toolbar
            var _a = this.prepareEditorActions(this.getEditorActions()), primaryEditorActions = _a.primaryEditorActions, secondaryEditorActions = _a.secondaryEditorActions;
            // Only update if something actually has changed
            var primaryEditorActionIds = primaryEditorActions.map(function (a) { return a.id; });
            var secondaryEditorActionIds = secondaryEditorActions.map(function (a) { return a.id; });
            if (!arrays.equals(primaryEditorActionIds, this.currentPrimaryEditorActionIds) ||
                !arrays.equals(secondaryEditorActionIds, this.currentSecondaryEditorActionIds) ||
                primaryEditorActions.some(function (action) { return action instanceof actions_1.ExecuteCommandAction; }) || // execute command actions can have the same ID but different arguments
                secondaryEditorActions.some(function (action) { return action instanceof actions_1.ExecuteCommandAction; }) // see also https://github.com/Microsoft/vscode/issues/16298
            ) {
                this.editorActionsToolbar.setActions(primaryEditorActions, secondaryEditorActions)();
                this.currentPrimaryEditorActionIds = primaryEditorActionIds;
                this.currentSecondaryEditorActionIds = secondaryEditorActionIds;
            }
        };
        TitleControl.prototype.prepareEditorActions = function (editorActions) {
            var primaryEditorActions;
            var secondaryEditorActions;
            // Primary actions only for the active group
            if (this.accessor.activeGroup === this.group) {
                primaryEditorActions = actions_2.prepareActions(editorActions.primary);
            }
            else {
                primaryEditorActions = [];
            }
            // Secondary actions for all groups
            secondaryEditorActions = actions_2.prepareActions(editorActions.secondary);
            return { primaryEditorActions: primaryEditorActions, secondaryEditorActions: secondaryEditorActions };
        };
        TitleControl.prototype.getEditorActions = function () {
            var _this = this;
            var primary = [];
            var secondary = [];
            // Dispose previous listeners
            this.editorToolBarMenuDisposables = lifecycle_1.dispose(this.editorToolBarMenuDisposables);
            // Update the resource context
            this.resourceContext.set(editor_2.toResource(this.group.activeEditor, { supportSideBySide: true }));
            // Editor actions require the editor control to be there, so we retrieve it via service
            var activeControl = this.group.activeControl;
            if (activeControl instanceof baseEditor_1.BaseEditor) {
                var codeEditor = editorBrowser_1.getCodeEditor(activeControl.getControl());
                var scopedContextKeyService = codeEditor && codeEditor.invokeWithinContext(function (accessor) { return accessor.get(contextkey_1.IContextKeyService); }) || this.contextKeyService;
                var titleBarMenu = this.menuService.createMenu(actions_1.MenuId.EditorTitle, scopedContextKeyService);
                this.editorToolBarMenuDisposables.push(titleBarMenu);
                this.editorToolBarMenuDisposables.push(titleBarMenu.onDidChange(function () {
                    _this.updateEditorActionsToolbar(); // Update editor toolbar whenever contributed actions change
                }));
                menuItemActionItem_1.fillInActionBarActions(titleBarMenu, { arg: this.resourceContext.get(), shouldForwardArgs: true }, { primary: primary, secondary: secondary });
            }
            return { primary: primary, secondary: secondary };
        };
        TitleControl.prototype.clearEditorActionsToolbar = function () {
            this.editorActionsToolbar.setActions([], [])();
            this.currentPrimaryEditorActionIds = [];
            this.currentSecondaryEditorActionIds = [];
        };
        TitleControl.prototype.enableGroupDragging = function (element) {
            var _this = this;
            // Drag start
            this._register(dom_1.addDisposableListener(element, dom_1.EventType.DRAG_START, function (e) {
                if (e.target !== element) {
                    return; // only if originating from tabs container
                }
                // Set editor group as transfer
                _this.groupTransfer.setData([new dnd_2.DraggedEditorGroupIdentifier(_this.group.id)], dnd_2.DraggedEditorGroupIdentifier.prototype);
                e.dataTransfer.effectAllowed = 'copyMove';
                // If tabs are disabled, treat dragging as if an editor tab was dragged
                if (!_this.accessor.partOptions.showTabs) {
                    var resource = editor_2.toResource(_this.group.activeEditor, { supportSideBySide: true });
                    if (resource) {
                        _this.instantiationService.invokeFunction(dnd_2.fillResourceDataTransfers, [resource], e);
                    }
                }
                // Drag Image
                var label = _this.group.activeEditor.getName();
                if (_this.accessor.partOptions.showTabs && _this.group.count > 1) {
                    label = nls_1.localize('draggedEditorGroup', "{0} (+{1})", label, _this.group.count - 1);
                }
                dnd_1.applyDragImage(e, label, 'monaco-editor-group-drag-image');
            }));
            // Drag end
            this._register(dom_1.addDisposableListener(element, dom_1.EventType.DRAG_END, function () {
                _this.groupTransfer.clearData(dnd_2.DraggedEditorGroupIdentifier.prototype);
            }));
        };
        TitleControl.prototype.onContextMenu = function (editor, e, node) {
            var _this = this;
            // Update the resource context
            var currentContext = this.resourceContext.get();
            this.resourceContext.set(editor_2.toResource(editor, { supportSideBySide: true }));
            // Find target anchor
            var anchor = node;
            if (e instanceof MouseEvent) {
                var event_1 = new mouseEvent_1.StandardMouseEvent(e);
                anchor = { x: event_1.posx, y: event_1.posy };
            }
            // Fill in contributed actions
            var actions = [];
            menuItemActionItem_1.fillInContextMenuActions(this.contextMenu, { shouldForwardArgs: true, arg: this.resourceContext.get() }, actions, this.contextMenuService);
            // Show it
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () { return Promise.resolve(actions); },
                getActionsContext: function () { return ({ groupId: _this.group.id, editorIndex: _this.group.getIndexOfEditor(editor) }); },
                getKeyBinding: function (action) { return _this.getKeybinding(action); },
                onHide: function () {
                    // restore previous context
                    _this.resourceContext.set(currentContext);
                    // restore focus to active group
                    _this.accessor.activeGroup.focus();
                }
            });
        };
        TitleControl.prototype.getKeybinding = function (action) {
            return this.keybindingService.lookupKeybinding(action.id);
        };
        TitleControl.prototype.getKeybindingLabel = function (action) {
            var keybinding = this.getKeybinding(action);
            return keybinding ? keybinding.getLabel() : void 0;
        };
        TitleControl.prototype.layout = function (dimension) {
            // Optionally implemented in subclasses
            if (this.breadcrumbsControl) {
                this.breadcrumbsControl.layout(undefined);
            }
        };
        TitleControl.prototype.getPreferredHeight = function () {
            return editor_1.EDITOR_TITLE_HEIGHT + (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden() ? breadcrumbsControl_1.BreadcrumbsControl.HEIGHT : 0);
        };
        TitleControl.prototype.dispose = function () {
            this.breadcrumbsControl = lifecycle_1.dispose(this.breadcrumbsControl);
            this.editorToolBarMenuDisposables = lifecycle_1.dispose(this.editorToolBarMenuDisposables);
            _super.prototype.dispose.call(this);
        };
        TitleControl = __decorate([
            __param(3, contextView_1.IContextMenuService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, contextkey_1.IContextKeyService),
            __param(6, keybinding_1.IKeybindingService),
            __param(7, telemetry_1.ITelemetryService),
            __param(8, notification_1.INotificationService),
            __param(9, actions_1.IMenuService),
            __param(10, quickOpen_1.IQuickOpenService),
            __param(11, themeService_1.IThemeService),
            __param(12, extensions_1.IExtensionService),
            __param(13, configuration_1.IConfigurationService)
        ], TitleControl);
        return TitleControl;
    }(theme_1.Themable));
    exports.TitleControl = TitleControl;
    themeService_1.registerThemingParticipant(function (theme, collector) {
        // Drag Feedback
        var dragImageBackground = theme.getColor(colorRegistry_1.listActiveSelectionBackground);
        var dragImageForeground = theme.getColor(colorRegistry_1.listActiveSelectionForeground);
        collector.addRule("\n\t\t.monaco-editor-group-drag-image {\n\t\t\tbackground: " + dragImageBackground + ";\n\t\t\tcolor: " + dragImageForeground + ";\n\t\t}\n\t");
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[419/*vs/workbench/browser/parts/editor/noTabsTitleControl*/], __M([0/*require*/,1/*exports*/,13/*vs/workbench/common/editor*/,232/*vs/workbench/browser/parts/editor/titleControl*/,60/*vs/workbench/browser/labels*/,58/*vs/workbench/common/theme*/,140/*vs/base/browser/touch*/,8/*vs/base/browser/dom*/,87/*vs/workbench/browser/parts/editor/editor*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,75/*vs/base/common/color*/,422/*vs/css!vs/workbench/browser/parts/editor/media/notabstitlecontrol*/]), function (require, exports, editor_1, titleControl_1, labels_1, theme_1, touch_1, dom_1, editor_2, editorCommands_1, color_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var NoTabsTitleControl = /** @class */ (function (_super) {
        __extends(NoTabsTitleControl, _super);
        function NoTabsTitleControl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.activeLabel = Object.create(null);
            return _this;
        }
        NoTabsTitleControl.prototype.create = function (parent) {
            var _this = this;
            this.titleContainer = parent;
            this.titleContainer.draggable = true;
            //Container listeners
            this.registerContainerListeners();
            // Gesture Support
            touch_1.Gesture.addTarget(this.titleContainer);
            var labelContainer = document.createElement('div');
            dom_1.addClass(labelContainer, 'label-container');
            this.titleContainer.appendChild(labelContainer);
            // Editor Label
            this.editorLabel = this._register(this.instantiationService.createInstance(labels_1.ResourceLabel, labelContainer, void 0));
            this._register(this.editorLabel.onClick(function (e) { return _this.onTitleLabelClick(e); }));
            // Breadcrumbs
            this.createBreadcrumbsControl(labelContainer, { showFileIcons: false, showSymbolIcons: true, showDecorationColors: false, breadcrumbsBackground: function () { return color_1.Color.transparent; } });
            dom_1.toggleClass(this.titleContainer, 'breadcrumbs', Boolean(this.breadcrumbsControl));
            this.toDispose.push({ dispose: function () { return dom_1.removeClass(_this.titleContainer, 'breadcrumbs'); } }); // import to remove because the container is a shared dom node
            // Right Actions Container
            var actionsContainer = document.createElement('div');
            dom_1.addClass(actionsContainer, 'title-actions');
            this.titleContainer.appendChild(actionsContainer);
            // Editor actions toolbar
            this.createEditorActionsToolBar(actionsContainer);
        };
        NoTabsTitleControl.prototype.registerContainerListeners = function () {
            var _this = this;
            // Group dragging
            this.enableGroupDragging(this.titleContainer);
            // Pin on double click
            this._register(dom_1.addDisposableListener(this.titleContainer, dom_1.EventType.DBLCLICK, function (e) { return _this.onTitleDoubleClick(e); }));
            // Detect mouse click
            this._register(dom_1.addDisposableListener(this.titleContainer, dom_1.EventType.CLICK, function (e) { return _this.onTitleClick(e); }));
            // Detect touch
            this._register(dom_1.addDisposableListener(this.titleContainer, touch_1.EventType.Tap, function (e) { return _this.onTitleClick(e); }));
            // Context Menu
            this._register(dom_1.addDisposableListener(this.titleContainer, dom_1.EventType.CONTEXT_MENU, function (e) { return _this.onContextMenu(_this.group.activeEditor, e, _this.titleContainer); }));
            this._register(dom_1.addDisposableListener(this.titleContainer, touch_1.EventType.Contextmenu, function (e) { return _this.onContextMenu(_this.group.activeEditor, e, _this.titleContainer); }));
        };
        NoTabsTitleControl.prototype.onTitleLabelClick = function (e) {
            var _this = this;
            dom_1.EventHelper.stop(e, false);
            // delayed to let the onTitleClick() come first which can cause a focus change which can close quick open
            setTimeout(function () { return _this.quickOpenService.show(); });
        };
        NoTabsTitleControl.prototype.onTitleDoubleClick = function (e) {
            dom_1.EventHelper.stop(e);
            this.group.pinEditor();
        };
        NoTabsTitleControl.prototype.onTitleClick = function (e) {
            // Close editor on middle mouse click
            if (e instanceof MouseEvent && e.button === 1 /* Middle Button */) {
                dom_1.EventHelper.stop(e, true /* for https://github.com/Microsoft/vscode/issues/56715 */);
                this.group.closeEditor(this.group.activeEditor);
            }
        };
        NoTabsTitleControl.prototype.getPreferredHeight = function () {
            return editor_2.EDITOR_TITLE_HEIGHT;
        };
        NoTabsTitleControl.prototype.openEditor = function (editor) {
            var _this = this;
            var activeEditorChanged = this.ifActiveEditorChanged(function () { return _this.redraw(); });
            if (!activeEditorChanged) {
                this.ifActiveEditorPropertiesChanged(function () { return _this.redraw(); });
            }
        };
        NoTabsTitleControl.prototype.closeEditor = function (editor) {
            var _this = this;
            this.ifActiveEditorChanged(function () { return _this.redraw(); });
        };
        NoTabsTitleControl.prototype.closeEditors = function (editors) {
            var _this = this;
            this.ifActiveEditorChanged(function () { return _this.redraw(); });
        };
        NoTabsTitleControl.prototype.closeAllEditors = function () {
            this.redraw();
        };
        NoTabsTitleControl.prototype.moveEditor = function (editor, fromIndex, targetIndex) {
            var _this = this;
            this.ifActiveEditorChanged(function () { return _this.redraw(); });
        };
        NoTabsTitleControl.prototype.pinEditor = function (editor) {
            var _this = this;
            this.ifEditorIsActive(editor, function () { return _this.redraw(); });
        };
        NoTabsTitleControl.prototype.setActive = function (isActive) {
            this.redraw();
        };
        NoTabsTitleControl.prototype.updateEditorLabel = function (editor) {
            var _this = this;
            this.ifEditorIsActive(editor, function () { return _this.redraw(); });
        };
        NoTabsTitleControl.prototype.updateEditorDirty = function (editor) {
            var _this = this;
            this.ifEditorIsActive(editor, function () {
                if (editor.isDirty()) {
                    dom_1.addClass(_this.titleContainer, 'dirty');
                }
                else {
                    dom_1.removeClass(_this.titleContainer, 'dirty');
                }
            });
        };
        NoTabsTitleControl.prototype.updateOptions = function (oldOptions, newOptions) {
            if (oldOptions.labelFormat !== newOptions.labelFormat) {
                this.redraw();
            }
        };
        NoTabsTitleControl.prototype.updateStyles = function () {
            this.redraw();
        };
        NoTabsTitleControl.prototype.handleBreadcrumbsEnablementChange = function () {
            dom_1.toggleClass(this.titleContainer, 'breadcrumbs', Boolean(this.breadcrumbsControl));
            this.redraw();
        };
        NoTabsTitleControl.prototype.ifActiveEditorChanged = function (fn) {
            if (!this.activeLabel.editor && this.group.activeEditor || // active editor changed from null => editor
                this.activeLabel.editor && !this.group.activeEditor || // active editor changed from editor => null
                !this.group.isActive(this.activeLabel.editor) // active editor changed from editorA => editorB
            ) {
                fn();
                return true;
            }
            return false;
        };
        NoTabsTitleControl.prototype.ifActiveEditorPropertiesChanged = function (fn) {
            if (!this.activeLabel.editor || !this.group.activeEditor) {
                return; // need an active editor to check for properties changed
            }
            if (this.activeLabel.pinned !== this.group.isPinned(this.group.activeEditor)) {
                fn(); // only run if pinned state has changed
            }
        };
        NoTabsTitleControl.prototype.ifEditorIsActive = function (editor, fn) {
            if (this.group.isActive(editor)) {
                fn(); // only run if editor is current active
            }
        };
        NoTabsTitleControl.prototype.redraw = function () {
            var editor = this.group.activeEditor;
            var isEditorPinned = this.group.isPinned(this.group.activeEditor);
            var isGroupActive = this.accessor.activeGroup === this.group;
            this.activeLabel = { editor: editor, pinned: isEditorPinned };
            // Update Breadcrumbs
            if (this.breadcrumbsControl) {
                if (isGroupActive) {
                    this.breadcrumbsControl.update();
                    dom_1.toggleClass(this.breadcrumbsControl.domNode, 'preview', !isEditorPinned);
                }
                else {
                    this.breadcrumbsControl.hide();
                }
            }
            // Clear if there is no editor
            if (!editor) {
                dom_1.removeClass(this.titleContainer, 'dirty');
                this.editorLabel.clear();
                this.clearEditorActionsToolbar();
            }
            // Otherwise render it
            else {
                // Dirty state
                this.updateEditorDirty(editor);
                // Editor Label
                var resource = editor_1.toResource(editor, { supportSideBySide: true });
                var name_1 = editor.getName() || '';
                var labelFormat = this.accessor.partOptions.labelFormat;
                var description = void 0;
                if (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden()) {
                    description = ''; // hide description when showing breadcrumbs
                }
                else if (labelFormat === 'default' && !isGroupActive) {
                    description = ''; // hide description when group is not active and style is 'default'
                }
                else {
                    description = editor.getDescription(this.getVerbosity(labelFormat)) || '';
                }
                var title = editor.getTitle(2 /* LONG */);
                if (description === title) {
                    title = ''; // dont repeat what is already shown
                }
                this.editorLabel.setLabel({ name: name_1, description: description, resource: resource }, { title: title, italic: !isEditorPinned, extraClasses: ['no-tabs', 'title-label'] });
                if (isGroupActive) {
                    this.editorLabel.element.style.color = this.getColor(theme_1.TAB_ACTIVE_FOREGROUND);
                }
                else {
                    this.editorLabel.element.style.color = this.getColor(theme_1.TAB_UNFOCUSED_ACTIVE_FOREGROUND);
                }
                // Update Editor Actions Toolbar
                this.updateEditorActionsToolbar();
            }
        };
        NoTabsTitleControl.prototype.getVerbosity = function (style) {
            switch (style) {
                case 'short': return 0 /* SHORT */;
                case 'long': return 2 /* LONG */;
                default: return 1 /* MEDIUM */;
            }
        };
        NoTabsTitleControl.prototype.prepareEditorActions = function (editorActions) {
            var isGroupActive = this.accessor.activeGroup === this.group;
            // Group active: show all actions
            if (isGroupActive) {
                return _super.prototype.prepareEditorActions.call(this, editorActions);
            }
            // Group inactive: only show close action
            return { primaryEditorActions: editorActions.primary.filter(function (action) { return action.id === editorCommands_1.CLOSE_EDITOR_COMMAND_ID; }), secondaryEditorActions: [] };
        };
        return NoTabsTitleControl;
    }(titleControl_1.TitleControl));
    exports.NoTabsTitleControl = NoTabsTitleControl;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[420/*vs/workbench/browser/parts/editor/tabsTitleControl*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/platform*/,83/*vs/base/common/labels*/,13/*vs/workbench/common/editor*/,68/*vs/base/browser/keyboardEvent*/,140/*vs/base/browser/touch*/,60/*vs/workbench/browser/labels*/,50/*vs/base/browser/ui/actionbar/actionbar*/,34/*vs/platform/contextview/browser/contextView*/,32/*vs/platform/telemetry/common/telemetry*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,10/*vs/platform/contextkey/common/contextkey*/,23/*vs/platform/actions/common/actions*/,232/*vs/workbench/browser/parts/editor/titleControl*/,46/*vs/platform/quickOpen/common/quickOpen*/,4/*vs/base/common/lifecycle*/,223/*vs/base/browser/ui/scrollbar/scrollableElement*/,134/*vs/base/common/scrollable*/,39/*vs/base/common/map*/,14/*vs/platform/theme/common/themeService*/,58/*vs/workbench/common/theme*/,30/*vs/platform/theme/common/colorRegistry*/,84/*vs/workbench/browser/dnd*/,28/*vs/platform/notification/common/notification*/,70/*vs/workbench/services/extensions/common/extensions*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,8/*vs/base/browser/dom*/,2/*vs/nls*/,164/*vs/workbench/browser/parts/editor/editorActions*/,7/*vs/platform/configuration/common/configuration*/,227/*vs/workbench/browser/parts/editor/breadcrumbsControl*/,243/*vs/css!vs/workbench/browser/parts/editor/media/tabstitlecontrol*/]), function (require, exports, platform_1, labels_1, editor_1, keyboardEvent_1, touch_1, labels_2, actionbar_1, contextView_1, telemetry_1, instantiation_1, keybinding_1, contextkey_1, actions_1, titleControl_1, quickOpen_1, lifecycle_1, scrollableElement_1, scrollable_1, map_1, themeService_1, theme_1, colorRegistry_1, dnd_1, notification_1, extensions_1, untitledEditorService_1, dom_1, nls_1, editorActions_1, configuration_1, breadcrumbsControl_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TabsTitleControl = /** @class */ (function (_super) {
        __extends(TabsTitleControl, _super);
        function TabsTitleControl(parent, accessor, group, contextMenuService, instantiationService, untitledEditorService, contextKeyService, keybindingService, telemetryService, notificationService, menuService, quickOpenService, themeService, extensionService, configurationService) {
            var _this = _super.call(this, parent, accessor, group, contextMenuService, instantiationService, contextKeyService, keybindingService, telemetryService, notificationService, menuService, quickOpenService, themeService, extensionService, configurationService) || this;
            _this.untitledEditorService = untitledEditorService;
            _this.tabLabelWidgets = [];
            _this.tabLabels = [];
            _this.tabDisposeables = [];
            return _this;
        }
        TabsTitleControl.prototype.create = function (parent) {
            this.titleContainer = parent;
            // Tabs Container
            this.tabsContainer = document.createElement('div');
            this.tabsContainer.setAttribute('role', 'tablist');
            this.tabsContainer.draggable = true;
            dom_1.addClass(this.tabsContainer, 'tabs-container');
            // Tabs Container listeners
            this.registerContainerListeners();
            // Scrollbar
            this.createScrollbar();
            // Editor Toolbar Container
            this.editorToolbarContainer = document.createElement('div');
            dom_1.addClass(this.editorToolbarContainer, 'editor-actions');
            this.titleContainer.appendChild(this.editorToolbarContainer);
            // Editor Actions Toolbar
            this.createEditorActionsToolBar(this.editorToolbarContainer);
            // Close Action
            this.closeOneEditorAction = this._register(this.instantiationService.createInstance(editorActions_1.CloseOneEditorAction, editorActions_1.CloseOneEditorAction.ID, editorActions_1.CloseOneEditorAction.LABEL));
            // Breadcrumbs
            var breadcrumbsContainer = document.createElement('div');
            dom_1.addClass(breadcrumbsContainer, 'tabs-breadcrumbs');
            this.titleContainer.appendChild(breadcrumbsContainer);
            this.createBreadcrumbsControl(breadcrumbsContainer, { showFileIcons: true, showSymbolIcons: true, showDecorationColors: false, breadcrumbsBackground: colorRegistry_1.breadcrumbsBackground });
        };
        TabsTitleControl.prototype.createScrollbar = function () {
            var _this = this;
            // Custom Scrollbar
            this.scrollbar = new scrollableElement_1.ScrollableElement(this.tabsContainer, {
                horizontal: scrollable_1.ScrollbarVisibility.Auto,
                vertical: scrollable_1.ScrollbarVisibility.Hidden,
                scrollYToX: true,
                useShadows: false,
                horizontalScrollbarSize: 3
            });
            this.scrollbar.onScroll(function (e) {
                _this.tabsContainer.scrollLeft = e.scrollLeft;
            });
            this.titleContainer.appendChild(this.scrollbar.getDomNode());
        };
        TabsTitleControl.prototype.updateBreadcrumbsControl = function () {
            if (this.breadcrumbsControl && this.breadcrumbsControl.update()) {
                // relayout when we have a breadcrumbs and when update changed
                // its hidden-status
                this.group.relayout();
            }
        };
        TabsTitleControl.prototype.handleBreadcrumbsEnablementChange = function () {
            // relayout when breadcrumbs are enable/disabled
            this.group.relayout();
        };
        TabsTitleControl.prototype.registerContainerListeners = function () {
            var _this = this;
            // Group dragging
            this.enableGroupDragging(this.tabsContainer);
            // Forward scrolling inside the container to our custom scrollbar
            this._register(dom_1.addDisposableListener(this.tabsContainer, dom_1.EventType.SCROLL, function () {
                if (dom_1.hasClass(_this.tabsContainer, 'scroll')) {
                    _this.scrollbar.setScrollPosition({
                        scrollLeft: _this.tabsContainer.scrollLeft // during DND the  container gets scrolled so we need to update the custom scrollbar
                    });
                }
            }));
            // New file when double clicking on tabs container (but not tabs)
            this._register(dom_1.addDisposableListener(this.tabsContainer, dom_1.EventType.DBLCLICK, function (e) {
                if (e.target === _this.tabsContainer) {
                    dom_1.EventHelper.stop(e);
                    _this.group.openEditor(_this.untitledEditorService.createOrGet(), { pinned: true /* untitled is always pinned */, index: _this.group.count /* always at the end */ });
                }
            }));
            // Prevent auto-scrolling (https://github.com/Microsoft/vscode/issues/16690)
            this._register(dom_1.addDisposableListener(this.tabsContainer, dom_1.EventType.MOUSE_DOWN, function (e) {
                if (e.button === 1) {
                    e.preventDefault();
                }
            }));
            // Drop support
            this._register(new dnd_1.DragAndDropObserver(this.tabsContainer, {
                onDragEnter: function (e) {
                    // Always enable support to scroll while dragging
                    dom_1.addClass(_this.tabsContainer, 'scroll');
                    // Return if the target is not on the tabs container
                    if (e.target !== _this.tabsContainer) {
                        _this.updateDropFeedback(_this.tabsContainer, false); // fixes https://github.com/Microsoft/vscode/issues/52093
                        return;
                    }
                    // Return if transfer is unsupported
                    if (!_this.isSupportedDropTransfer(e)) {
                        e.dataTransfer.dropEffect = 'none';
                        return;
                    }
                    // Return if dragged editor is last tab because then this is a no-op
                    var isLocalDragAndDrop = false;
                    if (_this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                        isLocalDragAndDrop = true;
                        var localDraggedEditor = _this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier;
                        if (_this.group.id === localDraggedEditor.groupId && _this.group.getIndexOfEditor(localDraggedEditor.editor) === _this.group.count - 1) {
                            e.dataTransfer.dropEffect = 'none';
                            return;
                        }
                    }
                    // Update the dropEffect to "copy" if there is no local data to be dragged because
                    // in that case we can only copy the data into and not move it from its source
                    if (!isLocalDragAndDrop) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                    _this.updateDropFeedback(_this.tabsContainer, true);
                },
                onDragLeave: function (e) {
                    _this.updateDropFeedback(_this.tabsContainer, false);
                    dom_1.removeClass(_this.tabsContainer, 'scroll');
                },
                onDragEnd: function (e) {
                    _this.updateDropFeedback(_this.tabsContainer, false);
                    dom_1.removeClass(_this.tabsContainer, 'scroll');
                },
                onDrop: function (e) {
                    _this.updateDropFeedback(_this.tabsContainer, false);
                    dom_1.removeClass(_this.tabsContainer, 'scroll');
                    if (e.target === _this.tabsContainer) {
                        _this.onDrop(e, _this.group.count);
                    }
                }
            }));
        };
        TabsTitleControl.prototype.updateEditorActionsToolbar = function () {
            _super.prototype.updateEditorActionsToolbar.call(this);
            // Changing the actions in the toolbar can have an impact on the size of the
            // tab container, so we need to layout the tabs to make sure the active is visible
            this.layout(this.dimension);
        };
        TabsTitleControl.prototype.openEditor = function (editor) {
            // Create tabs as needed
            for (var i = this.tabsContainer.children.length; i < this.group.count; i++) {
                this.tabsContainer.appendChild(this.createTab(i));
            }
            // An add of a tab requires to recompute all labels
            this.computeTabLabels();
            // Redraw all tabs
            this.redraw();
            // Update Breadcrumbs
            this.updateBreadcrumbsControl();
        };
        TabsTitleControl.prototype.closeEditor = function (editor) {
            this.handleClosedEditors();
        };
        TabsTitleControl.prototype.closeEditors = function (editors) {
            this.handleClosedEditors();
        };
        TabsTitleControl.prototype.closeAllEditors = function () {
            this.handleClosedEditors();
        };
        TabsTitleControl.prototype.handleClosedEditors = function () {
            // There are tabs to show
            if (this.group.activeEditor) {
                // Remove tabs that got closed
                while (this.tabsContainer.children.length > this.group.count) {
                    // Remove one tab from container (must be the last to keep indexes in order!)
                    this.tabsContainer.lastChild.remove();
                    // Remove associated tab label and widget
                    this.tabLabelWidgets.pop();
                    this.tabDisposeables.pop().dispose();
                }
                // A removal of a label requires to recompute all labels
                this.computeTabLabels();
                // Redraw all tabs
                this.redraw();
            }
            // No tabs to show
            else {
                dom_1.clearNode(this.tabsContainer);
                this.tabDisposeables = lifecycle_1.dispose(this.tabDisposeables);
                this.tabLabelWidgets = [];
                this.tabLabels = [];
                this.clearEditorActionsToolbar();
            }
            // Update Breadcrumbs
            this.updateBreadcrumbsControl();
        };
        TabsTitleControl.prototype.moveEditor = function (editor, fromIndex, targetIndex) {
            var _this = this;
            // Swap the editor label
            var editorLabel = this.tabLabels[fromIndex];
            this.tabLabels.splice(fromIndex, 1);
            this.tabLabels.splice(targetIndex, 0, editorLabel);
            // As such we need to redraw each tab
            this.forEachTab(function (editor, index, tabContainer, tabLabelWidget, tabLabel) {
                _this.redrawTab(editor, index, tabContainer, tabLabelWidget, tabLabel);
            });
            // Moving an editor requires a layout to keep the active editor visible
            this.layout(this.dimension);
        };
        TabsTitleControl.prototype.pinEditor = function (editor) {
            var _this = this;
            this.withTab(editor, function (tabContainer, tabLabelWidget, tabLabel) { return _this.redrawLabel(editor, tabContainer, tabLabelWidget, tabLabel); });
        };
        TabsTitleControl.prototype.setActive = function (isGroupActive) {
            var _this = this;
            // Activity has an impact on each tab
            this.forEachTab(function (editor, index, tabContainer, tabLabelWidget, tabLabel) {
                _this.redrawEditorActive(isGroupActive, editor, tabContainer, tabLabelWidget);
            });
            // Activity has an impact on the toolbar, so we need to update and layout
            this.updateEditorActionsToolbar();
            this.layout(this.dimension);
        };
        TabsTitleControl.prototype.updateEditorLabel = function (editor) {
            var _this = this;
            // A change to a label requires to recompute all labels
            this.computeTabLabels();
            // As such we need to redraw each label
            this.forEachTab(function (editor, index, tabContainer, tabLabelWidget, tabLabel) {
                _this.redrawLabel(editor, tabContainer, tabLabelWidget, tabLabel);
            });
            // A change to a label requires a layout to keep the active editor visible
            this.layout(this.dimension);
        };
        TabsTitleControl.prototype.updateEditorDirty = function (editor) {
            var _this = this;
            this.withTab(editor, function (tabContainer) { return _this.redrawEditorDirty(editor, tabContainer); });
        };
        TabsTitleControl.prototype.updateOptions = function (oldOptions, newOptions) {
            // A change to a label format options requires to recompute all labels
            if (oldOptions.labelFormat !== newOptions.labelFormat) {
                this.computeTabLabels();
            }
            // Apply new options if something of interest changed
            if (oldOptions.labelFormat !== newOptions.labelFormat ||
                oldOptions.tabCloseButton !== newOptions.tabCloseButton ||
                oldOptions.tabSizing !== newOptions.tabSizing ||
                oldOptions.showIcons !== newOptions.showIcons ||
                oldOptions.iconTheme !== newOptions.iconTheme) {
                this.redraw();
            }
        };
        TabsTitleControl.prototype.updateStyles = function () {
            this.redraw();
        };
        TabsTitleControl.prototype.withTab = function (editor, fn) {
            var editorIndex = this.group.getIndexOfEditor(editor);
            var tabContainer = this.tabsContainer.children[editorIndex];
            if (tabContainer) {
                fn(tabContainer, this.tabLabelWidgets[editorIndex], this.tabLabels[editorIndex]);
            }
        };
        TabsTitleControl.prototype.createTab = function (index) {
            var _this = this;
            // Tab Container
            var tabContainer = document.createElement('div');
            tabContainer.draggable = true;
            tabContainer.tabIndex = 0;
            tabContainer.setAttribute('role', 'presentation'); // cannot use role "tab" here due to https://github.com/Microsoft/vscode/issues/8659
            dom_1.addClass(tabContainer, 'tab');
            // Gesture Support
            touch_1.Gesture.addTarget(tabContainer);
            // Tab Border Top
            var tabBorderTopContainer = document.createElement('div');
            dom_1.addClass(tabBorderTopContainer, 'tab-border-top-container');
            tabContainer.appendChild(tabBorderTopContainer);
            // Tab Editor Label
            var editorLabel = this.instantiationService.createInstance(labels_2.ResourceLabel, tabContainer, void 0);
            this.tabLabelWidgets.push(editorLabel);
            // Tab Close Button
            var tabCloseContainer = document.createElement('div');
            dom_1.addClass(tabCloseContainer, 'tab-close');
            tabContainer.appendChild(tabCloseContainer);
            // Tab Border Bottom
            var tabBorderBottomContainer = document.createElement('div');
            dom_1.addClass(tabBorderBottomContainer, 'tab-border-bottom-container');
            tabContainer.appendChild(tabBorderBottomContainer);
            var tabActionRunner = new editor_1.EditorCommandsContextActionRunner({ groupId: this.group.id, editorIndex: index });
            var tabActionBar = new actionbar_1.ActionBar(tabCloseContainer, { ariaLabel: nls_1.localize('araLabelTabActions', "Tab actions"), actionRunner: tabActionRunner });
            tabActionBar.push(this.closeOneEditorAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.closeOneEditorAction) });
            tabActionBar.onDidBeforeRun(function () { return _this.blockRevealActiveTabOnce(); });
            // Eventing
            var eventsDisposable = this.registerTabListeners(tabContainer, index);
            this.tabDisposeables.push(lifecycle_1.combinedDisposable([eventsDisposable, tabActionBar, tabActionRunner, editorLabel]));
            return tabContainer;
        };
        TabsTitleControl.prototype.registerTabListeners = function (tab, index) {
            var _this = this;
            var disposables = [];
            var handleClickOrTouch = function (e) {
                tab.blur();
                if (e instanceof MouseEvent && e.button !== 0) {
                    if (e.button === 1) {
                        e.preventDefault(); // required to prevent auto-scrolling (https://github.com/Microsoft/vscode/issues/16690)
                    }
                    return void 0; // only for left mouse click
                }
                if (_this.originatesFromTabActionBar(e)) {
                    return; // not when clicking on actions
                }
                // Open tabs editor
                _this.group.openEditor(_this.group.getEditor(index));
                return void 0;
            };
            var showContextMenu = function (e) {
                dom_1.EventHelper.stop(e);
                _this.onContextMenu(_this.group.getEditor(index), e, tab);
            };
            // Open on Click / Touch
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.MOUSE_DOWN, function (e) { return handleClickOrTouch(e); }));
            disposables.push(dom_1.addDisposableListener(tab, touch_1.EventType.Tap, function (e) { return handleClickOrTouch(e); }));
            // Touch Scroll Support
            disposables.push(dom_1.addDisposableListener(tab, touch_1.EventType.Change, function (e) {
                _this.scrollbar.setScrollPosition({ scrollLeft: _this.scrollbar.getScrollPosition().scrollLeft - e.translationX });
            }));
            // Close on mouse middle click
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.MOUSE_UP, function (e) {
                dom_1.EventHelper.stop(e);
                tab.blur();
                if (e.button === 1 /* Middle Button*/ && !_this.originatesFromTabActionBar(e)) {
                    e.stopPropagation(); // for https://github.com/Microsoft/vscode/issues/56715
                    _this.blockRevealActiveTabOnce();
                    _this.closeOneEditorAction.run({ groupId: _this.group.id, editorIndex: index });
                }
            }));
            // Context menu on Shift+F10
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                if (event.shiftKey && event.keyCode === 68 /* F10 */) {
                    showContextMenu(e);
                }
            }));
            // Context menu on touch context menu gesture
            disposables.push(dom_1.addDisposableListener(tab, touch_1.EventType.Contextmenu, function (e) {
                showContextMenu(e);
            }));
            // Keyboard accessibility
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                var handled = false;
                // Run action on Enter/Space
                if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                    handled = true;
                    _this.group.openEditor(_this.group.getEditor(index));
                }
                // Navigate in editors
                else if ([15 /* LeftArrow */, 17 /* RightArrow */, 16 /* UpArrow */, 18 /* DownArrow */, 14 /* Home */, 13 /* End */].some(function (kb) { return event.equals(kb); })) {
                    var targetIndex = void 0;
                    if (event.equals(15 /* LeftArrow */) || event.equals(16 /* UpArrow */)) {
                        targetIndex = index - 1;
                    }
                    else if (event.equals(17 /* RightArrow */) || event.equals(18 /* DownArrow */)) {
                        targetIndex = index + 1;
                    }
                    else if (event.equals(14 /* Home */)) {
                        targetIndex = 0;
                    }
                    else {
                        targetIndex = _this.group.count - 1;
                    }
                    var target = _this.group.getEditor(targetIndex);
                    if (target) {
                        handled = true;
                        _this.group.openEditor(target, { preserveFocus: true });
                        _this.tabsContainer.childNodes[targetIndex].focus();
                    }
                }
                if (handled) {
                    dom_1.EventHelper.stop(e, true);
                }
                // moving in the tabs container can have an impact on scrolling position, so we need to update the custom scrollbar
                _this.scrollbar.setScrollPosition({
                    scrollLeft: _this.tabsContainer.scrollLeft
                });
            }));
            // Pin on double click
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.DBLCLICK, function (e) {
                dom_1.EventHelper.stop(e);
                _this.group.pinEditor(_this.group.getEditor(index));
            }));
            // Context menu
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.CONTEXT_MENU, function (e) {
                dom_1.EventHelper.stop(e, true);
                _this.onContextMenu(_this.group.getEditor(index), e, tab);
            }, true /* use capture to fix https://github.com/Microsoft/vscode/issues/19145 */));
            // Drag support
            disposables.push(dom_1.addDisposableListener(tab, dom_1.EventType.DRAG_START, function (e) {
                var editor = _this.group.getEditor(index);
                _this.editorTransfer.setData([new dnd_1.DraggedEditorIdentifier({ editor: editor, groupId: _this.group.id })], dnd_1.DraggedEditorIdentifier.prototype);
                e.dataTransfer.effectAllowed = 'copyMove';
                // Apply some datatransfer types to allow for dragging the element outside of the application
                var resource = editor_1.toResource(editor, { supportSideBySide: true });
                if (resource) {
                    _this.instantiationService.invokeFunction(dnd_1.fillResourceDataTransfers, [resource], e);
                }
                // Fixes https://github.com/Microsoft/vscode/issues/18733
                dom_1.addClass(tab, 'dragged');
                dom_1.scheduleAtNextAnimationFrame(function () { return dom_1.removeClass(tab, 'dragged'); });
            }));
            // Drop support
            disposables.push(new dnd_1.DragAndDropObserver(tab, {
                onDragEnter: function (e) {
                    // Update class to signal drag operation
                    dom_1.addClass(tab, 'dragged-over');
                    // Return if transfer is unsupported
                    if (!_this.isSupportedDropTransfer(e)) {
                        e.dataTransfer.dropEffect = 'none';
                        return;
                    }
                    // Return if dragged editor is the current tab dragged over
                    var isLocalDragAndDrop = false;
                    if (_this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                        isLocalDragAndDrop = true;
                        var localDraggedEditor = _this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier;
                        if (localDraggedEditor.editor === _this.group.getEditor(index) && localDraggedEditor.groupId === _this.group.id) {
                            e.dataTransfer.dropEffect = 'none';
                            return;
                        }
                    }
                    // Update the dropEffect to "copy" if there is no local data to be dragged because
                    // in that case we can only copy the data into and not move it from its source
                    if (!isLocalDragAndDrop) {
                        e.dataTransfer.dropEffect = 'copy';
                    }
                    _this.updateDropFeedback(tab, true, index);
                },
                onDragLeave: function (e) {
                    dom_1.removeClass(tab, 'dragged-over');
                    _this.updateDropFeedback(tab, false, index);
                },
                onDragEnd: function (e) {
                    dom_1.removeClass(tab, 'dragged-over');
                    _this.updateDropFeedback(tab, false, index);
                    _this.editorTransfer.clearData(dnd_1.DraggedEditorIdentifier.prototype);
                },
                onDrop: function (e) {
                    dom_1.removeClass(tab, 'dragged-over');
                    _this.updateDropFeedback(tab, false, index);
                    _this.onDrop(e, index);
                }
            }));
            return lifecycle_1.combinedDisposable(disposables);
        };
        TabsTitleControl.prototype.isSupportedDropTransfer = function (e) {
            if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {
                var group = this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0];
                if (group.identifier === this.group.id) {
                    return false; // groups cannot be dropped on title area it originates from
                }
                return true;
            }
            if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                return true; // (local) editors can always be dropped
            }
            if (e.dataTransfer.types.length > 0) {
                return true; // optimistically allow external data (// see https://github.com/Microsoft/vscode/issues/25789)
            }
            return false;
        };
        TabsTitleControl.prototype.updateDropFeedback = function (element, isDND, index) {
            var isTab = (typeof index === 'number');
            var isActiveTab = isTab && this.group.isActive(this.group.getEditor(index));
            // Background
            var noDNDBackgroundColor = isTab ? this.getColor(isActiveTab ? theme_1.TAB_ACTIVE_BACKGROUND : theme_1.TAB_INACTIVE_BACKGROUND) : null;
            element.style.backgroundColor = isDND ? this.getColor(theme_1.EDITOR_DRAG_AND_DROP_BACKGROUND) : noDNDBackgroundColor;
            // Outline
            var activeContrastBorderColor = this.getColor(colorRegistry_1.activeContrastBorder);
            if (activeContrastBorderColor && isDND) {
                element.style.outlineWidth = '2px';
                element.style.outlineStyle = 'dashed';
                element.style.outlineColor = activeContrastBorderColor;
                element.style.outlineOffset = isTab ? '-5px' : '-3px';
            }
            else {
                element.style.outlineWidth = null;
                element.style.outlineStyle = null;
                element.style.outlineColor = activeContrastBorderColor;
                element.style.outlineOffset = null;
            }
        };
        TabsTitleControl.prototype.computeTabLabels = function () {
            var labelFormat = this.accessor.partOptions.labelFormat;
            var _a = this.getLabelConfigFlags(labelFormat), verbosity = _a.verbosity, shortenDuplicates = _a.shortenDuplicates;
            // Build labels and descriptions for each editor
            var labels = this.group.editors.map(function (editor) { return ({
                editor: editor,
                name: editor.getName(),
                description: editor.getDescription(verbosity),
                title: editor.getTitle(2 /* LONG */)
            }); });
            // Shorten labels as needed
            if (shortenDuplicates) {
                this.shortenTabLabels(labels);
            }
            this.tabLabels = labels;
        };
        TabsTitleControl.prototype.shortenTabLabels = function (labels) {
            // Gather duplicate titles, while filtering out invalid descriptions
            var mapTitleToDuplicates = new Map();
            for (var _i = 0, labels_3 = labels; _i < labels_3.length; _i++) {
                var label = labels_3[_i];
                if (typeof label.description === 'string') {
                    map_1.getOrSet(mapTitleToDuplicates, label.name, []).push(label);
                }
                else {
                    label.description = '';
                }
            }
            // Identify duplicate titles and shorten descriptions
            mapTitleToDuplicates.forEach(function (duplicateTitles) {
                // Remove description if the title isn't duplicated
                if (duplicateTitles.length === 1) {
                    duplicateTitles[0].description = '';
                    return;
                }
                // Identify duplicate descriptions
                var mapDescriptionToDuplicates = new Map();
                for (var _i = 0, duplicateTitles_1 = duplicateTitles; _i < duplicateTitles_1.length; _i++) {
                    var label = duplicateTitles_1[_i];
                    map_1.getOrSet(mapDescriptionToDuplicates, label.description, []).push(label);
                }
                // For editors with duplicate descriptions, check whether any long descriptions differ
                var useLongDescriptions = false;
                mapDescriptionToDuplicates.forEach(function (duplicateDescriptions, name) {
                    if (!useLongDescriptions && duplicateDescriptions.length > 1) {
                        var _a = duplicateDescriptions.map(function (_a) {
                            var editor = _a.editor;
                            return editor.getDescription(2 /* LONG */);
                        }), first_1 = _a[0], rest = _a.slice(1);
                        useLongDescriptions = rest.some(function (description) { return description !== first_1; });
                    }
                });
                // If so, replace all descriptions with long descriptions
                if (useLongDescriptions) {
                    mapDescriptionToDuplicates.clear();
                    duplicateTitles.forEach(function (label) {
                        label.description = label.editor.getDescription(2 /* LONG */);
                        map_1.getOrSet(mapDescriptionToDuplicates, label.description, []).push(label);
                    });
                }
                // Obtain final set of descriptions
                var descriptions = [];
                mapDescriptionToDuplicates.forEach(function (_, description) { return descriptions.push(description); });
                // Remove description if all descriptions are identical
                if (descriptions.length === 1) {
                    for (var _a = 0, _b = mapDescriptionToDuplicates.get(descriptions[0]); _a < _b.length; _a++) {
                        var label = _b[_a];
                        label.description = '';
                    }
                    return;
                }
                // Shorten descriptions
                var shortenedDescriptions = labels_1.shorten(descriptions);
                descriptions.forEach(function (description, i) {
                    for (var _i = 0, _a = mapDescriptionToDuplicates.get(description); _i < _a.length; _i++) {
                        var label = _a[_i];
                        label.description = shortenedDescriptions[i];
                    }
                });
            });
        };
        TabsTitleControl.prototype.getLabelConfigFlags = function (value) {
            switch (value) {
                case 'short':
                    return { verbosity: 0 /* SHORT */, shortenDuplicates: false };
                case 'medium':
                    return { verbosity: 1 /* MEDIUM */, shortenDuplicates: false };
                case 'long':
                    return { verbosity: 2 /* LONG */, shortenDuplicates: false };
                default:
                    return { verbosity: 1 /* MEDIUM */, shortenDuplicates: true };
            }
        };
        TabsTitleControl.prototype.redraw = function () {
            var _this = this;
            // For each tab
            this.forEachTab(function (editor, index, tabContainer, tabLabelWidget, tabLabel) {
                _this.redrawTab(editor, index, tabContainer, tabLabelWidget, tabLabel);
            });
            // Update Editor Actions Toolbar
            this.updateEditorActionsToolbar();
            // Ensure the active tab is always revealed
            this.layout(this.dimension);
        };
        TabsTitleControl.prototype.forEachTab = function (fn) {
            var _this = this;
            this.group.editors.forEach(function (editor, index) {
                var tabContainer = _this.tabsContainer.children[index];
                if (tabContainer) {
                    fn(editor, index, tabContainer, _this.tabLabelWidgets[index], _this.tabLabels[index]);
                }
            });
        };
        TabsTitleControl.prototype.redrawTab = function (editor, index, tabContainer, tabLabelWidget, tabLabel) {
            // Label
            this.redrawLabel(editor, tabContainer, tabLabelWidget, tabLabel);
            // Borders / Outline
            var borderRightColor = (this.getColor(theme_1.TAB_BORDER) || this.getColor(colorRegistry_1.contrastBorder));
            tabContainer.style.borderRight = borderRightColor ? "1px solid " + borderRightColor : null;
            tabContainer.style.outlineColor = this.getColor(colorRegistry_1.activeContrastBorder);
            // Settings
            var options = this.accessor.partOptions;
            ['off', 'left', 'right'].forEach(function (option) {
                var domAction = options.tabCloseButton === option ? dom_1.addClass : dom_1.removeClass;
                domAction(tabContainer, "close-button-" + option);
            });
            ['fit', 'shrink'].forEach(function (option) {
                var domAction = options.tabSizing === option ? dom_1.addClass : dom_1.removeClass;
                domAction(tabContainer, "sizing-" + option);
            });
            if (options.showIcons && !!options.iconTheme) {
                dom_1.addClass(tabContainer, 'has-icon-theme');
            }
            else {
                dom_1.removeClass(tabContainer, 'has-icon-theme');
            }
            // Active state
            this.redrawEditorActive(this.accessor.activeGroup === this.group, editor, tabContainer, tabLabelWidget);
            // Dirty State
            this.redrawEditorDirty(editor, tabContainer);
        };
        TabsTitleControl.prototype.redrawLabel = function (editor, tabContainer, tabLabelWidget, tabLabel) {
            var name = tabLabel.name;
            var description = tabLabel.description || '';
            var title = tabLabel.title || '';
            // Container
            tabContainer.setAttribute('aria-label', name + ", tab");
            tabContainer.title = title;
            // Label
            tabLabelWidget.setLabel({ name: name, description: description, resource: editor_1.toResource(editor, { supportSideBySide: true }) }, { title: title, extraClasses: ['tab-label'], italic: !this.group.isPinned(editor) });
        };
        TabsTitleControl.prototype.redrawEditorActive = function (isGroupActive, editor, tabContainer, tabLabelWidget) {
            // Tab is active
            if (this.group.isActive(editor)) {
                // Container
                dom_1.addClass(tabContainer, 'active');
                tabContainer.setAttribute('aria-selected', 'true');
                tabContainer.style.backgroundColor = this.getColor(theme_1.TAB_ACTIVE_BACKGROUND);
                var activeTabBorderColorBottom = this.getColor(isGroupActive ? theme_1.TAB_ACTIVE_BORDER : theme_1.TAB_UNFOCUSED_ACTIVE_BORDER);
                if (activeTabBorderColorBottom) {
                    dom_1.addClass(tabContainer, 'tab-border-bottom');
                    tabContainer.style.setProperty('--tab-border-bottom-color', activeTabBorderColorBottom.toString());
                }
                else {
                    dom_1.removeClass(tabContainer, 'tab-border-bottom');
                    tabContainer.style.removeProperty('--tab-border-bottom-color');
                }
                var activeTabBorderColorTop = this.getColor(isGroupActive ? theme_1.TAB_ACTIVE_BORDER_TOP : theme_1.TAB_UNFOCUSED_ACTIVE_BORDER_TOP);
                if (activeTabBorderColorTop) {
                    dom_1.addClass(tabContainer, 'tab-border-top');
                    tabContainer.style.setProperty('--tab-border-top-color', activeTabBorderColorTop.toString());
                }
                else {
                    dom_1.removeClass(tabContainer, 'tab-border-top');
                    tabContainer.style.removeProperty('--tab-border-top-color');
                }
                // Label
                tabLabelWidget.element.style.color = this.getColor(isGroupActive ? theme_1.TAB_ACTIVE_FOREGROUND : theme_1.TAB_UNFOCUSED_ACTIVE_FOREGROUND);
            }
            // Tab is inactive
            else {
                // Containr
                dom_1.removeClass(tabContainer, 'active');
                tabContainer.setAttribute('aria-selected', 'false');
                tabContainer.style.backgroundColor = this.getColor(theme_1.TAB_INACTIVE_BACKGROUND);
                tabContainer.style.boxShadow = null;
                // Label
                tabLabelWidget.element.style.color = this.getColor(isGroupActive ? theme_1.TAB_INACTIVE_FOREGROUND : theme_1.TAB_UNFOCUSED_INACTIVE_FOREGROUND);
            }
        };
        TabsTitleControl.prototype.redrawEditorDirty = function (editor, tabContainer) {
            if (editor.isDirty()) {
                dom_1.addClass(tabContainer, 'dirty');
            }
            else {
                dom_1.removeClass(tabContainer, 'dirty');
            }
        };
        TabsTitleControl.prototype.layout = function (dimension) {
            var _this = this;
            var activeTab = this.getTab(this.group.activeEditor);
            if (!activeTab || !dimension) {
                return;
            }
            this.dimension = dimension;
            // The layout of tabs can be an expensive operation because we access DOM properties
            // that can result in the browser doing a full page layout to validate them. To buffer
            // this a little bit we try at least to schedule this work on the next animation frame.
            if (!this.layoutScheduled) {
                this.layoutScheduled = dom_1.scheduleAtNextAnimationFrame(function () {
                    _this.doLayout(_this.dimension);
                    _this.layoutScheduled = void 0;
                });
            }
        };
        TabsTitleControl.prototype.doLayout = function (dimension) {
            var activeTab = this.getTab(this.group.activeEditor);
            if (!activeTab) {
                return;
            }
            if (this.breadcrumbsControl && !this.breadcrumbsControl.isHidden()) {
                this.breadcrumbsControl.layout({ width: dimension.width, height: breadcrumbsControl_1.BreadcrumbsControl.HEIGHT });
                this.scrollbar.getDomNode().style.height = dimension.height - breadcrumbsControl_1.BreadcrumbsControl.HEIGHT + "px";
            }
            var visibleContainerWidth = this.tabsContainer.offsetWidth;
            var totalContainerWidth = this.tabsContainer.scrollWidth;
            var activeTabPosX;
            var activeTabWidth;
            if (!this.blockRevealActiveTab) {
                activeTabPosX = activeTab.offsetLeft;
                activeTabWidth = activeTab.offsetWidth;
            }
            // Update scrollbar
            this.scrollbar.setScrollDimensions({
                width: visibleContainerWidth,
                scrollWidth: totalContainerWidth
            });
            // Return now if we are blocked to reveal the active tab and clear flag
            if (this.blockRevealActiveTab) {
                this.blockRevealActiveTab = false;
                return;
            }
            // Reveal the active one
            var containerScrollPosX = this.scrollbar.getScrollPosition().scrollLeft;
            var activeTabFits = activeTabWidth <= visibleContainerWidth;
            // Tab is overflowing to the right: Scroll minimally until the element is fully visible to the right
            // Note: only try to do this if we actually have enough width to give to show the tab fully!
            if (activeTabFits && containerScrollPosX + visibleContainerWidth < activeTabPosX + activeTabWidth) {
                this.scrollbar.setScrollPosition({
                    scrollLeft: containerScrollPosX + ((activeTabPosX + activeTabWidth) /* right corner of tab */ - (containerScrollPosX + visibleContainerWidth) /* right corner of view port */)
                });
            }
            // Tab is overlflowng to the left or does not fit: Scroll it into view to the left
            else if (containerScrollPosX > activeTabPosX || !activeTabFits) {
                this.scrollbar.setScrollPosition({
                    scrollLeft: activeTabPosX
                });
            }
        };
        TabsTitleControl.prototype.getTab = function (editor) {
            var editorIndex = this.group.getIndexOfEditor(editor);
            if (editorIndex >= 0) {
                return this.tabsContainer.children[editorIndex];
            }
            return void 0;
        };
        TabsTitleControl.prototype.blockRevealActiveTabOnce = function () {
            // When closing tabs through the tab close button or gesture, the user
            // might want to rapidly close tabs in sequence and as such revealing
            // the active tab after each close would be annoying. As such we block
            // the automated revealing of the active tab once after the close is
            // triggered.
            this.blockRevealActiveTab = true;
        };
        TabsTitleControl.prototype.originatesFromTabActionBar = function (e) {
            var element;
            if (e instanceof MouseEvent) {
                element = (e.target || e.srcElement);
            }
            else {
                element = e.initialTarget;
            }
            return !!dom_1.findParentWithClass(element, 'monaco-action-bar', 'tab');
        };
        TabsTitleControl.prototype.onDrop = function (e, targetIndex) {
            var _this = this;
            dom_1.EventHelper.stop(e, true);
            this.updateDropFeedback(this.tabsContainer, false);
            dom_1.removeClass(this.tabsContainer, 'scroll');
            // Local Editor DND
            if (this.editorTransfer.hasData(dnd_1.DraggedEditorIdentifier.prototype)) {
                var draggedEditor = this.editorTransfer.getData(dnd_1.DraggedEditorIdentifier.prototype)[0].identifier;
                var sourceGroup = this.accessor.getGroup(draggedEditor.groupId);
                // Move editor to target position and index
                if (this.isMoveOperation(e, draggedEditor.groupId)) {
                    sourceGroup.moveEditor(draggedEditor.editor, this.group, { index: targetIndex });
                }
                // Copy editor to target position and index
                else {
                    sourceGroup.copyEditor(draggedEditor.editor, this.group, { index: targetIndex });
                }
                this.group.focus();
                this.editorTransfer.clearData(dnd_1.DraggedEditorIdentifier.prototype);
            }
            // Local Editor Group DND
            else if (this.groupTransfer.hasData(dnd_1.DraggedEditorGroupIdentifier.prototype)) {
                var sourceGroup = this.accessor.getGroup(this.groupTransfer.getData(dnd_1.DraggedEditorGroupIdentifier.prototype)[0].identifier);
                var mergeGroupOptions = { index: targetIndex };
                if (!this.isMoveOperation(e, sourceGroup.id)) {
                    mergeGroupOptions.mode = 0 /* COPY_EDITORS */;
                }
                this.accessor.mergeGroup(sourceGroup, this.group, mergeGroupOptions);
                this.group.focus();
                this.groupTransfer.clearData(dnd_1.DraggedEditorGroupIdentifier.prototype);
            }
            // External DND
            else {
                var dropHandler = this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: false /* open workspace file as file if dropped */ });
                dropHandler.handleDrop(e, function () { return _this.group; }, function () { return _this.group.focus(); }, targetIndex);
            }
        };
        TabsTitleControl.prototype.isMoveOperation = function (e, source) {
            var isCopy = (e.ctrlKey && !platform_1.isMacintosh) || (e.altKey && platform_1.isMacintosh);
            return !isCopy || source === this.group.id;
        };
        TabsTitleControl.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.layoutScheduled = lifecycle_1.dispose(this.layoutScheduled);
        };
        TabsTitleControl = __decorate([
            __param(3, contextView_1.IContextMenuService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, untitledEditorService_1.IUntitledEditorService),
            __param(6, contextkey_1.IContextKeyService),
            __param(7, keybinding_1.IKeybindingService),
            __param(8, telemetry_1.ITelemetryService),
            __param(9, notification_1.INotificationService),
            __param(10, actions_1.IMenuService),
            __param(11, quickOpen_1.IQuickOpenService),
            __param(12, themeService_1.IThemeService),
            __param(13, extensions_1.IExtensionService),
            __param(14, configuration_1.IConfigurationService)
        ], TabsTitleControl);
        return TabsTitleControl;
    }(titleControl_1.TitleControl));
    exports.TabsTitleControl = TabsTitleControl;
    themeService_1.registerThemingParticipant(function (theme, collector) {
        // Styling with Outline color (e.g. high contrast theme)
        var activeContrastBorderColor = theme.getColor(colorRegistry_1.activeContrastBorder);
        if (activeContrastBorderColor) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active,\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active:hover  {\n\t\t\t\toutline: 1px solid;\n\t\t\t\toutline-offset: -5px;\n\t\t\t}\n\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {\n\t\t\t\toutline: 1px dashed;\n\t\t\t\toutline-offset: -5px;\n\t\t\t}\n\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active > .tab-close .action-label,\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab.active:hover > .tab-close .action-label,\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab.dirty > .tab-close .action-label,\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover > .tab-close .action-label {\n\t\t\t\topacity: 1 !important;\n\t\t\t}\n\t\t");
        }
        // Hover Background
        var tabHoverBackground = theme.getColor(theme_1.TAB_HOVER_BACKGROUND);
        if (tabHoverBackground) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {\n\t\t\t\tbackground-color: " + tabHoverBackground + " !important;\n\t\t\t}\n\t\t");
        }
        var tabUnfocusedHoverBackground = theme.getColor(theme_1.TAB_UNFOCUSED_HOVER_BACKGROUND);
        if (tabUnfocusedHoverBackground) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {\n\t\t\t\tbackground-color: " + tabUnfocusedHoverBackground + " !important;\n\t\t\t}\n\t\t");
        }
        // Hover Border
        var tabHoverBorder = theme.getColor(theme_1.TAB_HOVER_BORDER);
        if (tabHoverBorder) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container.active > .title .tabs-container > .tab:hover  {\n\t\t\t\tbox-shadow: " + tabHoverBorder + " 0 -1px inset !important;\n\t\t\t}\n\t\t");
        }
        var tabUnfocusedHoverBorder = theme.getColor(theme_1.TAB_UNFOCUSED_HOVER_BORDER);
        if (tabUnfocusedHoverBorder) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container > .title .tabs-container > .tab:hover  {\n\t\t\t\tbox-shadow: " + tabUnfocusedHoverBorder + " 0 -1px inset !important;\n\t\t\t}\n\t\t");
        }
        // Fade out styles via linear gradient (when tabs are set to shrink)
        if (theme.type !== 'hc') {
            var workbenchBackground = theme_1.WORKBENCH_BACKGROUND(theme);
            var editorBackgroundColor = theme.getColor(colorRegistry_1.editorBackground);
            var editorGroupHeaderTabsBackground = theme.getColor(theme_1.EDITOR_GROUP_HEADER_TABS_BACKGROUND);
            var editorDragAndDropBackground = theme.getColor(theme_1.EDITOR_DRAG_AND_DROP_BACKGROUND);
            var adjustedTabBackground = void 0;
            if (editorGroupHeaderTabsBackground && editorBackgroundColor) {
                adjustedTabBackground = editorGroupHeaderTabsBackground.flatten(editorBackgroundColor, editorBackgroundColor, workbenchBackground);
            }
            var adjustedTabDragBackground = void 0;
            if (editorGroupHeaderTabsBackground && editorBackgroundColor && editorDragAndDropBackground && editorBackgroundColor) {
                adjustedTabDragBackground = editorGroupHeaderTabsBackground.flatten(editorBackgroundColor, editorDragAndDropBackground, editorBackgroundColor, workbenchBackground);
            }
            // Adjust gradient for (focused) hover background
            if (tabHoverBackground && adjustedTabBackground && adjustedTabDragBackground) {
                var adjustedColor = tabHoverBackground.flatten(adjustedTabBackground);
                var adjustedColorDrag = tabHoverBackground.flatten(adjustedTabDragBackground);
                collector.addRule("\n\t\t\t\t.monaco-workbench > .part.editor > .content:not(.dragged-over) .editor-group-container.active > .title .tabs-container > .tab.sizing-shrink:not(.dragged):hover > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColor + ", transparent) !important;\n\t\t\t\t}\n\n\n\t\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-shrink:not(.dragged):hover > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColorDrag + ", transparent) !important;\n\t\t\t\t}\n\t\t\t");
            }
            // Adjust gradient for unfocused hover background
            if (tabUnfocusedHoverBackground && adjustedTabBackground && adjustedTabDragBackground) {
                var adjustedColor = tabUnfocusedHoverBackground.flatten(adjustedTabBackground);
                var adjustedColorDrag = tabUnfocusedHoverBackground.flatten(adjustedTabDragBackground);
                collector.addRule("\n\t\t\t\t.monaco-workbench > .part.editor > .content:not(.dragged-over) .editor-group-container > .title .tabs-container > .tab.sizing-shrink:not(.dragged):hover > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColor + ", transparent) !important;\n\t\t\t\t}\n\n\t\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container > .title .tabs-container > .tab.sizing-shrink:not(.dragged):hover > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColorDrag + ", transparent) !important;\n\t\t\t\t}\n\t\t\t");
            }
            // Adjust gradient for drag and drop background
            if (editorDragAndDropBackground && adjustedTabDragBackground) {
                var adjustedColorDrag = editorDragAndDropBackground.flatten(adjustedTabDragBackground);
                collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container.active > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.active):not(.dragged) > .tab-label::after,\n\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container:not(.active) > .title .tabs-container > .tab.sizing-shrink.dragged-over:not(.dragged) > .tab-label::after {\n\t\t\t\tbackground: linear-gradient(to left, " + adjustedColorDrag + ", transparent) !important;\n\t\t\t}\n\t\t");
            }
            // Adjust gradient for active tab background
            var tabActiveBackground = theme.getColor(theme_1.TAB_ACTIVE_BACKGROUND);
            if (tabActiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
                var adjustedColor = tabActiveBackground.flatten(adjustedTabBackground);
                var adjustedColorDrag = tabActiveBackground.flatten(adjustedTabDragBackground);
                collector.addRule("\n\t\t\t\t.monaco-workbench > .part.editor > .content:not(.dragged-over) .editor-group-container > .title .tabs-container > .tab.sizing-shrink.active:not(.dragged) > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColor + ", transparent);\n\t\t\t\t}\n\n\t\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container > .title .tabs-container > .tab.sizing-shrink.active:not(.dragged) > .tab-label::after {\n\t\t\t\t\tbackground: linear-gradient(to left, " + adjustedColorDrag + ", transparent);\n\t\t\t\t}\n\t\t\t");
            }
            // Adjust gradient for inactive tab background
            var tabInactiveBackground = theme.getColor(theme_1.TAB_INACTIVE_BACKGROUND);
            if (tabInactiveBackground && adjustedTabBackground && adjustedTabDragBackground) {
                var adjustedColor = tabInactiveBackground.flatten(adjustedTabBackground);
                var adjustedColorDrag = tabInactiveBackground.flatten(adjustedTabDragBackground);
                collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content:not(.dragged-over) .editor-group-container > .title .tabs-container > .tab.sizing-shrink:not(.dragged) > .tab-label::after {\n\t\t\t\tbackground: linear-gradient(to left, " + adjustedColor + ", transparent);\n\t\t\t}\n\n\t\t\t.monaco-workbench > .part.editor > .content.dragged-over .editor-group-container > .title .tabs-container > .tab.sizing-shrink:not(.dragged) > .tab-label::after {\n\t\t\t\tbackground: linear-gradient(to left, " + adjustedColorDrag + ", transparent);\n\t\t\t}\n\t\t");
            }
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[233/*vs/workbench/browser/parts/quickopen/quickOpenController*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,111/*vs/base/browser/browser*/,22/*vs/base/common/strings*/,35/*vs/base/common/resources*/,29/*vs/base/common/types*/,15/*vs/base/common/actions*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,432/*vs/base/parts/quickopen/browser/quickOpenWidget*/,112/*vs/workbench/browser/actions*/,27/*vs/workbench/services/textfile/common/textfiles*/,9/*vs/platform/registry/common/platform*/,41/*vs/editor/common/services/modeService*/,60/*vs/workbench/browser/labels*/,36/*vs/editor/common/services/modelService*/,13/*vs/workbench/common/editor*/,147/*vs/workbench/common/component*/,6/*vs/base/common/event*/,49/*vs/workbench/services/part/common/partService*/,53/*vs/workbench/browser/quickopen*/,25/*vs/base/common/errors*/,7/*vs/platform/configuration/common/configuration*/,3/*vs/platform/instantiation/common/instantiation*/,10/*vs/platform/contextkey/common/contextkey*/,124/*vs/workbench/services/history/common/history*/,14/*vs/platform/theme/common/themeService*/,58/*vs/workbench/common/theme*/,40/*vs/platform/theme/common/styler*/,43/*vs/platform/environment/common/environment*/,16/*vs/platform/files/common/files*/,132/*vs/base/parts/quickopen/common/quickOpenScorer*/,51/*vs/platform/list/browser/listService*/,26/*vs/base/common/network*/,28/*vs/platform/notification/common/notification*/,8/*vs/base/browser/dom*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,59/*vs/platform/label/common/label*/,17/*vs/base/common/async*/,62/*vs/platform/quickinput/common/quickInput*/,55/*vs/base/common/cancellation*/,246/*vs/css!vs/workbench/browser/parts/quickopen/media/quickopen*/]), function (require, exports, winjs_base_1, nls, browser, strings, resources, types, actions_1, quickOpenModel_1, quickOpenWidget_1, actions_2, textfiles_1, platform_1, modeService_1, labels_1, modelService_1, editor_1, component_1, event_1, partService_1, quickopen_1, errors, configuration_1, instantiation_1, contextkey_1, history_1, themeService_1, theme_1, styler_1, environment_1, files_1, quickOpenScorer_1, listService_1, network_1, notification_1, dom_1, editorService_1, editorGroupsService_1, label_1, async_1, quickInput_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var HELP_PREFIX = '?';
    var QuickOpenController = /** @class */ (function (_super) {
        __extends(QuickOpenController, _super);
        function QuickOpenController(editorGroupService, notificationService, contextKeyService, configurationService, instantiationService, partService, environmentService, themeService) {
            var _this = _super.call(this, QuickOpenController.ID, themeService) || this;
            _this.editorGroupService = editorGroupService;
            _this.notificationService = notificationService;
            _this.contextKeyService = contextKeyService;
            _this.configurationService = configurationService;
            _this.instantiationService = instantiationService;
            _this.partService = partService;
            _this.environmentService = environmentService;
            _this._onShow = _this._register(new event_1.Emitter());
            _this._onHide = _this._register(new event_1.Emitter());
            _this.mapResolvedHandlersToPrefix = Object.create(null);
            _this.mapContextKeyToContext = Object.create(null);
            _this.handlerOnOpenCalled = Object.create(null);
            _this.promisesToCompleteOnHide = [];
            _this.actionProvider = new actions_2.ContributableActionProvider();
            _this.editorHistoryHandler = _this.instantiationService.createInstance(EditorHistoryHandler);
            _this.updateConfiguration();
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(QuickOpenController.prototype, "onShow", {
            get: function () { return this._onShow.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenController.prototype, "onHide", {
            get: function () { return this._onHide.event; },
            enumerable: true,
            configurable: true
        });
        QuickOpenController.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.configurationService.onDidChangeConfiguration(function () { return _this.updateConfiguration(); }));
            this._register(this.partService.onTitleBarVisibilityChange(function () { return _this.positionQuickOpenWidget(); }));
            this._register(browser.onDidChangeZoomLevel(function () { return _this.positionQuickOpenWidget(); }));
        };
        QuickOpenController.prototype.updateConfiguration = function () {
            if (this.environmentService.args['sticky-quickopen']) {
                this.closeOnFocusLost = false;
            }
            else {
                this.closeOnFocusLost = this.configurationService.getValue(quickopen_1.CLOSE_ON_FOCUS_LOST_CONFIG);
            }
            this.prefill = this.configurationService.getValue(quickopen_1.PREFILL_CONFIG);
            this.searchInEditorHistory = this.configurationService.getValue(quickopen_1.SEARCH_EDITOR_HISTORY);
        };
        QuickOpenController.prototype.navigate = function (next, quickNavigate) {
            if (this.quickOpenWidget) {
                this.quickOpenWidget.navigate(next, quickNavigate);
            }
        };
        QuickOpenController.prototype.accept = function () {
            if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {
                this.quickOpenWidget.accept();
            }
        };
        QuickOpenController.prototype.focus = function () {
            if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {
                this.quickOpenWidget.focus();
            }
        };
        QuickOpenController.prototype.close = function () {
            if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {
                this.quickOpenWidget.hide(2 /* CANCELED */);
            }
        };
        QuickOpenController.prototype.emitQuickOpenVisibilityChange = function (isVisible) {
            if (isVisible) {
                this._onShow.fire();
            }
            else {
                this._onHide.fire();
            }
        };
        QuickOpenController.prototype.show = function (prefix, options) {
            var _this = this;
            var quickNavigateConfiguration = options ? options.quickNavigateConfiguration : void 0;
            var inputSelection = options ? options.inputSelection : void 0;
            var autoFocus = options ? options.autoFocus : void 0;
            var promiseCompletedOnHide = new winjs_base_1.TPromise(function (c) {
                _this.promisesToCompleteOnHide.push(c);
            });
            // Telemetry: log that quick open is shown and log the mode
            var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);
            var handlerDescriptor = registry.getQuickOpenHandler(prefix) || registry.getDefaultQuickOpenHandler();
            // Trigger onOpen
            this.resolveHandler(handlerDescriptor);
            // Create upon first open
            if (!this.quickOpenWidget) {
                this.quickOpenWidget = this._register(new quickOpenWidget_1.QuickOpenWidget(this.partService.getWorkbenchElement(), {
                    onOk: function () { return _this.onOk(); },
                    onCancel: function () { },
                    onType: function (value) { return _this.onType(value || ''); },
                    onShow: function () { return _this.handleOnShow(); },
                    onHide: function (reason) { return _this.handleOnHide(reason); },
                    onFocusLost: function () { return !_this.closeOnFocusLost; }
                }, {
                    inputPlaceHolder: this.hasHandler(HELP_PREFIX) ? nls.localize('quickOpenInput', "Type '?' to get help on the actions you can take from here") : '',
                    keyboardSupport: false,
                    treeCreator: function (container, config, opts) { return _this.instantiationService.createInstance(listService_1.WorkbenchTree, container, config, opts); }
                }));
                this._register(styler_1.attachQuickOpenStyler(this.quickOpenWidget, this.themeService, { background: theme_1.SIDE_BAR_BACKGROUND, foreground: theme_1.SIDE_BAR_FOREGROUND }));
                var quickOpenContainer = this.quickOpenWidget.create();
                dom_1.addClass(quickOpenContainer, 'show-file-icons');
                this.positionQuickOpenWidget();
            }
            // Layout
            if (this.dimension) {
                this.quickOpenWidget.layout(this.dimension);
            }
            // Show quick open with prefix or editor history
            if (!this.quickOpenWidget.isVisible() || quickNavigateConfiguration) {
                if (prefix) {
                    this.quickOpenWidget.show(prefix, { quickNavigateConfiguration: quickNavigateConfiguration, inputSelection: inputSelection, autoFocus: autoFocus });
                }
                else {
                    var editorHistory = this.getEditorHistoryWithGroupLabel();
                    if (editorHistory.getEntries().length < 2) {
                        quickNavigateConfiguration = null; // If no entries can be shown, default to normal quick open mode
                    }
                    // Compute auto focus
                    if (!autoFocus) {
                        if (!quickNavigateConfiguration) {
                            autoFocus = { autoFocusFirstEntry: true };
                        }
                        else {
                            var autoFocusFirstEntry = this.editorGroupService.activeGroup.count === 0;
                            autoFocus = { autoFocusFirstEntry: autoFocusFirstEntry, autoFocusSecondEntry: !autoFocusFirstEntry };
                        }
                    }
                    // Update context
                    var registry_1 = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);
                    this.setQuickOpenContextKey(registry_1.getDefaultQuickOpenHandler().contextKey);
                    if (this.prefill) {
                        this.quickOpenWidget.show(editorHistory, { value: this.lastSubmittedInputValue, quickNavigateConfiguration: quickNavigateConfiguration, autoFocus: autoFocus, inputSelection: inputSelection });
                    }
                    else {
                        this.quickOpenWidget.show(editorHistory, { quickNavigateConfiguration: quickNavigateConfiguration, autoFocus: autoFocus, inputSelection: inputSelection });
                    }
                }
            }
            // Otherwise reset the widget to the prefix that is passed in
            else {
                this.quickOpenWidget.show(prefix || '', { inputSelection: inputSelection });
            }
            return promiseCompletedOnHide;
        };
        QuickOpenController.prototype.positionQuickOpenWidget = function () {
            var titlebarOffset = this.partService.getTitleBarOffset();
            if (this.quickOpenWidget) {
                this.quickOpenWidget.getElement().style.top = titlebarOffset + "px";
            }
        };
        QuickOpenController.prototype.handleOnShow = function () {
            this.emitQuickOpenVisibilityChange(true);
        };
        QuickOpenController.prototype.handleOnHide = function (reason) {
            var _this = this;
            // Clear state
            this.previousActiveHandlerDescriptor = null;
            // Cancel pending results calls
            this.cancelPendingGetResultsInvocation();
            var _loop_1 = function (prefix) {
                var promise = this_1.mapResolvedHandlersToPrefix[prefix];
                promise.then(function (handler) {
                    _this.handlerOnOpenCalled[prefix] = false;
                    handler.onClose(reason === 2 /* CANCELED */); // Don't check if onOpen was called to preserve old behaviour for now
                });
            };
            var this_1 = this;
            // Pass to handlers
            for (var prefix in this.mapResolvedHandlersToPrefix) {
                _loop_1(prefix);
            }
            // Complete promises that are waiting
            while (this.promisesToCompleteOnHide.length) {
                this.promisesToCompleteOnHide.pop()(true);
            }
            if (reason !== 1 /* FOCUS_LOST */) {
                this.editorGroupService.activeGroup.focus(); // focus back to editor group unless user clicked somewhere else
            }
            // Reset context keys
            this.resetQuickOpenContextKeys();
            // Events
            this.emitQuickOpenVisibilityChange(false);
        };
        QuickOpenController.prototype.cancelPendingGetResultsInvocation = function () {
            if (this.pendingGetResultsInvocation) {
                this.pendingGetResultsInvocation.cancel();
                this.pendingGetResultsInvocation.dispose();
                this.pendingGetResultsInvocation = null;
            }
        };
        QuickOpenController.prototype.resetQuickOpenContextKeys = function () {
            var _this = this;
            Object.keys(this.mapContextKeyToContext).forEach(function (k) { return _this.mapContextKeyToContext[k].reset(); });
        };
        QuickOpenController.prototype.setQuickOpenContextKey = function (id) {
            var key;
            if (id) {
                key = this.mapContextKeyToContext[id];
                if (!key) {
                    key = new contextkey_1.RawContextKey(id, false).bindTo(this.contextKeyService);
                    this.mapContextKeyToContext[id] = key;
                }
            }
            if (key && key.get()) {
                return; // already active context
            }
            this.resetQuickOpenContextKeys();
            if (key) {
                key.set(true);
            }
        };
        QuickOpenController.prototype.hasHandler = function (prefix) {
            return !!platform_1.Registry.as(quickopen_1.Extensions.Quickopen).getQuickOpenHandler(prefix);
        };
        QuickOpenController.prototype.getEditorHistoryWithGroupLabel = function () {
            var entries = this.editorHistoryHandler.getResults();
            // Apply label to first entry
            if (entries.length > 0) {
                entries[0] = new EditorHistoryEntryGroup(entries[0], nls.localize('historyMatches', "recently opened"), false);
            }
            return new quickOpenModel_1.QuickOpenModel(entries, this.actionProvider);
        };
        QuickOpenController.prototype.onOk = function () {
            if (this.isQuickOpen) {
                this.lastSubmittedInputValue = this.lastInputValue;
            }
        };
        QuickOpenController.prototype.onType = function (value) {
            var _this = this;
            // cancel any pending get results invocation and create new
            this.cancelPendingGetResultsInvocation();
            var pendingResultsInvocationTokenSource = new cancellation_1.CancellationTokenSource();
            var pendingResultsInvocationToken = pendingResultsInvocationTokenSource.token;
            this.pendingGetResultsInvocation = pendingResultsInvocationTokenSource;
            // look for a handler
            var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);
            var handlerDescriptor = registry.getQuickOpenHandler(value);
            var defaultHandlerDescriptor = registry.getDefaultQuickOpenHandler();
            var instantProgress = handlerDescriptor && handlerDescriptor.instantProgress;
            var contextKey = handlerDescriptor ? handlerDescriptor.contextKey : defaultHandlerDescriptor.contextKey;
            // Reset Progress
            if (!instantProgress) {
                this.quickOpenWidget.getProgressBar().stop().hide();
            }
            // Reset Extra Class
            this.quickOpenWidget.setExtraClass(null);
            // Update context
            this.setQuickOpenContextKey(contextKey);
            // Remove leading and trailing whitespace
            var trimmedValue = strings.trim(value);
            // If no value provided, default to editor history
            if (!trimmedValue) {
                // Trigger onOpen
                this.resolveHandler(handlerDescriptor || defaultHandlerDescriptor);
                this.quickOpenWidget.setInput(this.getEditorHistoryWithGroupLabel(), { autoFocusFirstEntry: true });
                // If quickOpen entered empty we have to clear the prefill-cache
                this.lastInputValue = '';
                this.isQuickOpen = true;
                return;
            }
            var resultPromise;
            var resultPromiseDone = false;
            if (handlerDescriptor) {
                this.isQuickOpen = false;
                resultPromise = this.handleSpecificHandler(handlerDescriptor, value, pendingResultsInvocationToken);
            }
            // Otherwise handle default handlers if no specific handler present
            else {
                this.isQuickOpen = true;
                // Cache the value for prefilling the quickOpen next time is opened
                this.lastInputValue = trimmedValue;
                resultPromise = this.handleDefaultHandler(defaultHandlerDescriptor, value, pendingResultsInvocationToken);
            }
            // Remember as the active one
            this.previousActiveHandlerDescriptor = handlerDescriptor;
            // Progress if task takes a long time
            setTimeout(function () {
                if (!resultPromiseDone && !pendingResultsInvocationToken.isCancellationRequested) {
                    _this.quickOpenWidget.getProgressBar().infinite().show();
                }
            }, instantProgress ? 0 : 800);
            // Promise done handling
            resultPromise.then(function () {
                resultPromiseDone = true;
                if (!pendingResultsInvocationToken.isCancellationRequested) {
                    _this.quickOpenWidget.getProgressBar().hide();
                }
                pendingResultsInvocationTokenSource.dispose();
            }, function (error) {
                resultPromiseDone = true;
                pendingResultsInvocationTokenSource.dispose();
                errors.onUnexpectedError(error);
                _this.notificationService.error(types.isString(error) ? new Error(error) : error);
            });
        };
        QuickOpenController.prototype.handleDefaultHandler = function (handler, value, token) {
            var _this = this;
            // Fill in history results if matching and we are configured to search in history
            var matchingHistoryEntries;
            if (value && !this.searchInEditorHistory) {
                matchingHistoryEntries = [];
            }
            else {
                matchingHistoryEntries = this.editorHistoryHandler.getResults(value, token);
            }
            if (matchingHistoryEntries.length > 0) {
                matchingHistoryEntries[0] = new EditorHistoryEntryGroup(matchingHistoryEntries[0], nls.localize('historyMatches', "recently opened"), false);
            }
            // Resolve
            return this.resolveHandler(handler).then(function (resolvedHandler) {
                var quickOpenModel = new quickOpenModel_1.QuickOpenModel(matchingHistoryEntries, _this.actionProvider);
                var inputSet = false;
                // If we have matching entries from history we want to show them directly and not wait for the other results to come in
                // This also applies when we used to have entries from a previous run and now there are no more history results matching
                var previousInput = _this.quickOpenWidget.getInput();
                var wasShowingHistory = previousInput && previousInput.entries && previousInput.entries.some(function (e) { return e instanceof EditorHistoryEntry || e instanceof EditorHistoryEntryGroup; });
                if (wasShowingHistory || matchingHistoryEntries.length > 0) {
                    var responseDelay = void 0;
                    if (resolvedHandler.hasShortResponseTime()) {
                        responseDelay = async_1.timeout(QuickOpenController.MAX_SHORT_RESPONSE_TIME);
                    }
                    else {
                        responseDelay = Promise.resolve(void 0);
                    }
                    responseDelay.then(function () {
                        if (!token.isCancellationRequested && !inputSet) {
                            _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });
                            inputSet = true;
                        }
                    });
                }
                // Get results
                return resolvedHandler.getResults(value, token).then(function (result) {
                    if (!token.isCancellationRequested) {
                        // now is the time to show the input if we did not have set it before
                        if (!inputSet) {
                            _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });
                            inputSet = true;
                        }
                        // merge history and default handler results
                        var handlerResults = (result && result.entries) || [];
                        _this.mergeResults(quickOpenModel, handlerResults, resolvedHandler.getGroupLabel());
                    }
                });
            });
        };
        QuickOpenController.prototype.mergeResults = function (quickOpenModel, handlerResults, groupLabel) {
            // Remove results already showing by checking for a "resource" property
            var mapEntryToResource = this.mapEntriesToResource(quickOpenModel);
            var additionalHandlerResults = [];
            for (var i = 0; i < handlerResults.length; i++) {
                var result = handlerResults[i];
                var resource = result.getResource();
                if (!result.mergeWithEditorHistory() || !resource || !mapEntryToResource[resource.toString()]) {
                    additionalHandlerResults.push(result);
                }
            }
            // Show additional handler results below any existing results
            if (additionalHandlerResults.length > 0) {
                var autoFocusFirstEntry = (quickOpenModel.getEntries().length === 0); // the user might have selected another entry meanwhile in local history (see https://github.com/Microsoft/vscode/issues/20828)
                var useTopBorder = quickOpenModel.getEntries().length > 0;
                additionalHandlerResults[0] = new quickOpenModel_1.QuickOpenEntryGroup(additionalHandlerResults[0], groupLabel, useTopBorder);
                quickOpenModel.addEntries(additionalHandlerResults);
                this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: autoFocusFirstEntry });
            }
            // Otherwise if no results are present (even from histoy) indicate this to the user
            else if (quickOpenModel.getEntries().length === 0) {
                quickOpenModel.addEntries([new PlaceholderQuickOpenEntry(nls.localize('noResultsFound1', "No results found"))]);
                this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: true });
            }
        };
        QuickOpenController.prototype.handleSpecificHandler = function (handlerDescriptor, value, token) {
            var _this = this;
            return this.resolveHandler(handlerDescriptor).then(function (resolvedHandler) {
                // Remove handler prefix from search value
                value = value.substr(handlerDescriptor.prefix.length);
                // Return early if the handler can not run in the current environment and inform the user
                var canRun = resolvedHandler.canRun();
                if (types.isUndefinedOrNull(canRun) || (typeof canRun === 'boolean' && !canRun) || typeof canRun === 'string') {
                    var placeHolderLabel = (typeof canRun === 'string') ? canRun : nls.localize('canNotRunPlaceholder', "This quick open handler can not be used in the current context");
                    var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(placeHolderLabel)], _this.actionProvider);
                    _this.showModel(model, resolvedHandler.getAutoFocus(value, { model: model, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), resolvedHandler.getAriaLabel());
                    return Promise.resolve(null);
                }
                // Support extra class from handler
                var extraClass = resolvedHandler.getClass();
                if (extraClass) {
                    _this.quickOpenWidget.setExtraClass(extraClass);
                }
                // When handlers change, clear the result list first before loading the new results
                if (_this.previousActiveHandlerDescriptor !== handlerDescriptor) {
                    _this.clearModel();
                }
                // Receive Results from Handler and apply
                return resolvedHandler.getResults(value, token).then(function (result) {
                    if (!token.isCancellationRequested) {
                        if (!result || !result.entries.length) {
                            var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(resolvedHandler.getEmptyLabel(value))]);
                            _this.showModel(model, resolvedHandler.getAutoFocus(value, { model: model, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), resolvedHandler.getAriaLabel());
                        }
                        else {
                            _this.showModel(result, resolvedHandler.getAutoFocus(value, { model: result, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), resolvedHandler.getAriaLabel());
                        }
                    }
                });
            });
        };
        QuickOpenController.prototype.showModel = function (model, autoFocus, ariaLabel) {
            // If the given model is already set in the widget, refresh and return early
            if (this.quickOpenWidget.getInput() === model) {
                this.quickOpenWidget.refresh(model, autoFocus);
                return;
            }
            // Otherwise just set it
            this.quickOpenWidget.setInput(model, autoFocus, ariaLabel);
        };
        QuickOpenController.prototype.clearModel = function () {
            this.showModel(new quickOpenModel_1.QuickOpenModel(), null);
        };
        QuickOpenController.prototype.mapEntriesToResource = function (model) {
            var entries = model.getEntries();
            var mapEntryToPath = {};
            entries.forEach(function (entry) {
                if (entry.getResource()) {
                    mapEntryToPath[entry.getResource().toString()] = entry;
                }
            });
            return mapEntryToPath;
        };
        QuickOpenController.prototype.resolveHandler = function (handler) {
            var _this = this;
            var result = this._resolveHandler(handler);
            var id = handler.getId();
            if (!this.handlerOnOpenCalled[id]) {
                var original_1 = result;
                this.handlerOnOpenCalled[id] = true;
                result = this.mapResolvedHandlersToPrefix[id] = original_1.then(function (resolved) {
                    _this.mapResolvedHandlersToPrefix[id] = original_1;
                    resolved.onOpen();
                    return resolved;
                });
            }
            return result.then(null, function (error) {
                delete _this.mapResolvedHandlersToPrefix[id];
                return winjs_base_1.TPromise.wrapError(new Error("Unable to instantiate quick open handler " + handler.getId() + ": " + JSON.stringify(error)));
            });
        };
        QuickOpenController.prototype._resolveHandler = function (handler) {
            var id = handler.getId();
            // Return Cached
            if (this.mapResolvedHandlersToPrefix[id]) {
                return this.mapResolvedHandlersToPrefix[id];
            }
            // Otherwise load and create
            return this.mapResolvedHandlersToPrefix[id] = Promise.resolve(handler.instantiate(this.instantiationService));
        };
        QuickOpenController.prototype.layout = function (dimension) {
            this.dimension = dimension;
            if (this.quickOpenWidget) {
                this.quickOpenWidget.layout(this.dimension);
            }
        };
        QuickOpenController.MAX_SHORT_RESPONSE_TIME = 500;
        QuickOpenController.ID = 'workbench.component.quickopen';
        QuickOpenController = __decorate([
            __param(0, editorGroupsService_1.IEditorGroupsService),
            __param(1, notification_1.INotificationService),
            __param(2, contextkey_1.IContextKeyService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, partService_1.IPartService),
            __param(6, environment_1.IEnvironmentService),
            __param(7, themeService_1.IThemeService)
        ], QuickOpenController);
        return QuickOpenController;
    }(component_1.Component));
    exports.QuickOpenController = QuickOpenController;
    var PlaceholderQuickOpenEntry = /** @class */ (function (_super) {
        __extends(PlaceholderQuickOpenEntry, _super);
        function PlaceholderQuickOpenEntry(placeHolderLabel) {
            var _this = _super.call(this) || this;
            _this.placeHolderLabel = placeHolderLabel;
            return _this;
        }
        PlaceholderQuickOpenEntry.prototype.getLabel = function () {
            return this.placeHolderLabel;
        };
        return PlaceholderQuickOpenEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    var EditorHistoryHandler = /** @class */ (function () {
        function EditorHistoryHandler(historyService, instantiationService, fileService) {
            this.historyService = historyService;
            this.instantiationService = instantiationService;
            this.fileService = fileService;
            this.scorerCache = Object.create(null);
        }
        EditorHistoryHandler.prototype.getResults = function (searchValue, token) {
            var _this = this;
            // Massage search for scoring
            var query = quickOpenScorer_1.prepareQuery(searchValue);
            // Just return all if we are not searching
            var history = this.historyService.getHistory();
            if (!query.value) {
                return history.map(function (input) { return _this.instantiationService.createInstance(EditorHistoryEntry, input); });
            }
            // Otherwise filter by search value and sort by score. Include matches on description
            // in case the user is explicitly including path separators.
            var accessor = query.containsPathSeparator ? MatchOnDescription : DoNotMatchOnDescription;
            return history
                // For now, only support to match on inputs that provide resource information
                .filter(function (input) {
                var resource;
                if (input instanceof editor_1.EditorInput) {
                    resource = resourceForEditorHistory(input, _this.fileService);
                }
                else {
                    resource = input.resource;
                }
                return !!resource;
            })
                // Conver to quick open entries
                .map(function (input) { return _this.instantiationService.createInstance(EditorHistoryEntry, input); })
                // Make sure the search value is matching
                .filter(function (e) {
                var itemScore = quickOpenScorer_1.scoreItem(e, query, false, accessor, _this.scorerCache);
                if (!itemScore.score) {
                    return false;
                }
                e.setHighlights(itemScore.labelMatch, itemScore.descriptionMatch);
                return true;
            })
                // Sort by score and provide a fallback sorter that keeps the
                // recency of items in case the score for items is the same
                .sort(function (e1, e2) { return quickOpenScorer_1.compareItemsByScore(e1, e2, query, false, accessor, _this.scorerCache, function () { return -1; }); });
        };
        EditorHistoryHandler = __decorate([
            __param(0, history_1.IHistoryService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, files_1.IFileService)
        ], EditorHistoryHandler);
        return EditorHistoryHandler;
    }());
    var EditorHistoryItemAccessorClass = /** @class */ (function (_super) {
        __extends(EditorHistoryItemAccessorClass, _super);
        function EditorHistoryItemAccessorClass(allowMatchOnDescription) {
            var _this = _super.call(this) || this;
            _this.allowMatchOnDescription = allowMatchOnDescription;
            return _this;
        }
        EditorHistoryItemAccessorClass.prototype.getItemDescription = function (entry) {
            return this.allowMatchOnDescription ? entry.getDescription() : void 0;
        };
        return EditorHistoryItemAccessorClass;
    }(quickOpenModel_1.QuickOpenItemAccessorClass));
    var MatchOnDescription = new EditorHistoryItemAccessorClass(true);
    var DoNotMatchOnDescription = new EditorHistoryItemAccessorClass(false);
    var EditorHistoryEntryGroup = /** @class */ (function (_super) {
        __extends(EditorHistoryEntryGroup, _super);
        function EditorHistoryEntryGroup() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EditorHistoryEntryGroup;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.EditorHistoryEntryGroup = EditorHistoryEntryGroup;
    var EditorHistoryEntry = /** @class */ (function (_super) {
        __extends(EditorHistoryEntry, _super);
        function EditorHistoryEntry(input, editorService, modeService, modelService, textFileService, configurationService, labelService, fileService) {
            var _this = _super.call(this, editorService) || this;
            _this.modeService = modeService;
            _this.modelService = modelService;
            _this.textFileService = textFileService;
            _this.configurationService = configurationService;
            _this.input = input;
            if (input instanceof editor_1.EditorInput) {
                _this.resource = resourceForEditorHistory(input, fileService);
                _this.label = input.getName();
                _this.description = input.getDescription();
                _this.dirty = input.isDirty();
            }
            else {
                var resourceInput = input;
                _this.resource = resourceInput.resource;
                _this.label = resources.basenameOrAuthority(resourceInput.resource);
                _this.description = labelService.getUriLabel(resources.dirname(_this.resource), { relative: true });
                _this.dirty = _this.resource && _this.textFileService.isDirty(_this.resource);
                if (_this.dirty && _this.textFileService.getAutoSaveMode() === 1 /* AFTER_SHORT_DELAY */) {
                    _this.dirty = false; // no dirty decoration if auto save is on with a short timeout
                }
            }
            return _this;
        }
        EditorHistoryEntry.prototype.getIcon = function () {
            return this.dirty ? 'dirty' : '';
        };
        EditorHistoryEntry.prototype.getLabel = function () {
            return this.label;
        };
        EditorHistoryEntry.prototype.getLabelOptions = function () {
            return {
                extraClasses: labels_1.getIconClasses(this.modelService, this.modeService, this.resource)
            };
        };
        EditorHistoryEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, recently opened", this.getLabel());
        };
        EditorHistoryEntry.prototype.getDescription = function () {
            return this.description;
        };
        EditorHistoryEntry.prototype.getResource = function () {
            return this.resource;
        };
        EditorHistoryEntry.prototype.getInput = function () {
            return this.input;
        };
        EditorHistoryEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                var sideBySide = !context.quickNavigateConfiguration && (context.keymods.alt || context.keymods.ctrlCmd);
                var pinned = !this.configurationService.getValue().workbench.editor.enablePreviewFromQuickOpen || context.keymods.alt;
                if (this.input instanceof editor_1.EditorInput) {
                    this.editorService.openEditor(this.input, { pinned: pinned }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);
                }
                else {
                    this.editorService.openEditor({ resource: this.input.resource, options: { pinned: pinned } }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);
                }
                return true;
            }
            return _super.prototype.run.call(this, mode, context);
        };
        EditorHistoryEntry = __decorate([
            __param(1, editorService_1.IEditorService),
            __param(2, modeService_1.IModeService),
            __param(3, modelService_1.IModelService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, configuration_1.IConfigurationService),
            __param(6, label_1.ILabelService),
            __param(7, files_1.IFileService)
        ], EditorHistoryEntry);
        return EditorHistoryEntry;
    }(quickopen_1.EditorQuickOpenEntry));
    exports.EditorHistoryEntry = EditorHistoryEntry;
    function resourceForEditorHistory(input, fileService) {
        var resource = input ? input.getResource() : void 0;
        // For the editor history we only prefer resources that are either untitled or
        // can be handled by the file service which indicates they are editable resources.
        if (resource && (fileService.canHandleResource(resource) || resource.scheme === network_1.Schemas.untitled)) {
            return resource;
        }
        return void 0;
    }
    var RemoveFromEditorHistoryAction = /** @class */ (function (_super) {
        __extends(RemoveFromEditorHistoryAction, _super);
        function RemoveFromEditorHistoryAction(id, label, quickInputService, modelService, modeService, instantiationService, historyService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickInputService = quickInputService;
            _this.modelService = modelService;
            _this.modeService = modeService;
            _this.instantiationService = instantiationService;
            _this.historyService = historyService;
            return _this;
        }
        RemoveFromEditorHistoryAction.prototype.run = function () {
            var _this = this;
            var history = this.historyService.getHistory();
            var picks = history.map(function (h) {
                var entry = _this.instantiationService.createInstance(EditorHistoryEntry, h);
                return {
                    input: h,
                    iconClasses: labels_1.getIconClasses(_this.modelService, _this.modeService, entry.getResource()),
                    label: entry.getLabel(),
                    description: entry.getDescription()
                };
            });
            return this.quickInputService.pick(picks, { placeHolder: nls.localize('pickHistory', "Select an editor entry to remove from history"), matchOnDescription: true }).then(function (pick) {
                if (pick) {
                    _this.historyService.remove(pick.input);
                }
            });
        };
        RemoveFromEditorHistoryAction.ID = 'workbench.action.removeFromEditorHistory';
        RemoveFromEditorHistoryAction.LABEL = nls.localize('removeFromEditorHistory', "Remove From History");
        RemoveFromEditorHistoryAction = __decorate([
            __param(2, quickInput_1.IQuickInputService),
            __param(3, modelService_1.IModelService),
            __param(4, modeService_1.IModeService),
            __param(5, instantiation_1.IInstantiationService),
            __param(6, history_1.IHistoryService)
        ], RemoveFromEditorHistoryAction);
        return RemoveFromEditorHistoryAction;
    }(actions_1.Action));
    exports.RemoveFromEditorHistoryAction = RemoveFromEditorHistoryAction;
});

define(__m[423/*vs/workbench/browser/parts/quickopen/quickopen.contribution*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,46/*vs/platform/quickOpen/common/quickOpen*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,233/*vs/workbench/browser/parts/quickopen/quickOpenController*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/,62/*vs/platform/quickinput/common/quickInput*/]), function (require, exports, platform_1, quickOpen_1, actions_1, actions_2, keybindingsRegistry_1, quickOpenController_1, quickopen_1, quickInput_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.closeQuickOpen',
        weight: 200 /* WorkbenchContrib */,
        when: quickopen_1.inQuickOpenContext,
        primary: 9 /* Escape */, secondary: [1024 /* Shift */ | 9 /* Escape */],
        handler: function (accessor) {
            var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
            quickOpenService.close();
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            return quickInputService.cancel();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.acceptSelectedQuickOpenItem',
        weight: 200 /* WorkbenchContrib */,
        when: quickopen_1.inQuickOpenContext,
        primary: null,
        handler: function (accessor) {
            var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
            quickOpenService.accept();
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            return quickInputService.accept();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.focusQuickOpen',
        weight: 200 /* WorkbenchContrib */,
        when: quickopen_1.inQuickOpenContext,
        primary: null,
        handler: function (accessor) {
            var quickOpenService = accessor.get(quickOpen_1.IQuickOpenService);
            quickOpenService.focus();
            var quickInputService = accessor.get(quickInput_1.IQuickInputService);
            quickInputService.focus();
        }
    });
    var registry = platform_1.Registry.as(actions_2.Extensions.WorkbenchActions);
    var globalQuickOpenKeybinding = { primary: 2048 /* CtrlCmd */ | 46 /* KEY_P */, secondary: [2048 /* CtrlCmd */ | 35 /* KEY_E */], mac: { primary: 2048 /* CtrlCmd */ | 46 /* KEY_P */, secondary: null } };
    keybindingsRegistry_1.KeybindingsRegistry.registerKeybindingRule({
        id: quickopen_1.QUICKOPEN_ACTION_ID,
        weight: 200 /* WorkbenchContrib */,
        when: undefined,
        primary: globalQuickOpenKeybinding.primary,
        secondary: globalQuickOpenKeybinding.secondary,
        mac: globalQuickOpenKeybinding.mac
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
        command: { id: quickopen_1.QUICKOPEN_ACTION_ID, title: { value: quickopen_1.QUICKOPEN_ACION_LABEL, original: 'Go to File...' } }
    });
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(quickopen_1.QuickOpenSelectNextAction, quickopen_1.QuickOpenSelectNextAction.ID, quickopen_1.QuickOpenSelectNextAction.LABEL, { primary: null, mac: { primary: 256 /* WinCtrl */ | 44 /* KEY_N */ } }, quickopen_1.inQuickOpenContext, 200 /* WorkbenchContrib */ + 50), 'Select Next in Quick Open');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(quickopen_1.QuickOpenSelectPreviousAction, quickopen_1.QuickOpenSelectPreviousAction.ID, quickopen_1.QuickOpenSelectPreviousAction.LABEL, { primary: null, mac: { primary: 256 /* WinCtrl */ | 46 /* KEY_P */ } }, quickopen_1.inQuickOpenContext, 200 /* WorkbenchContrib */ + 50), 'Select Previous in Quick Open');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(quickopen_1.QuickOpenNavigateNextAction, quickopen_1.QuickOpenNavigateNextAction.ID, quickopen_1.QuickOpenNavigateNextAction.LABEL), 'Navigate Next in Quick Open');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(quickopen_1.QuickOpenNavigatePreviousAction, quickopen_1.QuickOpenNavigatePreviousAction.ID, quickopen_1.QuickOpenNavigatePreviousAction.LABEL), 'Navigate Previous in Quick Open');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(quickOpenController_1.RemoveFromEditorHistoryAction, quickOpenController_1.RemoveFromEditorHistoryAction.ID, quickOpenController_1.RemoveFromEditorHistoryAction.LABEL), 'Remove From History');
    var quickOpenNavigateNextInFilePickerId = 'workbench.action.quickOpenNavigateNextInFilePicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigateNextInFilePickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_1.getQuickNavigateHandler(quickOpenNavigateNextInFilePickerId, true),
        when: quickopen_1.defaultQuickOpenContext,
        primary: globalQuickOpenKeybinding.primary,
        secondary: globalQuickOpenKeybinding.secondary,
        mac: globalQuickOpenKeybinding.mac
    });
    var quickOpenNavigatePreviousInFilePickerId = 'workbench.action.quickOpenNavigatePreviousInFilePicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigatePreviousInFilePickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_1.getQuickNavigateHandler(quickOpenNavigatePreviousInFilePickerId, false),
        when: quickopen_1.defaultQuickOpenContext,
        primary: globalQuickOpenKeybinding.primary | 1024 /* Shift */,
        secondary: [globalQuickOpenKeybinding.secondary[0] | 1024 /* Shift */],
        mac: {
            primary: globalQuickOpenKeybinding.mac.primary | 1024 /* Shift */,
            secondary: null
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[424/*vs/workbench/parts/files/common/dirtyFilesTracker*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,57/*vs/workbench/parts/files/common/files*/,27/*vs/workbench/services/textfile/common/textfiles*/,18/*vs/base/common/platform*/,42/*vs/platform/windows/common/windows*/,63/*vs/platform/lifecycle/common/lifecycle*/,4/*vs/base/common/lifecycle*/,159/*vs/workbench/services/activity/common/activity*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,19/*vs/base/common/arrays*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, nls, files_1, textfiles_1, platform_1, windows_1, lifecycle_1, lifecycle_2, activity_1, untitledEditorService_1, arrays, editorService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DirtyFilesTracker = /** @class */ (function (_super) {
        __extends(DirtyFilesTracker, _super);
        function DirtyFilesTracker(textFileService, lifecycleService, editorService, activityService, windowService, untitledEditorService) {
            var _this = _super.call(this) || this;
            _this.textFileService = textFileService;
            _this.lifecycleService = lifecycleService;
            _this.editorService = editorService;
            _this.activityService = activityService;
            _this.windowService = windowService;
            _this.untitledEditorService = untitledEditorService;
            _this.isDocumentedEdited = false;
            _this.registerListeners();
            return _this;
        }
        DirtyFilesTracker.prototype.registerListeners = function () {
            var _this = this;
            // Local text file changes
            this._register(this.untitledEditorService.onDidChangeDirty(function (e) { return _this.onUntitledDidChangeDirty(e); }));
            this._register(this.textFileService.models.onModelsDirty(function (e) { return _this.onTextFilesDirty(e); }));
            this._register(this.textFileService.models.onModelsSaved(function (e) { return _this.onTextFilesSaved(e); }));
            this._register(this.textFileService.models.onModelsSaveError(function (e) { return _this.onTextFilesSaveError(e); }));
            this._register(this.textFileService.models.onModelsReverted(function (e) { return _this.onTextFilesReverted(e); }));
            // Lifecycle
            this.lifecycleService.onShutdown(this.dispose, this);
        };
        DirtyFilesTracker.prototype.onUntitledDidChangeDirty = function (resource) {
            var gotDirty = this.untitledEditorService.isDirty(resource);
            if ((!this.isDocumentedEdited && gotDirty) || (this.isDocumentedEdited && !gotDirty)) {
                this.updateDocumentEdited();
            }
            if (gotDirty || this.lastDirtyCount > 0) {
                this.updateActivityBadge();
            }
        };
        DirtyFilesTracker.prototype.onTextFilesDirty = function (e) {
            var _this = this;
            if ((this.textFileService.getAutoSaveMode() !== 1 /* AFTER_SHORT_DELAY */) && !this.isDocumentedEdited) {
                this.updateDocumentEdited(); // no indication needed when auto save is enabled for short delay
            }
            if (this.textFileService.getAutoSaveMode() !== 1 /* AFTER_SHORT_DELAY */) {
                this.updateActivityBadge(); // no indication needed when auto save is enabled for short delay
            }
            // If files become dirty but are not opened, we open it in the background unless there are pending to be saved
            this.doOpenDirtyResources(arrays.distinct(e.filter(function (e) {
                // Only dirty models that are not PENDING_SAVE
                var model = _this.textFileService.models.get(e.resource);
                var shouldOpen = model && model.isDirty() && !model.hasState(2 /* PENDING_SAVE */);
                // Only if not open already
                return shouldOpen && !_this.editorService.isOpen({ resource: e.resource });
            }).map(function (e) { return e.resource; }), function (r) { return r.toString(); }));
        };
        DirtyFilesTracker.prototype.doOpenDirtyResources = function (resources) {
            var activeEditor = this.editorService.activeControl;
            // Open
            this.editorService.openEditors(resources.map(function (resource) {
                return {
                    resource: resource,
                    options: { inactive: true, pinned: true, preserveFocus: true }
                };
            }), activeEditor ? activeEditor.group : editorService_1.ACTIVE_GROUP);
        };
        DirtyFilesTracker.prototype.onTextFilesSaved = function (e) {
            if (this.isDocumentedEdited) {
                this.updateDocumentEdited();
            }
            if (this.lastDirtyCount > 0) {
                this.updateActivityBadge();
            }
        };
        DirtyFilesTracker.prototype.onTextFilesSaveError = function (e) {
            if (!this.isDocumentedEdited) {
                this.updateDocumentEdited();
            }
            this.updateActivityBadge();
        };
        DirtyFilesTracker.prototype.onTextFilesReverted = function (e) {
            if (this.isDocumentedEdited) {
                this.updateDocumentEdited();
            }
            if (this.lastDirtyCount > 0) {
                this.updateActivityBadge();
            }
        };
        DirtyFilesTracker.prototype.updateActivityBadge = function () {
            var dirtyCount = this.textFileService.getDirty().length;
            this.lastDirtyCount = dirtyCount;
            lifecycle_2.dispose(this.badgeHandle);
            if (dirtyCount > 0) {
                this.badgeHandle = this.activityService.showActivity(files_1.VIEWLET_ID, new activity_1.NumberBadge(dirtyCount, function (num) { return num === 1 ? nls.localize('dirtyFile', "1 unsaved file") : nls.localize('dirtyFiles', "{0} unsaved files", dirtyCount); }), 'explorer-viewlet-label');
            }
        };
        DirtyFilesTracker.prototype.updateDocumentEdited = function () {
            if (platform_1.platform === 1 /* Mac */) {
                var hasDirtyFiles = this.textFileService.isDirty();
                this.isDocumentedEdited = hasDirtyFiles;
                this.windowService.setDocumentEdited(hasDirtyFiles);
            }
        };
        DirtyFilesTracker = __decorate([
            __param(0, textfiles_1.ITextFileService),
            __param(1, lifecycle_1.ILifecycleService),
            __param(2, editorService_1.IEditorService),
            __param(3, activity_1.IActivityService),
            __param(4, windows_1.IWindowService),
            __param(5, untitledEditorService_1.IUntitledEditorService)
        ], DirtyFilesTracker);
        return DirtyFilesTracker;
    }(lifecycle_2.Disposable));
    exports.DirtyFilesTracker = DirtyFilesTracker;
});























define(__m[425/*vs/workbench/parts/search/browser/openFileHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,25/*vs/base/common/errors*/,2/*vs/nls*/,24/*vs/base/common/paths*/,38/*vs/base/common/objects*/,163/*vs/base/common/idGenerator*/,12/*vs/base/common/uri*/,35/*vs/base/common/resources*/,41/*vs/editor/common/services/modeService*/,60/*vs/workbench/browser/labels*/,36/*vs/editor/common/services/modelService*/,222/*vs/workbench/services/themes/common/workbenchThemeService*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,231/*vs/workbench/parts/search/common/queryBuilder*/,7/*vs/platform/configuration/common/configuration*/,3/*vs/platform/instantiation/common/instantiation*/,71/*vs/platform/search/common/search*/,20/*vs/platform/workspace/common/workspace*/,43/*vs/platform/environment/common/environment*/,143/*vs/workbench/parts/search/common/search*/,11/*vs/workbench/services/editor/common/editorService*/,132/*vs/base/parts/quickopen/common/quickOpenScorer*/,16/*vs/platform/files/common/files*/,59/*vs/platform/label/common/label*/,83/*vs/base/common/labels*/]), function (require, exports, winjs_base_1, errors, nls, paths, objects, idGenerator_1, uri_1, resources, modeService_1, labels_1, modelService_1, workbenchThemeService_1, quickOpenModel_1, quickopen_1, queryBuilder_1, configuration_1, instantiation_1, search_1, workspace_1, environment_1, search_2, editorService_1, quickOpenScorer_1, files_1, label_1, labels_2) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileQuickOpenModel = /** @class */ (function (_super) {
        __extends(FileQuickOpenModel, _super);
        function FileQuickOpenModel(entries, stats) {
            return _super.call(this, entries) || this;
        }
        return FileQuickOpenModel;
    }(quickOpenModel_1.QuickOpenModel));
    exports.FileQuickOpenModel = FileQuickOpenModel;
    var FileEntry = /** @class */ (function (_super) {
        __extends(FileEntry, _super);
        function FileEntry(resource, name, description, icon, editorService, modeService, modelService, configurationService, contextService) {
            var _this = _super.call(this, editorService) || this;
            _this.resource = resource;
            _this.name = name;
            _this.description = description;
            _this.icon = icon;
            _this.modeService = modeService;
            _this.modelService = modelService;
            _this.configurationService = configurationService;
            return _this;
        }
        FileEntry.prototype.getLabel = function () {
            return this.name;
        };
        FileEntry.prototype.getLabelOptions = function () {
            return {
                extraClasses: labels_1.getIconClasses(this.modelService, this.modeService, this.resource)
            };
        };
        FileEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, file picker", this.getLabel());
        };
        FileEntry.prototype.getDescription = function () {
            return this.description;
        };
        FileEntry.prototype.getIcon = function () {
            return this.icon;
        };
        FileEntry.prototype.getResource = function () {
            return this.resource;
        };
        FileEntry.prototype.setRange = function (range) {
            this.range = range;
        };
        FileEntry.prototype.mergeWithEditorHistory = function () {
            return true;
        };
        FileEntry.prototype.getInput = function () {
            var input = {
                resource: this.resource,
                options: {
                    pinned: !this.configurationService.getValue().workbench.editor.enablePreviewFromQuickOpen
                }
            };
            if (this.range) {
                input.options.selection = this.range;
            }
            return input;
        };
        FileEntry = __decorate([
            __param(4, editorService_1.IEditorService),
            __param(5, modeService_1.IModeService),
            __param(6, modelService_1.IModelService),
            __param(7, configuration_1.IConfigurationService),
            __param(8, workspace_1.IWorkspaceContextService)
        ], FileEntry);
        return FileEntry;
    }(quickopen_1.EditorQuickOpenEntry));
    exports.FileEntry = FileEntry;
    var OpenFileHandler = /** @class */ (function (_super) {
        __extends(OpenFileHandler, _super);
        function OpenFileHandler(editorService, instantiationService, themeService, contextService, searchService, environmentService, fileService, labelService) {
            var _this = _super.call(this) || this;
            _this.editorService = editorService;
            _this.instantiationService = instantiationService;
            _this.themeService = themeService;
            _this.contextService = contextService;
            _this.searchService = searchService;
            _this.environmentService = environmentService;
            _this.fileService = fileService;
            _this.labelService = labelService;
            _this.queryBuilder = _this.instantiationService.createInstance(queryBuilder_1.QueryBuilder);
            return _this;
        }
        OpenFileHandler.prototype.setOptions = function (options) {
            this.options = options;
        };
        OpenFileHandler.prototype.getResults = function (searchValue, token, maxSortedResults) {
            var query = quickOpenScorer_1.prepareQuery(searchValue);
            // Respond directly to empty search
            if (!query.value) {
                return winjs_base_1.TPromise.as(new FileQuickOpenModel([]));
            }
            // Untildify file pattern
            query.value = labels_2.untildify(query.value, this.environmentService.userHome);
            // Do find results
            return this.doFindResults(query, token, this.cacheState.cacheKey, maxSortedResults);
        };
        OpenFileHandler.prototype.doFindResults = function (query, token, cacheKey, maxSortedResults) {
            var _this = this;
            var queryOptions = this.doResolveQueryOptions(query, cacheKey, maxSortedResults);
            var iconClass;
            if (this.options && this.options.forceUseIcons && !this.themeService.getFileIconTheme()) {
                iconClass = 'file'; // only use a generic file icon if we are forced to use an icon and have no icon theme set otherwise
            }
            return this.getAbsolutePathResult(query).then(function (result) {
                if (token.isCancellationRequested) {
                    return winjs_base_1.TPromise.wrap({ results: [] });
                }
                // If the original search value is an existing file on disk, return it immediately and bypass the search service
                if (result) {
                    return winjs_base_1.TPromise.wrap({ results: [{ resource: result }] });
                }
                return _this.searchService.search(_this.queryBuilder.file(_this.contextService.getWorkspace().folders.map(function (folder) { return folder.uri; }), queryOptions), token);
            }).then(function (complete) {
                var results = [];
                if (!token.isCancellationRequested) {
                    for (var i = 0; i < complete.results.length; i++) {
                        var fileMatch = complete.results[i];
                        var label = paths.basename(fileMatch.resource.fsPath);
                        var description = _this.labelService.getUriLabel(resources.dirname(fileMatch.resource), { relative: true });
                        results.push(_this.instantiationService.createInstance(FileEntry, fileMatch.resource, label, description, iconClass));
                    }
                }
                return new FileQuickOpenModel(results, complete.stats);
            });
        };
        OpenFileHandler.prototype.getAbsolutePathResult = function (query) {
            if (paths.isAbsolute(query.original)) {
                var resource_1 = uri_1.URI.file(query.original);
                return this.fileService.resolveFile(resource_1).then(function (stat) { return stat.isDirectory ? void 0 : resource_1; }, function (error) { return void 0; });
            }
            return winjs_base_1.TPromise.as(null);
        };
        OpenFileHandler.prototype.doResolveQueryOptions = function (query, cacheKey, maxSortedResults) {
            var queryOptions = {
                extraFileResources: search_2.getOutOfWorkspaceEditorResources(this.editorService, this.contextService),
                filePattern: query.value,
                cacheKey: cacheKey
            };
            if (typeof maxSortedResults === 'number') {
                queryOptions.maxResults = maxSortedResults;
                queryOptions.sortByScore = true;
            }
            return queryOptions;
        };
        OpenFileHandler.prototype.hasShortResponseTime = function () {
            return this.isCacheLoaded;
        };
        OpenFileHandler.prototype.onOpen = function () {
            var _this = this;
            this.cacheState = new CacheState(function (cacheKey) { return _this.cacheQuery(cacheKey); }, function (query) { return _this.searchService.search(query); }, function (cacheKey) { return _this.searchService.clearCache(cacheKey); }, this.cacheState);
            this.cacheState.load();
        };
        OpenFileHandler.prototype.cacheQuery = function (cacheKey) {
            var options = {
                extraFileResources: search_2.getOutOfWorkspaceEditorResources(this.editorService, this.contextService),
                filePattern: '',
                cacheKey: cacheKey,
                maxResults: 0,
                sortByScore: true,
            };
            var folderResources = this.contextService.getWorkspace().folders.map(function (folder) { return folder.uri; });
            var query = this.queryBuilder.file(folderResources, options);
            return query;
        };
        Object.defineProperty(OpenFileHandler.prototype, "isCacheLoaded", {
            get: function () {
                return this.cacheState && this.cacheState.isLoaded;
            },
            enumerable: true,
            configurable: true
        });
        OpenFileHandler.prototype.getGroupLabel = function () {
            return nls.localize('searchResults', "search results");
        };
        OpenFileHandler.prototype.getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: true
            };
        };
        OpenFileHandler = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, workbenchThemeService_1.IWorkbenchThemeService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, search_1.ISearchService),
            __param(5, environment_1.IEnvironmentService),
            __param(6, files_1.IFileService),
            __param(7, label_1.ILabelService)
        ], OpenFileHandler);
        return OpenFileHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.OpenFileHandler = OpenFileHandler;
    var LoadingPhase;
    (function (LoadingPhase) {
        LoadingPhase[LoadingPhase["Created"] = 1] = "Created";
        LoadingPhase[LoadingPhase["Loading"] = 2] = "Loading";
        LoadingPhase[LoadingPhase["Loaded"] = 3] = "Loaded";
        LoadingPhase[LoadingPhase["Errored"] = 4] = "Errored";
        LoadingPhase[LoadingPhase["Disposed"] = 5] = "Disposed";
    })(LoadingPhase || (LoadingPhase = {}));
    /**
     * Exported for testing.
     */
    var CacheState = /** @class */ (function () {
        function CacheState(cacheQuery, doLoad, doDispose, previous) {
            this.doLoad = doLoad;
            this.doDispose = doDispose;
            this.previous = previous;
            this._cacheKey = idGenerator_1.defaultGenerator.nextId();
            this.loadingPhase = LoadingPhase.Created;
            this.query = cacheQuery(this._cacheKey);
            if (this.previous) {
                var current = objects.assign({}, this.query, { cacheKey: null });
                var previous_1 = objects.assign({}, this.previous.query, { cacheKey: null });
                if (!objects.equals(current, previous_1)) {
                    this.previous.dispose();
                    this.previous = null;
                }
            }
        }
        Object.defineProperty(CacheState.prototype, "cacheKey", {
            get: function () {
                return this.loadingPhase === LoadingPhase.Loaded || !this.previous ? this._cacheKey : this.previous.cacheKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CacheState.prototype, "isLoaded", {
            get: function () {
                var isLoaded = this.loadingPhase === LoadingPhase.Loaded;
                return isLoaded || !this.previous ? isLoaded : this.previous.isLoaded;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CacheState.prototype, "isUpdating", {
            get: function () {
                var isUpdating = this.loadingPhase === LoadingPhase.Loading;
                return isUpdating || !this.previous ? isUpdating : this.previous.isUpdating;
            },
            enumerable: true,
            configurable: true
        });
        CacheState.prototype.load = function () {
            var _this = this;
            if (this.isUpdating) {
                return;
            }
            this.loadingPhase = LoadingPhase.Loading;
            this.promise = this.doLoad(this.query)
                .then(function () {
                _this.loadingPhase = LoadingPhase.Loaded;
                if (_this.previous) {
                    _this.previous.dispose();
                    _this.previous = null;
                }
            }, function (err) {
                _this.loadingPhase = LoadingPhase.Errored;
                errors.onUnexpectedError(err);
            });
        };
        CacheState.prototype.dispose = function () {
            var _this = this;
            if (this.promise) {
                this.promise.then(null, function () { })
                    .then(function () {
                    _this.loadingPhase = LoadingPhase.Disposed;
                    return _this.doDispose(_this._cacheKey);
                }).then(null, function (err) {
                    errors.onUnexpectedError(err);
                });
            }
            else {
                this.loadingPhase = LoadingPhase.Disposed;
            }
            if (this.previous) {
                this.previous.dispose();
                this.previous = null;
            }
        };
        return CacheState;
    }());
    exports.CacheState = CacheState;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[426/*vs/workbench/parts/search/browser/openAnythingHandler*/], __M([0/*require*/,1/*exports*/,19/*vs/base/common/arrays*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,17/*vs/base/common/async*/,29/*vs/base/common/types*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,425/*vs/workbench/parts/search/browser/openFileHandler*/,179/*vs/workbench/parts/search/browser/openSymbolHandler*/,3/*vs/platform/instantiation/common/instantiation*/,7/*vs/platform/configuration/common/configuration*/,132/*vs/base/parts/quickopen/common/quickOpenScorer*/,28/*vs/platform/notification/common/notification*/,25/*vs/base/common/errors*/]), function (require, exports, arrays, winjs_base_1, nls, async_1, types, quickOpenModel_1, quickopen_1, openFileHandler_1, openSymbolHandler, instantiation_1, configuration_1, quickOpenScorer_1, notification_1, errors_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenSymbolHandler = openSymbolHandler.OpenSymbolHandler; // OpenSymbolHandler is used from an extension and must be in the main bundle file so it can load
    var OpenAnythingHandler = /** @class */ (function (_super) {
        __extends(OpenAnythingHandler, _super);
        function OpenAnythingHandler(notificationService, instantiationService, configurationService) {
            var _this = _super.call(this) || this;
            _this.notificationService = notificationService;
            _this.configurationService = configurationService;
            _this.scorerCache = Object.create(null);
            _this.searchDelayer = new async_1.ThrottledDelayer(OpenAnythingHandler.TYPING_SEARCH_DELAY);
            _this.openSymbolHandler = instantiationService.createInstance(exports.OpenSymbolHandler);
            _this.openFileHandler = instantiationService.createInstance(openFileHandler_1.OpenFileHandler);
            _this.updateHandlers(_this.configurationService.getValue());
            _this.registerListeners();
            return _this;
        }
        OpenAnythingHandler.prototype.registerListeners = function () {
            var _this = this;
            this.configurationService.onDidChangeConfiguration(function (e) { return _this.updateHandlers(_this.configurationService.getValue()); });
        };
        OpenAnythingHandler.prototype.updateHandlers = function (configuration) {
            this.includeSymbols = configuration && configuration.search && configuration.search.quickOpen && configuration.search.quickOpen.includeSymbols;
            // Files
            this.openFileHandler.setOptions({
                forceUseIcons: this.includeSymbols // only need icons for file results if we mix with symbol results
            });
            // Symbols
            this.openSymbolHandler.setOptions({
                skipDelay: true,
                skipLocalSymbols: true,
                skipSorting: true // we sort combined with file results
            });
        };
        OpenAnythingHandler.prototype.getResults = function (searchValue, token) {
            var _this = this;
            this.isClosed = false; // Treat this call as the handler being in use
            // Find a suitable range from the pattern looking for ":" and "#"
            var searchWithRange = this.extractRange(searchValue);
            if (searchWithRange) {
                searchValue = searchWithRange.search; // ignore range portion in query
            }
            // Prepare search for scoring
            var query = quickOpenScorer_1.prepareQuery(searchValue);
            if (!query.value) {
                return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel()); // Respond directly to empty search
            }
            // The throttler needs a factory for its promises
            var resultsPromise = function () {
                var resultPromises = [];
                // File Results
                var filePromise = _this.openFileHandler.getResults(query.original, token, OpenAnythingHandler.MAX_DISPLAYED_RESULTS);
                resultPromises.push(filePromise);
                // Symbol Results (unless disabled or a range or absolute path is specified)
                if (_this.includeSymbols && !searchWithRange) {
                    resultPromises.push(_this.openSymbolHandler.getResults(query.original, token));
                }
                // Join and sort unified
                return winjs_base_1.TPromise.join(resultPromises).then(function (results) {
                    // If the quick open widget has been closed meanwhile, ignore the result
                    if (_this.isClosed || token.isCancellationRequested) {
                        return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel());
                    }
                    // Combine results.
                    var mergedResults = [].concat.apply([], results.map(function (r) { return r.entries; }));
                    // Sort
                    var compare = function (elementA, elementB) { return quickOpenScorer_1.compareItemsByScore(elementA, elementB, query, true, quickOpenModel_1.QuickOpenItemAccessor, _this.scorerCache); };
                    var viewResults = arrays.top(mergedResults, compare, OpenAnythingHandler.MAX_DISPLAYED_RESULTS);
                    // Apply range and highlights to file entries
                    viewResults.forEach(function (entry) {
                        if (entry instanceof openFileHandler_1.FileEntry) {
                            entry.setRange(searchWithRange ? searchWithRange.range : null);
                            var itemScore = quickOpenScorer_1.scoreItem(entry, query, true, quickOpenModel_1.QuickOpenItemAccessor, _this.scorerCache);
                            entry.setHighlights(itemScore.labelMatch, itemScore.descriptionMatch);
                        }
                    });
                    return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel(viewResults));
                }, function (error) {
                    if (!errors_1.isPromiseCanceledError(error)) {
                        if (error && error[0] && error[0].message) {
                            _this.notificationService.error(error[0].message.replace(/[\*_\[\]]/g, '\\$&'));
                        }
                        else {
                            _this.notificationService.error(error);
                        }
                    }
                    return null;
                });
            };
            // Trigger through delayer to prevent accumulation while the user is typing (except when expecting results to come from cache)
            return this.hasShortResponseTime() ? resultsPromise() : this.searchDelayer.trigger(resultsPromise, OpenAnythingHandler.TYPING_SEARCH_DELAY);
        };
        OpenAnythingHandler.prototype.hasShortResponseTime = function () {
            if (!this.includeSymbols) {
                return this.openFileHandler.hasShortResponseTime();
            }
            return this.openFileHandler.hasShortResponseTime() && this.openSymbolHandler.hasShortResponseTime();
        };
        OpenAnythingHandler.prototype.extractRange = function (value) {
            if (!value) {
                return null;
            }
            var range = null;
            // Find Line/Column number from search value using RegExp
            var patternMatch = OpenAnythingHandler.LINE_COLON_PATTERN.exec(value);
            if (patternMatch && patternMatch.length > 1) {
                var startLineNumber = parseInt(patternMatch[1], 10);
                // Line Number
                if (types.isNumber(startLineNumber)) {
                    range = {
                        startLineNumber: startLineNumber,
                        startColumn: 1,
                        endLineNumber: startLineNumber,
                        endColumn: 1
                    };
                    // Column Number
                    if (patternMatch.length > 3) {
                        var startColumn = parseInt(patternMatch[3], 10);
                        if (types.isNumber(startColumn)) {
                            range = {
                                startLineNumber: range.startLineNumber,
                                startColumn: startColumn,
                                endLineNumber: range.endLineNumber,
                                endColumn: startColumn
                            };
                        }
                    }
                }
                // User has typed "something:" or "something#" without a line number, in this case treat as start of file
                else if (patternMatch[1] === '') {
                    range = {
                        startLineNumber: 1,
                        startColumn: 1,
                        endLineNumber: 1,
                        endColumn: 1
                    };
                }
            }
            if (range) {
                return {
                    search: value.substr(0, patternMatch.index),
                    range: range
                };
            }
            return null;
        };
        OpenAnythingHandler.prototype.getGroupLabel = function () {
            return this.includeSymbols ? nls.localize('fileAndTypeResults', "file and symbol results") : nls.localize('fileResults', "file results");
        };
        OpenAnythingHandler.prototype.getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: true
            };
        };
        OpenAnythingHandler.prototype.onOpen = function () {
            this.openSymbolHandler.onOpen();
            this.openFileHandler.onOpen();
        };
        OpenAnythingHandler.prototype.onClose = function (canceled) {
            this.isClosed = true;
            // Clear Cache
            this.scorerCache = Object.create(null);
            // Propagate
            this.openSymbolHandler.onClose(canceled);
            this.openFileHandler.onClose(canceled);
        };
        OpenAnythingHandler.ID = 'workbench.picker.anything';
        OpenAnythingHandler.LINE_COLON_PATTERN = /[#|:|\(](\d*)([#|:|,](\d*))?\)?$/;
        OpenAnythingHandler.TYPING_SEARCH_DELAY = 200; // This delay accommodates for the user typing a word and then stops typing to start searching
        OpenAnythingHandler.MAX_DISPLAYED_RESULTS = 512;
        OpenAnythingHandler = __decorate([
            __param(0, notification_1.INotificationService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, configuration_1.IConfigurationService)
        ], OpenAnythingHandler);
        return OpenAnythingHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.OpenAnythingHandler = OpenAnythingHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[235/*vs/workbench/services/editor/browser/editorService*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/,13/*vs/workbench/common/editor*/,93/*vs/workbench/common/editor/resourceEditorInput*/,185/*vs/workbench/common/editor/dataUriEditorInput*/,9/*vs/platform/registry/common/platform*/,39/*vs/base/common/map*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,16/*vs/platform/files/common/files*/,26/*vs/base/common/network*/,6/*vs/base/common/event*/,12/*vs/base/common/uri*/,24/*vs/base/common/paths*/,110/*vs/workbench/common/editor/diffEditorInput*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,7/*vs/platform/configuration/common/configuration*/,4/*vs/base/common/lifecycle*/,19/*vs/base/common/arrays*/,45/*vs/editor/browser/editorBrowser*/,59/*vs/platform/label/common/label*/]), function (require, exports, instantiation_1, editor_1, resourceEditorInput_1, dataUriEditorInput_1, platform_1, map_1, untitledEditorService_1, files_1, network_1, event_1, uri_1, paths_1, diffEditorInput_1, nls_1, winjs_base_1, editorGroupsService_1, editorService_1, configuration_1, lifecycle_1, arrays_1, editorBrowser_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditorService = /** @class */ (function (_super) {
        __extends(EditorService, _super);
        function EditorService(editorGroupService, untitledEditorService, instantiationService, labelService, fileService, configurationService) {
            var _this = _super.call(this) || this;
            _this.editorGroupService = editorGroupService;
            _this.untitledEditorService = untitledEditorService;
            _this.instantiationService = instantiationService;
            _this.labelService = labelService;
            _this.fileService = fileService;
            _this.configurationService = configurationService;
            //#region events
            _this._onDidActiveEditorChange = _this._register(new event_1.Emitter());
            _this._onDidVisibleEditorsChange = _this._register(new event_1.Emitter());
            _this._onDidCloseEditor = _this._register(new event_1.Emitter());
            _this._onDidOpenEditorFail = _this._register(new event_1.Emitter());
            _this.openEditorHandlers = [];
            _this.fileInputFactory = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).getFileInputFactory();
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(EditorService.prototype, "onDidActiveEditorChange", {
            get: function () { return this._onDidActiveEditorChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "onDidVisibleEditorsChange", {
            get: function () { return this._onDidVisibleEditorsChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "onDidCloseEditor", {
            get: function () { return this._onDidCloseEditor.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "onDidOpenEditorFail", {
            get: function () { return this._onDidOpenEditorFail.event; },
            enumerable: true,
            configurable: true
        });
        EditorService.prototype.registerListeners = function () {
            var _this = this;
            this.editorGroupService.whenRestored.then(function () { return _this.onEditorsRestored(); });
            this.editorGroupService.onDidActiveGroupChange(function (group) { return _this.handleActiveEditorChange(group); });
            this.editorGroupService.onDidAddGroup(function (group) { return _this.registerGroupListeners(group); });
        };
        EditorService.prototype.onEditorsRestored = function () {
            var _this = this;
            // Register listeners to each opened group
            this.editorGroupService.groups.forEach(function (group) { return _this.registerGroupListeners(group); });
            // Fire initial set of editor events if there is an active editor
            if (this.activeEditor) {
                this.doEmitActiveEditorChangeEvent();
                this._onDidVisibleEditorsChange.fire();
            }
        };
        EditorService.prototype.handleActiveEditorChange = function (group) {
            if (group !== this.editorGroupService.activeGroup) {
                return; // ignore if not the active group
            }
            if (!this.lastActiveEditor && !group.activeEditor) {
                return; // ignore if we still have no active editor
            }
            if (this.lastActiveGroupId === group.id && this.lastActiveEditor === group.activeEditor) {
                return; // ignore if the editor actually did not change
            }
            this.doEmitActiveEditorChangeEvent();
        };
        EditorService.prototype.doEmitActiveEditorChangeEvent = function () {
            var activeGroup = this.editorGroupService.activeGroup;
            this.lastActiveGroupId = activeGroup.id;
            this.lastActiveEditor = activeGroup.activeEditor;
            this._onDidActiveEditorChange.fire();
        };
        EditorService.prototype.registerGroupListeners = function (group) {
            var _this = this;
            var groupDisposeables = [];
            groupDisposeables.push(group.onDidGroupChange(function (e) {
                if (e.kind === 5 /* EDITOR_ACTIVE */) {
                    _this.handleActiveEditorChange(group);
                    _this._onDidVisibleEditorsChange.fire();
                }
            }));
            groupDisposeables.push(group.onDidCloseEditor(function (event) {
                _this._onDidCloseEditor.fire(event);
            }));
            groupDisposeables.push(group.onWillOpenEditor(function (event) {
                _this.onGroupWillOpenEditor(group, event);
            }));
            groupDisposeables.push(group.onDidOpenEditorFail(function (editor) {
                _this._onDidOpenEditorFail.fire({ editor: editor, groupId: group.id });
            }));
            event_1.once(group.onWillDispose)(function () {
                lifecycle_1.dispose(groupDisposeables);
            });
        };
        EditorService.prototype.onGroupWillOpenEditor = function (group, event) {
            var _loop_1 = function (i) {
                var handler = this_1.openEditorHandlers[i];
                var result = handler(event.editor, event.options, group);
                if (result && result.override) {
                    event.prevent((function () { return result.override; }));
                    return "break";
                }
            };
            var this_1 = this;
            for (var i = 0; i < this.openEditorHandlers.length; i++) {
                var state_1 = _loop_1(i);
                if (state_1 === "break")
                    break;
            }
        };
        Object.defineProperty(EditorService.prototype, "activeControl", {
            get: function () {
                var activeGroup = this.editorGroupService.activeGroup;
                return activeGroup ? activeGroup.activeControl : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "activeTextEditorWidget", {
            get: function () {
                var activeControl = this.activeControl;
                if (activeControl) {
                    var activeControlWidget = activeControl.getControl();
                    if (editorBrowser_1.isCodeEditor(activeControlWidget) || editorBrowser_1.isDiffEditor(activeControlWidget)) {
                        return activeControlWidget;
                    }
                }
                return void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "editors", {
            get: function () {
                var editors = [];
                this.editorGroupService.groups.forEach(function (group) {
                    editors.push.apply(editors, group.editors);
                });
                return editors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "activeEditor", {
            get: function () {
                var activeGroup = this.editorGroupService.activeGroup;
                return activeGroup ? activeGroup.activeEditor : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "visibleControls", {
            get: function () {
                return arrays_1.coalesce(this.editorGroupService.groups.map(function (group) { return group.activeControl; }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "visibleTextEditorWidgets", {
            get: function () {
                return this.visibleControls.map(function (control) { return control.getControl(); }).filter(function (widget) { return editorBrowser_1.isCodeEditor(widget) || editorBrowser_1.isDiffEditor(widget); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorService.prototype, "visibleEditors", {
            get: function () {
                return arrays_1.coalesce(this.editorGroupService.groups.map(function (group) { return group.activeEditor; }));
            },
            enumerable: true,
            configurable: true
        });
        //#region preventOpenEditor()
        EditorService.prototype.overrideOpenEditor = function (handler) {
            var _this = this;
            this.openEditorHandlers.push(handler);
            return lifecycle_1.toDisposable(function () {
                var index = _this.openEditorHandlers.indexOf(handler);
                if (index >= 0) {
                    _this.openEditorHandlers.splice(index, 1);
                }
            });
        };
        EditorService.prototype.openEditor = function (editor, optionsOrGroup, group) {
            // Typed Editor Support
            if (editor instanceof editor_1.EditorInput) {
                var editorOptions = this.toOptions(optionsOrGroup);
                var targetGroup = this.findTargetGroup(editor, editorOptions, group);
                return this.doOpenEditor(targetGroup, editor, editorOptions);
            }
            // Untyped Text Editor Support
            var textInput = editor;
            var typedInput = this.createInput(textInput);
            if (typedInput) {
                var editorOptions = editor_1.TextEditorOptions.from(textInput);
                var targetGroup = this.findTargetGroup(typedInput, editorOptions, optionsOrGroup);
                return this.doOpenEditor(targetGroup, typedInput, editorOptions);
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        EditorService.prototype.doOpenEditor = function (group, editor, options) {
            return group.openEditor(editor, options).then(function () { return group.activeControl; });
        };
        EditorService.prototype.findTargetGroup = function (input, options, group) {
            var targetGroup;
            // Group: Instance of Group
            if (group && typeof group !== 'number') {
                return group;
            }
            // Group: Side by Side
            if (group === editorService_1.SIDE_GROUP) {
                targetGroup = this.findSideBySideGroup();
            }
            // Group: Specific Group
            else if (typeof group === 'number' && group >= 0) {
                targetGroup = this.editorGroupService.getGroup(group);
            }
            // Group: Unspecified without a specific index to open
            else if (!options || typeof options.index !== 'number') {
                var groupsByLastActive = this.editorGroupService.getGroups(1 /* MOST_RECENTLY_ACTIVE */);
                // Respect option to reveal an editor if it is already visible in any group
                if (options && options.revealIfVisible) {
                    for (var i = 0; i < groupsByLastActive.length; i++) {
                        var group_1 = groupsByLastActive[i];
                        if (input.matches(group_1.activeEditor)) {
                            targetGroup = group_1;
                            break;
                        }
                    }
                }
                // Respect option to reveal an editor if it is open (not necessarily visible)
                if ((options && options.revealIfOpened) || this.configurationService.getValue('workbench.editor.revealIfOpen')) {
                    for (var i = 0; i < groupsByLastActive.length; i++) {
                        var group_2 = groupsByLastActive[i];
                        if (group_2.isOpened(input)) {
                            targetGroup = group_2;
                            break;
                        }
                    }
                }
            }
            // Fallback to active group if target not valid
            if (!targetGroup) {
                targetGroup = this.editorGroupService.activeGroup;
            }
            return targetGroup;
        };
        EditorService.prototype.findSideBySideGroup = function () {
            var direction = editorGroupsService_1.preferredSideBySideGroupDirection(this.configurationService);
            var neighbourGroup = this.editorGroupService.findGroup({ direction: direction });
            if (!neighbourGroup) {
                neighbourGroup = this.editorGroupService.addGroup(this.editorGroupService.activeGroup, direction);
            }
            return neighbourGroup;
        };
        EditorService.prototype.toOptions = function (options) {
            if (!options || options instanceof editor_1.EditorOptions) {
                return options;
            }
            var textOptions = options;
            if (!!textOptions.selection) {
                return editor_1.TextEditorOptions.create(options);
            }
            return editor_1.EditorOptions.create(options);
        };
        EditorService.prototype.openEditors = function (editors, group) {
            var _this = this;
            // Convert to typed editors and options
            var typedEditors = [];
            editors.forEach(function (editor) {
                if (editor_1.isEditorInputWithOptions(editor)) {
                    typedEditors.push(editor);
                }
                else {
                    typedEditors.push({ editor: _this.createInput(editor), options: editor_1.TextEditorOptions.from(editor) });
                }
            });
            // Find target groups to open
            var mapGroupToEditors = new Map();
            if (group === editorService_1.SIDE_GROUP) {
                mapGroupToEditors.set(this.findSideBySideGroup(), typedEditors);
            }
            else {
                typedEditors.forEach(function (typedEditor) {
                    var targetGroup = _this.findTargetGroup(typedEditor.editor, typedEditor.options, group);
                    var targetGroupEditors = mapGroupToEditors.get(targetGroup);
                    if (!targetGroupEditors) {
                        targetGroupEditors = [];
                        mapGroupToEditors.set(targetGroup, targetGroupEditors);
                    }
                    targetGroupEditors.push(typedEditor);
                });
            }
            // Open in targets
            var result = [];
            mapGroupToEditors.forEach(function (editorsWithOptions, group) {
                result.push((group.openEditors(editorsWithOptions)).then(function () { return group.activeControl; }));
            });
            return winjs_base_1.TPromise.join(result);
        };
        //#endregion
        //#region isOpen()
        EditorService.prototype.isOpen = function (editor, group) {
            return !!this.doGetOpened(editor);
        };
        //#endregion
        //#region getOpend()
        EditorService.prototype.getOpened = function (editor, group) {
            return this.doGetOpened(editor);
        };
        EditorService.prototype.doGetOpened = function (editor, group) {
            if (!(editor instanceof editor_1.EditorInput)) {
                var resourceInput = editor;
                if (!resourceInput.resource) {
                    return void 0; // we need a resource at least
                }
            }
            var groups = [];
            if (typeof group === 'number') {
                groups.push(this.editorGroupService.getGroup(group));
            }
            else if (group) {
                groups.push(group);
            }
            else {
                groups = this.editorGroupService.groups.slice();
            }
            // For each editor group
            for (var i = 0; i < groups.length; i++) {
                var group_3 = groups[i];
                // Typed editor
                if (editor instanceof editor_1.EditorInput) {
                    if (group_3.isOpened(editor)) {
                        return editor;
                    }
                }
                // Resource editor
                else {
                    for (var j = 0; j < group_3.editors.length; j++) {
                        var editorInGroup = group_3.editors[j];
                        var resource = editor_1.toResource(editorInGroup, { supportSideBySide: true });
                        if (!resource) {
                            continue; // need a resource to compare with
                        }
                        var resourceInput = editor;
                        if (resource.toString() === resourceInput.resource.toString()) {
                            return editorInGroup;
                        }
                    }
                }
            }
            return void 0;
        };
        EditorService.prototype.replaceEditors = function (editors, group) {
            var _this = this;
            var typedEditors = [];
            editors.forEach(function (replaceEditorArg) {
                if (replaceEditorArg.editor instanceof editor_1.EditorInput) {
                    typedEditors.push(replaceEditorArg);
                }
                else {
                    var editor = replaceEditorArg.editor;
                    var typedEditor = _this.createInput(editor);
                    var replacementEditor = _this.createInput(replaceEditorArg.replacement);
                    typedEditors.push({
                        editor: typedEditor,
                        replacement: replacementEditor,
                        options: _this.toOptions(editor.options)
                    });
                }
            });
            var targetGroup = typeof group === 'number' ? this.editorGroupService.getGroup(group) : group;
            return targetGroup.replaceEditors(typedEditors);
        };
        //#endregion
        //#region invokeWithinEditorContext()
        EditorService.prototype.invokeWithinEditorContext = function (fn) {
            var activeTextEditorWidget = this.activeTextEditorWidget;
            if (editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {
                return activeTextEditorWidget.invokeWithinContext(fn);
            }
            var activeGroup = this.editorGroupService.activeGroup;
            if (activeGroup) {
                return activeGroup.invokeWithinContext(fn);
            }
            return this.instantiationService.invokeFunction(fn);
        };
        //#endregion
        //#region createInput()
        EditorService.prototype.createInput = function (input) {
            // Typed Editor Input Support (EditorInput)
            if (input instanceof editor_1.EditorInput) {
                return input;
            }
            // Typed Editor Input Support (IEditorInputWithOptions)
            var editorInputWithOptions = input;
            if (editorInputWithOptions.editor instanceof editor_1.EditorInput) {
                return editorInputWithOptions.editor;
            }
            // Side by Side Support
            var resourceSideBySideInput = input;
            if (resourceSideBySideInput.masterResource && resourceSideBySideInput.detailResource) {
                var masterInput = this.createInput({ resource: resourceSideBySideInput.masterResource, forceFile: resourceSideBySideInput.forceFile });
                var detailInput = this.createInput({ resource: resourceSideBySideInput.detailResource, forceFile: resourceSideBySideInput.forceFile });
                return new editor_1.SideBySideEditorInput(resourceSideBySideInput.label || masterInput.getName(), typeof resourceSideBySideInput.description === 'string' ? resourceSideBySideInput.description : masterInput.getDescription(), detailInput, masterInput);
            }
            // Diff Editor Support
            var resourceDiffInput = input;
            if (resourceDiffInput.leftResource && resourceDiffInput.rightResource) {
                var leftInput = this.createInput({ resource: resourceDiffInput.leftResource, forceFile: resourceDiffInput.forceFile });
                var rightInput = this.createInput({ resource: resourceDiffInput.rightResource, forceFile: resourceDiffInput.forceFile });
                var label = resourceDiffInput.label || nls_1.localize('compareLabels', "{0}  {1}", this.toDiffLabel(leftInput), this.toDiffLabel(rightInput));
                return new diffEditorInput_1.DiffEditorInput(label, resourceDiffInput.description, leftInput, rightInput);
            }
            // Untitled file support
            var untitledInput = input;
            if (!untitledInput.resource || typeof untitledInput.filePath === 'string' || (untitledInput.resource instanceof uri_1.URI && untitledInput.resource.scheme === network_1.Schemas.untitled)) {
                return this.untitledEditorService.createOrGet(untitledInput.filePath ? uri_1.URI.file(untitledInput.filePath) : untitledInput.resource, untitledInput.language, untitledInput.contents, untitledInput.encoding);
            }
            // Resource Editor Support
            var resourceInput = input;
            if (resourceInput.resource instanceof uri_1.URI) {
                var label = resourceInput.label;
                if (!label && resourceInput.resource.scheme !== network_1.Schemas.data) {
                    label = paths_1.basename(resourceInput.resource.fsPath); // derive the label from the path (but not for data URIs)
                }
                return this.createOrGet(resourceInput.resource, this.instantiationService, label, resourceInput.description, resourceInput.encoding, resourceInput.forceFile);
            }
            return null;
        };
        EditorService.prototype.createOrGet = function (resource, instantiationService, label, description, encoding, forceFile) {
            if (EditorService.CACHE.has(resource)) {
                var input_1 = EditorService.CACHE.get(resource);
                if (input_1 instanceof resourceEditorInput_1.ResourceEditorInput) {
                    input_1.setName(label);
                    input_1.setDescription(description);
                }
                else if (!(input_1 instanceof dataUriEditorInput_1.DataUriEditorInput)) {
                    input_1.setPreferredEncoding(encoding);
                }
                return input_1;
            }
            var input;
            // File
            if (forceFile /* fix for https://github.com/Microsoft/vscode/issues/48275 */ || this.fileService.canHandleResource(resource)) {
                input = this.fileInputFactory.createFileInput(resource, encoding, instantiationService);
            }
            // Data URI
            else if (resource.scheme === network_1.Schemas.data) {
                input = instantiationService.createInstance(dataUriEditorInput_1.DataUriEditorInput, label, description, resource);
            }
            // Resource
            else {
                input = instantiationService.createInstance(resourceEditorInput_1.ResourceEditorInput, label, description, resource);
            }
            EditorService.CACHE.set(resource, input);
            event_1.once(input.onDispose)(function () {
                EditorService.CACHE.delete(resource);
            });
            return input;
        };
        EditorService.prototype.toDiffLabel = function (input) {
            var res = input.getResource();
            // Do not try to extract any paths from simple untitled editors
            if (res.scheme === network_1.Schemas.untitled && !this.untitledEditorService.hasAssociatedFilePath(res)) {
                return input.getName();
            }
            // Otherwise: for diff labels prefer to see the path as part of the label
            return this.labelService.getUriLabel(res, { relative: true });
        };
        EditorService.CACHE = new map_1.ResourceMap();
        EditorService = __decorate([
            __param(0, editorGroupsService_1.IEditorGroupsService),
            __param(1, untitledEditorService_1.IUntitledEditorService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, label_1.ILabelService),
            __param(4, files_1.IFileService),
            __param(5, configuration_1.IConfigurationService)
        ], EditorService);
        return EditorService;
    }(lifecycle_1.Disposable));
    exports.EditorService = EditorService;
    /**
     * The delegating workbench editor service can be used to override the behaviour of the openEditor()
     * method by providing a IEditorOpenHandler.
     */
    var DelegatingEditorService = /** @class */ (function (_super) {
        __extends(DelegatingEditorService, _super);
        function DelegatingEditorService(editorGroupService, untitledEditorService, instantiationService, labelService, fileService, configurationService) {
            return _super.call(this, editorGroupService, untitledEditorService, instantiationService, labelService, fileService, configurationService) || this;
        }
        DelegatingEditorService.prototype.setEditorOpenHandler = function (handler) {
            this.editorOpenHandler = handler;
        };
        DelegatingEditorService.prototype.doOpenEditor = function (group, editor, options) {
            var _this = this;
            var handleOpen = this.editorOpenHandler ? this.editorOpenHandler(group, editor, options) : winjs_base_1.TPromise.as(void 0);
            return handleOpen.then(function (control) {
                if (control) {
                    return winjs_base_1.TPromise.as(control); // the opening was handled, so return early
                }
                return _super.prototype.doOpenEditor.call(_this, group, editor, options);
            });
        };
        DelegatingEditorService = __decorate([
            __param(0, editorGroupsService_1.IEditorGroupsService),
            __param(1, untitledEditorService_1.IUntitledEditorService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, label_1.ILabelService),
            __param(4, files_1.IFileService),
            __param(5, configuration_1.IConfigurationService)
        ], DelegatingEditorService);
        return DelegatingEditorService;
    }(EditorService));
    exports.DelegatingEditorService = DelegatingEditorService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[428/*vs/workbench/services/textfile/electron-browser/textFileService*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,24/*vs/base/common/paths*/,22/*vs/base/common/strings*/,18/*vs/base/common/platform*/,402/*vs/workbench/services/textfile/common/textFileService*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,16/*vs/platform/files/common/files*/,20/*vs/platform/workspace/common/workspace*/,63/*vs/platform/lifecycle/common/lifecycle*/,7/*vs/platform/configuration/common/configuration*/,41/*vs/editor/common/services/modeService*/,73/*vs/editor/common/model/textModel*/,43/*vs/platform/environment/common/environment*/,3/*vs/platform/instantiation/common/instantiation*/,113/*vs/workbench/services/backup/common/backup*/,42/*vs/platform/windows/common/windows*/,124/*vs/workbench/services/history/common/history*/,10/*vs/platform/contextkey/common/contextkey*/,36/*vs/editor/common/services/modelService*/,28/*vs/platform/notification/common/notification*/,92/*vs/platform/dialogs/common/dialogs*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, nls, winjs_base_1, paths, strings, platform_1, textFileService_1, untitledEditorService_1, files_1, workspace_1, lifecycle_1, configuration_1, modeService_1, textModel_1, environment_1, instantiation_1, backup_1, windows_1, history_1, contextkey_1, modelService_1, notification_1, dialogs_1, editorService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextFileService = /** @class */ (function (_super) {
        __extends(TextFileService, _super);
        function TextFileService(contextService, fileService, untitledEditorService, lifecycleService, instantiationService, configurationService, modeService, modelService, windowService, environmentService, notificationService, backupFileService, windowsService, historyService, contextKeyService, dialogService, fileDialogService, editorService) {
            var _this = _super.call(this, lifecycleService, contextService, configurationService, fileService, untitledEditorService, instantiationService, notificationService, environmentService, backupFileService, windowsService, windowService, historyService, contextKeyService, modelService) || this;
            _this.modeService = modeService;
            _this.dialogService = dialogService;
            _this.fileDialogService = fileDialogService;
            _this.editorService = editorService;
            return _this;
        }
        TextFileService.prototype.resolveTextContent = function (resource, options) {
            return this.fileService.resolveStreamContent(resource, options).then(function (streamContent) {
                return textModel_1.createTextBufferFactoryFromStream(streamContent.value).then(function (res) {
                    var r = {
                        resource: streamContent.resource,
                        name: streamContent.name,
                        mtime: streamContent.mtime,
                        etag: streamContent.etag,
                        encoding: streamContent.encoding,
                        isReadonly: streamContent.isReadonly,
                        value: res
                    };
                    return r;
                });
            });
        };
        TextFileService.prototype.confirmSave = function (resources) {
            if (this.environmentService.isExtensionDevelopment) {
                return winjs_base_1.TPromise.wrap(1 /* DONT_SAVE */); // no veto when we are in extension dev mode because we cannot assum we run interactive (e.g. tests)
            }
            var resourcesToConfirm = this.getDirty(resources);
            if (resourcesToConfirm.length === 0) {
                return winjs_base_1.TPromise.wrap(1 /* DONT_SAVE */);
            }
            var message = resourcesToConfirm.length === 1 ? nls.localize('saveChangesMessage', "Do you want to save the changes you made to {0}?", paths.basename(resourcesToConfirm[0].fsPath))
                : dialogs_1.getConfirmMessage(nls.localize('saveChangesMessages', "Do you want to save the changes to the following {0} files?", resourcesToConfirm.length), resourcesToConfirm);
            var buttons = [
                resourcesToConfirm.length > 1 ? nls.localize({ key: 'saveAll', comment: ['&& denotes a mnemonic'] }, "&&Save All") : nls.localize({ key: 'save', comment: ['&& denotes a mnemonic'] }, "&&Save"),
                nls.localize({ key: 'dontSave', comment: ['&& denotes a mnemonic'] }, "Do&&n't Save"),
                nls.localize('cancel', "Cancel")
            ];
            return this.dialogService.show(notification_1.Severity.Warning, message, buttons, {
                cancelId: 2,
                detail: nls.localize('saveChangesDetail', "Your changes will be lost if you don't save them.")
            }).then(function (index) {
                switch (index) {
                    case 0: return 0 /* SAVE */;
                    case 1: return 1 /* DONT_SAVE */;
                    default: return 2 /* CANCEL */;
                }
            });
        };
        TextFileService.prototype.promptForPath = function (resource, defaultUri) {
            var _this = this;
            // Help user to find a name for the file by opening it first
            return this.editorService.openEditor({ resource: resource, options: { revealIfOpened: true, preserveFocus: true, } }).then(function () {
                return _this.fileDialogService.showSaveDialog(_this.getSaveDialogOptions(defaultUri));
            });
        };
        TextFileService.prototype.getSaveDialogOptions = function (defaultUri) {
            var _this = this;
            var options = {
                defaultUri: defaultUri,
                title: nls.localize('saveAsTitle', "Save As")
            };
            // Filters are only enabled on Windows where they work properly
            if (!platform_1.isWindows) {
                return options;
            }
            // Build the file filter by using our known languages
            var ext = defaultUri ? paths.extname(defaultUri.path) : void 0;
            var matchingFilter;
            var filters = this.modeService.getRegisteredLanguageNames().map(function (languageName) {
                var extensions = _this.modeService.getExtensions(languageName);
                if (!extensions || !extensions.length) {
                    return null;
                }
                var filter = { name: languageName, extensions: extensions.slice(0, 10).map(function (e) { return strings.trim(e, '.'); }) };
                if (ext && extensions.indexOf(ext) >= 0) {
                    matchingFilter = filter;
                    return null; // matching filter will be added last to the top
                }
                return filter;
            }).filter(function (f) { return !!f; });
            // Filters are a bit weird on Windows, based on having a match or not:
            // Match: we put the matching filter first so that it shows up selected and the all files last
            // No match: we put the all files filter first
            var allFilesFilter = { name: nls.localize('allFiles', "All Files"), extensions: ['*'] };
            if (matchingFilter) {
                filters.unshift(matchingFilter);
                filters.unshift(allFilesFilter);
            }
            else {
                filters.unshift(allFilesFilter);
            }
            // Allow to save file without extension
            filters.push({ name: nls.localize('noExt', "No Extension"), extensions: [''] });
            options.filters = filters;
            return options;
        };
        TextFileService = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, files_1.IFileService),
            __param(2, untitledEditorService_1.IUntitledEditorService),
            __param(3, lifecycle_1.ILifecycleService),
            __param(4, instantiation_1.IInstantiationService),
            __param(5, configuration_1.IConfigurationService),
            __param(6, modeService_1.IModeService),
            __param(7, modelService_1.IModelService),
            __param(8, windows_1.IWindowService),
            __param(9, environment_1.IEnvironmentService),
            __param(10, notification_1.INotificationService),
            __param(11, backup_1.IBackupFileService),
            __param(12, windows_1.IWindowsService),
            __param(13, history_1.IHistoryService),
            __param(14, contextkey_1.IContextKeyService),
            __param(15, dialogs_1.IDialogService),
            __param(16, dialogs_1.IFileDialogService),
            __param(17, editorService_1.IEditorService)
        ], TextFileService);
        return TextFileService;
    }(textFileService_1.TextFileService));
    exports.TextFileService = TextFileService;
});























define(__m[430/*vs/workbench/services/textmodelResolver/common/textModelResolverService*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,12/*vs/base/common/uri*/,17/*vs/base/common/async*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/,36/*vs/editor/common/services/modelService*/,186/*vs/workbench/common/editor/resourceEditorModel*/,27/*vs/workbench/services/textfile/common/textfiles*/,26/*vs/base/common/network*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,123/*vs/workbench/services/textfile/common/textFileEditorModel*/,16/*vs/platform/files/common/files*/]), function (require, exports, winjs_base_1, uri_1, async_1, instantiation_1, lifecycle_1, modelService_1, resourceEditorModel_1, textfiles_1, network, untitledEditorService_1, textFileEditorModel_1, files_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ResourceModelCollection = /** @class */ (function (_super) {
        __extends(ResourceModelCollection, _super);
        function ResourceModelCollection(instantiationService, textFileService, fileService) {
            var _this = _super.call(this) || this;
            _this.instantiationService = instantiationService;
            _this.textFileService = textFileService;
            _this.fileService = fileService;
            _this.providers = Object.create(null);
            return _this;
        }
        ResourceModelCollection.prototype.createReferencedObject = function (key) {
            var _this = this;
            var resource = uri_1.URI.parse(key);
            if (this.fileService.canHandleResource(resource)) {
                return this.textFileService.models.loadOrCreate(resource, { reason: 2 /* REFERENCE */ });
            }
            return this.resolveTextModelContent(key).then(function () { return _this.instantiationService.createInstance(resourceEditorModel_1.ResourceEditorModel, resource); });
        };
        ResourceModelCollection.prototype.destroyReferencedObject = function (modelPromise) {
            var _this = this;
            modelPromise.then(function (model) {
                if (model instanceof textFileEditorModel_1.TextFileEditorModel) {
                    _this.textFileService.models.disposeModel(model);
                }
                else {
                    model.dispose();
                }
            }, function (err) {
                // ignore
            });
        };
        ResourceModelCollection.prototype.registerTextModelContentProvider = function (scheme, provider) {
            var registry = this.providers;
            var providers = registry[scheme] || (registry[scheme] = []);
            providers.unshift(provider);
            return lifecycle_1.toDisposable(function () {
                var array = registry[scheme];
                if (!array) {
                    return;
                }
                var index = array.indexOf(provider);
                if (index === -1) {
                    return;
                }
                array.splice(index, 1);
                if (array.length === 0) {
                    delete registry[scheme];
                }
            });
        };
        ResourceModelCollection.prototype.resolveTextModelContent = function (key) {
            var resource = uri_1.URI.parse(key);
            var providers = this.providers[resource.scheme] || [];
            var factories = providers.map(function (p) { return function () { return winjs_base_1.TPromise.wrap(p.provideTextContent(resource)); }; });
            return async_1.first(factories).then(function (model) {
                if (!model) {
                    return winjs_base_1.TPromise.wrapError(new Error('resource is not available'));
                }
                return model;
            });
        };
        ResourceModelCollection = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, textfiles_1.ITextFileService),
            __param(2, files_1.IFileService)
        ], ResourceModelCollection);
        return ResourceModelCollection;
    }(lifecycle_1.ReferenceCollection));
    var TextModelResolverService = /** @class */ (function () {
        function TextModelResolverService(untitledEditorService, instantiationService, modelService) {
            this.untitledEditorService = untitledEditorService;
            this.instantiationService = instantiationService;
            this.modelService = modelService;
            this.resourceModelCollection = instantiationService.createInstance(ResourceModelCollection);
        }
        TextModelResolverService.prototype.createModelReference = function (resource) {
            return this._createModelReference(resource);
        };
        TextModelResolverService.prototype._createModelReference = function (resource) {
            // Untitled Schema: go through cached input
            if (resource.scheme === network.Schemas.untitled) {
                return this.untitledEditorService.loadOrCreate({ resource: resource }).then(function (model) { return new lifecycle_1.ImmortalReference(model); });
            }
            // InMemory Schema: go through model service cache
            if (resource.scheme === network.Schemas.inMemory) {
                var cachedModel = this.modelService.getModel(resource);
                if (!cachedModel) {
                    return winjs_base_1.TPromise.wrapError(new Error('Cant resolve inmemory resource'));
                }
                return winjs_base_1.TPromise.as(new lifecycle_1.ImmortalReference(this.instantiationService.createInstance(resourceEditorModel_1.ResourceEditorModel, resource)));
            }
            var ref = this.resourceModelCollection.acquire(resource.toString());
            return ref.object.then(function (model) { return ({ object: model, dispose: function () { return ref.dispose(); } }); }, function (err) {
                ref.dispose();
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        TextModelResolverService.prototype.registerTextModelContentProvider = function (scheme, provider) {
            return this.resourceModelCollection.registerTextModelContentProvider(scheme, provider);
        };
        TextModelResolverService = __decorate([
            __param(0, untitledEditorService_1.IUntitledEditorService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, modelService_1.IModelService)
        ], TextModelResolverService);
        return TextModelResolverService;
    }());
    exports.TextModelResolverService = TextModelResolverService;
});

define(__m[54/*vs/workbench/services/viewlet/browser/viewlet*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IViewletService = instantiation_1.createDecorator('viewletService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[76/*vs/workbench/browser/viewlet*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,8/*vs/base/browser/dom*/,9/*vs/platform/registry/common/platform*/,15/*vs/base/common/actions*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,182/*vs/workbench/browser/composite*/,337/*vs/workbench/browser/actions/toggleSidebarVisibility*/,49/*vs/workbench/services/part/common/partService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,336/*vs/workbench/browser/actions/toggleSidebarPosition*/]), function (require, exports, nls, DOM, platform_1, actions_1, viewlet_1, composite_1, toggleSidebarVisibility_1, partService_1, editorGroupsService_1, toggleSidebarPosition_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Viewlet = /** @class */ (function (_super) {
        __extends(Viewlet, _super);
        function Viewlet(id, configurationService, partService, telemetryService, themeService) {
            var _this = _super.call(this, id, telemetryService, themeService) || this;
            _this.configurationService = configurationService;
            _this.partService = partService;
            return _this;
        }
        Viewlet.prototype.getOptimalWidth = function () {
            return null;
        };
        Viewlet.prototype.getContextMenuActions = function () {
            var _this = this;
            var toggleSidebarPositionAction = new toggleSidebarPosition_1.ToggleSidebarPositionAction(toggleSidebarPosition_1.ToggleSidebarPositionAction.ID, toggleSidebarPosition_1.ToggleSidebarPositionAction.getLabel(this.partService), this.partService, this.configurationService);
            return [toggleSidebarPositionAction,
                {
                    id: toggleSidebarVisibility_1.ToggleSidebarVisibilityAction.ID,
                    label: nls.localize('compositePart.hideSideBarLabel', "Hide Side Bar"),
                    enabled: true,
                    run: function () { return _this.partService.setSideBarHidden(true); }
                }];
        };
        return Viewlet;
    }(composite_1.Composite));
    exports.Viewlet = Viewlet;
    /**
     * A viewlet descriptor is a leightweight descriptor of a viewlet in the workbench.
     */
    var ViewletDescriptor = /** @class */ (function (_super) {
        __extends(ViewletDescriptor, _super);
        function ViewletDescriptor(ctor, id, name, cssClass, order, _iconUrl) {
            var _this = _super.call(this, ctor, id, name, cssClass, order, id) || this;
            _this._iconUrl = _iconUrl;
            return _this;
        }
        Object.defineProperty(ViewletDescriptor.prototype, "iconUrl", {
            get: function () {
                return this._iconUrl;
            },
            enumerable: true,
            configurable: true
        });
        return ViewletDescriptor;
    }(composite_1.CompositeDescriptor));
    exports.ViewletDescriptor = ViewletDescriptor;
    exports.Extensions = {
        Viewlets: 'workbench.contributions.viewlets'
    };
    var ViewletRegistry = /** @class */ (function (_super) {
        __extends(ViewletRegistry, _super);
        function ViewletRegistry() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Registers a viewlet to the platform.
         */
        ViewletRegistry.prototype.registerViewlet = function (descriptor) {
            _super.prototype.registerComposite.call(this, descriptor);
        };
        /**
         * Returns the viewlet descriptor for the given id or null if none.
         */
        ViewletRegistry.prototype.getViewlet = function (id) {
            return this.getComposite(id);
        };
        /**
         * Returns an array of registered viewlets known to the platform.
         */
        ViewletRegistry.prototype.getViewlets = function () {
            return this.getComposites();
        };
        /**
         * Sets the id of the viewlet that should open on startup by default.
         */
        ViewletRegistry.prototype.setDefaultViewletId = function (id) {
            this.defaultViewletId = id;
        };
        /**
         * Gets the id of the viewlet that should open on startup by default.
         */
        ViewletRegistry.prototype.getDefaultViewletId = function () {
            return this.defaultViewletId;
        };
        return ViewletRegistry;
    }(composite_1.CompositeRegistry));
    exports.ViewletRegistry = ViewletRegistry;
    platform_1.Registry.add(exports.Extensions.Viewlets, new ViewletRegistry());
    /**
     * A reusable action to show a viewlet with a specific id.
     */
    var ShowViewletAction = /** @class */ (function (_super) {
        __extends(ShowViewletAction, _super);
        function ShowViewletAction(id, name, viewletId, viewletService, editorGroupService, partService) {
            var _this = _super.call(this, id, name) || this;
            _this.viewletService = viewletService;
            _this.editorGroupService = editorGroupService;
            _this.partService = partService;
            _this.viewletId = viewletId;
            _this.enabled = !!_this.viewletService && !!_this.editorGroupService;
            return _this;
        }
        ShowViewletAction.prototype.run = function () {
            // Pass focus to viewlet if not open or focused
            if (this.otherViewletShowing() || !this.sidebarHasFocus()) {
                return this.viewletService.openViewlet(this.viewletId, true);
            }
            // Otherwise pass focus to editor group
            this.editorGroupService.activeGroup.focus();
            return Promise.resolve(true);
        };
        ShowViewletAction.prototype.otherViewletShowing = function () {
            var activeViewlet = this.viewletService.getActiveViewlet();
            return !activeViewlet || activeViewlet.getId() !== this.viewletId;
        };
        ShowViewletAction.prototype.sidebarHasFocus = function () {
            var activeViewlet = this.viewletService.getActiveViewlet();
            var activeElement = document.activeElement;
            return activeViewlet && activeElement && DOM.isAncestor(activeElement, this.partService.getContainer(1 /* SIDEBAR_PART */));
        };
        ShowViewletAction = __decorate([
            __param(3, viewlet_1.IViewletService),
            __param(4, editorGroupsService_1.IEditorGroupsService),
            __param(5, partService_1.IPartService)
        ], ShowViewletAction);
        return ShowViewletAction;
    }(actions_1.Action));
    exports.ShowViewletAction = ShowViewletAction;
    // Collapse All action
    var CollapseAction = /** @class */ (function (_super) {
        __extends(CollapseAction, _super);
        function CollapseAction(viewer, enabled, clazz) {
            return _super.call(this, 'workbench.action.collapse', nls.localize('collapse', "Collapse All"), clazz, enabled, function (context) {
                if (viewer.getHighlight()) {
                    return Promise.resolve(null); // Global action disabled if user is in edit mode from another action
                }
                viewer.collapseAll();
                viewer.clearSelection();
                viewer.clearFocus();
                viewer.domFocus();
                viewer.focusFirst();
                return Promise.resolve(null);
            }) || this;
        }
        return CollapseAction;
    }(actions_1.Action));
    exports.CollapseAction = CollapseAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[167/*vs/workbench/browser/parts/views/panelViewlet*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,6/*vs/base/common/event*/,40/*vs/platform/theme/common/styler*/,58/*vs/workbench/common/theme*/,8/*vs/base/browser/dom*/,4/*vs/base/common/lifecycle*/,19/*vs/base/common/arrays*/,9/*vs/platform/registry/common/platform*/,112/*vs/workbench/browser/actions*/,76/*vs/workbench/browser/viewlet*/,133/*vs/base/browser/ui/toolbar/toolbar*/,31/*vs/platform/keybinding/common/keybinding*/,34/*vs/platform/contextview/browser/contextView*/,32/*vs/platform/telemetry/common/telemetry*/,14/*vs/platform/theme/common/themeService*/,215/*vs/base/browser/ui/splitview/panelview*/,7/*vs/platform/configuration/common/configuration*/,49/*vs/workbench/services/part/common/partService*/,137/*vs/base/browser/mouseEvent*/,247/*vs/css!vs/workbench/browser/parts/views/media/panelviewlet*/]), function (require, exports, nls, winjs_base_1, event_1, styler_1, theme_1, dom_1, lifecycle_1, arrays_1, platform_1, actions_1, viewlet_1, toolbar_1, keybinding_1, contextView_1, telemetry_1, themeService_1, panelview_1, configuration_1, partService_1, mouseEvent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ViewletPanel = /** @class */ (function (_super) {
        __extends(ViewletPanel, _super);
        function ViewletPanel(options, keybindingService, contextMenuService, configurationService) {
            var _this = _super.call(this, options) || this;
            _this.keybindingService = keybindingService;
            _this.contextMenuService = contextMenuService;
            _this.configurationService = configurationService;
            _this._onDidFocus = new event_1.Emitter();
            _this.onDidFocus = _this._onDidFocus.event;
            _this._onDidBlur = new event_1.Emitter();
            _this.onDidBlur = _this._onDidBlur.event;
            _this._onDidChangeTitleArea = new event_1.Emitter();
            _this.onDidChangeTitleArea = _this._onDidChangeTitleArea.event;
            _this.id = options.id;
            _this.title = options.title;
            _this.actionRunner = options.actionRunner;
            return _this;
        }
        ViewletPanel.prototype.setVisible = function (visible) {
            if (this._isVisible !== visible) {
                this._isVisible = visible;
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        ViewletPanel.prototype.isVisible = function () {
            return this._isVisible;
        };
        ViewletPanel.prototype.render = function () {
            var _this = this;
            _super.prototype.render.call(this);
            var focusTracker = dom_1.trackFocus(this.element);
            this.disposables.push(focusTracker);
            this.disposables.push(focusTracker.onDidFocus(function () { return _this._onDidFocus.fire(); }));
            this.disposables.push(focusTracker.onDidBlur(function () { return _this._onDidBlur.fire(); }));
        };
        ViewletPanel.prototype.renderHeader = function (container) {
            var _this = this;
            this.headerContainer = container;
            this.renderHeaderTitle(container, this.title);
            var actions = dom_1.append(container, dom_1.$('.actions'));
            this.toolbar = new toolbar_1.ToolBar(actions, this.contextMenuService, {
                orientation: 0 /* HORIZONTAL */,
                actionItemProvider: function (action) { return _this.getActionItem(action); },
                ariaLabel: nls.localize('viewToolbarAriaLabel', "{0} actions", this.title),
                getKeyBinding: function (action) { return _this.keybindingService.lookupKeybinding(action.id); },
                actionRunner: this.actionRunner
            });
            this.disposables.push(this.toolbar);
            this.setActions();
            var onDidRelevantConfigurationChange = event_1.filterEvent(this.configurationService.onDidChangeConfiguration, function (e) { return e.affectsConfiguration(ViewletPanel.AlwaysShowActionsConfig); });
            onDidRelevantConfigurationChange(this.updateActionsVisibility, this, this.disposables);
            this.updateActionsVisibility();
        };
        ViewletPanel.prototype.renderHeaderTitle = function (container, title) {
            dom_1.append(container, dom_1.$('h3.title', null, title));
        };
        ViewletPanel.prototype.focus = function () {
            if (this.element) {
                this.element.focus();
                this._onDidFocus.fire();
            }
        };
        ViewletPanel.prototype.setActions = function () {
            this.toolbar.setActions(actions_1.prepareActions(this.getActions()), actions_1.prepareActions(this.getSecondaryActions()))();
            this.toolbar.context = this.getActionsContext();
        };
        ViewletPanel.prototype.updateActionsVisibility = function () {
            var shouldAlwaysShowActions = this.configurationService.getValue('workbench.view.alwaysShowHeaderActions');
            dom_1.toggleClass(this.headerContainer, 'actions-always-visible', shouldAlwaysShowActions);
        };
        ViewletPanel.prototype.updateActions = function () {
            this.setActions();
            this._onDidChangeTitleArea.fire();
        };
        ViewletPanel.prototype.getActions = function () {
            return [];
        };
        ViewletPanel.prototype.getSecondaryActions = function () {
            return [];
        };
        ViewletPanel.prototype.getActionItem = function (action) {
            return null;
        };
        ViewletPanel.prototype.getActionsContext = function () {
            return undefined;
        };
        ViewletPanel.prototype.getOptimalWidth = function () {
            return 0;
        };
        ViewletPanel.prototype.shutdown = function () {
        };
        ViewletPanel.AlwaysShowActionsConfig = 'workbench.view.alwaysShowHeaderActions';
        ViewletPanel = __decorate([
            __param(1, keybinding_1.IKeybindingService),
            __param(2, contextView_1.IContextMenuService),
            __param(3, configuration_1.IConfigurationService)
        ], ViewletPanel);
        return ViewletPanel;
    }(panelview_1.Panel));
    exports.ViewletPanel = ViewletPanel;
    var PanelViewlet = /** @class */ (function (_super) {
        __extends(PanelViewlet, _super);
        function PanelViewlet(id, options, configurationService, partService, contextMenuService, telemetryService, themeService) {
            var _this = _super.call(this, id, configurationService, partService, telemetryService, themeService) || this;
            _this.options = options;
            _this.contextMenuService = contextMenuService;
            _this.panelItems = [];
            return _this;
        }
        Object.defineProperty(PanelViewlet.prototype, "onDidSashChange", {
            get: function () {
                return this.panelview.onDidSashChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PanelViewlet.prototype, "panels", {
            get: function () {
                return this.panelItems.map(function (i) { return i.panel; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PanelViewlet.prototype, "length", {
            get: function () {
                return this.panelItems.length;
            },
            enumerable: true,
            configurable: true
        });
        PanelViewlet.prototype.create = function (parent) {
            var _this = this;
            return _super.prototype.create.call(this, parent).then(function () {
                _this.panelview = _this._register(new panelview_1.PanelView(parent, _this.options));
                _this._register(_this.panelview.onDidDrop(function (_a) {
                    var from = _a.from, to = _a.to;
                    return _this.movePanel(from, to);
                }));
                _this._register(dom_1.addDisposableListener(parent, dom_1.EventType.CONTEXT_MENU, function (e) { return _this.showContextMenu(new mouseEvent_1.StandardMouseEvent(e)); }));
            });
        };
        PanelViewlet.prototype.showContextMenu = function (event) {
            var _this = this;
            for (var _i = 0, _a = this.panelItems; _i < _a.length; _i++) {
                var panelItem = _a[_i];
                // Do not show context menu if target is coming from inside panel views
                if (dom_1.isAncestor(event.target, panelItem.panel.element)) {
                    return;
                }
            }
            event.stopPropagation();
            event.preventDefault();
            var anchor = { x: event.posx, y: event.posy };
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () { return Promise.resolve(_this.getContextMenuActions()); }
            });
        };
        PanelViewlet.prototype.getTitle = function () {
            var title = platform_1.Registry.as(viewlet_1.Extensions.Viewlets).getViewlet(this.getId()).name;
            if (this.isSingleView()) {
                title += ': ' + this.panelItems[0].panel.title;
            }
            return title;
        };
        PanelViewlet.prototype.getActions = function () {
            if (this.isSingleView()) {
                return this.panelItems[0].panel.getActions();
            }
            return [];
        };
        PanelViewlet.prototype.getSecondaryActions = function () {
            if (this.isSingleView()) {
                return this.panelItems[0].panel.getSecondaryActions();
            }
            return [];
        };
        PanelViewlet.prototype.getActionItem = function (action) {
            if (this.isSingleView()) {
                return this.panelItems[0].panel.getActionItem(action);
            }
            return _super.prototype.getActionItem.call(this, action);
        };
        PanelViewlet.prototype.focus = function () {
            _super.prototype.focus.call(this);
            if (this.lastFocusedPanel) {
                this.lastFocusedPanel.focus();
            }
            else if (this.panelItems.length > 0) {
                for (var _i = 0, _a = this.panelItems; _i < _a.length; _i++) {
                    var panel = _a[_i].panel;
                    if (panel.isExpanded()) {
                        panel.focus();
                        return;
                    }
                }
            }
        };
        PanelViewlet.prototype.layout = function (dimension) {
            this.panelview.layout(dimension.height);
        };
        PanelViewlet.prototype.getOptimalWidth = function () {
            var sizes = this.panelItems
                .map(function (panelItem) { return panelItem.panel.getOptimalWidth() || 0; });
            return Math.max.apply(Math, sizes);
        };
        PanelViewlet.prototype.addPanels = function (panels) {
            var wasSingleView = this.isSingleView();
            for (var _i = 0, panels_1 = panels; _i < panels_1.length; _i++) {
                var _a = panels_1[_i], panel = _a.panel, size = _a.size, index = _a.index;
                this.addPanel(panel, size, index);
            }
            this.updateViewHeaders();
            if (this.isSingleView() !== wasSingleView) {
                this.updateTitleArea();
            }
        };
        PanelViewlet.prototype.addPanel = function (panel, size, index) {
            var _this = this;
            if (index === void 0) { index = this.panelItems.length - 1; }
            var disposables = [];
            var onDidFocus = panel.onDidFocus(function () { return _this.lastFocusedPanel = panel; }, null, disposables);
            var onDidChangeTitleArea = panel.onDidChangeTitleArea(function () {
                if (_this.isSingleView()) {
                    _this.updateTitleArea();
                }
            }, null, disposables);
            var onDidChange = panel.onDidChange(function () {
                if (panel === _this.lastFocusedPanel && !panel.isExpanded()) {
                    _this.lastFocusedPanel = undefined;
                }
            }, null, disposables);
            var panelStyler = styler_1.attachStyler(this.themeService, {
                headerForeground: theme_1.SIDE_BAR_SECTION_HEADER_FOREGROUND,
                headerBackground: theme_1.SIDE_BAR_SECTION_HEADER_BACKGROUND,
                headerBorder: index === 0 ? null : theme_1.SIDE_BAR_SECTION_HEADER_BORDER,
                dropBackground: theme_1.SIDE_BAR_DRAG_AND_DROP_BACKGROUND
            }, panel);
            var disposable = lifecycle_1.combinedDisposable([onDidFocus, onDidChangeTitleArea, panelStyler, onDidChange]);
            var panelItem = { panel: panel, disposable: disposable };
            this.panelItems.splice(index, 0, panelItem);
            this.panelview.addPanel(panel, size, index);
        };
        PanelViewlet.prototype.removePanels = function (panels) {
            var _this = this;
            var wasSingleView = this.isSingleView();
            panels.forEach(function (panel) { return _this.removePanel(panel); });
            this.updateViewHeaders();
            if (wasSingleView !== this.isSingleView()) {
                this.updateTitleArea();
            }
        };
        PanelViewlet.prototype.removePanel = function (panel) {
            var index = arrays_1.firstIndex(this.panelItems, function (i) { return i.panel === panel; });
            if (index === -1) {
                return;
            }
            if (this.lastFocusedPanel === panel) {
                this.lastFocusedPanel = undefined;
            }
            this.panelview.removePanel(panel);
            var panelItem = this.panelItems.splice(index, 1)[0];
            panelItem.disposable.dispose();
        };
        PanelViewlet.prototype.movePanel = function (from, to) {
            var fromIndex = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === from; });
            var toIndex = arrays_1.firstIndex(this.panelItems, function (item) { return item.panel === to; });
            if (fromIndex < 0 || fromIndex >= this.panelItems.length) {
                return;
            }
            if (toIndex < 0 || toIndex >= this.panelItems.length) {
                return;
            }
            var panelItem = this.panelItems.splice(fromIndex, 1)[0];
            this.panelItems.splice(toIndex, 0, panelItem);
            this.panelview.movePanel(from, to);
        };
        PanelViewlet.prototype.resizePanel = function (panel, size) {
            this.panelview.resizePanel(panel, size);
        };
        PanelViewlet.prototype.getPanelSize = function (panel) {
            return this.panelview.getPanelSize(panel);
        };
        PanelViewlet.prototype.updateViewHeaders = function () {
            if (this.isSingleView()) {
                this.panelItems[0].panel.setExpanded(true);
                this.panelItems[0].panel.headerVisible = false;
            }
            else {
                this.panelItems.forEach(function (i) { return i.panel.headerVisible = true; });
            }
        };
        PanelViewlet.prototype.isSingleView = function () {
            return this.options.showHeaderInTitleWhenSingleView && this.panelItems.length === 1;
        };
        PanelViewlet.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.panelItems.forEach(function (i) { return i.disposable.dispose(); });
            this.panelview.dispose();
        };
        PanelViewlet = __decorate([
            __param(2, configuration_1.IConfigurationService),
            __param(3, partService_1.IPartService),
            __param(4, contextView_1.IContextMenuService),
            __param(5, telemetry_1.ITelemetryService),
            __param(6, themeService_1.IThemeService)
        ], PanelViewlet);
        return PanelViewlet;
    }(viewlet_1.Viewlet));
    exports.PanelViewlet = PanelViewlet;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[400/*vs/workbench/browser/parts/views/views*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,108/*vs/workbench/common/views*/,9/*vs/platform/registry/common/platform*/,76/*vs/workbench/browser/viewlet*/,44/*vs/platform/storage/common/storage*/,63/*vs/platform/lifecycle/common/lifecycle*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,10/*vs/platform/contextkey/common/contextkey*/,6/*vs/base/common/event*/,19/*vs/base/common/arrays*/,20/*vs/platform/workspace/common/workspace*/,29/*vs/base/common/types*/,23/*vs/platform/actions/common/actions*/,37/*vs/platform/commands/common/commands*/,2/*vs/nls*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,253/*vs/css!vs/workbench/browser/parts/views/media/views*/]), function (require, exports, lifecycle_1, views_1, platform_1, viewlet_1, storage_1, lifecycle_2, viewlet_2, contextkey_1, event_1, arrays_1, workspace_1, types_1, actions_1, commands_1, nls_1, keybindingsRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function filterViewEvent(container, event) {
        return event_1.chain(event)
            .map(function (views) { return views.filter(function (view) { return view.container === container; }); })
            .filter(function (views) { return views.length > 0; })
            .event;
    }
    var CounterSet = /** @class */ (function () {
        function CounterSet() {
            this.map = new Map();
        }
        CounterSet.prototype.add = function (value) {
            this.map.set(value, (this.map.get(value) || 0) + 1);
            return this;
        };
        CounterSet.prototype.delete = function (value) {
            var counter = this.map.get(value) || 0;
            if (counter === 0) {
                return false;
            }
            counter--;
            if (counter === 0) {
                this.map.delete(value);
            }
            else {
                this.map.set(value, counter);
            }
            return true;
        };
        CounterSet.prototype.has = function (value) {
            return this.map.has(value);
        };
        return CounterSet;
    }());
    var ViewDescriptorCollection = /** @class */ (function (_super) {
        __extends(ViewDescriptorCollection, _super);
        function ViewDescriptorCollection(container, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.contextKeyService = contextKeyService;
            _this.contextKeys = new CounterSet();
            _this.items = [];
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChangeActiveViews = _this._onDidChange.event;
            var onRelevantViewsRegistered = filterViewEvent(container, views_1.ViewsRegistry.onViewsRegistered);
            _this._register(onRelevantViewsRegistered(_this.onViewsRegistered, _this));
            var onRelevantViewsDeregistered = filterViewEvent(container, views_1.ViewsRegistry.onViewsDeregistered);
            _this._register(onRelevantViewsDeregistered(_this.onViewsDeregistered, _this));
            var onRelevantContextChange = event_1.filterEvent(contextKeyService.onDidChangeContext, function (e) { return e.affectsSome(_this.contextKeys); });
            _this._register(onRelevantContextChange(_this.onContextChanged, _this));
            _this.onViewsRegistered(views_1.ViewsRegistry.getViews(container));
            return _this;
        }
        Object.defineProperty(ViewDescriptorCollection.prototype, "activeViewDescriptors", {
            get: function () {
                return this.items
                    .filter(function (i) { return i.active; })
                    .map(function (i) { return i.viewDescriptor; });
            },
            enumerable: true,
            configurable: true
        });
        ViewDescriptorCollection.prototype.onViewsRegistered = function (viewDescriptors) {
            var added = [];
            for (var _i = 0, viewDescriptors_1 = viewDescriptors; _i < viewDescriptors_1.length; _i++) {
                var viewDescriptor = viewDescriptors_1[_i];
                var item = {
                    viewDescriptor: viewDescriptor,
                    active: this.isViewDescriptorActive(viewDescriptor) // TODO: should read from some state?
                };
                this.items.push(item);
                if (viewDescriptor.when) {
                    for (var _a = 0, _b = viewDescriptor.when.keys(); _a < _b.length; _a++) {
                        var key = _b[_a];
                        this.contextKeys.add(key);
                    }
                }
                if (item.active) {
                    added.push(viewDescriptor);
                }
            }
            if (added.length) {
                this._onDidChange.fire({ added: added, removed: [] });
            }
        };
        ViewDescriptorCollection.prototype.onViewsDeregistered = function (viewDescriptors) {
            var removed = [];
            var _loop_1 = function (viewDescriptor) {
                var index = arrays_1.firstIndex(this_1.items, function (i) { return i.viewDescriptor.id === viewDescriptor.id; });
                if (index === -1) {
                    return "continue";
                }
                var item = this_1.items[index];
                this_1.items.splice(index, 1);
                if (viewDescriptor.when) {
                    for (var _i = 0, _a = viewDescriptor.when.keys(); _i < _a.length; _i++) {
                        var key = _a[_i];
                        this_1.contextKeys.delete(key);
                    }
                }
                if (item.active) {
                    removed.push(viewDescriptor);
                }
            };
            var this_1 = this;
            for (var _i = 0, viewDescriptors_2 = viewDescriptors; _i < viewDescriptors_2.length; _i++) {
                var viewDescriptor = viewDescriptors_2[_i];
                _loop_1(viewDescriptor);
            }
            if (removed.length) {
                this._onDidChange.fire({ added: [], removed: removed });
            }
        };
        ViewDescriptorCollection.prototype.onContextChanged = function (event) {
            var removed = [];
            var added = [];
            for (var _i = 0, _a = this.items; _i < _a.length; _i++) {
                var item = _a[_i];
                var active = this.isViewDescriptorActive(item.viewDescriptor);
                if (item.active !== active) {
                    if (active) {
                        added.push(item.viewDescriptor);
                    }
                    else {
                        removed.push(item.viewDescriptor);
                    }
                }
                item.active = active;
            }
            if (added.length || removed.length) {
                this._onDidChange.fire({ added: added, removed: removed });
            }
        };
        ViewDescriptorCollection.prototype.isViewDescriptorActive = function (viewDescriptor) {
            return !viewDescriptor.when || this.contextKeyService.contextMatchesRules(viewDescriptor.when);
        };
        ViewDescriptorCollection = __decorate([
            __param(1, contextkey_1.IContextKeyService)
        ], ViewDescriptorCollection);
        return ViewDescriptorCollection;
    }(lifecycle_1.Disposable));
    var ContributableViewsModel = /** @class */ (function (_super) {
        __extends(ContributableViewsModel, _super);
        function ContributableViewsModel(container, viewsService, viewStates) {
            if (viewStates === void 0) { viewStates = new Map(); }
            var _this = _super.call(this) || this;
            _this.viewStates = viewStates;
            _this.viewDescriptors = [];
            _this._onDidAdd = _this._register(new event_1.Emitter());
            _this.onDidAdd = _this._onDidAdd.event;
            _this._onDidRemove = _this._register(new event_1.Emitter());
            _this.onDidRemove = _this._onDidRemove.event;
            _this._onDidMove = _this._register(new event_1.Emitter());
            _this.onDidMove = _this._onDidMove.event;
            var viewDescriptorCollection = viewsService.getViewDescriptors(container);
            _this._register(viewDescriptorCollection.onDidChangeActiveViews(function () { return _this.onDidChangeViewDescriptors(viewDescriptorCollection.activeViewDescriptors); }));
            _this.onDidChangeViewDescriptors(viewDescriptorCollection.activeViewDescriptors);
            return _this;
        }
        Object.defineProperty(ContributableViewsModel.prototype, "visibleViewDescriptors", {
            get: function () {
                var _this = this;
                return this.viewDescriptors.filter(function (v) { return _this.viewStates.get(v.id).visible; });
            },
            enumerable: true,
            configurable: true
        });
        ContributableViewsModel.prototype.isVisible = function (id) {
            var state = this.viewStates.get(id);
            if (!state) {
                throw new Error("Unknown view " + id);
            }
            return state.visible;
        };
        ContributableViewsModel.prototype.setVisible = function (id, visible) {
            var _a = this.find(id), visibleIndex = _a.visibleIndex, viewDescriptor = _a.viewDescriptor, state = _a.state;
            if (!viewDescriptor.canToggleVisibility) {
                throw new Error("Can't toggle this view's visibility");
            }
            if (state.visible === visible) {
                return;
            }
            state.visible = visible;
            if (visible) {
                this._onDidAdd.fire([{ index: visibleIndex, viewDescriptor: viewDescriptor, size: state.size, collapsed: state.collapsed }]);
            }
            else {
                this._onDidRemove.fire([{ index: visibleIndex, viewDescriptor: viewDescriptor }]);
            }
        };
        ContributableViewsModel.prototype.isCollapsed = function (id) {
            var state = this.viewStates.get(id);
            if (!state) {
                throw new Error("Unknown view " + id);
            }
            return state.collapsed;
        };
        ContributableViewsModel.prototype.setCollapsed = function (id, collapsed) {
            var state = this.find(id).state;
            state.collapsed = collapsed;
        };
        ContributableViewsModel.prototype.getSize = function (id) {
            var state = this.viewStates.get(id);
            if (!state) {
                throw new Error("Unknown view " + id);
            }
            return state.size;
        };
        ContributableViewsModel.prototype.setSize = function (id, size) {
            var state = this.find(id).state;
            state.size = size;
        };
        ContributableViewsModel.prototype.move = function (from, to) {
            var fromIndex = arrays_1.firstIndex(this.viewDescriptors, function (v) { return v.id === from; });
            var toIndex = arrays_1.firstIndex(this.viewDescriptors, function (v) { return v.id === to; });
            var fromViewDescriptor = this.viewDescriptors[fromIndex];
            var toViewDescriptor = this.viewDescriptors[toIndex];
            arrays_1.move(this.viewDescriptors, fromIndex, toIndex);
            for (var index = 0; index < this.viewDescriptors.length; index++) {
                var state = this.viewStates.get(this.viewDescriptors[index].id);
                state.order = index;
            }
            this._onDidMove.fire({
                from: { index: fromIndex, viewDescriptor: fromViewDescriptor },
                to: { index: toIndex, viewDescriptor: toViewDescriptor }
            });
        };
        ContributableViewsModel.prototype.find = function (id) {
            for (var i = 0, visibleIndex = 0; i < this.viewDescriptors.length; i++) {
                var viewDescriptor = this.viewDescriptors[i];
                var state = this.viewStates.get(viewDescriptor.id);
                if (viewDescriptor.id === id) {
                    return { index: i, visibleIndex: visibleIndex, viewDescriptor: viewDescriptor, state: state };
                }
                if (state.visible) {
                    visibleIndex++;
                }
            }
            throw new Error("view descriptor " + id + " not found");
        };
        ContributableViewsModel.prototype.compareViewDescriptors = function (a, b) {
            if (a.id === b.id) {
                return 0;
            }
            return (this.getViewOrder(a) - this.getViewOrder(b)) || (a.id < b.id ? -1 : 1);
        };
        ContributableViewsModel.prototype.getViewOrder = function (viewDescriptor) {
            var viewState = this.viewStates.get(viewDescriptor.id);
            var viewOrder = viewState && typeof viewState.order === 'number' ? viewState.order : viewDescriptor.order;
            return typeof viewOrder === 'number' ? viewOrder : Number.MAX_VALUE;
        };
        ContributableViewsModel.prototype.onDidChangeViewDescriptors = function (viewDescriptors) {
            var _a;
            var ids = new Set();
            for (var _i = 0, _b = this.viewDescriptors; _i < _b.length; _i++) {
                var viewDescriptor = _b[_i];
                ids.add(viewDescriptor.id);
            }
            viewDescriptors = viewDescriptors.sort(this.compareViewDescriptors.bind(this));
            for (var _c = 0, viewDescriptors_3 = viewDescriptors; _c < viewDescriptors_3.length; _c++) {
                var viewDescriptor = viewDescriptors_3[_c];
                var viewState = this.viewStates.get(viewDescriptor.id);
                if (viewState) {
                    // set defaults if not set
                    viewState.visible = types_1.isUndefinedOrNull(viewState.visible) ? !viewDescriptor.hideByDefault : viewState.visible;
                    viewState.collapsed = types_1.isUndefinedOrNull(viewState.collapsed) ? !!viewDescriptor.collapsed : viewState.collapsed;
                }
                else {
                    this.viewStates.set(viewDescriptor.id, {
                        visible: !viewDescriptor.hideByDefault,
                        collapsed: viewDescriptor.collapsed
                    });
                }
            }
            var splices = arrays_1.sortedDiff(this.viewDescriptors, viewDescriptors, this.compareViewDescriptors.bind(this)).reverse();
            var toRemove = [];
            var toAdd = [];
            for (var _d = 0, splices_1 = splices; _d < splices_1.length; _d++) {
                var splice = splices_1[_d];
                var startViewDescriptor = this.viewDescriptors[splice.start];
                var startIndex = startViewDescriptor ? this.find(startViewDescriptor.id).visibleIndex : this.viewDescriptors.length;
                for (var i = 0; i < splice.deleteCount; i++) {
                    var viewDescriptor = this.viewDescriptors[splice.start + i];
                    var state = this.find(viewDescriptor.id).state;
                    if (state.visible) {
                        toRemove.push({ index: startIndex++, viewDescriptor: viewDescriptor });
                    }
                }
                for (var i = 0; i < splice.toInsert.length; i++) {
                    var viewDescriptor = splice.toInsert[i];
                    var state = this.viewStates.get(viewDescriptor.id);
                    if (state.visible) {
                        toAdd.push({ index: startIndex++, viewDescriptor: viewDescriptor, size: state.size, collapsed: state.collapsed });
                    }
                }
            }
            (_a = this.viewDescriptors).splice.apply(_a, [0, this.viewDescriptors.length].concat(viewDescriptors));
            if (toRemove.length) {
                this._onDidRemove.fire(toRemove);
            }
            if (toAdd.length) {
                this._onDidAdd.fire(toAdd);
            }
        };
        return ContributableViewsModel;
    }(lifecycle_1.Disposable));
    exports.ContributableViewsModel = ContributableViewsModel;
    var PersistentContributableViewsModel = /** @class */ (function (_super) {
        __extends(PersistentContributableViewsModel, _super);
        function PersistentContributableViewsModel(container, viewletStateStorageId, viewsService, storageService, contextService) {
            var _this = this;
            var hiddenViewsStorageId = viewletStateStorageId + ".hidden";
            var viewStates = PersistentContributableViewsModel.loadViewsStates(viewletStateStorageId, hiddenViewsStorageId, storageService, contextService);
            _this = _super.call(this, container, viewsService, viewStates) || this;
            _this.viewletStateStorageId = viewletStateStorageId;
            _this.hiddenViewsStorageId = hiddenViewsStorageId;
            _this.storageService = storageService;
            _this.contextService = contextService;
            _this._register(_this.onDidAdd(function (viewDescriptorRefs) { return _this.saveVisibilityStates(viewDescriptorRefs.map(function (r) { return r.viewDescriptor; })); }));
            _this._register(_this.onDidRemove(function (viewDescriptorRefs) { return _this.saveVisibilityStates(viewDescriptorRefs.map(function (r) { return r.viewDescriptor; })); }));
            return _this;
        }
        PersistentContributableViewsModel.prototype.saveViewsStates = function () {
            var storedViewsStates = {};
            for (var _i = 0, _a = this.viewDescriptors; _i < _a.length; _i++) {
                var viewDescriptor = _a[_i];
                var viewState = this.viewStates.get(viewDescriptor.id);
                if (viewState) {
                    storedViewsStates[viewDescriptor.id] = { collapsed: viewState.collapsed, size: viewState.size, order: viewState.order };
                }
            }
            this.storageService.store(this.viewletStateStorageId, JSON.stringify(storedViewsStates), this.contextService.getWorkbenchState() !== 1 /* EMPTY */ ? 1 /* WORKSPACE */ : 0 /* GLOBAL */);
        };
        PersistentContributableViewsModel.prototype.saveVisibilityStates = function (viewDescriptors) {
            var storedViewsVisibilityStates = PersistentContributableViewsModel.loadViewsVisibilityState(this.hiddenViewsStorageId, this.storageService, this.contextService);
            for (var _i = 0, viewDescriptors_4 = viewDescriptors; _i < viewDescriptors_4.length; _i++) {
                var viewDescriptor = viewDescriptors_4[_i];
                if (viewDescriptor.canToggleVisibility) {
                    var viewState = this.viewStates.get(viewDescriptor.id);
                    storedViewsVisibilityStates.push({ id: viewDescriptor.id, isHidden: viewState ? !viewState.visible : void 0 });
                }
            }
            this.storageService.store(this.hiddenViewsStorageId, JSON.stringify(storedViewsVisibilityStates), 0 /* GLOBAL */);
        };
        PersistentContributableViewsModel.loadViewsStates = function (viewletStateStorageId, hiddenViewsStorageId, storageService, contextService) {
            var viewStates = new Map();
            var storedViewsStates = JSON.parse(storageService.get(viewletStateStorageId, contextService.getWorkbenchState() !== 1 /* EMPTY */ ? 1 /* WORKSPACE */ : 0 /* GLOBAL */, '{}'));
            var viewsVisibilityStates = PersistentContributableViewsModel.loadViewsVisibilityState(hiddenViewsStorageId, storageService, contextService);
            for (var _i = 0, viewsVisibilityStates_1 = viewsVisibilityStates; _i < viewsVisibilityStates_1.length; _i++) {
                var _a = viewsVisibilityStates_1[_i], id = _a.id, isHidden = _a.isHidden;
                var viewState = storedViewsStates[id];
                if (viewState) {
                    viewStates.set(id, __assign({}, viewState, { visible: !isHidden }));
                }
                else {
                    // New workspace
                    viewStates.set(id, __assign({ visible: !isHidden }));
                }
            }
            for (var _b = 0, _c = Object.keys(storedViewsStates); _b < _c.length; _b++) {
                var id = _c[_b];
                if (!viewStates.has(id)) {
                    viewStates.set(id, __assign({}, storedViewsStates[id]));
                }
            }
            return viewStates;
        };
        PersistentContributableViewsModel.loadViewsVisibilityState = function (hiddenViewsStorageId, storageService, contextService) {
            var storedVisibilityStates = JSON.parse(storageService.get(hiddenViewsStorageId, 0 /* GLOBAL */, '[]'));
            return storedVisibilityStates.map(function (c) { return typeof c === 'string' /* migration */ ? { id: c, isHidden: true } : c; });
        };
        PersistentContributableViewsModel.prototype.dispose = function () {
            this.saveViewsStates();
            _super.prototype.dispose.call(this);
        };
        PersistentContributableViewsModel = __decorate([
            __param(2, views_1.IViewsService),
            __param(3, storage_1.IStorageService),
            __param(4, workspace_1.IWorkspaceContextService)
        ], PersistentContributableViewsModel);
        return PersistentContributableViewsModel;
    }(ContributableViewsModel));
    exports.PersistentContributableViewsModel = PersistentContributableViewsModel;
    var SCM_VIEWLET_ID = 'workbench.view.scm';
    var ViewsService = /** @class */ (function (_super) {
        __extends(ViewsService, _super);
        function ViewsService(lifecycleService, viewletService, storageService, workspaceContextService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.lifecycleService = lifecycleService;
            _this.viewletService = viewletService;
            _this.storageService = storageService;
            _this.workspaceContextService = workspaceContextService;
            _this.contextKeyService = contextKeyService;
            _this.viewDescriptorCollections = new Map();
            _this.activeViewContextKeys = new Map();
            _this.onDidRegisterViews(views_1.ViewsRegistry.getAllViews());
            _this._register(views_1.ViewsRegistry.onViewsRegistered(function (views) { return _this.onDidRegisterViews(views); }));
            var viewContainersRegistry = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry);
            viewContainersRegistry.all.forEach(function (viewContainer) { return _this.onDidRegisterViewContainer(viewContainer); });
            _this._register(viewContainersRegistry.onDidRegister(function (viewContainer) { return _this.onDidRegisterViewContainer(viewContainer); }));
            _this._register(platform_1.Registry.as(viewlet_1.Extensions.Viewlets).onDidRegister(function (viewlet) { return _this.viewletService.setViewletEnablement(viewlet.id, _this.storageService.getBoolean("viewservice." + viewlet.id + ".enablement", _this.getStorageScope(), viewlet.id !== views_1.TEST_VIEW_CONTAINER_ID)); }));
            return _this;
        }
        ViewsService.prototype.getViewDescriptors = function (container) {
            return this.viewDescriptorCollections.get(container);
        };
        ViewsService.prototype.openView = function (id, focus) {
            var viewDescriptor = views_1.ViewsRegistry.getView(id);
            if (viewDescriptor) {
                var viewletDescriptor = this.viewletService.getViewlet(viewDescriptor.container.id);
                if (viewletDescriptor) {
                    return this.viewletService.openViewlet(viewletDescriptor.id)
                        .then(function (viewlet) {
                        if (viewlet && viewlet.openView) {
                            return viewlet.openView(id, focus);
                        }
                        return null;
                    });
                }
            }
            return Promise.resolve(null);
        };
        ViewsService.prototype.onDidRegisterViewContainer = function (viewContainer) {
            var _this = this;
            var viewDescriptorCollection = this.registerViewDescriptorCollection(viewContainer);
            // TODO: @Joao Remove this after moving SCM Viewlet to ViewContainerViewlet - https://github.com/Microsoft/vscode/issues/49054
            if (viewContainer.id !== SCM_VIEWLET_ID) {
                this._register(viewDescriptorCollection.onDidChangeActiveViews(function () { return _this.updateViewletEnablement(viewContainer, viewDescriptorCollection); }));
                this.lifecycleService.when(4 /* Eventually */).then(function () { return _this.updateViewletEnablement(viewContainer, viewDescriptorCollection); });
            }
        };
        ViewsService.prototype.registerViewDescriptorCollection = function (viewContainer) {
            var _this = this;
            var viewDescriptorCollection = this._register(new ViewDescriptorCollection(viewContainer, this.contextKeyService));
            this.onDidChangeActiveViews({ added: viewDescriptorCollection.activeViewDescriptors, removed: [] });
            this._register(viewDescriptorCollection.onDidChangeActiveViews(function (changed) { return _this.onDidChangeActiveViews(changed); }));
            this.viewDescriptorCollections.set(viewContainer, viewDescriptorCollection);
            return viewDescriptorCollection;
        };
        ViewsService.prototype.onDidChangeActiveViews = function (_a) {
            var _this = this;
            var added = _a.added, removed = _a.removed;
            added.forEach(function (viewDescriptor) { return _this.getOrCreateActiveViewContextKey(viewDescriptor).set(true); });
            removed.forEach(function (viewDescriptor) { return _this.getOrCreateActiveViewContextKey(viewDescriptor).set(false); });
        };
        ViewsService.prototype.onDidRegisterViews = function (viewDescriptors) {
            var _this = this;
            var _loop_2 = function (viewDescriptor) {
                var viewlet = this_2.viewletService.getViewlet(viewDescriptor.container.id);
                var command = {
                    id: viewDescriptor.focusCommand ? viewDescriptor.focusCommand.id : viewDescriptor.id + ".focus",
                    title: { original: "Focus on " + viewDescriptor.name + " View", value: nls_1.localize('focus view', "Focus on {0} View", viewDescriptor.name) },
                    category: viewlet ? viewlet.name : nls_1.localize('view category', "View"),
                };
                var when = contextkey_1.ContextKeyExpr.has(viewDescriptor.id + ".active");
                commands_1.CommandsRegistry.registerCommand(command.id, function () { return _this.openView(viewDescriptor.id, true); });
                actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.CommandPalette, {
                    command: command,
                    when: when
                });
                if (viewDescriptor.focusCommand && viewDescriptor.focusCommand.keybindings) {
                    keybindingsRegistry_1.KeybindingsRegistry.registerKeybindingRule({
                        id: command.id,
                        when: when,
                        weight: 200 /* WorkbenchContrib */,
                        primary: viewDescriptor.focusCommand.keybindings.primary,
                        secondary: viewDescriptor.focusCommand.keybindings.secondary,
                        linux: viewDescriptor.focusCommand.keybindings.linux,
                        mac: viewDescriptor.focusCommand.keybindings.mac,
                        win: viewDescriptor.focusCommand.keybindings.win
                    });
                }
            };
            var this_2 = this;
            for (var _i = 0, viewDescriptors_5 = viewDescriptors; _i < viewDescriptors_5.length; _i++) {
                var viewDescriptor = viewDescriptors_5[_i];
                _loop_2(viewDescriptor);
            }
        };
        ViewsService.prototype.getOrCreateActiveViewContextKey = function (viewDescriptor) {
            var activeContextKeyId = viewDescriptor.id + ".active";
            var contextKey = this.activeViewContextKeys.get(activeContextKeyId);
            if (!contextKey) {
                contextKey = new contextkey_1.RawContextKey(activeContextKeyId, false).bindTo(this.contextKeyService);
                this.activeViewContextKeys.set(activeContextKeyId, contextKey);
            }
            return contextKey;
        };
        ViewsService.prototype.updateViewletEnablement = function (viewContainer, viewDescriptorCollection) {
            var enabled = viewDescriptorCollection.activeViewDescriptors.length > 0;
            this.viewletService.setViewletEnablement(viewContainer.id, enabled);
            this.storageService.store("viewservice." + viewContainer.id + ".enablement", enabled, this.getStorageScope());
        };
        ViewsService.prototype.getStorageScope = function () {
            return this.workspaceContextService.getWorkbenchState() === 1 /* EMPTY */ ? 0 /* GLOBAL */ : 1 /* WORKSPACE */;
        };
        ViewsService = __decorate([
            __param(0, lifecycle_2.ILifecycleService),
            __param(1, viewlet_2.IViewletService),
            __param(2, storage_1.IStorageService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, contextkey_1.IContextKeyService)
        ], ViewsService);
        return ViewsService;
    }(lifecycle_1.Disposable));
    exports.ViewsService = ViewsService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[221/*vs/workbench/browser/parts/views/viewsViewlet*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,8/*vs/base/browser/dom*/,4/*vs/base/common/lifecycle*/,50/*vs/base/browser/ui/actionbar/actionbar*/,19/*vs/base/common/arrays*/,70/*vs/workbench/services/extensions/common/extensions*/,34/*vs/platform/contextview/browser/contextView*/,108/*vs/workbench/common/views*/,32/*vs/platform/telemetry/common/telemetry*/,14/*vs/platform/theme/common/themeService*/,3/*vs/platform/instantiation/common/instantiation*/,44/*vs/platform/storage/common/storage*/,20/*vs/platform/workspace/common/workspace*/,10/*vs/platform/contextkey/common/contextkey*/,137/*vs/base/browser/mouseEvent*/,167/*vs/workbench/browser/parts/views/panelViewlet*/,215/*vs/base/browser/ui/splitview/panelview*/,51/*vs/platform/list/browser/listService*/,6/*vs/base/common/event*/,7/*vs/platform/configuration/common/configuration*/,49/*vs/workbench/services/part/common/partService*/,2/*vs/nls*/,400/*vs/workbench/browser/parts/views/views*/,9/*vs/platform/registry/common/platform*/]), function (require, exports, winjs_base_1, DOM, lifecycle_1, actionbar_1, arrays_1, extensions_1, contextView_1, views_1, telemetry_1, themeService_1, instantiation_1, storage_1, workspace_1, contextkey_1, mouseEvent_1, panelViewlet_1, panelview_1, listService_1, event_1, configuration_1, partService_1, nls_1, views_2, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TreeViewsViewletPanel = /** @class */ (function (_super) {
        __extends(TreeViewsViewletPanel, _super);
        function TreeViewsViewletPanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TreeViewsViewletPanel.prototype.setExpanded = function (expanded) {
            if (this.isExpanded() !== expanded) {
                this.updateTreeVisibility(this.tree, expanded);
                _super.prototype.setExpanded.call(this, expanded);
            }
        };
        TreeViewsViewletPanel.prototype.setVisible = function (visible) {
            var _this = this;
            if (this.isVisible() !== visible) {
                return _super.prototype.setVisible.call(this, visible)
                    .then(function () { return _this.updateTreeVisibility(_this.tree, visible && _this.isExpanded()); });
            }
            return winjs_base_1.TPromise.wrap(null);
        };
        TreeViewsViewletPanel.prototype.focus = function () {
            _super.prototype.focus.call(this);
            this.focusTree();
        };
        TreeViewsViewletPanel.prototype.layoutBody = function (size) {
            if (this.tree) {
                this.tree.layout(size);
            }
        };
        TreeViewsViewletPanel.prototype.updateTreeVisibility = function (tree, isVisible) {
            if (!tree) {
                return;
            }
            if (isVisible) {
                DOM.show(tree.getHTMLElement());
            }
            else {
                DOM.hide(tree.getHTMLElement()); // make sure the tree goes out of the tabindex world by hiding it
            }
            if (isVisible) {
                tree.onVisible();
            }
            else {
                tree.onHidden();
            }
        };
        TreeViewsViewletPanel.prototype.focusTree = function () {
            if (!this.tree) {
                return; // return early if viewlet has not yet been created
            }
            // Make sure the current selected element is revealed
            var selectedElement = this.tree.getSelection()[0];
            if (selectedElement) {
                this.tree.reveal(selectedElement, 0.5);
            }
            // Pass Focus to Viewer
            this.tree.domFocus();
        };
        TreeViewsViewletPanel.prototype.dispose = function () {
            if (this.tree) {
                this.tree.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        return TreeViewsViewletPanel;
    }(panelViewlet_1.ViewletPanel));
    exports.TreeViewsViewletPanel = TreeViewsViewletPanel;
    var ViewContainerViewlet = /** @class */ (function (_super) {
        __extends(ViewContainerViewlet, _super);
        function ViewContainerViewlet(id, viewletStateStorageId, showHeaderInTitleWhenSingleView, configurationService, partService, telemetryService, storageService, instantiationService, themeService, contextMenuService, extensionService, contextService) {
            var _this = _super.call(this, id, { showHeaderInTitleWhenSingleView: showHeaderInTitleWhenSingleView, dnd: new panelview_1.DefaultPanelDndController() }, configurationService, partService, contextMenuService, telemetryService, themeService) || this;
            _this.storageService = storageService;
            _this.instantiationService = instantiationService;
            _this.contextMenuService = contextMenuService;
            _this.extensionService = extensionService;
            _this.contextService = contextService;
            _this.didLayout = false;
            _this.areExtensionsReady = false;
            _this.viewDisposables = [];
            var container = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).get(id);
            _this.viewsModel = _this._register(_this.instantiationService.createInstance(views_2.PersistentContributableViewsModel, container, viewletStateStorageId));
            _this.viewletSettings = _this.getMemento(storageService, 1 /* WORKSPACE */);
            _this.visibleViewsStorageId = id + ".numberOfVisibleViews";
            _this.visibleViewsCountFromCache = _this.storageService.getInteger(_this.visibleViewsStorageId, _this.contextService.getWorkbenchState() === 1 /* EMPTY */ ? 0 /* GLOBAL */ : 1 /* WORKSPACE */, 0);
            _this._register(lifecycle_1.toDisposable(function () { return _this.viewDisposables = lifecycle_1.dispose(_this.viewDisposables); }));
            return _this;
        }
        ViewContainerViewlet.prototype.create = function (parent) {
            var _this = this;
            return _super.prototype.create.call(this, parent).then(function () {
                _this._register(_this.onDidSashChange(function () { return _this.saveViewSizes(); }));
                _this.viewsModel.onDidAdd(function (added) { return _this.onDidAddViews(added); });
                _this.viewsModel.onDidRemove(function (removed) { return _this.onDidRemoveViews(removed); });
                var addedViews = _this.viewsModel.visibleViewDescriptors.map(function (viewDescriptor, index) {
                    var size = _this.viewsModel.getSize(viewDescriptor.id);
                    var collapsed = _this.viewsModel.isCollapsed(viewDescriptor.id);
                    return ({ viewDescriptor: viewDescriptor, index: index, size: size, collapsed: collapsed });
                });
                if (addedViews.length) {
                    _this.onDidAddViews(addedViews);
                }
                // Update headers after and title contributed views after available, since we read from cache in the beginning to know if the viewlet has single view or not. Ref #29609
                _this.extensionService.whenInstalledExtensionsRegistered().then(function () {
                    _this.areExtensionsReady = true;
                    if (_this.panels.length) {
                        _this.updateTitleArea();
                        _this.updateViewHeaders();
                    }
                });
                _this.focus();
            });
        };
        ViewContainerViewlet.prototype.getContextMenuActions = function () {
            var _this = this;
            var result = [];
            var viewToggleActions = this.viewsModel.viewDescriptors.map(function (viewDescriptor) { return ({
                id: viewDescriptor.id + ".toggleVisibility",
                label: viewDescriptor.name,
                checked: _this.viewsModel.isVisible(viewDescriptor.id),
                enabled: viewDescriptor.canToggleVisibility,
                run: function () { return _this.toggleViewVisibility(viewDescriptor.id); }
            }); });
            result.push.apply(result, viewToggleActions);
            var parentActions = _super.prototype.getContextMenuActions.call(this);
            if (viewToggleActions.length && parentActions.length) {
                result.push(new actionbar_1.Separator());
            }
            result.push.apply(result, parentActions);
            return result;
        };
        ViewContainerViewlet.prototype.setVisible = function (visible) {
            var _this = this;
            return _super.prototype.setVisible.call(this, visible)
                .then(function () { return Promise.all(_this.panels.filter(function (view) { return view.isVisible() !== visible; })
                .map(function (view) { return view.setVisible(visible); })); })
                .then(function () { return void 0; });
        };
        ViewContainerViewlet.prototype.openView = function (id, focus) {
            if (focus) {
                this.focus();
            }
            var view = this.getView(id);
            if (!view) {
                this.toggleViewVisibility(id);
            }
            view = this.getView(id);
            view.setExpanded(true);
            if (focus) {
                view.focus();
            }
            return Promise.resolve(view);
        };
        ViewContainerViewlet.prototype.movePanel = function (from, to) {
            var fromIndex = arrays_1.firstIndex(this.panels, function (panel) { return panel === from; });
            var toIndex = arrays_1.firstIndex(this.panels, function (panel) { return panel === to; });
            var fromViewDescriptor = this.viewsModel.visibleViewDescriptors[fromIndex];
            var toViewDescriptor = this.viewsModel.visibleViewDescriptors[toIndex];
            _super.prototype.movePanel.call(this, from, to);
            this.viewsModel.move(fromViewDescriptor.id, toViewDescriptor.id);
        };
        ViewContainerViewlet.prototype.layout = function (dimension) {
            _super.prototype.layout.call(this, dimension);
            this.dimension = dimension;
            if (this.didLayout) {
                this.saveViewSizes();
            }
            else {
                this.didLayout = true;
                this.restoreViewSizes();
            }
        };
        ViewContainerViewlet.prototype.getOptimalWidth = function () {
            var additionalMargin = 16;
            var optimalWidth = Math.max.apply(Math, this.panels.map(function (view) { return view.getOptimalWidth() || 0; }));
            return optimalWidth + additionalMargin;
        };
        ViewContainerViewlet.prototype.shutdown = function () {
            this.panels.forEach(function (view) { return view.shutdown(); });
            this.storageService.store(this.visibleViewsStorageId, this.length, this.contextService.getWorkbenchState() !== 1 /* EMPTY */ ? 1 /* WORKSPACE */ : 0 /* GLOBAL */);
            this.viewsModel.saveViewsStates();
            _super.prototype.shutdown.call(this);
        };
        ViewContainerViewlet.prototype.isSingleView = function () {
            if (!_super.prototype.isSingleView.call(this)) {
                return false;
            }
            if (!this.areExtensionsReady) {
                // Check in cache so that view do not jump. See #29609
                return this.visibleViewsCountFromCache === 1;
            }
            return true;
        };
        ViewContainerViewlet.prototype.createView = function (viewDescriptor, options) {
            return this.instantiationService.createInstance(viewDescriptor.ctor, options);
        };
        ViewContainerViewlet.prototype.getView = function (id) {
            return this.panels.filter(function (view) { return view.id === id; })[0];
        };
        ViewContainerViewlet.prototype.onDidAddViews = function (added) {
            var _this = this;
            var panelsToAdd = [];
            var _loop_1 = function (viewDescriptor, collapsed, index, size) {
                var panel = this_1.createView(viewDescriptor, {
                    id: viewDescriptor.id,
                    title: viewDescriptor.name,
                    actionRunner: this_1.getActionRunner(),
                    expanded: !collapsed,
                    viewletSettings: this_1.viewletSettings
                });
                panel.render();
                panel.setVisible(true);
                var contextMenuDisposable = DOM.addDisposableListener(panel.draggableElement, 'contextmenu', function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    _this.onContextMenu(new mouseEvent_1.StandardMouseEvent(e), viewDescriptor);
                });
                var collapseDisposable = event_1.latch(event_1.mapEvent(panel.onDidChange, function () { return !panel.isExpanded(); }))(function (collapsed) {
                    _this.viewsModel.setCollapsed(viewDescriptor.id, collapsed);
                });
                this_1.viewDisposables.splice(index, 0, lifecycle_1.combinedDisposable([contextMenuDisposable, collapseDisposable]));
                panelsToAdd.push({ panel: panel, size: size || panel.minimumSize, index: index });
            };
            var this_1 = this;
            for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
                var _a = added_1[_i], viewDescriptor = _a.viewDescriptor, collapsed = _a.collapsed, index = _a.index, size = _a.size;
                _loop_1(viewDescriptor, collapsed, index, size);
            }
            this.addPanels(panelsToAdd);
            this.restoreViewSizes();
            return panelsToAdd.map(function (_a) {
                var panel = _a.panel;
                return panel;
            });
        };
        ViewContainerViewlet.prototype.onDidRemoveViews = function (removed) {
            removed = removed.sort(function (a, b) { return b.index - a.index; });
            var panelsToRemove = [];
            for (var _i = 0, removed_1 = removed; _i < removed_1.length; _i++) {
                var index = removed_1[_i].index;
                var disposable = this.viewDisposables.splice(index, 1)[0];
                disposable.dispose();
                panelsToRemove.push(this.panels[index]);
            }
            this.removePanels(panelsToRemove);
            lifecycle_1.dispose(panelsToRemove);
        };
        ViewContainerViewlet.prototype.onContextMenu = function (event, viewDescriptor) {
            var _this = this;
            event.stopPropagation();
            event.preventDefault();
            var actions = [];
            actions.push({
                id: viewDescriptor.id + ".removeView",
                label: nls_1.localize('hideView', "Hide"),
                enabled: viewDescriptor.canToggleVisibility,
                run: function () { return _this.toggleViewVisibility(viewDescriptor.id); }
            });
            var otherActions = this.getContextMenuActions();
            if (otherActions.length) {
                actions.push.apply(actions, [new actionbar_1.Separator()].concat(otherActions));
            }
            var anchor = { x: event.posx, y: event.posy };
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () { return Promise.resolve(actions); }
            });
        };
        ViewContainerViewlet.prototype.toggleViewVisibility = function (viewId) {
            var visible = !this.viewsModel.isVisible(viewId);
            /* __GDPR__
                "views.toggleVisibility" : {
                    "viewId" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "visible": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('views.toggledVisibility', { viewId: viewId, visible: visible });
            this.viewsModel.setVisible(viewId, visible);
        };
        ViewContainerViewlet.prototype.saveViewSizes = function () {
            // Save size only when the layout has happened
            if (this.didLayout) {
                for (var _i = 0, _a = this.panels; _i < _a.length; _i++) {
                    var view = _a[_i];
                    this.viewsModel.setSize(view.id, this.getPanelSize(view));
                }
            }
        };
        ViewContainerViewlet.prototype.restoreViewSizes = function () {
            // Restore sizes only when the layout has happened
            if (this.didLayout) {
                var initialSizes = void 0;
                for (var i = 0; i < this.viewsModel.visibleViewDescriptors.length; i++) {
                    var panel = this.panels[i];
                    var viewDescriptor = this.viewsModel.visibleViewDescriptors[i];
                    var size = this.viewsModel.getSize(viewDescriptor.id);
                    if (typeof size === 'number') {
                        this.resizePanel(panel, size);
                    }
                    else {
                        initialSizes = initialSizes ? initialSizes : this.computeInitialSizes();
                        this.resizePanel(panel, initialSizes[panel.id] || 200);
                    }
                }
            }
        };
        ViewContainerViewlet.prototype.computeInitialSizes = function () {
            var sizes = {};
            if (this.dimension) {
                var totalWeight = this.viewsModel.visibleViewDescriptors.reduce(function (totalWeight, _a) {
                    var weight = _a.weight;
                    return totalWeight + (weight || 20);
                }, 0);
                for (var _i = 0, _a = this.viewsModel.visibleViewDescriptors; _i < _a.length; _i++) {
                    var viewDescriptor = _a[_i];
                    sizes[viewDescriptor.id] = this.dimension.height * (viewDescriptor.weight || 20) / totalWeight;
                }
            }
            return sizes;
        };
        ViewContainerViewlet = __decorate([
            __param(3, configuration_1.IConfigurationService),
            __param(4, partService_1.IPartService),
            __param(5, telemetry_1.ITelemetryService),
            __param(6, storage_1.IStorageService),
            __param(7, instantiation_1.IInstantiationService),
            __param(8, themeService_1.IThemeService),
            __param(9, contextView_1.IContextMenuService),
            __param(10, extensions_1.IExtensionService),
            __param(11, workspace_1.IWorkspaceContextService)
        ], ViewContainerViewlet);
        return ViewContainerViewlet;
    }(panelViewlet_1.PanelViewlet));
    exports.ViewContainerViewlet = ViewContainerViewlet;
    var FileIconThemableWorkbenchTree = /** @class */ (function (_super) {
        __extends(FileIconThemableWorkbenchTree, _super);
        function FileIconThemableWorkbenchTree(container, configuration, options, contextKeyService, listService, themeService, configurationService, instantiationService) {
            var _this = _super.call(this, container, configuration, __assign({}, options, { showTwistie: false, twistiePixels: 12 }), contextKeyService, listService, themeService, instantiationService, configurationService) || this;
            DOM.addClass(container, 'file-icon-themable-tree');
            DOM.addClass(container, 'show-file-icons');
            var onFileIconThemeChange = function (fileIconTheme) {
                DOM.toggleClass(container, 'align-icons-and-twisties', fileIconTheme.hasFileIcons && !fileIconTheme.hasFolderIcons);
                DOM.toggleClass(container, 'hide-arrows', fileIconTheme.hidesExplorerArrows === true);
            };
            _this.disposables.push(themeService.onDidFileIconThemeChange(onFileIconThemeChange));
            onFileIconThemeChange(themeService.getFileIconTheme());
            return _this;
        }
        FileIconThemableWorkbenchTree = __decorate([
            __param(3, contextkey_1.IContextKeyService),
            __param(4, listService_1.IListService),
            __param(5, themeService_1.IThemeService),
            __param(6, configuration_1.IConfigurationService),
            __param(7, instantiation_1.IInstantiationService)
        ], FileIconThemableWorkbenchTree);
        return FileIconThemableWorkbenchTree;
    }(listService_1.WorkbenchTree));
    exports.FileIconThemableWorkbenchTree = FileIconThemableWorkbenchTree;
});























define(__m[398/*vs/workbench/parts/files/browser/editors/textFileEditor*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,25/*vs/base/common/errors*/,98/*vs/base/common/errorMessage*/,29/*vs/base/common/types*/,24/*vs/base/common/paths*/,15/*vs/base/common/actions*/,57/*vs/workbench/parts/files/common/files*/,27/*vs/workbench/services/textfile/common/textfiles*/,149/*vs/workbench/browser/parts/editor/textEditor*/,127/*vs/workbench/common/editor/binaryEditorModel*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,16/*vs/platform/files/common/files*/,32/*vs/platform/telemetry/common/telemetry*/,20/*vs/platform/workspace/common/workspace*/,44/*vs/platform/storage/common/storage*/,88/*vs/editor/common/services/resourceConfiguration*/,3/*vs/platform/instantiation/common/instantiation*/,61/*vs/workbench/services/preferences/common/preferences*/,14/*vs/platform/theme/common/themeService*/,42/*vs/platform/windows/common/windows*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/]), function (require, exports, nls, errors, errorMessage_1, types, paths, actions_1, files_1, textfiles_1, textEditor_1, binaryEditorModel_1, viewlet_1, files_2, telemetry_1, workspace_1, storage_1, resourceConfiguration_1, instantiation_1, preferences_1, themeService_1, windows_1, editorService_1, editorGroupsService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * An implementation of editor for file system resources.
     */
    var TextFileEditor = /** @class */ (function (_super) {
        __extends(TextFileEditor, _super);
        function TextFileEditor(telemetryService, fileService, viewletService, instantiationService, contextService, storageService, configurationService, editorService, themeService, editorGroupService, textFileService, windowsService, preferencesService, windowService) {
            var _this = _super.call(this, TextFileEditor.ID, telemetryService, instantiationService, storageService, configurationService, themeService, textFileService, editorService, editorGroupService, windowService) || this;
            _this.fileService = fileService;
            _this.viewletService = viewletService;
            _this.contextService = contextService;
            _this.windowsService = windowsService;
            _this.preferencesService = preferencesService;
            _this.updateRestoreViewStateConfiguration();
            // Clear view state for deleted files
            _this._register(_this.fileService.onFileChanges(function (e) { return _this.onFilesChanged(e); }));
            return _this;
        }
        TextFileEditor.prototype.onFilesChanged = function (e) {
            var deleted = e.getDeleted();
            if (deleted && deleted.length) {
                this.clearTextEditorViewState(deleted.map(function (d) { return d.resource; }));
            }
        };
        TextFileEditor.prototype.handleConfigurationChangeEvent = function (configuration) {
            _super.prototype.handleConfigurationChangeEvent.call(this, configuration);
            this.updateRestoreViewStateConfiguration();
        };
        TextFileEditor.prototype.updateRestoreViewStateConfiguration = function () {
            this.restoreViewState = this.configurationService.getValue(null, 'workbench.editor.restoreViewState');
        };
        TextFileEditor.prototype.getTitle = function () {
            return this.input ? this.input.getName() : nls.localize('textFileEditor', "Text File Editor");
        };
        Object.defineProperty(TextFileEditor.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: true,
            configurable: true
        });
        TextFileEditor.prototype.setEditorVisible = function (visible, group) {
            var _this = this;
            _super.prototype.setEditorVisible.call(this, visible, group);
            // React to editors closing to preserve or clear view state. This needs to happen
            // in the onWillCloseEditor because at that time the editor has not yet
            // been disposed and we can safely persist the view state still as needed.
            this._register(group.onWillCloseEditor(function (e) {
                if (e.editor === _this.input) {
                    _this.doSaveOrClearTextEditorViewState(_this.input);
                }
            }));
        };
        TextFileEditor.prototype.setOptions = function (options) {
            var textOptions = options;
            if (textOptions && types.isFunction(textOptions.apply)) {
                textOptions.apply(this.getControl(), 0 /* Smooth */);
            }
        };
        TextFileEditor.prototype.setInput = function (input, options, token) {
            var _this = this;
            // Update/clear view settings if input changes
            this.doSaveOrClearTextEditorViewState(this.input);
            // Set input and resolve
            return _super.prototype.setInput.call(this, input, options, token).then(function () {
                return input.resolve().then(function (resolvedModel) {
                    // Check for cancellation
                    if (token.isCancellationRequested) {
                        return void 0;
                    }
                    // There is a special case where the text editor has to handle binary file editor input: if a binary file
                    // has been resolved and cached before, it maybe an actual instance of BinaryEditorModel. In this case our text
                    // editor has to open this model using the binary editor. We return early in this case.
                    if (resolvedModel instanceof binaryEditorModel_1.BinaryEditorModel) {
                        return _this.openAsBinary(input, options);
                    }
                    // Check Model state
                    var textFileModel = resolvedModel;
                    var hasInput = !!_this.input;
                    var modelDisposed = textFileModel.isDisposed();
                    var inputChanged = hasInput && _this.input.getResource().toString() !== textFileModel.getResource().toString();
                    if (!hasInput || // editor got hidden meanwhile
                        modelDisposed || // input got disposed meanwhile
                        inputChanged // a different input was set meanwhile
                    ) {
                        return void 0;
                    }
                    // Editor
                    var textEditor = _this.getControl();
                    textEditor.setModel(textFileModel.textEditorModel);
                    // Always restore View State if any associated
                    var editorViewState = _this.loadTextEditorViewState(_this.input.getResource());
                    if (editorViewState) {
                        textEditor.restoreViewState(editorViewState);
                    }
                    // TextOptions (avoiding instanceof here for a reason, do not change!)
                    if (options && types.isFunction(options.apply)) {
                        options.apply(textEditor, 1 /* Immediate */);
                    }
                    // Readonly flag
                    textEditor.updateOptions({ readOnly: textFileModel.isReadonly() });
                }, function (error) {
                    // In case we tried to open a file inside the text editor and the response
                    // indicates that this is not a text file, reopen the file through the binary
                    // editor.
                    if (error.fileOperationResult === 0 /* FILE_IS_BINARY */) {
                        return _this.openAsBinary(input, options);
                    }
                    // Similar, handle case where we were asked to open a folder in the text editor.
                    if (error.fileOperationResult === 1 /* FILE_IS_DIRECTORY */) {
                        _this.openAsFolder(input);
                        return Promise.reject(new Error(nls.localize('openFolderError', "File is a directory")));
                    }
                    // Offer to create a file from the error if we have a file not found and the name is valid
                    if (error.fileOperationResult === 2 /* FILE_NOT_FOUND */ && paths.isValidBasename(paths.basename(input.getResource().fsPath))) {
                        return Promise.reject(errors.create(errorMessage_1.toErrorMessage(error), {
                            actions: [
                                new actions_1.Action('workbench.files.action.createMissingFile', nls.localize('createFile', "Create File"), null, true, function () {
                                    return _this.fileService.updateContent(input.getResource(), '').then(function () { return _this.editorService.openEditor({
                                        resource: input.getResource(),
                                        options: {
                                            pinned: true // new file gets pinned by default
                                        }
                                    }); });
                                })
                            ]
                        }));
                    }
                    if (error.fileOperationResult === 10 /* FILE_EXCEED_MEMORY_LIMIT */) {
                        var memoryLimit_1 = Math.max(files_2.MIN_MAX_MEMORY_SIZE_MB, +_this.configurationService.getValue(null, 'files.maxMemoryForLargeFilesMB') || files_2.FALLBACK_MAX_MEMORY_SIZE_MB);
                        return Promise.reject(errors.create(errorMessage_1.toErrorMessage(error), {
                            actions: [
                                new actions_1.Action('workbench.window.action.relaunchWithIncreasedMemoryLimit', nls.localize('relaunchWithIncreasedMemoryLimit', "Restart with {0} MB", memoryLimit_1), null, true, function () {
                                    return _this.windowsService.relaunch({
                                        addArgs: [
                                            "--max-memory=" + memoryLimit_1
                                        ]
                                    });
                                }),
                                new actions_1.Action('workbench.window.action.configureMemoryLimit', nls.localize('configureMemoryLimit', 'Configure Memory Limit'), null, true, function () {
                                    return _this.preferencesService.openGlobalSettings(undefined, { query: 'files.maxMemoryForLargeFilesMB' });
                                })
                            ]
                        }));
                    }
                    // Otherwise make sure the error bubbles up
                    return Promise.reject(error);
                });
            });
        };
        TextFileEditor.prototype.openAsBinary = function (input, options) {
            input.setForceOpenAsBinary();
            this.editorService.openEditor(input, options, this.group);
        };
        TextFileEditor.prototype.openAsFolder = function (input) {
            var _this = this;
            // Since we cannot open a folder, we have to restore the previous input if any and close the editor
            this.group.closeEditor(this.input).then(function () {
                // Best we can do is to reveal the folder in the explorer
                if (_this.contextService.isInsideWorkspace(input.getResource())) {
                    _this.viewletService.openViewlet(files_1.VIEWLET_ID, true).then(function (viewlet) {
                        return viewlet.getExplorerView().select(input.getResource(), true);
                    });
                }
            });
        };
        TextFileEditor.prototype.getAriaLabel = function () {
            var input = this.input;
            var inputName = input && input.getName();
            var ariaLabel;
            if (inputName) {
                ariaLabel = nls.localize('fileEditorWithInputAriaLabel', "{0}. Text file editor.", inputName);
            }
            else {
                ariaLabel = nls.localize('fileEditorAriaLabel', "Text file editor.");
            }
            return ariaLabel;
        };
        TextFileEditor.prototype.clearInput = function () {
            // Update/clear editor view state in settings
            this.doSaveOrClearTextEditorViewState(this.input);
            // Clear Model
            this.getControl().setModel(null);
            // Pass to super
            _super.prototype.clearInput.call(this);
        };
        TextFileEditor.prototype.shutdown = function () {
            // Update/clear editor view State
            this.doSaveOrClearTextEditorViewState(this.input);
            // Call Super
            _super.prototype.shutdown.call(this);
        };
        TextFileEditor.prototype.doSaveOrClearTextEditorViewState = function (input) {
            if (!input) {
                return; // ensure we have an input to handle view state for
            }
            // If the user configured to not restore view state, we clear the view
            // state unless the editor is still opened in the group.
            if (!this.restoreViewState && (!this.group || !this.group.isOpened(input))) {
                this.clearTextEditorViewState([input.getResource()], this.group);
            }
            // Otherwise we save the view state to restore it later
            else if (!input.isDisposed()) {
                this.saveTextEditorViewState(input.getResource());
            }
        };
        TextFileEditor.ID = files_1.TEXT_FILE_EDITOR_ID;
        TextFileEditor = __decorate([
            __param(0, telemetry_1.ITelemetryService),
            __param(1, files_2.IFileService),
            __param(2, viewlet_1.IViewletService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, workspace_1.IWorkspaceContextService),
            __param(5, storage_1.IStorageService),
            __param(6, resourceConfiguration_1.ITextResourceConfigurationService),
            __param(7, editorService_1.IEditorService),
            __param(8, themeService_1.IThemeService),
            __param(9, editorGroupsService_1.IEditorGroupsService),
            __param(10, textfiles_1.ITextFileService),
            __param(11, windows_1.IWindowsService),
            __param(12, preferences_1.IPreferencesService),
            __param(13, windows_1.IWindowService)
        ], TextFileEditor);
        return TextFileEditor;
    }(textEditor_1.BaseTextEditor));
    exports.TextFileEditor = TextFileEditor;
});























define(__m[396/*vs/workbench/parts/quickopen/browser/viewPickerHandler*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,67/*vs/base/parts/quickopen/browser/quickOpenModel*/,53/*vs/workbench/browser/quickopen*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,173/*vs/workbench/parts/output/common/output*/,269/*vs/workbench/parts/terminal/common/terminal*/,81/*vs/workbench/services/panel/common/panelService*/,46/*vs/platform/quickOpen/common/quickOpen*/,15/*vs/base/common/actions*/,31/*vs/platform/keybinding/common/keybinding*/,22/*vs/base/common/strings*/,69/*vs/base/common/filters*/,108/*vs/workbench/common/views*/,10/*vs/platform/contextkey/common/contextkey*/,9/*vs/platform/registry/common/platform*/]), function (require, exports, winjs_base_1, nls, quickOpenModel_1, quickopen_1, viewlet_1, output_1, terminal_1, panelService_1, quickOpen_1, actions_1, keybinding_1, strings_1, filters_1, views_1, contextkey_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VIEW_PICKER_PREFIX = 'view ';
    var ViewEntry = /** @class */ (function (_super) {
        __extends(ViewEntry, _super);
        function ViewEntry(label, category, open) {
            var _this = _super.call(this) || this;
            _this.label = label;
            _this.category = category;
            _this.open = open;
            return _this;
        }
        ViewEntry.prototype.getLabel = function () {
            return this.label;
        };
        ViewEntry.prototype.getCategory = function () {
            return this.category;
        };
        ViewEntry.prototype.getAriaLabel = function () {
            return nls.localize('entryAriaLabel', "{0}, view picker", this.getLabel());
        };
        ViewEntry.prototype.run = function (mode, context) {
            if (mode === 1 /* OPEN */) {
                return this.runOpen(context);
            }
            return _super.prototype.run.call(this, mode, context);
        };
        ViewEntry.prototype.runOpen = function (context) {
            var _this = this;
            setTimeout(function () {
                _this.open();
            }, 0);
            return true;
        };
        return ViewEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.ViewEntry = ViewEntry;
    var ViewPickerHandler = /** @class */ (function (_super) {
        __extends(ViewPickerHandler, _super);
        function ViewPickerHandler(viewletService, viewsService, outputService, terminalService, panelService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.viewletService = viewletService;
            _this.viewsService = viewsService;
            _this.outputService = outputService;
            _this.terminalService = terminalService;
            _this.panelService = panelService;
            _this.contextKeyService = contextKeyService;
            return _this;
        }
        ViewPickerHandler.prototype.getResults = function (searchValue, token) {
            searchValue = searchValue.trim();
            var normalizedSearchValueLowercase = strings_1.stripWildcards(searchValue).toLowerCase();
            var viewEntries = this.getViewEntries();
            var entries = viewEntries.filter(function (e) {
                if (!searchValue) {
                    return true;
                }
                var highlights = filters_1.matchesFuzzy(normalizedSearchValueLowercase, e.getLabel(), true);
                if (highlights) {
                    e.setHighlights(highlights);
                }
                if (!highlights && !strings_1.fuzzyContains(e.getCategory(), normalizedSearchValueLowercase)) {
                    return false;
                }
                return true;
            });
            var lastCategory;
            entries.forEach(function (e, index) {
                if (lastCategory !== e.getCategory()) {
                    lastCategory = e.getCategory();
                    e.setShowBorder(index > 0);
                    e.setGroupLabel(lastCategory);
                }
                else {
                    e.setShowBorder(false);
                    e.setGroupLabel(void 0);
                }
            });
            return winjs_base_1.TPromise.as(new quickOpenModel_1.QuickOpenModel(entries));
        };
        ViewPickerHandler.prototype.getViewEntries = function () {
            var _this = this;
            var viewEntries = [];
            var getViewEntriesForViewlet = function (viewlet, viewContainer) {
                var views = views_1.ViewsRegistry.getViews(viewContainer);
                var result = [];
                if (views.length) {
                    var _loop_1 = function (view) {
                        if (_this.contextKeyService.contextMatchesRules(view.when)) {
                            result.push(new ViewEntry(view.name, viewlet.name, function () { return _this.viewsService.openView(view.id, true); }));
                        }
                    };
                    for (var _i = 0, views_2 = views; _i < views_2.length; _i++) {
                        var view = views_2[_i];
                        _loop_1(view);
                    }
                }
                return result;
            };
            // Viewlets
            var viewlets = this.viewletService.getViewlets();
            viewlets.forEach(function (viewlet, index) { return viewEntries.push(new ViewEntry(viewlet.name, nls.localize('views', "Views"), function () { return _this.viewletService.openViewlet(viewlet.id, true); })); });
            // Panels
            var panels = this.panelService.getPanels();
            panels.forEach(function (panel, index) { return viewEntries.push(new ViewEntry(panel.name, nls.localize('panels', "Panels"), function () { return _this.panelService.openPanel(panel.id, true); })); });
            // Viewlet Views
            viewlets.forEach(function (viewlet, index) {
                var viewContainer = platform_1.Registry.as(views_1.Extensions.ViewContainersRegistry).get(viewlet.id);
                if (viewContainer) {
                    var viewEntriesForViewlet = getViewEntriesForViewlet(viewlet, viewContainer);
                    viewEntries.push.apply(viewEntries, viewEntriesForViewlet);
                }
            });
            // Terminals
            var terminalsCategory = nls.localize('terminals', "Terminal");
            this.terminalService.terminalTabs.forEach(function (tab, tabIndex) {
                tab.terminalInstances.forEach(function (terminal, terminalIndex) {
                    var index = tabIndex + 1 + "." + (terminalIndex + 1);
                    var entry = new ViewEntry(nls.localize('terminalTitle', "{0}: {1}", index, terminal.title), terminalsCategory, function () {
                        _this.terminalService.showPanel(true).then(function () {
                            _this.terminalService.setActiveInstance(terminal);
                        });
                    });
                    viewEntries.push(entry);
                });
            });
            // Output Channels
            var channels = this.outputService.getChannelDescriptors();
            channels.forEach(function (channel, index) {
                var outputCategory = nls.localize('channels', "Output");
                var entry = new ViewEntry(channel.label, outputCategory, function () { return _this.outputService.showChannel(channel.id); });
                viewEntries.push(entry);
            });
            return viewEntries;
        };
        ViewPickerHandler.prototype.getAutoFocus = function (searchValue, context) {
            return {
                autoFocusFirstEntry: !!searchValue || !!context.quickNavigateConfiguration
            };
        };
        ViewPickerHandler.ID = 'workbench.picker.views';
        ViewPickerHandler = __decorate([
            __param(0, viewlet_1.IViewletService),
            __param(1, views_1.IViewsService),
            __param(2, output_1.IOutputService),
            __param(3, terminal_1.ITerminalService),
            __param(4, panelService_1.IPanelService),
            __param(5, contextkey_1.IContextKeyService)
        ], ViewPickerHandler);
        return ViewPickerHandler;
    }(quickopen_1.QuickOpenHandler));
    exports.ViewPickerHandler = ViewPickerHandler;
    var OpenViewPickerAction = /** @class */ (function (_super) {
        __extends(OpenViewPickerAction, _super);
        function OpenViewPickerAction(id, label, quickOpenService) {
            return _super.call(this, id, label, exports.VIEW_PICKER_PREFIX, quickOpenService) || this;
        }
        OpenViewPickerAction.ID = 'workbench.action.openView';
        OpenViewPickerAction.LABEL = nls.localize('openView', "Open View");
        OpenViewPickerAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService)
        ], OpenViewPickerAction);
        return OpenViewPickerAction;
    }(quickopen_1.QuickOpenAction));
    exports.OpenViewPickerAction = OpenViewPickerAction;
    var QuickOpenViewPickerAction = /** @class */ (function (_super) {
        __extends(QuickOpenViewPickerAction, _super);
        function QuickOpenViewPickerAction(id, label, quickOpenService, keybindingService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.keybindingService = keybindingService;
            return _this;
        }
        QuickOpenViewPickerAction.prototype.run = function () {
            var keys = this.keybindingService.lookupKeybindings(this.id);
            this.quickOpenService.show(exports.VIEW_PICKER_PREFIX, { quickNavigateConfiguration: { keybindings: keys } });
            return winjs_base_1.TPromise.as(true);
        };
        QuickOpenViewPickerAction.ID = 'workbench.action.quickOpenView';
        QuickOpenViewPickerAction.LABEL = nls.localize('quickOpenView', "Quick Open View");
        QuickOpenViewPickerAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, keybinding_1.IKeybindingService)
        ], QuickOpenViewPickerAction);
        return QuickOpenViewPickerAction;
    }(actions_1.Action));
    exports.QuickOpenViewPickerAction = QuickOpenViewPickerAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[395/*vs/workbench/parts/quickopen/browser/quickopen.contribution*/], __M([0/*require*/,1/*exports*/,18/*vs/base/common/platform*/,2/*vs/nls*/,53/*vs/workbench/browser/quickopen*/,9/*vs/platform/registry/common/platform*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,293/*vs/workbench/parts/quickopen/browser/gotoSymbolHandler*/,301/*vs/workbench/parts/quickopen/browser/commandsHandler*/,291/*vs/workbench/parts/quickopen/browser/gotoLineHandler*/,295/*vs/workbench/parts/quickopen/browser/helpHandler*/,396/*vs/workbench/parts/quickopen/browser/viewPickerHandler*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/,10/*vs/platform/contextkey/common/contextkey*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/]), function (require, exports, env, nls, quickopen_1, platform_1, actions_1, actions_2, gotoSymbolHandler_1, commandsHandler_1, gotoLineHandler_1, helpHandler_1, viewPickerHandler_1, quickopen_2, contextkey_1, keybindingsRegistry_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Register Actions
    var registry = platform_1.Registry.as(actions_2.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(commandsHandler_1.ClearCommandHistoryAction, commandsHandler_1.ClearCommandHistoryAction.ID, commandsHandler_1.ClearCommandHistoryAction.LABEL), 'Clear Command History');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(commandsHandler_1.ShowAllCommandsAction, commandsHandler_1.ShowAllCommandsAction.ID, commandsHandler_1.ShowAllCommandsAction.LABEL, {
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 46 /* KEY_P */,
        secondary: [59 /* F1 */]
    }), 'Show All Commands');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(gotoLineHandler_1.GotoLineAction, gotoLineHandler_1.GotoLineAction.ID, gotoLineHandler_1.GotoLineAction.LABEL, {
        primary: 2048 /* CtrlCmd */ | 37 /* KEY_G */,
        mac: { primary: 256 /* WinCtrl */ | 37 /* KEY_G */ }
    }), 'Go to Line...');
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(gotoSymbolHandler_1.GotoSymbolAction, gotoSymbolHandler_1.GotoSymbolAction.ID, gotoSymbolHandler_1.GotoSymbolAction.LABEL, {
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 45 /* KEY_O */
    }), 'Go to Symbol in File...');
    var inViewsPickerContextKey = 'inViewsPicker';
    var inViewsPickerContext = contextkey_1.ContextKeyExpr.and(quickopen_2.inQuickOpenContext, contextkey_1.ContextKeyExpr.has(inViewsPickerContextKey));
    var viewPickerKeybinding = { primary: 2048 /* CtrlCmd */ | 47 /* KEY_Q */, mac: { primary: 256 /* WinCtrl */ | 47 /* KEY_Q */ }, linux: { primary: null } };
    var viewCategory = nls.localize('view', "View");
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(viewPickerHandler_1.OpenViewPickerAction, viewPickerHandler_1.OpenViewPickerAction.ID, viewPickerHandler_1.OpenViewPickerAction.LABEL), 'View: Open View', viewCategory);
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(viewPickerHandler_1.QuickOpenViewPickerAction, viewPickerHandler_1.QuickOpenViewPickerAction.ID, viewPickerHandler_1.QuickOpenViewPickerAction.LABEL, viewPickerKeybinding), 'View: Quick Open View', viewCategory);
    var quickOpenNavigateNextInViewPickerId = 'workbench.action.quickOpenNavigateNextInViewPicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigateNextInViewPickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_2.getQuickNavigateHandler(quickOpenNavigateNextInViewPickerId, true),
        when: inViewsPickerContext,
        primary: viewPickerKeybinding.primary,
        linux: viewPickerKeybinding.linux,
        mac: viewPickerKeybinding.mac
    });
    var quickOpenNavigatePreviousInViewPickerId = 'workbench.action.quickOpenNavigatePreviousInViewPicker';
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: quickOpenNavigatePreviousInViewPickerId,
        weight: 200 /* WorkbenchContrib */ + 50,
        handler: quickopen_2.getQuickNavigateHandler(quickOpenNavigatePreviousInViewPickerId, false),
        when: inViewsPickerContext,
        primary: viewPickerKeybinding.primary | 1024 /* Shift */,
        linux: viewPickerKeybinding.linux,
        mac: {
            primary: viewPickerKeybinding.mac.primary | 1024 /* Shift */
        }
    });
    // Register Quick Open Handler
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(commandsHandler_1.CommandsHandler, commandsHandler_1.CommandsHandler.ID, commandsHandler_1.ALL_COMMANDS_PREFIX, 'inCommandsPicker', nls.localize('commandsHandlerDescriptionDefault', "Show and Run Commands")));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(gotoLineHandler_1.GotoLineHandler, gotoLineHandler_1.GotoLineHandler.ID, gotoLineHandler_1.GOTO_LINE_PREFIX, null, [
        {
            prefix: gotoLineHandler_1.GOTO_LINE_PREFIX,
            needsEditor: true,
            description: env.isMacintosh ? nls.localize('gotoLineDescriptionMac', "Go to Line") : nls.localize('gotoLineDescriptionWin', "Go to Line")
        },
    ]));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(gotoSymbolHandler_1.GotoSymbolHandler, gotoSymbolHandler_1.GotoSymbolHandler.ID, gotoSymbolHandler_1.GOTO_SYMBOL_PREFIX, 'inFileSymbolsPicker', [
        {
            prefix: gotoSymbolHandler_1.GOTO_SYMBOL_PREFIX,
            needsEditor: true,
            description: nls.localize('gotoSymbolDescription', "Go to Symbol in File")
        },
        {
            prefix: gotoSymbolHandler_1.GOTO_SYMBOL_PREFIX + gotoSymbolHandler_1.SCOPE_PREFIX,
            needsEditor: true,
            description: nls.localize('gotoSymbolDescriptionScoped', "Go to Symbol in File by Category")
        }
    ]));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(helpHandler_1.HelpHandler, helpHandler_1.HelpHandler.ID, helpHandler_1.HELP_PREFIX, null, nls.localize('helpDescription', "Show Help")));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(viewPickerHandler_1.ViewPickerHandler, viewPickerHandler_1.ViewPickerHandler.ID, viewPickerHandler_1.VIEW_PICKER_PREFIX, inViewsPickerContextKey, [
        {
            prefix: viewPickerHandler_1.VIEW_PICKER_PREFIX,
            needsEditor: false,
            description: nls.localize('viewPickerDescription', "Open View")
        }
    ]));
    // View menu
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {
        group: '1_open',
        command: {
            id: commandsHandler_1.ShowAllCommandsAction.ID,
            title: nls.localize({ key: 'miCommandPalette', comment: ['&& denotes a mnemonic'] }, "&&Command Palette...")
        },
        order: 1
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {
        group: '1_open',
        command: {
            id: viewPickerHandler_1.OpenViewPickerAction.ID,
            title: nls.localize({ key: 'miOpenView', comment: ['&& denotes a mnemonic'] }, "&&Open View...")
        },
        order: 2
    });
    // Go to menu
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {
        group: 'z_go_to',
        command: {
            id: 'workbench.action.gotoSymbol',
            title: nls.localize({ key: 'miGotoSymbolInFile', comment: ['&& denotes a mnemonic'] }, "Go to &&Symbol in File...")
        },
        order: 2
    });
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {
        group: 'z_go_to',
        command: {
            id: 'workbench.action.gotoLine',
            title: nls.localize({ key: 'miGotoLine', comment: ['&& denotes a mnemonic'] }, "Go to &&Line...")
        },
        order: 7
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[141/*vs/workbench/parts/search/browser/searchActions*/], __M([0/*require*/,1/*exports*/,8/*vs/base/browser/dom*/,15/*vs/base/common/actions*/,65/*vs/base/common/keyCodes*/,83/*vs/base/common/labels*/,26/*vs/base/common/network*/,18/*vs/base/common/platform*/,5/*vs/base/common/winjs.base*/,2/*vs/nls*/,79/*vs/platform/clipboard/common/clipboardService*/,31/*vs/platform/keybinding/common/keybinding*/,71/*vs/platform/search/common/search*/,148/*vs/workbench/parts/search/common/constants*/,119/*vs/workbench/parts/search/common/replace*/,106/*vs/workbench/parts/search/common/searchModel*/,11/*vs/workbench/services/editor/common/editorService*/,81/*vs/workbench/services/panel/common/panelService*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,24/*vs/base/common/paths*/,33/*vs/workbench/services/group/common/editorGroupsService*/]), function (require, exports, DOM, actions_1, keyCodes_1, labels_1, network_1, platform_1, winjs_base_1, nls, clipboardService_1, keybinding_1, search_1, Constants, replace_1, searchModel_1, editorService_1, panelService_1, viewlet_1, paths_1, editorGroupsService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSearchViewFocused(viewletService, panelService) {
        var searchView = getSearchView(viewletService, panelService);
        var activeElement = document.activeElement;
        return searchView && activeElement && DOM.isAncestor(activeElement, searchView.getContainer());
    }
    exports.isSearchViewFocused = isSearchViewFocused;
    function appendKeyBindingLabel(label, keyBinding, keyBindingService2) {
        if (typeof keyBinding === 'number') {
            var resolvedKeybindings = keyBindingService2.resolveKeybinding(keyCodes_1.createKeybinding(keyBinding, platform_1.OS));
            return doAppendKeyBindingLabel(label, resolvedKeybindings.length > 0 ? resolvedKeybindings[0] : null);
        }
        else {
            return doAppendKeyBindingLabel(label, keyBinding);
        }
    }
    exports.appendKeyBindingLabel = appendKeyBindingLabel;
    function openSearchView(viewletService, panelService, focus) {
        if (viewletService.getViewlets().filter(function (v) { return v.id === search_1.VIEW_ID; }).length) {
            return viewletService.openViewlet(search_1.VIEW_ID, focus).then(function (viewlet) { return viewlet; });
        }
        return panelService.openPanel(search_1.VIEW_ID, focus).then(function (panel) { return panel; });
    }
    exports.openSearchView = openSearchView;
    function getSearchView(viewletService, panelService) {
        var activeViewlet = viewletService.getActiveViewlet();
        if (activeViewlet && activeViewlet.getId() === search_1.VIEW_ID) {
            return activeViewlet;
        }
        var activePanel = panelService.getActivePanel();
        if (activePanel && activePanel.getId() === search_1.VIEW_ID) {
            return activePanel;
        }
        return undefined;
    }
    exports.getSearchView = getSearchView;
    function doAppendKeyBindingLabel(label, keyBinding) {
        return keyBinding ? label + ' (' + keyBinding.getLabel() + ')' : label;
    }
    exports.toggleCaseSensitiveCommand = function (accessor) {
        var searchView = getSearchView(accessor.get(viewlet_1.IViewletService), accessor.get(panelService_1.IPanelService));
        searchView.toggleCaseSensitive();
    };
    exports.toggleWholeWordCommand = function (accessor) {
        var searchView = getSearchView(accessor.get(viewlet_1.IViewletService), accessor.get(panelService_1.IPanelService));
        searchView.toggleWholeWords();
    };
    exports.toggleRegexCommand = function (accessor) {
        var searchView = getSearchView(accessor.get(viewlet_1.IViewletService), accessor.get(panelService_1.IPanelService));
        searchView.toggleRegex();
    };
    var FocusNextInputAction = /** @class */ (function (_super) {
        __extends(FocusNextInputAction, _super);
        function FocusNextInputAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            return _this;
        }
        FocusNextInputAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            searchView.focusNextInputBox();
            return winjs_base_1.TPromise.as(null);
        };
        FocusNextInputAction.ID = 'search.focus.nextInputBox';
        FocusNextInputAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], FocusNextInputAction);
        return FocusNextInputAction;
    }(actions_1.Action));
    exports.FocusNextInputAction = FocusNextInputAction;
    var FocusPreviousInputAction = /** @class */ (function (_super) {
        __extends(FocusPreviousInputAction, _super);
        function FocusPreviousInputAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            return _this;
        }
        FocusPreviousInputAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            searchView.focusPreviousInputBox();
            return winjs_base_1.TPromise.as(null);
        };
        FocusPreviousInputAction.ID = 'search.focus.previousInputBox';
        FocusPreviousInputAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], FocusPreviousInputAction);
        return FocusPreviousInputAction;
    }(actions_1.Action));
    exports.FocusPreviousInputAction = FocusPreviousInputAction;
    var FindOrReplaceInFilesAction = /** @class */ (function (_super) {
        __extends(FindOrReplaceInFilesAction, _super);
        function FindOrReplaceInFilesAction(id, label, viewletService, panelService, expandSearchReplaceWidget) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.expandSearchReplaceWidget = expandSearchReplaceWidget;
            return _this;
        }
        FindOrReplaceInFilesAction.prototype.run = function () {
            var _this = this;
            return openSearchView(this.viewletService, this.panelService, false).then(function (openedView) {
                var searchAndReplaceWidget = openedView.searchAndReplaceWidget;
                searchAndReplaceWidget.toggleReplace(_this.expandSearchReplaceWidget);
                var updatedText = openedView.updateTextFromSelection(!_this.expandSearchReplaceWidget);
                openedView.searchAndReplaceWidget.focus(undefined, updatedText, updatedText);
            });
        };
        return FindOrReplaceInFilesAction;
    }(actions_1.Action));
    exports.FindOrReplaceInFilesAction = FindOrReplaceInFilesAction;
    var FindInFilesAction = /** @class */ (function (_super) {
        __extends(FindInFilesAction, _super);
        function FindInFilesAction(id, label, viewletService, panelService) {
            return _super.call(this, id, label, viewletService, panelService, /*expandSearchReplaceWidget=*/ false) || this;
        }
        FindInFilesAction.LABEL = nls.localize('findInFiles', "Find in Files");
        FindInFilesAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], FindInFilesAction);
        return FindInFilesAction;
    }(FindOrReplaceInFilesAction));
    exports.FindInFilesAction = FindInFilesAction;
    var OpenSearchViewletAction = /** @class */ (function (_super) {
        __extends(OpenSearchViewletAction, _super);
        function OpenSearchViewletAction(id, label, viewletService, panelService, editorGroupService) {
            var _this = _super.call(this, id, label, viewletService, panelService, /*expandSearchReplaceWidget=*/ false) || this;
            _this.editorGroupService = editorGroupService;
            return _this;
        }
        OpenSearchViewletAction.prototype.run = function () {
            // Pass focus to viewlet if not open or focused
            if (this.otherViewletShowing() || !isSearchViewFocused(this.viewletService, this.panelService)) {
                return _super.prototype.run.call(this);
            }
            // Otherwise pass focus to editor group
            this.editorGroupService.activeGroup.focus();
            return winjs_base_1.TPromise.as(true);
        };
        OpenSearchViewletAction.prototype.otherViewletShowing = function () {
            return !getSearchView(this.viewletService, this.panelService);
        };
        OpenSearchViewletAction.LABEL = nls.localize('showSearch', "Show Search");
        OpenSearchViewletAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService),
            __param(4, editorGroupsService_1.IEditorGroupsService)
        ], OpenSearchViewletAction);
        return OpenSearchViewletAction;
    }(FindOrReplaceInFilesAction));
    exports.OpenSearchViewletAction = OpenSearchViewletAction;
    var ReplaceInFilesAction = /** @class */ (function (_super) {
        __extends(ReplaceInFilesAction, _super);
        function ReplaceInFilesAction(id, label, viewletService, panelService) {
            return _super.call(this, id, label, viewletService, panelService, /*expandSearchReplaceWidget=*/ true) || this;
        }
        ReplaceInFilesAction.ID = 'workbench.action.replaceInFiles';
        ReplaceInFilesAction.LABEL = nls.localize('replaceInFiles', "Replace in Files");
        ReplaceInFilesAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], ReplaceInFilesAction);
        return ReplaceInFilesAction;
    }(FindOrReplaceInFilesAction));
    exports.ReplaceInFilesAction = ReplaceInFilesAction;
    var CloseReplaceAction = /** @class */ (function (_super) {
        __extends(CloseReplaceAction, _super);
        function CloseReplaceAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            return _this;
        }
        CloseReplaceAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            searchView.searchAndReplaceWidget.toggleReplace(false);
            searchView.searchAndReplaceWidget.focus();
            return winjs_base_1.TPromise.as(null);
        };
        CloseReplaceAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], CloseReplaceAction);
        return CloseReplaceAction;
    }(actions_1.Action));
    exports.CloseReplaceAction = CloseReplaceAction;
    var RefreshAction = /** @class */ (function (_super) {
        __extends(RefreshAction, _super);
        function RefreshAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label, 'search-action refresh') || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.update();
            return _this;
        }
        RefreshAction.prototype.update = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            this.enabled = searchView && searchView.isSearchSubmitted();
        };
        RefreshAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            if (searchView) {
                searchView.onQueryChanged();
            }
            return winjs_base_1.TPromise.as(null);
        };
        RefreshAction.ID = 'search.action.refreshSearchResults';
        RefreshAction.LABEL = nls.localize('RefreshAction.label', "Refresh");
        RefreshAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], RefreshAction);
        return RefreshAction;
    }(actions_1.Action));
    exports.RefreshAction = RefreshAction;
    var CollapseDeepestExpandedLevelAction = /** @class */ (function (_super) {
        __extends(CollapseDeepestExpandedLevelAction, _super);
        function CollapseDeepestExpandedLevelAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label, 'search-action collapse') || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.update();
            return _this;
        }
        CollapseDeepestExpandedLevelAction.prototype.update = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            this.enabled = searchView && searchView.hasSearchResults();
        };
        CollapseDeepestExpandedLevelAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            if (searchView) {
                var viewer = searchView.getControl();
                if (viewer.getHighlight()) {
                    return winjs_base_1.TPromise.as(null); // Global action disabled if user is in edit mode from another action
                }
                /**
                 * The hierarchy is FolderMatch, FileMatch, Match. If the top level is FileMatches, then there is only
                 * one level to collapse so collapse everything. If FolderMatch, check if there are visible grandchildren,
                 * i.e. if Matches are returned by the navigator, and if so, collapse to them, otherwise collapse all levels.
                 */
                var navigator_1 = viewer.getNavigator();
                var node = navigator_1.first();
                var collapseFileMatchLevel = false;
                if (node instanceof searchModel_1.FolderMatch) {
                    while (node = navigator_1.next()) {
                        if (node instanceof searchModel_1.Match) {
                            collapseFileMatchLevel = true;
                            break;
                        }
                    }
                }
                if (collapseFileMatchLevel) {
                    node = navigator_1.first();
                    do {
                        if (node instanceof searchModel_1.FileMatch) {
                            viewer.collapse(node);
                        }
                    } while (node = navigator_1.next());
                }
                else {
                    viewer.collapseAll();
                }
                viewer.clearSelection();
                viewer.clearFocus();
                viewer.domFocus();
                viewer.focusFirst();
            }
            return winjs_base_1.TPromise.as(null);
        };
        CollapseDeepestExpandedLevelAction.ID = 'search.action.collapseSearchResults';
        CollapseDeepestExpandedLevelAction.LABEL = nls.localize('CollapseDeepestExpandedLevelAction.label', "Collapse All");
        CollapseDeepestExpandedLevelAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], CollapseDeepestExpandedLevelAction);
        return CollapseDeepestExpandedLevelAction;
    }(actions_1.Action));
    exports.CollapseDeepestExpandedLevelAction = CollapseDeepestExpandedLevelAction;
    var ClearSearchResultsAction = /** @class */ (function (_super) {
        __extends(ClearSearchResultsAction, _super);
        function ClearSearchResultsAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label, 'search-action clear-search-results') || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.update();
            return _this;
        }
        ClearSearchResultsAction.prototype.update = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            this.enabled = searchView && searchView.isSearchSubmitted();
        };
        ClearSearchResultsAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            if (searchView) {
                searchView.clearSearchResults();
            }
            return winjs_base_1.TPromise.as(null);
        };
        ClearSearchResultsAction.ID = 'search.action.clearSearchResults';
        ClearSearchResultsAction.LABEL = nls.localize('ClearSearchResultsAction.label', "Clear Search Results");
        ClearSearchResultsAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], ClearSearchResultsAction);
        return ClearSearchResultsAction;
    }(actions_1.Action));
    exports.ClearSearchResultsAction = ClearSearchResultsAction;
    var CancelSearchAction = /** @class */ (function (_super) {
        __extends(CancelSearchAction, _super);
        function CancelSearchAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label, 'search-action cancel-search') || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.update();
            return _this;
        }
        CancelSearchAction.prototype.update = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            this.enabled = searchView && searchView.isSearching();
        };
        CancelSearchAction.prototype.run = function () {
            var searchView = getSearchView(this.viewletService, this.panelService);
            if (searchView) {
                searchView.cancelSearch();
            }
            return winjs_base_1.TPromise.as(null);
        };
        CancelSearchAction.ID = 'search.action.cancelSearch';
        CancelSearchAction.LABEL = nls.localize('CancelSearchAction.label', "Cancel Search");
        CancelSearchAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], CancelSearchAction);
        return CancelSearchAction;
    }(actions_1.Action));
    exports.CancelSearchAction = CancelSearchAction;
    var FocusNextSearchResultAction = /** @class */ (function (_super) {
        __extends(FocusNextSearchResultAction, _super);
        function FocusNextSearchResultAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            return _this;
        }
        FocusNextSearchResultAction.prototype.run = function () {
            return openSearchView(this.viewletService, this.panelService).then(function (searchView) {
                searchView.selectNextMatch();
            });
        };
        FocusNextSearchResultAction.ID = 'search.action.focusNextSearchResult';
        FocusNextSearchResultAction.LABEL = nls.localize('FocusNextSearchResult.label', "Focus Next Search Result");
        FocusNextSearchResultAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], FocusNextSearchResultAction);
        return FocusNextSearchResultAction;
    }(actions_1.Action));
    exports.FocusNextSearchResultAction = FocusNextSearchResultAction;
    var FocusPreviousSearchResultAction = /** @class */ (function (_super) {
        __extends(FocusPreviousSearchResultAction, _super);
        function FocusPreviousSearchResultAction(id, label, viewletService, panelService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            return _this;
        }
        FocusPreviousSearchResultAction.prototype.run = function () {
            return openSearchView(this.viewletService, this.panelService).then(function (searchView) {
                searchView.selectPreviousMatch();
            });
        };
        FocusPreviousSearchResultAction.ID = 'search.action.focusPreviousSearchResult';
        FocusPreviousSearchResultAction.LABEL = nls.localize('FocusPreviousSearchResult.label', "Focus Previous Search Result");
        FocusPreviousSearchResultAction = __decorate([
            __param(2, viewlet_1.IViewletService),
            __param(3, panelService_1.IPanelService)
        ], FocusPreviousSearchResultAction);
        return FocusPreviousSearchResultAction;
    }(actions_1.Action));
    exports.FocusPreviousSearchResultAction = FocusPreviousSearchResultAction;
    var AbstractSearchAndReplaceAction = /** @class */ (function (_super) {
        __extends(AbstractSearchAndReplaceAction, _super);
        function AbstractSearchAndReplaceAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns element to focus after removing the given element
         */
        AbstractSearchAndReplaceAction.prototype.getElementToFocusAfterRemoved = function (viewer, elementToBeRemoved) {
            var elementToFocus = this.getNextElementAfterRemoved(viewer, elementToBeRemoved);
            if (!elementToFocus) {
                elementToFocus = this.getPreviousElementAfterRemoved(viewer, elementToBeRemoved);
            }
            return elementToFocus;
        };
        AbstractSearchAndReplaceAction.prototype.getNextElementAfterRemoved = function (viewer, element) {
            var navigator = this.getNavigatorAt(element, viewer);
            if (element instanceof searchModel_1.FolderMatch) {
                // If file match is removed then next element is the next file match
                while (!!navigator.next() && !(navigator.current() instanceof searchModel_1.FolderMatch)) { }
            }
            else if (element instanceof searchModel_1.FileMatch) {
                // If file match is removed then next element is the next file match
                while (!!navigator.next() && !(navigator.current() instanceof searchModel_1.FileMatch)) { }
            }
            else {
                while (navigator.next() && !(navigator.current() instanceof searchModel_1.Match)) {
                    viewer.expand(navigator.current());
                }
            }
            return navigator.current();
        };
        AbstractSearchAndReplaceAction.prototype.getPreviousElementAfterRemoved = function (viewer, element) {
            var navigator = this.getNavigatorAt(element, viewer);
            var previousElement = navigator.previous();
            // If this is the only match, then the file/folder match is also removed
            // Hence take the previous element.
            var parent = element.parent();
            if (parent === previousElement) {
                previousElement = navigator.previous();
            }
            if (parent instanceof searchModel_1.FileMatch && parent.parent() === previousElement) {
                previousElement = navigator.previous();
            }
            // If the previous element is a File or Folder, expand it and go to its last child.
            // Spell out the two cases, would be too easy to create an infinite loop, like by adding another level...
            if (element instanceof searchModel_1.Match && previousElement && previousElement instanceof searchModel_1.FolderMatch) {
                navigator.next();
                viewer.expand(previousElement);
                previousElement = navigator.previous();
            }
            if (element instanceof searchModel_1.Match && previousElement && previousElement instanceof searchModel_1.FileMatch) {
                navigator.next();
                viewer.expand(previousElement);
                previousElement = navigator.previous();
            }
            return previousElement;
        };
        AbstractSearchAndReplaceAction.prototype.getNavigatorAt = function (element, viewer) {
            var navigator = viewer.getNavigator();
            while (navigator.current() !== element && !!navigator.next()) { }
            return navigator;
        };
        return AbstractSearchAndReplaceAction;
    }(actions_1.Action));
    exports.AbstractSearchAndReplaceAction = AbstractSearchAndReplaceAction;
    var RemoveAction = /** @class */ (function (_super) {
        __extends(RemoveAction, _super);
        function RemoveAction(viewer, element) {
            var _this = _super.call(this, 'remove', RemoveAction.LABEL, 'action-remove') || this;
            _this.viewer = viewer;
            _this.element = element;
            return _this;
        }
        RemoveAction.prototype.run = function () {
            var currentFocusElement = this.viewer.getFocus();
            var nextFocusElement = !currentFocusElement || currentFocusElement instanceof searchModel_1.SearchResult || elementIsEqualOrParent(currentFocusElement, this.element) ?
                this.getElementToFocusAfterRemoved(this.viewer, this.element) :
                null;
            if (nextFocusElement) {
                this.viewer.reveal(nextFocusElement);
                this.viewer.setFocus(nextFocusElement);
            }
            var elementToRefresh;
            var element = this.element;
            if (element instanceof searchModel_1.FolderMatch) {
                var parent_1 = element.parent();
                parent_1.remove(element);
                elementToRefresh = parent_1;
            }
            else if (element instanceof searchModel_1.FileMatch) {
                var parent_2 = element.parent();
                parent_2.remove(element);
                elementToRefresh = parent_2;
            }
            else if (element instanceof searchModel_1.Match) {
                var parent_3 = element.parent();
                parent_3.remove(element);
                elementToRefresh = parent_3.count() === 0 ? parent_3.parent() : parent_3;
            }
            this.viewer.domFocus();
            return this.viewer.refresh(elementToRefresh);
        };
        RemoveAction.LABEL = nls.localize('RemoveAction.label', "Dismiss");
        return RemoveAction;
    }(AbstractSearchAndReplaceAction));
    exports.RemoveAction = RemoveAction;
    function elementIsEqualOrParent(element, testParent) {
        do {
            if (element === testParent) {
                return true;
            }
        } while (!(element.parent() instanceof searchModel_1.SearchResult) && (element = element.parent()));
        return false;
    }
    var ReplaceAllAction = /** @class */ (function (_super) {
        __extends(ReplaceAllAction, _super);
        function ReplaceAllAction(viewer, fileMatch, viewlet, keyBindingService) {
            var _this = _super.call(this, Constants.ReplaceAllInFileActionId, appendKeyBindingLabel(ReplaceAllAction.LABEL, keyBindingService.lookupKeybinding(Constants.ReplaceAllInFileActionId), keyBindingService), 'action-replace-all') || this;
            _this.viewer = viewer;
            _this.fileMatch = fileMatch;
            _this.viewlet = viewlet;
            return _this;
        }
        ReplaceAllAction.prototype.run = function () {
            var _this = this;
            var nextFocusElement = this.getElementToFocusAfterRemoved(this.viewer, this.fileMatch);
            return this.fileMatch.parent().replace(this.fileMatch).then(function () {
                if (nextFocusElement) {
                    _this.viewer.setFocus(nextFocusElement);
                }
                _this.viewer.domFocus();
                _this.viewlet.open(_this.fileMatch, true);
            });
        };
        ReplaceAllAction.LABEL = nls.localize('file.replaceAll.label', "Replace All");
        ReplaceAllAction = __decorate([
            __param(3, keybinding_1.IKeybindingService)
        ], ReplaceAllAction);
        return ReplaceAllAction;
    }(AbstractSearchAndReplaceAction));
    exports.ReplaceAllAction = ReplaceAllAction;
    var ReplaceAllInFolderAction = /** @class */ (function (_super) {
        __extends(ReplaceAllInFolderAction, _super);
        function ReplaceAllInFolderAction(viewer, folderMatch, keyBindingService) {
            var _this = _super.call(this, Constants.ReplaceAllInFolderActionId, appendKeyBindingLabel(ReplaceAllInFolderAction.LABEL, keyBindingService.lookupKeybinding(Constants.ReplaceAllInFolderActionId), keyBindingService), 'action-replace-all') || this;
            _this.viewer = viewer;
            _this.folderMatch = folderMatch;
            return _this;
        }
        ReplaceAllInFolderAction.prototype.run = function () {
            var _this = this;
            var nextFocusElement = this.getElementToFocusAfterRemoved(this.viewer, this.folderMatch);
            return this.folderMatch.replaceAll()
                .then(function () {
                if (nextFocusElement) {
                    _this.viewer.setFocus(nextFocusElement);
                }
                _this.viewer.domFocus();
            });
        };
        ReplaceAllInFolderAction.LABEL = nls.localize('file.replaceAll.label', "Replace All");
        ReplaceAllInFolderAction = __decorate([
            __param(2, keybinding_1.IKeybindingService)
        ], ReplaceAllInFolderAction);
        return ReplaceAllInFolderAction;
    }(AbstractSearchAndReplaceAction));
    exports.ReplaceAllInFolderAction = ReplaceAllInFolderAction;
    var ReplaceAction = /** @class */ (function (_super) {
        __extends(ReplaceAction, _super);
        function ReplaceAction(viewer, element, viewlet, replaceService, keyBindingService, editorService) {
            var _this = _super.call(this, Constants.ReplaceActionId, appendKeyBindingLabel(ReplaceAction.LABEL, keyBindingService.lookupKeybinding(Constants.ReplaceActionId), keyBindingService), 'action-replace') || this;
            _this.viewer = viewer;
            _this.element = element;
            _this.viewlet = viewlet;
            _this.replaceService = replaceService;
            _this.editorService = editorService;
            return _this;
        }
        ReplaceAction.prototype.run = function () {
            var _this = this;
            this.enabled = false;
            return this.element.parent().replace(this.element).then(function () {
                var elementToFocus = _this.getElementToFocusAfterReplace();
                if (elementToFocus) {
                    _this.viewer.setFocus(elementToFocus);
                }
                var elementToShowReplacePreview = _this.getElementToShowReplacePreview(elementToFocus);
                _this.viewer.domFocus();
                if (!elementToShowReplacePreview || _this.hasToOpenFile()) {
                    _this.viewlet.open(_this.element, true);
                }
                else {
                    _this.replaceService.openReplacePreview(elementToShowReplacePreview, true);
                }
            });
        };
        ReplaceAction.prototype.getElementToFocusAfterReplace = function () {
            var navigator = this.viewer.getNavigator();
            var fileMatched = false;
            var elementToFocus = null;
            do {
                elementToFocus = navigator.current();
                if (elementToFocus instanceof searchModel_1.Match) {
                    if (elementToFocus.parent().id() === this.element.parent().id()) {
                        fileMatched = true;
                        if (this.element.range().getStartPosition().isBeforeOrEqual(elementToFocus.range().getStartPosition())) {
                            // Closest next match in the same file
                            break;
                        }
                    }
                    else if (fileMatched) {
                        // First match in the next file (if expanded)
                        break;
                    }
                }
                else if (fileMatched) {
                    if (!this.viewer.isExpanded(elementToFocus)) {
                        // Next file match (if collapsed)
                        break;
                    }
                }
            } while (!!navigator.next());
            return elementToFocus;
        };
        ReplaceAction.prototype.getElementToShowReplacePreview = function (elementToFocus) {
            if (this.hasSameParent(elementToFocus)) {
                return elementToFocus;
            }
            var previousElement = this.getPreviousElementAfterRemoved(this.viewer, this.element);
            if (this.hasSameParent(previousElement)) {
                return previousElement;
            }
            return null;
        };
        ReplaceAction.prototype.hasSameParent = function (element) {
            return element && element instanceof searchModel_1.Match && element.parent().resource() === this.element.parent().resource();
        };
        ReplaceAction.prototype.hasToOpenFile = function () {
            var activeEditor = this.editorService.activeEditor;
            var file = activeEditor ? activeEditor.getResource() : void 0;
            if (file) {
                return file.toString() === this.element.parent().resource().toString();
            }
            return false;
        };
        ReplaceAction.LABEL = nls.localize('match.replace.label', "Replace");
        ReplaceAction = __decorate([
            __param(3, replace_1.IReplaceService),
            __param(4, keybinding_1.IKeybindingService),
            __param(5, editorService_1.IEditorService)
        ], ReplaceAction);
        return ReplaceAction;
    }(AbstractSearchAndReplaceAction));
    exports.ReplaceAction = ReplaceAction;
    function uriToClipboardString(resource) {
        return resource.scheme === network_1.Schemas.file ? paths_1.normalize(labels_1.normalizeDriveLetter(resource.fsPath), true) : resource.toString();
    }
    exports.copyPathCommand = function (accessor, fileMatch) {
        var clipboardService = accessor.get(clipboardService_1.IClipboardService);
        var text = uriToClipboardString(fileMatch.resource());
        clipboardService.writeText(text);
    };
    function matchToString(match) {
        return match.range().startLineNumber + "," + match.range().startColumn + ": " + match.text();
    }
    var lineDelimiter = platform_1.isWindows ? '\r\n' : '\n';
    function fileMatchToString(fileMatch, maxMatches) {
        var matchTextRows = fileMatch.matches()
            .sort(searchModel_1.searchMatchComparer)
            .slice(0, maxMatches)
            .map(matchToString)
            .map(function (matchText) { return '  ' + matchText; });
        return {
            text: "" + uriToClipboardString(fileMatch.resource()) + lineDelimiter + matchTextRows.join(lineDelimiter),
            count: matchTextRows.length
        };
    }
    function folderMatchToString(folderMatch, maxMatches) {
        var fileResults = [];
        var numMatches = 0;
        var matches = folderMatch.matches().sort(searchModel_1.searchMatchComparer);
        for (var i = 0; i < folderMatch.fileCount() && numMatches < maxMatches; i++) {
            var fileResult = fileMatchToString(matches[i], maxMatches - numMatches);
            numMatches += fileResult.count;
            fileResults.push(fileResult.text);
        }
        return {
            text: fileResults.join(lineDelimiter + lineDelimiter),
            count: numMatches
        };
    }
    var maxClipboardMatches = 1e4;
    exports.copyMatchCommand = function (accessor, match) {
        var clipboardService = accessor.get(clipboardService_1.IClipboardService);
        var text;
        if (match instanceof searchModel_1.Match) {
            text = matchToString(match);
        }
        else if (match instanceof searchModel_1.FileMatch) {
            text = fileMatchToString(match, maxClipboardMatches).text;
        }
        else if (match instanceof searchModel_1.FolderMatch) {
            text = folderMatchToString(match, maxClipboardMatches).text;
        }
        if (text) {
            clipboardService.writeText(text);
        }
    };
    function allFolderMatchesToString(folderMatches, maxMatches) {
        var folderResults = [];
        var numMatches = 0;
        folderMatches = folderMatches.sort(searchModel_1.searchMatchComparer);
        for (var i = 0; i < folderMatches.length && numMatches < maxMatches; i++) {
            var folderResult = folderMatchToString(folderMatches[i], maxMatches - numMatches);
            if (folderResult.count) {
                numMatches += folderResult.count;
                folderResults.push(folderResult.text);
            }
        }
        return folderResults.join(lineDelimiter + lineDelimiter);
    }
    exports.copyAllCommand = function (accessor) {
        var viewletService = accessor.get(viewlet_1.IViewletService);
        var panelService = accessor.get(panelService_1.IPanelService);
        var clipboardService = accessor.get(clipboardService_1.IClipboardService);
        var searchView = getSearchView(viewletService, panelService);
        var root = searchView.getControl().getInput();
        var text = allFolderMatchesToString(root.folderMatches(), maxClipboardMatches);
        clipboardService.writeText(text);
    };
    exports.clearHistoryCommand = function (accessor) {
        var searchHistoryService = accessor.get(search_1.ISearchHistoryService);
        searchHistoryService.clearHistory();
    };
    exports.focusSearchListCommand = function (accessor) {
        var viewletService = accessor.get(viewlet_1.IViewletService);
        var panelService = accessor.get(panelService_1.IPanelService);
        openSearchView(viewletService, panelService).then(function (searchView) {
            searchView.moveFocusToResults();
        });
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[389/*vs/workbench/parts/search/browser/searchResultsView*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,35/*vs/base/common/resources*/,24/*vs/base/common/paths*/,8/*vs/base/browser/dom*/,4/*vs/base/common/lifecycle*/,5/*vs/base/common/winjs.base*/,50/*vs/base/browser/ui/actionbar/actionbar*/,342/*vs/base/browser/ui/countBadge/countBadge*/,60/*vs/workbench/browser/labels*/,106/*vs/workbench/parts/search/common/searchModel*/,20/*vs/platform/workspace/common/workspace*/,141/*vs/workbench/parts/search/browser/searchActions*/,3/*vs/platform/instantiation/common/instantiation*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,16/*vs/platform/files/common/files*/,7/*vs/platform/configuration/common/configuration*/,34/*vs/platform/contextview/browser/contextView*/,23/*vs/platform/actions/common/actions*/,51/*vs/platform/list/browser/listService*/,115/*vs/platform/actions/browser/menuItemActionItem*/,59/*vs/platform/label/common/label*/]), function (require, exports, nls, resources, paths, DOM, lifecycle_1, winjs_base_1, actionbar_1, countBadge_1, labels_1, searchModel_1, workspace_1, searchActions_1, instantiation_1, styler_1, themeService_1, files_1, configuration_1, contextView_1, actions_1, listService_1, menuItemActionItem_1, label_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchDataSource = /** @class */ (function () {
        function SearchDataSource(contextService, configurationService) {
            var _this = this;
            this.contextService = contextService;
            this.configurationService = configurationService;
            this.updateIncludeFolderMatch();
            this.listener = this.contextService.onDidChangeWorkbenchState(function () { return _this.updateIncludeFolderMatch(); });
        }
        SearchDataSource.prototype.updateIncludeFolderMatch = function () {
            this.includeFolderMatch = (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */);
        };
        SearchDataSource.prototype.getId = function (tree, element) {
            if (element instanceof searchModel_1.FolderMatch) {
                return element.id();
            }
            if (element instanceof searchModel_1.FileMatch) {
                return element.id();
            }
            if (element instanceof searchModel_1.Match) {
                return element.id();
            }
            return 'root';
        };
        SearchDataSource.prototype._getChildren = function (element) {
            if (element instanceof searchModel_1.FileMatch) {
                return element.matches();
            }
            else if (element instanceof searchModel_1.FolderMatch) {
                return element.matches();
            }
            else if (element instanceof searchModel_1.SearchResult) {
                var folderMatches = element.folderMatches();
                return folderMatches.length > 2 ? // "Other files" + workspace folder = 2
                    folderMatches.filter(function (fm) { return !fm.isEmpty(); }) :
                    element.matches();
            }
            return [];
        };
        SearchDataSource.prototype.getChildren = function (tree, element) {
            return winjs_base_1.TPromise.as(this._getChildren(element));
        };
        SearchDataSource.prototype.hasChildren = function (tree, element) {
            return element instanceof searchModel_1.FileMatch || element instanceof searchModel_1.FolderMatch || element instanceof searchModel_1.SearchResult;
        };
        SearchDataSource.prototype.getParent = function (tree, element) {
            var value = null;
            if (element instanceof searchModel_1.Match) {
                value = element.parent();
            }
            else if (element instanceof searchModel_1.FileMatch) {
                value = this.includeFolderMatch ? element.parent() : element.parent().parent();
            }
            else if (element instanceof searchModel_1.FolderMatch) {
                value = element.parent();
            }
            return winjs_base_1.TPromise.as(value);
        };
        SearchDataSource.prototype.shouldAutoexpand = function (tree, element) {
            var numChildren = this._getChildren(element).length;
            if (numChildren <= 0) {
                return false;
            }
            var collapseOption = this.configurationService.getValue('search.collapseResults');
            if (collapseOption === 'alwaysCollapse') {
                return false;
            }
            else if (collapseOption === 'alwaysExpand') {
                return true;
            }
            return numChildren < SearchDataSource.AUTOEXPAND_CHILD_LIMIT || element instanceof searchModel_1.FolderMatch;
        };
        SearchDataSource.prototype.dispose = function () {
            this.listener = lifecycle_1.dispose(this.listener);
        };
        SearchDataSource.AUTOEXPAND_CHILD_LIMIT = 10;
        SearchDataSource = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, configuration_1.IConfigurationService)
        ], SearchDataSource);
        return SearchDataSource;
    }());
    exports.SearchDataSource = SearchDataSource;
    var SearchSorter = /** @class */ (function () {
        function SearchSorter() {
        }
        SearchSorter.prototype.compare = function (tree, elementA, elementB) {
            return searchModel_1.searchMatchComparer(elementA, elementB);
        };
        return SearchSorter;
    }());
    exports.SearchSorter = SearchSorter;
    var SearchRenderer = /** @class */ (function (_super) {
        __extends(SearchRenderer, _super);
        function SearchRenderer(actionRunner, searchView, instantiationService, themeService, contextService) {
            var _this = _super.call(this) || this;
            _this.searchView = searchView;
            _this.instantiationService = instantiationService;
            _this.themeService = themeService;
            _this.contextService = contextService;
            return _this;
        }
        SearchRenderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        SearchRenderer.prototype.getTemplateId = function (tree, element) {
            if (element instanceof searchModel_1.FolderMatch) {
                return SearchRenderer.FOLDER_MATCH_TEMPLATE_ID;
            }
            else if (element instanceof searchModel_1.FileMatch) {
                return SearchRenderer.FILE_MATCH_TEMPLATE_ID;
            }
            else if (element instanceof searchModel_1.Match) {
                return SearchRenderer.MATCH_TEMPLATE_ID;
            }
            return null;
        };
        SearchRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            if (templateId === SearchRenderer.FOLDER_MATCH_TEMPLATE_ID) {
                return this.renderFolderMatchTemplate(tree, templateId, container);
            }
            if (templateId === SearchRenderer.FILE_MATCH_TEMPLATE_ID) {
                return this.renderFileMatchTemplate(tree, templateId, container);
            }
            if (templateId === SearchRenderer.MATCH_TEMPLATE_ID) {
                return this.renderMatchTemplate(tree, templateId, container);
            }
            return null;
        };
        SearchRenderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            if (SearchRenderer.FOLDER_MATCH_TEMPLATE_ID === templateId) {
                this.renderFolderMatch(tree, element, templateData);
            }
            else if (SearchRenderer.FILE_MATCH_TEMPLATE_ID === templateId) {
                this.renderFileMatch(tree, element, templateData);
            }
            else if (SearchRenderer.MATCH_TEMPLATE_ID === templateId) {
                this.renderMatch(tree, element, templateData);
            }
        };
        SearchRenderer.prototype.renderFolderMatchTemplate = function (tree, templateId, container) {
            var folderMatchElement = DOM.append(container, DOM.$('.foldermatch'));
            var label = this.instantiationService.createInstance(labels_1.FileLabel, folderMatchElement, void 0);
            var badge = new countBadge_1.CountBadge(DOM.append(folderMatchElement, DOM.$('.badge')));
            this._register(styler_1.attachBadgeStyler(badge, this.themeService));
            var actions = new actionbar_1.ActionBar(folderMatchElement, { animated: false });
            return { label: label, badge: badge, actions: actions };
        };
        SearchRenderer.prototype.renderFileMatchTemplate = function (tree, templateId, container) {
            var fileMatchElement = DOM.append(container, DOM.$('.filematch'));
            var label = this.instantiationService.createInstance(labels_1.FileLabel, fileMatchElement, void 0);
            var badge = new countBadge_1.CountBadge(DOM.append(fileMatchElement, DOM.$('.badge')));
            this._register(styler_1.attachBadgeStyler(badge, this.themeService));
            var actions = new actionbar_1.ActionBar(fileMatchElement, { animated: false });
            return { el: fileMatchElement, label: label, badge: badge, actions: actions };
        };
        SearchRenderer.prototype.renderMatchTemplate = function (tree, templateId, container) {
            DOM.addClass(container, 'linematch');
            var parent = DOM.append(container, DOM.$('a.plain.match'));
            var before = DOM.append(parent, DOM.$('span'));
            var match = DOM.append(parent, DOM.$('span.findInFileMatch'));
            var replace = DOM.append(parent, DOM.$('span.replaceMatch'));
            var after = DOM.append(parent, DOM.$('span'));
            var actions = new actionbar_1.ActionBar(container, { animated: false });
            return {
                parent: parent,
                before: before,
                match: match,
                replace: replace,
                after: after,
                actions: actions
            };
        };
        SearchRenderer.prototype.renderFolderMatch = function (tree, folderMatch, templateData) {
            if (folderMatch.hasResource()) {
                var workspaceFolder = this.contextService.getWorkspaceFolder(folderMatch.resource());
                if (workspaceFolder && resources.isEqual(workspaceFolder.uri, folderMatch.resource())) {
                    templateData.label.setFile(folderMatch.resource(), { fileKind: files_1.FileKind.ROOT_FOLDER, hidePath: true });
                }
                else {
                    templateData.label.setFile(folderMatch.resource(), { fileKind: files_1.FileKind.FOLDER });
                }
            }
            else {
                templateData.label.setValue(nls.localize('searchFolderMatch.other.label', "Other files"));
            }
            var count = folderMatch.fileCount();
            templateData.badge.setCount(count);
            templateData.badge.setTitleFormat(count > 1 ? nls.localize('searchFileMatches', "{0} files found", count) : nls.localize('searchFileMatch', "{0} file found", count));
            templateData.actions.clear();
            var input = tree.getInput();
            var actions = [];
            if (input.searchModel.isReplaceActive() && count > 0) {
                actions.push(this.instantiationService.createInstance(searchActions_1.ReplaceAllInFolderAction, tree, folderMatch));
            }
            actions.push(new searchActions_1.RemoveAction(tree, folderMatch));
            templateData.actions.push(actions, { icon: true, label: false });
        };
        SearchRenderer.prototype.renderFileMatch = function (tree, fileMatch, templateData) {
            templateData.el.setAttribute('data-resource', fileMatch.resource().toString());
            templateData.label.setFile(fileMatch.resource(), { hideIcon: false });
            var count = fileMatch.count();
            templateData.badge.setCount(count);
            templateData.badge.setTitleFormat(count > 1 ? nls.localize('searchMatches', "{0} matches found", count) : nls.localize('searchMatch', "{0} match found", count));
            var input = tree.getInput();
            templateData.actions.clear();
            var actions = [];
            if (input.searchModel.isReplaceActive() && count > 0) {
                actions.push(this.instantiationService.createInstance(searchActions_1.ReplaceAllAction, tree, fileMatch, this.searchView));
            }
            actions.push(new searchActions_1.RemoveAction(tree, fileMatch));
            templateData.actions.push(actions, { icon: true, label: false });
        };
        SearchRenderer.prototype.renderMatch = function (tree, match, templateData) {
            var preview = match.preview();
            var searchModel = tree.getInput().searchModel;
            var replace = searchModel.isReplaceActive() && !!searchModel.replaceString;
            templateData.before.textContent = preview.before;
            templateData.match.textContent = preview.inside;
            DOM.toggleClass(templateData.match, 'replace', replace);
            templateData.replace.textContent = replace ? match.replaceString : '';
            templateData.after.textContent = preview.after;
            templateData.parent.title = (preview.before + (replace ? match.replaceString : preview.inside) + preview.after).trim().substr(0, 999);
            templateData.actions.clear();
            if (searchModel.isReplaceActive()) {
                templateData.actions.push([this.instantiationService.createInstance(searchActions_1.ReplaceAction, tree, match, this.searchView), new searchActions_1.RemoveAction(tree, match)], { icon: true, label: false });
            }
            else {
                templateData.actions.push([new searchActions_1.RemoveAction(tree, match)], { icon: true, label: false });
            }
        };
        SearchRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            if (SearchRenderer.FOLDER_MATCH_TEMPLATE_ID === templateId) {
                var template = templateData;
                template.label.dispose();
                template.actions.dispose();
            }
            else if (SearchRenderer.FILE_MATCH_TEMPLATE_ID === templateId) {
                var template = templateData;
                template.label.dispose();
                template.actions.dispose();
            }
            else if (SearchRenderer.MATCH_TEMPLATE_ID === templateId) {
                var template = templateData;
                template.actions.dispose();
            }
        };
        SearchRenderer.FOLDER_MATCH_TEMPLATE_ID = 'folderMatch';
        SearchRenderer.FILE_MATCH_TEMPLATE_ID = 'fileMatch';
        SearchRenderer.MATCH_TEMPLATE_ID = 'match';
        SearchRenderer = __decorate([
            __param(2, instantiation_1.IInstantiationService),
            __param(3, themeService_1.IThemeService),
            __param(4, workspace_1.IWorkspaceContextService)
        ], SearchRenderer);
        return SearchRenderer;
    }(lifecycle_1.Disposable));
    exports.SearchRenderer = SearchRenderer;
    var SearchAccessibilityProvider = /** @class */ (function () {
        function SearchAccessibilityProvider(labelService) {
            this.labelService = labelService;
        }
        SearchAccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            if (element instanceof searchModel_1.FolderMatch) {
                return element.hasResource() ?
                    nls.localize('folderMatchAriaLabel', "{0} matches in folder root {1}, Search result", element.count(), element.name()) :
                    nls.localize('otherFilesAriaLabel', "{0} matches outside of the workspace, Search result", element.count());
            }
            if (element instanceof searchModel_1.FileMatch) {
                var path = this.labelService.getUriLabel(element.resource(), { relative: true }) || element.resource().fsPath;
                return nls.localize('fileMatchAriaLabel', "{0} matches in file {1} of folder {2}, Search result", element.count(), element.name(), paths.dirname(path));
            }
            if (element instanceof searchModel_1.Match) {
                var match = element;
                var searchModel = tree.getInput().searchModel;
                var replace = searchModel.isReplaceActive() && !!searchModel.replaceString;
                var matchString = match.getMatchString();
                var range = match.range();
                var matchText = match.text().substr(0, range.endColumn + 150);
                if (replace) {
                    return nls.localize('replacePreviewResultAria', "Replace term {0} with {1} at column position {2} in line with text {3}", matchString, match.replaceString, range.startColumn + 1, matchText);
                }
                return nls.localize('searchResultAria', "Found term {0} at column position {1} in line with text {2}", matchString, range.startColumn + 1, matchText);
            }
            return undefined;
        };
        SearchAccessibilityProvider = __decorate([
            __param(0, label_1.ILabelService)
        ], SearchAccessibilityProvider);
        return SearchAccessibilityProvider;
    }());
    exports.SearchAccessibilityProvider = SearchAccessibilityProvider;
    var SearchFilter = /** @class */ (function () {
        function SearchFilter() {
        }
        SearchFilter.prototype.isVisible = function (tree, element) {
            return !(element instanceof searchModel_1.FileMatch || element instanceof searchModel_1.FolderMatch) || element.matches().length > 0;
        };
        return SearchFilter;
    }());
    exports.SearchFilter = SearchFilter;
    var SearchTreeController = /** @class */ (function (_super) {
        __extends(SearchTreeController, _super);
        function SearchTreeController(contextMenuService, menuService, configurationService) {
            var _this = _super.call(this, {}, configurationService) || this;
            _this.contextMenuService = contextMenuService;
            _this.menuService = menuService;
            return _this;
        }
        SearchTreeController.prototype.onContextMenu = function (tree, element, event) {
            var _this = this;
            if (!this.contextMenu) {
                this.contextMenu = this.menuService.createMenu(actions_1.MenuId.SearchContext, tree.contextKeyService);
            }
            tree.setFocus(element, { preventOpenOnFocus: true });
            var anchor = { x: event.posx, y: event.posy };
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () {
                    var actions = [];
                    menuItemActionItem_1.fillInContextMenuActions(_this.contextMenu, { shouldForwardArgs: true }, actions, _this.contextMenuService);
                    return winjs_base_1.TPromise.as(actions);
                },
                getActionsContext: function () { return element; }
            });
            return true;
        };
        SearchTreeController = __decorate([
            __param(0, contextView_1.IContextMenuService),
            __param(1, actions_1.IMenuService),
            __param(2, configuration_1.IConfigurationService)
        ], SearchTreeController);
        return SearchTreeController;
    }(listService_1.WorkbenchTreeController));
    exports.SearchTreeController = SearchTreeController;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[383/*vs/workbench/parts/search/browser/searchViewLocationUpdater*/], __M([0/*require*/,1/*exports*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,81/*vs/workbench/services/panel/common/panelService*/,7/*vs/platform/configuration/common/configuration*/,71/*vs/platform/search/common/search*/]), function (require, exports, viewlet_1, panelService_1, configuration_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchViewLocationUpdater = /** @class */ (function () {
        function SearchViewLocationUpdater(viewletService, panelService, configurationService) {
            var updateSearchViewLocation = function (open) {
                var config = configurationService.getValue();
                if (config.search.location === 'panel') {
                    viewletService.setViewletEnablement(search_1.VIEW_ID, false);
                    panelService.setPanelEnablement(search_1.VIEW_ID, true);
                    if (open) {
                        panelService.openPanel(search_1.VIEW_ID);
                    }
                }
                else {
                    panelService.setPanelEnablement(search_1.VIEW_ID, false);
                    viewletService.setViewletEnablement(search_1.VIEW_ID, true);
                    if (open) {
                        viewletService.openViewlet(search_1.VIEW_ID);
                    }
                }
            };
            configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('search.location')) {
                    updateSearchViewLocation(true);
                }
            });
            updateSearchViewLocation(false);
        }
        SearchViewLocationUpdater = __decorate([
            __param(0, viewlet_1.IViewletService),
            __param(1, panelService_1.IPanelService),
            __param(2, configuration_1.IConfigurationService)
        ], SearchViewLocationUpdater);
        return SearchViewLocationUpdater;
    }());
    exports.SearchViewLocationUpdater = SearchViewLocationUpdater;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[217/*vs/workbench/parts/search/browser/searchWidget*/], __M([0/*require*/,1/*exports*/,111/*vs/base/browser/browser*/,8/*vs/base/browser/dom*/,50/*vs/base/browser/ui/actionbar/actionbar*/,121/*vs/base/browser/ui/button/button*/,95/*vs/base/browser/ui/widget*/,15/*vs/base/common/actions*/,17/*vs/base/common/async*/,6/*vs/base/common/event*/,22/*vs/base/common/strings*/,5/*vs/base/common/winjs.base*/,381/*vs/editor/contrib/find/findModel*/,2/*vs/nls*/,79/*vs/platform/clipboard/common/clipboardService*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,31/*vs/platform/keybinding/common/keybinding*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,254/*vs/platform/widget/browser/contextScopedHistoryWidget*/,141/*vs/workbench/parts/search/browser/searchActions*/,148/*vs/workbench/parts/search/common/constants*/,81/*vs/workbench/services/panel/common/panelService*/,54/*vs/workbench/services/viewlet/browser/viewlet*/]), function (require, exports, browser, dom, actionbar_1, button_1, widget_1, actions_1, async_1, event_1, strings, winjs_base_1, findModel_1, nls, clipboardService_1, configuration_1, contextkey_1, contextView_1, keybinding_1, keybindingsRegistry_1, styler_1, themeService_1, contextScopedHistoryWidget_1, searchActions_1, Constants, panelService_1, viewlet_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReplaceAllAction = /** @class */ (function (_super) {
        __extends(ReplaceAllAction, _super);
        function ReplaceAllAction() {
            var _this = _super.call(this, ReplaceAllAction.ID, '', 'action-replace-all', false) || this;
            _this._searchWidget = null;
            return _this;
        }
        Object.defineProperty(ReplaceAllAction, "INSTANCE", {
            get: function () {
                if (ReplaceAllAction.fgInstance === null) {
                    ReplaceAllAction.fgInstance = new ReplaceAllAction();
                }
                return ReplaceAllAction.fgInstance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReplaceAllAction.prototype, "searchWidget", {
            set: function (searchWidget) {
                this._searchWidget = searchWidget;
            },
            enumerable: true,
            configurable: true
        });
        ReplaceAllAction.prototype.run = function () {
            if (this._searchWidget) {
                return this._searchWidget.triggerReplaceAll();
            }
            return winjs_base_1.TPromise.as(null);
        };
        ReplaceAllAction.fgInstance = null;
        ReplaceAllAction.ID = 'search.action.replaceAll';
        return ReplaceAllAction;
    }(actions_1.Action));
    var SearchWidget = /** @class */ (function (_super) {
        __extends(SearchWidget, _super);
        function SearchWidget(container, options, contextViewService, themeService, contextKeyService, keyBindingService, clipboardServce, configurationService) {
            var _this = _super.call(this) || this;
            _this.contextViewService = contextViewService;
            _this.themeService = themeService;
            _this.contextKeyService = contextKeyService;
            _this.keyBindingService = keyBindingService;
            _this.clipboardServce = clipboardServce;
            _this.configurationService = configurationService;
            _this.ignoreGlobalFindBufferOnNextFocus = false;
            _this._onSearchSubmit = _this._register(new event_1.Emitter());
            _this.onSearchSubmit = _this._onSearchSubmit.event;
            _this._onSearchCancel = _this._register(new event_1.Emitter());
            _this.onSearchCancel = _this._onSearchCancel.event;
            _this._onReplaceToggled = _this._register(new event_1.Emitter());
            _this.onReplaceToggled = _this._onReplaceToggled.event;
            _this._onReplaceStateChange = _this._register(new event_1.Emitter());
            _this.onReplaceStateChange = _this._onReplaceStateChange.event;
            _this._onReplaceValueChanged = _this._register(new event_1.Emitter());
            _this.onReplaceValueChanged = _this._onReplaceValueChanged.event;
            _this._onReplaceAll = _this._register(new event_1.Emitter());
            _this.onReplaceAll = _this._onReplaceAll.event;
            _this._onBlur = _this._register(new event_1.Emitter());
            _this.onBlur = _this._onBlur.event;
            _this.replaceActive = Constants.ReplaceActiveKey.bindTo(_this.contextKeyService);
            _this.searchInputBoxFocused = Constants.SearchInputBoxFocusedKey.bindTo(_this.contextKeyService);
            _this.replaceInputBoxFocused = Constants.ReplaceInputBoxFocusedKey.bindTo(_this.contextKeyService);
            _this._replaceHistoryDelayer = new async_1.Delayer(500);
            _this.render(container, options);
            _this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('editor.accessibilitySupport')) {
                    _this.updateAccessibilitySupport();
                }
            });
            browser.onDidChangeAccessibilitySupport(function () { return _this.updateAccessibilitySupport(); });
            _this.updateAccessibilitySupport();
            return _this;
        }
        SearchWidget.prototype.focus = function (select, focusReplace, suppressGlobalSearchBuffer) {
            if (select === void 0) { select = true; }
            if (focusReplace === void 0) { focusReplace = false; }
            if (suppressGlobalSearchBuffer === void 0) { suppressGlobalSearchBuffer = false; }
            this.ignoreGlobalFindBufferOnNextFocus = suppressGlobalSearchBuffer;
            if (focusReplace && this.isReplaceShown()) {
                this.replaceInput.focus();
                if (select) {
                    this.replaceInput.select();
                }
            }
            else {
                this.searchInput.focus();
                if (select) {
                    this.searchInput.select();
                }
            }
        };
        SearchWidget.prototype.setWidth = function (width) {
            this.searchInput.setWidth(width);
            this.replaceInput.width = width - 28;
        };
        SearchWidget.prototype.clear = function () {
            this.searchInput.clear();
            this.replaceInput.value = '';
            this.setReplaceAllActionState(false);
        };
        SearchWidget.prototype.isReplaceShown = function () {
            return !dom.hasClass(this.replaceContainer, 'disabled');
        };
        SearchWidget.prototype.isReplaceActive = function () {
            return this.replaceActive.get();
        };
        SearchWidget.prototype.getReplaceValue = function () {
            return this.replaceInput.value;
        };
        SearchWidget.prototype.toggleReplace = function (show) {
            if (show === void 0 || show !== this.isReplaceShown()) {
                this.onToggleReplaceButton();
            }
        };
        SearchWidget.prototype.getSearchHistory = function () {
            return this.searchInput.inputBox.getHistory();
        };
        SearchWidget.prototype.getReplaceHistory = function () {
            return this.replaceInput.getHistory();
        };
        SearchWidget.prototype.clearHistory = function () {
            this.searchInput.inputBox.clearHistory();
        };
        SearchWidget.prototype.showNextSearchTerm = function () {
            this.searchInput.inputBox.showNextValue();
        };
        SearchWidget.prototype.showPreviousSearchTerm = function () {
            this.searchInput.inputBox.showPreviousValue();
        };
        SearchWidget.prototype.showNextReplaceTerm = function () {
            this.replaceInput.showNextValue();
        };
        SearchWidget.prototype.showPreviousReplaceTerm = function () {
            this.replaceInput.showPreviousValue();
        };
        SearchWidget.prototype.searchInputHasFocus = function () {
            return this.searchInputBoxFocused.get();
        };
        SearchWidget.prototype.replaceInputHasFocus = function () {
            return this.replaceInput.hasFocus();
        };
        SearchWidget.prototype.focusReplaceAllAction = function () {
            this.replaceActionBar.focus(true);
        };
        SearchWidget.prototype.focusRegexAction = function () {
            this.searchInput.focusOnRegex();
        };
        SearchWidget.prototype.render = function (container, options) {
            this.domNode = dom.append(container, dom.$('.search-widget'));
            this.domNode.style.position = 'relative';
            this.renderToggleReplaceButton(this.domNode);
            this.renderSearchInput(this.domNode, options);
            this.renderReplaceInput(this.domNode, options);
        };
        SearchWidget.prototype.isScreenReaderOptimized = function () {
            var detected = browser.getAccessibilitySupport() === 2 /* Enabled */;
            var config = this.configurationService.getValue('editor').accessibilitySupport;
            return config === 'on' || (config === 'auto' && detected);
        };
        SearchWidget.prototype.updateAccessibilitySupport = function () {
            this.searchInput.setFocusInputOnOptionClick(!this.isScreenReaderOptimized());
        };
        SearchWidget.prototype.renderToggleReplaceButton = function (parent) {
            var _this = this;
            var opts = {
                buttonBackground: null,
                buttonBorder: null,
                buttonForeground: null,
                buttonHoverBackground: null
            };
            this.toggleReplaceButton = this._register(new button_1.Button(parent, opts));
            this.toggleReplaceButton.element.setAttribute('aria-expanded', 'false');
            this.toggleReplaceButton.element.classList.add('collapse');
            this.toggleReplaceButton.icon = 'toggle-replace-button';
            // TODO@joh need to dispose this listener eventually
            this.toggleReplaceButton.onDidClick(function () { return _this.onToggleReplaceButton(); });
            this.toggleReplaceButton.element.title = nls.localize('search.replace.toggle.button.title', "Toggle Replace");
        };
        SearchWidget.prototype.renderSearchInput = function (parent, options) {
            var _this = this;
            var inputOptions = {
                label: nls.localize('label.Search', 'Search: Type Search Term and press Enter to search or Escape to cancel'),
                validation: function (value) { return _this.validateSearchInput(value); },
                placeholder: nls.localize('search.placeHolder', "Search"),
                appendCaseSensitiveLabel: searchActions_1.appendKeyBindingLabel('', this.keyBindingService.lookupKeybinding(Constants.ToggleCaseSensitiveCommandId), this.keyBindingService),
                appendWholeWordsLabel: searchActions_1.appendKeyBindingLabel('', this.keyBindingService.lookupKeybinding(Constants.ToggleWholeWordCommandId), this.keyBindingService),
                appendRegexLabel: searchActions_1.appendKeyBindingLabel('', this.keyBindingService.lookupKeybinding(Constants.ToggleRegexCommandId), this.keyBindingService),
                history: options.searchHistory
            };
            var searchInputContainer = dom.append(parent, dom.$('.search-container.input-box'));
            this.searchInput = this._register(new contextScopedHistoryWidget_1.ContextScopedFindInput(searchInputContainer, this.contextViewService, inputOptions, this.contextKeyService, true));
            this._register(styler_1.attachFindInputBoxStyler(this.searchInput, this.themeService));
            this.searchInput.onKeyDown(function (keyboardEvent) { return _this.onSearchInputKeyDown(keyboardEvent); });
            this.searchInput.setValue(options.value || '');
            this.searchInput.setRegex(!!options.isRegex);
            this.searchInput.setCaseSensitive(!!options.isCaseSensitive);
            this.searchInput.setWholeWords(!!options.isWholeWords);
            this._register(this.onSearchSubmit(function () {
                _this.searchInput.inputBox.addToHistory();
            }));
            this.searchInput.onCaseSensitiveKeyDown(function (keyboardEvent) { return _this.onCaseSensitiveKeyDown(keyboardEvent); });
            this.searchInput.onRegexKeyDown(function (keyboardEvent) { return _this.onRegexKeyDown(keyboardEvent); });
            this._register(this.onReplaceValueChanged(function () {
                _this._replaceHistoryDelayer.trigger(function () { return _this.replaceInput.addToHistory(); });
            }));
            this.searchInputFocusTracker = this._register(dom.trackFocus(this.searchInput.inputBox.inputElement));
            this._register(this.searchInputFocusTracker.onDidFocus(function () {
                _this.searchInputBoxFocused.set(true);
                var useGlobalFindBuffer = _this.configurationService.getValue('search').globalFindClipboard;
                if (!_this.ignoreGlobalFindBufferOnNextFocus && useGlobalFindBuffer) {
                    var globalBufferText = _this.clipboardServce.readFindText();
                    if (_this.previousGlobalFindBufferValue !== globalBufferText) {
                        _this.searchInput.inputBox.addToHistory();
                        _this.searchInput.setValue(globalBufferText);
                        _this.searchInput.select();
                    }
                    _this.previousGlobalFindBufferValue = globalBufferText;
                }
                _this.ignoreGlobalFindBufferOnNextFocus = false;
            }));
            this._register(this.searchInputFocusTracker.onDidBlur(function () { return _this.searchInputBoxFocused.set(false); }));
        };
        SearchWidget.prototype.renderReplaceInput = function (parent, options) {
            var _this = this;
            this.replaceContainer = dom.append(parent, dom.$('.replace-container.disabled'));
            var replaceBox = dom.append(this.replaceContainer, dom.$('.input-box'));
            this.replaceInput = this._register(new contextScopedHistoryWidget_1.ContextScopedHistoryInputBox(replaceBox, this.contextViewService, {
                ariaLabel: nls.localize('label.Replace', 'Replace: Type replace term and press Enter to preview or Escape to cancel'),
                placeholder: nls.localize('search.replace.placeHolder', "Replace"),
                history: options.replaceHistory || []
            }, this.contextKeyService));
            this._register(styler_1.attachInputBoxStyler(this.replaceInput, this.themeService));
            this.onkeydown(this.replaceInput.inputElement, function (keyboardEvent) { return _this.onReplaceInputKeyDown(keyboardEvent); });
            this.replaceInput.onDidChange(function () { return _this._onReplaceValueChanged.fire(); });
            this.searchInput.inputBox.onDidChange(function () { return _this.onSearchInputChanged(); });
            this.replaceAllAction = ReplaceAllAction.INSTANCE;
            this.replaceAllAction.searchWidget = this;
            this.replaceAllAction.label = SearchWidget.REPLACE_ALL_DISABLED_LABEL;
            this.replaceActionBar = this._register(new actionbar_1.ActionBar(this.replaceContainer));
            this.replaceActionBar.push([this.replaceAllAction], { icon: true, label: false });
            this.onkeydown(this.replaceActionBar.domNode, function (keyboardEvent) { return _this.onReplaceActionbarKeyDown(keyboardEvent); });
            this.replaceInputFocusTracker = this._register(dom.trackFocus(this.replaceInput.inputElement));
            this._register(this.replaceInputFocusTracker.onDidFocus(function () { return _this.replaceInputBoxFocused.set(true); }));
            this._register(this.replaceInputFocusTracker.onDidBlur(function () { return _this.replaceInputBoxFocused.set(false); }));
        };
        SearchWidget.prototype.triggerReplaceAll = function () {
            this._onReplaceAll.fire();
            return winjs_base_1.TPromise.as(null);
        };
        SearchWidget.prototype.onToggleReplaceButton = function () {
            dom.toggleClass(this.replaceContainer, 'disabled');
            dom.toggleClass(this.toggleReplaceButton.element, 'collapse');
            dom.toggleClass(this.toggleReplaceButton.element, 'expand');
            this.toggleReplaceButton.element.setAttribute('aria-expanded', this.isReplaceShown() ? 'true' : 'false');
            this.updateReplaceActiveState();
            this._onReplaceToggled.fire();
        };
        SearchWidget.prototype.setReplaceAllActionState = function (enabled) {
            if (this.replaceAllAction.enabled !== enabled) {
                this.replaceAllAction.enabled = enabled;
                this.replaceAllAction.label = enabled ? SearchWidget.REPLACE_ALL_ENABLED_LABEL(this.keyBindingService) : SearchWidget.REPLACE_ALL_DISABLED_LABEL;
                this.updateReplaceActiveState();
            }
        };
        SearchWidget.prototype.updateReplaceActiveState = function () {
            var currentState = this.isReplaceActive();
            var newState = this.isReplaceShown() && this.replaceAllAction.enabled;
            if (currentState !== newState) {
                this.replaceActive.set(newState);
                this._onReplaceStateChange.fire(newState);
            }
        };
        SearchWidget.prototype.validateSearchInput = function (value) {
            if (value.length === 0) {
                return null;
            }
            if (!this.searchInput.getRegex()) {
                return null;
            }
            var regExp;
            try {
                regExp = new RegExp(value);
            }
            catch (e) {
                return { content: e.message };
            }
            if (strings.regExpLeadsToEndlessLoop(regExp)) {
                return { content: nls.localize('regexp.validationFailure', "Expression matches everything") };
            }
            if (strings.regExpContainsBackreference(value)) {
                return { content: nls.localize('regexp.backreferenceValidationFailure', "Backreferences are not supported") };
            }
            return null;
        };
        SearchWidget.prototype.onSearchInputChanged = function () {
            this.searchInput.clearMessage();
            this.setReplaceAllActionState(false);
        };
        SearchWidget.prototype.onSearchInputKeyDown = function (keyboardEvent) {
            if (keyboardEvent.equals(3 /* Enter */)) {
                this.submitSearch();
                keyboardEvent.preventDefault();
            }
            else if (keyboardEvent.equals(9 /* Escape */)) {
                this._onSearchCancel.fire();
                keyboardEvent.preventDefault();
            }
            else if (keyboardEvent.equals(2 /* Tab */)) {
                if (this.isReplaceShown()) {
                    this.replaceInput.focus();
                }
                else {
                    this.searchInput.focusOnCaseSensitive();
                }
                keyboardEvent.preventDefault();
            }
        };
        SearchWidget.prototype.onCaseSensitiveKeyDown = function (keyboardEvent) {
            if (keyboardEvent.equals(1024 /* Shift */ | 2 /* Tab */)) {
                if (this.isReplaceShown()) {
                    this.replaceInput.focus();
                    keyboardEvent.preventDefault();
                }
            }
        };
        SearchWidget.prototype.onRegexKeyDown = function (keyboardEvent) {
            if (keyboardEvent.equals(2 /* Tab */)) {
                if (this.isReplaceActive()) {
                    this.focusReplaceAllAction();
                }
                else {
                    this._onBlur.fire();
                }
                keyboardEvent.preventDefault();
            }
        };
        SearchWidget.prototype.onReplaceInputKeyDown = function (keyboardEvent) {
            if (keyboardEvent.equals(3 /* Enter */)) {
                this.submitSearch();
                keyboardEvent.preventDefault();
            }
            else if (keyboardEvent.equals(2 /* Tab */)) {
                this.searchInput.focusOnCaseSensitive();
                keyboardEvent.preventDefault();
            }
            else if (keyboardEvent.equals(1024 /* Shift */ | 2 /* Tab */)) {
                this.searchInput.focus();
                keyboardEvent.preventDefault();
            }
        };
        SearchWidget.prototype.onReplaceActionbarKeyDown = function (keyboardEvent) {
            if (keyboardEvent.equals(1024 /* Shift */ | 2 /* Tab */)) {
                this.focusRegexAction();
                keyboardEvent.preventDefault();
            }
        };
        SearchWidget.prototype.submitSearch = function () {
            var value = this.searchInput.getValue();
            var useGlobalFindBuffer = this.configurationService.getValue('search').globalFindClipboard;
            if (value) {
                if (useGlobalFindBuffer) {
                    this.clipboardServce.writeFindText(value);
                }
                this._onSearchSubmit.fire();
            }
        };
        SearchWidget.prototype.dispose = function () {
            this.setReplaceAllActionState(false);
            this.replaceAllAction.searchWidget = null;
            this.replaceActionBar = null;
            _super.prototype.dispose.call(this);
        };
        SearchWidget.REPLACE_ALL_DISABLED_LABEL = nls.localize('search.action.replaceAll.disabled.label', "Replace All (Submit Search to Enable)");
        SearchWidget.REPLACE_ALL_ENABLED_LABEL = function (keyBindingService2) {
            var kb = keyBindingService2.lookupKeybinding(ReplaceAllAction.ID);
            return searchActions_1.appendKeyBindingLabel(nls.localize('search.action.replaceAll.enabled.label', "Replace All"), kb, keyBindingService2);
        };
        SearchWidget = __decorate([
            __param(2, contextView_1.IContextViewService),
            __param(3, themeService_1.IThemeService),
            __param(4, contextkey_1.IContextKeyService),
            __param(5, keybinding_1.IKeybindingService),
            __param(6, clipboardService_1.IClipboardService),
            __param(7, configuration_1.IConfigurationService)
        ], SearchWidget);
        return SearchWidget;
    }(widget_1.Widget));
    exports.SearchWidget = SearchWidget;
    function registerContributions() {
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
            id: ReplaceAllAction.ID,
            weight: 200 /* WorkbenchContrib */,
            when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.ReplaceActiveKey, findModel_1.CONTEXT_FIND_WIDGET_NOT_VISIBLE),
            primary: 512 /* Alt */ | 2048 /* CtrlCmd */ | 3 /* Enter */,
            handler: function (accessor) {
                if (searchActions_1.isSearchViewFocused(accessor.get(viewlet_1.IViewletService), accessor.get(panelService_1.IPanelService))) {
                    ReplaceAllAction.INSTANCE.run();
                }
            }
        });
    }
    exports.registerContributions = registerContributions;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[379/*vs/workbench/services/progress/browser/progressService*/], __M([0/*require*/,1/*exports*/,4/*vs/base/common/lifecycle*/,5/*vs/base/common/winjs.base*/,29/*vs/base/common/types*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,81/*vs/workbench/services/panel/common/panelService*/]), function (require, exports, lifecycle_1, winjs_base_1, types, viewlet_1, panelService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScopedService = /** @class */ (function (_super) {
        __extends(ScopedService, _super);
        function ScopedService(viewletService, panelService, scopeId) {
            var _this = _super.call(this) || this;
            _this.viewletService = viewletService;
            _this.panelService = panelService;
            _this.scopeId = scopeId;
            _this.registerListeners();
            return _this;
        }
        ScopedService.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.viewletService.onDidViewletOpen(function (viewlet) { return _this.onScopeOpened(viewlet.getId()); }));
            this._register(this.panelService.onDidPanelOpen(function (panel) { return _this.onScopeOpened(panel.getId()); }));
            this._register(this.viewletService.onDidViewletClose(function (viewlet) { return _this.onScopeClosed(viewlet.getId()); }));
            this._register(this.panelService.onDidPanelClose(function (panel) { return _this.onScopeClosed(panel.getId()); }));
        };
        ScopedService.prototype.onScopeClosed = function (scopeId) {
            if (scopeId === this.scopeId) {
                this.onScopeDeactivated();
            }
        };
        ScopedService.prototype.onScopeOpened = function (scopeId) {
            if (scopeId === this.scopeId) {
                this.onScopeActivated();
            }
        };
        return ScopedService;
    }(lifecycle_1.Disposable));
    exports.ScopedService = ScopedService;
    var ScopedProgressService = /** @class */ (function (_super) {
        __extends(ScopedProgressService, _super);
        function ScopedProgressService(progressbar, scopeId, isActive, viewletService, panelService) {
            var _this = _super.call(this, viewletService, panelService, scopeId) || this;
            _this.progressbar = progressbar;
            _this.isActive = isActive || types.isUndefinedOrNull(scopeId); // If service is unscoped, enable by default
            _this.progressState = Object.create(null);
            return _this;
        }
        ScopedProgressService.prototype.onScopeDeactivated = function () {
            this.isActive = false;
        };
        ScopedProgressService.prototype.onScopeActivated = function () {
            this.isActive = true;
            // Return early if progress state indicates that progress is done
            if (this.progressState.done) {
                return;
            }
            // Replay Infinite Progress from Promise
            if (this.progressState.whilePromise) {
                var delay = void 0;
                if (this.progressState.whileDelay > 0) {
                    var remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);
                    if (remainingDelay > 0) {
                        delay = remainingDelay;
                    }
                }
                this.doShowWhile(delay);
            }
            // Replay Infinite Progress
            else if (this.progressState.infinite) {
                this.progressbar.infinite().show();
            }
            // Replay Finite Progress (Total & Worked)
            else {
                if (this.progressState.total) {
                    this.progressbar.total(this.progressState.total).show();
                }
                if (this.progressState.worked) {
                    this.progressbar.worked(this.progressState.worked).show();
                }
            }
        };
        ScopedProgressService.prototype.clearProgressState = function () {
            this.progressState.infinite = void 0;
            this.progressState.done = void 0;
            this.progressState.worked = void 0;
            this.progressState.total = void 0;
            this.progressState.whilePromise = void 0;
            this.progressState.whileStart = void 0;
            this.progressState.whileDelay = void 0;
        };
        ScopedProgressService.prototype.show = function (infiniteOrTotal, delay) {
            var _this = this;
            var infinite;
            var total;
            // Sort out Arguments
            if (typeof infiniteOrTotal === 'boolean') {
                infinite = infiniteOrTotal;
            }
            else {
                total = infiniteOrTotal;
            }
            // Reset State
            this.clearProgressState();
            // Keep in State
            this.progressState.infinite = infinite;
            this.progressState.total = total;
            // Active: Show Progress
            if (this.isActive) {
                // Infinite: Start Progressbar and Show after Delay
                if (!types.isUndefinedOrNull(infinite)) {
                    this.progressbar.infinite().show(delay);
                }
                // Finite: Start Progressbar and Show after Delay
                else if (!types.isUndefinedOrNull(total)) {
                    this.progressbar.total(total).show(delay);
                }
            }
            return {
                total: function (total) {
                    _this.progressState.infinite = false;
                    _this.progressState.total = total;
                    if (_this.isActive) {
                        _this.progressbar.total(total);
                    }
                },
                worked: function (worked) {
                    // Verify first that we are either not active or the progressbar has a total set
                    if (!_this.isActive || _this.progressbar.hasTotal()) {
                        _this.progressState.infinite = false;
                        if (_this.progressState.worked) {
                            _this.progressState.worked += worked;
                        }
                        else {
                            _this.progressState.worked = worked;
                        }
                        if (_this.isActive) {
                            _this.progressbar.worked(worked);
                        }
                    }
                    // Otherwise the progress bar does not support worked(), we fallback to infinite() progress
                    else {
                        _this.progressState.infinite = true;
                        _this.progressState.worked = void 0;
                        _this.progressState.total = void 0;
                        _this.progressbar.infinite().show();
                    }
                },
                done: function () {
                    _this.progressState.infinite = false;
                    _this.progressState.done = true;
                    if (_this.isActive) {
                        _this.progressbar.stop().hide();
                    }
                }
            };
        };
        ScopedProgressService.prototype.showWhile = function (promise, delay) {
            var _this = this;
            var stack = !!this.progressState.whilePromise;
            // Reset State
            if (!stack) {
                this.clearProgressState();
            }
            // Otherwise join with existing running promise to ensure progress is accurate
            else {
                promise = winjs_base_1.TPromise.join([promise, this.progressState.whilePromise]);
            }
            // Keep Promise in State
            this.progressState.whilePromise = promise;
            this.progressState.whileDelay = delay || 0;
            this.progressState.whileStart = Date.now();
            var stop = function () {
                // If this is not the last promise in the list of joined promises, return early
                if (!!_this.progressState.whilePromise && _this.progressState.whilePromise !== promise) {
                    return;
                }
                // The while promise is either null or equal the promise we last hooked on
                _this.clearProgressState();
                if (_this.isActive) {
                    _this.progressbar.stop().hide();
                }
            };
            this.doShowWhile(delay);
            return promise.then(stop, stop);
        };
        ScopedProgressService.prototype.doShowWhile = function (delay) {
            // Show Progress when active
            if (this.isActive) {
                this.progressbar.infinite().show(delay);
            }
        };
        ScopedProgressService = __decorate([
            __param(3, viewlet_1.IViewletService),
            __param(4, panelService_1.IPanelService)
        ], ScopedProgressService);
        return ScopedProgressService;
    }(ScopedService));
    exports.ScopedProgressService = ScopedProgressService;
    var ProgressService = /** @class */ (function () {
        function ProgressService(progressbar) {
            this.progressbar = progressbar;
        }
        ProgressService.prototype.show = function (infiniteOrTotal, delay) {
            var _this = this;
            if (typeof infiniteOrTotal === 'boolean') {
                this.progressbar.infinite().show(delay);
            }
            else {
                this.progressbar.total(infiniteOrTotal).show(delay);
            }
            return {
                total: function (total) {
                    _this.progressbar.total(total);
                },
                worked: function (worked) {
                    if (_this.progressbar.hasTotal()) {
                        _this.progressbar.worked(worked);
                    }
                    else {
                        _this.progressbar.infinite().show();
                    }
                },
                done: function () {
                    _this.progressbar.stop().hide();
                }
            };
        };
        ProgressService.prototype.showWhile = function (promise, delay) {
            var _this = this;
            var stop = function () {
                _this.progressbar.stop().hide();
            };
            this.progressbar.infinite().show(delay);
            return promise.then(stop, stop);
        };
        return ProgressService;
    }());
    exports.ProgressService = ProgressService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[374/*vs/workbench/browser/parts/editor/editorGroupView*/], __M([0/*require*/,1/*exports*/,5/*vs/base/common/winjs.base*/,188/*vs/workbench/common/editor/editorGroup*/,13/*vs/workbench/common/editor*/,6/*vs/base/common/event*/,3/*vs/platform/instantiation/common/instantiation*/,8/*vs/base/browser/dom*/,368/*vs/platform/instantiation/common/serviceCollection*/,10/*vs/platform/contextkey/common/contextkey*/,343/*vs/base/browser/ui/progressbar/progressbar*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,58/*vs/workbench/common/theme*/,420/*vs/workbench/browser/parts/editor/tabsTitleControl*/,339/*vs/workbench/browser/parts/editor/editorControl*/,99/*vs/platform/progress/common/progress*/,379/*vs/workbench/services/progress/browser/progressService*/,2/*vs/nls*/,25/*vs/base/common/errors*/,4/*vs/base/common/lifecycle*/,28/*vs/platform/notification/common/notification*/,98/*vs/base/common/errorMessage*/,32/*vs/platform/telemetry/common/telemetry*/,17/*vs/base/common/async*/,140/*vs/base/browser/touch*/,87/*vs/workbench/browser/parts/editor/editor*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,24/*vs/base/common/paths*/,50/*vs/base/browser/ui/actionbar/actionbar*/,31/*vs/platform/keybinding/common/keybinding*/,15/*vs/base/common/actions*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,419/*vs/workbench/browser/parts/editor/noTabsTitleControl*/,23/*vs/platform/actions/common/actions*/,137/*vs/base/browser/mouseEvent*/,115/*vs/platform/actions/browser/menuItemActionItem*/,34/*vs/platform/contextview/browser/contextView*/,404/*vs/css!vs/workbench/browser/parts/editor/media/editorgroupview*/]), function (require, exports, winjs_base_1, editorGroup_1, editor_1, event_1, instantiation_1, dom_1, serviceCollection_1, contextkey_1, progressbar_1, styler_1, themeService_1, colorRegistry_1, theme_1, tabsTitleControl_1, editorControl_1, progress_1, progressService_1, nls_1, errors_1, lifecycle_1, notification_1, errorMessage_1, telemetry_1, async_1, touch_1, editor_2, untitledEditorService_1, paths_1, actionbar_1, keybinding_1, actions_1, editorCommands_1, noTabsTitleControl_1, actions_2, mouseEvent_1, menuItemActionItem_1, contextView_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EditorGroupView = /** @class */ (function (_super) {
        __extends(EditorGroupView, _super);
        function EditorGroupView(accessor, from, _label, instantiationService, contextKeyService, themeService, notificationService, telemetryService, untitledEditorService, keybindingService, menuService, contextMenuService) {
            var _this = _super.call(this, themeService) || this;
            _this.accessor = accessor;
            _this._label = _label;
            _this.instantiationService = instantiationService;
            _this.contextKeyService = contextKeyService;
            _this.notificationService = notificationService;
            _this.telemetryService = telemetryService;
            _this.untitledEditorService = untitledEditorService;
            _this.keybindingService = keybindingService;
            _this.menuService = menuService;
            _this.contextMenuService = contextMenuService;
            //#endregion
            //#region events
            _this._onDidFocus = _this._register(new event_1.Emitter());
            _this._onWillDispose = _this._register(new event_1.Emitter());
            _this._onDidGroupChange = _this._register(new event_1.Emitter());
            _this._onWillOpenEditor = _this._register(new event_1.Emitter());
            _this._onDidOpenEditorFail = _this._register(new event_1.Emitter());
            _this._onWillCloseEditor = _this._register(new event_1.Emitter());
            _this._onDidCloseEditor = _this._register(new event_1.Emitter());
            _this.mapEditorToPendingConfirmation = new Map();
            //#endregion
            //#region ISerializableView
            _this.element = document.createElement('div');
            _this._onDidChange = _this._register(new event_1.Relay());
            _this.onDidChange = _this._onDidChange.event;
            if (from instanceof EditorGroupView) {
                _this._group = _this._register(from.group.clone());
            }
            else if (editorGroup_1.isSerializedEditorGroup(from)) {
                _this._group = _this._register(instantiationService.createInstance(editorGroup_1.EditorGroup, from));
            }
            else {
                _this._group = _this._register(instantiationService.createInstance(editorGroup_1.EditorGroup, void 0));
            }
            _this.disposedEditorsWorker = _this._register(new async_1.RunOnceWorker(function (editors) { return _this.handleDisposedEditors(editors); }, 0));
            _this.create();
            _this._whenRestored = _this.restoreEditors(from);
            _this._whenRestored.then(function () { return _this.isRestored = true; });
            _this.registerListeners();
            return _this;
        }
        //#region factory
        EditorGroupView.createNew = function (accessor, label, instantiationService) {
            return instantiationService.createInstance(EditorGroupView, accessor, null, label);
        };
        EditorGroupView.createFromSerialized = function (serialized, accessor, label, instantiationService) {
            return instantiationService.createInstance(EditorGroupView, accessor, serialized, label);
        };
        EditorGroupView.createCopy = function (copyFrom, accessor, label, instantiationService) {
            return instantiationService.createInstance(EditorGroupView, accessor, copyFrom, label);
        };
        Object.defineProperty(EditorGroupView.prototype, "onDidFocus", {
            get: function () { return this._onDidFocus.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onWillDispose", {
            get: function () { return this._onWillDispose.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onDidGroupChange", {
            get: function () { return this._onDidGroupChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onWillOpenEditor", {
            get: function () { return this._onWillOpenEditor.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onDidOpenEditorFail", {
            get: function () { return this._onDidOpenEditorFail.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onWillCloseEditor", {
            get: function () { return this._onWillCloseEditor.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "onDidCloseEditor", {
            get: function () { return this._onDidCloseEditor.event; },
            enumerable: true,
            configurable: true
        });
        EditorGroupView.prototype.create = function () {
            // Container
            dom_1.addClasses(this.element, 'editor-group-container');
            // Container listeners
            this.registerContainerListeners();
            // Container toolbar
            this.createContainerToolbar();
            // Container context menu
            this.createContainerContextMenu();
            // Letterpress container
            var letterpressContainer = document.createElement('div');
            dom_1.addClass(letterpressContainer, 'editor-group-letterpress');
            this.element.appendChild(letterpressContainer);
            // Progress bar
            this.progressBar = this._register(new progressbar_1.ProgressBar(this.element));
            this._register(styler_1.attachProgressBarStyler(this.progressBar, this.themeService));
            this.progressBar.hide();
            // Scoped services
            var scopedContextKeyService = this._register(this.contextKeyService.createScoped(this.element));
            this.scopedInstantiationService = this.instantiationService.createChild(new serviceCollection_1.ServiceCollection([contextkey_1.IContextKeyService, scopedContextKeyService], [progress_1.IProgressService, new progressService_1.ProgressService(this.progressBar)]));
            // Context keys
            this.handleGroupContextKeys(scopedContextKeyService);
            // Title container
            this.titleContainer = document.createElement('div');
            dom_1.addClass(this.titleContainer, 'title');
            this.element.appendChild(this.titleContainer);
            // Title control
            this.createTitleAreaControl();
            // Editor container
            this.editorContainer = document.createElement('div');
            dom_1.addClass(this.editorContainer, 'editor-container');
            this.element.appendChild(this.editorContainer);
            // Editor control
            this.editorControl = this._register(this.scopedInstantiationService.createInstance(editorControl_1.EditorControl, this.editorContainer, this));
            this._onDidChange.input = this.editorControl.onDidSizeConstraintsChange;
            // Track Focus
            this.doTrackFocus();
            // Update containers
            this.updateTitleContainer();
            this.updateContainer();
            // Update styles
            this.updateStyles();
        };
        EditorGroupView.prototype.handleGroupContextKeys = function (contextKeyServcie) {
            var _this = this;
            var groupActiveEditorDirtyContextKey = editor_1.EditorGroupActiveEditorDirtyContext.bindTo(contextKeyServcie);
            var activeEditorListener;
            var observeActiveEditor = function () {
                activeEditorListener = lifecycle_1.dispose(activeEditorListener);
                var activeEditor = _this._group.activeEditor;
                if (activeEditor) {
                    groupActiveEditorDirtyContextKey.set(activeEditor.isDirty());
                    activeEditorListener = activeEditor.onDidChangeDirty(function () { return groupActiveEditorDirtyContextKey.set(activeEditor.isDirty()); });
                }
                else {
                    groupActiveEditorDirtyContextKey.set(false);
                }
            };
            // Track the active editor and update context key that reflects
            // the dirty state of this editor
            this._register(this.onDidGroupChange(function (e) {
                if (e.kind === 5 /* EDITOR_ACTIVE */) {
                    observeActiveEditor();
                }
            }));
            observeActiveEditor();
        };
        EditorGroupView.prototype.registerContainerListeners = function () {
            var _this = this;
            // Open new file via doubleclick on empty container
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.DBLCLICK, function (e) {
                if (_this.isEmpty()) {
                    dom_1.EventHelper.stop(e);
                    _this.openEditor(_this.untitledEditorService.createOrGet(), editor_1.EditorOptions.create({ pinned: true }));
                }
            }));
            // Close empty editor group via middle mouse click
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.MOUSE_UP, function (e) {
                if (_this.isEmpty() && e.button === 1 /* Middle Button */) {
                    dom_1.EventHelper.stop(e);
                    _this.accessor.removeGroup(_this);
                }
            }));
        };
        EditorGroupView.prototype.createContainerToolbar = function () {
            var _this = this;
            // Toolbar Container
            var toolbarContainer = document.createElement('div');
            dom_1.addClass(toolbarContainer, 'editor-group-container-toolbar');
            this.element.appendChild(toolbarContainer);
            // Toolbar
            var groupId = this._group.id;
            var containerToolbar = new actionbar_1.ActionBar(toolbarContainer, {
                ariaLabel: nls_1.localize('araLabelGroupActions', "Editor group actions"), actionRunner: this._register(new /** @class */ (function (_super) {
                    __extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    class_1.prototype.run = function (action) {
                        return action.run(groupId);
                    };
                    return class_1;
                }(actions_1.ActionRunner)))
            });
            // Toolbar actions
            var removeGroupAction = this._register(new actions_1.Action(editorCommands_1.CLOSE_EDITOR_GROUP_COMMAND_ID, nls_1.localize('closeGroupAction', "Close"), 'close-editor-group', true, function () { _this.accessor.removeGroup(_this); return winjs_base_1.TPromise.as(true); }));
            var keybinding = this.keybindingService.lookupKeybinding(removeGroupAction.id);
            containerToolbar.push(removeGroupAction, { icon: true, label: false, keybinding: keybinding ? keybinding.getLabel() : void 0 });
        };
        EditorGroupView.prototype.createContainerContextMenu = function () {
            var _this = this;
            var menu = this._register(this.menuService.createMenu(actions_2.MenuId.EmptyEditorGroupContext, this.contextKeyService));
            this._register(dom_1.addDisposableListener(this.element, dom_1.EventType.CONTEXT_MENU, function (event) { return _this.onShowContainerContextMenu(menu, event); }));
            this._register(dom_1.addDisposableListener(this.element, touch_1.EventType.Contextmenu, function (event) { return _this.onShowContainerContextMenu(menu); }));
        };
        EditorGroupView.prototype.onShowContainerContextMenu = function (menu, e) {
            var _this = this;
            if (!this.isEmpty()) {
                return; // only for empty editor groups
            }
            // Find target anchor
            var anchor = this.element;
            if (e instanceof MouseEvent) {
                var event_2 = new mouseEvent_1.StandardMouseEvent(e);
                anchor = { x: event_2.posx, y: event_2.posy };
            }
            // Fill in contributed actions
            var actions = [];
            menuItemActionItem_1.fillInContextMenuActions(menu, void 0, actions, this.contextMenuService);
            // Show it
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () { return winjs_base_1.TPromise.as(actions); },
                onHide: function () { return _this.focus(); }
            });
        };
        EditorGroupView.prototype.doTrackFocus = function () {
            var _this = this;
            // Container
            var containerFocusTracker = this._register(dom_1.trackFocus(this.element));
            this._register(containerFocusTracker.onDidFocus(function () {
                if (_this.isEmpty()) {
                    _this._onDidFocus.fire(); // only when empty to prevent accident focus
                }
            }));
            // Title Container
            var handleTitleClickOrTouch = function (e) {
                var target;
                if (e instanceof MouseEvent) {
                    if (e.button !== 0) {
                        return void 0; // only for left mouse click
                    }
                    target = e.target;
                }
                else {
                    target = e.initialTarget;
                }
                if (dom_1.findParentWithClass(target, 'monaco-action-bar', _this.titleContainer) ||
                    dom_1.findParentWithClass(target, 'monaco-breadcrumb-item', _this.titleContainer)) {
                    return; // not when clicking on actions or breadcrumbs
                }
                // timeout to keep focus in editor after mouse up
                setTimeout(function () {
                    _this.focus();
                });
            };
            this._register(dom_1.addDisposableListener(this.titleContainer, dom_1.EventType.MOUSE_DOWN, function (e) { return handleTitleClickOrTouch(e); }));
            this._register(dom_1.addDisposableListener(this.titleContainer, touch_1.EventType.Tap, function (e) { return handleTitleClickOrTouch(e); }));
            // Editor Container
            this._register(this.editorControl.onDidFocus(function () {
                _this._onDidFocus.fire();
            }));
        };
        EditorGroupView.prototype.updateContainer = function () {
            // Empty Container: add some empty container attributes
            if (this.isEmpty()) {
                dom_1.addClass(this.element, 'empty');
                this.element.tabIndex = 0;
                this.element.setAttribute('aria-label', nls_1.localize('emptyEditorGroup', "{0} (empty)", this.label));
            }
            // Non-Empty Container: revert empty container attributes
            else {
                dom_1.removeClass(this.element, 'empty');
                this.element.removeAttribute('tabIndex');
                this.element.removeAttribute('aria-label');
            }
            // Update styles
            this.updateStyles();
        };
        EditorGroupView.prototype.updateTitleContainer = function () {
            dom_1.toggleClass(this.titleContainer, 'tabs', this.accessor.partOptions.showTabs);
            dom_1.toggleClass(this.titleContainer, 'show-file-icons', this.accessor.partOptions.showIcons);
        };
        EditorGroupView.prototype.createTitleAreaControl = function () {
            // Clear old if existing
            if (this.titleAreaControl) {
                this.titleAreaControl.dispose();
                dom_1.clearNode(this.titleContainer);
            }
            // Create new based on options
            if (this.accessor.partOptions.showTabs) {
                this.titleAreaControl = this.scopedInstantiationService.createInstance(tabsTitleControl_1.TabsTitleControl, this.titleContainer, this.accessor, this);
            }
            else {
                this.titleAreaControl = this.scopedInstantiationService.createInstance(noTabsTitleControl_1.NoTabsTitleControl, this.titleContainer, this.accessor, this);
            }
        };
        EditorGroupView.prototype.restoreEditors = function (from) {
            var _this = this;
            if (this._group.count === 0) {
                return winjs_base_1.TPromise.as(void 0); // nothing to show
            }
            // Determine editor options
            var options;
            if (from instanceof EditorGroupView) {
                options = editor_2.getActiveTextEditorOptions(from); // if we copy from another group, ensure to copy its active editor viewstate
            }
            else {
                options = new editor_1.EditorOptions();
            }
            var activeEditor = this._group.activeEditor;
            options.pinned = this._group.isPinned(activeEditor); // preserve pinned state
            options.preserveFocus = true; // handle focus after editor is opened
            // Show active editor
            return this.doShowEditor(activeEditor, true, options).then(function () {
                // Set focused now if this is the active group
                if (_this.accessor.activeGroup === _this) {
                    _this.focus();
                }
            });
        };
        //#region event handling
        EditorGroupView.prototype.registerListeners = function () {
            var _this = this;
            // Model Events
            this._register(this._group.onDidEditorPin(function (editor) { return _this.onDidEditorPin(editor); }));
            this._register(this._group.onDidEditorOpen(function (editor) { return _this.onDidEditorOpen(editor); }));
            this._register(this._group.onDidEditorClose(function (editor) { return _this.onDidEditorClose(editor); }));
            this._register(this._group.onDidEditorDispose(function (editor) { return _this.onDidEditorDispose(editor); }));
            this._register(this._group.onDidEditorBecomeDirty(function (editor) { return _this.onDidEditorBecomeDirty(editor); }));
            this._register(this._group.onDidEditorLabelChange(function (editor) { return _this.onDidEditorLabelChange(editor); }));
            // Option Changes
            this._register(this.accessor.onDidEditorPartOptionsChange(function (e) { return _this.onDidEditorPartOptionsChange(e); }));
        };
        EditorGroupView.prototype.onDidEditorPin = function (editor) {
            // Event
            this._onDidGroupChange.fire({ kind: 7 /* EDITOR_PIN */, editor: editor });
        };
        EditorGroupView.prototype.onDidEditorOpen = function (editor) {
            /* __GDPR__
                "editorOpened" : {
                    "${include}": [
                        "${EditorTelemetryDescriptor}"
                    ]
                }
            */
            this.telemetryService.publicLog('editorOpened', editor.getTelemetryDescriptor());
            // Update container
            this.updateContainer();
            // Event
            this._onDidGroupChange.fire({ kind: 2 /* EDITOR_OPEN */, editor: editor });
        };
        EditorGroupView.prototype.onDidEditorClose = function (event) {
            var _this = this;
            // Before close
            this._onWillCloseEditor.fire(event);
            // Handle event
            var editor = event.editor;
            var editorsToClose = [editor];
            // Include both sides of side by side editors when being closed and not opened multiple times
            if (editor instanceof editor_1.SideBySideEditorInput && !this.accessor.groups.some(function (groupView) { return groupView.group.contains(editor); })) {
                editorsToClose.push(editor.master, editor.details);
            }
            // Close the editor when it is no longer open in any group including diff editors
            editorsToClose.forEach(function (editorToClose) {
                var resource = editorToClose ? editorToClose.getResource() : void 0; // prefer resource to not close right-hand side editors of a diff editor
                if (!_this.accessor.groups.some(function (groupView) { return groupView.group.contains(resource || editorToClose); })) {
                    editorToClose.close();
                }
            });
            /* __GDPR__
                "editorClosed" : {
                    "${include}": [
                        "${EditorTelemetryDescriptor}"
                    ]
                }
            */
            this.telemetryService.publicLog('editorClosed', event.editor.getTelemetryDescriptor());
            // Update container
            this.updateContainer();
            // Event
            this._onDidCloseEditor.fire(event);
            this._onDidGroupChange.fire({ kind: 3 /* EDITOR_CLOSE */, editor: editor, editorIndex: event.index });
        };
        EditorGroupView.prototype.onDidEditorDispose = function (editor) {
            // To prevent race conditions, we handle disposed editors in our worker with a timeout
            // because it can happen that an input is being disposed with the intent to replace
            // it with some other input right after.
            this.disposedEditorsWorker.work(editor);
        };
        EditorGroupView.prototype.handleDisposedEditors = function (editors) {
            var _this = this;
            // Split between visible and hidden editors
            var activeEditor;
            var inactiveEditors = [];
            editors.forEach(function (editor) {
                if (_this._group.isActive(editor)) {
                    activeEditor = editor;
                }
                else if (_this._group.contains(editor)) {
                    inactiveEditors.push(editor);
                }
            });
            // Close all inactive editors first to prevent UI flicker
            inactiveEditors.forEach(function (hidden) { return _this.doCloseEditor(hidden, false); });
            // Close active one last
            if (activeEditor) {
                this.doCloseEditor(activeEditor, false);
            }
        };
        EditorGroupView.prototype.onDidEditorPartOptionsChange = function (event) {
            // Title container
            this.updateTitleContainer();
            // Title control Switch between showing tabs <=> not showing tabs
            if (event.oldPartOptions.showTabs !== event.newPartOptions.showTabs) {
                this.createTitleAreaControl();
                if (this._group.activeEditor) {
                    this.titleAreaControl.openEditor(this._group.activeEditor);
                }
            }
            // Just update title control
            else {
                this.titleAreaControl.updateOptions(event.oldPartOptions, event.newPartOptions);
            }
            // Styles
            this.updateStyles();
            // Pin preview editor once user disables preview
            if (event.oldPartOptions.enablePreview && !event.newPartOptions.enablePreview) {
                this.pinEditor(this._group.previewEditor);
            }
        };
        EditorGroupView.prototype.onDidEditorBecomeDirty = function (editor) {
            // Always show dirty editors pinned
            this.pinEditor(editor);
            // Forward to title control
            this.titleAreaControl.updateEditorDirty(editor);
            // Event
            this._onDidGroupChange.fire({ kind: 8 /* EDITOR_DIRTY */, editor: editor });
        };
        EditorGroupView.prototype.onDidEditorLabelChange = function (editor) {
            // Forward to title control
            this.titleAreaControl.updateEditorLabel(editor);
            // Event
            this._onDidGroupChange.fire({ kind: 6 /* EDITOR_LABEL */, editor: editor });
        };
        Object.defineProperty(EditorGroupView.prototype, "group", {
            //#endregion
            //region IEditorGroupView
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "disposed", {
            get: function () {
                return this._disposed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "whenRestored", {
            get: function () {
                return this._whenRestored;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroupView.prototype.setLabel = function (label) {
            if (this._label !== label) {
                this._label = label;
                this._onDidGroupChange.fire({ kind: 1 /* GROUP_LABEL */ });
            }
        };
        EditorGroupView.prototype.setActive = function (isActive) {
            this.active = isActive;
            // Update container
            dom_1.toggleClass(this.element, 'active', isActive);
            dom_1.toggleClass(this.element, 'inactive', !isActive);
            // Update title control
            this.titleAreaControl.setActive(isActive);
            // Update styles
            this.updateStyles();
            // Event
            this._onDidGroupChange.fire({ kind: 0 /* GROUP_ACTIVE */ });
        };
        EditorGroupView.prototype.isEmpty = function () {
            return this._group.count === 0;
        };
        Object.defineProperty(EditorGroupView.prototype, "id", {
            //#endregion
            //#region IEditorGroup
            //#region basics()
            get: function () {
                return this._group.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "editors", {
            get: function () {
                return this._group.getEditors();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "count", {
            get: function () {
                return this._group.count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "activeControl", {
            get: function () {
                return this.editorControl ? this.editorControl.activeControl : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "activeEditor", {
            get: function () {
                return this._group.activeEditor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "previewEditor", {
            get: function () {
                return this._group.previewEditor;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroupView.prototype.isPinned = function (editor) {
            return this._group.isPinned(editor);
        };
        EditorGroupView.prototype.isActive = function (editor) {
            return this._group.isActive(editor);
        };
        EditorGroupView.prototype.getEditors = function (order) {
            if (order === 0 /* MOST_RECENTLY_ACTIVE */) {
                return this._group.getEditors(true);
            }
            return this.editors;
        };
        EditorGroupView.prototype.getEditor = function (index) {
            return this._group.getEditor(index);
        };
        EditorGroupView.prototype.getIndexOfEditor = function (editor) {
            return this._group.indexOf(editor);
        };
        EditorGroupView.prototype.isOpened = function (editor) {
            return this._group.contains(editor);
        };
        EditorGroupView.prototype.focus = function () {
            // Pass focus to widgets
            if (this.activeControl) {
                this.activeControl.focus();
            }
            else {
                this.element.focus();
            }
            // Event
            this._onDidFocus.fire();
        };
        EditorGroupView.prototype.pinEditor = function (editor) {
            if (editor === void 0) { editor = this.activeEditor; }
            if (editor && !this._group.isPinned(editor)) {
                // Update model
                this._group.pin(editor);
                // Forward to title control
                this.titleAreaControl.pinEditor(editor);
            }
        };
        EditorGroupView.prototype.invokeWithinContext = function (fn) {
            return this.scopedInstantiationService.invokeFunction(fn);
        };
        //#endregion
        //#region openEditor()
        EditorGroupView.prototype.openEditor = function (editor, options) {
            // Guard against invalid inputs
            if (!editor) {
                return winjs_base_1.TPromise.as(void 0);
            }
            // Editor opening event allows for prevention
            var event = new EditorOpeningEvent(this._group.id, editor, options);
            this._onWillOpenEditor.fire(event);
            var prevented = event.isPrevented();
            if (prevented) {
                return prevented();
            }
            // Proceed with opening
            return this.doOpenEditor(editor, options);
        };
        EditorGroupView.prototype.doOpenEditor = function (editor, options) {
            // Determine options
            var openEditorOptions = {
                index: options ? options.index : void 0,
                pinned: !this.accessor.partOptions.enablePreview || editor.isDirty() || (options && options.pinned) || (options && typeof options.index === 'number'),
                active: this._group.count === 0 || !options || !options.inactive
            };
            if (!openEditorOptions.active && !openEditorOptions.pinned && this._group.isPreview(this._group.activeEditor)) {
                // Special case: we are to open an editor inactive and not pinned, but the current active
                // editor is also not pinned, which means it will get replaced with this one. As such,
                // the editor can only be active.
                openEditorOptions.active = true;
            }
            // Set group active unless we open inactive or preserve focus
            // Do this before we open the editor in the group to prevent a false
            // active editor change event before the editor is loaded
            // (see https://github.com/Microsoft/vscode/issues/51679)
            if (openEditorOptions.active && (!options || !options.preserveFocus)) {
                this.accessor.activateGroup(this);
            }
            // Update model
            this._group.openEditor(editor, openEditorOptions);
            // Show editor
            var showEditorResult = this.doShowEditor(editor, openEditorOptions.active, options);
            return showEditorResult;
        };
        EditorGroupView.prototype.doShowEditor = function (editor, active, options) {
            var _this = this;
            // Show in editor control if the active editor changed
            var openEditorPromise;
            if (active) {
                openEditorPromise = this.editorControl.openEditor(editor, options).then(function (result) {
                    // Editor change event
                    if (result.editorChanged) {
                        _this._onDidGroupChange.fire({ kind: 5 /* EDITOR_ACTIVE */, editor: editor });
                    }
                }, function (error) {
                    // Handle errors but do not bubble them up
                    _this.doHandleOpenEditorError(error, editor, options);
                });
            }
            else {
                openEditorPromise = winjs_base_1.TPromise.as(void 0);
            }
            // Show in title control after editor control because some actions depend on it
            this.titleAreaControl.openEditor(editor);
            return openEditorPromise;
        };
        EditorGroupView.prototype.doHandleOpenEditorError = function (error, editor, options) {
            // Report error only if this was not us restoring previous error state or
            // we are told to ignore errors that occur from opening an editor
            if (this.isRestored && !errors_1.isPromiseCanceledError(error) && !this.ignoreOpenEditorErrors) {
                var actions_3 = { primary: [] };
                if (errors_1.isErrorWithActions(error)) {
                    actions_3.primary = error.actions;
                }
                var handle = this.notificationService.notify({
                    severity: notification_1.Severity.Error,
                    message: nls_1.localize('editorOpenError', "Unable to open '{0}': {1}.", editor.getName(), errorMessage_1.toErrorMessage(error)),
                    actions: actions_3
                });
                event_1.once(handle.onDidClose)(function () { return lifecycle_1.dispose(actions_3.primary); });
            }
            // Event
            this._onDidOpenEditorFail.fire(editor);
            // Recover by closing the active editor (if the input is still the active one)
            if (this.activeEditor === editor) {
                var focusNext = !options || !options.preserveFocus;
                this.doCloseEditor(editor, focusNext, true /* from error */);
            }
        };
        //#endregion
        //#region openEditors()
        EditorGroupView.prototype.openEditors = function (editors) {
            var _this = this;
            if (!editors.length) {
                return winjs_base_1.TPromise.as(void 0);
            }
            // Do not modify original array
            editors = editors.slice(0);
            // Use the first editor as active editor
            var _a = editors.shift(), editor = _a.editor, options = _a.options;
            return this.openEditor(editor, options).then(function () {
                var startingIndex = _this.getIndexOfEditor(editor) + 1;
                // Open the other ones inactive
                return Promise.all(editors.map(function (_a, index) {
                    var editor = _a.editor, options = _a.options;
                    var adjustedEditorOptions = options || new editor_1.EditorOptions();
                    adjustedEditorOptions.inactive = true;
                    adjustedEditorOptions.pinned = true;
                    adjustedEditorOptions.index = startingIndex + index;
                    return _this.openEditor(editor, adjustedEditorOptions);
                })).then(function () { return void 0; });
            });
        };
        //#endregion
        //#region moveEditor()
        EditorGroupView.prototype.moveEditor = function (editor, target, options) {
            // Move within same group
            if (this === target) {
                this.doMoveEditorInsideGroup(editor, options);
            }
            // Move across groups
            else {
                this.doMoveOrCopyEditorAcrossGroups(editor, target, options);
            }
        };
        EditorGroupView.prototype.doMoveEditorInsideGroup = function (editor, moveOptions) {
            var moveToIndex = moveOptions ? moveOptions.index : void 0;
            if (typeof moveToIndex !== 'number') {
                return; // do nothing if we move into same group without index
            }
            var currentIndex = this._group.indexOf(editor);
            if (currentIndex === moveToIndex) {
                return; // do nothing if editor is already at the given index
            }
            // Update model
            this._group.moveEditor(editor, moveToIndex);
            this._group.pin(editor);
            // Forward to title area
            this.titleAreaControl.moveEditor(editor, currentIndex, moveToIndex);
            this.titleAreaControl.pinEditor(editor);
            // Event
            this._onDidGroupChange.fire({ kind: 4 /* EDITOR_MOVE */, editor: editor });
        };
        EditorGroupView.prototype.doMoveOrCopyEditorAcrossGroups = function (editor, target, moveOptions, keepCopy) {
            if (moveOptions === void 0) { moveOptions = Object.create(null); }
            // When moving an editor, try to preserve as much view state as possible by checking
            // for the editor to be a text editor and creating the options accordingly if so
            var options = editor_2.getActiveTextEditorOptions(this, editor, editor_1.EditorOptions.create(moveOptions));
            options.pinned = true; // always pin moved editor
            // A move to another group is an open first...
            target.openEditor(editor, options);
            // ...and a close afterwards (unless we copy)
            if (!keepCopy) {
                this.doCloseEditor(editor, false /* do not focus next one behind if any */);
            }
        };
        //#endregion
        //#region copyEditor()
        EditorGroupView.prototype.copyEditor = function (editor, target, options) {
            // Move within same group because we do not support to show the same editor
            // multiple times in the same group
            if (this === target) {
                this.doMoveEditorInsideGroup(editor, options);
            }
            // Copy across groups
            else {
                this.doMoveOrCopyEditorAcrossGroups(editor, target, options, true);
            }
        };
        //#endregion
        //#region closeEditor()
        EditorGroupView.prototype.closeEditor = function (editor) {
            var _this = this;
            if (editor === void 0) { editor = this.activeEditor; }
            if (!editor) {
                return winjs_base_1.TPromise.as(void 0);
            }
            // Check for dirty and veto
            return this.handleDirty([editor]).then(function (veto) {
                if (veto) {
                    return;
                }
                // Do close
                _this.doCloseEditor(editor);
            });
        };
        EditorGroupView.prototype.doCloseEditor = function (editor, focusNext, fromError) {
            if (focusNext === void 0) { focusNext = this.accessor.activeGroup === this; }
            // Closing the active editor of the group is a bit more work
            if (this._group.isActive(editor)) {
                this.doCloseActiveEditor(focusNext, fromError);
            }
            // Closing inactive editor is just a model update
            else {
                this.doCloseInactiveEditor(editor);
            }
            // Forward to title control
            this.titleAreaControl.closeEditor(editor);
        };
        EditorGroupView.prototype.doCloseActiveEditor = function (focusNext, fromError) {
            var _this = this;
            if (focusNext === void 0) { focusNext = this.accessor.activeGroup === this; }
            var editorToClose = this.activeEditor;
            var editorHasFocus = dom_1.isAncestor(document.activeElement, this.element);
            // Optimization: if we are about to close the last editor in this group and settings
            // are configured to close the group since it will be empty, we first set the last
            // active group as empty before closing the editor. This reduces the amount of editor
            // change events that this operation emits and will reduce flicker. Without this
            // optimization, this group (if active) would first trigger a active editor change
            // event because it became empty, only to then trigger another one when the next
            // group gets active.
            var closeEmptyGroup = this.accessor.partOptions.closeEmptyGroups;
            if (closeEmptyGroup && this.active && this._group.count === 1) {
                var mostRecentlyActiveGroups = this.accessor.getGroups(1 /* MOST_RECENTLY_ACTIVE */);
                var nextActiveGroup = mostRecentlyActiveGroups[1]; // [0] will be the current one, so take [1]
                if (nextActiveGroup) {
                    if (editorHasFocus) {
                        nextActiveGroup.focus();
                    }
                    else {
                        this.accessor.activateGroup(nextActiveGroup);
                    }
                }
            }
            // Update model
            this._group.closeEditor(editorToClose);
            // Open next active if there are more to show
            var nextActiveEditor = this._group.activeEditor;
            if (nextActiveEditor) {
                // When closing an editor due to an error we can end up in a loop where we continue closing
                // editors that fail to open (e.g. when the file no longer exists). We do not want to show
                // repeated errors in this case to the user. As such, if we open the next editor and we are
                // in a scope of a previous editor failing, we silence the input errors until the editor is
                // opened.
                if (fromError) {
                    this.ignoreOpenEditorErrors = true;
                }
                var options = !focusNext ? editor_1.EditorOptions.create({ preserveFocus: true }) : void 0;
                this.openEditor(nextActiveEditor, options).then(function () {
                    _this.ignoreOpenEditorErrors = false;
                });
            }
            // Otherwise we are empty, so clear from editor control and send event
            else {
                // Forward to editor control
                this.editorControl.closeEditor(editorToClose);
                // Restore focus to group container as needed unless group gets closed
                if (editorHasFocus && !closeEmptyGroup) {
                    this.focus();
                }
                // Events
                this._onDidGroupChange.fire({ kind: 5 /* EDITOR_ACTIVE */ });
                // Remove empty group if we should
                if (closeEmptyGroup) {
                    this.accessor.removeGroup(this);
                }
            }
        };
        EditorGroupView.prototype.doCloseInactiveEditor = function (editor) {
            // Update model
            this._group.closeEditor(editor);
        };
        EditorGroupView.prototype.handleDirty = function (editors) {
            var _this = this;
            if (!editors.length) {
                return winjs_base_1.TPromise.as(false); // no veto
            }
            var editor = editors.shift();
            // To prevent multiple confirmation dialogs from showing up one after the other
            // we check if a pending confirmation is currently showing and if so, join that
            var handleDirtyPromise = this.mapEditorToPendingConfirmation.get(editor);
            if (!handleDirtyPromise) {
                handleDirtyPromise = this.doHandleDirty(editor);
                this.mapEditorToPendingConfirmation.set(editor, handleDirtyPromise);
            }
            return handleDirtyPromise.then(function (veto) {
                // Make sure to remove from our map of cached pending confirmations
                _this.mapEditorToPendingConfirmation.delete(editor);
                // Return for the first veto we got
                if (veto) {
                    return veto;
                }
                // Otherwise continue with the remainders
                return _this.handleDirty(editors);
            });
        };
        EditorGroupView.prototype.doHandleDirty = function (editor) {
            var _this = this;
            if (!editor.isDirty() || // editor must be dirty
                this.accessor.groups.some(function (groupView) { return groupView !== _this && groupView.group.contains(editor, true /* support side by side */); }) || // editor is opened in other group
                editor instanceof editor_1.SideBySideEditorInput && this.isOpened(editor.master) // side by side editor master is still opened
            ) {
                return winjs_base_1.TPromise.as(false);
            }
            // Switch to editor that we want to handle and confirm to save/revert
            return this.openEditor(editor).then(function () { return editor.confirmSave().then(function (res) {
                // It could be that the editor saved meanwhile, so we check again
                // to see if anything needs to happen before closing for good.
                // This can happen for example if autoSave: onFocusChange is configured
                // so that the save happens when the dialog opens.
                if (!editor.isDirty()) {
                    return res === 2 /* CANCEL */ ? true : false;
                }
                // Otherwise, handle accordingly
                switch (res) {
                    case 0 /* SAVE */:
                        return editor.save().then(function (ok) { return !ok; });
                    case 1 /* DONT_SAVE */:
                        // first try a normal revert where the contents of the editor are restored
                        return editor.revert().then(function (ok) { return !ok; }, function (error) {
                            // if that fails, since we are about to close the editor, we accept that
                            // the editor cannot be reverted and instead do a soft revert that just
                            // enables us to close the editor. With this, a user can always close a
                            // dirty editor even when reverting fails.
                            return editor.revert({ soft: true }).then(function (ok) { return !ok; });
                        });
                    case 2 /* CANCEL */:
                        return true; // veto
                }
            }); });
        };
        //#endregion
        //#region closeEditors()
        EditorGroupView.prototype.closeEditors = function (args) {
            var _this = this;
            if (this.isEmpty()) {
                return winjs_base_1.TPromise.as(void 0);
            }
            var editors = this.getEditorsToClose(args);
            // Check for dirty and veto
            return this.handleDirty(editors.slice(0)).then(function (veto) {
                if (veto) {
                    return;
                }
                // Do close
                _this.doCloseEditors(editors);
            });
        };
        EditorGroupView.prototype.getEditorsToClose = function (editors) {
            if (Array.isArray(editors)) {
                return editors;
            }
            var filter = editors;
            var hasDirection = typeof filter.direction === 'number';
            var editorsToClose = this._group.getEditors(!hasDirection /* in MRU order only if direction is not specified */);
            // Filter: saved only
            if (filter.savedOnly) {
                editorsToClose = editorsToClose.filter(function (e) { return !e.isDirty(); });
            }
            // Filter: direction (left / right)
            else if (hasDirection) {
                editorsToClose = (filter.direction === 0 /* LEFT */) ?
                    editorsToClose.slice(0, this._group.indexOf(filter.except)) :
                    editorsToClose.slice(this._group.indexOf(filter.except) + 1);
            }
            // Filter: except
            else if (filter.except) {
                editorsToClose = editorsToClose.filter(function (e) { return !e.matches(filter.except); });
            }
            return editorsToClose;
        };
        EditorGroupView.prototype.doCloseEditors = function (editors) {
            var _this = this;
            // Close all inactive editors first
            var closeActiveEditor = false;
            editors.forEach(function (editor) {
                if (!_this.isActive(editor)) {
                    _this.doCloseInactiveEditor(editor);
                }
                else {
                    closeActiveEditor = true;
                }
            });
            // Close active editor last if contained in editors list to close
            if (closeActiveEditor) {
                this.doCloseActiveEditor();
            }
            // Forward to title control
            this.titleAreaControl.closeEditors(editors);
        };
        //#endregion
        //#region closeAllEditors()
        EditorGroupView.prototype.closeAllEditors = function () {
            var _this = this;
            if (this.isEmpty()) {
                // If the group is empty and the request is to close all editors, we still close
                // the editor group is the related setting to close empty groups is enabled for
                // a convinient way of removing empty editor groups for the user.
                if (this.accessor.partOptions.closeEmptyGroups) {
                    this.accessor.removeGroup(this);
                }
                return winjs_base_1.TPromise.as(void 0);
            }
            // Check for dirty and veto
            var editors = this._group.getEditors(true);
            return this.handleDirty(editors.slice(0)).then(function (veto) {
                if (veto) {
                    return;
                }
                // Do close
                _this.doCloseAllEditors();
            });
        };
        EditorGroupView.prototype.doCloseAllEditors = function () {
            var _this = this;
            // Close all inactive editors first
            this.editors.forEach(function (editor) {
                if (!_this.isActive(editor)) {
                    _this.doCloseInactiveEditor(editor);
                }
            });
            // Close active editor last
            this.doCloseActiveEditor();
            // Forward to title control
            this.titleAreaControl.closeAllEditors();
        };
        //#endregion
        //#region replaceEditors()
        EditorGroupView.prototype.replaceEditors = function (editors) {
            var _this = this;
            // Extract active vs. inactive replacements
            var activeReplacement;
            var inactiveReplacements = [];
            editors.forEach(function (_a) {
                var editor = _a.editor, replacement = _a.replacement, options = _a.options;
                if (editor.isDirty()) {
                    return; // we do not handle dirty in this method, so ignore all dirty
                }
                var index = _this.getIndexOfEditor(editor);
                if (index >= 0) {
                    var isActiveEditor = _this.isActive(editor);
                    // make sure we respect the index of the editor to replace
                    if (options) {
                        options.index = index;
                    }
                    else {
                        options = editor_1.EditorOptions.create({ index: index });
                    }
                    options.inactive = !isActiveEditor;
                    options.pinned = true;
                    var editorToReplace = { editor: editor, replacement: replacement, options: options };
                    if (isActiveEditor) {
                        activeReplacement = editorToReplace;
                    }
                    else {
                        inactiveReplacements.push(editorToReplace);
                    }
                }
            });
            // Handle inactive first
            inactiveReplacements.forEach(function (_a) {
                var editor = _a.editor, replacement = _a.replacement, options = _a.options;
                // Open inactive editor
                _this.doOpenEditor(replacement, options);
                // Close replaced inactive edior
                _this.doCloseInactiveEditor(editor);
                // Forward to title control
                _this.titleAreaControl.closeEditor(editor);
            });
            // Handle active last
            if (activeReplacement) {
                // Open replacement as active editor
                var openEditorResult = this.doOpenEditor(activeReplacement.replacement, activeReplacement.options);
                // Close previous active editor
                this.doCloseInactiveEditor(activeReplacement.editor);
                // Forward to title control
                this.titleAreaControl.closeEditor(activeReplacement.editor);
                return openEditorResult;
            }
            return winjs_base_1.TPromise.as(void 0);
        };
        //#endregion
        //#endregion
        //#region Themable
        EditorGroupView.prototype.updateStyles = function () {
            var isEmpty = this.isEmpty();
            // Container
            if (isEmpty) {
                this.element.style.backgroundColor = this.getColor(theme_1.EDITOR_GROUP_EMPTY_BACKGROUND);
            }
            else {
                this.element.style.backgroundColor = null;
            }
            // Title control
            var showTabs = this.accessor.partOptions.showTabs;
            var borderColor = this.getColor(theme_1.EDITOR_GROUP_HEADER_TABS_BORDER) || this.getColor(colorRegistry_1.contrastBorder);
            if (!isEmpty && showTabs && borderColor) {
                dom_1.addClass(this.titleContainer, 'title-border-bottom');
                this.titleContainer.style.setProperty('--title-border-bottom-color', borderColor.toString());
            }
            else {
                dom_1.removeClass(this.titleContainer, 'title-border-bottom');
                this.titleContainer.style.removeProperty('--title-border-bottom-color');
            }
            this.titleContainer.style.backgroundColor = this.getColor(showTabs ? theme_1.EDITOR_GROUP_HEADER_TABS_BACKGROUND : theme_1.EDITOR_GROUP_HEADER_NO_TABS_BACKGROUND);
            // Editor container
            this.editorContainer.style.backgroundColor = this.getColor(colorRegistry_1.editorBackground);
        };
        Object.defineProperty(EditorGroupView.prototype, "minimumWidth", {
            get: function () { return this.editorControl.minimumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "minimumHeight", {
            get: function () { return this.editorControl.minimumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "maximumWidth", {
            get: function () { return this.editorControl.maximumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorGroupView.prototype, "maximumHeight", {
            get: function () { return this.editorControl.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        EditorGroupView.prototype.layout = function (width, height) {
            this.dimension = new dom_1.Dimension(width, height);
            // Forward to controls
            this.titleAreaControl.layout(new dom_1.Dimension(this.dimension.width, this.titleAreaControl.getPreferredHeight()));
            this.editorControl.layout(new dom_1.Dimension(this.dimension.width, this.dimension.height - this.titleAreaControl.getPreferredHeight()));
        };
        EditorGroupView.prototype.relayout = function () {
            if (this.dimension) {
                var _a = this.dimension, width = _a.width, height = _a.height;
                this.layout(width, height);
            }
        };
        EditorGroupView.prototype.toJSON = function () {
            return this._group.serialize();
        };
        //#endregion
        EditorGroupView.prototype.shutdown = function () {
            this.editorControl.shutdown();
        };
        EditorGroupView.prototype.dispose = function () {
            this._disposed = true;
            this._onWillDispose.fire();
            this.titleAreaControl.dispose();
            // this.editorControl = null;
            _super.prototype.dispose.call(this);
        };
        EditorGroupView = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, contextkey_1.IContextKeyService),
            __param(5, themeService_1.IThemeService),
            __param(6, notification_1.INotificationService),
            __param(7, telemetry_1.ITelemetryService),
            __param(8, untitledEditorService_1.IUntitledEditorService),
            __param(9, keybinding_1.IKeybindingService),
            __param(10, actions_2.IMenuService),
            __param(11, contextView_1.IContextMenuService)
        ], EditorGroupView);
        return EditorGroupView;
    }(theme_1.Themable));
    exports.EditorGroupView = EditorGroupView;
    var EditorOpeningEvent = /** @class */ (function () {
        function EditorOpeningEvent(_group, _editor, _options) {
            this._group = _group;
            this._editor = _editor;
            this._options = _options;
        }
        Object.defineProperty(EditorOpeningEvent.prototype, "groupId", {
            get: function () {
                return this._group;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorOpeningEvent.prototype, "editor", {
            get: function () {
                return this._editor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorOpeningEvent.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: true,
            configurable: true
        });
        EditorOpeningEvent.prototype.prevent = function (callback) {
            this.override = callback;
        };
        EditorOpeningEvent.prototype.isPrevented = function () {
            return this.override;
        };
        return EditorOpeningEvent;
    }());
    themeService_1.registerThemingParticipant(function (theme, collector, environment) {
        // Letterpress
        var letterpress = "resources/letterpress" + (theme.type === 'dark' ? '-dark' : theme.type === 'hc' ? '-hc' : '') + ".svg";
        collector.addRule("\n\t\t.monaco-workbench > .part.editor > .content .editor-group-container.empty .editor-group-letterpress {\n\t\t\tbackground-image: url('" + paths_1.join(environment.appRoot, letterpress) + "')\n\t\t}\n\t");
        // Focused Empty Group Border
        var focusedEmptyGroupBorder = theme.getColor(theme_1.EDITOR_GROUP_FOCUSED_EMPTY_BORDER);
        if (focusedEmptyGroupBorder) {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content:not(.empty) .editor-group-container.empty.active:focus {\n\t\t\t\toutline-width: 1px;\n\t\t\t\toutline-color: " + focusedEmptyGroupBorder + ";\n\t\t\t\toutline-offset: -2px;\n\t\t\t\toutline-style: solid;\n\t\t\t}\n\n\t\t\t.monaco-workbench > .part.editor > .content.empty .editor-group-container.empty.active:focus {\n\t\t\t\toutline: none; /* never show outline for empty group if it is the last */\n\t\t\t}\n\t\t");
        }
        else {
            collector.addRule("\n\t\t\t.monaco-workbench > .part.editor > .content .editor-group-container.empty.active:focus {\n\t\t\t\toutline: none; /* disable focus outline unless active empty group border is defined */\n\t\t\t}\n\t\t");
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[353/*vs/workbench/browser/parts/editor/editorPart*/], __M([0/*require*/,1/*exports*/,14/*vs/platform/theme/common/themeService*/,364/*vs/workbench/browser/part*/,8/*vs/base/browser/dom*/,6/*vs/base/common/event*/,30/*vs/platform/theme/common/colorRegistry*/,3/*vs/platform/instantiation/common/instantiation*/,359/*vs/base/browser/ui/grid/grid*/,39/*vs/base/common/map*/,58/*vs/workbench/common/theme*/,19/*vs/base/common/arrays*/,87/*vs/workbench/browser/parts/editor/editor*/,374/*vs/workbench/browser/parts/editor/editorGroupView*/,7/*vs/platform/configuration/common/configuration*/,4/*vs/base/common/lifecycle*/,38/*vs/base/common/objects*/,44/*vs/platform/storage/common/storage*/,188/*vs/workbench/common/editor/editorGroup*/,5/*vs/base/common/winjs.base*/,17/*vs/base/common/async*/,412/*vs/workbench/browser/parts/editor/editorDropTarget*/,2/*vs/nls*/,75/*vs/base/common/color*/,355/*vs/base/browser/ui/centered/centeredViewLayout*/,219/*vs/base/browser/ui/grid/gridview*/,25/*vs/base/common/errors*/,417/*vs/workbench/browser/parts/editor/editor.contribution*/]), function (require, exports, themeService_1, part_1, dom_1, event_1, colorRegistry_1, instantiation_1, grid_1, map_1, theme_1, arrays_1, editor_1, editorGroupView_1, configuration_1, lifecycle_1, objects_1, storage_1, editorGroup_1, winjs_base_1, async_1, editorDropTarget_1, nls_1, color_1, centeredViewLayout_1, gridview_1, errors_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var GridWidgetView = /** @class */ (function () {
        function GridWidgetView() {
            this.element = dom_1.$('.grid-view-container');
            this._onDidChange = new event_1.Relay();
            this.onDidChange = this._onDidChange.event;
        }
        Object.defineProperty(GridWidgetView.prototype, "minimumWidth", {
            get: function () { return this.gridWidget ? this.gridWidget.minimumWidth : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridWidgetView.prototype, "maximumWidth", {
            get: function () { return this.gridWidget ? this.gridWidget.maximumWidth : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridWidgetView.prototype, "minimumHeight", {
            get: function () { return this.gridWidget ? this.gridWidget.minimumHeight : 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridWidgetView.prototype, "maximumHeight", {
            get: function () { return this.gridWidget ? this.gridWidget.maximumHeight : Number.POSITIVE_INFINITY; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GridWidgetView.prototype, "gridWidget", {
            get: function () {
                return this._gridWidget;
            },
            set: function (grid) {
                this.element.innerHTML = '';
                if (grid) {
                    this.element.appendChild(grid.element);
                    this._onDidChange.input = grid.onDidChange;
                }
                else {
                    this._onDidChange.input = event_1.Event.None;
                }
                this._gridWidget = grid;
            },
            enumerable: true,
            configurable: true
        });
        GridWidgetView.prototype.layout = function (width, height) {
            if (this.gridWidget) {
                this.gridWidget.layout(width, height);
            }
        };
        GridWidgetView.prototype.dispose = function () {
            this._onDidChange.dispose();
        };
        return GridWidgetView;
    }());
    var EditorPart = /** @class */ (function (_super) {
        __extends(EditorPart, _super);
        function EditorPart(id, restorePreviousState, instantiationService, themeService, configurationService, storageService) {
            var _this = _super.call(this, id, { hasTitle: false }, themeService) || this;
            _this.restorePreviousState = restorePreviousState;
            _this.instantiationService = instantiationService;
            _this.configurationService = configurationService;
            _this.storageService = storageService;
            //#region Events
            _this._onDidLayout = _this._register(new event_1.Emitter());
            _this._onDidActiveGroupChange = _this._register(new event_1.Emitter());
            _this._onDidAddGroup = _this._register(new event_1.Emitter());
            _this._onDidRemoveGroup = _this._register(new event_1.Emitter());
            _this._onDidMoveGroup = _this._register(new event_1.Emitter());
            _this.onDidSetGridWidget = _this._register(new event_1.Emitter());
            _this._onDidSizeConstraintsChange = _this._register(new event_1.Relay());
            _this._onDidPreferredSizeChange = _this._register(new event_1.Emitter());
            _this.groupViews = new Map();
            _this.mostRecentActiveGroups = [];
            //#region IEditorGroupsAccessor
            _this.enforcedPartOptions = [];
            _this._onDidEditorPartOptionsChange = _this._register(new event_1.Emitter());
            _this.gridWidgetView = new GridWidgetView();
            _this._partOptions = editor_1.getEditorPartOptions(_this.configurationService.getValue());
            _this.memento = _this.getMemento(_this.storageService, 1 /* WORKSPACE */);
            _this.globalMemento = _this.getMemento(_this.storageService, 0 /* GLOBAL */);
            _this._whenRestored = new winjs_base_1.TPromise(function (resolve) {
                _this.whenRestoredComplete = resolve;
            });
            _this.registerListeners();
            return _this;
        }
        Object.defineProperty(EditorPart.prototype, "onDidLayout", {
            get: function () { return this._onDidLayout.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidActiveGroupChange", {
            get: function () { return this._onDidActiveGroupChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidAddGroup", {
            get: function () { return this._onDidAddGroup.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidRemoveGroup", {
            get: function () { return this._onDidRemoveGroup.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidMoveGroup", {
            get: function () { return this._onDidMoveGroup.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidSizeConstraintsChange", {
            get: function () { return event_1.anyEvent(this.onDidSetGridWidget.event, this._onDidSizeConstraintsChange.event); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidPreferredSizeChange", {
            get: function () { return this._onDidPreferredSizeChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "onDidEditorPartOptionsChange", {
            get: function () { return this._onDidEditorPartOptionsChange.event; },
            enumerable: true,
            configurable: true
        });
        EditorPart.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(e); }));
        };
        EditorPart.prototype.onConfigurationUpdated = function (event) {
            if (editor_1.impactsEditorPartOptions(event)) {
                this.handleChangedPartOptions();
            }
        };
        EditorPart.prototype.handleChangedPartOptions = function () {
            var oldPartOptions = this._partOptions;
            var newPartOptions = editor_1.getEditorPartOptions(this.configurationService.getValue());
            this.enforcedPartOptions.forEach(function (enforcedPartOptions) {
                objects_1.assign(newPartOptions, enforcedPartOptions); // check for overrides
            });
            this._partOptions = newPartOptions;
            this._onDidEditorPartOptionsChange.fire({ oldPartOptions: oldPartOptions, newPartOptions: newPartOptions });
        };
        Object.defineProperty(EditorPart.prototype, "partOptions", {
            get: function () {
                return this._partOptions;
            },
            enumerable: true,
            configurable: true
        });
        EditorPart.prototype.enforcePartOptions = function (options) {
            var _this = this;
            this.enforcedPartOptions.push(options);
            this.handleChangedPartOptions();
            return lifecycle_1.toDisposable(function () {
                _this.enforcedPartOptions.splice(_this.enforcedPartOptions.indexOf(options), 1);
                _this.handleChangedPartOptions();
            });
        };
        Object.defineProperty(EditorPart.prototype, "activeGroup", {
            //#endregion
            //#region IEditorGroupsService
            get: function () {
                return this._activeGroup;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "groups", {
            get: function () {
                return map_1.values(this.groupViews);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "count", {
            get: function () {
                return this.groupViews.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "orientation", {
            get: function () {
                if (!this.gridWidget) {
                    return void 0; // we have not been created yet
                }
                return this.gridWidget.orientation === 0 /* VERTICAL */ ? 1 /* VERTICAL */ : 0 /* HORIZONTAL */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "whenRestored", {
            get: function () {
                return this._whenRestored;
            },
            enumerable: true,
            configurable: true
        });
        EditorPart.prototype.getGroups = function (order) {
            var _this = this;
            if (order === void 0) { order = 0 /* CREATION_TIME */; }
            switch (order) {
                case 0 /* CREATION_TIME */:
                    return this.groups;
                case 1 /* MOST_RECENTLY_ACTIVE */:
                    var mostRecentActive = this.mostRecentActiveGroups.map(function (groupId) { return _this.getGroup(groupId); });
                    // there can be groups that got never active, even though they exist. in this case
                    // make sure to ust append them at the end so that all groups are returned properly
                    return arrays_1.distinct(mostRecentActive.concat(this.groups));
                case 2 /* GRID_APPEARANCE */:
                    var views = [];
                    if (this.gridWidget) {
                        this.fillGridNodes(views, this.gridWidget.getViews());
                    }
                    return views;
            }
        };
        EditorPart.prototype.fillGridNodes = function (target, node) {
            var _this = this;
            if (grid_1.isGridBranchNode(node)) {
                node.children.forEach(function (child) { return _this.fillGridNodes(target, child); });
            }
            else {
                target.push(node.view);
            }
        };
        EditorPart.prototype.getGroup = function (identifier) {
            return this.groupViews.get(identifier);
        };
        EditorPart.prototype.findGroup = function (scope, source, wrap) {
            if (source === void 0) { source = this.activeGroup; }
            // by direction
            if (typeof scope.direction === 'number') {
                return this.doFindGroupByDirection(scope.direction, source, wrap);
            }
            // by location
            return this.doFindGroupByLocation(scope.location, source, wrap);
        };
        EditorPart.prototype.doFindGroupByDirection = function (direction, source, wrap) {
            var _this = this;
            var sourceGroupView = this.assertGroupView(source);
            // Find neighbours and sort by our MRU list
            var neighbours = this.gridWidget.getNeighborViews(sourceGroupView, this.toGridViewDirection(direction), wrap);
            neighbours.sort((function (n1, n2) { return _this.mostRecentActiveGroups.indexOf(n1.id) - _this.mostRecentActiveGroups.indexOf(n2.id); }));
            return neighbours[0];
        };
        EditorPart.prototype.doFindGroupByLocation = function (location, source, wrap) {
            var sourceGroupView = this.assertGroupView(source);
            var groups = this.getGroups(2 /* GRID_APPEARANCE */);
            var index = groups.indexOf(sourceGroupView);
            switch (location) {
                case 0 /* FIRST */:
                    return groups[0];
                case 1 /* LAST */:
                    return groups[groups.length - 1];
                case 2 /* NEXT */:
                    var nextGroup = groups[index + 1];
                    if (!nextGroup && wrap) {
                        nextGroup = this.doFindGroupByLocation(0 /* FIRST */, source);
                    }
                    return nextGroup;
                case 3 /* PREVIOUS */:
                    var previousGroup = groups[index - 1];
                    if (!previousGroup && wrap) {
                        previousGroup = this.doFindGroupByLocation(1 /* LAST */, source);
                    }
                    return previousGroup;
            }
        };
        EditorPart.prototype.activateGroup = function (group) {
            var groupView = this.assertGroupView(group);
            this.doSetGroupActive(groupView);
            return groupView;
        };
        EditorPart.prototype.getSize = function (group) {
            var groupView = this.assertGroupView(group);
            return this.gridWidget.getViewSize(groupView);
        };
        EditorPart.prototype.setSize = function (group, size) {
            var groupView = this.assertGroupView(group);
            this.gridWidget.resizeView(groupView, size);
        };
        EditorPart.prototype.arrangeGroups = function (arrangement) {
            if (this.count < 2) {
                return; // require at least 2 groups to show
            }
            if (!this.gridWidget) {
                return; // we have not been created yet
            }
            // Even all group sizes
            if (arrangement === 1 /* EVEN */) {
                this.gridWidget.distributeViewSizes();
            }
            // Maximize the current active group
            else {
                this.gridWidget.maximizeViewSize(this.activeGroup);
            }
        };
        EditorPart.prototype.setGroupOrientation = function (orientation) {
            if (!this.gridWidget) {
                return; // we have not been created yet
            }
            var newOrientation = (orientation === 0 /* HORIZONTAL */) ? 1 /* HORIZONTAL */ : 0 /* VERTICAL */;
            if (this.gridWidget.orientation !== newOrientation) {
                this.gridWidget.orientation = newOrientation;
                // Mark preferred size as changed
                this.resetPreferredSize();
            }
        };
        EditorPart.prototype.applyLayout = function (layout) {
            var _this = this;
            var gridHasFocus = dom_1.isAncestor(document.activeElement, this.container);
            // Determine how many groups we need overall
            var layoutGroupsCount = 0;
            function countGroups(groups) {
                groups.forEach(function (group) {
                    if (Array.isArray(group.groups)) {
                        countGroups(group.groups);
                    }
                    else {
                        layoutGroupsCount++;
                    }
                });
            }
            countGroups(layout.groups);
            // If we currently have too many groups, merge them into the last one
            var currentGroupViews = this.getGroups(2 /* GRID_APPEARANCE */);
            if (layoutGroupsCount < currentGroupViews.length) {
                var lastGroupInLayout_1 = currentGroupViews[layoutGroupsCount - 1];
                currentGroupViews.forEach(function (group, index) {
                    if (index >= layoutGroupsCount) {
                        _this.mergeGroup(group, lastGroupInLayout_1);
                    }
                });
                currentGroupViews = this.getGroups(2 /* GRID_APPEARANCE */);
            }
            var activeGroup = this.activeGroup;
            // Prepare grid descriptor to create new grid from
            var gridDescriptor = grid_1.createSerializedGrid({
                orientation: this.toGridViewOrientation(layout.orientation, this.isTwoDimensionalGrid() ?
                    this.gridWidget.orientation : // preserve original orientation for 2-dimensional grids
                    gridview_1.orthogonal(this.gridWidget.orientation) // otherwise flip (fix https://github.com/Microsoft/vscode/issues/52975)
                ),
                groups: layout.groups
            });
            // Recreate gridwidget with descriptor
            this.doCreateGridControlWithState(gridDescriptor, activeGroup.id, currentGroupViews);
            // Layout
            this.doLayout(this.dimension);
            // Update container
            this.updateContainer();
            // Mark preferred size as changed
            this.resetPreferredSize();
            // Events for groups that got added
            this.getGroups(2 /* GRID_APPEARANCE */).forEach(function (groupView) {
                if (currentGroupViews.indexOf(groupView) === -1) {
                    _this._onDidAddGroup.fire(groupView);
                }
            });
            // Update labels
            this.updateGroupLabels();
            // Restore focus as needed
            if (gridHasFocus) {
                this._activeGroup.focus();
            }
        };
        EditorPart.prototype.isTwoDimensionalGrid = function () {
            var views = this.gridWidget.getViews();
            if (grid_1.isGridBranchNode(views)) {
                // the grid is 2-dimensional if any children
                // of the grid is a branch node
                return views.children.some(function (child) { return grid_1.isGridBranchNode(child); });
            }
            return false;
        };
        EditorPart.prototype.addGroup = function (location, direction, options) {
            var locationView = this.assertGroupView(location);
            var group = this.doAddGroup(locationView, direction);
            if (options && options.activate) {
                this.doSetGroupActive(group);
            }
            return group;
        };
        EditorPart.prototype.doAddGroup = function (locationView, direction, groupToCopy) {
            var newGroupView = this.doCreateGroupView(groupToCopy);
            // Add to grid widget
            this.gridWidget.addView(newGroupView, "distribute" /* Distribute */, locationView, this.toGridViewDirection(direction));
            // Update container
            this.updateContainer();
            // Mark preferred size as changed
            this.resetPreferredSize();
            // Event
            this._onDidAddGroup.fire(newGroupView);
            // Update labels
            this.updateGroupLabels();
            return newGroupView;
        };
        EditorPart.prototype.doCreateGroupView = function (from) {
            var _this = this;
            // Label: just use the number of existing groups as label
            var label = this.getGroupLabel(this.count + 1);
            // Create group view
            var groupView;
            if (from instanceof editorGroupView_1.EditorGroupView) {
                groupView = editorGroupView_1.EditorGroupView.createCopy(from, this, label, this.instantiationService);
            }
            else if (editorGroup_1.isSerializedEditorGroup(from)) {
                groupView = editorGroupView_1.EditorGroupView.createFromSerialized(from, this, label, this.instantiationService);
            }
            else {
                groupView = editorGroupView_1.EditorGroupView.createNew(this, label, this.instantiationService);
            }
            // Keep in map
            this.groupViews.set(groupView.id, groupView);
            // Track focus
            var groupDisposables = [];
            groupDisposables.push(groupView.onDidFocus(function () {
                _this.doSetGroupActive(groupView);
            }));
            // Track editor change
            groupDisposables.push(groupView.onDidGroupChange(function (e) {
                if (e.kind === 5 /* EDITOR_ACTIVE */) {
                    _this.updateContainer();
                }
            }));
            // Track dispose
            event_1.once(groupView.onWillDispose)(function () {
                groupDisposables = lifecycle_1.dispose(groupDisposables);
                _this.groupViews.delete(groupView.id);
                _this.doUpdateMostRecentActive(groupView);
            });
            return groupView;
        };
        EditorPart.prototype.doSetGroupActive = function (group) {
            if (this._activeGroup === group) {
                return; // return if this is already the active group
            }
            var previousActiveGroup = this._activeGroup;
            this._activeGroup = group;
            // Update list of most recently active groups
            this.doUpdateMostRecentActive(group, true);
            // Mark previous one as inactive
            if (previousActiveGroup) {
                previousActiveGroup.setActive(false);
            }
            // Mark group as new active
            group.setActive(true);
            // Maximize the group if it is currently minimized
            if (this.gridWidget) {
                var viewSize = this.gridWidget.getViewSize2(group);
                if (viewSize.width === group.minimumWidth || viewSize.height === group.minimumHeight) {
                    this.arrangeGroups(0 /* MINIMIZE_OTHERS */);
                }
            }
            // Event
            this._onDidActiveGroupChange.fire(group);
        };
        EditorPart.prototype.doUpdateMostRecentActive = function (group, makeMostRecentlyActive) {
            var index = this.mostRecentActiveGroups.indexOf(group.id);
            // Remove from MRU list
            if (index !== -1) {
                this.mostRecentActiveGroups.splice(index, 1);
            }
            // Add to front as needed
            if (makeMostRecentlyActive) {
                this.mostRecentActiveGroups.unshift(group.id);
            }
        };
        EditorPart.prototype.toGridViewDirection = function (direction) {
            switch (direction) {
                case 0 /* UP */: return 0 /* Up */;
                case 1 /* DOWN */: return 1 /* Down */;
                case 2 /* LEFT */: return 2 /* Left */;
                case 3 /* RIGHT */: return 3 /* Right */;
            }
        };
        EditorPart.prototype.toGridViewOrientation = function (orientation, fallback) {
            if (typeof orientation === 'number') {
                return orientation === 0 /* HORIZONTAL */ ? 1 /* HORIZONTAL */ : 0 /* VERTICAL */;
            }
            return fallback;
        };
        EditorPart.prototype.removeGroup = function (group) {
            var groupView = this.assertGroupView(group);
            if (this.groupViews.size === 1) {
                return; // Cannot remove the last root group
            }
            // Remove empty group
            if (groupView.isEmpty()) {
                return this.doRemoveEmptyGroup(groupView);
            }
            // Remove group with editors
            this.doRemoveGroupWithEditors(groupView);
        };
        EditorPart.prototype.doRemoveGroupWithEditors = function (groupView) {
            var mostRecentlyActiveGroups = this.getGroups(1 /* MOST_RECENTLY_ACTIVE */);
            var lastActiveGroup;
            if (this._activeGroup === groupView) {
                lastActiveGroup = mostRecentlyActiveGroups[1];
            }
            else {
                lastActiveGroup = mostRecentlyActiveGroups[0];
            }
            // Removing a group with editors should merge these editors into the
            // last active group and then remove this group.
            this.mergeGroup(groupView, lastActiveGroup);
        };
        EditorPart.prototype.doRemoveEmptyGroup = function (groupView) {
            var gridHasFocus = dom_1.isAncestor(document.activeElement, this.container);
            // Activate next group if the removed one was active
            if (this._activeGroup === groupView) {
                var mostRecentlyActiveGroups = this.getGroups(1 /* MOST_RECENTLY_ACTIVE */);
                var nextActiveGroup = mostRecentlyActiveGroups[1]; // [0] will be the current group we are about to dispose
                this.activateGroup(nextActiveGroup);
            }
            // Remove from grid widget & dispose
            this.gridWidget.removeView(groupView, "distribute" /* Distribute */);
            groupView.dispose();
            // Restore focus if we had it previously (we run this after gridWidget.removeView() is called
            // because removing a view can mean to reparent it and thus focus would be removed otherwise)
            if (gridHasFocus) {
                this._activeGroup.focus();
            }
            // Update labels
            this.updateGroupLabels();
            // Update container
            this.updateContainer();
            // Mark preferred size as changed
            this.resetPreferredSize();
            // Event
            this._onDidRemoveGroup.fire(groupView);
        };
        EditorPart.prototype.moveGroup = function (group, location, direction) {
            var sourceView = this.assertGroupView(group);
            var targetView = this.assertGroupView(location);
            if (sourceView.id === targetView.id) {
                throw new Error('Cannot move group into its own');
            }
            var groupHasFocus = dom_1.isAncestor(document.activeElement, sourceView.element);
            // Move through grid widget API
            this.gridWidget.moveView(sourceView, "distribute" /* Distribute */, targetView, this.toGridViewDirection(direction));
            // Restore focus if we had it previously (we run this after gridWidget.removeView() is called
            // because removing a view can mean to reparent it and thus focus would be removed otherwise)
            if (groupHasFocus) {
                sourceView.focus();
            }
            // Event
            this._onDidMoveGroup.fire(sourceView);
            return sourceView;
        };
        EditorPart.prototype.copyGroup = function (group, location, direction) {
            var groupView = this.assertGroupView(group);
            var locationView = this.assertGroupView(location);
            var groupHasFocus = dom_1.isAncestor(document.activeElement, groupView.element);
            // Copy the group view
            var copiedGroupView = this.doAddGroup(locationView, direction, groupView);
            // Restore focus if we had it
            if (groupHasFocus) {
                copiedGroupView.focus();
            }
            return copiedGroupView;
        };
        EditorPart.prototype.mergeGroup = function (group, target, options) {
            var _this = this;
            var sourceView = this.assertGroupView(group);
            var targetView = this.assertGroupView(target);
            // Move/Copy editors over into target
            var index = (options && typeof options.index === 'number') ? options.index : targetView.count;
            sourceView.editors.forEach(function (editor) {
                var inactive = !sourceView.isActive(editor) || _this._activeGroup !== sourceView;
                var copyOptions = { index: index, inactive: inactive, preserveFocus: inactive };
                if (options && options.mode === 0 /* COPY_EDITORS */) {
                    sourceView.copyEditor(editor, targetView, copyOptions);
                }
                else {
                    sourceView.moveEditor(editor, targetView, copyOptions);
                }
                index++;
            });
            // Remove source if the view is now empty and not already removed
            if (sourceView.isEmpty() && !sourceView.disposed /* could have been disposed already via workbench.editor.closeEmptyGroups setting */) {
                this.removeGroup(sourceView);
            }
            return targetView;
        };
        EditorPart.prototype.assertGroupView = function (group) {
            if (typeof group === 'number') {
                group = this.getGroup(group);
            }
            if (!group) {
                throw new Error('Invalid editor group provided!');
            }
            return group;
        };
        Object.defineProperty(EditorPart.prototype, "minimumWidth", {
            //#endregion
            //#region Part
            get: function () { return this.centeredLayoutWidget.minimumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "maximumWidth", {
            get: function () { return this.centeredLayoutWidget.maximumWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "minimumHeight", {
            get: function () { return this.centeredLayoutWidget.minimumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "maximumHeight", {
            get: function () { return this.centeredLayoutWidget.maximumHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EditorPart.prototype, "preferredSize", {
            get: function () {
                if (!this._preferredSize) {
                    this._preferredSize = new dom_1.Dimension(this.gridWidget.minimumWidth, this.gridWidget.minimumHeight);
                }
                return this._preferredSize;
            },
            enumerable: true,
            configurable: true
        });
        EditorPart.prototype.resetPreferredSize = function () {
            // Reset (will be computed upon next access)
            this._preferredSize = void 0;
            // Event
            this._onDidPreferredSizeChange.fire();
        };
        Object.defineProperty(EditorPart.prototype, "gridSeparatorBorder", {
            get: function () {
                return this.theme.getColor(theme_1.EDITOR_GROUP_BORDER) || this.theme.getColor(colorRegistry_1.contrastBorder) || color_1.Color.transparent;
            },
            enumerable: true,
            configurable: true
        });
        EditorPart.prototype.updateStyles = function () {
            this.container.style.backgroundColor = this.getColor(colorRegistry_1.editorBackground);
            var separatorBorderStyle = { separatorBorder: this.gridSeparatorBorder, background: this.theme.getColor(theme_1.EDITOR_PANE_BACKGROUND) || color_1.Color.transparent };
            this.gridWidget.style(separatorBorderStyle);
            this.centeredLayoutWidget.styles(separatorBorderStyle);
        };
        EditorPart.prototype.createContentArea = function (parent) {
            // Container
            this.container = document.createElement('div');
            dom_1.addClass(this.container, 'content');
            parent.appendChild(this.container);
            // Grid control with center layout
            this.doCreateGridControl();
            this.centeredLayoutWidget = this._register(new centeredViewLayout_1.CenteredViewLayout(this.container, this.gridWidgetView, this.globalMemento[EditorPart.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY]));
            // Drop support
            this._register(this.instantiationService.createInstance(editorDropTarget_1.EditorDropTarget, this, this.container));
            return this.container;
        };
        EditorPart.prototype.centerLayout = function (active) {
            this.centeredLayoutWidget.activate(active);
        };
        EditorPart.prototype.isLayoutCentered = function () {
            return this.centeredLayoutWidget.isActive();
        };
        EditorPart.prototype.doCreateGridControl = function () {
            var _this = this;
            // Grid Widget (with previous UI state)
            if (this.restorePreviousState) {
                this.doCreateGridControlWithPreviousState();
            }
            // Grid Widget (no previous UI state or failed to restore)
            if (!this.gridWidget) {
                var initialGroup = this.doCreateGroupView();
                this.doSetGridWidget(new grid_1.SerializableGrid(initialGroup));
                // Ensure a group is active
                this.doSetGroupActive(initialGroup);
            }
            // Signal restored
            async_1.always(winjs_base_1.TPromise.join(this.groups.map(function (group) { return group.whenRestored; })), function () { return _this.whenRestoredComplete(void 0); });
            // Update container
            this.updateContainer();
        };
        EditorPart.prototype.doCreateGridControlWithPreviousState = function () {
            var uiState = this.memento[EditorPart.EDITOR_PART_UI_STATE_STORAGE_KEY];
            if (uiState && uiState.serializedGrid) {
                try {
                    // MRU
                    this.mostRecentActiveGroups = uiState.mostRecentActiveGroups;
                    // Grid Widget
                    this.doCreateGridControlWithState(uiState.serializedGrid, uiState.activeGroup);
                    // Ensure last active group has focus
                    this._activeGroup.focus();
                }
                catch (error) {
                    this.handleGridRestoreError(error, uiState);
                }
            }
        };
        EditorPart.prototype.handleGridRestoreError = function (error, state) {
            // Log error
            errors_1.onUnexpectedError(new Error("Error restoring editor grid widget: " + error + " (with state: " + JSON.stringify(state) + ")"));
            // Clear any state we have from the failing restore
            if (this.gridWidget) {
                this.doSetGridWidget();
            }
            this.groupViews.forEach(function (group) { return group.dispose(); });
            this.groupViews.clear();
            this._activeGroup = void 0;
            this.mostRecentActiveGroups = [];
        };
        EditorPart.prototype.doCreateGridControlWithState = function (serializedGrid, activeGroupId, editorGroupViewsToReuse) {
            var _this = this;
            // Determine group views to reuse if any
            var reuseGroupViews;
            if (editorGroupViewsToReuse) {
                reuseGroupViews = editorGroupViewsToReuse.slice(0); // do not modify original array
            }
            else {
                reuseGroupViews = [];
            }
            // Create new
            var groupViews = [];
            var gridWidget = grid_1.SerializableGrid.deserialize(serializedGrid, {
                fromJSON: function (serializedEditorGroup) {
                    var groupView;
                    if (reuseGroupViews.length > 0) {
                        groupView = reuseGroupViews.shift();
                    }
                    else {
                        groupView = _this.doCreateGroupView(serializedEditorGroup);
                    }
                    groupViews.push(groupView);
                    if (groupView.id === activeGroupId) {
                        _this.doSetGroupActive(groupView);
                    }
                    return groupView;
                }
            }, { styles: { separatorBorder: this.gridSeparatorBorder } });
            // If the active group was not found when restoring the grid
            // make sure to make at least one group active. We always need
            // an active group.
            if (!this._activeGroup) {
                this.doSetGroupActive(groupViews[0]);
            }
            // Validate MRU group views matches grid widget state
            if (this.mostRecentActiveGroups.some(function (groupId) { return !_this.getGroup(groupId); })) {
                this.mostRecentActiveGroups = groupViews.map(function (group) { return group.id; });
            }
            // Set it
            this.doSetGridWidget(gridWidget);
        };
        EditorPart.prototype.doSetGridWidget = function (gridWidget) {
            if (this.gridWidget) {
                this.gridWidget.dispose();
            }
            this.gridWidget = gridWidget;
            this.gridWidgetView.gridWidget = gridWidget;
            if (gridWidget) {
                this._onDidSizeConstraintsChange.input = gridWidget.onDidChange;
            }
            this.onDidSetGridWidget.fire();
        };
        EditorPart.prototype.updateContainer = function () {
            dom_1.toggleClass(this.container, 'empty', this.isEmpty());
        };
        EditorPart.prototype.updateGroupLabels = function () {
            var _this = this;
            // Since our labels are created using the index of the
            // group, adding/removing a group might produce gaps.
            // So we iterate over all groups and reassign the label
            // based on the index.
            this.getGroups(2 /* GRID_APPEARANCE */).forEach(function (group, index) {
                group.setLabel(_this.getGroupLabel(index + 1));
            });
        };
        EditorPart.prototype.getGroupLabel = function (index) {
            return nls_1.localize('groupLabel', "Group {0}", index);
        };
        EditorPart.prototype.isEmpty = function () {
            return this.groupViews.size === 1 && this._activeGroup.isEmpty();
        };
        EditorPart.prototype.layout = function (dimension) {
            var sizes = _super.prototype.layout.call(this, dimension);
            this.doLayout(sizes[1]);
            return sizes;
        };
        EditorPart.prototype.doLayout = function (dimension) {
            this.dimension = dimension;
            // Layout Grid
            this.centeredLayoutWidget.layout(this.dimension.width, this.dimension.height);
            // Event
            this._onDidLayout.fire(dimension);
        };
        EditorPart.prototype.shutdown = function () {
            // Persist grid UI state
            if (this.gridWidget) {
                var uiState = {
                    serializedGrid: this.gridWidget.serialize(),
                    activeGroup: this._activeGroup.id,
                    mostRecentActiveGroups: this.mostRecentActiveGroups
                };
                if (this.isEmpty()) {
                    delete this.memento[EditorPart.EDITOR_PART_UI_STATE_STORAGE_KEY];
                }
                else {
                    this.memento[EditorPart.EDITOR_PART_UI_STATE_STORAGE_KEY] = uiState;
                }
            }
            // Persist centered view state
            this.globalMemento[EditorPart.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY] = this.centeredLayoutWidget.state;
            // Forward to all groups
            this.groupViews.forEach(function (group) { return group.shutdown(); });
            _super.prototype.shutdown.call(this);
        };
        EditorPart.prototype.dispose = function () {
            // Forward to all groups
            this.groupViews.forEach(function (group) { return group.dispose(); });
            this.groupViews.clear();
            // Grid widget
            if (this.gridWidget) {
                this.gridWidget.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        EditorPart.EDITOR_PART_UI_STATE_STORAGE_KEY = 'editorpart.state';
        EditorPart.EDITOR_PART_CENTERED_VIEW_STORAGE_KEY = 'editorpart.centeredview';
        EditorPart = __decorate([
            __param(2, instantiation_1.IInstantiationService),
            __param(3, themeService_1.IThemeService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, storage_1.IStorageService)
        ], EditorPart);
        return EditorPart;
    }(part_1.Part));
    exports.EditorPart = EditorPart;
});























define(__m[351/*vs/workbench/services/progress/browser/progressService2*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,4/*vs/base/common/lifecycle*/,99/*vs/platform/progress/common/progress*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,209/*vs/platform/statusbar/common/statusbar*/,5/*vs/base/common/winjs.base*/,17/*vs/base/common/async*/,159/*vs/workbench/services/activity/common/activity*/,28/*vs/platform/notification/common/notification*/,15/*vs/base/common/actions*/,6/*vs/base/common/event*/,108/*vs/workbench/common/views*/,277/*vs/css!vs/workbench/services/progress/browser/media/progressService2*/]), function (require, exports, nls_1, lifecycle_1, progress_1, viewlet_1, statusbar_1, winjs_base_1, async_1, activity_1, notification_1, actions_1, event_1, views_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressService2 = /** @class */ (function () {
        function ProgressService2(_activityBar, _viewletService, _notificationService, _statusbarService) {
            this._activityBar = _activityBar;
            this._viewletService = _viewletService;
            this._notificationService = _notificationService;
            this._statusbarService = _statusbarService;
            this._stack = [];
            //
        }
        ProgressService2.prototype.withProgress = function (options, task, onDidCancel) {
            var location = options.location;
            if (location instanceof views_1.ViewContainer) {
                var viewlet = this._viewletService.getViewlet(location.id);
                if (viewlet) {
                    return this._withViewletProgress(location.id, task);
                }
                console.warn("Bad progress location: " + location.id);
                return undefined;
            }
            switch (location) {
                case 15 /* Notification */:
                    return this._withNotificationProgress(options, task, onDidCancel);
                case 10 /* Window */:
                    return this._withWindowProgress(options, task);
                case 1 /* Explorer */:
                    return this._withViewletProgress('workbench.view.explorer', task);
                case 3 /* Scm */:
                    return this._withViewletProgress('workbench.view.scm', task);
                case 5 /* Extensions */:
                    return this._withViewletProgress('workbench.view.extensions', task);
                default:
                    console.warn("Bad progress location: " + location);
                    return undefined;
            }
        };
        ProgressService2.prototype._withWindowProgress = function (options, callback) {
            var _this = this;
            var task = [options, new progress_1.Progress(function () { return _this._updateWindowProgress(); })];
            var promise = callback(task[1]);
            var delayHandle = setTimeout(function () {
                delayHandle = undefined;
                _this._stack.unshift(task);
                _this._updateWindowProgress();
                // show progress for at least 150ms
                async_1.always(Promise.all([
                    async_1.timeout(150),
                    promise
                ]), function () {
                    var idx = _this._stack.indexOf(task);
                    _this._stack.splice(idx, 1);
                    _this._updateWindowProgress();
                });
            }, 150);
            // cancel delay if promise finishes below 150ms
            async_1.always(promise, function () { return clearTimeout(delayHandle); });
            return promise;
        };
        ProgressService2.prototype._updateWindowProgress = function (idx) {
            if (idx === void 0) { idx = 0; }
            lifecycle_1.dispose(this._globalStatusEntry);
            if (idx < this._stack.length) {
                var _a = this._stack[idx], options = _a[0], progress = _a[1];
                var progressTitle = options.title;
                var progressMessage = progress.value && progress.value.message;
                var text = void 0;
                var title = void 0;
                if (progressTitle && progressMessage) {
                    // <title>: <message>
                    text = nls_1.localize('progress.text2', "{0}: {1}", progressTitle, progressMessage);
                    title = options.source ? nls_1.localize('progress.title3', "[{0}] {1}: {2}", options.source, progressTitle, progressMessage) : text;
                }
                else if (progressTitle) {
                    // <title>
                    text = progressTitle;
                    title = options.source ? nls_1.localize('progress.title2', "[{0}]: {1}", options.source, progressTitle) : text;
                }
                else if (progressMessage) {
                    // <message>
                    text = progressMessage;
                    title = options.source ? nls_1.localize('progress.title2', "[{0}]: {1}", options.source, progressMessage) : text;
                }
                else {
                    // no title, no message -> no progress. try with next on stack
                    this._updateWindowProgress(idx + 1);
                    return;
                }
                this._globalStatusEntry = this._statusbarService.addEntry({
                    text: "$(sync~spin) " + text,
                    tooltip: title
                }, 0 /* LEFT */);
            }
        };
        ProgressService2.prototype._withNotificationProgress = function (options, callback, onDidCancel) {
            var _this = this;
            var toDispose = [];
            var createNotification = function (message, increment) {
                if (!message) {
                    return undefined; // we need a message at least
                }
                var actions = { primary: [] };
                if (options.cancellable) {
                    var cancelAction = new /** @class */ (function (_super) {
                        __extends(class_1, _super);
                        function class_1() {
                            return _super.call(this, 'progress.cancel', nls_1.localize('cancel', "Cancel"), null, true) || this;
                        }
                        class_1.prototype.run = function () {
                            if (typeof onDidCancel === 'function') {
                                onDidCancel();
                            }
                            return winjs_base_1.TPromise.as(undefined);
                        };
                        return class_1;
                    }(actions_1.Action));
                    toDispose.push(cancelAction);
                    actions.primary.push(cancelAction);
                }
                var handle = _this._notificationService.notify({
                    severity: notification_1.Severity.Info,
                    message: message,
                    source: options.source,
                    actions: actions
                });
                updateProgress(handle, increment);
                event_1.once(handle.onDidClose)(function () {
                    lifecycle_1.dispose(toDispose);
                });
                return handle;
            };
            var updateProgress = function (notification, increment) {
                if (typeof increment === 'number' && increment >= 0) {
                    notification.progress.total(100); // always percentage based
                    notification.progress.worked(increment);
                }
                else {
                    notification.progress.infinite();
                }
            };
            var handle;
            var updateNotification = function (message, increment) {
                if (!handle) {
                    handle = createNotification(message, increment);
                }
                else {
                    if (typeof message === 'string') {
                        var newMessage = void 0;
                        if (typeof options.title === 'string') {
                            newMessage = options.title + ": " + message; // always prefix with overall title if we have it (https://github.com/Microsoft/vscode/issues/50932)
                        }
                        else {
                            newMessage = message;
                        }
                        handle.updateMessage(newMessage);
                    }
                    if (typeof increment === 'number') {
                        updateProgress(handle, increment);
                    }
                }
            };
            // Show initially
            updateNotification(options.title);
            // Update based on progress
            var p = callback({
                report: function (progress) {
                    updateNotification(progress.message, progress.increment);
                }
            });
            // Show progress for at least 800ms and then hide once done or canceled
            async_1.always(Promise.all([async_1.timeout(800), p]), function () {
                if (handle) {
                    handle.close();
                }
            });
            return p;
        };
        ProgressService2.prototype._withViewletProgress = function (viewletId, task) {
            var _this = this;
            var promise = task(progress_1.emptyProgress);
            // show in viewlet
            var viewletProgress = this._viewletService.getProgressIndicator(viewletId);
            if (viewletProgress) {
                viewletProgress.showWhile(winjs_base_1.TPromise.wrap(promise));
            }
            // show activity bar
            var activityProgress;
            var delayHandle = setTimeout(function () {
                delayHandle = undefined;
                var handle = _this._activityBar.showActivity(viewletId, new activity_1.ProgressBadge(function () { return ''; }), 'progress-badge', 100);
                var startTimeVisible = Date.now();
                var minTimeVisible = 300;
                activityProgress = {
                    dispose: function () {
                        var d = Date.now() - startTimeVisible;
                        if (d < minTimeVisible) {
                            // should at least show for Nms
                            setTimeout(function () { return handle.dispose(); }, minTimeVisible - d);
                        }
                        else {
                            // shown long enough
                            handle.dispose();
                        }
                    }
                };
            }, 300);
            var onDone = function () {
                clearTimeout(delayHandle);
                lifecycle_1.dispose(activityProgress);
            };
            promise.then(onDone, onDone);
            return promise;
        };
        ProgressService2 = __decorate([
            __param(0, activity_1.IActivityService),
            __param(1, viewlet_1.IViewletService),
            __param(2, notification_1.INotificationService),
            __param(3, statusbar_1.IStatusbarService)
        ], ProgressService2);
        return ProgressService2;
    }());
    exports.ProgressService2 = ProgressService2;
});























define(__m[330/*vs/workbench/services/viewlet/browser/viewletService*/], __M([0/*require*/,1/*exports*/,6/*vs/base/common/event*/,9/*vs/platform/registry/common/platform*/,76/*vs/workbench/browser/viewlet*/,10/*vs/platform/contextkey/common/contextkey*/,70/*vs/workbench/services/extensions/common/extensions*/,4/*vs/base/common/lifecycle*/]), function (require, exports, event_1, platform_1, viewlet_1, contextkey_1, extensions_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ActiveViewletContextId = 'activeViewlet';
    exports.ActiveViewletContext = new contextkey_1.RawContextKey(ActiveViewletContextId, '');
    var ViewletService = /** @class */ (function (_super) {
        __extends(ViewletService, _super);
        function ViewletService(sidebarPart, contextKeyService, extensionService) {
            var _this = _super.call(this) || this;
            _this.extensionService = extensionService;
            _this._onDidViewletEnable = new event_1.Emitter();
            _this.sidebarPart = sidebarPart;
            _this.viewletRegistry = platform_1.Registry.as(viewlet_1.Extensions.Viewlets);
            _this.activeViewletContextKey = exports.ActiveViewletContext.bindTo(contextKeyService);
            _this._register(_this.onDidViewletOpen(_this._onDidViewletOpen, _this));
            _this._register(_this.onDidViewletClose(_this._onDidViewletClose, _this));
            return _this;
        }
        Object.defineProperty(ViewletService.prototype, "onDidViewletRegister", {
            get: function () { return this.viewletRegistry.onDidRegister; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewletService.prototype, "onDidViewletOpen", {
            get: function () { return this.sidebarPart.onDidViewletOpen; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewletService.prototype, "onDidViewletClose", {
            get: function () { return this.sidebarPart.onDidViewletClose; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewletService.prototype, "onDidViewletEnablementChange", {
            get: function () { return this._onDidViewletEnable.event; },
            enumerable: true,
            configurable: true
        });
        ViewletService.prototype._onDidViewletOpen = function (viewlet) {
            this.activeViewletContextKey.set(viewlet.getId());
        };
        ViewletService.prototype._onDidViewletClose = function (viewlet) {
            var id = viewlet.getId();
            if (this.activeViewletContextKey.get() === id) {
                this.activeViewletContextKey.reset();
            }
        };
        ViewletService.prototype.setViewletEnablement = function (id, enabled) {
            var descriptor = this.getAllViewlets().filter(function (desc) { return desc.id === id; }).pop();
            if (descriptor && descriptor.enabled !== enabled) {
                descriptor.enabled = enabled;
                this._onDidViewletEnable.fire({ id: id, enabled: enabled });
            }
        };
        ViewletService.prototype.openViewlet = function (id, focus) {
            var _this = this;
            if (this.getViewlet(id)) {
                return this.sidebarPart.openViewlet(id, focus);
            }
            return this.extensionService.whenInstalledExtensionsRegistered()
                .then(function () {
                if (_this.getViewlet(id)) {
                    return _this.sidebarPart.openViewlet(id, focus);
                }
                return null;
            });
        };
        ViewletService.prototype.getActiveViewlet = function () {
            return this.sidebarPart.getActiveViewlet();
        };
        ViewletService.prototype.getViewlets = function () {
            return this.getAllViewlets()
                .filter(function (v) { return v.enabled; });
        };
        ViewletService.prototype.getAllViewlets = function () {
            return this.viewletRegistry.getViewlets()
                .sort(function (v1, v2) { return v1.order - v2.order; });
        };
        ViewletService.prototype.getDefaultViewletId = function () {
            return this.viewletRegistry.getDefaultViewletId();
        };
        ViewletService.prototype.getViewlet = function (id) {
            return this.getViewlets().filter(function (viewlet) { return viewlet.id === id; })[0];
        };
        ViewletService.prototype.getProgressIndicator = function (id) {
            return this.sidebarPart.getProgressIndicator(id);
        };
        ViewletService = __decorate([
            __param(1, contextkey_1.IContextKeyService),
            __param(2, extensions_1.IExtensionService)
        ], ViewletService);
        return ViewletService;
    }(lifecycle_1.Disposable));
    exports.ViewletService = ViewletService;
});

define(__m[325/*vs/codesandbox/codesandbox.services*/], __M([0/*require*/,1/*exports*/,44/*vs/platform/storage/common/storage*/,96/*vs/editor/browser/services/codeEditorService*/,92/*vs/platform/dialogs/common/dialogs*/,59/*vs/platform/label/common/label*/,33/*vs/workbench/services/group/common/editorGroupsService*/,49/*vs/workbench/services/part/common/partService*/,124/*vs/workbench/services/history/common/history*/,16/*vs/platform/files/common/files*/,11/*vs/workbench/services/editor/common/editorService*/,42/*vs/platform/windows/common/windows*/,27/*vs/workbench/services/textfile/common/textfiles*/,70/*vs/workbench/services/extensions/common/extensions*/,122/*vs/platform/extensionManagement/common/extensionManagement*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,94/*vs/workbench/services/hash/common/hashService*/,113/*vs/workbench/services/backup/common/backup*/,155/*vs/workbench/services/decorations/browser/decorations*/,61/*vs/workbench/services/preferences/common/preferences*/,154/*vs/workbench/services/configuration/common/jsonEditing*/,66/*vs/editor/common/services/resolverService*/,160/*vs/platform/workspaces/common/workspaces*/,71/*vs/platform/search/common/search*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,349/*vs/platform/broadcast/electron-browser/broadcastService*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,207/*vs/workbench/services/progress/common/progress*/,159/*vs/workbench/services/activity/common/activity*/,173/*vs/workbench/parts/output/common/output*/,81/*vs/workbench/services/panel/common/panelService*/,62/*vs/platform/quickinput/common/quickInput*/,305/*vs/workbench/api/electron-browser/mainThreadHeapService*/,369/*vs/codesandbox/windowsService*/,235/*vs/workbench/services/editor/browser/editorService*/,306/*vs/codesandbox/services/codesandbox/common/codesandboxEditorConnector*/,451/*vs/platform/request/node/request*/,354/*vs/codesandbox/requestService*/,109/*vs/workbench/parts/preferences/common/preferences*/,230/*vs/workbench/parts/preferences/electron-browser/preferencesSearch*/,79/*vs/platform/clipboard/common/clipboardService*/,299/*vs/codesandbox/clipboardService*/,218/*vs/workbench/services/keybinding/common/keybindingEditing*/,63/*vs/platform/lifecycle/common/lifecycle*/,421/*vs/codesandbox/lifecycleService*/,9/*vs/platform/registry/common/platform*/,107/*vs/workbench/common/contributions*/,209/*vs/platform/statusbar/common/statusbar*/,362/*vs/codesandbox/statusbarService*/,80/*vs/platform/instantiation/common/extensions*/,363/*vs/workbench/services/search/node/searchHistoryService*/,346/*vs/workbench/services/history/electron-browser/history*/,112/*vs/workbench/browser/actions*/,393/*vs/codesandbox/services/codesandbox/saveParticipant*/,358/*vs/codesandbox/activityService*/,340/*vs/codesandbox/outputService*/,341/*vs/codesandbox/panelService*/,292/*vs/codesandbox/broadcastService*/,392/*vs/codesandbox/workspacesService*/,388/*vs/workbench/services/configuration/node/jsonEditingService*/,279/*vs/workbench/services/decorations/browser/decorationsService*/,120/*vs/platform/instantiation/common/descriptors*/,308/*vs/codesandbox/fileService*/,311/*vs/codesandbox/extensionGalleryService*/,371/*vs/codesandbox/fileDialogService*/,316/*vs/codesandbox/extensionManagementService*/,264/*vs/platform/extensionManagement/common/extensionEnablementService*/,255/*vs/platform/windows/electron-browser/windowService*/,288/*vs/codesandbox/backupFileService*/,317/*vs/codesandbox/extensionService*/,331/*vs/codesandbox/hashService*/,353/*vs/workbench/browser/parts/editor/editorPart*/,238/*vs/platform/storage/common/storageService*/,330/*vs/workbench/services/viewlet/browser/viewletService*/,309/*vs/codesandbox/workbench*/,428/*vs/workbench/services/textfile/electron-browser/textFileService*/,430/*vs/workbench/services/textmodelResolver/common/textModelResolverService*/,405/*vs/codesandbox/searchService*/,298/*vs/workbench/services/codeEditor/browser/codeEditorService*/,282/*vs/codesandbox/services/codesandbox/browser/codesandboxEditorConnectorService*/,361/*vs/workbench/services/preferences/browser/preferencesService*/,351/*vs/workbench/services/progress/browser/progressService2*/,197/*vs/workbench/browser/parts/quickinput/quickInput*/,233/*vs/workbench/browser/parts/quickopen/quickOpenController*/,46/*vs/platform/quickOpen/common/quickOpen*/,300/*vs/codesandbox/environmentService*/,43/*vs/platform/environment/common/environment*/,321/*vs/codesandbox/keybindingService*/,31/*vs/platform/keybinding/common/keybinding*/,97/*vs/codesandbox/services/codesandbox/common/codesandbox*/,226/*vs/codesandbox/services/codesandbox/browser/codesandboxService*/]), function (require, exports, storage_1, codeEditorService_1, dialogs_1, label_1, editorGroupsService_1, partService_1, history_1, files_1, editorService_1, windows_1, textfiles_1, extensions_1, extensionManagement_1, untitledEditorService_1, hashService_1, backup_1, decorations_1, preferences_1, jsonEditing_1, resolverService_1, workspaces_1, search_1, viewlet_1, broadcastService_1, breadcrumbs_1, progress_1, activity_1, output_1, panelService_1, quickInput_1, mainThreadHeapService_1, windowsService_1, editorService_2, codesandboxEditorConnector_1, request_1, requestService_1, preferences_2, preferencesSearch_1, clipboardService_1, clipboardService_2, keybindingEditing_1, lifecycle_1, lifecycleService_1, platform_1, contributions_1, statusbar_1, statusbarService_1, extensions_2, searchHistoryService_1, history_2, actions_1, saveParticipant_1, activityService_1, outputService_1, panelService_2, broadcastService_2, workspacesService_1, jsonEditingService_1, decorationsService_1, descriptors_1, fileService_1, extensionGalleryService_1, fileDialogService_1, extensionManagementService_1, extensionEnablementService_1, windowService_1, backupFileService_1, extensionService_1, hashService_2, editorPart_1, storageService_1, viewletService_1, workbench_1, textFileService_1, textModelResolverService_1, searchService_1, codeEditorService_2, codesandboxEditorConnectorService_1, preferencesService_1, progressService2_1, quickInput_2, quickOpenController_1, quickOpen_1, environmentService_1, environment_1, keybindingService_1, keybinding_1, codesandbox_1, codesandboxService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function loadCodesandboxServices(serviceCollection, instantiationService, overrides) {
        // The or case in this serviceCollection should never happen, we still put it in here to trick
        // the treeshaker to include it.
        serviceCollection.set(codesandbox_1.ICodeSandboxService, overrides.codesandboxService(instantiationService) ||
            instantiationService.createInstance(codesandboxService_1.CodeSandboxService));
        serviceCollection.set(environment_1.IEnvironmentService, instantiationService.createInstance(environmentService_1.CodeSandboxEnvironmentService));
        var existingKeybindingService = serviceCollection.get(keybinding_1.IKeybindingService);
        if (existingKeybindingService) {
            existingKeybindingService.dispose();
        }
        var keybindingService = instantiationService.createInstance(keybindingService_1.CodeSandboxKeybindingService, window);
        serviceCollection.set(keybinding_1.IKeybindingService, keybindingService);
        serviceCollection.set(statusbar_1.IStatusbarService, new descriptors_1.SyncDescriptor(statusbarService_1.CodeSandboxStatusbarService));
        serviceCollection.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.CodeSandboxRequestService));
        serviceCollection.set(clipboardService_1.IClipboardService, new descriptors_1.SyncDescriptor(clipboardService_2.CodeSandboxClipboardService));
        serviceCollection.set(label_1.ILabelService, new descriptors_1.SyncDescriptor(label_1.LabelService));
        serviceCollection.set(activity_1.IActivityService, new descriptors_1.SyncDescriptor(activityService_1.CodeSandboxActivityService));
        serviceCollection.set(output_1.IOutputService, new descriptors_1.SyncDescriptor(outputService_1.CodeSandboxOutputService));
        serviceCollection.set(panelService_1.IPanelService, new descriptors_1.SyncDescriptor(panelService_2.CodeSandboxPanelService));
        serviceCollection.set(breadcrumbs_1.IBreadcrumbsService, new descriptors_1.SyncDescriptor(breadcrumbs_1.BreadcrumbsService));
        serviceCollection.set(broadcastService_1.IBroadcastService, new descriptors_1.SyncDescriptor(broadcastService_2.CodeSandboxBroadcastService, 1));
        serviceCollection.set(workspaces_1.IWorkspacesService, new descriptors_1.SyncDescriptor(workspacesService_1.CodeSandboxWorkspacesService));
        serviceCollection.set(jsonEditing_1.IJSONEditingService, new descriptors_1.SyncDescriptor(jsonEditingService_1.JSONEditingService));
        serviceCollection.set(decorations_1.IDecorationsService, new descriptors_1.SyncDescriptor(decorationsService_1.FileDecorationsService));
        serviceCollection.set(backup_1.IBackupFileService, new descriptors_1.SyncDescriptor(backupFileService_1.CodeSandboxBackupService));
        var lifecycleService = instantiationService.createInstance(lifecycleService_1.CodeSandboxLifecycleService);
        serviceCollection.set(lifecycle_1.ILifecycleService, lifecycleService);
        serviceCollection.set(files_1.IFileService, new descriptors_1.SyncDescriptor(fileService_1.CodeSandboxFileService));
        serviceCollection.set(windows_1.IWindowsService, new descriptors_1.SyncDescriptor(windowsService_1.CodeSandboxWindowsService));
        serviceCollection.set(windows_1.IWindowService, new descriptors_1.SyncDescriptor(windowService_1.WindowService, 1, {}));
        serviceCollection.set(extensionManagement_1.IExtensionGalleryService, new descriptors_1.SyncDescriptor(extensionGalleryService_1.CodeSandboxExtensionGalleryService));
        serviceCollection.set(dialogs_1.IFileDialogService, new descriptors_1.SyncDescriptor(fileDialogService_1.CodeSandboxFileDialogService));
        serviceCollection.set(extensionManagement_1.IExtensionManagementService, new descriptors_1.SyncDescriptor(extensionManagementService_1.CodeSandboxExtensionManagementService));
        serviceCollection.set(extensionManagement_1.IExtensionEnablementService, new descriptors_1.SyncDescriptor(extensionEnablementService_1.ExtensionEnablementService));
        serviceCollection.set(extensions_1.IExtensionService, new descriptors_1.SyncDescriptor(extensionService_1.CodeSandboxExtensionService));
        serviceCollection.set(hashService_1.IHashService, new descriptors_1.SyncDescriptor(hashService_2.CodeSandboxHashService));
        serviceCollection.set(editorGroupsService_1.IEditorGroupsService, new descriptors_1.SyncDescriptor(editorPart_1.EditorPart, 'codesandbox-editor', false));
        serviceCollection.set(storage_1.IStorageService, new storageService_1.StorageService(localStorage, localStorage));
        serviceCollection.set(viewlet_1.IViewletService, new descriptors_1.SyncDescriptor(viewletService_1.ViewletService, {
            onDidViewletOpen: function () { return true; },
            onDidViewletClose: function () { return true; },
        }));
        serviceCollection.set(partService_1.IPartService, new descriptors_1.SyncDescriptor(workbench_1.CodeSandboxWorkbench));
        serviceCollection.set(untitledEditorService_1.IUntitledEditorService, new descriptors_1.SyncDescriptor(untitledEditorService_1.UntitledEditorService));
        serviceCollection.set(editorService_1.IEditorService, new descriptors_1.SyncDescriptor(editorService_2.EditorService));
        serviceCollection.set(search_1.ISearchService, new descriptors_1.SyncDescriptor(searchService_1.CodeSandboxSearchService));
        serviceCollection.set(history_1.IHistoryService, new descriptors_1.SyncDescriptor(history_2.HistoryService));
        serviceCollection.set(textfiles_1.ITextFileService, new descriptors_1.SyncDescriptor(textFileService_1.TextFileService));
        serviceCollection.set(resolverService_1.ITextModelService, new descriptors_1.SyncDescriptor(textModelResolverService_1.TextModelResolverService));
        serviceCollection.set(codeEditorService_1.ICodeEditorService, instantiationService.createInstance(codeEditorService_2.CodeEditorService));
        serviceCollection.set(codesandboxEditorConnector_1.ICodeSandboxEditorConnectorService, instantiationService.createInstance(codesandboxEditorConnectorService_1.CodeSandboxEditorConnectorService));
        serviceCollection.set(preferences_2.IPreferencesSearchService, new descriptors_1.SyncDescriptor(preferencesSearch_1.PreferencesSearchService));
        serviceCollection.set(preferences_1.IPreferencesService, new descriptors_1.SyncDescriptor(preferencesService_1.PreferencesService));
        serviceCollection.set(keybindingEditing_1.IKeybindingEditingService, new descriptors_1.SyncDescriptor(keybindingEditing_1.KeybindingsEditingService));
        serviceCollection.set(progress_1.IProgressService2, new descriptors_1.SyncDescriptor(progressService2_1.ProgressService2));
        serviceCollection.set(quickOpen_1.IQuickOpenService, instantiationService.createInstance(quickOpenController_1.QuickOpenController));
        serviceCollection.set(quickInput_1.IQuickInputService, new descriptors_1.SyncDescriptor(quickInput_2.QuickInputService));
        serviceCollection.set(mainThreadHeapService_1.IHeapService, new descriptors_1.SyncDescriptor(mainThreadHeapService_1.HeapService));
        serviceCollection.set(search_1.ISearchHistoryService, new descriptors_1.SyncDescriptor(searchHistoryService_1.SearchHistoryService));
        platform_1.Registry.as(contributions_1.Extensions.Workbench).start(instantiationService, lifecycleService);
        platform_1.Registry.as(actions_1.Extensions.Actionbar).setInstantiationService(instantiationService);
        instantiationService.createInstance(saveParticipant_1.SaveParticipant);
        // Contributed services
        var contributedServices = extensions_2.getServices();
        for (var _i = 0, contributedServices_1 = contributedServices; _i < contributedServices_1.length; _i++) {
            var contributedService = contributedServices_1[_i];
            serviceCollection.set(contributedService.id, contributedService.descriptor);
        }
    }
    exports.loadCodesandboxServices = loadCodesandboxServices;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[322/*vs/editor/standalone/browser/codesandbox.standaloneEditor*/], __M([0/*require*/,1/*exports*/,453/*vs/editor/common/editorCommon*/,45/*vs/editor/browser/editorBrowser*/,454/*vs/editor/standalone/browser/standaloneCodeEditor*/,134/*vs/base/common/scrollable*/,455/*vs/editor/standalone/browser/standaloneServices*/,456/*vs/editor/browser/services/openerService*/,138/*vs/platform/opener/common/opener*/,457/*vs/editor/standalone/browser/colorizer*/,458/*vs/editor/standalone/browser/simpleServices*/,85/*vs/editor/common/modes*/,459/*vs/editor/common/services/webWorker*/,367/*vs/editor/browser/widget/diffNavigator*/,37/*vs/platform/commands/common/commands*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,31/*vs/platform/keybinding/common/keybinding*/,10/*vs/platform/contextkey/common/contextkey*/,96/*vs/editor/browser/services/codeEditorService*/,397/*vs/editor/common/services/editorWorkerService*/,66/*vs/editor/common/services/resolverService*/,460/*vs/editor/common/modes/nullMode*/,461/*vs/editor/standalone/common/standaloneThemeService*/,431/*vs/editor/common/config/fontInfo*/,201/*vs/editor/common/config/editorOptions*/,284/*vs/editor/common/controller/cursorEvents*/,72/*vs/editor/common/model*/,28/*vs/platform/notification/common/notification*/,7/*vs/platform/configuration/common/configuration*/,325/*vs/codesandbox/codesandbox.services*/,463/*vs/css!vs/editor/standalone/browser/standalone-tokens*/]), function (require, exports, editorCommon, editorBrowser_1, standaloneCodeEditor_1, scrollable_1, standaloneServices_1, openerService_1, opener_1, colorizer_1, simpleServices_1, modes, webWorker_1, diffNavigator_1, commands_1, contextView_1, instantiation_1, keybinding_1, contextkey_1, codeEditorService_1, editorWorkerService_1, resolverService_1, nullMode_1, standaloneThemeService_1, fontInfo_1, editorOptions, cursorEvents_1, model_1, notification_1, configuration_1, codesandbox_services_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var services = null;
    function withAllStandaloneServices(domElement, override, callback) {
        services = new standaloneServices_1.DynamicStandaloneServices(domElement, override);
        if (override) {
            codesandbox_services_1.loadCodesandboxServices(services, services.get(instantiation_1.IInstantiationService), override);
        }
        var simpleEditorModelResolverService = null;
        if (!services.has(resolverService_1.ITextModelService)) {
            simpleEditorModelResolverService = new simpleServices_1.SimpleEditorModelResolverService();
            services.set(resolverService_1.ITextModelService, simpleEditorModelResolverService);
        }
        if (!services.has(opener_1.IOpenerService)) {
            services.set(opener_1.IOpenerService, new openerService_1.OpenerService(services.get(codeEditorService_1.ICodeEditorService), services.get(commands_1.ICommandService)));
        }
        var result = callback(services);
        if (simpleEditorModelResolverService) {
            simpleEditorModelResolverService.setEditor(result);
        }
        return result;
    }
    /**
     * Create a new editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function create(domElement, options, override, callback) {
        var usedCallback = callback || (function (services) {
            return new standaloneCodeEditor_1.StandaloneEditor(domElement, options, services, services.get(instantiation_1.IInstantiationService), services.get(codeEditorService_1.ICodeEditorService), services.get(commands_1.ICommandService), services.get(contextkey_1.IContextKeyService), services.get(keybinding_1.IKeybindingService), services.get(contextView_1.IContextViewService), services.get(standaloneThemeService_1.IStandaloneThemeService), services.get(notification_1.INotificationService), services.get(configuration_1.IConfigurationService));
        });
        return withAllStandaloneServices(domElement, override, usedCallback);
    }
    exports.create = create;
    /**
     * Emitted when an editor is created.
     * Creating a diff editor might cause this listener to be invoked with the two editors.
     * @event
     */
    function onDidCreateEditor(listener) {
        return standaloneServices_1.StaticServices.codeEditorService.get().onCodeEditorAdd(function (editor) {
            listener(editor);
        });
    }
    exports.onDidCreateEditor = onDidCreateEditor;
    /**
     * Create a new diff editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function createDiffEditor(domElement, options, override) {
        return withAllStandaloneServices(domElement, override, function (services) {
            return new standaloneCodeEditor_1.StandaloneDiffEditor(domElement, options, services, services.get(instantiation_1.IInstantiationService), services.get(contextkey_1.IContextKeyService), services.get(keybinding_1.IKeybindingService), services.get(contextView_1.IContextViewService), services.get(editorWorkerService_1.IEditorWorkerService), services.get(codeEditorService_1.ICodeEditorService), services.get(standaloneThemeService_1.IStandaloneThemeService), services.get(notification_1.INotificationService), services.get(configuration_1.IConfigurationService));
        });
    }
    exports.createDiffEditor = createDiffEditor;
    function createDiffNavigator(diffEditor, opts) {
        return new diffNavigator_1.DiffNavigator(diffEditor, opts);
    }
    exports.createDiffNavigator = createDiffNavigator;
    function doCreateModel(value, mode, uri) {
        return standaloneServices_1.StaticServices.modelService.get().createModel(value, mode, uri);
    }
    /**
     * Create a new editor model.
     * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
     */
    function createModel(value, language, uri) {
        value = value || '';
        if (!language) {
            var path = uri ? uri.path : null;
            var firstLF = value.indexOf('\n');
            var firstLine = value;
            if (firstLF !== -1) {
                firstLine = value.substring(0, firstLF);
            }
            return doCreateModel(value, standaloneServices_1.StaticServices.modeService.get().getOrCreateModeByFilepathOrFirstLine(path, firstLine), uri);
        }
        return doCreateModel(value, standaloneServices_1.StaticServices.modeService.get().getOrCreateMode(language), uri);
    }
    exports.createModel = createModel;
    /**
     * Change the language for a model.
     */
    function setModelLanguage(model, languageId) {
        standaloneServices_1.StaticServices.modelService.get().setMode(model, standaloneServices_1.StaticServices.modeService.get().getOrCreateMode(languageId));
    }
    exports.setModelLanguage = setModelLanguage;
    /**
     * Set the markers for a model.
     */
    function setModelMarkers(model, owner, markers) {
        if (model) {
            standaloneServices_1.StaticServices.markerService.get().changeOne(owner, model.uri, markers);
        }
    }
    exports.setModelMarkers = setModelMarkers;
    /**
     * Get markers for owner and/or resource
     * @returns {IMarker[]} list of markers
     * @param filter
     */
    function getModelMarkers(filter) {
        return standaloneServices_1.StaticServices.markerService.get().read(filter);
    }
    exports.getModelMarkers = getModelMarkers;
    function resolveModel(uri) {
        return services.get(resolverService_1.ITextModelService).createModelReference(uri);
    }
    exports.resolveModel = resolveModel;
    /**
     * Get the model that has `uri` if it exists.
     */
    function getModel(uri) {
        return standaloneServices_1.StaticServices.modelService.get().getModel(uri);
    }
    exports.getModel = getModel;
    /**
     * Get all the created models.
     */
    function getModels() {
        return standaloneServices_1.StaticServices.modelService.get().getModels();
    }
    exports.getModels = getModels;
    /**
     * Emitted when a model is created.
     * @event
     */
    function onDidCreateModel(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelAdded(listener);
    }
    exports.onDidCreateModel = onDidCreateModel;
    /**
     * Emitted right before a model is disposed.
     * @event
     */
    function onWillDisposeModel(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelRemoved(listener);
    }
    exports.onWillDisposeModel = onWillDisposeModel;
    /**
     * Emitted when a different language is set to a model.
     * @event
     */
    function onDidChangeModelLanguage(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelModeChanged(function (e) {
            listener({
                model: e.model,
                oldLanguage: e.oldModeId
            });
        });
    }
    exports.onDidChangeModelLanguage = onDidChangeModelLanguage;
    /**
     * Create a new web worker that has model syncing capabilities built in.
     * Specify an AMD module to load that will `create` an object that will be proxied.
     */
    function createWebWorker(opts) {
        return webWorker_1.createWebWorker(standaloneServices_1.StaticServices.modelService.get(), opts);
    }
    exports.createWebWorker = createWebWorker;
    /**
     * Colorize the contents of `domNode` using attribute `data-lang`.
     */
    function colorizeElement(domNode, options) {
        return colorizer_1.Colorizer.colorizeElement(standaloneServices_1.StaticServices.standaloneThemeService.get(), standaloneServices_1.StaticServices.modeService.get(), domNode, options);
    }
    exports.colorizeElement = colorizeElement;
    /**
     * Colorize `text` using language `languageId`.
     */
    function colorize(text, languageId, options) {
        return colorizer_1.Colorizer.colorize(standaloneServices_1.StaticServices.modeService.get(), text, languageId, options);
    }
    exports.colorize = colorize;
    /**
     * Colorize a line in a model.
     */
    function colorizeModelLine(model, lineNumber, tabSize) {
        if (tabSize === void 0) { tabSize = 4; }
        return colorizer_1.Colorizer.colorizeModelLine(model, lineNumber, tabSize);
    }
    exports.colorizeModelLine = colorizeModelLine;
    /**
     * @internal
     */
    function getSafeTokenizationSupport(language) {
        var tokenizationSupport = modes.TokenizationRegistry.get(language);
        if (tokenizationSupport) {
            return tokenizationSupport;
        }
        return {
            getInitialState: function () { return nullMode_1.NULL_STATE; },
            tokenize: function (line, state, deltaOffset) { return nullMode_1.nullTokenize(language, line, state, deltaOffset); },
            tokenize2: undefined,
        };
    }
    /**
     * Tokenize `text` using language `languageId`
     */
    function tokenize(text, languageId) {
        var modeService = standaloneServices_1.StaticServices.modeService.get();
        // Needed in order to get the mode registered for subsequent look-ups
        modeService.getOrCreateMode(languageId);
        var tokenizationSupport = getSafeTokenizationSupport(languageId);
        var lines = text.split(/\r\n|\r|\n/);
        var result = [];
        var state = tokenizationSupport.getInitialState();
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            var tokenizationResult = tokenizationSupport.tokenize(line, state, 0);
            result[i] = tokenizationResult.tokens;
            state = tokenizationResult.endState;
        }
        return result;
    }
    exports.tokenize = tokenize;
    /**
     * Define a new theme or updte an existing theme.
     */
    function defineTheme(themeName, themeData) {
        standaloneServices_1.StaticServices.standaloneThemeService.get().defineTheme(themeName, themeData);
    }
    exports.defineTheme = defineTheme;
    /**
     * Switches to a theme.
     */
    function setTheme(themeName) {
        standaloneServices_1.StaticServices.standaloneThemeService.get().setTheme(themeName);
    }
    exports.setTheme = setTheme;
    /**
     * @internal
     * --------------------------------------------
     * This is repeated here so it can be exported
     * because TS inlines const enums
     * --------------------------------------------
     */
    var ScrollType;
    (function (ScrollType) {
        ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
        ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
    })(ScrollType || (ScrollType = {}));
    /**
     * @internal
     * --------------------------------------------
     * This is repeated here so it can be exported
     * because TS inlines const enums
     * --------------------------------------------
     */
    var RenderLineNumbersType;
    (function (RenderLineNumbersType) {
        RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
        RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
        RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
        RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
        RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
    })(RenderLineNumbersType || (RenderLineNumbersType = {}));
    /**
     * @internal
     */
    function createMonacoEditorAPI() {
        return {
            // methods
            create: create,
            onDidCreateEditor: onDidCreateEditor,
            createDiffEditor: createDiffEditor,
            createDiffNavigator: createDiffNavigator,
            createModel: createModel,
            setModelLanguage: setModelLanguage,
            setModelMarkers: setModelMarkers,
            getModelMarkers: getModelMarkers,
            getModels: getModels,
            getModel: getModel,
            resolveModel: resolveModel,
            onDidCreateModel: onDidCreateModel,
            onWillDisposeModel: onWillDisposeModel,
            onDidChangeModelLanguage: onDidChangeModelLanguage,
            createWebWorker: createWebWorker,
            colorizeElement: colorizeElement,
            colorize: colorize,
            colorizeModelLine: colorizeModelLine,
            tokenize: tokenize,
            defineTheme: defineTheme,
            setTheme: setTheme,
            // enums
            ScrollbarVisibility: scrollable_1.ScrollbarVisibility,
            WrappingIndent: editorOptions.WrappingIndent,
            OverviewRulerLane: model_1.OverviewRulerLane,
            EndOfLinePreference: model_1.EndOfLinePreference,
            DefaultEndOfLine: model_1.DefaultEndOfLine,
            EndOfLineSequence: model_1.EndOfLineSequence,
            TrackedRangeStickiness: model_1.TrackedRangeStickiness,
            CursorChangeReason: cursorEvents_1.CursorChangeReason,
            MouseTargetType: editorBrowser_1.MouseTargetType,
            TextEditorCursorStyle: editorOptions.TextEditorCursorStyle,
            TextEditorCursorBlinkingStyle: editorOptions.TextEditorCursorBlinkingStyle,
            ContentWidgetPositionPreference: editorBrowser_1.ContentWidgetPositionPreference,
            OverlayWidgetPositionPreference: editorBrowser_1.OverlayWidgetPositionPreference,
            RenderMinimap: editorOptions.RenderMinimap,
            ScrollType: ScrollType,
            RenderLineNumbersType: RenderLineNumbersType,
            // classes
            InternalEditorOptions: editorOptions.InternalEditorOptions,
            BareFontInfo: fontInfo_1.BareFontInfo,
            FontInfo: fontInfo_1.FontInfo,
            TextModelResolvedOptions: model_1.TextModelResolvedOptions,
            FindMatch: model_1.FindMatch,
            // vars
            EditorType: editorCommon.EditorType
        };
    }
    exports.createMonacoEditorAPI = createMonacoEditorAPI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[310/*vs/editor/codesandbox.editor.api*/], __M([0/*require*/,1/*exports*/,465/*vs/editor/common/standalone/standaloneBase*/,322/*vs/editor/standalone/browser/codesandbox.standaloneEditor*/,466/*vs/editor/standalone/browser/standaloneLanguages*/,201/*vs/editor/common/config/editorOptions*/,467/*vs/base/common/winjs.polyfill.promise*/]), function (require, exports, standaloneBase_1, codesandbox_standaloneEditor_1, standaloneLanguages_1, editorOptions_1, winjs_polyfill_promise_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var global = self;
    // When missing, polyfill the native promise
    // with our winjs-based polyfill
    if (typeof global.Promise === 'undefined') {
        global.Promise = winjs_polyfill_promise_1.PolyfillPromise;
    }
    // Set defaults for standalone editor
    editorOptions_1.EDITOR_DEFAULTS.wrappingIndent = editorOptions_1.WrappingIndent.None;
    editorOptions_1.EDITOR_DEFAULTS.viewInfo.glyphMargin = false;
    editorOptions_1.EDITOR_DEFAULTS.autoIndent = false;
    var api = global.monaco || standaloneBase_1.createMonacoBaseAPI();
    api.editor = codesandbox_standaloneEditor_1.createMonacoEditorAPI();
    api.languages = api.languages || standaloneLanguages_1.createMonacoLanguagesAPI();
    exports.CancellationTokenSource = api.CancellationTokenSource;
    exports.Emitter = api.Emitter;
    exports.KeyCode = api.KeyCode;
    exports.KeyMod = api.KeyMod;
    exports.Position = api.Position;
    exports.Range = api.Range;
    exports.Selection = api.Selection;
    exports.SelectionDirection = api.SelectionDirection;
    exports.MarkerSeverity = api.MarkerSeverity;
    exports.MarkerTag = api.MarkerTag;
    exports.Promise = api.Promise;
    exports.Uri = api.Uri;
    exports.Token = api.Token;
    exports.editor = api.editor;
    exports.languages = api.languages;
    global.monaco = api;
    if (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {
        global.require.config({
            ignoreDuplicateModules: [
                'vscode-languageserver-types',
                'vscode-languageserver-types/main',
                'vscode-nls',
                'vscode-nls/vscode-nls',
                'jsonc-parser',
                'jsonc-parser/main',
                'vscode-uri',
                'vscode-uri/index',
                'vs/basic-languages/typescript/typescript'
            ]
        });
    }
});

define(__m[145/*vs/workbench/services/workspace/common/workspaceEditing*/], __M([0/*require*/,1/*exports*/,3/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspaceEditingService = instantiation_1.createDecorator('workspaceEditingService');
    exports.IWorkspaceMigrationService = instantiation_1.createDecorator('workspaceMigrationService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[184/*vs/workbench/browser/actions/workspaceCommands*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,20/*vs/platform/workspace/common/workspace*/,145/*vs/workbench/services/workspace/common/workspaceEditing*/,35/*vs/base/common/resources*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,55/*vs/base/common/cancellation*/,83/*vs/base/common/labels*/,37/*vs/platform/commands/common/commands*/,16/*vs/platform/files/common/files*/,59/*vs/platform/label/common/label*/,62/*vs/platform/quickinput/common/quickInput*/,60/*vs/workbench/browser/labels*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,26/*vs/base/common/network*/,92/*vs/platform/dialogs/common/dialogs*/]), function (require, exports, nls, workspace_1, workspaceEditing_1, resources, viewlet_1, cancellation_1, labels_1, commands_1, files_1, label_1, quickInput_1, labels_2, modelService_1, modeService_1, network_1, dialogs_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ADD_ROOT_FOLDER_COMMAND_ID = 'addRootFolder';
    exports.ADD_ROOT_FOLDER_LABEL = nls.localize('addFolderToWorkspace', "Add Folder to Workspace...");
    exports.PICK_WORKSPACE_FOLDER_COMMAND_ID = '_workbench.pickWorkspaceFolder';
    // Command registration
    commands_1.CommandsRegistry.registerCommand({
        id: 'workbench.action.files.openFileFolderInNewWindow',
        handler: function (accessor) { return accessor.get(dialogs_1.IFileDialogService).pickFileFolderAndOpen({ forceNewWindow: true }); }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: '_files.pickFolderAndOpen',
        handler: function (accessor, forceNewWindow) { return accessor.get(dialogs_1.IFileDialogService).pickFolderAndOpen({ forceNewWindow: forceNewWindow }); }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: 'workbench.action.files.openFolderInNewWindow',
        handler: function (accessor) { return accessor.get(dialogs_1.IFileDialogService).pickFolderAndOpen({ forceNewWindow: true }); }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: 'workbench.action.files.openFileInNewWindow',
        handler: function (accessor) { return accessor.get(dialogs_1.IFileDialogService).pickFileAndOpen({ forceNewWindow: true }); }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: 'workbench.action.openWorkspaceInNewWindow',
        handler: function (accessor) { return accessor.get(dialogs_1.IFileDialogService).pickWorkspaceAndOpen({ forceNewWindow: true }); }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.ADD_ROOT_FOLDER_COMMAND_ID,
        handler: function (accessor) {
            var viewletService = accessor.get(viewlet_1.IViewletService);
            var workspaceEditingService = accessor.get(workspaceEditing_1.IWorkspaceEditingService);
            var dialogsService = accessor.get(dialogs_1.IFileDialogService);
            return dialogsService.showOpenDialog({
                openLabel: labels_1.mnemonicButtonLabel(nls.localize({ key: 'add', comment: ['&& denotes a mnemonic'] }, "&&Add")),
                title: nls.localize('addFolderToWorkspaceTitle', "Add Folder to Workspace"),
                canSelectFolders: true,
                canSelectMany: true,
                defaultUri: dialogsService.defaultFolderPath(network_1.Schemas.file)
            }).then(function (folders) {
                if (!folders || !folders.length) {
                    return null;
                }
                // Add and show Files Explorer viewlet
                return workspaceEditingService.addFolders(folders.map(function (folder) { return ({ uri: folder }); }))
                    .then(function () { return viewletService.openViewlet(viewletService.getDefaultViewletId(), true); })
                    .then(function () { return void 0; });
            });
        }
    });
    commands_1.CommandsRegistry.registerCommand(exports.PICK_WORKSPACE_FOLDER_COMMAND_ID, function (accessor, args) {
        var quickInputService = accessor.get(quickInput_1.IQuickInputService);
        var labelService = accessor.get(label_1.ILabelService);
        var contextService = accessor.get(workspace_1.IWorkspaceContextService);
        var modelService = accessor.get(modelService_1.IModelService);
        var modeService = accessor.get(modeService_1.IModeService);
        var folders = contextService.getWorkspace().folders;
        if (!folders.length) {
            return void 0;
        }
        var folderPicks = folders.map(function (folder) {
            return {
                label: folder.name,
                description: labelService.getUriLabel(resources.dirname(folder.uri), { relative: true }),
                folder: folder,
                iconClasses: labels_2.getIconClasses(modelService, modeService, folder.uri, files_1.FileKind.ROOT_FOLDER)
            };
        });
        var options;
        if (args) {
            options = args[0];
        }
        if (!options) {
            options = Object.create(null);
        }
        if (!options.activeItem) {
            options.activeItem = folderPicks[0];
        }
        if (!options.placeHolder) {
            options.placeHolder = nls.localize('workspaceFolderPickerPlaceholder', "Select workspace folder");
        }
        if (typeof options.matchOnDescription !== 'boolean') {
            options.matchOnDescription = true;
        }
        var token;
        if (args) {
            token = args[1];
        }
        if (!token) {
            token = cancellation_1.CancellationToken.None;
        }
        return quickInputService.pick(folderPicks, options, token).then(function (pick) {
            if (!pick) {
                return void 0;
            }
            return folders[folderPicks.indexOf(pick)];
        });
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[181/*vs/workbench/browser/actions/workspaceActions*/], __M([0/*require*/,1/*exports*/,15/*vs/base/common/actions*/,2/*vs/nls*/,42/*vs/platform/windows/common/windows*/,20/*vs/platform/workspace/common/workspace*/,145/*vs/workbench/services/workspace/common/workspaceEditing*/,160/*vs/platform/workspaces/common/workspaces*/,83/*vs/base/common/labels*/,11/*vs/workbench/services/editor/common/editorService*/,37/*vs/platform/commands/common/commands*/,184/*vs/workbench/browser/actions/workspaceCommands*/,12/*vs/base/common/uri*/,26/*vs/base/common/network*/,92/*vs/platform/dialogs/common/dialogs*/]), function (require, exports, actions_1, nls, windows_1, workspace_1, workspaceEditing_1, workspaces_1, labels_1, editorService_1, commands_1, workspaceCommands_1, uri_1, network_1, dialogs_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var OpenFileAction = /** @class */ (function (_super) {
        __extends(OpenFileAction, _super);
        function OpenFileAction(id, label, dialogService) {
            var _this = _super.call(this, id, label) || this;
            _this.dialogService = dialogService;
            return _this;
        }
        OpenFileAction.prototype.run = function (event, data) {
            return this.dialogService.pickFileAndOpen({ forceNewWindow: false, telemetryExtraData: data });
        };
        OpenFileAction.ID = 'workbench.action.files.openFile';
        OpenFileAction.LABEL = nls.localize('openFile', "Open File...");
        OpenFileAction = __decorate([
            __param(2, dialogs_1.IFileDialogService)
        ], OpenFileAction);
        return OpenFileAction;
    }(actions_1.Action));
    exports.OpenFileAction = OpenFileAction;
    var OpenFolderAction = /** @class */ (function (_super) {
        __extends(OpenFolderAction, _super);
        function OpenFolderAction(id, label, dialogService) {
            var _this = _super.call(this, id, label) || this;
            _this.dialogService = dialogService;
            return _this;
        }
        OpenFolderAction.prototype.run = function (event, data) {
            return this.dialogService.pickFolderAndOpen({ forceNewWindow: false, telemetryExtraData: data });
        };
        OpenFolderAction.ID = 'workbench.action.files.openFolder';
        OpenFolderAction.LABEL = nls.localize('openFolder', "Open Folder...");
        OpenFolderAction = __decorate([
            __param(2, dialogs_1.IFileDialogService)
        ], OpenFolderAction);
        return OpenFolderAction;
    }(actions_1.Action));
    exports.OpenFolderAction = OpenFolderAction;
    var OpenFileFolderAction = /** @class */ (function (_super) {
        __extends(OpenFileFolderAction, _super);
        function OpenFileFolderAction(id, label, dialogService) {
            var _this = _super.call(this, id, label) || this;
            _this.dialogService = dialogService;
            return _this;
        }
        OpenFileFolderAction.prototype.run = function (event, data) {
            return this.dialogService.pickFileFolderAndOpen({ forceNewWindow: false, telemetryExtraData: data });
        };
        OpenFileFolderAction.ID = 'workbench.action.files.openFileFolder';
        OpenFileFolderAction.LABEL = nls.localize('openFileFolder', "Open...");
        OpenFileFolderAction = __decorate([
            __param(2, dialogs_1.IFileDialogService)
        ], OpenFileFolderAction);
        return OpenFileFolderAction;
    }(actions_1.Action));
    exports.OpenFileFolderAction = OpenFileFolderAction;
    var AddRootFolderAction = /** @class */ (function (_super) {
        __extends(AddRootFolderAction, _super);
        function AddRootFolderAction(id, label, commandService) {
            var _this = _super.call(this, id, label) || this;
            _this.commandService = commandService;
            return _this;
        }
        AddRootFolderAction.prototype.run = function () {
            return this.commandService.executeCommand(workspaceCommands_1.ADD_ROOT_FOLDER_COMMAND_ID);
        };
        AddRootFolderAction.ID = 'workbench.action.addRootFolder';
        AddRootFolderAction.LABEL = workspaceCommands_1.ADD_ROOT_FOLDER_LABEL;
        AddRootFolderAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], AddRootFolderAction);
        return AddRootFolderAction;
    }(actions_1.Action));
    exports.AddRootFolderAction = AddRootFolderAction;
    var GlobalRemoveRootFolderAction = /** @class */ (function (_super) {
        __extends(GlobalRemoveRootFolderAction, _super);
        function GlobalRemoveRootFolderAction(id, label, workspaceEditingService, contextService, commandService) {
            var _this = _super.call(this, id, label) || this;
            _this.workspaceEditingService = workspaceEditingService;
            _this.contextService = contextService;
            _this.commandService = commandService;
            return _this;
        }
        GlobalRemoveRootFolderAction.prototype.run = function () {
            var _this = this;
            var state = this.contextService.getWorkbenchState();
            // Workspace / Folder
            if (state === 3 /* WORKSPACE */ || state === 2 /* FOLDER */) {
                return this.commandService.executeCommand(workspaceCommands_1.PICK_WORKSPACE_FOLDER_COMMAND_ID).then(function (folder) {
                    if (folder) {
                        return _this.workspaceEditingService.removeFolders([folder.uri]).then(function () { return true; });
                    }
                    return true;
                });
            }
            return Promise.resolve(true);
        };
        GlobalRemoveRootFolderAction.ID = 'workbench.action.removeRootFolder';
        GlobalRemoveRootFolderAction.LABEL = nls.localize('globalRemoveFolderFromWorkspace', "Remove Folder from Workspace...");
        GlobalRemoveRootFolderAction = __decorate([
            __param(2, workspaceEditing_1.IWorkspaceEditingService),
            __param(3, workspace_1.IWorkspaceContextService),
            __param(4, commands_1.ICommandService)
        ], GlobalRemoveRootFolderAction);
        return GlobalRemoveRootFolderAction;
    }(actions_1.Action));
    exports.GlobalRemoveRootFolderAction = GlobalRemoveRootFolderAction;
    var SaveWorkspaceAsAction = /** @class */ (function (_super) {
        __extends(SaveWorkspaceAsAction, _super);
        function SaveWorkspaceAsAction(id, label, contextService, workspaceEditingService, dialogService) {
            var _this = _super.call(this, id, label) || this;
            _this.contextService = contextService;
            _this.workspaceEditingService = workspaceEditingService;
            _this.dialogService = dialogService;
            return _this;
        }
        SaveWorkspaceAsAction.prototype.run = function () {
            var _this = this;
            return this.getNewWorkspaceConfigPath().then(function (configPathUri) {
                if (configPathUri) {
                    var configPath = configPathUri.fsPath;
                    switch (_this.contextService.getWorkbenchState()) {
                        case 1 /* EMPTY */:
                        case 2 /* FOLDER */:
                            var folders = _this.contextService.getWorkspace().folders.map(function (folder) { return ({ uri: folder.uri }); });
                            return _this.workspaceEditingService.createAndEnterWorkspace(folders, configPath);
                        case 3 /* WORKSPACE */:
                            return _this.workspaceEditingService.saveAndEnterWorkspace(configPath);
                    }
                }
                return null;
            });
        };
        SaveWorkspaceAsAction.prototype.getNewWorkspaceConfigPath = function () {
            return this.dialogService.showSaveDialog({
                buttonLabel: labels_1.mnemonicButtonLabel(nls.localize({ key: 'save', comment: ['&& denotes a mnemonic'] }, "&&Save")),
                title: nls.localize('saveWorkspace', "Save Workspace"),
                filters: workspaces_1.WORKSPACE_FILTER,
                defaultUri: this.dialogService.defaultWorkspacePath(network_1.Schemas.file)
            });
        };
        SaveWorkspaceAsAction.ID = 'workbench.action.saveWorkspaceAs';
        SaveWorkspaceAsAction.LABEL = nls.localize('saveWorkspaceAsAction', "Save Workspace As...");
        SaveWorkspaceAsAction = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, workspaceEditing_1.IWorkspaceEditingService),
            __param(4, dialogs_1.IFileDialogService)
        ], SaveWorkspaceAsAction);
        return SaveWorkspaceAsAction;
    }(actions_1.Action));
    exports.SaveWorkspaceAsAction = SaveWorkspaceAsAction;
    var OpenWorkspaceAction = /** @class */ (function (_super) {
        __extends(OpenWorkspaceAction, _super);
        function OpenWorkspaceAction(id, label, dialogService) {
            var _this = _super.call(this, id, label) || this;
            _this.dialogService = dialogService;
            return _this;
        }
        OpenWorkspaceAction.prototype.run = function (event, data) {
            return this.dialogService.pickWorkspaceAndOpen({ telemetryExtraData: data });
        };
        OpenWorkspaceAction.ID = 'workbench.action.openWorkspace';
        OpenWorkspaceAction.LABEL = nls.localize('openWorkspaceAction', "Open Workspace...");
        OpenWorkspaceAction = __decorate([
            __param(2, dialogs_1.IFileDialogService)
        ], OpenWorkspaceAction);
        return OpenWorkspaceAction;
    }(actions_1.Action));
    exports.OpenWorkspaceAction = OpenWorkspaceAction;
    var OpenWorkspaceConfigFileAction = /** @class */ (function (_super) {
        __extends(OpenWorkspaceConfigFileAction, _super);
        function OpenWorkspaceConfigFileAction(id, label, workspaceContextService, editorService) {
            var _this = _super.call(this, id, label) || this;
            _this.workspaceContextService = workspaceContextService;
            _this.editorService = editorService;
            _this.enabled = !!_this.workspaceContextService.getWorkspace().configuration;
            return _this;
        }
        OpenWorkspaceConfigFileAction.prototype.run = function () {
            return this.editorService.openEditor({ resource: this.workspaceContextService.getWorkspace().configuration });
        };
        OpenWorkspaceConfigFileAction.ID = 'workbench.action.openWorkspaceConfigFile';
        OpenWorkspaceConfigFileAction.LABEL = nls.localize('openWorkspaceConfigFile', "Open Workspace Configuration File");
        OpenWorkspaceConfigFileAction = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, editorService_1.IEditorService)
        ], OpenWorkspaceConfigFileAction);
        return OpenWorkspaceConfigFileAction;
    }(actions_1.Action));
    exports.OpenWorkspaceConfigFileAction = OpenWorkspaceConfigFileAction;
    var DuplicateWorkspaceInNewWindowAction = /** @class */ (function (_super) {
        __extends(DuplicateWorkspaceInNewWindowAction, _super);
        function DuplicateWorkspaceInNewWindowAction(id, label, workspaceContextService, workspaceEditingService, windowService, workspacesService) {
            var _this = _super.call(this, id, label) || this;
            _this.workspaceContextService = workspaceContextService;
            _this.workspaceEditingService = workspaceEditingService;
            _this.windowService = windowService;
            _this.workspacesService = workspacesService;
            return _this;
        }
        DuplicateWorkspaceInNewWindowAction.prototype.run = function () {
            var _this = this;
            var folders = this.workspaceContextService.getWorkspace().folders;
            return this.workspacesService.createWorkspace(folders).then(function (newWorkspace) {
                return _this.workspaceEditingService.copyWorkspaceSettings(newWorkspace).then(function () {
                    return _this.windowService.openWindow([uri_1.URI.file(newWorkspace.configPath)], { forceNewWindow: true });
                });
            });
        };
        DuplicateWorkspaceInNewWindowAction.ID = 'workbench.action.duplicateWorkspaceInNewWindow';
        DuplicateWorkspaceInNewWindowAction.LABEL = nls.localize('duplicateWorkspaceInNewWindow', "Duplicate Workspace in New Window");
        DuplicateWorkspaceInNewWindowAction = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, workspaceEditing_1.IWorkspaceEditingService),
            __param(4, windows_1.IWindowService),
            __param(5, workspaces_1.IWorkspacesService)
        ], DuplicateWorkspaceInNewWindowAction);
        return DuplicateWorkspaceInNewWindowAction;
    }(actions_1.Action));
    exports.DuplicateWorkspaceInNewWindowAction = DuplicateWorkspaceInNewWindowAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[150/*vs/workbench/parts/files/electron-browser/fileCommands*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,24/*vs/base/common/paths*/,12/*vs/base/common/uri*/,13/*vs/workbench/common/editor*/,42/*vs/platform/windows/common/windows*/,3/*vs/platform/instantiation/common/instantiation*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,20/*vs/platform/workspace/common/workspace*/,57/*vs/workbench/parts/files/common/files*/,79/*vs/platform/clipboard/common/clipboardService*/,27/*vs/workbench/services/textfile/common/textfiles*/,98/*vs/base/common/errorMessage*/,51/*vs/platform/list/browser/listService*/,176/*vs/base/parts/tree/browser/treeImpl*/,37/*vs/platform/commands/common/commands*/,10/*vs/platform/contextkey/common/contextkey*/,16/*vs/platform/files/common/files*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,45/*vs/editor/browser/editorBrowser*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,65/*vs/base/common/keyCodes*/,18/*vs/base/common/platform*/,66/*vs/editor/common/services/resolverService*/,17/*vs/base/common/async*/,178/*vs/workbench/parts/files/browser/files*/,145/*vs/workbench/services/workspace/common/workspaceEditing*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,26/*vs/base/common/network*/,28/*vs/platform/notification/common/notification*/,114/*vs/editor/common/editorContextKeys*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,59/*vs/platform/label/common/label*/]), function (require, exports, nls, paths, uri_1, editor_1, windows_1, instantiation_1, viewlet_1, workspace_1, files_1, clipboardService_1, textfiles_1, errorMessage_1, listService_1, treeImpl_1, commands_1, contextkey_1, files_2, untitledEditorService_1, editorBrowser_1, keybindingsRegistry_1, keyCodes_1, platform_1, resolverService_1, async_1, files_3, workspaceEditing_1, editorCommands_1, network_1, notification_1, editorContextKeys_1, editorService_1, editorGroupsService_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Commands
    exports.REVEAL_IN_OS_COMMAND_ID = 'revealFileInOS';
    exports.REVEAL_IN_OS_LABEL = platform_1.isWindows ? nls.localize('revealInWindows', "Reveal in Explorer") : platform_1.isMacintosh ? nls.localize('revealInMac', "Reveal in Finder") : nls.localize('openContainer', "Open Containing Folder");
    exports.REVEAL_IN_EXPLORER_COMMAND_ID = 'revealInExplorer';
    exports.REVERT_FILE_COMMAND_ID = 'workbench.action.files.revert';
    exports.OPEN_TO_SIDE_COMMAND_ID = 'explorer.openToSide';
    exports.SELECT_FOR_COMPARE_COMMAND_ID = 'selectForCompare';
    exports.COMPARE_SELECTED_COMMAND_ID = 'compareSelected';
    exports.COMPARE_RESOURCE_COMMAND_ID = 'compareFiles';
    exports.COMPARE_WITH_SAVED_COMMAND_ID = 'workbench.files.action.compareWithSaved';
    exports.COPY_PATH_COMMAND_ID = 'copyFilePath';
    exports.COPY_RELATIVE_PATH_COMMAND_ID = 'copyRelativeFilePath';
    exports.SAVE_FILE_AS_COMMAND_ID = 'workbench.action.files.saveAs';
    exports.SAVE_FILE_AS_LABEL = nls.localize('saveAs', "Save As...");
    exports.SAVE_FILE_COMMAND_ID = 'workbench.action.files.save';
    exports.SAVE_FILE_LABEL = nls.localize('save', "Save");
    exports.SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID = 'workbench.action.files.saveWithoutFormatting';
    exports.SAVE_FILE_WITHOUT_FORMATTING_LABEL = nls.localize('saveWithoutFormatting', "Save without Formatting");
    exports.SAVE_ALL_COMMAND_ID = 'saveAll';
    exports.SAVE_ALL_LABEL = nls.localize('saveAll', "Save All");
    exports.SAVE_ALL_IN_GROUP_COMMAND_ID = 'workbench.files.action.saveAllInGroup';
    exports.SAVE_FILES_COMMAND_ID = 'workbench.action.files.saveFiles';
    exports.OpenEditorsGroupContext = new contextkey_1.RawContextKey('groupFocusedInOpenEditors', false);
    exports.DirtyEditorContext = new contextkey_1.RawContextKey('dirtyEditor', false);
    exports.ResourceSelectedForCompareContext = new contextkey_1.RawContextKey('resourceSelectedForCompare', false);
    exports.REMOVE_ROOT_FOLDER_COMMAND_ID = 'removeRootFolder';
    exports.REMOVE_ROOT_FOLDER_LABEL = nls.localize('removeFolderFromWorkspace', "Remove Folder from Workspace");
    exports.openWindowCommand = function (accessor, paths, forceNewWindow) {
        var windowService = accessor.get(windows_1.IWindowService);
        windowService.openWindow(paths.map(function (p) { return typeof p === 'string' ? uri_1.URI.file(p) : p; }), { forceNewWindow: forceNewWindow });
    };
    function save(resource, isSaveAs, options, editorService, fileService, untitledEditorService, textFileService, editorGroupService) {
        function ensureForcedSave(options) {
            if (!options) {
                options = { force: true };
            }
            else {
                options.force = true;
            }
            return options;
        }
        if (resource && (fileService.canHandleResource(resource) || resource.scheme === network_1.Schemas.untitled)) {
            // Save As (or Save untitled with associated path)
            if (isSaveAs || resource.scheme === network_1.Schemas.untitled) {
                var encodingOfSource_1;
                if (resource.scheme === network_1.Schemas.untitled) {
                    encodingOfSource_1 = untitledEditorService.getEncoding(resource);
                }
                else if (fileService.canHandleResource(resource)) {
                    var textModel = textFileService.models.get(resource);
                    encodingOfSource_1 = textModel && textModel.getEncoding(); // text model can be null e.g. if this is a binary file!
                }
                var viewStateOfSource_1;
                var activeTextEditorWidget = editorBrowser_1.getCodeEditor(editorService.activeTextEditorWidget);
                if (activeTextEditorWidget) {
                    var activeResource = editor_1.toResource(editorService.activeEditor, { supportSideBySide: true });
                    if (activeResource && (fileService.canHandleResource(activeResource) || resource.scheme === network_1.Schemas.untitled) && activeResource.toString() === resource.toString()) {
                        viewStateOfSource_1 = activeTextEditorWidget.saveViewState();
                    }
                }
                // Special case: an untitled file with associated path gets saved directly unless "saveAs" is true
                var savePromise = void 0;
                if (!isSaveAs && resource.scheme === network_1.Schemas.untitled && untitledEditorService.hasAssociatedFilePath(resource)) {
                    savePromise = textFileService.save(resource, options).then(function (result) {
                        if (result) {
                            return resource.with({ scheme: network_1.Schemas.file });
                        }
                        return null;
                    });
                }
                // Otherwise, really "Save As..."
                else {
                    // Force a change to the file to trigger external watchers if any
                    // fixes https://github.com/Microsoft/vscode/issues/59655
                    options = ensureForcedSave(options);
                    savePromise = textFileService.saveAs(resource, void 0, options);
                }
                return savePromise.then(function (target) {
                    if (!target || target.toString() === resource.toString()) {
                        return void 0; // save canceled or same resource used
                    }
                    var replacement = {
                        resource: target,
                        encoding: encodingOfSource_1,
                        options: {
                            pinned: true,
                            viewState: viewStateOfSource_1
                        }
                    };
                    return Promise.all(editorGroupService.groups.map(function (g) {
                        return editorService.replaceEditors([{
                                editor: { resource: resource },
                                replacement: replacement
                            }], g);
                    })).then(function () { return true; });
                });
            }
            // Pin the active editor if we are saving it
            var activeControl = editorService.activeControl;
            var activeEditorResource = activeControl && activeControl.input && activeControl.input.getResource();
            if (activeEditorResource && activeEditorResource.toString() === resource.toString()) {
                activeControl.group.pinEditor(activeControl.input);
            }
            // Just save (force a change to the file to trigger external watchers if any)
            options = ensureForcedSave(options);
            return textFileService.save(resource, options);
        }
        return Promise.resolve(false);
    }
    function saveAll(saveAllArguments, editorService, untitledEditorService, textFileService, editorGroupService) {
        // Store some properties per untitled file to restore later after save is completed
        var groupIdToUntitledResourceInput = new Map();
        editorGroupService.groups.forEach(function (g) {
            var activeEditorResource = g.activeEditor && g.activeEditor.getResource();
            g.editors.forEach(function (e) {
                var resource = e.getResource();
                if (resource && untitledEditorService.isDirty(resource)) {
                    if (!groupIdToUntitledResourceInput.has(g.id)) {
                        groupIdToUntitledResourceInput.set(g.id, []);
                    }
                    groupIdToUntitledResourceInput.get(g.id).push({
                        encoding: untitledEditorService.getEncoding(resource),
                        resource: resource,
                        options: {
                            inactive: activeEditorResource ? activeEditorResource.toString() !== resource.toString() : true,
                            pinned: true,
                            preserveFocus: true,
                            index: g.getIndexOfEditor(e)
                        }
                    });
                }
            });
        });
        // Save all
        return textFileService.saveAll(saveAllArguments).then(function (result) {
            groupIdToUntitledResourceInput.forEach(function (inputs, groupId) {
                // Update untitled resources to the saved ones, so we open the proper files
                inputs.forEach(function (i) {
                    var targetResult = result.results.filter(function (r) { return r.success && r.source.toString() === i.resource.toString(); }).pop();
                    if (targetResult) {
                        i.resource = targetResult.target;
                    }
                });
                editorService.openEditors(inputs, groupId);
            });
        });
    }
    // Command registration
    commands_1.CommandsRegistry.registerCommand({
        id: exports.REVERT_FILE_COMMAND_ID,
        handler: function (accessor, resource) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var textFileService = accessor.get(textfiles_1.ITextFileService);
            var notificationService = accessor.get(notification_1.INotificationService);
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), editorService)
                .filter(function (resource) { return resource.scheme !== network_1.Schemas.untitled; });
            if (resources.length) {
                return textFileService.revertAll(resources, { force: true }).then(null, function (error) {
                    notificationService.error(nls.localize('genericRevertError', "Failed to revert '{0}': {1}", resources.map(function (r) { return paths.basename(r.fsPath); }).join(', '), errorMessage_1.toErrorMessage(error, false)));
                });
            }
            return Promise.resolve(true);
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: 200 /* WorkbenchContrib */,
        when: files_1.ExplorerFocusCondition,
        primary: 2048 /* CtrlCmd */ | 3 /* Enter */,
        mac: {
            primary: 256 /* WinCtrl */ | 3 /* Enter */
        },
        id: exports.OPEN_TO_SIDE_COMMAND_ID, handler: function (accessor, resource) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var listService = accessor.get(listService_1.IListService);
            var fileService = accessor.get(files_2.IFileService);
            var tree = listService.lastFocusedList;
            var resources = files_3.getMultiSelectedResources(resource, listService, editorService);
            // Remove highlight
            if (tree instanceof treeImpl_1.Tree) {
                tree.clearHighlight();
            }
            // Set side input
            if (resources.length) {
                return fileService.resolveFiles(resources.map(function (resource) { return ({ resource: resource }); })).then(function (resolved) {
                    var editors = resolved.filter(function (r) { return r.success && !r.stat.isDirectory; }).map(function (r) { return ({
                        resource: r.stat.resource
                    }); });
                    return editorService.openEditors(editors, editorService_1.SIDE_GROUP);
                });
            }
            return Promise.resolve(true);
        }
    });
    var COMPARE_WITH_SAVED_SCHEMA = 'showModifications';
    var provider;
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: exports.COMPARE_WITH_SAVED_COMMAND_ID,
        when: undefined,
        weight: 200 /* WorkbenchContrib */,
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 34 /* KEY_D */),
        handler: function (accessor, resource) {
            if (!provider) {
                var instantiationService = accessor.get(instantiation_1.IInstantiationService);
                var textModelService = accessor.get(resolverService_1.ITextModelService);
                provider = instantiationService.createInstance(files_1.FileOnDiskContentProvider);
                textModelService.registerTextModelContentProvider(COMPARE_WITH_SAVED_SCHEMA, provider);
            }
            var editorService = accessor.get(editorService_1.IEditorService);
            var uri = files_3.getResourceForCommand(resource, accessor.get(listService_1.IListService), editorService);
            if (uri && uri.scheme === network_1.Schemas.file /* only files on disk supported for now */) {
                var name_1 = paths.basename(uri.fsPath);
                var editorLabel = nls.localize('modifiedLabel', "{0} (on disk)  {1}", name_1, name_1);
                return editorService.openEditor({ leftResource: uri.with({ scheme: COMPARE_WITH_SAVED_SCHEMA }), rightResource: uri, label: editorLabel }).then(function () { return void 0; });
            }
            return Promise.resolve(true);
        }
    });
    var globalResourceToCompare;
    var resourceSelectedForCompareContext;
    commands_1.CommandsRegistry.registerCommand({
        id: exports.SELECT_FOR_COMPARE_COMMAND_ID,
        handler: function (accessor, resource) {
            var listService = accessor.get(listService_1.IListService);
            var tree = listService.lastFocusedList;
            // Remove highlight
            if (tree instanceof treeImpl_1.Tree) {
                tree.clearHighlight();
                tree.domFocus();
            }
            globalResourceToCompare = files_3.getResourceForCommand(resource, listService, accessor.get(editorService_1.IEditorService));
            if (!resourceSelectedForCompareContext) {
                resourceSelectedForCompareContext = exports.ResourceSelectedForCompareContext.bindTo(accessor.get(contextkey_1.IContextKeyService));
            }
            resourceSelectedForCompareContext.set(true);
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.COMPARE_SELECTED_COMMAND_ID,
        handler: function (accessor, resource) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), editorService);
            if (resources.length === 2) {
                return editorService.openEditor({
                    leftResource: resources[0],
                    rightResource: resources[1]
                });
            }
            return Promise.resolve(true);
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.COMPARE_RESOURCE_COMMAND_ID,
        handler: function (accessor, resource) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var listService = accessor.get(listService_1.IListService);
            var tree = listService.lastFocusedList;
            // Remove highlight
            if (tree instanceof treeImpl_1.Tree) {
                tree.clearHighlight();
            }
            return editorService.openEditor({
                leftResource: globalResourceToCompare,
                rightResource: files_3.getResourceForCommand(resource, listService, editorService)
            }).then(function () { return void 0; });
        }
    });
    function revealResourcesInOS(resources, windowsService, notificationService, workspaceContextService) {
        if (resources.length) {
            async_1.sequence(resources.map(function (r) { return function () { return windowsService.showItemInFolder(paths.normalize(r.fsPath, true)); }; }));
        }
        else if (workspaceContextService.getWorkspace().folders.length) {
            windowsService.showItemInFolder(paths.normalize(workspaceContextService.getWorkspace().folders[0].uri.fsPath, true));
        }
        else {
            notificationService.info(nls.localize('openFileToReveal', "Open a file first to reveal"));
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: exports.REVEAL_IN_OS_COMMAND_ID,
        weight: 200 /* WorkbenchContrib */,
        when: editorContextKeys_1.EditorContextKeys.focus.toNegated(),
        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KEY_R */,
        win: {
            primary: 1024 /* Shift */ | 512 /* Alt */ | 48 /* KEY_R */
        },
        handler: function (accessor, resource) {
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), accessor.get(editorService_1.IEditorService));
            revealResourcesInOS(resources, accessor.get(windows_1.IWindowsService), accessor.get(notification_1.INotificationService), accessor.get(workspace_1.IWorkspaceContextService));
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: 200 /* WorkbenchContrib */,
        when: undefined,
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 48 /* KEY_R */),
        id: 'workbench.action.files.revealActiveFileInWindows',
        handler: function (accessor) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var activeInput = editorService.activeEditor;
            var resources = activeInput && activeInput.getResource() ? [activeInput.getResource()] : [];
            revealResourcesInOS(resources, accessor.get(windows_1.IWindowsService), accessor.get(notification_1.INotificationService), accessor.get(workspace_1.IWorkspaceContextService));
        }
    });
    function resourcesToClipboard(resources, relative, clipboardService, notificationService, labelService) {
        if (resources.length) {
            var lineDelimiter = platform_1.isWindows ? '\r\n' : '\n';
            var text = resources.map(function (resource) { return labelService.getUriLabel(resource, { relative: relative, noPrefix: true }); })
                .join(lineDelimiter);
            clipboardService.writeText(text);
        }
        else {
            notificationService.info(nls.localize('openFileToCopy', "Open a file first to copy its path"));
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: 200 /* WorkbenchContrib */,
        when: editorContextKeys_1.EditorContextKeys.focus.toNegated(),
        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */,
        win: {
            primary: 1024 /* Shift */ | 512 /* Alt */ | 33 /* KEY_C */
        },
        id: exports.COPY_PATH_COMMAND_ID,
        handler: function (accessor, resource) {
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), accessor.get(editorService_1.IEditorService));
            resourcesToClipboard(resources, false, accessor.get(clipboardService_1.IClipboardService), accessor.get(notification_1.INotificationService), accessor.get(label_1.ILabelService));
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: 200 /* WorkbenchContrib */,
        when: editorContextKeys_1.EditorContextKeys.focus.toNegated(),
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 33 /* KEY_C */,
        win: {
            primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */)
        },
        id: exports.COPY_RELATIVE_PATH_COMMAND_ID,
        handler: function (accessor, resource) {
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), accessor.get(editorService_1.IEditorService));
            resourcesToClipboard(resources, true, accessor.get(clipboardService_1.IClipboardService), accessor.get(notification_1.INotificationService), accessor.get(label_1.ILabelService));
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        weight: 200 /* WorkbenchContrib */,
        when: undefined,
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 46 /* KEY_P */),
        id: 'workbench.action.files.copyPathOfActiveFile',
        handler: function (accessor) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var activeInput = editorService.activeEditor;
            var resources = activeInput && activeInput.getResource() ? [activeInput.getResource()] : [];
            resourcesToClipboard(resources, false, accessor.get(clipboardService_1.IClipboardService), accessor.get(notification_1.INotificationService), accessor.get(label_1.ILabelService));
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.REVEAL_IN_EXPLORER_COMMAND_ID,
        handler: function (accessor, resource) {
            var viewletService = accessor.get(viewlet_1.IViewletService);
            var contextService = accessor.get(workspace_1.IWorkspaceContextService);
            var uri = files_3.getResourceForCommand(resource, accessor.get(listService_1.IListService), accessor.get(editorService_1.IEditorService));
            viewletService.openViewlet(files_1.VIEWLET_ID, false).then(function (viewlet) {
                var isInsideWorkspace = contextService.isInsideWorkspace(uri);
                if (isInsideWorkspace) {
                    var explorerView = viewlet.getExplorerView();
                    if (explorerView) {
                        explorerView.setExpanded(true);
                        explorerView.select(uri, true);
                    }
                }
                else {
                    var openEditorsView = viewlet.getOpenEditorsView();
                    if (openEditorsView) {
                        openEditorsView.setExpanded(true);
                    }
                }
            });
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: exports.SAVE_FILE_AS_COMMAND_ID,
        weight: 200 /* WorkbenchContrib */,
        when: undefined,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 49 /* KEY_S */,
        handler: function (accessor, resourceOrObject) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var resource = undefined;
            if (resourceOrObject && 'from' in resourceOrObject && resourceOrObject.from === 'menu') {
                resource = editor_1.toResource(editorService.activeEditor);
            }
            else {
                resource = files_3.getResourceForCommand(resourceOrObject, accessor.get(listService_1.IListService), editorService);
            }
            return save(resource, true, void 0, editorService, accessor.get(files_2.IFileService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        when: undefined,
        weight: 200 /* WorkbenchContrib */,
        primary: 2048 /* CtrlCmd */ | 49 /* KEY_S */,
        id: exports.SAVE_FILE_COMMAND_ID,
        handler: function (accessor, resource) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), editorService);
            if (resources.length === 1) {
                // If only one resource is selected explictly call save since the behavior is a bit different than save all #41841
                return save(resources[0], false, void 0, editorService, accessor.get(files_2.IFileService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
            }
            return saveAll(resources, editorService, accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        when: undefined,
        weight: 200 /* WorkbenchContrib */,
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 49 /* KEY_S */),
        win: { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 1024 /* Shift */ | 49 /* KEY_S */) },
        id: exports.SAVE_FILE_WITHOUT_FORMATTING_COMMAND_ID,
        handler: function (accessor) {
            var editorService = accessor.get(editorService_1.IEditorService);
            var resource = editor_1.toResource(editorService.activeEditor, { supportSideBySide: true });
            if (resource) {
                return save(resource, false, { skipSaveParticipants: true }, editorService, accessor.get(files_2.IFileService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
            }
            return void 0;
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.SAVE_ALL_COMMAND_ID,
        handler: function (accessor) {
            return saveAll(true, accessor.get(editorService_1.IEditorService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.SAVE_ALL_IN_GROUP_COMMAND_ID,
        handler: function (accessor, resource, editorContext) {
            var contexts = editorCommands_1.getMultiSelectedEditorContexts(editorContext, accessor.get(listService_1.IListService), accessor.get(editorGroupsService_1.IEditorGroupsService));
            var editorGroupService = accessor.get(editorGroupsService_1.IEditorGroupsService);
            var saveAllArg;
            if (!contexts.length) {
                saveAllArg = true;
            }
            else {
                var fileService_1 = accessor.get(files_2.IFileService);
                saveAllArg = [];
                contexts.forEach(function (context) {
                    var editorGroup = editorGroupService.getGroup(context.groupId);
                    editorGroup.editors.forEach(function (editor) {
                        var resource = editor_1.toResource(editor, { supportSideBySide: true });
                        if (resource && (resource.scheme === network_1.Schemas.untitled || fileService_1.canHandleResource(resource))) {
                            saveAllArg.push(resource);
                        }
                    });
                });
            }
            return saveAll(saveAllArg, accessor.get(editorService_1.IEditorService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.SAVE_FILES_COMMAND_ID,
        handler: function (accessor) {
            return saveAll(false, accessor.get(editorService_1.IEditorService), accessor.get(untitledEditorService_1.IUntitledEditorService), accessor.get(textfiles_1.ITextFileService), accessor.get(editorGroupsService_1.IEditorGroupsService));
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.REMOVE_ROOT_FOLDER_COMMAND_ID,
        handler: function (accessor, resource) {
            var workspaceEditingService = accessor.get(workspaceEditing_1.IWorkspaceEditingService);
            var contextService = accessor.get(workspace_1.IWorkspaceContextService);
            var workspace = contextService.getWorkspace();
            var resources = files_3.getMultiSelectedResources(resource, accessor.get(listService_1.IListService), accessor.get(editorService_1.IEditorService)).filter(function (r) {
                // Need to verify resources are workspaces since multi selection can trigger this command on some non workspace resources
                return workspace.folders.some(function (f) { return f.uri.toString() === r.toString(); });
            });
            return workspaceEditingService.removeFolders(resources);
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[156/*vs/workbench/parts/files/electron-browser/fileActions*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,29/*vs/base/common/types*/,18/*vs/base/common/platform*/,17/*vs/base/common/async*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,98/*vs/base/common/errorMessage*/,22/*vs/base/common/strings*/,15/*vs/base/common/actions*/,4/*vs/base/common/lifecycle*/,57/*vs/workbench/parts/files/common/files*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,13/*vs/workbench/common/editor*/,91/*vs/workbench/parts/files/common/explorerModel*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,76/*vs/workbench/browser/viewlet*/,46/*vs/platform/quickOpen/common/quickOpen*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,3/*vs/platform/instantiation/common/instantiation*/,42/*vs/platform/windows/common/windows*/,150/*vs/workbench/parts/files/electron-browser/fileCommands*/,66/*vs/editor/common/services/resolverService*/,7/*vs/platform/configuration/common/configuration*/,79/*vs/platform/clipboard/common/clipboardService*/,41/*vs/editor/common/services/modeService*/,36/*vs/editor/common/services/modelService*/,37/*vs/platform/commands/common/commands*/,51/*vs/platform/list/browser/listService*/,10/*vs/platform/contextkey/common/contextkey*/,26/*vs/base/common/network*/,92/*vs/platform/dialogs/common/dialogs*/,28/*vs/platform/notification/common/notification*/,11/*vs/workbench/services/editor/common/editorService*/,104/*vs/workbench/browser/parts/editor/editorCommands*/,259/*vs/css!vs/workbench/parts/files/electron-browser/media/fileactions*/]), function (require, exports, nls, types, platform_1, async_1, paths, resources, errorMessage_1, strings, actions_1, lifecycle_1, files_1, textfiles_1, files_2, editor_1, explorerModel_1, untitledEditorService_1, viewlet_1, quickOpen_1, viewlet_2, instantiation_1, windows_1, fileCommands_1, resolverService_1, configuration_1, clipboardService_1, modeService_1, modelService_1, commands_1, listService_1, contextkey_1, network_1, dialogs_1, notification_1, editorService_1, editorCommands_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NEW_FILE_COMMAND_ID = 'explorer.newFile';
    exports.NEW_FILE_LABEL = nls.localize('newFile', "New File");
    exports.NEW_FOLDER_COMMAND_ID = 'explorer.newFolder';
    exports.NEW_FOLDER_LABEL = nls.localize('newFolder', "New Folder");
    exports.TRIGGER_RENAME_LABEL = nls.localize('rename', "Rename");
    exports.MOVE_FILE_TO_TRASH_LABEL = nls.localize('delete', "Delete");
    exports.COPY_FILE_LABEL = nls.localize('copyFile', "Copy");
    exports.PASTE_FILE_LABEL = nls.localize('pasteFile', "Paste");
    exports.FileCopiedContext = new contextkey_1.RawContextKey('fileCopied', false);
    var BaseErrorReportingAction = /** @class */ (function (_super) {
        __extends(BaseErrorReportingAction, _super);
        function BaseErrorReportingAction(id, label, _notificationService) {
            var _this = _super.call(this, id, label) || this;
            _this._notificationService = _notificationService;
            return _this;
        }
        Object.defineProperty(BaseErrorReportingAction.prototype, "notificationService", {
            get: function () {
                return this._notificationService;
            },
            enumerable: true,
            configurable: true
        });
        BaseErrorReportingAction.prototype.onError = function (error) {
            if (error.message === 'string') {
                error = error.message;
            }
            this._notificationService.error(errorMessage_1.toErrorMessage(error, false));
        };
        BaseErrorReportingAction.prototype.onErrorWithRetry = function (error, retry) {
            this._notificationService.prompt(notification_1.Severity.Error, errorMessage_1.toErrorMessage(error, false), [{
                    label: nls.localize('retry', "Retry"),
                    run: function () { return retry(); }
                }]);
        };
        return BaseErrorReportingAction;
    }(actions_1.Action));
    exports.BaseErrorReportingAction = BaseErrorReportingAction;
    var BaseFileAction = /** @class */ (function (_super) {
        __extends(BaseFileAction, _super);
        function BaseFileAction(id, label, fileService, notificationService, textFileService) {
            var _this = _super.call(this, id, label, notificationService) || this;
            _this.fileService = fileService;
            _this.textFileService = textFileService;
            _this.enabled = false;
            return _this;
        }
        BaseFileAction.prototype._isEnabled = function () {
            return true;
        };
        BaseFileAction.prototype._updateEnablement = function () {
            this.enabled = !!(this.fileService && this._isEnabled());
        };
        BaseFileAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService)
        ], BaseFileAction);
        return BaseFileAction;
    }(BaseErrorReportingAction));
    exports.BaseFileAction = BaseFileAction;
    var TriggerRenameFileAction = /** @class */ (function (_super) {
        __extends(TriggerRenameFileAction, _super);
        function TriggerRenameFileAction(tree, element, fileService, notificationService, textFileService, instantiationService) {
            var _this = _super.call(this, TriggerRenameFileAction.ID, exports.TRIGGER_RENAME_LABEL, fileService, notificationService, textFileService) || this;
            _this.tree = tree;
            _this.element = element;
            _this.renameAction = instantiationService.createInstance(RenameFileAction, element);
            _this._updateEnablement();
            return _this;
        }
        TriggerRenameFileAction.prototype.validateFileName = function (name) {
            var names = name.split(/[\\/]/).filter(function (part) { return !!part; });
            if (names.length > 1) { // error only occurs on multi-path
                var comparer = platform_1.isLinux ? strings.compare : strings.compareIgnoreCase;
                if (comparer(names[0], this.element.name) === 0) {
                    return nls.localize('renameWhenSourcePathIsParentOfTargetError', "Please use the 'New Folder' or 'New File' command to add children to an existing folder");
                }
            }
            return this.renameAction.validateFileName(this.element.parent, name);
        };
        TriggerRenameFileAction.prototype.run = function (context) {
            var _this = this;
            if (!context) {
                return Promise.reject(new Error('No context provided to BaseEnableFileRenameAction.'));
            }
            var viewletState = context.viewletState;
            if (!viewletState) {
                return Promise.reject(new Error('Invalid viewlet state provided to BaseEnableFileRenameAction.'));
            }
            var stat = context.stat;
            if (!stat) {
                return Promise.reject(new Error('Invalid stat provided to BaseEnableFileRenameAction.'));
            }
            viewletState.setEditable(stat, {
                action: this.renameAction,
                validator: function (value) {
                    var message = _this.validateFileName(value);
                    if (!message) {
                        return null;
                    }
                    return {
                        content: message,
                        formatContent: true,
                        type: 3 /* ERROR */
                    };
                }
            });
            this.tree.refresh(stat, false).then(function () {
                _this.tree.setHighlight(stat);
                var unbind = _this.tree.onDidChangeHighlight(function (e) {
                    if (!e.highlight) {
                        viewletState.clearEditable(stat);
                        _this.tree.refresh(stat);
                        unbind.dispose();
                    }
                });
            });
            return void 0;
        };
        TriggerRenameFileAction.ID = 'renameFile';
        TriggerRenameFileAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, instantiation_1.IInstantiationService)
        ], TriggerRenameFileAction);
        return TriggerRenameFileAction;
    }(BaseFileAction));
    var BaseRenameAction = /** @class */ (function (_super) {
        __extends(BaseRenameAction, _super);
        function BaseRenameAction(id, label, element, fileService, notificationService, textFileService) {
            var _this = _super.call(this, id, label, fileService, notificationService, textFileService) || this;
            _this.element = element;
            return _this;
        }
        BaseRenameAction.prototype._isEnabled = function () {
            return _super.prototype._isEnabled.call(this) && this.element && !this.element.isReadonly;
        };
        BaseRenameAction.prototype.run = function (context) {
            var _this = this;
            if (!context) {
                return Promise.reject(new Error('No context provided to BaseRenameFileAction.'));
            }
            var name = context.value;
            if (!name) {
                return Promise.reject(new Error('No new name provided to BaseRenameFileAction.'));
            }
            // Automatically trim whitespaces and trailing dots to produce nice file names
            name = getWellFormedFileName(name);
            var existingName = getWellFormedFileName(this.element.name);
            // Return early if name is invalid or didn't change
            if (name === existingName || this.validateFileName(this.element.parent, name)) {
                return Promise.resolve(null);
            }
            // Call function and Emit Event through viewer
            var promise = this.runAction(name).then(null, function (error) {
                _this.onError(error);
            });
            return promise;
        };
        BaseRenameAction.prototype.validateFileName = function (parent, name) {
            var source = this.element.name;
            var target = name;
            if (!platform_1.isLinux) { // allow rename of same file also when case differs (e.g. Game.js => game.js)
                source = source.toLowerCase();
                target = target.toLowerCase();
            }
            if (getWellFormedFileName(source) === getWellFormedFileName(target)) {
                return null;
            }
            return validateFileName(parent, name);
        };
        BaseRenameAction = __decorate([
            __param(3, files_2.IFileService),
            __param(4, notification_1.INotificationService),
            __param(5, textfiles_1.ITextFileService)
        ], BaseRenameAction);
        return BaseRenameAction;
    }(BaseFileAction));
    exports.BaseRenameAction = BaseRenameAction;
    var RenameFileAction = /** @class */ (function (_super) {
        __extends(RenameFileAction, _super);
        function RenameFileAction(element, fileService, notificationService, textFileService) {
            var _this = _super.call(this, RenameFileAction.ID, nls.localize('rename', "Rename"), element, fileService, notificationService, textFileService) || this;
            _this._updateEnablement();
            return _this;
        }
        RenameFileAction.prototype.runAction = function (newName) {
            var parentResource = this.element.parent.resource;
            var targetResource = resources.joinPath(parentResource, newName);
            return this.textFileService.move(this.element.resource, targetResource);
        };
        RenameFileAction.ID = 'workbench.files.action.renameFile';
        RenameFileAction = __decorate([
            __param(1, files_2.IFileService),
            __param(2, notification_1.INotificationService),
            __param(3, textfiles_1.ITextFileService)
        ], RenameFileAction);
        return RenameFileAction;
    }(BaseRenameAction));
    /* Base New File/Folder Action */
    var BaseNewAction = /** @class */ (function (_super) {
        __extends(BaseNewAction, _super);
        function BaseNewAction(id, label, tree, isFile, editableAction, element, fileService, notificationService, textFileService) {
            var _this = _super.call(this, id, label, fileService, notificationService, textFileService) || this;
            if (element) {
                _this.presetFolder = element.isDirectory ? element : element.parent;
            }
            _this.tree = tree;
            _this.isFile = isFile;
            _this.renameAction = editableAction;
            return _this;
        }
        BaseNewAction.prototype.run = function (context) {
            var _this = this;
            if (!context) {
                return Promise.reject(new Error('No context provided to BaseNewAction.'));
            }
            var viewletState = context.viewletState;
            if (!viewletState) {
                return Promise.reject(new Error('Invalid viewlet state provided to BaseNewAction.'));
            }
            var folder = this.presetFolder;
            if (!folder) {
                var focus_1 = this.tree.getFocus();
                if (focus_1) {
                    folder = focus_1.isDirectory ? focus_1 : focus_1.parent;
                }
                else {
                    var input = this.tree.getInput();
                    folder = input instanceof explorerModel_1.Model ? input.roots[0] : input;
                }
            }
            if (!folder) {
                return Promise.reject(new Error('Invalid parent folder to create.'));
            }
            if (folder.isReadonly) {
                return Promise.reject(new Error('Parent folder is readonly.'));
            }
            if (!!folder.getChild(explorerModel_1.NewStatPlaceholder.NAME)) {
                // Do not allow to creatae a new file/folder while in the process of creating a new file/folder #47606
                return Promise.resolve(new Error('Parent folder is already in the process of creating a file'));
            }
            return this.tree.reveal(folder, 0.5).then(function () {
                return _this.tree.expand(folder).then(function () {
                    var stat = explorerModel_1.NewStatPlaceholder.addNewStatPlaceholder(folder, !_this.isFile);
                    _this.renameAction.element = stat;
                    viewletState.setEditable(stat, {
                        action: _this.renameAction,
                        validator: function (value) {
                            var message = _this.renameAction.validateFileName(folder, value);
                            if (!message) {
                                return null;
                            }
                            return {
                                content: message,
                                formatContent: true,
                                type: 3 /* ERROR */
                            };
                        }
                    });
                    return _this.tree.refresh(folder).then(function () {
                        return _this.tree.expand(folder).then(function () {
                            return _this.tree.reveal(stat, 0.5).then(function () {
                                _this.tree.setHighlight(stat);
                                var unbind = _this.tree.onDidChangeHighlight(function (e) {
                                    if (!e.highlight) {
                                        stat.destroy();
                                        _this.tree.refresh(folder);
                                        unbind.dispose();
                                    }
                                });
                            });
                        });
                    });
                });
            });
        };
        BaseNewAction = __decorate([
            __param(6, files_2.IFileService),
            __param(7, notification_1.INotificationService),
            __param(8, textfiles_1.ITextFileService)
        ], BaseNewAction);
        return BaseNewAction;
    }(BaseFileAction));
    exports.BaseNewAction = BaseNewAction;
    /* New File */
    var NewFileAction = /** @class */ (function (_super) {
        __extends(NewFileAction, _super);
        function NewFileAction(tree, element, fileService, notificationService, textFileService, instantiationService) {
            var _this = _super.call(this, 'explorer.newFile', exports.NEW_FILE_LABEL, tree, true, instantiationService.createInstance(CreateFileAction, element), null, fileService, notificationService, textFileService) || this;
            _this.class = 'explorer-action new-file';
            _this._updateEnablement();
            return _this;
        }
        NewFileAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, instantiation_1.IInstantiationService)
        ], NewFileAction);
        return NewFileAction;
    }(BaseNewAction));
    exports.NewFileAction = NewFileAction;
    /* New Folder */
    var NewFolderAction = /** @class */ (function (_super) {
        __extends(NewFolderAction, _super);
        function NewFolderAction(tree, element, fileService, notificationService, textFileService, instantiationService) {
            var _this = _super.call(this, 'explorer.newFolder', exports.NEW_FOLDER_LABEL, tree, false, instantiationService.createInstance(CreateFolderAction, element), null, fileService, notificationService, textFileService) || this;
            _this.class = 'explorer-action new-folder';
            _this._updateEnablement();
            return _this;
        }
        NewFolderAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, instantiation_1.IInstantiationService)
        ], NewFolderAction);
        return NewFolderAction;
    }(BaseNewAction));
    exports.NewFolderAction = NewFolderAction;
    /* Create new file from anywhere: Open untitled */
    var GlobalNewUntitledFileAction = /** @class */ (function (_super) {
        __extends(GlobalNewUntitledFileAction, _super);
        function GlobalNewUntitledFileAction(id, label, editorService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            return _this;
        }
        GlobalNewUntitledFileAction.prototype.run = function () {
            return this.editorService.openEditor({ options: { pinned: true } }); // untitled are always pinned
        };
        GlobalNewUntitledFileAction.ID = 'workbench.action.files.newUntitledFile';
        GlobalNewUntitledFileAction.LABEL = nls.localize('newUntitledFile', "New Untitled File");
        GlobalNewUntitledFileAction = __decorate([
            __param(2, editorService_1.IEditorService)
        ], GlobalNewUntitledFileAction);
        return GlobalNewUntitledFileAction;
    }(actions_1.Action));
    exports.GlobalNewUntitledFileAction = GlobalNewUntitledFileAction;
    /* Create New File/Folder (only used internally by explorerViewer) */
    var BaseCreateAction = /** @class */ (function (_super) {
        __extends(BaseCreateAction, _super);
        function BaseCreateAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BaseCreateAction.prototype.validateFileName = function (parent, name) {
            if (this.element instanceof explorerModel_1.NewStatPlaceholder) {
                return validateFileName(parent, name);
            }
            return _super.prototype.validateFileName.call(this, parent, name);
        };
        return BaseCreateAction;
    }(BaseRenameAction));
    exports.BaseCreateAction = BaseCreateAction;
    /* Create New File (only used internally by explorerViewer) */
    var CreateFileAction = /** @class */ (function (_super) {
        __extends(CreateFileAction, _super);
        function CreateFileAction(element, fileService, editorService, notificationService, textFileService) {
            var _this = _super.call(this, CreateFileAction.ID, CreateFileAction.LABEL, element, fileService, notificationService, textFileService) || this;
            _this.editorService = editorService;
            _this._updateEnablement();
            return _this;
        }
        CreateFileAction.prototype.runAction = function (fileName) {
            var _this = this;
            var resource = this.element.parent.resource;
            return this.fileService.createFile(resources.joinPath(resource, fileName)).then(function (stat) {
                return _this.editorService.openEditor({ resource: stat.resource, options: { pinned: true } });
            }, function (error) {
                _this.onErrorWithRetry(error, function () { return _this.runAction(fileName); });
            });
        };
        CreateFileAction.ID = 'workbench.files.action.createFileFromExplorer';
        CreateFileAction.LABEL = nls.localize('createNewFile', "New File");
        CreateFileAction = __decorate([
            __param(1, files_2.IFileService),
            __param(2, editorService_1.IEditorService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService)
        ], CreateFileAction);
        return CreateFileAction;
    }(BaseCreateAction));
    /* Create New Folder (only used internally by explorerViewer) */
    var CreateFolderAction = /** @class */ (function (_super) {
        __extends(CreateFolderAction, _super);
        function CreateFolderAction(element, fileService, notificationService, textFileService) {
            var _this = _super.call(this, CreateFolderAction.ID, CreateFolderAction.LABEL, null, fileService, notificationService, textFileService) || this;
            _this._updateEnablement();
            return _this;
        }
        CreateFolderAction.prototype.runAction = function (fileName) {
            var _this = this;
            var resource = this.element.parent.resource;
            return this.fileService.createFolder(resources.joinPath(resource, fileName)).then(null, function (error) {
                _this.onErrorWithRetry(error, function () { return _this.runAction(fileName); });
            });
        };
        CreateFolderAction.ID = 'workbench.files.action.createFolderFromExplorer';
        CreateFolderAction.LABEL = nls.localize('createNewFolder', "New Folder");
        CreateFolderAction = __decorate([
            __param(1, files_2.IFileService),
            __param(2, notification_1.INotificationService),
            __param(3, textfiles_1.ITextFileService)
        ], CreateFolderAction);
        return CreateFolderAction;
    }(BaseCreateAction));
    var BaseDeleteFileAction = /** @class */ (function (_super) {
        __extends(BaseDeleteFileAction, _super);
        function BaseDeleteFileAction(tree, elements, useTrash, fileService, notificationService, dialogService, textFileService, configurationService) {
            var _this = _super.call(this, 'moveFileToTrash', exports.MOVE_FILE_TO_TRASH_LABEL, fileService, notificationService, textFileService) || this;
            _this.tree = tree;
            _this.elements = elements;
            _this.useTrash = useTrash;
            _this.dialogService = dialogService;
            _this.configurationService = configurationService;
            _this.tree = tree;
            _this.useTrash = useTrash && elements.every(function (e) { return !paths.isUNC(e.resource.fsPath); }); // on UNC shares there is no trash
            _this._updateEnablement();
            return _this;
        }
        BaseDeleteFileAction.prototype._isEnabled = function () {
            return _super.prototype._isEnabled.call(this) && this.elements && this.elements.every(function (e) { return !e.isReadonly; });
        };
        BaseDeleteFileAction.prototype.run = function () {
            var _this = this;
            // Remove highlight
            if (this.tree) {
                this.tree.clearHighlight();
            }
            var primaryButton;
            if (this.useTrash) {
                primaryButton = platform_1.isWindows ? nls.localize('deleteButtonLabelRecycleBin', "&&Move to Recycle Bin") : nls.localize({ key: 'deleteButtonLabelTrash', comment: ['&& denotes a mnemonic'] }, "&&Move to Trash");
            }
            else {
                primaryButton = nls.localize({ key: 'deleteButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Delete");
            }
            var distinctElements = resources.distinctParents(this.elements, function (e) { return e.resource; });
            // Handle dirty
            var confirmDirtyPromise = Promise.resolve(true);
            var dirty = this.textFileService.getDirty().filter(function (d) { return distinctElements.some(function (e) { return resources.isEqualOrParent(d, e.resource, !platform_1.isLinux /* ignorecase */); }); });
            if (dirty.length) {
                var message = void 0;
                if (distinctElements.length > 1) {
                    message = nls.localize('dirtyMessageFilesDelete', "You are deleting files with unsaved changes. Do you want to continue?");
                }
                else if (distinctElements[0].isDirectory) {
                    if (dirty.length === 1) {
                        message = nls.localize('dirtyMessageFolderOneDelete', "You are deleting a folder with unsaved changes in 1 file. Do you want to continue?");
                    }
                    else {
                        message = nls.localize('dirtyMessageFolderDelete', "You are deleting a folder with unsaved changes in {0} files. Do you want to continue?", dirty.length);
                    }
                }
                else {
                    message = nls.localize('dirtyMessageFileDelete', "You are deleting a file with unsaved changes. Do you want to continue?");
                }
                confirmDirtyPromise = this.dialogService.confirm({
                    message: message,
                    type: 'warning',
                    detail: nls.localize('dirtyWarning', "Your changes will be lost if you don't save them."),
                    primaryButton: primaryButton
                }).then(function (res) {
                    if (!res.confirmed) {
                        return false;
                    }
                    _this.skipConfirm = true; // since we already asked for confirmation
                    return _this.textFileService.revertAll(dirty).then(function () { return true; });
                });
            }
            // Check if file is dirty in editor and save it to avoid data loss
            return confirmDirtyPromise.then(function (confirmed) {
                if (!confirmed) {
                    return null;
                }
                var confirmDeletePromise;
                // Check if we need to ask for confirmation at all
                if (_this.skipConfirm || (_this.useTrash && _this.configurationService.getValue(BaseDeleteFileAction.CONFIRM_DELETE_SETTING_KEY) === false)) {
                    confirmDeletePromise = Promise.resolve({ confirmed: true });
                }
                // Confirm for moving to trash
                else if (_this.useTrash) {
                    var message = _this.getMoveToTrashMessage(distinctElements);
                    confirmDeletePromise = _this.dialogService.confirm({
                        message: message,
                        detail: platform_1.isWindows ? nls.localize('undoBin', "You can restore from the Recycle Bin.") : nls.localize('undoTrash', "You can restore from the Trash."),
                        primaryButton: primaryButton,
                        checkbox: {
                            label: nls.localize('doNotAskAgain', "Do not ask me again")
                        },
                        type: 'question'
                    });
                }
                // Confirm for deleting permanently
                else {
                    var message = _this.getDeleteMessage(distinctElements);
                    confirmDeletePromise = _this.dialogService.confirm({
                        message: message,
                        detail: nls.localize('irreversible', "This action is irreversible!"),
                        primaryButton: primaryButton,
                        type: 'warning'
                    });
                }
                return confirmDeletePromise.then(function (confirmation) {
                    // Check for confirmation checkbox
                    var updateConfirmSettingsPromise = Promise.resolve(void 0);
                    if (confirmation.confirmed && confirmation.checkboxChecked === true) {
                        updateConfirmSettingsPromise = _this.configurationService.updateValue(BaseDeleteFileAction.CONFIRM_DELETE_SETTING_KEY, false, 1 /* USER */);
                    }
                    return updateConfirmSettingsPromise.then(function () {
                        // Check for confirmation
                        if (!confirmation.confirmed) {
                            return Promise.resolve(null);
                        }
                        // Call function
                        var servicePromise = Promise.all(distinctElements.map(function (e) { return _this.fileService.del(e.resource, { useTrash: _this.useTrash, recursive: true }); })).then(function () {
                            if (distinctElements[0].parent) {
                                _this.tree.setFocus(distinctElements[0].parent); // move focus to parent
                            }
                        }, function (error) {
                            // Handle error to delete file(s) from a modal confirmation dialog
                            var errorMessage;
                            var detailMessage;
                            var primaryButton;
                            if (_this.useTrash) {
                                errorMessage = platform_1.isWindows ? nls.localize('binFailed', "Failed to delete using the Recycle Bin. Do you want to permanently delete instead?") : nls.localize('trashFailed', "Failed to delete using the Trash. Do you want to permanently delete instead?");
                                detailMessage = nls.localize('irreversible', "This action is irreversible!");
                                primaryButton = nls.localize({ key: 'deletePermanentlyButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Delete Permanently");
                            }
                            else {
                                errorMessage = errorMessage_1.toErrorMessage(error, false);
                                primaryButton = nls.localize({ key: 'retryButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Retry");
                            }
                            return _this.dialogService.confirm({
                                message: errorMessage,
                                detail: detailMessage,
                                type: 'warning',
                                primaryButton: primaryButton
                            }).then(function (res) {
                                // Focus back to tree
                                _this.tree.domFocus();
                                if (res.confirmed) {
                                    if (_this.useTrash) {
                                        _this.useTrash = false; // Delete Permanently
                                    }
                                    _this.skipConfirm = true;
                                    return _this.run();
                                }
                                return Promise.resolve(void 0);
                            });
                        });
                        return servicePromise;
                    });
                });
            });
        };
        BaseDeleteFileAction.prototype.getMoveToTrashMessage = function (distinctElements) {
            if (this.containsBothDirectoryAndFile(distinctElements)) {
                return dialogs_1.getConfirmMessage(nls.localize('confirmMoveTrashMessageFilesAndDirectories', "Are you sure you want to delete the following {0} files/directories and their contents?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
            }
            if (distinctElements.length > 1) {
                if (distinctElements[0].isDirectory) {
                    return dialogs_1.getConfirmMessage(nls.localize('confirmMoveTrashMessageMultipleDirectories', "Are you sure you want to delete the following {0} directories and their contents?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
                }
                return dialogs_1.getConfirmMessage(nls.localize('confirmMoveTrashMessageMultiple', "Are you sure you want to delete the following {0} files?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
            }
            if (distinctElements[0].isDirectory) {
                return nls.localize('confirmMoveTrashMessageFolder', "Are you sure you want to delete '{0}' and its contents?", distinctElements[0].name);
            }
            return nls.localize('confirmMoveTrashMessageFile', "Are you sure you want to delete '{0}'?", distinctElements[0].name);
        };
        BaseDeleteFileAction.prototype.getDeleteMessage = function (distinctElements) {
            if (this.containsBothDirectoryAndFile(distinctElements)) {
                return dialogs_1.getConfirmMessage(nls.localize('confirmDeleteMessageFilesAndDirectories', "Are you sure you want to permanently delete the following {0} files/directories and their contents?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
            }
            if (distinctElements.length > 1) {
                if (distinctElements[0].isDirectory) {
                    return dialogs_1.getConfirmMessage(nls.localize('confirmDeleteMessageMultipleDirectories', "Are you sure you want to permanently delete the following {0} directories and their contents?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
                }
                return dialogs_1.getConfirmMessage(nls.localize('confirmDeleteMessageMultiple', "Are you sure you want to permanently delete the following {0} files?", distinctElements.length), distinctElements.map(function (e) { return e.resource; }));
            }
            if (distinctElements[0].isDirectory) {
                return nls.localize('confirmDeleteMessageFolder', "Are you sure you want to permanently delete '{0}' and its contents?", distinctElements[0].name);
            }
            return nls.localize('confirmDeleteMessageFile', "Are you sure you want to permanently delete '{0}'?", distinctElements[0].name);
        };
        BaseDeleteFileAction.prototype.containsBothDirectoryAndFile = function (distinctElements) {
            var directories = distinctElements.filter(function (element) { return element.isDirectory; });
            var files = distinctElements.filter(function (element) { return !element.isDirectory; });
            return directories.length > 0 && files.length > 0;
        };
        BaseDeleteFileAction.CONFIRM_DELETE_SETTING_KEY = 'explorer.confirmDelete';
        BaseDeleteFileAction = __decorate([
            __param(3, files_2.IFileService),
            __param(4, notification_1.INotificationService),
            __param(5, dialogs_1.IDialogService),
            __param(6, textfiles_1.ITextFileService),
            __param(7, configuration_1.IConfigurationService)
        ], BaseDeleteFileAction);
        return BaseDeleteFileAction;
    }(BaseFileAction));
    /* Add File */
    var AddFilesAction = /** @class */ (function (_super) {
        __extends(AddFilesAction, _super);
        function AddFilesAction(tree, element, clazz, fileService, editorService, dialogService, notificationService, textFileService) {
            var _this = _super.call(this, 'workbench.files.action.addFile', nls.localize('addFiles', "Add Files"), fileService, notificationService, textFileService) || this;
            _this.editorService = editorService;
            _this.dialogService = dialogService;
            _this.tree = tree;
            _this.element = element;
            if (clazz) {
                _this.class = clazz;
            }
            _this._updateEnablement();
            return _this;
        }
        AddFilesAction.prototype.run = function (resourcesToAdd) {
            var _this = this;
            var addPromise = Promise.resolve(null).then(function () {
                if (resourcesToAdd && resourcesToAdd.length > 0) {
                    // Find parent to add to
                    var targetElement_1;
                    if (_this.element) {
                        targetElement_1 = _this.element;
                    }
                    else {
                        var input = _this.tree.getInput();
                        targetElement_1 = _this.tree.getFocus() || (input instanceof explorerModel_1.Model ? input.roots[0] : input);
                    }
                    if (!targetElement_1.isDirectory) {
                        targetElement_1 = targetElement_1.parent;
                    }
                    // Resolve target to check for name collisions and ask user
                    return _this.fileService.resolveFile(targetElement_1.resource).then(function (targetStat) {
                        // Check for name collisions
                        var targetNames = new Set();
                        targetStat.children.forEach(function (child) {
                            targetNames.add(platform_1.isLinux ? child.name : child.name.toLowerCase());
                        });
                        var overwritePromise = Promise.resolve({ confirmed: true });
                        if (resourcesToAdd.some(function (resource) {
                            return targetNames.has(!resources.hasToIgnoreCase(resource) ? resources.basename(resource) : resources.basename(resource).toLowerCase());
                        })) {
                            var confirm_1 = {
                                message: nls.localize('confirmOverwrite', "A file or folder with the same name already exists in the destination folder. Do you want to replace it?"),
                                detail: nls.localize('irreversible', "This action is irreversible!"),
                                primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Replace"),
                                type: 'warning'
                            };
                            overwritePromise = _this.dialogService.confirm(confirm_1);
                        }
                        return overwritePromise.then(function (res) {
                            if (!res.confirmed) {
                                return void 0;
                            }
                            // Run add in sequence
                            var addPromisesFactory = [];
                            resourcesToAdd.forEach(function (resource) {
                                addPromisesFactory.push(function () {
                                    var sourceFile = resource;
                                    var targetFile = resources.joinPath(targetElement_1.resource, resources.basename(sourceFile));
                                    // if the target exists and is dirty, make sure to revert it. otherwise the dirty contents
                                    // of the target file would replace the contents of the added file. since we already
                                    // confirmed the overwrite before, this is OK.
                                    var revertPromise = Promise.resolve(null);
                                    if (_this.textFileService.isDirty(targetFile)) {
                                        revertPromise = _this.textFileService.revertAll([targetFile], { soft: true });
                                    }
                                    return revertPromise.then(function () {
                                        var target = resources.joinPath(targetElement_1.resource, resources.basename(sourceFile));
                                        return _this.fileService.copyFile(sourceFile, target, true).then(function (stat) {
                                            // if we only add one file, just open it directly
                                            if (resourcesToAdd.length === 1) {
                                                _this.editorService.openEditor({ resource: stat.resource, options: { pinned: true } });
                                            }
                                        }, function (error) { return _this.onError(error); });
                                    });
                                });
                            });
                            return async_1.sequence(addPromisesFactory);
                        });
                    });
                }
                return void 0;
            });
            return addPromise.then(function () {
                _this.tree.clearHighlight();
            }, function (error) {
                _this.onError(error);
                _this.tree.clearHighlight();
            });
        };
        AddFilesAction = __decorate([
            __param(3, files_2.IFileService),
            __param(4, editorService_1.IEditorService),
            __param(5, dialogs_1.IDialogService),
            __param(6, notification_1.INotificationService),
            __param(7, textfiles_1.ITextFileService)
        ], AddFilesAction);
        return AddFilesAction;
    }(BaseFileAction));
    exports.AddFilesAction = AddFilesAction;
    // Copy File/Folder
    var CopyFileAction = /** @class */ (function (_super) {
        __extends(CopyFileAction, _super);
        function CopyFileAction(tree, elements, fileService, notificationService, textFileService, contextKeyService, clipboardService) {
            var _this = _super.call(this, 'filesExplorer.copy', exports.COPY_FILE_LABEL, fileService, notificationService, textFileService) || this;
            _this.elements = elements;
            _this.clipboardService = clipboardService;
            _this.tree = tree;
            _this._updateEnablement();
            return _this;
        }
        CopyFileAction.prototype.run = function () {
            // Write to clipboard as file/folder to copy
            this.clipboardService.writeResources(this.elements.map(function (e) { return e.resource; }));
            // Remove highlight
            if (this.tree) {
                this.tree.clearHighlight();
            }
            this.tree.domFocus();
            return Promise.resolve(null);
        };
        CopyFileAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, contextkey_1.IContextKeyService),
            __param(6, clipboardService_1.IClipboardService)
        ], CopyFileAction);
        return CopyFileAction;
    }(BaseFileAction));
    // Paste File/Folder
    var PasteFileAction = /** @class */ (function (_super) {
        __extends(PasteFileAction, _super);
        function PasteFileAction(tree, element, fileService, notificationService, textFileService, editorService) {
            var _this = _super.call(this, PasteFileAction.ID, exports.PASTE_FILE_LABEL, fileService, notificationService, textFileService) || this;
            _this.editorService = editorService;
            _this.tree = tree;
            _this.element = element;
            if (!_this.element) {
                var input = _this.tree.getInput();
                _this.element = input instanceof explorerModel_1.Model ? input.roots[0] : input;
            }
            _this._updateEnablement();
            return _this;
        }
        PasteFileAction.prototype.run = function (fileToPaste) {
            var _this = this;
            // Check if target is ancestor of pasted folder
            if (this.element.resource.toString() !== fileToPaste.toString() && resources.isEqualOrParent(this.element.resource, fileToPaste, !platform_1.isLinux /* ignorecase */)) {
                throw new Error(nls.localize('fileIsAncestor', "File to paste is an ancestor of the destination folder"));
            }
            return this.fileService.resolveFile(fileToPaste).then(function (fileToPasteStat) {
                // Remove highlight
                if (_this.tree) {
                    _this.tree.clearHighlight();
                }
                // Find target
                var target;
                if (_this.element.resource.toString() === fileToPaste.toString()) {
                    target = _this.element.parent;
                }
                else {
                    target = _this.element.isDirectory ? _this.element : _this.element.parent;
                }
                var targetFile = findValidPasteFileTarget(target, { resource: fileToPaste, isDirectory: fileToPasteStat.isDirectory });
                // Copy File
                return _this.fileService.copyFile(fileToPaste, targetFile).then(function (stat) {
                    if (!stat.isDirectory) {
                        return _this.editorService.openEditor({ resource: stat.resource, options: { pinned: true } });
                    }
                    return void 0;
                }, function (error) { return _this.onError(error); }).then(function () {
                    _this.tree.domFocus();
                });
            }, function (error) {
                _this.onError(new Error(nls.localize('fileDeleted', "File to paste was deleted or moved meanwhile")));
            });
        };
        PasteFileAction.ID = 'filesExplorer.paste';
        PasteFileAction = __decorate([
            __param(2, files_2.IFileService),
            __param(3, notification_1.INotificationService),
            __param(4, textfiles_1.ITextFileService),
            __param(5, editorService_1.IEditorService)
        ], PasteFileAction);
        return PasteFileAction;
    }(BaseFileAction));
    // Duplicate File/Folder
    var DuplicateFileAction = /** @class */ (function (_super) {
        __extends(DuplicateFileAction, _super);
        function DuplicateFileAction(tree, fileToDuplicate, target, fileService, editorService, notificationService, textFileService) {
            var _this = _super.call(this, 'workbench.files.action.duplicateFile', nls.localize('duplicateFile', "Duplicate"), fileService, notificationService, textFileService) || this;
            _this.editorService = editorService;
            _this.tree = tree;
            _this.element = fileToDuplicate;
            _this.target = (target && target.isDirectory) ? target : fileToDuplicate.parent;
            _this._updateEnablement();
            return _this;
        }
        DuplicateFileAction.prototype.run = function () {
            var _this = this;
            // Remove highlight
            if (this.tree) {
                this.tree.clearHighlight();
            }
            // Copy File
            var result = this.fileService.copyFile(this.element.resource, findValidPasteFileTarget(this.target, { resource: this.element.resource, isDirectory: this.element.isDirectory })).then(function (stat) {
                if (!stat.isDirectory) {
                    return _this.editorService.openEditor({ resource: stat.resource, options: { pinned: true } });
                }
                return void 0;
            }, function (error) { return _this.onError(error); });
            return result;
        };
        DuplicateFileAction = __decorate([
            __param(3, files_2.IFileService),
            __param(4, editorService_1.IEditorService),
            __param(5, notification_1.INotificationService),
            __param(6, textfiles_1.ITextFileService)
        ], DuplicateFileAction);
        return DuplicateFileAction;
    }(BaseFileAction));
    exports.DuplicateFileAction = DuplicateFileAction;
    function findValidPasteFileTarget(targetFolder, fileToPaste) {
        var name = resources.basenameOrAuthority(fileToPaste.resource);
        var candidate = resources.joinPath(targetFolder.resource, name);
        while (true) {
            if (!targetFolder.root.find(candidate)) {
                break;
            }
            name = incrementFileName(name, fileToPaste.isDirectory);
            candidate = resources.joinPath(targetFolder.resource, name);
        }
        return candidate;
    }
    function incrementFileName(name, isFolder) {
        var separators = '[\\.\\-_]';
        var maxNumber = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        // file.1.txt=>file.2.txt
        var suffixFileRegex = RegExp('(.*' + separators + ')(\\d+)(\\..*)$');
        if (!isFolder && name.match(suffixFileRegex)) {
            return name.replace(suffixFileRegex, function (match, g1, g2, g3) {
                var number = parseInt(g2);
                return number < maxNumber
                    ? g1 + strings.pad(number + 1, g2.length) + g3
                    : strings.format('{0}{1}.1{2}', g1, g2, g3);
            });
        }
        // 1.file.txt=>2.file.txt
        var prefixFileRegex = RegExp('(\\d+)(' + separators + '.*)(\\..*)$');
        if (!isFolder && name.match(prefixFileRegex)) {
            return name.replace(prefixFileRegex, function (match, g1, g2, g3) {
                var number = parseInt(g1);
                return number < maxNumber
                    ? strings.pad(number + 1, g1.length) + g2 + g3
                    : strings.format('{0}{1}.1{2}', g1, g2, g3);
            });
        }
        // 1.txt=>2.txt
        var prefixFileNoNameRegex = RegExp('(\\d+)(\\..*)$');
        if (!isFolder && name.match(prefixFileNoNameRegex)) {
            return name.replace(prefixFileNoNameRegex, function (match, g1, g2) {
                var number = parseInt(g1);
                return number < maxNumber
                    ? strings.pad(number + 1, g1.length) + g2
                    : strings.format('{0}.1{1}', g1, g2);
            });
        }
        // file.txt=>file.1.txt
        var lastIndexOfDot = name.lastIndexOf('.');
        if (!isFolder && lastIndexOfDot >= 0) {
            return strings.format('{0}.1{1}', name.substr(0, lastIndexOfDot), name.substr(lastIndexOfDot));
        }
        // folder.1=>folder.2
        if (isFolder && name.match(/(\d+)$/)) {
            return name.replace(/(\d+)$/, function (match) {
                var groups = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    groups[_i - 1] = arguments[_i];
                }
                var number = parseInt(groups[0]);
                return number < maxNumber
                    ? strings.pad(number + 1, groups[0].length)
                    : strings.format('{0}.1', groups[0]);
            });
        }
        // 1.folder=>2.folder
        if (isFolder && name.match(/^(\d+)/)) {
            return name.replace(/^(\d+)(.*)$/, function (match) {
                var groups = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    groups[_i - 1] = arguments[_i];
                }
                var number = parseInt(groups[0]);
                return number < maxNumber
                    ? strings.pad(number + 1, groups[0].length) + groups[1]
                    : strings.format('{0}{1}.1', groups[0], groups[1]);
            });
        }
        // file/folder=>file.1/folder.1
        return strings.format('{0}.1', name);
    }
    exports.incrementFileName = incrementFileName;
    // Global Compare with
    var GlobalCompareResourcesAction = /** @class */ (function (_super) {
        __extends(GlobalCompareResourcesAction, _super);
        function GlobalCompareResourcesAction(id, label, quickOpenService, editorService, notificationService) {
            var _this = _super.call(this, id, label) || this;
            _this.quickOpenService = quickOpenService;
            _this.editorService = editorService;
            _this.notificationService = notificationService;
            return _this;
        }
        GlobalCompareResourcesAction.prototype.run = function () {
            var _this = this;
            var activeInput = this.editorService.activeEditor;
            var activeResource = activeInput ? activeInput.getResource() : void 0;
            if (activeResource) {
                // Compare with next editor that opens
                var toDispose_1 = this.editorService.overrideOpenEditor(function (editor, options, group) {
                    // Only once!
                    toDispose_1.dispose();
                    // Open editor as diff
                    var resource = editor.getResource();
                    if (resource) {
                        return {
                            override: _this.editorService.openEditor({
                                leftResource: activeResource,
                                rightResource: resource
                            }).then(function () { return void 0; })
                        };
                    }
                    return void 0;
                });
                // Bring up quick open
                this.quickOpenService.show('', { autoFocus: { autoFocusSecondEntry: true } }).then(function () {
                    toDispose_1.dispose(); // make sure to unbind if quick open is closing
                });
            }
            else {
                this.notificationService.info(nls.localize('openFileToCompare', "Open a file first to compare it with another file."));
            }
            return Promise.resolve(true);
        };
        GlobalCompareResourcesAction.ID = 'workbench.files.action.compareFileWith';
        GlobalCompareResourcesAction.LABEL = nls.localize('globalCompareFile', "Compare Active File With...");
        GlobalCompareResourcesAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, editorService_1.IEditorService),
            __param(4, notification_1.INotificationService)
        ], GlobalCompareResourcesAction);
        return GlobalCompareResourcesAction;
    }(actions_1.Action));
    exports.GlobalCompareResourcesAction = GlobalCompareResourcesAction;
    // Refresh Explorer Viewer
    var RefreshViewExplorerAction = /** @class */ (function (_super) {
        __extends(RefreshViewExplorerAction, _super);
        function RefreshViewExplorerAction(explorerView, clazz) {
            return _super.call(this, 'workbench.files.action.refreshFilesExplorer', nls.localize('refresh', "Refresh"), clazz, true, function (context) { return explorerView.refresh(); }) || this;
        }
        return RefreshViewExplorerAction;
    }(actions_1.Action));
    exports.RefreshViewExplorerAction = RefreshViewExplorerAction;
    var ToggleAutoSaveAction = /** @class */ (function (_super) {
        __extends(ToggleAutoSaveAction, _super);
        function ToggleAutoSaveAction(id, label, configurationService) {
            var _this = _super.call(this, id, label) || this;
            _this.configurationService = configurationService;
            return _this;
        }
        ToggleAutoSaveAction.prototype.run = function () {
            var setting = this.configurationService.inspect('files.autoSave');
            var userAutoSaveConfig = setting.user;
            if (types.isUndefinedOrNull(userAutoSaveConfig)) {
                userAutoSaveConfig = setting.default; // use default if setting not defined
            }
            var newAutoSaveValue;
            if ([files_2.AutoSaveConfiguration.AFTER_DELAY, files_2.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_2.AutoSaveConfiguration.ON_WINDOW_CHANGE].some(function (s) { return s === userAutoSaveConfig; })) {
                newAutoSaveValue = files_2.AutoSaveConfiguration.OFF;
            }
            else {
                newAutoSaveValue = files_2.AutoSaveConfiguration.AFTER_DELAY;
            }
            return this.configurationService.updateValue('files.autoSave', newAutoSaveValue, 1 /* USER */);
        };
        ToggleAutoSaveAction.ID = 'workbench.action.toggleAutoSave';
        ToggleAutoSaveAction.LABEL = nls.localize('toggleAutoSave', "Toggle Auto Save");
        ToggleAutoSaveAction = __decorate([
            __param(2, configuration_1.IConfigurationService)
        ], ToggleAutoSaveAction);
        return ToggleAutoSaveAction;
    }(actions_1.Action));
    exports.ToggleAutoSaveAction = ToggleAutoSaveAction;
    var BaseSaveAllAction = /** @class */ (function (_super) {
        __extends(BaseSaveAllAction, _super);
        function BaseSaveAllAction(id, label, textFileService, untitledEditorService, commandService, notificationService) {
            var _this = _super.call(this, id, label, notificationService) || this;
            _this.textFileService = textFileService;
            _this.untitledEditorService = untitledEditorService;
            _this.commandService = commandService;
            _this.toDispose = [];
            _this.lastIsDirty = _this.textFileService.isDirty();
            _this.enabled = _this.lastIsDirty;
            _this.registerListeners();
            return _this;
        }
        BaseSaveAllAction.prototype.registerListeners = function () {
            var _this = this;
            // listen to files being changed locally
            this.toDispose.push(this.textFileService.models.onModelsDirty(function (e) { return _this.updateEnablement(true); }));
            this.toDispose.push(this.textFileService.models.onModelsSaved(function (e) { return _this.updateEnablement(false); }));
            this.toDispose.push(this.textFileService.models.onModelsReverted(function (e) { return _this.updateEnablement(false); }));
            this.toDispose.push(this.textFileService.models.onModelsSaveError(function (e) { return _this.updateEnablement(true); }));
            if (this.includeUntitled()) {
                this.toDispose.push(this.untitledEditorService.onDidChangeDirty(function (resource) { return _this.updateEnablement(_this.untitledEditorService.isDirty(resource)); }));
            }
        };
        BaseSaveAllAction.prototype.updateEnablement = function (isDirty) {
            if (this.lastIsDirty !== isDirty) {
                this.enabled = this.textFileService.isDirty();
                this.lastIsDirty = this.enabled;
            }
        };
        BaseSaveAllAction.prototype.run = function (context) {
            var _this = this;
            return this.doRun(context).then(function () { return true; }, function (error) {
                _this.onError(error);
                return null;
            });
        };
        BaseSaveAllAction.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            _super.prototype.dispose.call(this);
        };
        BaseSaveAllAction = __decorate([
            __param(2, textfiles_1.ITextFileService),
            __param(3, untitledEditorService_1.IUntitledEditorService),
            __param(4, commands_1.ICommandService),
            __param(5, notification_1.INotificationService)
        ], BaseSaveAllAction);
        return BaseSaveAllAction;
    }(BaseErrorReportingAction));
    exports.BaseSaveAllAction = BaseSaveAllAction;
    var SaveAllAction = /** @class */ (function (_super) {
        __extends(SaveAllAction, _super);
        function SaveAllAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(SaveAllAction.prototype, "class", {
            get: function () {
                return 'explorer-action save-all';
            },
            enumerable: true,
            configurable: true
        });
        SaveAllAction.prototype.doRun = function (context) {
            return this.commandService.executeCommand(fileCommands_1.SAVE_ALL_COMMAND_ID);
        };
        SaveAllAction.prototype.includeUntitled = function () {
            return true;
        };
        SaveAllAction.ID = 'workbench.action.files.saveAll';
        SaveAllAction.LABEL = fileCommands_1.SAVE_ALL_LABEL;
        return SaveAllAction;
    }(BaseSaveAllAction));
    exports.SaveAllAction = SaveAllAction;
    var SaveAllInGroupAction = /** @class */ (function (_super) {
        __extends(SaveAllInGroupAction, _super);
        function SaveAllInGroupAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(SaveAllInGroupAction.prototype, "class", {
            get: function () {
                return 'explorer-action save-all';
            },
            enumerable: true,
            configurable: true
        });
        SaveAllInGroupAction.prototype.doRun = function (context) {
            return this.commandService.executeCommand(fileCommands_1.SAVE_ALL_IN_GROUP_COMMAND_ID, {}, context);
        };
        SaveAllInGroupAction.prototype.includeUntitled = function () {
            return true;
        };
        SaveAllInGroupAction.ID = 'workbench.files.action.saveAllInGroup';
        SaveAllInGroupAction.LABEL = nls.localize('saveAllInGroup', "Save All in Group");
        return SaveAllInGroupAction;
    }(BaseSaveAllAction));
    exports.SaveAllInGroupAction = SaveAllInGroupAction;
    var CloseGroupAction = /** @class */ (function (_super) {
        __extends(CloseGroupAction, _super);
        function CloseGroupAction(id, label, commandService) {
            var _this = _super.call(this, id, label, 'action-close-all-files') || this;
            _this.commandService = commandService;
            return _this;
        }
        CloseGroupAction.prototype.run = function (context) {
            return this.commandService.executeCommand(editorCommands_1.CLOSE_EDITORS_AND_GROUP_COMMAND_ID, {}, context);
        };
        CloseGroupAction.ID = 'workbench.files.action.closeGroup';
        CloseGroupAction.LABEL = nls.localize('closeGroup', "Close Group");
        CloseGroupAction = __decorate([
            __param(2, commands_1.ICommandService)
        ], CloseGroupAction);
        return CloseGroupAction;
    }(actions_1.Action));
    exports.CloseGroupAction = CloseGroupAction;
    var FocusFilesExplorer = /** @class */ (function (_super) {
        __extends(FocusFilesExplorer, _super);
        function FocusFilesExplorer(id, label, viewletService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            return _this;
        }
        FocusFilesExplorer.prototype.run = function () {
            return this.viewletService.openViewlet(files_1.VIEWLET_ID, true).then(function (viewlet) {
                var view = viewlet.getExplorerView();
                if (view) {
                    view.setExpanded(true);
                    view.getViewer().domFocus();
                }
            });
        };
        FocusFilesExplorer.ID = 'workbench.files.action.focusFilesExplorer';
        FocusFilesExplorer.LABEL = nls.localize('focusFilesExplorer', "Focus on Files Explorer");
        FocusFilesExplorer = __decorate([
            __param(2, viewlet_2.IViewletService)
        ], FocusFilesExplorer);
        return FocusFilesExplorer;
    }(actions_1.Action));
    exports.FocusFilesExplorer = FocusFilesExplorer;
    var ShowActiveFileInExplorer = /** @class */ (function (_super) {
        __extends(ShowActiveFileInExplorer, _super);
        function ShowActiveFileInExplorer(id, label, editorService, notificationService, commandService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            _this.notificationService = notificationService;
            _this.commandService = commandService;
            return _this;
        }
        ShowActiveFileInExplorer.prototype.run = function () {
            var resource = editor_1.toResource(this.editorService.activeEditor, { supportSideBySide: true });
            if (resource) {
                this.commandService.executeCommand(fileCommands_1.REVEAL_IN_EXPLORER_COMMAND_ID, resource);
            }
            else {
                this.notificationService.info(nls.localize('openFileToShow', "Open a file first to show it in the explorer"));
            }
            return Promise.resolve(true);
        };
        ShowActiveFileInExplorer.ID = 'workbench.files.action.showActiveFileInExplorer';
        ShowActiveFileInExplorer.LABEL = nls.localize('showInExplorer', "Reveal Active File in Side Bar");
        ShowActiveFileInExplorer = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, notification_1.INotificationService),
            __param(4, commands_1.ICommandService)
        ], ShowActiveFileInExplorer);
        return ShowActiveFileInExplorer;
    }(actions_1.Action));
    exports.ShowActiveFileInExplorer = ShowActiveFileInExplorer;
    var CollapseExplorerView = /** @class */ (function (_super) {
        __extends(CollapseExplorerView, _super);
        function CollapseExplorerView(id, label, viewletService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            return _this;
        }
        CollapseExplorerView.prototype.run = function () {
            return this.viewletService.openViewlet(files_1.VIEWLET_ID, true).then(function (viewlet) {
                var explorerView = viewlet.getExplorerView();
                if (explorerView) {
                    var viewer = explorerView.getViewer();
                    if (viewer) {
                        var action = new viewlet_1.CollapseAction(viewer, true, null);
                        action.run();
                        action.dispose();
                    }
                }
            });
        };
        CollapseExplorerView.ID = 'workbench.files.action.collapseExplorerFolders';
        CollapseExplorerView.LABEL = nls.localize('collapseExplorerFolders', "Collapse Folders in Explorer");
        CollapseExplorerView = __decorate([
            __param(2, viewlet_2.IViewletService)
        ], CollapseExplorerView);
        return CollapseExplorerView;
    }(actions_1.Action));
    exports.CollapseExplorerView = CollapseExplorerView;
    var RefreshExplorerView = /** @class */ (function (_super) {
        __extends(RefreshExplorerView, _super);
        function RefreshExplorerView(id, label, viewletService) {
            var _this = _super.call(this, id, label) || this;
            _this.viewletService = viewletService;
            return _this;
        }
        RefreshExplorerView.prototype.run = function () {
            return this.viewletService.openViewlet(files_1.VIEWLET_ID, true).then(function (viewlet) {
                var explorerView = viewlet.getExplorerView();
                if (explorerView) {
                    explorerView.refresh();
                }
            });
        };
        RefreshExplorerView.ID = 'workbench.files.action.refreshFilesExplorer';
        RefreshExplorerView.LABEL = nls.localize('refreshExplorer', "Refresh Explorer");
        RefreshExplorerView = __decorate([
            __param(2, viewlet_2.IViewletService)
        ], RefreshExplorerView);
        return RefreshExplorerView;
    }(actions_1.Action));
    exports.RefreshExplorerView = RefreshExplorerView;
    var ShowOpenedFileInNewWindow = /** @class */ (function (_super) {
        __extends(ShowOpenedFileInNewWindow, _super);
        function ShowOpenedFileInNewWindow(id, label, editorService, windowService, notificationService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            _this.windowService = windowService;
            _this.notificationService = notificationService;
            return _this;
        }
        ShowOpenedFileInNewWindow.prototype.run = function () {
            var fileResource = editor_1.toResource(this.editorService.activeEditor, { supportSideBySide: true, filter: network_1.Schemas.file /* todo@remote */ });
            if (fileResource) {
                this.windowService.openWindow([fileResource], { forceNewWindow: true, forceOpenWorkspaceAsFile: true });
            }
            else {
                this.notificationService.info(nls.localize('openFileToShowInNewWindow', "Open a file first to open in new window"));
            }
            return Promise.resolve(true);
        };
        ShowOpenedFileInNewWindow.ID = 'workbench.action.files.showOpenedFileInNewWindow';
        ShowOpenedFileInNewWindow.LABEL = nls.localize('openFileInNewWindow', "Open Active File in New Window");
        ShowOpenedFileInNewWindow = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, windows_1.IWindowService),
            __param(4, notification_1.INotificationService)
        ], ShowOpenedFileInNewWindow);
        return ShowOpenedFileInNewWindow;
    }(actions_1.Action));
    exports.ShowOpenedFileInNewWindow = ShowOpenedFileInNewWindow;
    function validateFileName(parent, name) {
        // Produce a well formed file name
        name = getWellFormedFileName(name);
        // Name not provided
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return nls.localize('emptyFileNameError', "A file or folder name must be provided.");
        }
        // Relative paths only
        if (name[0] === '/' || name[0] === '\\') {
            return nls.localize('fileNameStartsWithSlashError', "A file or folder name cannot start with a slash.");
        }
        var names = name.split(/[\\/]/).filter(function (part) { return !!part; });
        // Do not allow to overwrite existing file
        var childExists = !!parent.getChild(name);
        if (childExists) {
            return nls.localize('fileNameExistsError', "A file or folder **{0}** already exists at this location. Please choose a different name.", name);
        }
        // Invalid File name
        if (names.some(function (folderName) { return !paths.isValidBasename(folderName); })) {
            return nls.localize('invalidFileNameError', "The name **{0}** is not valid as a file or folder name. Please choose a different name.", trimLongName(name));
        }
        // Max length restriction (on Windows)
        if (platform_1.isWindows) {
            var fullPathLength = name.length + parent.resource.fsPath.length + 1 /* path segment */;
            if (fullPathLength > 255) {
                return nls.localize('filePathTooLongError', "The name **{0}** results in a path that is too long. Please choose a shorter name.", trimLongName(name));
            }
        }
        return null;
    }
    exports.validateFileName = validateFileName;
    function trimLongName(name) {
        if (name && name.length > 255) {
            return name.substr(0, 255) + "...";
        }
        return name;
    }
    function getWellFormedFileName(filename) {
        if (!filename) {
            return filename;
        }
        // Trim tabs
        filename = strings.trim(filename, '\t');
        // Remove trailing dots, slashes, and spaces
        filename = strings.rtrim(filename, '.');
        filename = strings.rtrim(filename, '/');
        filename = strings.rtrim(filename, '\\');
        return filename;
    }
    exports.getWellFormedFileName = getWellFormedFileName;
    var CompareWithClipboardAction = /** @class */ (function (_super) {
        __extends(CompareWithClipboardAction, _super);
        function CompareWithClipboardAction(id, label, editorService, instantiationService, textModelService, fileService) {
            var _this = _super.call(this, id, label) || this;
            _this.editorService = editorService;
            _this.instantiationService = instantiationService;
            _this.textModelService = textModelService;
            _this.fileService = fileService;
            _this.enabled = true;
            return _this;
        }
        CompareWithClipboardAction.prototype.run = function () {
            var _this = this;
            var resource = editor_1.toResource(this.editorService.activeEditor, { supportSideBySide: true });
            if (resource && (this.fileService.canHandleResource(resource) || resource.scheme === network_1.Schemas.untitled)) {
                if (!this.registrationDisposal) {
                    var provider = this.instantiationService.createInstance(ClipboardContentProvider);
                    this.registrationDisposal = this.textModelService.registerTextModelContentProvider(CompareWithClipboardAction.SCHEME, provider);
                }
                var name_1 = resources.basename(resource);
                var editorLabel = nls.localize('clipboardComparisonLabel', "Clipboard  {0}", name_1);
                var cleanUp = function () {
                    _this.registrationDisposal = lifecycle_1.dispose(_this.registrationDisposal);
                };
                return async_1.always(this.editorService.openEditor({ leftResource: resource.with({ scheme: CompareWithClipboardAction.SCHEME }), rightResource: resource, label: editorLabel }), cleanUp);
            }
            return Promise.resolve(true);
        };
        CompareWithClipboardAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.registrationDisposal = lifecycle_1.dispose(this.registrationDisposal);
        };
        CompareWithClipboardAction.ID = 'workbench.files.action.compareWithClipboard';
        CompareWithClipboardAction.LABEL = nls.localize('compareWithClipboard', "Compare Active File with Clipboard");
        CompareWithClipboardAction.SCHEME = 'clipboardCompare';
        CompareWithClipboardAction = __decorate([
            __param(2, editorService_1.IEditorService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, resolverService_1.ITextModelService),
            __param(5, files_2.IFileService)
        ], CompareWithClipboardAction);
        return CompareWithClipboardAction;
    }(actions_1.Action));
    exports.CompareWithClipboardAction = CompareWithClipboardAction;
    var ClipboardContentProvider = /** @class */ (function () {
        function ClipboardContentProvider(clipboardService, modeService, modelService) {
            this.clipboardService = clipboardService;
            this.modeService = modeService;
            this.modelService = modelService;
        }
        ClipboardContentProvider.prototype.provideTextContent = function (resource) {
            var model = this.modelService.createModel(this.clipboardService.readText(), this.modeService.getOrCreateMode('text/plain'), resource);
            return Promise.resolve(model);
        };
        ClipboardContentProvider = __decorate([
            __param(0, clipboardService_1.IClipboardService),
            __param(1, modeService_1.IModeService),
            __param(2, modelService_1.IModelService)
        ], ClipboardContentProvider);
        return ClipboardContentProvider;
    }());
    function getContext(listWidget, viewletService) {
        // These commands can only be triggered when explorer viewlet is visible so get it using the active viewlet
        var tree = listWidget;
        var stat = tree.getFocus();
        var selection = tree.getSelection();
        // Only respect the selection if user clicked inside it (focus belongs to it)
        return { stat: stat, selection: selection && selection.indexOf(stat) >= 0 ? selection : [], viewletState: viewletService.getActiveViewlet().getViewletState() };
    }
    // TODO@isidor these commands are calling into actions due to the complex inheritance action structure.
    // It should be the other way around, that actions call into commands.
    function openExplorerAndRunAction(accessor, constructor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var viewletService = accessor.get(viewlet_2.IViewletService);
        var activeViewlet = viewletService.getActiveViewlet();
        var explorerPromise = Promise.resolve(activeViewlet);
        if (!activeViewlet || activeViewlet.getId() !== files_1.VIEWLET_ID) {
            explorerPromise = viewletService.openViewlet(files_1.VIEWLET_ID, true);
        }
        return explorerPromise.then(function (explorer) {
            var explorerView = explorer.getExplorerView();
            if (explorerView && explorerView.isVisible() && explorerView.isExpanded()) {
                explorerView.focus();
                var explorerContext = getContext(listService.lastFocusedList, viewletService);
                var action = instantationService.createInstance(constructor, listService.lastFocusedList, explorerContext.stat);
                return action.run(explorerContext);
            }
            return undefined;
        });
    }
    commands_1.CommandsRegistry.registerCommand({
        id: exports.NEW_FILE_COMMAND_ID,
        handler: function (accessor) {
            return openExplorerAndRunAction(accessor, NewFileAction);
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: exports.NEW_FOLDER_COMMAND_ID,
        handler: function (accessor) {
            return openExplorerAndRunAction(accessor, NewFolderAction);
        }
    });
    exports.renameHandler = function (accessor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var explorerContext = getContext(listService.lastFocusedList, accessor.get(viewlet_2.IViewletService));
        var renameAction = instantationService.createInstance(TriggerRenameFileAction, listService.lastFocusedList, explorerContext.stat);
        return renameAction.run(explorerContext);
    };
    exports.moveFileToTrashHandler = function (accessor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var explorerContext = getContext(listService.lastFocusedList, accessor.get(viewlet_2.IViewletService));
        var stats = explorerContext.selection.length > 1 ? explorerContext.selection : [explorerContext.stat];
        var moveFileToTrashAction = instantationService.createInstance(BaseDeleteFileAction, listService.lastFocusedList, stats, true);
        return moveFileToTrashAction.run();
    };
    exports.deleteFileHandler = function (accessor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var explorerContext = getContext(listService.lastFocusedList, accessor.get(viewlet_2.IViewletService));
        var stats = explorerContext.selection.length > 1 ? explorerContext.selection : [explorerContext.stat];
        var deleteFileAction = instantationService.createInstance(BaseDeleteFileAction, listService.lastFocusedList, stats, false);
        return deleteFileAction.run();
    };
    exports.copyFileHandler = function (accessor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var explorerContext = getContext(listService.lastFocusedList, accessor.get(viewlet_2.IViewletService));
        var stats = explorerContext.selection.length > 1 ? explorerContext.selection : [explorerContext.stat];
        var copyFileAction = instantationService.createInstance(CopyFileAction, listService.lastFocusedList, stats);
        return copyFileAction.run();
    };
    exports.pasteFileHandler = function (accessor) {
        var instantationService = accessor.get(instantiation_1.IInstantiationService);
        var listService = accessor.get(listService_1.IListService);
        var clipboardService = accessor.get(clipboardService_1.IClipboardService);
        var explorerContext = getContext(listService.lastFocusedList, accessor.get(viewlet_2.IViewletService));
        return Promise.all(resources.distinctParents(clipboardService.readResources(), function (r) { return r; }).map(function (toCopy) {
            var pasteFileAction = instantationService.createInstance(PasteFileAction, listService.lastFocusedList, explorerContext.stat);
            return pasteFileAction.run(toCopy);
        }));
    };
});























define(__m[276/*vs/workbench/parts/files/electron-browser/saveErrorHandler*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,98/*vs/base/common/errorMessage*/,24/*vs/base/common/paths*/,15/*vs/base/common/actions*/,12/*vs/base/common/uri*/,27/*vs/workbench/services/textfile/common/textfiles*/,3/*vs/platform/instantiation/common/instantiation*/,4/*vs/base/common/lifecycle*/,123/*vs/workbench/services/textfile/common/textFileEditorModel*/,66/*vs/editor/common/services/resolverService*/,39/*vs/base/common/map*/,110/*vs/workbench/common/editor/diffEditorInput*/,93/*vs/workbench/common/editor/resourceEditorInput*/,10/*vs/platform/contextkey/common/contextkey*/,57/*vs/workbench/parts/files/common/files*/,125/*vs/workbench/parts/files/common/editors/fileEditorInput*/,36/*vs/editor/common/services/modelService*/,150/*vs/workbench/parts/files/electron-browser/fileCommands*/,73/*vs/editor/common/model/textModel*/,28/*vs/platform/notification/common/notification*/,138/*vs/platform/opener/common/opener*/,44/*vs/platform/storage/common/storage*/,23/*vs/platform/actions/common/actions*/,43/*vs/platform/environment/common/environment*/,6/*vs/base/common/event*/,11/*vs/workbench/services/editor/common/editorService*/]), function (require, exports, nls, errorMessage_1, paths, actions_1, uri_1, textfiles_1, instantiation_1, lifecycle_1, textFileEditorModel_1, resolverService_1, map_1, diffEditorInput_1, resourceEditorInput_1, contextkey_1, files_1, fileEditorInput_1, modelService_1, fileCommands_1, textModel_1, notification_1, opener_1, storage_1, actions_2, environment_1, event_1, editorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CONFLICT_RESOLUTION_CONTEXT = 'saveConflictResolutionContext';
    exports.CONFLICT_RESOLUTION_SCHEME = 'conflictResolution';
    var LEARN_MORE_DIRTY_WRITE_IGNORE_KEY = 'learnMoreDirtyWriteError';
    var conflictEditorHelp = nls.localize('userGuide', "Use the actions in the editor tool bar to either undo your changes or overwrite the content on disk with your changes.");
    // A handler for save error happening with conflict resolution actions
    var SaveErrorHandler = /** @class */ (function (_super) {
        __extends(SaveErrorHandler, _super);
        function SaveErrorHandler(notificationService, textFileService, contextKeyService, editorService, textModelService, instantiationService, storageService) {
            var _this = _super.call(this) || this;
            _this.notificationService = notificationService;
            _this.textFileService = textFileService;
            _this.editorService = editorService;
            _this.instantiationService = instantiationService;
            _this.storageService = storageService;
            _this.messages = new map_1.ResourceMap();
            _this.conflictResolutionContext = new contextkey_1.RawContextKey(exports.CONFLICT_RESOLUTION_CONTEXT, false).bindTo(contextKeyService);
            var provider = _this._register(instantiationService.createInstance(files_1.FileOnDiskContentProvider));
            _this._register(textModelService.registerTextModelContentProvider(exports.CONFLICT_RESOLUTION_SCHEME, provider));
            // Hook into model
            textFileEditorModel_1.TextFileEditorModel.setSaveErrorHandler(_this);
            _this.registerListeners();
            return _this;
        }
        SaveErrorHandler.prototype.registerListeners = function () {
            var _this = this;
            this._register(this.textFileService.models.onModelSaved(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
            this._register(this.textFileService.models.onModelReverted(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
            this._register(this.editorService.onDidActiveEditorChange(function () { return _this.onActiveEditorChanged(); }));
        };
        SaveErrorHandler.prototype.onActiveEditorChanged = function () {
            var isActiveEditorSaveConflictResolution = false;
            var activeConflictResolutionResource;
            var activeInput = this.editorService.activeEditor;
            if (activeInput instanceof diffEditorInput_1.DiffEditorInput && activeInput.originalInput instanceof resourceEditorInput_1.ResourceEditorInput && activeInput.modifiedInput instanceof fileEditorInput_1.FileEditorInput) {
                var resource = activeInput.originalInput.getResource();
                if (resource && resource.scheme === exports.CONFLICT_RESOLUTION_SCHEME) {
                    isActiveEditorSaveConflictResolution = true;
                    activeConflictResolutionResource = activeInput.modifiedInput.getResource();
                }
            }
            this.conflictResolutionContext.set(isActiveEditorSaveConflictResolution);
            this.activeConflictResolutionResource = activeConflictResolutionResource;
        };
        SaveErrorHandler.prototype.onFileSavedOrReverted = function (resource) {
            var messageHandle = this.messages.get(resource);
            if (messageHandle) {
                messageHandle.close();
                this.messages.delete(resource);
            }
        };
        SaveErrorHandler.prototype.onSaveError = function (error, model) {
            var fileOperationError = error;
            var resource = model.getResource();
            var message;
            var actions = { primary: [], secondary: [] };
            // Dirty write prevention
            if (fileOperationError.fileOperationResult === 4 /* FILE_MODIFIED_SINCE */) {
                // If the user tried to save from the opened conflict editor, show its message again
                if (this.activeConflictResolutionResource && this.activeConflictResolutionResource.toString() === model.getResource().toString()) {
                    if (this.storageService.getBoolean(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY)) {
                        return; // return if this message is ignored
                    }
                    message = conflictEditorHelp;
                    actions.primary.push(this.instantiationService.createInstance(ResolveConflictLearnMoreAction));
                    actions.secondary.push(this.instantiationService.createInstance(DoNotShowResolveConflictLearnMoreAction));
                }
                // Otherwise show the message that will lead the user into the save conflict editor.
                else {
                    message = nls.localize('staleSaveError', "Failed to save '{0}': The content on disk is newer. Please compare your version with the one on disk.", paths.basename(resource.fsPath));
                    actions.primary.push(this.instantiationService.createInstance(ResolveSaveConflictAction, model));
                }
            }
            // Any other save error
            else {
                var isReadonly = fileOperationError.fileOperationResult === 6 /* FILE_READ_ONLY */;
                var triedToMakeWriteable = isReadonly && fileOperationError.options && fileOperationError.options.overwriteReadonly;
                var isPermissionDenied = fileOperationError.fileOperationResult === 7 /* FILE_PERMISSION_DENIED */;
                // Save Elevated
                if (isPermissionDenied || triedToMakeWriteable) {
                    actions.primary.push(this.instantiationService.createInstance(SaveElevatedAction, model, triedToMakeWriteable));
                }
                // Overwrite
                else if (isReadonly) {
                    actions.primary.push(this.instantiationService.createInstance(OverwriteReadonlyAction, model));
                }
                // Retry
                else {
                    actions.primary.push(this.instantiationService.createInstance(actions_2.ExecuteCommandAction, fileCommands_1.SAVE_FILE_COMMAND_ID, nls.localize('retry', "Retry")));
                }
                // Save As
                actions.primary.push(this.instantiationService.createInstance(actions_2.ExecuteCommandAction, fileCommands_1.SAVE_FILE_AS_COMMAND_ID, fileCommands_1.SAVE_FILE_AS_LABEL));
                // Discard
                actions.primary.push(this.instantiationService.createInstance(actions_2.ExecuteCommandAction, fileCommands_1.REVERT_FILE_COMMAND_ID, nls.localize('discard', "Discard")));
                if (isReadonly) {
                    if (triedToMakeWriteable) {
                        message = nls.localize('readonlySaveErrorAdmin', "Failed to save '{0}': File is write protected. Select 'Overwrite as Admin' to retry as administrator.", paths.basename(resource.fsPath));
                    }
                    else {
                        message = nls.localize('readonlySaveError', "Failed to save '{0}': File is write protected. Select 'Overwrite' to attempt to remove protection.", paths.basename(resource.fsPath));
                    }
                }
                else if (isPermissionDenied) {
                    message = nls.localize('permissionDeniedSaveError', "Failed to save '{0}': Insufficient permissions. Select 'Retry as Admin' to retry as administrator.", paths.basename(resource.fsPath));
                }
                else {
                    message = nls.localize('genericSaveError', "Failed to save '{0}': {1}", paths.basename(resource.fsPath), errorMessage_1.toErrorMessage(error, false));
                }
            }
            // Show message and keep function to hide in case the file gets saved/reverted
            var handle = this.notificationService.notify({ severity: notification_1.Severity.Error, message: message, actions: actions });
            event_1.once(handle.onDidClose)(function () { return lifecycle_1.dispose.apply(void 0, actions.primary.concat(actions.secondary)); });
            this.messages.set(model.getResource(), handle);
        };
        SaveErrorHandler.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.messages.clear();
        };
        SaveErrorHandler = __decorate([
            __param(0, notification_1.INotificationService),
            __param(1, textfiles_1.ITextFileService),
            __param(2, contextkey_1.IContextKeyService),
            __param(3, editorService_1.IEditorService),
            __param(4, resolverService_1.ITextModelService),
            __param(5, instantiation_1.IInstantiationService),
            __param(6, storage_1.IStorageService)
        ], SaveErrorHandler);
        return SaveErrorHandler;
    }(lifecycle_1.Disposable));
    exports.SaveErrorHandler = SaveErrorHandler;
    var pendingResolveSaveConflictMessages = [];
    function clearPendingResolveSaveConflictMessages() {
        while (pendingResolveSaveConflictMessages.length > 0) {
            pendingResolveSaveConflictMessages.pop().close();
        }
    }
    var ResolveConflictLearnMoreAction = /** @class */ (function (_super) {
        __extends(ResolveConflictLearnMoreAction, _super);
        function ResolveConflictLearnMoreAction(openerService) {
            var _this = _super.call(this, 'workbench.files.action.resolveConflictLearnMore', nls.localize('learnMore', "Learn More")) || this;
            _this.openerService = openerService;
            return _this;
        }
        ResolveConflictLearnMoreAction.prototype.run = function () {
            return this.openerService.open(uri_1.URI.parse('https://go.microsoft.com/fwlink/?linkid=868264'));
        };
        ResolveConflictLearnMoreAction = __decorate([
            __param(0, opener_1.IOpenerService)
        ], ResolveConflictLearnMoreAction);
        return ResolveConflictLearnMoreAction;
    }(actions_1.Action));
    var DoNotShowResolveConflictLearnMoreAction = /** @class */ (function (_super) {
        __extends(DoNotShowResolveConflictLearnMoreAction, _super);
        function DoNotShowResolveConflictLearnMoreAction(storageService) {
            var _this = _super.call(this, 'workbench.files.action.resolveConflictLearnMoreDoNotShowAgain', nls.localize('dontShowAgain', "Don't Show Again")) || this;
            _this.storageService = storageService;
            return _this;
        }
        DoNotShowResolveConflictLearnMoreAction.prototype.run = function (notification) {
            this.storageService.store(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY, true);
            // Hide notification
            notification.dispose();
            return Promise.resolve(void 0);
        };
        DoNotShowResolveConflictLearnMoreAction = __decorate([
            __param(0, storage_1.IStorageService)
        ], DoNotShowResolveConflictLearnMoreAction);
        return DoNotShowResolveConflictLearnMoreAction;
    }(actions_1.Action));
    var ResolveSaveConflictAction = /** @class */ (function (_super) {
        __extends(ResolveSaveConflictAction, _super);
        function ResolveSaveConflictAction(model, editorService, notificationService, instantiationService, storageService, environmentService) {
            var _this = _super.call(this, 'workbench.files.action.resolveConflict', nls.localize('compareChanges', "Compare")) || this;
            _this.model = model;
            _this.editorService = editorService;
            _this.notificationService = notificationService;
            _this.instantiationService = instantiationService;
            _this.storageService = storageService;
            _this.environmentService = environmentService;
            return _this;
        }
        ResolveSaveConflictAction.prototype.run = function () {
            var _this = this;
            if (!this.model.isDisposed()) {
                var resource = this.model.getResource();
                var name_1 = paths.basename(resource.fsPath);
                var editorLabel = nls.localize('saveConflictDiffLabel', "{0} (on disk)  {1} (in {2}) - Resolve save conflict", name_1, name_1, this.environmentService.appNameLong);
                return this.editorService.openEditor({
                    leftResource: uri_1.URI.from({ scheme: exports.CONFLICT_RESOLUTION_SCHEME, path: resource.fsPath }),
                    rightResource: resource,
                    label: editorLabel,
                    options: { pinned: true }
                }).then(function () {
                    if (_this.storageService.getBoolean(LEARN_MORE_DIRTY_WRITE_IGNORE_KEY)) {
                        return; // return if this message is ignored
                    }
                    // Show additional help how to resolve the save conflict
                    var actions = { primary: [], secondary: [] };
                    actions.primary.push(_this.instantiationService.createInstance(ResolveConflictLearnMoreAction));
                    actions.secondary.push(_this.instantiationService.createInstance(DoNotShowResolveConflictLearnMoreAction));
                    var handle = _this.notificationService.notify({ severity: notification_1.Severity.Info, message: conflictEditorHelp, actions: actions });
                    event_1.once(handle.onDidClose)(function () { return lifecycle_1.dispose.apply(void 0, actions.primary.concat(actions.secondary)); });
                    pendingResolveSaveConflictMessages.push(handle);
                });
            }
            return Promise.resolve(true);
        };
        ResolveSaveConflictAction = __decorate([
            __param(1, editorService_1.IEditorService),
            __param(2, notification_1.INotificationService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, storage_1.IStorageService),
            __param(5, environment_1.IEnvironmentService)
        ], ResolveSaveConflictAction);
        return ResolveSaveConflictAction;
    }(actions_1.Action));
    var SaveElevatedAction = /** @class */ (function (_super) {
        __extends(SaveElevatedAction, _super);
        function SaveElevatedAction(model, triedToMakeWriteable) {
            var _this = _super.call(this, 'workbench.files.action.saveElevated', triedToMakeWriteable ? nls.localize('overwriteElevated', "Overwrite as Admin...") : nls.localize('saveElevated', "Retry as Admin...")) || this;
            _this.model = model;
            _this.triedToMakeWriteable = triedToMakeWriteable;
            return _this;
        }
        SaveElevatedAction.prototype.run = function () {
            if (!this.model.isDisposed()) {
                this.model.save({
                    writeElevated: true,
                    overwriteReadonly: this.triedToMakeWriteable
                });
            }
            return Promise.resolve(true);
        };
        return SaveElevatedAction;
    }(actions_1.Action));
    var OverwriteReadonlyAction = /** @class */ (function (_super) {
        __extends(OverwriteReadonlyAction, _super);
        function OverwriteReadonlyAction(model) {
            var _this = _super.call(this, 'workbench.files.action.overwrite', nls.localize('overwrite', "Overwrite")) || this;
            _this.model = model;
            return _this;
        }
        OverwriteReadonlyAction.prototype.run = function () {
            if (!this.model.isDisposed()) {
                this.model.save({ overwriteReadonly: true });
            }
            return Promise.resolve(true);
        };
        return OverwriteReadonlyAction;
    }(actions_1.Action));
    exports.acceptLocalChangesCommand = function (accessor, resource) {
        var editorService = accessor.get(editorService_1.IEditorService);
        var resolverService = accessor.get(resolverService_1.ITextModelService);
        var modelService = accessor.get(modelService_1.IModelService);
        var control = editorService.activeControl;
        var editor = control.input;
        var group = control.group;
        resolverService.createModelReference(resource).then(function (reference) {
            var model = reference.object;
            var localModelSnapshot = model.createSnapshot();
            clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
            // Revert to be able to save
            return model.revert().then(function () {
                // Restore user value (without loosing undo stack)
                modelService.updateModel(model.textEditorModel, textModel_1.createTextBufferFactoryFromSnapshot(localModelSnapshot));
                // Trigger save
                return model.save().then(function () {
                    // Reopen file input
                    return editorService.openEditor({ resource: model.getResource() }, group).then(function () {
                        // Clean up
                        group.closeEditor(editor);
                        editor.dispose();
                        reference.dispose();
                    });
                });
            });
        });
    };
    exports.revertLocalChangesCommand = function (accessor, resource) {
        var editorService = accessor.get(editorService_1.IEditorService);
        var resolverService = accessor.get(resolverService_1.ITextModelService);
        var control = editorService.activeControl;
        var editor = control.input;
        var group = control.group;
        resolverService.createModelReference(resource).then(function (reference) {
            var model = reference.object;
            clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
            // Revert on model
            return model.revert().then(function () {
                // Reopen file input
                return editorService.openEditor({ resource: model.getResource() }, group).then(function () {
                    // Clean up
                    group.closeEditor(editor);
                    editor.dispose();
                    reference.dispose();
                });
            });
        });
    };
});


































define(__m[267/*vs/workbench/parts/files/electron-browser/views/emptyView*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,25/*vs/base/common/errors*/,18/*vs/base/common/platform*/,8/*vs/base/browser/dom*/,121/*vs/base/browser/ui/button/button*/,3/*vs/platform/instantiation/common/instantiation*/,181/*vs/workbench/browser/actions/workspaceActions*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,31/*vs/platform/keybinding/common/keybinding*/,34/*vs/platform/contextview/browser/contextView*/,20/*vs/platform/workspace/common/workspace*/,7/*vs/platform/configuration/common/configuration*/,167/*vs/workbench/browser/parts/views/panelViewlet*/,84/*vs/workbench/browser/dnd*/,30/*vs/platform/theme/common/colorRegistry*/,58/*vs/workbench/common/theme*/]), function (require, exports, nls, errors, env, DOM, button_1, instantiation_1, workspaceActions_1, styler_1, themeService_1, keybinding_1, contextView_1, workspace_1, configuration_1, panelViewlet_1, dnd_1, colorRegistry_1, theme_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var EmptyView = /** @class */ (function (_super) {
        __extends(EmptyView, _super);
        function EmptyView(options, themeService, instantiationService, keybindingService, contextMenuService, contextService, configurationService) {
            var _this = _super.call(this, __assign({}, options, { ariaHeaderLabel: nls.localize('explorerSection', "Files Explorer Section") }), keybindingService, contextMenuService, configurationService) || this;
            _this.themeService = themeService;
            _this.instantiationService = instantiationService;
            _this.contextService = contextService;
            _this.contextService.onDidChangeWorkbenchState(function () { return _this.setLabels(); });
            return _this;
        }
        EmptyView.prototype.renderHeader = function (container) {
            var titleContainer = document.createElement('div');
            DOM.addClass(titleContainer, 'title');
            container.appendChild(titleContainer);
            this.titleElement = document.createElement('span');
            this.titleElement.textContent = name;
            titleContainer.appendChild(this.titleElement);
        };
        EmptyView.prototype.renderBody = function (container) {
            var _this = this;
            DOM.addClass(container, 'explorer-empty-view');
            var messageContainer = document.createElement('div');
            DOM.addClass(messageContainer, 'section');
            container.appendChild(messageContainer);
            this.messageElement = document.createElement('p');
            messageContainer.appendChild(this.messageElement);
            this.button = new button_1.Button(messageContainer);
            styler_1.attachButtonStyler(this.button, this.themeService);
            this.disposables.push(this.button.onDidClick(function () {
                var actionClass = _this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ ? workspaceActions_1.AddRootFolderAction : env.isMacintosh ? workspaceActions_1.OpenFileFolderAction : workspaceActions_1.OpenFolderAction;
                var action = _this.instantiationService.createInstance(actionClass, actionClass.ID, actionClass.LABEL);
                _this.actionRunner.run(action).then(function () {
                    action.dispose();
                }, function (err) {
                    action.dispose();
                    errors.onUnexpectedError(err);
                });
            }));
            this.disposables.push(new dnd_1.DragAndDropObserver(container, {
                onDrop: function (e) {
                    container.style.backgroundColor = _this.themeService.getTheme().getColor(theme_1.SIDE_BAR_BACKGROUND).toString();
                    var dropHandler = _this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: true });
                    dropHandler.handleDrop(e, function () { return undefined; }, function (targetGroup) { return undefined; });
                },
                onDragEnter: function (e) {
                    container.style.backgroundColor = _this.themeService.getTheme().getColor(colorRegistry_1.listDropBackground).toString();
                },
                onDragEnd: function () {
                    container.style.backgroundColor = _this.themeService.getTheme().getColor(theme_1.SIDE_BAR_BACKGROUND).toString();
                },
                onDragLeave: function () {
                    container.style.backgroundColor = _this.themeService.getTheme().getColor(theme_1.SIDE_BAR_BACKGROUND).toString();
                },
                onDragOver: function (e) {
                    e.dataTransfer.dropEffect = 'copy';
                }
            }));
            this.setLabels();
        };
        EmptyView.prototype.setLabels = function () {
            if (this.contextService.getWorkbenchState() === 3 /* WORKSPACE */) {
                this.messageElement.textContent = nls.localize('noWorkspaceHelp', "You have not yet added a folder to the workspace.");
                if (this.button) {
                    this.button.label = nls.localize('addFolder', "Add Folder");
                }
                this.titleElement.textContent = EmptyView.NAME;
            }
            else {
                this.messageElement.textContent = nls.localize('noFolderHelp', "You have not yet opened a folder.");
                if (this.button) {
                    this.button.label = nls.localize('openFolder', "Open Folder");
                }
                this.titleElement.textContent = this.title;
            }
        };
        EmptyView.prototype.layoutBody = function (size) {
            // no-op
        };
        EmptyView.prototype.setVisible = function (visible) {
            return Promise.resolve(null);
        };
        EmptyView.prototype.focusBody = function () {
            if (this.button) {
                this.button.element.focus();
            }
        };
        EmptyView.prototype.reveal = function (element, relativeTop) {
            return Promise.resolve(null);
        };
        EmptyView.prototype.getActions = function () {
            return [];
        };
        EmptyView.prototype.getSecondaryActions = function () {
            return [];
        };
        EmptyView.prototype.getActionItem = function (action) {
            return null;
        };
        EmptyView.prototype.shutdown = function () {
            // Subclass to implement
        };
        EmptyView.ID = 'workbench.explorer.emptyView';
        EmptyView.NAME = nls.localize('noWorkspace', "No Folder Opened");
        EmptyView = __decorate([
            __param(1, themeService_1.IThemeService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, keybinding_1.IKeybindingService),
            __param(4, contextView_1.IContextMenuService),
            __param(5, workspace_1.IWorkspaceContextService),
            __param(6, configuration_1.IConfigurationService)
        ], EmptyView);
        return EmptyView;
    }(panelViewlet_1.ViewletPanel));
    exports.EmptyView = EmptyView;
});























define(__m[228/*vs/workbench/parts/files/electron-browser/views/explorerViewer*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,38/*vs/base/common/objects*/,8/*vs/base/browser/dom*/,78/*path*/,12/*vs/base/common/uri*/,476/*vs/base/common/functional*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,25/*vs/base/common/errors*/,15/*vs/base/common/actions*/,166/*vs/base/common/comparers*/,139/*vs/base/browser/ui/inputbox/inputBox*/,18/*vs/base/common/platform*/,142/*vs/base/common/glob*/,60/*vs/workbench/browser/labels*/,4/*vs/base/common/lifecycle*/,27/*vs/workbench/services/textfile/common/textfiles*/,16/*vs/platform/files/common/files*/,156/*vs/workbench/parts/files/electron-browser/fileActions*/,477/*vs/base/parts/tree/browser/tree*/,478/*vs/base/parts/tree/browser/treeDnd*/,91/*vs/workbench/parts/files/common/explorerModel*/,49/*vs/workbench/services/part/common/partService*/,20/*vs/platform/workspace/common/workspace*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,99/*vs/platform/progress/common/progress*/,32/*vs/platform/telemetry/common/telemetry*/,23/*vs/platform/actions/common/actions*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,42/*vs/platform/windows/common/windows*/,145/*vs/workbench/services/workspace/common/workspaceEditing*/,84/*vs/workbench/browser/dnd*/,51/*vs/platform/list/browser/listService*/,79/*vs/platform/clipboard/common/clipboardService*/,165/*vs/base/browser/dnd*/,26/*vs/base/common/network*/,22/*vs/base/common/strings*/,92/*vs/platform/dialogs/common/dialogs*/,28/*vs/platform/notification/common/notification*/,11/*vs/workbench/services/editor/common/editorService*/,115/*vs/platform/actions/browser/menuItemActionItem*/]), function (require, exports, nls, objects, DOM, path, uri_1, functional_1, paths, resources, errors, actions_1, comparers, inputBox_1, platform_1, glob, labels_1, lifecycle_1, textfiles_1, files_1, fileActions_1, tree_1, treeDnd_1, explorerModel_1, partService_1, workspace_1, configuration_1, contextkey_1, contextView_1, instantiation_1, progress_1, telemetry_1, actions_2, styler_1, themeService_1, windows_1, workspaceEditing_1, dnd_1, listService_1, clipboardService_1, dnd_2, network_1, strings_1, dialogs_1, notification_1, editorService_1, menuItemActionItem_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileDataSource = /** @class */ (function () {
        function FileDataSource(progressService, notificationService, fileService, partService) {
            this.progressService = progressService;
            this.notificationService = notificationService;
            this.fileService = fileService;
            this.partService = partService;
        }
        FileDataSource.prototype.getId = function (tree, stat) {
            if (stat instanceof explorerModel_1.Model) {
                return 'model';
            }
            return stat.root.resource.toString() + ":" + stat.getId();
        };
        FileDataSource.prototype.hasChildren = function (tree, stat) {
            return stat instanceof explorerModel_1.Model || (stat instanceof explorerModel_1.ExplorerItem && (stat.isDirectory || stat.isRoot));
        };
        FileDataSource.prototype.getChildren = function (tree, stat) {
            var _this = this;
            if (stat instanceof explorerModel_1.Model) {
                return Promise.resolve(stat.roots);
            }
            // Return early if stat is already resolved
            if (stat.isDirectoryResolved) {
                return Promise.resolve(stat.getChildrenArray());
            }
            // Resolve children and add to fileStat for future lookup
            else {
                // Resolve
                var promise = this.fileService.resolveFile(stat.resource, { resolveSingleChildDescendants: true }).then(function (dirStat) {
                    // Convert to view model
                    var modelDirStat = explorerModel_1.ExplorerItem.create(dirStat, stat.root);
                    // Add children to folder
                    var children = modelDirStat.getChildrenArray();
                    if (children) {
                        children.forEach(function (child) {
                            stat.addChild(child);
                        });
                    }
                    stat.isDirectoryResolved = true;
                    return stat.getChildrenArray();
                }, function (e) {
                    // Do not show error for roots since we already use an explorer decoration to notify user
                    if (!(stat instanceof explorerModel_1.ExplorerItem && stat.isRoot)) {
                        _this.notificationService.error(e);
                    }
                    return []; // we could not resolve any children because of an error
                });
                this.progressService.showWhile(promise, this.partService.isCreated() ? 800 : 3200 /* less ugly initial startup */);
                return promise;
            }
        };
        FileDataSource.prototype.getParent = function (tree, stat) {
            if (!stat) {
                return Promise.resolve(null); // can be null if nothing selected in the tree
            }
            // Return if root reached
            if (tree.getInput() === stat) {
                return Promise.resolve(null);
            }
            // Return if parent already resolved
            if (stat instanceof explorerModel_1.ExplorerItem && stat.parent) {
                return Promise.resolve(stat.parent);
            }
            // We never actually resolve the parent from the disk for performance reasons. It wouldnt make
            // any sense to resolve parent by parent with requests to walk up the chain. Instead, the explorer
            // makes sure to properly resolve a deep path to a specific file and merges the result with the model.
            return Promise.resolve(null);
        };
        FileDataSource = __decorate([
            __param(0, progress_1.IProgressService),
            __param(1, notification_1.INotificationService),
            __param(2, files_1.IFileService),
            __param(3, partService_1.IPartService)
        ], FileDataSource);
        return FileDataSource;
    }());
    exports.FileDataSource = FileDataSource;
    var FileViewletState = /** @class */ (function () {
        function FileViewletState() {
            this.editableStats = new Map();
        }
        FileViewletState.prototype.getEditableData = function (stat) {
            return this.editableStats.get(stat);
        };
        FileViewletState.prototype.setEditable = function (stat, editableData) {
            if (editableData) {
                this.editableStats.set(stat, editableData);
            }
        };
        FileViewletState.prototype.clearEditable = function (stat) {
            this.editableStats.delete(stat);
        };
        return FileViewletState;
    }());
    exports.FileViewletState = FileViewletState;
    var ActionRunner = /** @class */ (function (_super) {
        __extends(ActionRunner, _super);
        function ActionRunner(state) {
            var _this = _super.call(this) || this;
            _this.viewletState = state;
            return _this;
        }
        ActionRunner.prototype.run = function (action, context) {
            return _super.prototype.run.call(this, action, { viewletState: this.viewletState });
        };
        return ActionRunner;
    }(actions_1.ActionRunner));
    exports.ActionRunner = ActionRunner;
    // Explorer Renderer
    var FileRenderer = /** @class */ (function () {
        function FileRenderer(state, contextViewService, instantiationService, themeService, configurationService, contextService) {
            var _this = this;
            this.contextViewService = contextViewService;
            this.instantiationService = instantiationService;
            this.themeService = themeService;
            this.configurationService = configurationService;
            this.contextService = contextService;
            this.state = state;
            this.config = this.configurationService.getValue();
            this.configListener = this.configurationService.onDidChangeConfiguration(function (e) {
                if (e.affectsConfiguration('explorer')) {
                    _this.config = _this.configurationService.getValue();
                }
            });
        }
        FileRenderer.prototype.dispose = function () {
            this.configListener.dispose();
        };
        FileRenderer.prototype.getHeight = function (tree, element) {
            return FileRenderer.ITEM_HEIGHT;
        };
        FileRenderer.prototype.getTemplateId = function (tree, element) {
            return FileRenderer.FILE_TEMPLATE_ID;
        };
        FileRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            templateData.elementDisposable.dispose();
            templateData.label.dispose();
        };
        FileRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            var elementDisposable = lifecycle_1.Disposable.None;
            var label = this.instantiationService.createInstance(labels_1.FileLabel, container, void 0);
            return { elementDisposable: elementDisposable, label: label, container: container };
        };
        FileRenderer.prototype.renderElement = function (tree, stat, templateId, templateData) {
            templateData.elementDisposable.dispose();
            var editableData = this.state.getEditableData(stat);
            // File Label
            if (!editableData) {
                templateData.label.element.style.display = 'flex';
                var extraClasses = ['explorer-item'];
                templateData.label.setFile(stat.resource, {
                    hidePath: true,
                    fileKind: stat.isRoot ? files_1.FileKind.ROOT_FOLDER : stat.isDirectory ? files_1.FileKind.FOLDER : files_1.FileKind.FILE,
                    extraClasses: extraClasses,
                    fileDecorations: this.config.explorer.decorations
                });
                templateData.elementDisposable = templateData.label.onDidRender(function () {
                    tree.updateWidth(stat);
                });
            }
            // Input Box
            else {
                templateData.label.element.style.display = 'none';
                this.renderInputBox(templateData.container, tree, stat, editableData);
                templateData.elementDisposable = lifecycle_1.Disposable.None;
            }
        };
        FileRenderer.prototype.renderInputBox = function (container, tree, stat, editableData) {
            var _this = this;
            // Use a file label only for the icon next to the input box
            var label = this.instantiationService.createInstance(labels_1.FileLabel, container, void 0);
            var extraClasses = ['explorer-item', 'explorer-item-edited'];
            var fileKind = stat.isRoot ? files_1.FileKind.ROOT_FOLDER : (stat.isDirectory || (stat instanceof explorerModel_1.NewStatPlaceholder && stat.isDirectoryPlaceholder())) ? files_1.FileKind.FOLDER : files_1.FileKind.FILE;
            var labelOptions = { hidePath: true, hideLabel: true, fileKind: fileKind, extraClasses: extraClasses };
            var parent = stat.name ? resources.dirname(stat.resource) : stat.resource;
            var value = stat.name || '';
            label.setFile(resources.joinPath(parent, value || ' '), labelOptions); // Use icon for ' ' if name is empty.
            // Input field for name
            var inputBox = new inputBox_1.InputBox(label.element, this.contextViewService, {
                validationOptions: {
                    validation: editableData.validator
                },
                ariaLabel: nls.localize('fileInputAriaLabel', "Type file name. Press Enter to confirm or Escape to cancel.")
            });
            var styler = styler_1.attachInputBoxStyler(inputBox, this.themeService);
            inputBox.onDidChange(function (value) {
                label.setFile(resources.joinPath(parent, value || ' '), labelOptions); // update label icon while typing!
            });
            var lastDot = value.lastIndexOf('.');
            inputBox.value = value;
            inputBox.select({ start: 0, end: lastDot > 0 && !stat.isDirectory ? lastDot : value.length });
            inputBox.focus();
            var done = functional_1.once(function (commit, blur) {
                tree.clearHighlight();
                label.element.style.display = 'none';
                if (commit && inputBox.value) {
                    editableData.action.run({ value: inputBox.value });
                }
                setTimeout(function () {
                    if (!blur) { // https://github.com/Microsoft/vscode/issues/20269
                        tree.domFocus();
                    }
                    lifecycle_1.dispose(toDispose);
                    container.removeChild(label.element);
                }, 0);
            });
            var toDispose = [
                inputBox,
                DOM.addStandardDisposableListener(inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {
                    if (e.equals(3 /* Enter */)) {
                        if (inputBox.validate()) {
                            done(true, false);
                        }
                    }
                    else if (e.equals(9 /* Escape */)) {
                        done(false, false);
                    }
                }),
                DOM.addStandardDisposableListener(inputBox.inputElement, DOM.EventType.KEY_UP, function (e) {
                    var initialRelPath = path.relative(stat.root.resource.path, stat.parent.resource.path);
                    var projectFolderName = '';
                    if (_this.contextService.getWorkbenchState() === 3 /* WORKSPACE */) {
                        projectFolderName = paths.basename(stat.root.resource.path); // show root folder name in multi-folder project
                    }
                    _this.showInputMessage(inputBox, initialRelPath, projectFolderName, editableData.action.id);
                }),
                DOM.addDisposableListener(inputBox.inputElement, DOM.EventType.BLUR, function () {
                    done(inputBox.isInputValid(), true);
                }),
                label,
                styler
            ];
        };
        FileRenderer.prototype.showInputMessage = function (inputBox, initialRelPath, projectFolderName, actionID) {
            if (projectFolderName === void 0) { projectFolderName = ''; }
            if (inputBox.validate()) {
                var value = inputBox.value;
                if (value && /.[\\/]./.test(value)) { // only show if there's at least one slash enclosed in the string
                    var displayPath = path.normalize(path.join(projectFolderName, initialRelPath, value));
                    displayPath = strings_1.rtrim(displayPath, paths.nativeSep);
                    var indexLastSlash = displayPath.lastIndexOf(paths.nativeSep);
                    var name_1 = displayPath.substring(indexLastSlash + 1);
                    var leadingPathPart = displayPath.substring(0, indexLastSlash);
                    var msg = void 0;
                    switch (actionID) {
                        case 'workbench.files.action.createFileFromExplorer':
                            msg = nls.localize('createFileFromExplorerInfoMessage', "Create file **{0}** in **{1}**", name_1, leadingPathPart);
                            break;
                        case 'workbench.files.action.renameFile':
                            msg = nls.localize('renameFileFromExplorerInfoMessage', "Move and rename to **{0}**", displayPath);
                            break;
                        case 'workbench.files.action.createFolderFromExplorer': // fallthrough
                        default:
                            msg = nls.localize('createFolderFromExplorerInfoMessage', "Create folder **{0}** in **{1}**", name_1, leadingPathPart);
                    }
                    inputBox.showMessage({
                        type: 1 /* INFO */,
                        content: msg,
                        formatContent: true
                    });
                }
                else if (value && /^\s|\s$/.test(value)) {
                    inputBox.showMessage({
                        content: nls.localize('whitespace', "Leading or trailing whitespace detected"),
                        formatContent: true,
                        type: 2 /* WARNING */
                    });
                }
                else { // fixes #46744: inputbox hides again if all slashes are removed
                    inputBox.hideMessage();
                }
            }
        };
        FileRenderer.ITEM_HEIGHT = 22;
        FileRenderer.FILE_TEMPLATE_ID = 'file';
        FileRenderer = __decorate([
            __param(1, contextView_1.IContextViewService),
            __param(2, instantiation_1.IInstantiationService),
            __param(3, themeService_1.IThemeService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, workspace_1.IWorkspaceContextService)
        ], FileRenderer);
        return FileRenderer;
    }());
    exports.FileRenderer = FileRenderer;
    // Explorer Accessibility Provider
    var FileAccessibilityProvider = /** @class */ (function () {
        function FileAccessibilityProvider() {
        }
        FileAccessibilityProvider.prototype.getAriaLabel = function (tree, stat) {
            return stat.name;
        };
        return FileAccessibilityProvider;
    }());
    exports.FileAccessibilityProvider = FileAccessibilityProvider;
    // Explorer Controller
    var FileController = /** @class */ (function (_super) {
        __extends(FileController, _super);
        function FileController(editorService, contextMenuService, telemetryService, menuService, contextKeyService, clipboardService, configurationService) {
            var _this = _super.call(this, { clickBehavior: 1 /* ON_MOUSE_UP */ /* do not change to not break DND */ }, configurationService) || this;
            _this.editorService = editorService;
            _this.contextMenuService = contextMenuService;
            _this.telemetryService = telemetryService;
            _this.menuService = menuService;
            _this.clipboardService = clipboardService;
            _this.fileCopiedContextKey = fileActions_1.FileCopiedContext.bindTo(contextKeyService);
            _this.toDispose = [];
            return _this;
        }
        FileController.prototype.onLeftClick = function (tree, stat, event, origin) {
            if (origin === void 0) { origin = 'mouse'; }
            var payload = { origin: origin };
            var isDoubleClick = (origin === 'mouse' && event.detail === 2);
            // Handle Highlight Mode
            if (tree.getHighlight()) {
                // Cancel Event
                event.preventDefault();
                event.stopPropagation();
                tree.clearHighlight(payload);
                return false;
            }
            // Handle root
            if (stat instanceof explorerModel_1.Model) {
                tree.clearFocus(payload);
                tree.clearSelection(payload);
                return false;
            }
            // Cancel Event
            var isMouseDown = event && event.browserEvent && event.browserEvent.type === 'mousedown';
            if (!isMouseDown) {
                event.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
            }
            event.stopPropagation();
            // Set DOM focus
            tree.domFocus();
            if (stat instanceof explorerModel_1.NewStatPlaceholder) {
                return true;
            }
            // Allow to multiselect
            if ((tree.useAltAsMultipleSelectionModifier && event.altKey) || !tree.useAltAsMultipleSelectionModifier && (event.ctrlKey || event.metaKey)) {
                var selection = tree.getSelection();
                this.previousSelectionRangeStop = undefined;
                if (selection.indexOf(stat) >= 0) {
                    tree.setSelection(selection.filter(function (s) { return s !== stat; }));
                }
                else {
                    tree.setSelection(selection.concat(stat));
                    tree.setFocus(stat, payload);
                }
            }
            // Allow to unselect
            else if (event.shiftKey) {
                var focus_1 = tree.getFocus();
                if (focus_1) {
                    if (this.previousSelectionRangeStop) {
                        tree.deselectRange(stat, this.previousSelectionRangeStop);
                    }
                    tree.selectRange(focus_1, stat, payload);
                    this.previousSelectionRangeStop = stat;
                }
            }
            // Select, Focus and open files
            else {
                // Expand / Collapse
                if (isDoubleClick || this.openOnSingleClick || this.isClickOnTwistie(event)) {
                    tree.toggleExpansion(stat, event.altKey);
                    this.previousSelectionRangeStop = undefined;
                }
                var preserveFocus = !isDoubleClick;
                tree.setFocus(stat, payload);
                if (isDoubleClick) {
                    event.preventDefault(); // focus moves to editor, we need to prevent default
                }
                tree.setSelection([stat], payload);
                if (!stat.isDirectory && (isDoubleClick || this.openOnSingleClick)) {
                    var sideBySide = false;
                    if (event) {
                        sideBySide = tree.useAltAsMultipleSelectionModifier ? (event.ctrlKey || event.metaKey) : event.altKey;
                    }
                    this.openEditor(stat, { preserveFocus: preserveFocus, sideBySide: sideBySide, pinned: isDoubleClick });
                }
            }
            return true;
        };
        FileController.prototype.onMouseMiddleClick = function (tree, element, event) {
            var sideBySide = false;
            if (event) {
                sideBySide = tree.useAltAsMultipleSelectionModifier ? (event.ctrlKey || event.metaKey) : event.altKey;
            }
            if (element instanceof explorerModel_1.ExplorerItem && !element.isDirectory) {
                this.openEditor(element, { preserveFocus: true, sideBySide: sideBySide, pinned: true });
            }
            return true;
        };
        FileController.prototype.onContextMenu = function (tree, stat, event) {
            var _this = this;
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return false;
            }
            event.preventDefault();
            event.stopPropagation();
            tree.setFocus(stat);
            // update dynamic contexts
            this.fileCopiedContextKey.set(this.clipboardService.hasResources());
            if (!this.contributedContextMenu) {
                this.contributedContextMenu = this.menuService.createMenu(actions_2.MenuId.ExplorerContext, tree.contextKeyService);
                this.toDispose.push(this.contributedContextMenu);
            }
            var anchor = { x: event.posx, y: event.posy };
            var selection = tree.getSelection();
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return anchor; },
                getActions: function () {
                    var actions = [];
                    menuItemActionItem_1.fillInContextMenuActions(_this.contributedContextMenu, { arg: stat instanceof explorerModel_1.ExplorerItem ? stat.resource : {}, shouldForwardArgs: true }, actions, _this.contextMenuService);
                    return Promise.resolve(actions);
                },
                onHide: function (wasCancelled) {
                    if (wasCancelled) {
                        tree.domFocus();
                    }
                },
                getActionsContext: function () { return selection && selection.indexOf(stat) >= 0
                    ? selection.map(function (fs) { return fs.resource; })
                    : stat instanceof explorerModel_1.ExplorerItem ? [stat.resource] : []; }
            });
            return true;
        };
        FileController.prototype.openEditor = function (stat, options) {
            if (stat && !stat.isDirectory) {
                /* __GDPR__
                    "workbenchActionExecuted" : {
                        "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                this.telemetryService.publicLog('workbenchActionExecuted', { id: 'workbench.files.openFile', from: 'explorer' });
                this.editorService.openEditor({ resource: stat.resource, options: options }, options.sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);
            }
        };
        FileController.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        FileController = __decorate([
            __param(0, editorService_1.IEditorService),
            __param(1, contextView_1.IContextMenuService),
            __param(2, telemetry_1.ITelemetryService),
            __param(3, actions_2.IMenuService),
            __param(4, contextkey_1.IContextKeyService),
            __param(5, clipboardService_1.IClipboardService),
            __param(6, configuration_1.IConfigurationService)
        ], FileController);
        return FileController;
    }(listService_1.WorkbenchTreeController));
    exports.FileController = FileController;
    // Explorer Sorter
    var FileSorter = /** @class */ (function () {
        function FileSorter(configurationService, contextService) {
            this.configurationService = configurationService;
            this.contextService = contextService;
            this.toDispose = [];
            this.updateSortOrder();
            this.registerListeners();
        }
        FileSorter.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(this.configurationService.onDidChangeConfiguration(function (e) { return _this.updateSortOrder(); }));
        };
        FileSorter.prototype.updateSortOrder = function () {
            this.sortOrder = this.configurationService.getValue('explorer.sortOrder') || 'default';
        };
        FileSorter.prototype.compare = function (tree, statA, statB) {
            // Do not sort roots
            if (statA.isRoot) {
                if (statB.isRoot) {
                    return this.contextService.getWorkspaceFolder(statA.resource).index - this.contextService.getWorkspaceFolder(statB.resource).index;
                }
                return -1;
            }
            if (statB.isRoot) {
                return 1;
            }
            // Sort Directories
            switch (this.sortOrder) {
                case 'type':
                    if (statA.isDirectory && !statB.isDirectory) {
                        return -1;
                    }
                    if (statB.isDirectory && !statA.isDirectory) {
                        return 1;
                    }
                    if (statA.isDirectory && statB.isDirectory) {
                        return comparers.compareFileNames(statA.name, statB.name);
                    }
                    break;
                case 'filesFirst':
                    if (statA.isDirectory && !statB.isDirectory) {
                        return 1;
                    }
                    if (statB.isDirectory && !statA.isDirectory) {
                        return -1;
                    }
                    break;
                case 'mixed':
                    break; // not sorting when "mixed" is on
                default: /* 'default', 'modified' */
                    if (statA.isDirectory && !statB.isDirectory) {
                        return -1;
                    }
                    if (statB.isDirectory && !statA.isDirectory) {
                        return 1;
                    }
                    break;
            }
            // Sort "New File/Folder" placeholders
            if (statA instanceof explorerModel_1.NewStatPlaceholder) {
                return -1;
            }
            if (statB instanceof explorerModel_1.NewStatPlaceholder) {
                return 1;
            }
            // Sort Files
            switch (this.sortOrder) {
                case 'type':
                    return comparers.compareFileExtensions(statA.name, statB.name);
                case 'modified':
                    if (statA.mtime !== statB.mtime) {
                        return statA.mtime < statB.mtime ? 1 : -1;
                    }
                    return comparers.compareFileNames(statA.name, statB.name);
                default: /* 'default', 'mixed', 'filesFirst' */
                    return comparers.compareFileNames(statA.name, statB.name);
            }
        };
        FileSorter.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        FileSorter = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, workspace_1.IWorkspaceContextService)
        ], FileSorter);
        return FileSorter;
    }());
    exports.FileSorter = FileSorter;
    var FileFilter = /** @class */ (function () {
        function FileFilter(contextService, configurationService) {
            this.contextService = contextService;
            this.configurationService = configurationService;
            this.hiddenExpressionPerRoot = new Map();
            this.registerListeners();
        }
        FileFilter.prototype.registerListeners = function () {
            var _this = this;
            this.workspaceFolderChangeListener = this.contextService.onDidChangeWorkspaceFolders(function () { return _this.updateConfiguration(); });
        };
        FileFilter.prototype.updateConfiguration = function () {
            var _this = this;
            var needsRefresh = false;
            this.contextService.getWorkspace().folders.forEach(function (folder) {
                var configuration = _this.configurationService.getValue({ resource: folder.uri });
                var excludesConfig = (configuration && configuration.files && configuration.files.exclude) || Object.create(null);
                if (!needsRefresh) {
                    var cached = _this.hiddenExpressionPerRoot.get(folder.uri.toString());
                    needsRefresh = !cached || !objects.equals(cached.original, excludesConfig);
                }
                var excludesConfigCopy = objects.deepClone(excludesConfig); // do not keep the config, as it gets mutated under our hoods
                _this.hiddenExpressionPerRoot.set(folder.uri.toString(), { original: excludesConfigCopy, parsed: glob.parse(excludesConfigCopy) });
            });
            return needsRefresh;
        };
        FileFilter.prototype.isVisible = function (tree, stat) {
            return this.doIsVisible(stat);
        };
        FileFilter.prototype.doIsVisible = function (stat) {
            if (stat instanceof explorerModel_1.NewStatPlaceholder || stat.isRoot) {
                return true; // always visible
            }
            // Hide those that match Hidden Patterns
            var cached = this.hiddenExpressionPerRoot.get(stat.root.resource.toString());
            if (cached && cached.parsed(paths.normalize(path.relative(stat.root.resource.path, stat.resource.path), true), stat.name, function (name) { return !!stat.parent.getChild(name); })) {
                return false; // hidden through pattern
            }
            return true;
        };
        FileFilter.prototype.dispose = function () {
            this.workspaceFolderChangeListener = lifecycle_1.dispose(this.workspaceFolderChangeListener);
        };
        FileFilter = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, configuration_1.IConfigurationService)
        ], FileFilter);
        return FileFilter;
    }());
    exports.FileFilter = FileFilter;
    // Explorer Drag And Drop Controller
    var FileDragAndDrop = /** @class */ (function (_super) {
        __extends(FileDragAndDrop, _super);
        function FileDragAndDrop(notificationService, dialogService, contextService, fileService, configurationService, instantiationService, textFileService, windowService, workspaceEditingService) {
            var _this = _super.call(this, function (stat) { return _this.statToResource(stat); }, instantiationService) || this;
            _this.notificationService = notificationService;
            _this.dialogService = dialogService;
            _this.contextService = contextService;
            _this.fileService = fileService;
            _this.configurationService = configurationService;
            _this.textFileService = textFileService;
            _this.windowService = windowService;
            _this.workspaceEditingService = workspaceEditingService;
            _this.toDispose = [];
            _this.updateDropEnablement();
            _this.registerListeners();
            return _this;
        }
        FileDragAndDrop.prototype.statToResource = function (stat) {
            if (stat.isDirectory) {
                return uri_1.URI.from({ scheme: 'folder', path: stat.resource.path }); // indicates that we are dragging a folder
            }
            return stat.resource;
        };
        FileDragAndDrop.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(this.configurationService.onDidChangeConfiguration(function (e) { return _this.updateDropEnablement(); }));
        };
        FileDragAndDrop.prototype.updateDropEnablement = function () {
            this.dropEnabled = this.configurationService.getValue('explorer.enableDragAndDrop');
        };
        FileDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
            var sources = data.getData();
            if (sources && sources.length) {
                // When dragging folders, make sure to collapse them to free up some space
                sources.forEach(function (s) {
                    if (s.isDirectory && tree.isExpanded(s)) {
                        tree.collapse(s, false);
                    }
                });
                // Apply some datatransfer types to allow for dragging the element outside of the application
                this.instantiationService.invokeFunction(dnd_1.fillResourceDataTransfers, sources, originalEvent);
                // The only custom data transfer we set from the explorer is a file transfer
                // to be able to DND between multiple code file explorers across windows
                var fileResources = sources.filter(function (s) { return !s.isDirectory && s.resource.scheme === network_1.Schemas.file; }).map(function (r) { return r.resource.fsPath; });
                if (fileResources.length) {
                    originalEvent.dataTransfer.setData(dnd_1.CodeDataTransfers.FILES, JSON.stringify(fileResources));
                }
            }
        };
        FileDragAndDrop.prototype.onDragOver = function (tree, data, target, originalEvent) {
            if (!this.dropEnabled) {
                return tree_1.DRAG_OVER_REJECT;
            }
            var isCopy = originalEvent && ((originalEvent.ctrlKey && !platform_1.isMacintosh) || (originalEvent.altKey && platform_1.isMacintosh));
            var fromDesktop = data instanceof treeDnd_1.DesktopDragAndDropData;
            // Desktop DND
            if (fromDesktop) {
                var types = originalEvent.dataTransfer.types;
                var typesArray = [];
                for (var i = 0; i < types.length; i++) {
                    typesArray.push(types[i].toLowerCase()); // somehow the types are lowercase
                }
                if (typesArray.indexOf(dnd_2.DataTransfers.FILES.toLowerCase()) === -1 && typesArray.indexOf(dnd_1.CodeDataTransfers.FILES.toLowerCase()) === -1) {
                    return tree_1.DRAG_OVER_REJECT;
                }
            }
            // Other-Tree DND
            else if (data instanceof treeDnd_1.ExternalElementsDragAndDropData) {
                return tree_1.DRAG_OVER_REJECT;
            }
            // In-Explorer DND
            else {
                var sources = data.getData();
                if (target instanceof explorerModel_1.Model) {
                    if (sources[0].isRoot) {
                        return tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN(false);
                    }
                    return tree_1.DRAG_OVER_REJECT;
                }
                if (!Array.isArray(sources)) {
                    return tree_1.DRAG_OVER_REJECT;
                }
                if (sources.some(function (source) {
                    if (source instanceof explorerModel_1.NewStatPlaceholder) {
                        return true; // NewStatPlaceholders can not be moved
                    }
                    if (source.isRoot && target instanceof explorerModel_1.ExplorerItem && !target.isRoot) {
                        return true; // Root folder can not be moved to a non root file stat.
                    }
                    if (source.resource.toString() === target.resource.toString()) {
                        return true; // Can not move anything onto itself
                    }
                    if (source.isRoot && target instanceof explorerModel_1.ExplorerItem && target.isRoot) {
                        // Disable moving workspace roots in one another
                        return false;
                    }
                    if (!isCopy && resources.dirname(source.resource).toString() === target.resource.toString()) {
                        return true; // Can not move a file to the same parent unless we copy
                    }
                    if (resources.isEqualOrParent(target.resource, source.resource, !platform_1.isLinux /* ignorecase */)) {
                        return true; // Can not move a parent folder into one of its children
                    }
                    return false;
                })) {
                    return tree_1.DRAG_OVER_REJECT;
                }
            }
            // All (target = model)
            if (target instanceof explorerModel_1.Model) {
                return this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY(false) : tree_1.DRAG_OVER_REJECT; // can only drop folders to workspace
            }
            // All (target = file/folder)
            else {
                if (target.isDirectory) {
                    if (target.isReadonly) {
                        return tree_1.DRAG_OVER_REJECT;
                    }
                    return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY(true) : tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN(true);
                }
                if (this.contextService.getWorkspace().folders.every(function (folder) { return folder.uri.toString() !== target.resource.toString(); })) {
                    return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP_COPY : tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP;
                }
            }
            return tree_1.DRAG_OVER_REJECT;
        };
        FileDragAndDrop.prototype.drop = function (tree, data, target, originalEvent) {
            // Desktop DND (Import file)
            if (data instanceof treeDnd_1.DesktopDragAndDropData) {
                this.handleExternalDrop(tree, data, target, originalEvent);
            }
            // In-Explorer DND (Move/Copy file)
            else {
                this.handleExplorerDrop(tree, data, target, originalEvent);
            }
        };
        FileDragAndDrop.prototype.handleExternalDrop = function (tree, data, target, originalEvent) {
            var _this = this;
            var droppedResources = dnd_1.extractResources(originalEvent.browserEvent, true);
            // Check for dropped external files to be folders
            return this.fileService.resolveFiles(droppedResources).then(function (result) {
                // Pass focus to window
                _this.windowService.focusWindow();
                // Handle folders by adding to workspace if we are in workspace context
                var folders = result.filter(function (r) { return r.success && r.stat.isDirectory; }).map(function (result) { return ({ uri: result.stat.resource }); });
                if (folders.length > 0) {
                    // If we are in no-workspace context, ask for confirmation to create a workspace
                    var confirmedPromise = Promise.resolve({ confirmed: true });
                    if (_this.contextService.getWorkbenchState() !== 3 /* WORKSPACE */) {
                        confirmedPromise = _this.dialogService.confirm({
                            message: folders.length > 1 ? nls.localize('dropFolders', "Do you want to add the folders to the workspace?") : nls.localize('dropFolder', "Do you want to add the folder to the workspace?"),
                            type: 'question',
                            primaryButton: folders.length > 1 ? nls.localize('addFolders', "&&Add Folders") : nls.localize('addFolder', "&&Add Folder")
                        });
                    }
                    return confirmedPromise.then(function (res) {
                        if (res.confirmed) {
                            return _this.workspaceEditingService.addFolders(folders);
                        }
                        return void 0;
                    });
                }
                // Handle dropped files (only support FileStat as target)
                else if (target instanceof explorerModel_1.ExplorerItem && !target.isReadonly) {
                    var addFilesAction = _this.instantiationService.createInstance(fileActions_1.AddFilesAction, tree, target, null);
                    return addFilesAction.run(droppedResources.map(function (res) { return res.resource; }));
                }
                return void 0;
            });
        };
        FileDragAndDrop.prototype.handleExplorerDrop = function (tree, data, target, originalEvent) {
            var _this = this;
            var sources = resources.distinctParents(data.getData(), function (s) { return s.resource; });
            var isCopy = (originalEvent.ctrlKey && !platform_1.isMacintosh) || (originalEvent.altKey && platform_1.isMacintosh);
            var confirmPromise;
            // Handle confirm setting
            var confirmDragAndDrop = !isCopy && this.configurationService.getValue(FileDragAndDrop.CONFIRM_DND_SETTING_KEY);
            if (confirmDragAndDrop) {
                confirmPromise = this.dialogService.confirm({
                    message: sources.length > 1 && sources.every(function (s) { return s.isRoot; }) ? nls.localize('confirmRootsMove', "Are you sure you want to change the order of multiple root folders in your workspace?")
                        : sources.length > 1 ? dialogs_1.getConfirmMessage(nls.localize('confirmMultiMove', "Are you sure you want to move the following {0} files?", sources.length), sources.map(function (s) { return s.resource; }))
                            : sources[0].isRoot ? nls.localize('confirmRootMove', "Are you sure you want to change the order of root folder '{0}' in your workspace?", sources[0].name)
                                : nls.localize('confirmMove', "Are you sure you want to move '{0}'?", sources[0].name),
                    checkbox: {
                        label: nls.localize('doNotAskAgain', "Do not ask me again")
                    },
                    type: 'question',
                    primaryButton: nls.localize({ key: 'moveButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Move")
                });
            }
            else {
                confirmPromise = Promise.resolve({ confirmed: true });
            }
            return confirmPromise.then(function (res) {
                // Check for confirmation checkbox
                var updateConfirmSettingsPromise = Promise.resolve(void 0);
                if (res.confirmed && res.checkboxChecked === true) {
                    updateConfirmSettingsPromise = _this.configurationService.updateValue(FileDragAndDrop.CONFIRM_DND_SETTING_KEY, false, 1 /* USER */);
                }
                return updateConfirmSettingsPromise.then(function () {
                    if (res.confirmed) {
                        var rootDropPromise = _this.doHandleRootDrop(sources.filter(function (s) { return s.isRoot; }), target);
                        return Promise.all(sources.filter(function (s) { return !s.isRoot; }).map(function (source) { return _this.doHandleExplorerDrop(tree, source, target, isCopy); }).concat(rootDropPromise)).then(function () { return void 0; });
                    }
                    return Promise.resolve(void 0);
                });
            });
        };
        FileDragAndDrop.prototype.doHandleRootDrop = function (roots, target) {
            if (roots.length === 0) {
                return Promise.resolve(undefined);
            }
            var folders = this.contextService.getWorkspace().folders;
            var targetIndex;
            var workspaceCreationData = [];
            var rootsToMove = [];
            var _loop_1 = function (index) {
                var data = {
                    uri: folders[index].uri
                };
                if (target instanceof explorerModel_1.ExplorerItem && folders[index].uri.toString() === target.resource.toString()) {
                    targetIndex = workspaceCreationData.length;
                }
                if (roots.every(function (r) { return r.resource.toString() !== folders[index].uri.toString(); })) {
                    workspaceCreationData.push(data);
                }
                else {
                    rootsToMove.push(data);
                }
            };
            for (var index = 0; index < folders.length; index++) {
                _loop_1(index);
            }
            if (target instanceof explorerModel_1.Model) {
                targetIndex = workspaceCreationData.length;
            }
            workspaceCreationData.splice.apply(workspaceCreationData, [targetIndex, 0].concat(rootsToMove));
            return this.workspaceEditingService.updateFolders(0, workspaceCreationData.length, workspaceCreationData);
        };
        FileDragAndDrop.prototype.doHandleExplorerDrop = function (tree, source, target, isCopy) {
            var _this = this;
            if (!(target instanceof explorerModel_1.ExplorerItem)) {
                return Promise.resolve(void 0);
            }
            return tree.expand(target).then(function () {
                if (target.isReadonly) {
                    return void 0;
                }
                // Reuse duplicate action if user copies
                if (isCopy) {
                    return _this.instantiationService.createInstance(fileActions_1.DuplicateFileAction, tree, source, target).run();
                }
                // Otherwise move
                var targetResource = resources.joinPath(target.resource, source.name);
                return _this.textFileService.move(source.resource, targetResource).then(null, function (error) {
                    // Conflict
                    if (error.fileOperationResult === 5 /* FILE_MOVE_CONFLICT */) {
                        var confirm_1 = {
                            message: nls.localize('confirmOverwriteMessage', "'{0}' already exists in the destination folder. Do you want to replace it?", source.name),
                            detail: nls.localize('irreversible', "This action is irreversible!"),
                            primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Replace"),
                            type: 'warning'
                        };
                        // Move with overwrite if the user confirms
                        return _this.dialogService.confirm(confirm_1).then(function (res) {
                            if (res.confirmed) {
                                return _this.textFileService.move(source.resource, targetResource, true /* overwrite */).then(null, function (error) { return _this.notificationService.error(error); });
                            }
                            return void 0;
                        });
                    }
                    // Any other error
                    else {
                        _this.notificationService.error(error);
                    }
                    return void 0;
                });
            }, errors.onUnexpectedError);
        };
        FileDragAndDrop.CONFIRM_DND_SETTING_KEY = 'explorer.confirmDragAndDrop';
        FileDragAndDrop = __decorate([
            __param(0, notification_1.INotificationService),
            __param(1, dialogs_1.IDialogService),
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, files_1.IFileService),
            __param(4, configuration_1.IConfigurationService),
            __param(5, instantiation_1.IInstantiationService),
            __param(6, textfiles_1.ITextFileService),
            __param(7, windows_1.IWindowService),
            __param(8, workspaceEditing_1.IWorkspaceEditingService)
        ], FileDragAndDrop);
        return FileDragAndDrop;
    }(dnd_1.SimpleFileResourceDragAndDrop));
    exports.FileDragAndDrop = FileDragAndDrop;
});


































define(__m[429/*vs/workbench/parts/files/electron-browser/views/explorerView*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,12/*vs/base/common/uri*/,17/*vs/base/common/async*/,24/*vs/base/common/paths*/,35/*vs/base/common/resources*/,146/*vs/base/common/decorators*/,57/*vs/workbench/parts/files/common/files*/,16/*vs/platform/files/common/files*/,156/*vs/workbench/parts/files/electron-browser/fileActions*/,228/*vs/workbench/parts/files/electron-browser/views/explorerViewer*/,13/*vs/workbench/common/editor*/,110/*vs/workbench/common/editor/diffEditorInput*/,8/*vs/base/browser/dom*/,76/*vs/workbench/browser/viewlet*/,221/*vs/workbench/browser/parts/views/viewsViewlet*/,91/*vs/workbench/parts/files/common/explorerModel*/,49/*vs/workbench/services/part/common/partService*/,241/*vs/workbench/parts/files/electron-browser/views/explorerDecorationsProvider*/,20/*vs/platform/workspace/common/workspace*/,7/*vs/platform/configuration/common/configuration*/,31/*vs/platform/keybinding/common/keybinding*/,3/*vs/platform/instantiation/common/instantiation*/,99/*vs/platform/progress/common/progress*/,34/*vs/platform/contextview/browser/contextView*/,10/*vs/platform/contextkey/common/contextkey*/,82/*vs/workbench/common/resources*/,175/*vs/workbench/electron-browser/resources*/,18/*vs/base/common/platform*/,155/*vs/workbench/services/decorations/browser/decorations*/,165/*vs/base/browser/dnd*/,26/*vs/base/common/network*/,28/*vs/platform/notification/common/notification*/,11/*vs/workbench/services/editor/common/editorService*/,59/*vs/platform/label/common/label*/]), function (require, exports, nls, uri_1, async_1, paths, resources, decorators_1, files_1, files_2, fileActions_1, explorerViewer_1, editor_1, diffEditorInput_1, DOM, viewlet_1, viewsViewlet_1, explorerModel_1, partService_1, explorerDecorationsProvider_1, workspace_1, configuration_1, keybinding_1, instantiation_1, progress_1, contextView_1, contextkey_1, resources_1, resources_2, platform_1, decorations_1, dnd_1, network_1, notification_1, editorService_1, label_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExplorerView = /** @class */ (function (_super) {
        __extends(ExplorerView, _super);
        function ExplorerView(options, notificationService, contextMenuService, instantiationService, contextService, progressService, editorService, fileService, partService, keybindingService, contextKeyService, configurationService, decorationService, labelService) {
            var _this = _super.call(this, __assign({}, options, { ariaHeaderLabel: nls.localize('explorerSection', "Files Explorer Section") }), keybindingService, contextMenuService, configurationService) || this;
            _this.notificationService = notificationService;
            _this.instantiationService = instantiationService;
            _this.contextService = contextService;
            _this.progressService = progressService;
            _this.editorService = editorService;
            _this.fileService = fileService;
            _this.partService = partService;
            _this.labelService = labelService;
            _this.id = ExplorerView.ID;
            _this.settings = options.viewletSettings;
            _this.viewletState = options.viewletState;
            _this.autoReveal = true;
            _this.explorerRefreshDelayer = new async_1.ThrottledDelayer(ExplorerView.EXPLORER_FILE_CHANGES_REFRESH_DELAY);
            _this.resourceContext = instantiationService.createInstance(resources_1.ResourceContextKey);
            _this.folderContext = files_1.ExplorerFolderContext.bindTo(contextKeyService);
            _this.readonlyContext = files_1.ExplorerResourceReadonlyContext.bindTo(contextKeyService);
            _this.rootContext = files_1.ExplorerRootContext.bindTo(contextKeyService);
            _this.fileEventsFilter = instantiationService.createInstance(resources_2.ResourceGlobMatcher, function (root) { return _this.getFileEventsExcludes(root); }, function (event) { return event.affectsConfiguration(files_2.FILES_EXCLUDE_CONFIG); });
            _this.decorationProvider = new explorerDecorationsProvider_1.ExplorerDecorationsProvider(_this.model, contextService);
            decorationService.registerDecorationsProvider(_this.decorationProvider);
            _this.disposables.push(_this.decorationProvider);
            _this.disposables.push(_this.resourceContext);
            return _this;
        }
        ExplorerView.prototype.getFileEventsExcludes = function (root) {
            var scope = root ? { resource: root } : void 0;
            var configuration = this.configurationService.getValue(scope);
            return (configuration && configuration.files && configuration.files.exclude) || Object.create(null);
        };
        ExplorerView.prototype.renderHeader = function (container) {
            var _this = this;
            _super.prototype.renderHeader.call(this, container);
            // Expand on drag over
            this.dragHandler = new dnd_1.DelayedDragHandler(container, function () { return _this.setExpanded(true); });
            var titleElement = container.querySelector('.title');
            var setHeader = function () {
                var workspace = _this.contextService.getWorkspace();
                var title = workspace.folders.map(function (folder) { return folder.name; }).join();
                titleElement.textContent = _this.name;
                titleElement.title = title;
            };
            this.disposables.push(this.contextService.onDidChangeWorkspaceName(setHeader));
            this.disposables.push(this.labelService.onDidRegisterFormatter(setHeader));
            setHeader();
        };
        Object.defineProperty(ExplorerView.prototype, "name", {
            get: function () {
                return this.labelService.getWorkspaceLabel(this.contextService.getWorkspace());
            },
            set: function (value) {
                // noop
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerView.prototype, "title", {
            get: function () {
                return this.name;
            },
            set: function (value) {
                // noop
            },
            enumerable: true,
            configurable: true
        });
        ExplorerView.prototype.render = function () {
            var _this = this;
            _super.prototype.render.call(this);
            // Update configuration
            var configuration = this.configurationService.getValue();
            this.onConfigurationUpdated(configuration);
            // Load and Fill Viewer
            var targetsToExpand = [];
            if (this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES]) {
                targetsToExpand = this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES].map(function (e) { return uri_1.URI.parse(e); });
            }
            this.doRefresh(targetsToExpand).then(function () {
                // When the explorer viewer is loaded, listen to changes to the editor input
                _this.disposables.push(_this.editorService.onDidActiveEditorChange(function () { return _this.revealActiveFile(); }));
                // Also handle configuration updates
                _this.disposables.push(_this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(_this.configurationService.getValue(), e); }));
                _this.revealActiveFile();
            });
        };
        ExplorerView.prototype.renderBody = function (container) {
            var _this = this;
            this.treeContainer = DOM.append(container, DOM.$('.explorer-folders-view'));
            this.tree = this.createViewer(this.treeContainer);
            if (this.toolbar) {
                this.toolbar.setActions(this.getActions(), this.getSecondaryActions())();
            }
            this.disposables.push(this.contextService.onDidChangeWorkspaceFolders(function (e) { return _this.refreshFromEvent(e.added); }));
            this.disposables.push(this.contextService.onDidChangeWorkbenchState(function (e) { return _this.refreshFromEvent(); }));
            this.disposables.push(this.fileService.onDidChangeFileSystemProviderRegistrations(function () { return _this.refreshFromEvent(); }));
            this.disposables.push(this.labelService.onDidRegisterFormatter(function () {
                _this._onDidChangeTitleArea.fire();
                _this.refreshFromEvent();
            }));
        };
        ExplorerView.prototype.layoutBody = function (size) {
            if (this.treeContainer) {
                this.treeContainer.style.height = size + 'px';
            }
            _super.prototype.layoutBody.call(this, size);
        };
        ExplorerView.prototype.getActions = function () {
            var actions = [];
            actions.push(this.instantiationService.createInstance(fileActions_1.NewFileAction, this.getViewer(), null));
            actions.push(this.instantiationService.createInstance(fileActions_1.NewFolderAction, this.getViewer(), null));
            actions.push(this.instantiationService.createInstance(fileActions_1.RefreshViewExplorerAction, this, 'explorer-action refresh-explorer'));
            actions.push(this.instantiationService.createInstance(viewlet_1.CollapseAction, this.getViewer(), true, 'explorer-action collapse-explorer'));
            return actions;
        };
        ExplorerView.prototype.revealActiveFile = function () {
            if (!this.autoReveal) {
                return; // do not touch selection or focus if autoReveal === false
            }
            var clearSelection = true;
            var clearFocus = false;
            // Handle files
            var activeFile = this.getActiveFile();
            if (activeFile) {
                // Always remember last opened file
                this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = activeFile.toString();
                // Select file if input is inside workspace
                if (this.isVisible() && !this.isDisposed && this.contextService.isInsideWorkspace(activeFile)) {
                    var selection = this.hasSingleSelection(activeFile);
                    if (!selection) {
                        this.select(activeFile);
                    }
                    clearSelection = false;
                }
            }
            // Handle closed or untitled file (convince explorer to not reopen any file when getting visible)
            var activeInput = this.editorService.activeEditor;
            if (!activeInput || editor_1.toResource(activeInput, { supportSideBySide: true, filter: network_1.Schemas.untitled })) {
                this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = void 0;
                clearFocus = true;
            }
            // Otherwise clear
            if (clearSelection) {
                this.explorerViewer.clearSelection();
            }
            if (clearFocus) {
                this.explorerViewer.clearFocus();
            }
        };
        ExplorerView.prototype.onConfigurationUpdated = function (configuration, event) {
            if (this.isDisposed) {
                return; // guard against possible race condition when config change causes recreate of views
            }
            this.autoReveal = configuration && configuration.explorer && configuration.explorer.autoReveal;
            // Push down config updates to components of viewer
            var needsRefresh = false;
            if (this.filter) {
                needsRefresh = this.filter.updateConfiguration();
            }
            var configSortOrder = configuration && configuration.explorer && configuration.explorer.sortOrder || 'default';
            if (this.sortOrder !== configSortOrder) {
                this.sortOrder = configSortOrder;
                needsRefresh = true;
            }
            if (event && !needsRefresh) {
                needsRefresh = event.affectsConfiguration('explorer.decorations.colors')
                    || event.affectsConfiguration('explorer.decorations.badges');
            }
            // Refresh viewer as needed if this originates from a config event
            if (event && needsRefresh) {
                this.doRefresh();
            }
        };
        ExplorerView.prototype.focus = function () {
            _super.prototype.focus.call(this);
            var keepFocus = false;
            // Make sure the current selected element is revealed
            if (this.explorerViewer) {
                if (this.autoReveal) {
                    var selection = this.explorerViewer.getSelection();
                    if (selection.length > 0) {
                        this.reveal(selection[0], 0.5);
                    }
                }
                // Pass Focus to Viewer
                this.explorerViewer.domFocus();
                keepFocus = true;
            }
            // Open the focused element in the editor if there is currently no file opened
            var activeFile = this.getActiveFile();
            if (!activeFile) {
                this.openFocusedElement(keepFocus);
            }
        };
        ExplorerView.prototype.setVisible = function (visible) {
            var _this = this;
            return _super.prototype.setVisible.call(this, visible).then(function () {
                // Show
                if (visible) {
                    // If a refresh was requested and we are now visible, run it
                    var refreshPromise = Promise.resolve(null);
                    if (_this.shouldRefresh) {
                        refreshPromise = _this.doRefresh();
                        _this.shouldRefresh = false; // Reset flag
                    }
                    if (!_this.autoReveal) {
                        return refreshPromise; // do not react to setVisible call if autoReveal === false
                    }
                    // Always select the current navigated file in explorer if input is file editor input
                    // unless autoReveal is set to false
                    var activeFile_1 = _this.getActiveFile();
                    if (activeFile_1) {
                        return refreshPromise.then(function () {
                            return _this.select(activeFile_1);
                        });
                    }
                    // Return now if the workbench has not yet been created - in this case the workbench takes care of restoring last used editors
                    if (!_this.partService.isCreated()) {
                        return Promise.resolve(null);
                    }
                    // Otherwise restore last used file: By lastActiveFileResource
                    var lastActiveFileResource = void 0;
                    if (_this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE]) {
                        lastActiveFileResource = uri_1.URI.parse(_this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE]);
                    }
                    if (lastActiveFileResource && _this.isCreated && _this.model.findClosest(lastActiveFileResource)) {
                        _this.editorService.openEditor({ resource: lastActiveFileResource, options: { revealIfVisible: true } });
                        return refreshPromise;
                    }
                    // Otherwise restore last used file: By Explorer selection
                    return refreshPromise.then(function () {
                        _this.openFocusedElement();
                    });
                }
                return void 0;
            });
        };
        ExplorerView.prototype.openFocusedElement = function (preserveFocus) {
            var stat = this.explorerViewer.getFocus();
            if (stat && !stat.isDirectory) {
                this.editorService.openEditor({ resource: stat.resource, options: { preserveFocus: preserveFocus, revealIfVisible: true } });
            }
        };
        ExplorerView.prototype.getActiveFile = function () {
            var input = this.editorService.activeEditor;
            // ignore diff editor inputs (helps to get out of diffing when returning to explorer)
            if (input instanceof diffEditorInput_1.DiffEditorInput) {
                return null;
            }
            // check for files
            return editor_1.toResource(input, { supportSideBySide: true });
        };
        Object.defineProperty(ExplorerView.prototype, "isCreated", {
            get: function () {
                return !!(this.explorerViewer && this.explorerViewer.getInput());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExplorerView.prototype, "model", {
            get: function () {
                var model = this.instantiationService.createInstance(explorerModel_1.Model);
                this.disposables.push(model);
                return model;
            },
            enumerable: true,
            configurable: true
        });
        ExplorerView.prototype.createViewer = function (container) {
            var _this = this;
            var dataSource = this.instantiationService.createInstance(explorerViewer_1.FileDataSource);
            var renderer = this.instantiationService.createInstance(explorerViewer_1.FileRenderer, this.viewletState);
            var controller = this.instantiationService.createInstance(explorerViewer_1.FileController);
            this.disposables.push(controller);
            var sorter = this.instantiationService.createInstance(explorerViewer_1.FileSorter);
            this.disposables.push(sorter);
            this.filter = this.instantiationService.createInstance(explorerViewer_1.FileFilter);
            this.disposables.push(this.filter);
            var dnd = this.instantiationService.createInstance(explorerViewer_1.FileDragAndDrop);
            var accessibilityProvider = this.instantiationService.createInstance(explorerViewer_1.FileAccessibilityProvider);
            this.explorerViewer = this.instantiationService.createInstance(viewsViewlet_1.FileIconThemableWorkbenchTree, container, {
                dataSource: dataSource,
                renderer: renderer,
                controller: controller,
                sorter: sorter,
                filter: this.filter,
                dnd: dnd,
                accessibilityProvider: accessibilityProvider
            }, {
                autoExpandSingleChildren: true,
                ariaLabel: nls.localize('treeAriaLabel', "Files Explorer")
            });
            // Bind context keys
            files_1.FilesExplorerFocusedContext.bindTo(this.explorerViewer.contextKeyService);
            files_1.ExplorerFocusedContext.bindTo(this.explorerViewer.contextKeyService);
            // Update Viewer based on File Change Events
            this.disposables.push(this.fileService.onAfterOperation(function (e) { return _this.onFileOperation(e); }));
            this.disposables.push(this.fileService.onFileChanges(function (e) { return _this.onFileChanges(e); }));
            // Update resource context based on focused element
            this.disposables.push(this.explorerViewer.onDidChangeFocus(function (e) {
                var isSingleFolder = _this.contextService.getWorkbenchState() === 2 /* FOLDER */;
                var resource = e.focus ? e.focus.resource : isSingleFolder ? _this.contextService.getWorkspace().folders[0].uri : undefined;
                _this.resourceContext.set(resource);
                _this.folderContext.set((isSingleFolder && !e.focus) || e.focus && e.focus.isDirectory);
                _this.readonlyContext.set(e.focus && e.focus.isReadonly);
                _this.rootContext.set(!e.focus || (e.focus && e.focus.isRoot));
            }));
            // Open when selecting via keyboard
            this.disposables.push(this.explorerViewer.onDidChangeSelection(function (event) {
                if (event && event.payload && event.payload.origin === 'keyboard') {
                    var element = _this.tree.getSelection();
                    if (Array.isArray(element) && element[0] instanceof explorerModel_1.ExplorerItem) {
                        if (element[0].isDirectory) {
                            _this.explorerViewer.toggleExpansion(element[0]);
                        }
                        controller.openEditor(element[0], { pinned: false, sideBySide: false, preserveFocus: false });
                    }
                }
            }));
            return this.explorerViewer;
        };
        ExplorerView.prototype.getViewer = function () {
            return this.tree;
        };
        ExplorerView.prototype.getOptimalWidth = function () {
            var parentNode = this.explorerViewer.getHTMLElement();
            var childNodes = [].slice.call(parentNode.querySelectorAll('.explorer-item .label-name')); // select all file labels
            return DOM.getLargestChildWidth(parentNode, childNodes);
        };
        ExplorerView.prototype.onFileOperation = function (e) {
            var _this = this;
            if (!this.isCreated) {
                return; // ignore if not yet created
            }
            // Add
            if (e.operation === 0 /* CREATE */ || e.operation === 3 /* COPY */) {
                var addedElement_1 = e.target;
                var parentResource = resources.dirname(addedElement_1.resource);
                var parents = this.model.findAll(parentResource);
                if (parents.length) {
                    // Add the new file to its parent (Model)
                    parents.forEach(function (p) {
                        // We have to check if the parent is resolved #29177
                        var thenable = p.isDirectoryResolved ? Promise.resolve(null) : _this.fileService.resolveFile(p.resource);
                        thenable.then(function (stat) {
                            if (stat) {
                                var modelStat = explorerModel_1.ExplorerItem.create(stat, p.root);
                                explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, p);
                            }
                            var childElement = explorerModel_1.ExplorerItem.create(addedElement_1, p.root);
                            p.removeChild(childElement); // make sure to remove any previous version of the file if any
                            p.addChild(childElement);
                            // Refresh the Parent (View)
                            _this.explorerViewer.refresh(p).then(function () {
                                return _this.reveal(childElement, 0.5).then(function () {
                                    // Focus new element
                                    _this.explorerViewer.setFocus(childElement);
                                });
                            });
                        });
                    });
                }
            }
            // Move (including Rename)
            else if (e.operation === 2 /* MOVE */) {
                var oldResource = e.resource;
                var newElement_1 = e.target;
                var oldParentResource = resources.dirname(oldResource);
                var newParentResource = resources.dirname(newElement_1.resource);
                // Only update focus if renamed/moved element is selected
                var restoreFocus_1 = false;
                var focus_1 = this.explorerViewer.getFocus();
                if (focus_1 && focus_1.resource && focus_1.resource.toString() === oldResource.toString()) {
                    restoreFocus_1 = true;
                }
                var isExpanded_1 = false;
                // Handle Rename
                if (oldParentResource && newParentResource && oldParentResource.toString() === newParentResource.toString()) {
                    var modelElements = this.model.findAll(oldResource);
                    modelElements.forEach(function (modelElement) {
                        //Check if element is expanded
                        isExpanded_1 = _this.explorerViewer.isExpanded(modelElement);
                        // Rename File (Model)
                        modelElement.rename(newElement_1);
                        // Update Parent (View)
                        _this.explorerViewer.refresh(modelElement.parent).then(function () {
                            // Select in Viewer if set
                            if (restoreFocus_1) {
                                _this.explorerViewer.setFocus(modelElement);
                            }
                            //Expand the element again
                            if (isExpanded_1) {
                                _this.explorerViewer.expand(modelElement);
                            }
                        });
                    });
                }
                // Handle Move
                else if (oldParentResource && newParentResource) {
                    var newParents_1 = this.model.findAll(newParentResource);
                    var modelElements = this.model.findAll(oldResource);
                    if (newParents_1.length && modelElements.length) {
                        // Move in Model
                        modelElements.forEach(function (modelElement, index) {
                            var oldParent = modelElement.parent;
                            modelElement.move(newParents_1[index], function (callback) {
                                // Update old parent
                                _this.explorerViewer.refresh(oldParent).then(callback);
                            }, function () {
                                // Update new parent
                                _this.explorerViewer.refresh(newParents_1[index], true).then(function () { return _this.explorerViewer.expand(newParents_1[index]); });
                            });
                        });
                    }
                }
            }
            // Delete
            else if (e.operation === 1 /* DELETE */) {
                var modelElements = this.model.findAll(e.resource);
                modelElements.forEach(function (element) {
                    if (element.parent) {
                        var parent_1 = element.parent;
                        // Remove Element from Parent (Model)
                        parent_1.removeChild(element);
                        // Refresh Parent (View)
                        var restoreFocus_2 = _this.explorerViewer.isDOMFocused();
                        _this.explorerViewer.refresh(parent_1).then(function () {
                            // Ensure viewer has keyboard focus if event originates from viewer
                            if (restoreFocus_2) {
                                _this.explorerViewer.domFocus();
                            }
                        });
                    }
                });
            }
        };
        ExplorerView.prototype.onFileChanges = function (e) {
            var _this = this;
            // Ensure memento state does not capture a deleted file (we run this from a timeout because
            // delete events can result in UI activity that will fill the memento again when multiple
            // editors are closing)
            setTimeout(function () {
                var lastActiveResource = _this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE];
                if (lastActiveResource && e.contains(uri_1.URI.parse(lastActiveResource), 2 /* DELETED */)) {
                    _this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE] = null;
                }
            });
            // Check if an explorer refresh is necessary (delayed to give internal events a chance to react first)
            // Note: there is no guarantee when the internal events are fired vs real ones. Code has to deal with the fact that one might
            // be fired first over the other or not at all.
            setTimeout(function () {
                if (!_this.shouldRefresh && _this.shouldRefreshFromEvent(e)) {
                    _this.refreshFromEvent();
                }
            }, ExplorerView.EXPLORER_FILE_CHANGES_REACT_DELAY);
        };
        ExplorerView.prototype.shouldRefreshFromEvent = function (e) {
            if (!this.isCreated) {
                return false;
            }
            // Filter to the ones we care
            e = this.filterToViewRelevantEvents(e);
            // Handle added files/folders
            var added = e.getAdded();
            if (added.length) {
                // Check added: Refresh if added file/folder is not part of resolved root and parent is part of it
                var ignoredPaths = {};
                for (var i = 0; i < added.length; i++) {
                    var change = added[i];
                    // Find parent
                    var parent_2 = resources.dirname(change.resource);
                    // Continue if parent was already determined as to be ignored
                    if (ignoredPaths[parent_2.toString()]) {
                        continue;
                    }
                    // Compute if parent is visible and added file not yet part of it
                    var parentStat = this.model.findClosest(parent_2);
                    if (parentStat && parentStat.isDirectoryResolved && !this.model.findClosest(change.resource)) {
                        return true;
                    }
                    // Keep track of path that can be ignored for faster lookup
                    if (!parentStat || !parentStat.isDirectoryResolved) {
                        ignoredPaths[parent_2.toString()] = true;
                    }
                }
            }
            // Handle deleted files/folders
            var deleted = e.getDeleted();
            if (deleted.length) {
                // Check deleted: Refresh if deleted file/folder part of resolved root
                for (var j = 0; j < deleted.length; j++) {
                    var del = deleted[j];
                    if (this.model.findClosest(del.resource)) {
                        return true;
                    }
                }
            }
            // Handle updated files/folders if we sort by modified
            if (this.sortOrder === files_1.SortOrderConfiguration.MODIFIED) {
                var updated = e.getUpdated();
                // Check updated: Refresh if updated file/folder part of resolved root
                for (var j = 0; j < updated.length; j++) {
                    var upd = updated[j];
                    if (this.model.findClosest(upd.resource)) {
                        return true;
                    }
                }
            }
            return false;
        };
        ExplorerView.prototype.filterToViewRelevantEvents = function (e) {
            var _this = this;
            return new files_2.FileChangesEvent(e.changes.filter(function (change) {
                if (change.type === 0 /* UPDATED */ && _this.sortOrder !== files_1.SortOrderConfiguration.MODIFIED) {
                    return false; // we only are about updated if we sort by modified time
                }
                if (!_this.contextService.isInsideWorkspace(change.resource)) {
                    return false; // exclude changes for resources outside of workspace
                }
                if (_this.fileEventsFilter.matches(change.resource)) {
                    return false; // excluded via files.exclude setting
                }
                return true;
            }));
        };
        ExplorerView.prototype.refreshFromEvent = function (newRoots) {
            var _this = this;
            if (newRoots === void 0) { newRoots = []; }
            if (this.isVisible() && !this.isDisposed) {
                this.explorerRefreshDelayer.trigger(function () {
                    if (!_this.explorerViewer.getHighlight()) {
                        return _this.doRefresh(newRoots.map(function (r) { return r.uri; })).then(function () {
                            if (newRoots.length === 1) {
                                return _this.reveal(_this.model.findClosest(newRoots[0].uri), 0.5);
                            }
                            return undefined;
                        });
                    }
                    return Promise.resolve(null);
                });
            }
            else {
                this.shouldRefresh = true;
            }
        };
        /**
         * Refresh the contents of the explorer to get up to date data from the disk about the file structure.
         */
        ExplorerView.prototype.refresh = function () {
            var _this = this;
            if (!this.explorerViewer || this.explorerViewer.getHighlight()) {
                return Promise.resolve(null);
            }
            // Focus
            this.explorerViewer.domFocus();
            // Find resource to focus from active editor input if set
            var resourceToFocus;
            if (this.autoReveal) {
                resourceToFocus = this.getActiveFile();
                if (!resourceToFocus) {
                    var selection = this.explorerViewer.getSelection();
                    if (selection && selection.length === 1) {
                        resourceToFocus = selection[0].resource;
                    }
                }
            }
            return this.doRefresh().then(function () {
                if (resourceToFocus) {
                    return _this.select(resourceToFocus, true);
                }
                return Promise.resolve(null);
            });
        };
        ExplorerView.prototype.doRefresh = function (targetsToExpand) {
            var _this = this;
            if (targetsToExpand === void 0) { targetsToExpand = []; }
            var targetsToResolve = this.model.roots.map(function (root) { return ({ root: root, resource: root.resource, options: { resolveTo: [] } }); });
            // First time refresh: Receive target through active editor input or selection and also include settings from previous session
            if (!this.isCreated) {
                var activeFile = this.getActiveFile();
                if (activeFile) {
                    var workspaceFolder_1 = this.contextService.getWorkspaceFolder(activeFile);
                    if (workspaceFolder_1) {
                        var found = targetsToResolve.filter(function (t) { return t.root.resource.toString() === workspaceFolder_1.uri.toString(); }).pop();
                        found.options.resolveTo.push(activeFile);
                    }
                }
                targetsToExpand.forEach(function (toExpand) {
                    var workspaceFolder = _this.contextService.getWorkspaceFolder(toExpand);
                    if (workspaceFolder) {
                        var found = targetsToResolve.filter(function (ttr) { return ttr.resource.toString() === workspaceFolder.uri.toString(); }).pop();
                        found.options.resolveTo.push(toExpand);
                    }
                });
            }
            // Subsequent refresh: Receive targets through expanded folders in tree
            else {
                targetsToResolve.forEach(function (t) {
                    _this.getResolvedDirectories(t.root, t.options.resolveTo);
                });
            }
            var promise = this.resolveRoots(targetsToResolve, targetsToExpand).then(function (result) {
                _this.decorationProvider.changed(targetsToResolve.map(function (t) { return t.root.resource; }));
                return result;
            });
            this.progressService.showWhile(promise, this.partService.isCreated() ? 800 : 1200 /* less ugly initial startup */);
            return promise;
        };
        ExplorerView.prototype.resolveRoots = function (targetsToResolve, targetsToExpand) {
            var _this = this;
            // Display roots only when multi folder workspace
            var input = this.contextService.getWorkbenchState() === 2 /* FOLDER */ ? this.model.roots[0] : this.model;
            var errorRoot = function (resource, root) {
                if (input === _this.model.roots[0]) {
                    input = _this.model;
                }
                return explorerModel_1.ExplorerItem.create({
                    resource: resource,
                    name: paths.basename(resource.fsPath),
                    mtime: 0,
                    etag: undefined,
                    isDirectory: true
                }, root, undefined, true);
            };
            var setInputAndExpand = function (input, statsToExpand) {
                // Make sure to expand all folders that where expanded in the previous session
                // Special case: we are switching to multi workspace view, thus expand all the roots (they might just be added)
                if (input === _this.model && statsToExpand.every(function (fs) { return fs && !fs.isRoot; })) {
                    statsToExpand = _this.model.roots.concat(statsToExpand);
                }
                return _this.explorerViewer.setInput(input).then(function () { return _this.explorerViewer.expandAll(statsToExpand); });
            };
            if (targetsToResolve.every(function (t) { return t.root.resource.scheme === 'file'; })) {
                // All the roots are local, resolve them in parallel
                return this.fileService.resolveFiles(targetsToResolve).then(function (results) {
                    // Convert to model
                    var modelStats = results.map(function (result, index) {
                        if (result.success && result.stat.isDirectory) {
                            return explorerModel_1.ExplorerItem.create(result.stat, targetsToResolve[index].root, targetsToResolve[index].options.resolveTo);
                        }
                        return errorRoot(targetsToResolve[index].resource, targetsToResolve[index].root);
                    });
                    // Subsequent refresh: Merge stat into our local model and refresh tree
                    modelStats.forEach(function (modelStat, index) {
                        if (index < _this.model.roots.length) {
                            explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, _this.model.roots[index]);
                        }
                    });
                    var statsToExpand = _this.explorerViewer.getExpandedElements().concat(targetsToExpand.map(function (expand) { return _this.model.findClosest(expand); }));
                    if (input === _this.explorerViewer.getInput()) {
                        return _this.explorerViewer.refresh().then(function () { return _this.explorerViewer.expandAll(statsToExpand); });
                    }
                    return setInputAndExpand(input, statsToExpand);
                });
            }
            // There is a remote root, resolve the roots sequantally
            var statsToExpand = [];
            var delayer = new async_1.Delayer(100);
            var delayerPromise;
            return Promise.all(targetsToResolve.map(function (target, index) { return _this.fileService.resolveFile(target.resource, target.options)
                .then(function (result) { return result.isDirectory ? explorerModel_1.ExplorerItem.create(result, target.root, target.options.resolveTo) : errorRoot(target.resource, target.root); }, function () { return errorRoot(target.resource, target.root); })
                .then(function (modelStat) {
                // Subsequent refresh: Merge stat into our local model and refresh tree
                if (index < _this.model.roots.length) {
                    explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, _this.model.roots[index]);
                }
                var toExpand = _this.explorerViewer.getExpandedElements().concat(targetsToExpand.map(function (target) { return _this.model.findClosest(target); }));
                if (input === _this.explorerViewer.getInput()) {
                    statsToExpand = statsToExpand.concat(toExpand);
                    if (!delayer.isTriggered()) {
                        delayerPromise = delayer.trigger(function () { return _this.explorerViewer.refresh()
                            .then(function () { return _this.explorerViewer.expandAll(statsToExpand); })
                            .then(function () { return statsToExpand = []; }); });
                    }
                    return delayerPromise;
                }
                return setInputAndExpand(input, statsToExpand);
            }); }));
        };
        /**
         * Given a stat, fills an array of path that make all folders below the stat that are resolved directories.
         */
        ExplorerView.prototype.getResolvedDirectories = function (stat, resolvedDirectories) {
            var _this = this;
            if (stat.isDirectoryResolved) {
                if (!stat.isRoot) {
                    // Drop those path which are parents of the current one
                    for (var i = resolvedDirectories.length - 1; i >= 0; i--) {
                        var resource = resolvedDirectories[i];
                        if (resources.isEqualOrParent(stat.resource, resource, !platform_1.isLinux /* ignorecase */)) {
                            resolvedDirectories.splice(i);
                        }
                    }
                    // Add to the list of path to resolve
                    resolvedDirectories.push(stat.resource);
                }
                // Recurse into children
                stat.getChildrenArray().forEach(function (child) {
                    _this.getResolvedDirectories(child, resolvedDirectories);
                });
            }
        };
        /**
         * Selects and reveal the file element provided by the given resource if its found in the explorer. Will try to
         * resolve the path from the disk in case the explorer is not yet expanded to the file yet.
         */
        ExplorerView.prototype.select = function (resource, reveal) {
            var _this = this;
            if (reveal === void 0) { reveal = this.autoReveal; }
            // Require valid path
            if (!resource) {
                return Promise.resolve(null);
            }
            // If path already selected, just reveal and return
            var selection = this.hasSingleSelection(resource);
            if (selection) {
                return reveal ? this.reveal(selection, 0.5) : Promise.resolve(null);
            }
            // First try to get the stat object from the input to avoid a roundtrip
            if (!this.isCreated) {
                return Promise.resolve(null);
            }
            var fileStat = this.model.findClosest(resource);
            if (fileStat) {
                return this.doSelect(fileStat, reveal);
            }
            // Stat needs to be resolved first and then revealed
            var options = { resolveTo: [resource] };
            var workspaceFolder = this.contextService.getWorkspaceFolder(resource);
            var rootUri = workspaceFolder ? workspaceFolder.uri : this.model.roots[0].resource;
            return this.fileService.resolveFile(rootUri, options).then(function (stat) {
                // Convert to model
                var root = _this.model.roots.filter(function (r) { return r.resource.toString() === rootUri.toString(); }).pop();
                var modelStat = explorerModel_1.ExplorerItem.create(stat, root, options.resolveTo);
                // Update Input with disk Stat
                explorerModel_1.ExplorerItem.mergeLocalWithDisk(modelStat, root);
                // Select and Reveal
                return _this.explorerViewer.refresh(root).then(function () { return _this.doSelect(root.find(resource), reveal); });
            }, function (e) { _this.notificationService.error(e); });
        };
        ExplorerView.prototype.hasSingleSelection = function (resource) {
            var currentSelection = this.explorerViewer.getSelection();
            return currentSelection.length === 1 && currentSelection[0].resource.toString() === resource.toString()
                ? currentSelection[0]
                : undefined;
        };
        ExplorerView.prototype.doSelect = function (fileStat, reveal) {
            var _this = this;
            if (!fileStat) {
                return Promise.resolve(null);
            }
            // Special case: we are asked to reveal and select an element that is not visible
            // In this case we take the parent element so that we are at least close to it.
            if (!this.filter.isVisible(this.tree, fileStat)) {
                fileStat = fileStat.parent;
                if (!fileStat) {
                    return Promise.resolve(null);
                }
            }
            // Reveal depending on flag
            var revealPromise;
            if (reveal) {
                revealPromise = this.reveal(fileStat, 0.5);
            }
            else {
                revealPromise = Promise.resolve(null);
            }
            return revealPromise.then(function () {
                if (!fileStat.isDirectory) {
                    _this.explorerViewer.setSelection([fileStat]); // Since folders can not be opened, only select files
                }
                _this.explorerViewer.setFocus(fileStat);
            });
        };
        ExplorerView.prototype.reveal = function (element, relativeTop) {
            if (!this.tree) {
                return Promise.resolve(null); // return early if viewlet has not yet been created
            }
            return this.tree.reveal(element, relativeTop);
        };
        ExplorerView.prototype.shutdown = function () {
            // Keep list of expanded folders to restore on next load
            if (this.isCreated) {
                var expanded = this.explorerViewer.getExpandedElements()
                    .filter(function (e) { return e instanceof explorerModel_1.ExplorerItem; })
                    .map(function (e) { return e.resource.toString(); });
                if (expanded.length) {
                    this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES] = expanded;
                }
                else {
                    delete this.settings[ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES];
                }
            }
            // Clean up last focused if not set
            if (!this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE]) {
                delete this.settings[ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE];
            }
            _super.prototype.shutdown.call(this);
        };
        ExplorerView.prototype.dispose = function () {
            this.isDisposed = true;
            if (this.dragHandler) {
                this.dragHandler.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        ExplorerView.ID = 'workbench.explorer.fileView';
        ExplorerView.EXPLORER_FILE_CHANGES_REACT_DELAY = 500; // delay in ms to react to file changes to give our internal events a chance to react first
        ExplorerView.EXPLORER_FILE_CHANGES_REFRESH_DELAY = 100; // delay in ms to refresh the explorer from disk file changes
        ExplorerView.MEMENTO_LAST_ACTIVE_FILE_RESOURCE = 'explorer.memento.lastActiveFileResource';
        ExplorerView.MEMENTO_EXPANDED_FOLDER_RESOURCES = 'explorer.memento.expandedFolderResources';
        __decorate([
            decorators_1.memoize
        ], ExplorerView.prototype, "model", null);
        ExplorerView = __decorate([
            __param(1, notification_1.INotificationService),
            __param(2, contextView_1.IContextMenuService),
            __param(3, instantiation_1.IInstantiationService),
            __param(4, workspace_1.IWorkspaceContextService),
            __param(5, progress_1.IProgressService),
            __param(6, editorService_1.IEditorService),
            __param(7, files_2.IFileService),
            __param(8, partService_1.IPartService),
            __param(9, keybinding_1.IKeybindingService),
            __param(10, contextkey_1.IContextKeyService),
            __param(11, configuration_1.IConfigurationService),
            __param(12, decorations_1.IDecorationsService),
            __param(13, label_1.ILabelService)
        ], ExplorerView);
        return ExplorerView;
    }(viewsViewlet_1.TreeViewsViewletPanel));
    exports.ExplorerView = ExplorerView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[408/*vs/workbench/parts/files/electron-browser/views/openEditorsView*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,17/*vs/base/common/async*/,15/*vs/base/common/actions*/,8/*vs/base/browser/dom*/,34/*vs/platform/contextview/browser/contextView*/,3/*vs/platform/instantiation/common/instantiation*/,33/*vs/workbench/services/group/common/editorGroupsService*/,7/*vs/platform/configuration/common/configuration*/,31/*vs/platform/keybinding/common/keybinding*/,156/*vs/workbench/parts/files/electron-browser/fileActions*/,57/*vs/workbench/parts/files/common/files*/,27/*vs/workbench/services/textfile/common/textfiles*/,91/*vs/workbench/parts/files/common/explorerModel*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,164/*vs/workbench/browser/parts/editor/editorActions*/,312/*vs/workbench/browser/actions/toggleEditorLayout*/,10/*vs/platform/contextkey/common/contextkey*/,40/*vs/platform/theme/common/styler*/,14/*vs/platform/theme/common/themeService*/,30/*vs/platform/theme/common/colorRegistry*/,51/*vs/platform/list/browser/listService*/,60/*vs/workbench/browser/labels*/,50/*vs/base/browser/ui/actionbar/actionbar*/,32/*vs/platform/telemetry/common/telemetry*/,11/*vs/workbench/services/editor/common/editorService*/,4/*vs/base/common/lifecycle*/,115/*vs/platform/actions/browser/menuItemActionItem*/,23/*vs/platform/actions/common/actions*/,150/*vs/workbench/parts/files/electron-browser/fileCommands*/,82/*vs/workbench/common/resources*/,84/*vs/workbench/browser/dnd*/,167/*vs/workbench/browser/parts/views/panelViewlet*/]), function (require, exports, nls, async_1, actions_1, dom, contextView_1, instantiation_1, editorGroupsService_1, configuration_1, keybinding_1, fileActions_1, files_1, textfiles_1, explorerModel_1, untitledEditorService_1, editorActions_1, toggleEditorLayout_1, contextkey_1, styler_1, themeService_1, colorRegistry_1, listService_1, labels_1, actionbar_1, telemetry_1, editorService_1, lifecycle_1, menuItemActionItem_1, actions_2, fileCommands_1, resources_1, dnd_1, panelViewlet_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = dom.$;
    var OpenEditorsView = /** @class */ (function (_super) {
        __extends(OpenEditorsView, _super);
        function OpenEditorsView(options, instantiationService, contextMenuService, textFileService, editorService, editorGroupService, configurationService, keybindingService, untitledEditorService, contextKeyService, themeService, telemetryService, menuService) {
            var _this = _super.call(this, __assign({}, options, { ariaHeaderLabel: nls.localize({ key: 'openEditosrSection', comment: ['Open is an adjective'] }, "Open Editors Section") }), keybindingService, contextMenuService, configurationService) || this;
            _this.instantiationService = instantiationService;
            _this.textFileService = textFileService;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.untitledEditorService = untitledEditorService;
            _this.contextKeyService = contextKeyService;
            _this.themeService = themeService;
            _this.telemetryService = telemetryService;
            _this.menuService = menuService;
            _this.structuralRefreshDelay = 0;
            _this.listRefreshScheduler = new async_1.RunOnceScheduler(function () {
                var previousLength = _this.list.length;
                _this.list.splice(0, _this.list.length, _this.elements);
                _this.focusActiveEditor();
                if (previousLength !== _this.list.length) {
                    _this.updateSize();
                }
                _this.needsRefresh = false;
            }, _this.structuralRefreshDelay);
            _this.registerUpdateEvents();
            // Also handle configuration updates
            _this.disposables.push(_this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationChange(e); }));
            // Handle dirty counter
            _this.disposables.push(_this.untitledEditorService.onDidChangeDirty(function () { return _this.updateDirtyIndicator(); }));
            _this.disposables.push(_this.textFileService.models.onModelsDirty(function () { return _this.updateDirtyIndicator(); }));
            _this.disposables.push(_this.textFileService.models.onModelsSaved(function () { return _this.updateDirtyIndicator(); }));
            _this.disposables.push(_this.textFileService.models.onModelsSaveError(function () { return _this.updateDirtyIndicator(); }));
            _this.disposables.push(_this.textFileService.models.onModelsReverted(function () { return _this.updateDirtyIndicator(); }));
            return _this;
        }
        OpenEditorsView.prototype.registerUpdateEvents = function () {
            var _this = this;
            var updateWholeList = function () {
                if (!_this.isVisible() || !_this.list || !_this.isExpanded()) {
                    _this.needsRefresh = true;
                    return;
                }
                _this.listRefreshScheduler.schedule(_this.structuralRefreshDelay);
            };
            var groupDisposables = new Map();
            var addGroupListener = function (group) {
                groupDisposables.set(group.id, group.onDidGroupChange(function (e) {
                    if (_this.listRefreshScheduler.isScheduled()) {
                        return;
                    }
                    if (!_this.isVisible() || !_this.list || !_this.isExpanded()) {
                        _this.needsRefresh = true;
                        return;
                    }
                    var index = _this.getIndex(group, e.editor);
                    switch (e.kind) {
                        case 1 /* GROUP_LABEL */: {
                            if (_this.showGroups) {
                                _this.list.splice(index, 1, [group]);
                            }
                            break;
                        }
                        case 0 /* GROUP_ACTIVE */:
                        case 5 /* EDITOR_ACTIVE */: {
                            _this.focusActiveEditor();
                            break;
                        }
                        case 8 /* EDITOR_DIRTY */:
                        case 6 /* EDITOR_LABEL */:
                        case 7 /* EDITOR_PIN */: {
                            _this.list.splice(index, 1, [new explorerModel_1.OpenEditor(e.editor, group)]);
                            break;
                        }
                        case 2 /* EDITOR_OPEN */: {
                            _this.list.splice(index, 0, [new explorerModel_1.OpenEditor(e.editor, group)]);
                            setTimeout(function () { return _this.updateSize(); }, _this.structuralRefreshDelay);
                            break;
                        }
                        case 3 /* EDITOR_CLOSE */: {
                            var previousIndex = _this.getIndex(group, undefined) + e.editorIndex + (_this.showGroups ? 1 : 0);
                            _this.list.splice(previousIndex, 1);
                            _this.updateSize();
                            break;
                        }
                        case 4 /* EDITOR_MOVE */: {
                            _this.listRefreshScheduler.schedule();
                            break;
                        }
                    }
                }));
                _this.disposables.push(groupDisposables.get(group.id));
            };
            this.editorGroupService.groups.forEach(function (g) { return addGroupListener(g); });
            this.disposables.push(this.editorGroupService.onDidAddGroup(function (group) {
                addGroupListener(group);
                updateWholeList();
            }));
            this.disposables.push(this.editorGroupService.onDidMoveGroup(function () { return updateWholeList(); }));
            this.disposables.push(this.editorGroupService.onDidRemoveGroup(function (group) {
                lifecycle_1.dispose(groupDisposables.get(group.id));
                updateWholeList();
            }));
        };
        OpenEditorsView.prototype.renderHeaderTitle = function (container) {
            var _this = this;
            _super.prototype.renderHeaderTitle.call(this, container, this.title);
            var count = dom.append(container, $('.count'));
            this.dirtyCountElement = dom.append(count, $('.monaco-count-badge'));
            this.disposables.push((styler_1.attachStylerCallback(this.themeService, { badgeBackground: colorRegistry_1.badgeBackground, badgeForeground: colorRegistry_1.badgeForeground, contrastBorder: colorRegistry_1.contrastBorder }, function (colors) {
                var background = colors.badgeBackground ? colors.badgeBackground.toString() : null;
                var foreground = colors.badgeForeground ? colors.badgeForeground.toString() : null;
                var border = colors.contrastBorder ? colors.contrastBorder.toString() : null;
                _this.dirtyCountElement.style.backgroundColor = background;
                _this.dirtyCountElement.style.color = foreground;
                _this.dirtyCountElement.style.borderWidth = border ? '1px' : null;
                _this.dirtyCountElement.style.borderStyle = border ? 'solid' : null;
                _this.dirtyCountElement.style.borderColor = border;
            })));
            this.updateDirtyIndicator();
        };
        OpenEditorsView.prototype.renderBody = function (container) {
            var _this = this;
            dom.addClass(container, 'explorer-open-editors');
            dom.addClass(container, 'show-file-icons');
            var delegate = new OpenEditorsDelegate();
            var getSelectedElements = function () {
                var selected = _this.list.getSelectedElements();
                var focused = _this.list.getFocusedElements();
                if (focused.length && selected.indexOf(focused[0]) >= 0) {
                    return selected;
                }
                return focused;
            };
            if (this.list) {
                this.list.dispose();
            }
            this.list = this.instantiationService.createInstance(listService_1.WorkbenchList, container, delegate, [
                new EditorGroupRenderer(this.keybindingService, this.instantiationService, this.editorGroupService),
                new OpenEditorRenderer(getSelectedElements, this.instantiationService, this.keybindingService, this.configurationService, this.editorGroupService)
            ], {
                identityProvider: function (element) { return element instanceof explorerModel_1.OpenEditor ? element.getId() : element.id.toString(); },
                selectOnMouseDown: false /* disabled to better support DND */
            });
            this.disposables.push(this.list);
            this.contributedContextMenu = this.menuService.createMenu(actions_2.MenuId.OpenEditorsContext, this.list.contextKeyService);
            this.disposables.push(this.contributedContextMenu);
            this.updateSize();
            // Bind context keys
            files_1.OpenEditorsFocusedContext.bindTo(this.list.contextKeyService);
            files_1.ExplorerFocusedContext.bindTo(this.list.contextKeyService);
            this.resourceContext = this.instantiationService.createInstance(resources_1.ResourceContextKey);
            this.disposables.push(this.resourceContext);
            this.groupFocusedContext = fileCommands_1.OpenEditorsGroupContext.bindTo(this.contextKeyService);
            this.dirtyEditorFocusedContext = fileCommands_1.DirtyEditorContext.bindTo(this.contextKeyService);
            this.disposables.push(this.list.onContextMenu(function (e) { return _this.onListContextMenu(e); }));
            this.list.onFocusChange(function (e) {
                _this.resourceContext.reset();
                _this.groupFocusedContext.reset();
                _this.dirtyEditorFocusedContext.reset();
                var element = e.elements.length ? e.elements[0] : undefined;
                if (element instanceof explorerModel_1.OpenEditor) {
                    _this.dirtyEditorFocusedContext.set(_this.textFileService.isDirty(element.getResource()));
                    _this.resourceContext.set(element.getResource());
                }
                else if (!!element) {
                    _this.groupFocusedContext.set(true);
                }
            });
            // Open when selecting via keyboard
            this.disposables.push(this.list.onMouseMiddleClick(function (e) {
                if (e && e.element instanceof explorerModel_1.OpenEditor) {
                    e.element.group.closeEditor(e.element.editor);
                }
            }));
            this.disposables.push(this.list.onOpen(function (e) {
                var browserEvent = e.browserEvent;
                var openToSide = false;
                var isSingleClick = false;
                var isDoubleClick = false;
                if (browserEvent instanceof MouseEvent) {
                    isSingleClick = browserEvent.detail === 1;
                    isDoubleClick = browserEvent.detail === 2;
                    openToSide = _this.list.useAltAsMultipleSelectionModifier ? (browserEvent.ctrlKey || browserEvent.metaKey) : browserEvent.altKey;
                }
                var focused = _this.list.getFocusedElements();
                var element = focused.length ? focused[0] : undefined;
                if (element instanceof explorerModel_1.OpenEditor) {
                    _this.openEditor(element, { preserveFocus: isSingleClick, pinned: isDoubleClick, sideBySide: openToSide });
                }
                else {
                    _this.editorGroupService.activateGroup(element);
                }
            }));
            this.listRefreshScheduler.schedule(0);
        };
        OpenEditorsView.prototype.getActions = function () {
            return [
                this.instantiationService.createInstance(toggleEditorLayout_1.ToggleEditorLayoutAction, toggleEditorLayout_1.ToggleEditorLayoutAction.ID, toggleEditorLayout_1.ToggleEditorLayoutAction.LABEL),
                this.instantiationService.createInstance(fileActions_1.SaveAllAction, fileActions_1.SaveAllAction.ID, fileActions_1.SaveAllAction.LABEL),
                this.instantiationService.createInstance(editorActions_1.CloseAllEditorsAction, editorActions_1.CloseAllEditorsAction.ID, editorActions_1.CloseAllEditorsAction.LABEL)
            ];
        };
        OpenEditorsView.prototype.setExpanded = function (expanded) {
            _super.prototype.setExpanded.call(this, expanded);
            this.updateListVisibility(expanded);
            if (expanded && this.needsRefresh) {
                this.listRefreshScheduler.schedule(0);
            }
        };
        OpenEditorsView.prototype.setVisible = function (visible) {
            var _this = this;
            return _super.prototype.setVisible.call(this, visible).then(function () {
                _this.updateListVisibility(visible && _this.isExpanded());
                if (visible && _this.needsRefresh) {
                    _this.listRefreshScheduler.schedule(0);
                }
            });
        };
        OpenEditorsView.prototype.focus = function () {
            _super.prototype.focus.call(this);
            this.list.domFocus();
        };
        OpenEditorsView.prototype.getList = function () {
            return this.list;
        };
        OpenEditorsView.prototype.layoutBody = function (size) {
            if (this.list) {
                this.list.layout(size);
            }
        };
        OpenEditorsView.prototype.updateListVisibility = function (isVisible) {
            if (this.list) {
                if (isVisible) {
                    dom.show(this.list.getHTMLElement());
                }
                else {
                    dom.hide(this.list.getHTMLElement()); // make sure the list goes out of the tabindex world by hiding it
                }
            }
        };
        Object.defineProperty(OpenEditorsView.prototype, "showGroups", {
            get: function () {
                return this.editorGroupService.groups.length > 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OpenEditorsView.prototype, "elements", {
            get: function () {
                var _this = this;
                var result = [];
                this.editorGroupService.getGroups(2 /* GRID_APPEARANCE */).forEach(function (g) {
                    if (_this.showGroups) {
                        result.push(g);
                    }
                    result.push.apply(result, g.editors.map(function (ei) { return new explorerModel_1.OpenEditor(ei, g); }));
                });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        OpenEditorsView.prototype.getIndex = function (group, editor) {
            var index = editor ? group.getIndexOfEditor(editor) : 0;
            if (!this.showGroups) {
                return index;
            }
            for (var _i = 0, _a = this.editorGroupService.getGroups(2 /* GRID_APPEARANCE */); _i < _a.length; _i++) {
                var g = _a[_i];
                if (g.id === group.id) {
                    return index + (!!editor ? 1 : 0);
                }
                else {
                    index += g.count + 1;
                }
            }
            return -1;
        };
        OpenEditorsView.prototype.openEditor = function (element, options) {
            var _this = this;
            if (element) {
                /* __GDPR__
                    "workbenchActionExecuted" : {
                        "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                this.telemetryService.publicLog('workbenchActionExecuted', { id: 'workbench.files.openFile', from: 'openEditors' });
                var preserveActivateGroup_1 = options.sideBySide && options.preserveFocus; // needed for https://github.com/Microsoft/vscode/issues/42399
                if (!preserveActivateGroup_1) {
                    this.editorGroupService.activateGroup(element.groupId); // needed for https://github.com/Microsoft/vscode/issues/6672
                }
                this.editorService.openEditor(element.editor, options, options.sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP).then(function (editor) {
                    if (!preserveActivateGroup_1) {
                        _this.editorGroupService.activateGroup(editor.group);
                    }
                });
            }
        };
        OpenEditorsView.prototype.onListContextMenu = function (e) {
            var _this = this;
            var element = e.element;
            this.contextMenuService.showContextMenu({
                getAnchor: function () { return e.anchor; },
                getActions: function () {
                    var actions = [];
                    menuItemActionItem_1.fillInContextMenuActions(_this.contributedContextMenu, { shouldForwardArgs: true, arg: element instanceof explorerModel_1.OpenEditor ? element.editor.getResource() : {} }, actions, _this.contextMenuService);
                    return Promise.resolve(actions);
                },
                getActionsContext: function () { return element instanceof explorerModel_1.OpenEditor ? { groupId: element.groupId, editorIndex: element.editorIndex } : { groupId: element.id }; }
            });
        };
        OpenEditorsView.prototype.focusActiveEditor = function () {
            if (this.list.length && this.editorGroupService.activeGroup) {
                var index = this.getIndex(this.editorGroupService.activeGroup, this.editorGroupService.activeGroup.activeEditor);
                this.list.setFocus([index]);
                this.list.setSelection([index]);
                this.list.reveal(index);
            }
            else {
                this.list.setFocus([]);
                this.list.setSelection([]);
            }
        };
        OpenEditorsView.prototype.onConfigurationChange = function (event) {
            if (event.affectsConfiguration('explorer.openEditors')) {
                this.updateSize();
            }
            // Trigger a 'repaint' when decoration settings change
            if (event.affectsConfiguration('explorer.decorations')) {
                this.listRefreshScheduler.schedule();
            }
        };
        OpenEditorsView.prototype.updateSize = function () {
            // Adjust expanded body size
            this.minimumBodySize = this.getMinExpandedBodySize();
            this.maximumBodySize = this.getMaxExpandedBodySize();
        };
        OpenEditorsView.prototype.updateDirtyIndicator = function () {
            var dirty = this.textFileService.getAutoSaveMode() !== 1 /* AFTER_SHORT_DELAY */ ? this.textFileService.getDirty().length
                : this.untitledEditorService.getDirty().length;
            if (dirty === 0) {
                dom.addClass(this.dirtyCountElement, 'hidden');
            }
            else {
                this.dirtyCountElement.textContent = nls.localize('dirtyCounter', "{0} unsaved", dirty);
                dom.removeClass(this.dirtyCountElement, 'hidden');
            }
        };
        Object.defineProperty(OpenEditorsView.prototype, "elementCount", {
            get: function () {
                return this.editorGroupService.groups.map(function (g) { return g.count; })
                    .reduce(function (first, second) { return first + second; }, this.showGroups ? this.editorGroupService.groups.length : 0);
            },
            enumerable: true,
            configurable: true
        });
        OpenEditorsView.prototype.getMaxExpandedBodySize = function () {
            return this.elementCount * OpenEditorsDelegate.ITEM_HEIGHT;
        };
        OpenEditorsView.prototype.getMinExpandedBodySize = function () {
            var visibleOpenEditors = this.configurationService.getValue('explorer.openEditors.visible');
            if (typeof visibleOpenEditors !== 'number') {
                visibleOpenEditors = OpenEditorsView.DEFAULT_VISIBLE_OPEN_EDITORS;
            }
            return this.computeMinExpandedBodySize(visibleOpenEditors);
        };
        OpenEditorsView.prototype.computeMinExpandedBodySize = function (visibleOpenEditors) {
            if (visibleOpenEditors === void 0) { visibleOpenEditors = OpenEditorsView.DEFAULT_VISIBLE_OPEN_EDITORS; }
            var itemsToShow = Math.min(Math.max(visibleOpenEditors, 1), this.elementCount);
            return itemsToShow * OpenEditorsDelegate.ITEM_HEIGHT;
        };
        OpenEditorsView.prototype.setStructuralRefreshDelay = function (delay) {
            this.structuralRefreshDelay = delay;
        };
        OpenEditorsView.prototype.getOptimalWidth = function () {
            var parentNode = this.list.getHTMLElement();
            var childNodes = [].slice.call(parentNode.querySelectorAll('.open-editor > a'));
            return dom.getLargestChildWidth(parentNode, childNodes);
        };
        OpenEditorsView.DEFAULT_VISIBLE_OPEN_EDITORS = 9;
        OpenEditorsView.ID = 'workbench.explorer.openEditorsView';
        OpenEditorsView.NAME = nls.localize({ key: 'openEditors', comment: ['Open is an adjective'] }, "Open Editors");
        OpenEditorsView = __decorate([
            __param(1, instantiation_1.IInstantiationService),
            __param(2, contextView_1.IContextMenuService),
            __param(3, textfiles_1.ITextFileService),
            __param(4, editorService_1.IEditorService),
            __param(5, editorGroupsService_1.IEditorGroupsService),
            __param(6, configuration_1.IConfigurationService),
            __param(7, keybinding_1.IKeybindingService),
            __param(8, untitledEditorService_1.IUntitledEditorService),
            __param(9, contextkey_1.IContextKeyService),
            __param(10, themeService_1.IThemeService),
            __param(11, telemetry_1.ITelemetryService),
            __param(12, actions_2.IMenuService)
        ], OpenEditorsView);
        return OpenEditorsView;
    }(panelViewlet_1.ViewletPanel));
    exports.OpenEditorsView = OpenEditorsView;
    var OpenEditorActionRunner = /** @class */ (function (_super) {
        __extends(OpenEditorActionRunner, _super);
        function OpenEditorActionRunner() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OpenEditorActionRunner.prototype.run = function (action, context) {
            return _super.prototype.run.call(this, action, { groupId: this.editor.groupId, editorIndex: this.editor.editorIndex });
        };
        return OpenEditorActionRunner;
    }(actions_1.ActionRunner));
    var OpenEditorsDelegate = /** @class */ (function () {
        function OpenEditorsDelegate() {
        }
        OpenEditorsDelegate.prototype.getHeight = function (element) {
            return OpenEditorsDelegate.ITEM_HEIGHT;
        };
        OpenEditorsDelegate.prototype.getTemplateId = function (element) {
            if (element instanceof explorerModel_1.OpenEditor) {
                return OpenEditorRenderer.ID;
            }
            return EditorGroupRenderer.ID;
        };
        OpenEditorsDelegate.ITEM_HEIGHT = 22;
        return OpenEditorsDelegate;
    }());
    /**
     * Check if the item being dragged is one of the supported types that can be dropped on an
     * open editor or editor group. Fixes https://github.com/Microsoft/vscode/issues/52344.
     * @param e
     * @returns true if dropping is supported.
     */
    function dropOnEditorSupported(e) {
        // DataTransfer types are automatically converted to lower case, except Files.
        var supportedTransferTypes = {
            openEditor: dnd_1.CodeDataTransfers.EDITORS.toLowerCase(),
            externalFile: 'Files',
            codeFile: dnd_1.CodeDataTransfers.FILES.toLowerCase()
        };
        if (e.dataTransfer.types.indexOf(supportedTransferTypes.openEditor) !== -1 ||
            e.dataTransfer.types.indexOf(supportedTransferTypes.externalFile) !== -1 ||
            // All Code files should already register as normal files, but just to be safe:
            e.dataTransfer.types.indexOf(supportedTransferTypes.codeFile) !== -1) {
            return true;
        }
        else {
            return false;
        }
    }
    var EditorGroupRenderer = /** @class */ (function () {
        function EditorGroupRenderer(keybindingService, instantiationService, editorGroupService) {
            this.keybindingService = keybindingService;
            this.instantiationService = instantiationService;
            this.editorGroupService = editorGroupService;
            this.transfer = dnd_1.LocalSelectionTransfer.getInstance();
            // noop
        }
        Object.defineProperty(EditorGroupRenderer.prototype, "templateId", {
            get: function () {
                return EditorGroupRenderer.ID;
            },
            enumerable: true,
            configurable: true
        });
        EditorGroupRenderer.prototype.renderTemplate = function (container) {
            var _this = this;
            var editorGroupTemplate = Object.create(null);
            editorGroupTemplate.root = dom.append(container, $('.editor-group'));
            editorGroupTemplate.name = dom.append(editorGroupTemplate.root, $('span.name'));
            editorGroupTemplate.actionBar = new actionbar_1.ActionBar(container);
            var saveAllInGroupAction = this.instantiationService.createInstance(fileActions_1.SaveAllInGroupAction, fileActions_1.SaveAllInGroupAction.ID, fileActions_1.SaveAllInGroupAction.LABEL);
            var saveAllInGroupKey = this.keybindingService.lookupKeybinding(saveAllInGroupAction.id);
            editorGroupTemplate.actionBar.push(saveAllInGroupAction, { icon: true, label: false, keybinding: saveAllInGroupKey ? saveAllInGroupKey.getLabel() : void 0 });
            var closeGroupAction = this.instantiationService.createInstance(fileActions_1.CloseGroupAction, fileActions_1.CloseGroupAction.ID, fileActions_1.CloseGroupAction.LABEL);
            var closeGroupActionKey = this.keybindingService.lookupKeybinding(closeGroupAction.id);
            editorGroupTemplate.actionBar.push(closeGroupAction, { icon: true, label: false, keybinding: closeGroupActionKey ? closeGroupActionKey.getLabel() : void 0 });
            editorGroupTemplate.toDispose = [];
            editorGroupTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_OVER, function (e) {
                if (dropOnEditorSupported(e)) {
                    dom.addClass(container, 'focused');
                }
            }));
            editorGroupTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_LEAVE, function () {
                dom.removeClass(container, 'focused');
            }));
            editorGroupTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DROP, function (e) {
                dom.removeClass(container, 'focused');
                if (_this.transfer.hasData(explorerModel_1.OpenEditor.prototype)) {
                    _this.transfer.getData(explorerModel_1.OpenEditor.prototype).forEach(function (oe) {
                        return oe.group.moveEditor(oe.editor, editorGroupTemplate.editorGroup, { preserveFocus: true });
                    });
                    _this.editorGroupService.activateGroup(editorGroupTemplate.editorGroup);
                }
                else {
                    var dropHandler = _this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: false });
                    dropHandler.handleDrop(e, function () { return editorGroupTemplate.editorGroup; }, function () { return editorGroupTemplate.editorGroup.focus(); });
                }
            }));
            return editorGroupTemplate;
        };
        EditorGroupRenderer.prototype.renderElement = function (editorGroup, index, templateData) {
            templateData.editorGroup = editorGroup;
            templateData.name.textContent = editorGroup.label;
            templateData.actionBar.context = { groupId: editorGroup.id };
        };
        EditorGroupRenderer.prototype.disposeElement = function () {
            // noop
        };
        EditorGroupRenderer.prototype.disposeTemplate = function (templateData) {
            templateData.actionBar.dispose();
            lifecycle_1.dispose(templateData.toDispose);
        };
        EditorGroupRenderer.ID = 'editorgroup';
        return EditorGroupRenderer;
    }());
    var OpenEditorRenderer = /** @class */ (function () {
        function OpenEditorRenderer(getSelectedElements, instantiationService, keybindingService, configurationService, editorGroupService) {
            this.getSelectedElements = getSelectedElements;
            this.instantiationService = instantiationService;
            this.keybindingService = keybindingService;
            this.configurationService = configurationService;
            this.editorGroupService = editorGroupService;
            this.transfer = dnd_1.LocalSelectionTransfer.getInstance();
            // noop
        }
        Object.defineProperty(OpenEditorRenderer.prototype, "templateId", {
            get: function () {
                return OpenEditorRenderer.ID;
            },
            enumerable: true,
            configurable: true
        });
        OpenEditorRenderer.prototype.renderTemplate = function (container) {
            var _this = this;
            var editorTemplate = Object.create(null);
            editorTemplate.container = container;
            editorTemplate.actionRunner = new OpenEditorActionRunner();
            editorTemplate.actionBar = new actionbar_1.ActionBar(container, { actionRunner: editorTemplate.actionRunner });
            container.draggable = true;
            var closeEditorAction = this.instantiationService.createInstance(editorActions_1.CloseEditorAction, editorActions_1.CloseEditorAction.ID, editorActions_1.CloseEditorAction.LABEL);
            var key = this.keybindingService.lookupKeybinding(closeEditorAction.id);
            editorTemplate.actionBar.push(closeEditorAction, { icon: true, label: false, keybinding: key ? key.getLabel() : void 0 });
            editorTemplate.root = this.instantiationService.createInstance(labels_1.EditorLabel, container, void 0);
            editorTemplate.toDispose = [];
            editorTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_START, function (e) {
                var dragged = _this.getSelectedElements().filter(function (e) { return e instanceof explorerModel_1.OpenEditor && !!e.getResource(); });
                var dragImage = document.createElement('div');
                e.dataTransfer.effectAllowed = 'copyMove';
                dragImage.className = 'monaco-tree-drag-image';
                dragImage.textContent = dragged.length === 1 ? editorTemplate.openEditor.editor.getName() : String(dragged.length);
                document.body.appendChild(dragImage);
                e.dataTransfer.setDragImage(dragImage, -10, -10);
                setTimeout(function () { return document.body.removeChild(dragImage); }, 0);
                _this.transfer.setData(dragged, explorerModel_1.OpenEditor.prototype);
                if (editorTemplate.openEditor && editorTemplate.openEditor.editor) {
                    _this.instantiationService.invokeFunction(dnd_1.fillResourceDataTransfers, dragged.map(function (d) { return d.getResource(); }), e);
                }
            }));
            editorTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_OVER, function (e) {
                if (dropOnEditorSupported(e)) {
                    dom.addClass(container, 'focused');
                }
            }));
            editorTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_LEAVE, function () {
                dom.removeClass(container, 'focused');
            }));
            editorTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DROP, function (e) {
                dom.removeClass(container, 'focused');
                var index = editorTemplate.openEditor.group.getIndexOfEditor(editorTemplate.openEditor.editor);
                if (_this.transfer.hasData(explorerModel_1.OpenEditor.prototype)) {
                    _this.transfer.getData(explorerModel_1.OpenEditor.prototype).forEach(function (oe, offset) {
                        return oe.group.moveEditor(oe.editor, editorTemplate.openEditor.group, { index: index + offset, preserveFocus: true });
                    });
                    _this.editorGroupService.activateGroup(editorTemplate.openEditor.group);
                }
                else {
                    var dropHandler = _this.instantiationService.createInstance(dnd_1.ResourcesDropHandler, { allowWorkspaceOpen: false });
                    dropHandler.handleDrop(e, function () { return editorTemplate.openEditor.group; }, function () { return editorTemplate.openEditor.group.focus(); }, index);
                }
            }));
            editorTemplate.toDispose.push(dom.addDisposableListener(container, dom.EventType.DRAG_END, function () {
                _this.transfer.clearData(explorerModel_1.OpenEditor.prototype);
            }));
            return editorTemplate;
        };
        OpenEditorRenderer.prototype.renderElement = function (editor, index, templateData) {
            templateData.openEditor = editor;
            templateData.actionRunner.editor = editor;
            editor.isDirty() ? dom.addClass(templateData.container, 'dirty') : dom.removeClass(templateData.container, 'dirty');
            templateData.root.setEditor(editor.editor, {
                italic: editor.isPreview(),
                extraClasses: ['open-editor'],
                fileDecorations: this.configurationService.getValue().explorer.decorations
            });
        };
        OpenEditorRenderer.prototype.disposeElement = function () {
            // noop
        };
        OpenEditorRenderer.prototype.disposeTemplate = function (templateData) {
            templateData.actionBar.dispose();
            templateData.root.dispose();
            templateData.actionRunner.dispose();
            lifecycle_1.dispose(templateData.toDispose);
        };
        OpenEditorRenderer.ID = 'openeditor';
        return OpenEditorRenderer;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

































define(__m[406/*vs/workbench/parts/files/electron-browser/explorerViewlet*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,8/*vs/base/browser/dom*/,57/*vs/workbench/parts/files/common/files*/,221/*vs/workbench/browser/parts/views/viewsViewlet*/,7/*vs/platform/configuration/common/configuration*/,228/*vs/workbench/parts/files/electron-browser/views/explorerViewer*/,429/*vs/workbench/parts/files/electron-browser/views/explorerView*/,267/*vs/workbench/parts/files/electron-browser/views/emptyView*/,408/*vs/workbench/parts/files/electron-browser/views/openEditorsView*/,44/*vs/platform/storage/common/storage*/,3/*vs/platform/instantiation/common/instantiation*/,70/*vs/workbench/services/extensions/common/extensions*/,20/*vs/platform/workspace/common/workspace*/,32/*vs/platform/telemetry/common/telemetry*/,368/*vs/platform/instantiation/common/serviceCollection*/,10/*vs/platform/contextkey/common/contextkey*/,14/*vs/platform/theme/common/themeService*/,108/*vs/workbench/common/views*/,34/*vs/platform/contextview/browser/contextView*/,4/*vs/base/common/lifecycle*/,49/*vs/workbench/services/part/common/partService*/,235/*vs/workbench/services/editor/browser/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,11/*vs/workbench/services/editor/common/editorService*/,65/*vs/base/common/keyCodes*/,258/*vs/css!vs/workbench/parts/files/electron-browser/media/explorerviewlet*/]), function (require, exports, nls_1, DOM, files_1, viewsViewlet_1, configuration_1, explorerViewer_1, explorerView_1, emptyView_1, openEditorsView_1, storage_1, instantiation_1, extensions_1, workspace_1, telemetry_1, serviceCollection_1, contextkey_1, themeService_1, views_1, contextView_1, lifecycle_1, partService_1, editorService_1, editorGroupsService_1, editorService_2, keyCodes_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExplorerViewletViewsContribution = /** @class */ (function (_super) {
        __extends(ExplorerViewletViewsContribution, _super);
        function ExplorerViewletViewsContribution(workspaceContextService, configurationService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.workspaceContextService = workspaceContextService;
            _this.configurationService = configurationService;
            _this.registerViews();
            _this.openEditorsVisibleContextKey = files_1.OpenEditorsVisibleContext.bindTo(contextKeyService);
            _this.updateOpenEditorsVisibility();
            _this._register(workspaceContextService.onDidChangeWorkbenchState(function () { return _this.registerViews(); }));
            _this._register(workspaceContextService.onDidChangeWorkspaceFolders(function () { return _this.registerViews(); }));
            _this._register(_this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(e); }));
            return _this;
        }
        ExplorerViewletViewsContribution.prototype.registerViews = function () {
            var viewDescriptors = views_1.ViewsRegistry.getViews(files_1.VIEW_CONTAINER);
            var viewDescriptorsToRegister = [];
            var viewDescriptorsToDeregister = [];
            var openEditorsViewDescriptor = this.createOpenEditorsViewDescriptor();
            var openEditorsViewDescriptorExists = viewDescriptors.some(function (v) { return v.id === openEditorsViewDescriptor.id; });
            var explorerViewDescriptor = this.createExplorerViewDescriptor();
            var explorerViewDescriptorExists = viewDescriptors.some(function (v) { return v.id === explorerViewDescriptor.id; });
            var emptyViewDescriptor = this.createEmptyViewDescriptor();
            var emptyViewDescriptorExists = viewDescriptors.some(function (v) { return v.id === emptyViewDescriptor.id; });
            if (!openEditorsViewDescriptorExists) {
                viewDescriptorsToRegister.push(openEditorsViewDescriptor);
            }
            if (this.workspaceContextService.getWorkbenchState() === 1 /* EMPTY */ || this.workspaceContextService.getWorkspace().folders.length === 0) {
                if (explorerViewDescriptorExists) {
                    viewDescriptorsToDeregister.push(explorerViewDescriptor.id);
                }
                if (!emptyViewDescriptorExists) {
                    viewDescriptorsToRegister.push(emptyViewDescriptor);
                }
            }
            else {
                if (emptyViewDescriptorExists) {
                    viewDescriptorsToDeregister.push(emptyViewDescriptor.id);
                }
                if (!explorerViewDescriptorExists) {
                    viewDescriptorsToRegister.push(explorerViewDescriptor);
                }
            }
            if (viewDescriptorsToRegister.length) {
                views_1.ViewsRegistry.registerViews(viewDescriptorsToRegister);
            }
            if (viewDescriptorsToDeregister.length) {
                views_1.ViewsRegistry.deregisterViews(viewDescriptorsToDeregister, files_1.VIEW_CONTAINER);
            }
        };
        ExplorerViewletViewsContribution.prototype.createOpenEditorsViewDescriptor = function () {
            return {
                id: openEditorsView_1.OpenEditorsView.ID,
                name: openEditorsView_1.OpenEditorsView.NAME,
                container: files_1.VIEW_CONTAINER,
                ctor: openEditorsView_1.OpenEditorsView,
                order: 0,
                when: files_1.OpenEditorsVisibleCondition,
                canToggleVisibility: true,
                focusCommand: {
                    id: 'workbench.files.action.focusOpenEditorsView',
                    keybindings: { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 35 /* KEY_E */) }
                }
            };
        };
        ExplorerViewletViewsContribution.prototype.createEmptyViewDescriptor = function () {
            return {
                id: emptyView_1.EmptyView.ID,
                name: emptyView_1.EmptyView.NAME,
                container: files_1.VIEW_CONTAINER,
                ctor: emptyView_1.EmptyView,
                order: 1,
                canToggleVisibility: false
            };
        };
        ExplorerViewletViewsContribution.prototype.createExplorerViewDescriptor = function () {
            return {
                id: explorerView_1.ExplorerView.ID,
                name: nls_1.localize('folders', "Folders"),
                container: files_1.VIEW_CONTAINER,
                ctor: explorerView_1.ExplorerView,
                order: 1,
                canToggleVisibility: false
            };
        };
        ExplorerViewletViewsContribution.prototype.onConfigurationUpdated = function (e) {
            if (e.affectsConfiguration('explorer.openEditors.visible')) {
                this.updateOpenEditorsVisibility();
            }
        };
        ExplorerViewletViewsContribution.prototype.updateOpenEditorsVisibility = function () {
            this.openEditorsVisibleContextKey.set(this.workspaceContextService.getWorkbenchState() === 1 /* EMPTY */ || this.configurationService.getValue('explorer.openEditors.visible') !== 0);
        };
        ExplorerViewletViewsContribution = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, contextkey_1.IContextKeyService)
        ], ExplorerViewletViewsContribution);
        return ExplorerViewletViewsContribution;
    }(lifecycle_1.Disposable));
    exports.ExplorerViewletViewsContribution = ExplorerViewletViewsContribution;
    var ExplorerViewlet = /** @class */ (function (_super) {
        __extends(ExplorerViewlet, _super);
        function ExplorerViewlet(partService, telemetryService, contextService, storageService, editorService, editorGroupService, configurationService, instantiationService, contextKeyService, themeService, contextMenuService, extensionService) {
            var _this = _super.call(this, files_1.VIEWLET_ID, ExplorerViewlet.EXPLORER_VIEWS_STATE, true, configurationService, partService, telemetryService, storageService, instantiationService, themeService, contextMenuService, extensionService, contextService) || this;
            _this.contextService = contextService;
            _this.storageService = storageService;
            _this.editorService = editorService;
            _this.editorGroupService = editorGroupService;
            _this.instantiationService = instantiationService;
            _this.viewletState = new explorerViewer_1.FileViewletState();
            _this.viewletVisibleContextKey = files_1.ExplorerViewletVisibleContext.bindTo(contextKeyService);
            _this._register(_this.contextService.onDidChangeWorkspaceName(function (e) { return _this.updateTitleArea(); }));
            return _this;
        }
        ExplorerViewlet.prototype.create = function (parent) {
            return _super.prototype.create.call(this, parent).then(function () {
                DOM.addClass(parent, 'explorer-viewlet');
            });
        };
        ExplorerViewlet.prototype.createView = function (viewDescriptor, options) {
            var _this = this;
            if (viewDescriptor.id === explorerView_1.ExplorerView.ID) {
                // Create a delegating editor service for the explorer to be able to delay the refresh in the opened
                // editors view above. This is a workaround for being able to double click on a file to make it pinned
                // without causing the animation in the opened editors view to kick in and change scroll position.
                // We try to be smart and only use the delay if we recognize that the user action is likely to cause
                // a new entry in the opened editors view.
                var delegatingEditorService = this.instantiationService.createInstance(editorService_1.DelegatingEditorService);
                delegatingEditorService.setEditorOpenHandler(function (group, editor, options) {
                    var openEditorsView = _this.getOpenEditorsView();
                    if (openEditorsView) {
                        var delay = 0;
                        var config = _this.configurationService.getValue();
                        var delayEditorOpeningInOpenedEditors = !!config.workbench.editor.enablePreview; // No need to delay if preview is disabled
                        var activeGroup = _this.editorGroupService.activeGroup;
                        if (delayEditorOpeningInOpenedEditors && group === activeGroup && !activeGroup.previewEditor) {
                            delay = 250; // a new editor entry is likely because there is either no group or no preview in group
                        }
                        openEditorsView.setStructuralRefreshDelay(delay);
                    }
                    var onSuccessOrError = function (editor) {
                        var openEditorsView = _this.getOpenEditorsView();
                        if (openEditorsView) {
                            openEditorsView.setStructuralRefreshDelay(0);
                        }
                        return editor;
                    };
                    return _this.editorService.openEditor(editor, options, group).then(onSuccessOrError, onSuccessOrError);
                });
                var explorerInstantiator = this.instantiationService.createChild(new serviceCollection_1.ServiceCollection([editorService_2.IEditorService, delegatingEditorService]));
                return explorerInstantiator.createInstance(explorerView_1.ExplorerView, __assign({}, options, { viewletState: this.viewletState }));
            }
            return _super.prototype.createView.call(this, viewDescriptor, options);
        };
        ExplorerViewlet.prototype.getExplorerView = function () {
            return this.getView(explorerView_1.ExplorerView.ID);
        };
        ExplorerViewlet.prototype.getOpenEditorsView = function () {
            return this.getView(openEditorsView_1.OpenEditorsView.ID);
        };
        ExplorerViewlet.prototype.getEmptyView = function () {
            return this.getView(emptyView_1.EmptyView.ID);
        };
        ExplorerViewlet.prototype.setVisible = function (visible) {
            this.viewletVisibleContextKey.set(visible);
            return _super.prototype.setVisible.call(this, visible);
        };
        ExplorerViewlet.prototype.getActionRunner = function () {
            if (!this.actionRunner) {
                this.actionRunner = new explorerViewer_1.ActionRunner(this.viewletState);
            }
            return this.actionRunner;
        };
        ExplorerViewlet.prototype.getViewletState = function () {
            return this.viewletState;
        };
        ExplorerViewlet.prototype.focus = function () {
            var explorerView = this.getExplorerView();
            if (explorerView && explorerView.isExpanded()) {
                explorerView.focus();
            }
            else {
                _super.prototype.focus.call(this);
            }
        };
        ExplorerViewlet.EXPLORER_VIEWS_STATE = 'workbench.explorer.views.state';
        ExplorerViewlet = __decorate([
            __param(0, partService_1.IPartService),
            __param(1, telemetry_1.ITelemetryService),
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, storage_1.IStorageService),
            __param(4, editorService_2.IEditorService),
            __param(5, editorGroupsService_1.IEditorGroupsService),
            __param(6, configuration_1.IConfigurationService),
            __param(7, instantiation_1.IInstantiationService),
            __param(8, contextkey_1.IContextKeyService),
            __param(9, themeService_1.IThemeService),
            __param(10, contextView_1.IContextMenuService),
            __param(11, extensions_1.IExtensionService)
        ], ExplorerViewlet);
        return ExplorerViewlet;
    }(viewsViewlet_1.ViewContainerViewlet));
    exports.ExplorerViewlet = ExplorerViewlet;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[260/*vs/workbench/parts/files/electron-browser/files.contribution*/], __M([0/*require*/,1/*exports*/,12/*vs/base/common/uri*/,76/*vs/workbench/browser/viewlet*/,2/*vs/nls*/,23/*vs/platform/actions/common/actions*/,9/*vs/platform/registry/common/platform*/,90/*vs/platform/configuration/common/configurationRegistry*/,47/*vs/workbench/common/actions*/,107/*vs/workbench/common/contributions*/,13/*vs/workbench/common/editor*/,16/*vs/platform/files/common/files*/,57/*vs/workbench/parts/files/common/files*/,377/*vs/workbench/parts/files/browser/editors/fileEditorTracker*/,276/*vs/workbench/parts/files/electron-browser/saveErrorHandler*/,125/*vs/workbench/parts/files/common/editors/fileEditorInput*/,398/*vs/workbench/parts/files/browser/editors/textFileEditor*/,376/*vs/workbench/parts/files/browser/editors/binaryFileEditor*/,120/*vs/platform/instantiation/common/descriptors*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,18/*vs/base/common/platform*/,424/*vs/workbench/parts/files/common/dirtyFilesTracker*/,406/*vs/workbench/parts/files/electron-browser/explorerViewlet*/,105/*vs/workbench/browser/editor*/,185/*vs/workbench/common/editor/dataUriEditorInput*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,59/*vs/platform/label/common/label*/,24/*vs/base/common/paths*/,49/*vs/workbench/services/part/common/partService*/]), function (require, exports, uri_1, viewlet_1, nls, actions_1, platform_1, configurationRegistry_1, actions_2, contributions_1, editor_1, files_1, files_2, fileEditorTracker_1, saveErrorHandler_1, fileEditorInput_1, textFileEditor_1, binaryFileEditor_1, descriptors_1, viewlet_2, platform, dirtyFilesTracker_1, explorerViewlet_1, editor_2, dataUriEditorInput_1, editorService_1, editorGroupsService_1, label_1, paths_1, partService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // Viewlet Action
    var OpenExplorerViewletAction = /** @class */ (function (_super) {
        __extends(OpenExplorerViewletAction, _super);
        function OpenExplorerViewletAction(id, label, viewletService, editorGroupService, partService) {
            return _super.call(this, id, label, files_2.VIEWLET_ID, viewletService, editorGroupService, partService) || this;
        }
        OpenExplorerViewletAction.ID = files_2.VIEWLET_ID;
        OpenExplorerViewletAction.LABEL = nls.localize('showExplorerViewlet', "Show Explorer");
        OpenExplorerViewletAction = __decorate([
            __param(2, viewlet_2.IViewletService),
            __param(3, editorGroupsService_1.IEditorGroupsService),
            __param(4, partService_1.IPartService)
        ], OpenExplorerViewletAction);
        return OpenExplorerViewletAction;
    }(viewlet_1.ShowViewletAction));
    exports.OpenExplorerViewletAction = OpenExplorerViewletAction;
    var FileUriLabelContribution = /** @class */ (function () {
        function FileUriLabelContribution(labelService) {
            labelService.registerFormatter('file://', {
                uri: {
                    label: '${authority}${path}',
                    separator: paths_1.nativeSep,
                    tildify: !platform.isWindows,
                    normalizeDriveLetter: platform.isWindows,
                    authorityPrefix: paths_1.nativeSep + paths_1.nativeSep
                },
                workspace: {
                    suffix: ''
                }
            });
        }
        FileUriLabelContribution = __decorate([
            __param(0, label_1.ILabelService)
        ], FileUriLabelContribution);
        return FileUriLabelContribution;
    }());
    // Register Viewlet
    platform_1.Registry.as(viewlet_1.Extensions.Viewlets).registerViewlet(new viewlet_1.ViewletDescriptor(explorerViewlet_1.ExplorerViewlet, files_2.VIEWLET_ID, nls.localize('explore', "Explorer"), 'explore', 0));
    platform_1.Registry.as(viewlet_1.Extensions.Viewlets).setDefaultViewletId(files_2.VIEWLET_ID);
    var openViewletKb = {
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 35 /* KEY_E */
    };
    // Register Action to Open Viewlet
    var registry = platform_1.Registry.as(actions_2.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_1.SyncActionDescriptor(OpenExplorerViewletAction, OpenExplorerViewletAction.ID, OpenExplorerViewletAction.LABEL, openViewletKb), 'View: Show Explorer', nls.localize('view', "View"));
    // Register file editors
    platform_1.Registry.as(editor_2.Extensions.Editors).registerEditor(new editor_2.EditorDescriptor(textFileEditor_1.TextFileEditor, textFileEditor_1.TextFileEditor.ID, nls.localize('textFileEditor', "Text File Editor")), [
        new descriptors_1.SyncDescriptor(fileEditorInput_1.FileEditorInput)
    ]);
    platform_1.Registry.as(editor_2.Extensions.Editors).registerEditor(new editor_2.EditorDescriptor(binaryFileEditor_1.BinaryFileEditor, binaryFileEditor_1.BinaryFileEditor.ID, nls.localize('binaryFileEditor', "Binary File Editor")), [
        new descriptors_1.SyncDescriptor(fileEditorInput_1.FileEditorInput),
        new descriptors_1.SyncDescriptor(dataUriEditorInput_1.DataUriEditorInput)
    ]);
    // Register default file input factory
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerFileInputFactory({
        createFileInput: function (resource, encoding, instantiationService) {
            return instantiationService.createInstance(fileEditorInput_1.FileEditorInput, resource, encoding);
        },
        isFileInput: function (obj) {
            return obj instanceof fileEditorInput_1.FileEditorInput;
        }
    });
    // Register Editor Input Factory
    var FileEditorInputFactory = /** @class */ (function () {
        function FileEditorInputFactory() {
        }
        FileEditorInputFactory.prototype.serialize = function (editorInput) {
            var fileEditorInput = editorInput;
            var resource = fileEditorInput.getResource();
            var fileInput = {
                resource: resource.toString(),
                resourceJSON: resource.toJSON(),
                encoding: fileEditorInput.getEncoding()
            };
            return JSON.stringify(fileInput);
        };
        FileEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            return instantiationService.invokeFunction(function (accessor) {
                var fileInput = JSON.parse(serializedEditorInput);
                var resource = !!fileInput.resourceJSON ? uri_1.URI.revive(fileInput.resourceJSON) : uri_1.URI.parse(fileInput.resource);
                var encoding = fileInput.encoding;
                return accessor.get(editorService_1.IEditorService).createInput({ resource: resource, encoding: encoding, forceFile: true });
            });
        };
        return FileEditorInputFactory;
    }());
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerEditorInputFactory(files_2.FILE_EDITOR_INPUT_ID, FileEditorInputFactory);
    // Register Explorer views
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(explorerViewlet_1.ExplorerViewletViewsContribution, 1 /* Starting */);
    // Register File Editor Tracker
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(fileEditorTracker_1.FileEditorTracker, 1 /* Starting */);
    // Register Save Error Handler
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(saveErrorHandler_1.SaveErrorHandler, 1 /* Starting */);
    // Register Dirty Files Tracker
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(dirtyFilesTracker_1.DirtyFilesTracker, 1 /* Starting */);
    // Register uri display for file uris
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(FileUriLabelContribution, 1 /* Starting */);
    // Configuration
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    configurationRegistry.registerConfiguration({
        'id': 'files',
        'order': 9,
        'title': nls.localize('filesConfigurationTitle', "Files"),
        'type': 'object',
        'properties': {
            'files.exclude': {
                'type': 'object',
                'markdownDescription': nls.localize('exclude', "Configure glob patterns for excluding files and folders. For example, the files explorer decides which files and folders to show or hide based on this setting. Read more about glob patterns [here](https://code.visualstudio.com/docs/editor/codebasics#_advanced-search-options)."),
                'default': { '**/.git': true, '**/.svn': true, '**/.hg': true, '**/CVS': true, '**/.DS_Store': true },
                'scope': 3 /* RESOURCE */,
                'additionalProperties': {
                    'anyOf': [
                        {
                            'type': 'boolean',
                            'description': nls.localize('files.exclude.boolean', "The glob pattern to match file paths against. Set to true or false to enable or disable the pattern."),
                        },
                        {
                            'type': 'object',
                            'properties': {
                                'when': {
                                    'type': 'string',
                                    'pattern': '\\w*\\$\\(basename\\)\\w*',
                                    'default': '$(basename).ext',
                                    'description': nls.localize('files.exclude.when', "Additional check on the siblings of a matching file. Use $(basename) as variable for the matching file name.")
                                }
                            }
                        }
                    ]
                }
            },
            'files.associations': {
                'type': 'object',
                'markdownDescription': nls.localize('associations', "Configure file associations to languages (e.g. `\"*.extension\": \"html\"`). These have precedence over the default associations of the languages installed."),
            },
            'files.encoding': {
                'type': 'string',
                'overridable': true,
                'enum': Object.keys(files_1.SUPPORTED_ENCODINGS),
                'default': 'utf8',
                'description': nls.localize('encoding', "The default character set encoding to use when reading and writing files. This setting can also be configured per language."),
                'scope': 3 /* RESOURCE */,
                'enumDescriptions': Object.keys(files_1.SUPPORTED_ENCODINGS).map(function (key) { return files_1.SUPPORTED_ENCODINGS[key].labelLong; })
            },
            'files.autoGuessEncoding': {
                'type': 'boolean',
                'overridable': true,
                'default': false,
                'description': nls.localize('autoGuessEncoding', "When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language."),
                'scope': 3 /* RESOURCE */
            },
            'files.eol': {
                'type': 'string',
                'enum': [
                    '\n',
                    '\r\n'
                ],
                'enumDescriptions': [
                    nls.localize('eol.LF', "LF"),
                    nls.localize('eol.CRLF', "CRLF")
                ],
                'default': (platform.isLinux || platform.isMacintosh) ? '\n' : '\r\n',
                'description': nls.localize('eol', "The default end of line character."),
                'scope': 3 /* RESOURCE */
            },
            'files.enableTrash': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize('useTrash', "Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently.")
            },
            'files.trimTrailingWhitespace': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize('trimTrailingWhitespace', "When enabled, will trim trailing whitespace when saving a file."),
                'overridable': true,
                'scope': 3 /* RESOURCE */
            },
            'files.insertFinalNewline': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize('insertFinalNewline', "When enabled, insert a final new line at the end of the file when saving it."),
                'overridable': true,
                'scope': 3 /* RESOURCE */
            },
            'files.trimFinalNewlines': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize('trimFinalNewlines', "When enabled, will trim all new lines after the final new line at the end of the file when saving it."),
                'overridable': true,
                'scope': 3 /* RESOURCE */
            },
            'files.autoSave': {
                'type': 'string',
                'enum': [files_1.AutoSaveConfiguration.OFF, files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE],
                'markdownEnumDescriptions': [
                    nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.off' }, "A dirty file is never automatically saved."),
                    nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.afterDelay' }, "A dirty file is automatically saved after the configured `#files.autoSaveDelay#`."),
                    nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.onFocusChange' }, "A dirty file is automatically saved when the editor loses focus."),
                    nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.onWindowChange' }, "A dirty file is automatically saved when the window loses focus.")
                ],
                'default': files_1.AutoSaveConfiguration.OFF,
                'markdownDescription': nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'autoSave' }, "Controls auto save of dirty files. Read more about autosave [here](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save).", files_1.AutoSaveConfiguration.OFF, files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE, files_1.AutoSaveConfiguration.AFTER_DELAY)
            },
            'files.autoSaveDelay': {
                'type': 'number',
                'default': 1000,
                'markdownDescription': nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'autoSaveDelay' }, "Controls the delay in ms after which a dirty file is saved automatically. Only applies when `#files.autoSave#` is set to `{0}`.", files_1.AutoSaveConfiguration.AFTER_DELAY)
            },
            'files.watcherExclude': {
                'type': 'object',
                'default': platform.isWindows /* https://github.com/Microsoft/vscode/issues/23954 */ ? { '**/.git/objects/**': true, '**/.git/subtree-cache/**': true, '**/node_modules/*/**': true } : { '**/.git/objects/**': true, '**/.git/subtree-cache/**': true, '**/node_modules/**': true },
                'description': nls.localize('watcherExclude', "Configure glob patterns of file paths to exclude from file watching. Patterns must match on absolute paths (i.e. prefix with ** or the full path to match properly). Changing this setting requires a restart. When you experience Code consuming lots of cpu time on startup, you can exclude large folders to reduce the initial load."),
                'scope': 3 /* RESOURCE */
            },
            'files.hotExit': {
                'type': 'string',
                'enum': [files_1.HotExitConfiguration.OFF, files_1.HotExitConfiguration.ON_EXIT, files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE],
                'default': files_1.HotExitConfiguration.ON_EXIT,
                'markdownEnumDescriptions': [
                    nls.localize('hotExit.off', 'Disable hot exit.'),
                    nls.localize('hotExit.onExit', 'Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu). All windows with backups will be restored upon next launch.'),
                    nls.localize('hotExit.onExitAndWindowClose', 'Hot exit will be triggered when the last window is closed on Windows/Linux or when the `workbench.action.quit` command is triggered (command palette, keybinding, menu), and also for any window with a folder opened regardless of whether it\'s the last window. All windows without folders opened will be restored upon next launch. To restore folder windows as they were before shutdown set `#window.restoreWindows#` to `all`.')
                ],
                'description': nls.localize('hotExit', "Controls whether unsaved files are remembered between sessions, allowing the save prompt when exiting the editor to be skipped.", files_1.HotExitConfiguration.ON_EXIT, files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE)
            },
            'files.useExperimentalFileWatcher': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize('useExperimentalFileWatcher', "Use the new experimental file watcher.")
            },
            'files.defaultLanguage': {
                'type': 'string',
                'description': nls.localize('defaultLanguage', "The default language mode that is assigned to new files.")
            },
            'files.maxMemoryForLargeFilesMB': {
                'type': 'number',
                'default': 4096,
                'markdownDescription': nls.localize('maxMemoryForLargeFilesMB', "Controls the memory available to VS Code after restart when trying to open large files. Same effect as specifying `--max-memory=NEWSIZE` on the command line.")
            }
        }
    });
    configurationRegistry.registerConfiguration({
        id: 'editor',
        order: 5,
        title: nls.localize('editorConfigurationTitle', "Editor"),
        type: 'object',
        properties: {
            'editor.formatOnSave': {
                'type': 'boolean',
                // CODESANDBOX EDIT
                'default': true,
                'description': nls.localize('formatOnSave', "Format a file on save. A formatter must be available, the file must not be auto-saved, and editor must not be shutting down."),
                'overridable': true,
                'scope': 3 /* RESOURCE */
            },
            'editor.formatOnSaveTimeout': {
                'type': 'number',
                'default': 750,
                'description': nls.localize('formatOnSaveTimeout', "Timeout in milliseconds after which the formatting that is run on file save is cancelled."),
                'overridable': true,
                'scope': 3 /* RESOURCE */
            }
        }
    });
    configurationRegistry.registerConfiguration({
        'id': 'explorer',
        'order': 10,
        'title': nls.localize('explorerConfigurationTitle', "File Explorer"),
        'type': 'object',
        'properties': {
            'explorer.openEditors.visible': {
                'type': 'number',
                'description': nls.localize({ key: 'openEditorsVisible', comment: ['Open is an adjective'] }, "Number of editors shown in the Open Editors pane."),
                'default': 9
            },
            'explorer.autoReveal': {
                'type': 'boolean',
                'description': nls.localize('autoReveal', "Controls whether the explorer should automatically reveal and select files when opening them."),
                'default': true
            },
            'explorer.enableDragAndDrop': {
                'type': 'boolean',
                'description': nls.localize('enableDragAndDrop', "Controls whether the explorer should allow to move files and folders via drag and drop."),
                'default': true
            },
            'explorer.confirmDragAndDrop': {
                'type': 'boolean',
                'description': nls.localize('confirmDragAndDrop', "Controls whether the explorer should ask for confirmation to move files and folders via drag and drop."),
                'default': true
            },
            'explorer.confirmDelete': {
                'type': 'boolean',
                'description': nls.localize('confirmDelete', "Controls whether the explorer should ask for confirmation when deleting a file via the trash."),
                'default': true
            },
            'explorer.sortOrder': {
                'type': 'string',
                'enum': [files_2.SortOrderConfiguration.DEFAULT, files_2.SortOrderConfiguration.MIXED, files_2.SortOrderConfiguration.FILES_FIRST, files_2.SortOrderConfiguration.TYPE, files_2.SortOrderConfiguration.MODIFIED],
                'default': files_2.SortOrderConfiguration.DEFAULT,
                'enumDescriptions': [
                    nls.localize('sortOrder.default', 'Files and folders are sorted by their names, in alphabetical order. Folders are displayed before files.'),
                    nls.localize('sortOrder.mixed', 'Files and folders are sorted by their names, in alphabetical order. Files are interwoven with folders.'),
                    nls.localize('sortOrder.filesFirst', 'Files and folders are sorted by their names, in alphabetical order. Files are displayed before folders.'),
                    nls.localize('sortOrder.type', 'Files and folders are sorted by their extensions, in alphabetical order. Folders are displayed before files.'),
                    nls.localize('sortOrder.modified', 'Files and folders are sorted by last modified date, in descending order. Folders are displayed before files.')
                ],
                'description': nls.localize('sortOrder', "Controls sorting order of files and folders in the explorer.")
            },
            'explorer.decorations.colors': {
                type: 'boolean',
                description: nls.localize('explorer.decorations.colors', "Controls whether file decorations should use colors."),
                default: true
            },
            'explorer.decorations.badges': {
                type: 'boolean',
                description: nls.localize('explorer.decorations.badges', "Controls whether file decorations should use badges."),
                default: true
            },
        }
    });
    // View menu
    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {
        group: '3_views',
        command: {
            id: files_2.VIEWLET_ID,
            title: nls.localize({ key: 'miViewExplorer', comment: ['&& denotes a mnemonic'] }, "&&Explorer")
        },
        order: 1
    });
});























define(__m[250/*vs/workbench/parts/preferences/browser/preferencesActions*/], __M([0/*require*/,1/*exports*/,15/*vs/base/common/actions*/,4/*vs/base/common/lifecycle*/,12/*vs/base/common/uri*/,36/*vs/editor/common/services/modelService*/,41/*vs/editor/common/services/modeService*/,2/*vs/nls*/,37/*vs/platform/commands/common/commands*/,62/*vs/platform/quickinput/common/quickInput*/,20/*vs/platform/workspace/common/workspace*/,184/*vs/workbench/browser/actions/workspaceCommands*/,60/*vs/workbench/browser/labels*/,61/*vs/workbench/services/preferences/common/preferences*/]), function (require, exports, actions_1, lifecycle_1, uri_1, modelService_1, modeService_1, nls, commands_1, quickInput_1, workspace_1, workspaceCommands_1, labels_1, preferences_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var OpenRawDefaultSettingsAction = /** @class */ (function (_super) {
        __extends(OpenRawDefaultSettingsAction, _super);
        function OpenRawDefaultSettingsAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenRawDefaultSettingsAction.prototype.run = function (event) {
            return this.preferencesService.openRawDefaultSettings();
        };
        OpenRawDefaultSettingsAction.ID = 'workbench.action.openRawDefaultSettings';
        OpenRawDefaultSettingsAction.LABEL = nls.localize('openRawDefaultSettings', "Open Raw Default Settings");
        OpenRawDefaultSettingsAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenRawDefaultSettingsAction);
        return OpenRawDefaultSettingsAction;
    }(actions_1.Action));
    exports.OpenRawDefaultSettingsAction = OpenRawDefaultSettingsAction;
    var OpenSettings2Action = /** @class */ (function (_super) {
        __extends(OpenSettings2Action, _super);
        function OpenSettings2Action(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenSettings2Action.prototype.run = function (event) {
            return this.preferencesService.openSettings(false);
        };
        OpenSettings2Action.ID = 'workbench.action.openSettings2';
        OpenSettings2Action.LABEL = nls.localize('openSettings2', "Open Settings (UI)");
        OpenSettings2Action = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenSettings2Action);
        return OpenSettings2Action;
    }(actions_1.Action));
    exports.OpenSettings2Action = OpenSettings2Action;
    var OpenSettingsAction = /** @class */ (function (_super) {
        __extends(OpenSettingsAction, _super);
        function OpenSettingsAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenSettingsAction.prototype.run = function (event) {
            return this.preferencesService.openSettings();
        };
        OpenSettingsAction.ID = 'workbench.action.openSettings';
        OpenSettingsAction.LABEL = nls.localize('openSettings', "Open Settings");
        OpenSettingsAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenSettingsAction);
        return OpenSettingsAction;
    }(actions_1.Action));
    exports.OpenSettingsAction = OpenSettingsAction;
    var OpenSettingsJsonAction = /** @class */ (function (_super) {
        __extends(OpenSettingsJsonAction, _super);
        function OpenSettingsJsonAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenSettingsJsonAction.prototype.run = function (event) {
            return this.preferencesService.openSettings(true);
        };
        OpenSettingsJsonAction.ID = 'workbench.action.openSettingsJson';
        OpenSettingsJsonAction.LABEL = nls.localize('openSettingsJson', "Open Settings (JSON)");
        OpenSettingsJsonAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenSettingsJsonAction);
        return OpenSettingsJsonAction;
    }(actions_1.Action));
    exports.OpenSettingsJsonAction = OpenSettingsJsonAction;
    var OpenGlobalSettingsAction = /** @class */ (function (_super) {
        __extends(OpenGlobalSettingsAction, _super);
        function OpenGlobalSettingsAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenGlobalSettingsAction.prototype.run = function (event) {
            return this.preferencesService.openGlobalSettings();
        };
        OpenGlobalSettingsAction.ID = 'workbench.action.openGlobalSettings';
        OpenGlobalSettingsAction.LABEL = nls.localize('openGlobalSettings', "Open User Settings");
        OpenGlobalSettingsAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenGlobalSettingsAction);
        return OpenGlobalSettingsAction;
    }(actions_1.Action));
    exports.OpenGlobalSettingsAction = OpenGlobalSettingsAction;
    var OpenGlobalKeybindingsAction = /** @class */ (function (_super) {
        __extends(OpenGlobalKeybindingsAction, _super);
        function OpenGlobalKeybindingsAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenGlobalKeybindingsAction.prototype.run = function (event) {
            return this.preferencesService.openGlobalKeybindingSettings(false);
        };
        OpenGlobalKeybindingsAction.ID = 'workbench.action.openGlobalKeybindings';
        OpenGlobalKeybindingsAction.LABEL = nls.localize('openGlobalKeybindings', "Open Keyboard Shortcuts");
        OpenGlobalKeybindingsAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenGlobalKeybindingsAction);
        return OpenGlobalKeybindingsAction;
    }(actions_1.Action));
    exports.OpenGlobalKeybindingsAction = OpenGlobalKeybindingsAction;
    var OpenGlobalKeybindingsFileAction = /** @class */ (function (_super) {
        __extends(OpenGlobalKeybindingsFileAction, _super);
        function OpenGlobalKeybindingsFileAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenGlobalKeybindingsFileAction.prototype.run = function (event) {
            return this.preferencesService.openGlobalKeybindingSettings(true);
        };
        OpenGlobalKeybindingsFileAction.ID = 'workbench.action.openGlobalKeybindingsFile';
        OpenGlobalKeybindingsFileAction.LABEL = nls.localize('openGlobalKeybindingsFile', "Open Keyboard Shortcuts File");
        OpenGlobalKeybindingsFileAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenGlobalKeybindingsFileAction);
        return OpenGlobalKeybindingsFileAction;
    }(actions_1.Action));
    exports.OpenGlobalKeybindingsFileAction = OpenGlobalKeybindingsFileAction;
    var OpenDefaultKeybindingsFileAction = /** @class */ (function (_super) {
        __extends(OpenDefaultKeybindingsFileAction, _super);
        function OpenDefaultKeybindingsFileAction(id, label, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            return _this;
        }
        OpenDefaultKeybindingsFileAction.prototype.run = function (event) {
            return this.preferencesService.openDefaultKeybindingsFile();
        };
        OpenDefaultKeybindingsFileAction.ID = 'workbench.action.openDefaultKeybindingsFile';
        OpenDefaultKeybindingsFileAction.LABEL = nls.localize('openDefaultKeybindingsFile', "Open Default Keyboard Shortcuts File");
        OpenDefaultKeybindingsFileAction = __decorate([
            __param(2, preferences_1.IPreferencesService)
        ], OpenDefaultKeybindingsFileAction);
        return OpenDefaultKeybindingsFileAction;
    }(actions_1.Action));
    exports.OpenDefaultKeybindingsFileAction = OpenDefaultKeybindingsFileAction;
    var OpenWorkspaceSettingsAction = /** @class */ (function (_super) {
        __extends(OpenWorkspaceSettingsAction, _super);
        function OpenWorkspaceSettingsAction(id, label, preferencesService, workspaceContextService) {
            var _this = _super.call(this, id, label) || this;
            _this.preferencesService = preferencesService;
            _this.workspaceContextService = workspaceContextService;
            _this.disposables = [];
            _this.update();
            _this.workspaceContextService.onDidChangeWorkbenchState(function () { return _this.update(); }, _this, _this.disposables);
            return _this;
        }
        OpenWorkspaceSettingsAction.prototype.update = function () {
            this.enabled = this.workspaceContextService.getWorkbenchState() !== 1 /* EMPTY */;
        };
        OpenWorkspaceSettingsAction.prototype.run = function (event) {
            return this.preferencesService.openWorkspaceSettings();
        };
        OpenWorkspaceSettingsAction.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            _super.prototype.dispose.call(this);
        };
        OpenWorkspaceSettingsAction.ID = 'workbench.action.openWorkspaceSettings';
        OpenWorkspaceSettingsAction.LABEL = nls.localize('openWorkspaceSettings', "Open Workspace Settings");
        OpenWorkspaceSettingsAction = __decorate([
            __param(2, preferences_1.IPreferencesService),
            __param(3, workspace_1.IWorkspaceContextService)
        ], OpenWorkspaceSettingsAction);
        return OpenWorkspaceSettingsAction;
    }(actions_1.Action));
    exports.OpenWorkspaceSettingsAction = OpenWorkspaceSettingsAction;
    exports.OPEN_FOLDER_SETTINGS_COMMAND = '_workbench.action.openFolderSettings';
    exports.OPEN_FOLDER_SETTINGS_LABEL = nls.localize('openFolderSettings', "Open Folder Settings");
    var OpenFolderSettingsAction = /** @class */ (function (_super) {
        __extends(OpenFolderSettingsAction, _super);
        function OpenFolderSettingsAction(id, label, workspaceContextService, preferencesService, commandService) {
            var _this = _super.call(this, id, label) || this;
            _this.workspaceContextService = workspaceContextService;
            _this.preferencesService = preferencesService;
            _this.commandService = commandService;
            _this.disposables = [];
            _this.update();
            _this.workspaceContextService.onDidChangeWorkbenchState(function () { return _this.update(); }, _this, _this.disposables);
            _this.workspaceContextService.onDidChangeWorkspaceFolders(function () { return _this.update(); }, _this, _this.disposables);
            return _this;
        }
        OpenFolderSettingsAction.prototype.update = function () {
            this.enabled = this.workspaceContextService.getWorkbenchState() === 3 /* WORKSPACE */ && this.workspaceContextService.getWorkspace().folders.length > 0;
        };
        OpenFolderSettingsAction.prototype.run = function () {
            var _this = this;
            return this.commandService.executeCommand(workspaceCommands_1.PICK_WORKSPACE_FOLDER_COMMAND_ID)
                .then(function (workspaceFolder) {
                if (workspaceFolder) {
                    return _this.preferencesService.openFolderSettings(workspaceFolder.uri);
                }
                return null;
            });
        };
        OpenFolderSettingsAction.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            _super.prototype.dispose.call(this);
        };
        OpenFolderSettingsAction.ID = 'workbench.action.openFolderSettings';
        OpenFolderSettingsAction.LABEL = exports.OPEN_FOLDER_SETTINGS_LABEL;
        OpenFolderSettingsAction = __decorate([
            __param(2, workspace_1.IWorkspaceContextService),
            __param(3, preferences_1.IPreferencesService),
            __param(4, commands_1.ICommandService)
        ], OpenFolderSettingsAction);
        return OpenFolderSettingsAction;
    }(actions_1.Action));
    exports.OpenFolderSettingsAction = OpenFolderSettingsAction;
    var ConfigureLanguageBasedSettingsAction = /** @class */ (function (_super) {
        __extends(ConfigureLanguageBasedSettingsAction, _super);
        function ConfigureLanguageBasedSettingsAction(id, label, modelService, modeService, quickInputService, preferencesService) {
            var _this = _super.call(this, id, label) || this;
            _this.modelService = modelService;
            _this.modeService = modeService;
            _this.quickInputService = quickInputService;
            _this.preferencesService = preferencesService;
            return _this;
        }
        ConfigureLanguageBasedSettingsAction.prototype.run = function () {
            var _this = this;
            var languages = this.modeService.getRegisteredLanguageNames();
            var picks = languages.sort().map(function (lang, index) {
                var description = nls.localize('languageDescriptionConfigured', "({0})", _this.modeService.getModeIdForLanguageName(lang.toLowerCase()));
                // construct a fake resource to be able to show nice icons if any
                var fakeResource;
                var extensions = _this.modeService.getExtensions(lang);
                if (extensions && extensions.length) {
                    fakeResource = uri_1.URI.file(extensions[0]);
                }
                else {
                    var filenames = _this.modeService.getFilenames(lang);
                    if (filenames && filenames.length) {
                        fakeResource = uri_1.URI.file(filenames[0]);
                    }
                }
                return {
                    label: lang,
                    iconClasses: labels_1.getIconClasses(_this.modelService, _this.modeService, fakeResource),
                    description: description
                };
            });
            return this.quickInputService.pick(picks, { placeHolder: nls.localize('pickLanguage', "Select Language") })
                .then(function (pick) {
                if (pick) {
                    return _this.modeService.getOrCreateModeByLanguageName(pick.label)
                        .then(function (mode) { return _this.preferencesService.configureSettingsForLanguage(mode.getLanguageIdentifier().language); });
                }
                return undefined;
            });
        };
        ConfigureLanguageBasedSettingsAction.ID = 'workbench.action.configureLanguageBasedSettings';
        ConfigureLanguageBasedSettingsAction.LABEL = nls.localize('configureLanguageBasedSettings', "Configure Language Specific Settings...");
        ConfigureLanguageBasedSettingsAction = __decorate([
            __param(2, modelService_1.IModelService),
            __param(3, modeService_1.IModeService),
            __param(4, quickInput_1.IQuickInputService),
            __param(5, preferences_1.IPreferencesService)
        ], ConfigureLanguageBasedSettingsAction);
        return ConfigureLanguageBasedSettingsAction;
    }(actions_1.Action));
    exports.ConfigureLanguageBasedSettingsAction = ConfigureLanguageBasedSettingsAction;
});














define(__m[249/*vs/workbench/parts/preferences/electron-browser/preferences.contribution*/], __M([0/*require*/,1/*exports*/,2/*vs/nls*/,12/*vs/base/common/uri*/,9/*vs/platform/registry/common/platform*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,47/*vs/workbench/common/actions*/,13/*vs/workbench/common/editor*/,23/*vs/platform/actions/common/actions*/,80/*vs/platform/instantiation/common/extensions*/,65/*vs/base/common/keyCodes*/,120/*vs/platform/instantiation/common/descriptors*/,216/*vs/workbench/parts/preferences/browser/preferencesEditor*/,384/*vs/workbench/parts/preferences/electron-browser/settingsEditor2*/,205/*vs/workbench/services/preferences/common/preferencesEditorInput*/,391/*vs/workbench/parts/preferences/browser/keybindingsEditor*/,250/*vs/workbench/parts/preferences/browser/preferencesActions*/,109/*vs/workbench/parts/preferences/common/preferences*/,3/*vs/platform/instantiation/common/instantiation*/,107/*vs/workbench/common/contributions*/,357/*vs/workbench/parts/preferences/common/preferencesContribution*/,10/*vs/platform/contextkey/common/contextkey*/,11/*vs/workbench/services/editor/common/editorService*/,37/*vs/platform/commands/common/commands*/,105/*vs/workbench/browser/editor*/,230/*vs/workbench/parts/preferences/electron-browser/preferencesSearch*/,61/*vs/workbench/services/preferences/common/preferences*/,56/*vs/editor/browser/editorExtensions*/,211/*vs/editor/contrib/suggest/suggest*/,265/*vs/css!vs/workbench/parts/preferences/browser/media/preferences*/]), function (require, exports, nls, uri_1, platform_1, keybindingsRegistry_1, actions_1, editor_1, actions_2, extensions_1, keyCodes_1, descriptors_1, preferencesEditor_1, settingsEditor2_1, preferencesEditorInput_1, keybindingsEditor_1, preferencesActions_1, preferences_1, instantiation_1, contributions_1, preferencesContribution_1, contextkey_1, editorService_1, commands_1, editor_2, preferencesSearch_1, preferences_2, editorExtensions_1, suggest_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    extensions_1.registerSingleton(preferences_1.IPreferencesSearchService, preferencesSearch_1.PreferencesSearchService);
    platform_1.Registry.as(editor_2.Extensions.Editors).registerEditor(new editor_2.EditorDescriptor(preferencesEditor_1.PreferencesEditor, preferencesEditor_1.PreferencesEditor.ID, nls.localize('defaultPreferencesEditor', "Default Preferences Editor")), [
        new descriptors_1.SyncDescriptor(preferencesEditorInput_1.PreferencesEditorInput)
    ]);
    platform_1.Registry.as(editor_2.Extensions.Editors).registerEditor(new editor_2.EditorDescriptor(settingsEditor2_1.SettingsEditor2, settingsEditor2_1.SettingsEditor2.ID, nls.localize('settingsEditor2', "Settings Editor 2")), [
        new descriptors_1.SyncDescriptor(preferencesEditorInput_1.SettingsEditor2Input)
    ]);
    platform_1.Registry.as(editor_2.Extensions.Editors).registerEditor(new editor_2.EditorDescriptor(keybindingsEditor_1.KeybindingsEditor, keybindingsEditor_1.KeybindingsEditor.ID, nls.localize('keybindingsEditor', "Keybindings Editor")), [
        new descriptors_1.SyncDescriptor(preferencesEditorInput_1.KeybindingsEditorInput)
    ]);
    // Register Preferences Editor Input Factory
    var PreferencesEditorInputFactory = /** @class */ (function () {
        function PreferencesEditorInputFactory() {
        }
        PreferencesEditorInputFactory.prototype.serialize = function (editorInput) {
            var input = editorInput;
            if (input.details && input.master) {
                var registry_1 = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
                var detailsInputFactory = registry_1.getEditorInputFactory(input.details.getTypeId());
                var masterInputFactory = registry_1.getEditorInputFactory(input.master.getTypeId());
                if (detailsInputFactory && masterInputFactory) {
                    var detailsSerialized = detailsInputFactory.serialize(input.details);
                    var masterSerialized = masterInputFactory.serialize(input.master);
                    if (detailsSerialized && masterSerialized) {
                        return JSON.stringify({
                            name: input.getName(),
                            description: input.getDescription(),
                            detailsSerialized: detailsSerialized,
                            masterSerialized: masterSerialized,
                            detailsTypeId: input.details.getTypeId(),
                            masterTypeId: input.master.getTypeId()
                        });
                    }
                }
            }
            return null;
        };
        PreferencesEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            var deserialized = JSON.parse(serializedEditorInput);
            var registry = platform_1.Registry.as(editor_1.Extensions.EditorInputFactories);
            var detailsInputFactory = registry.getEditorInputFactory(deserialized.detailsTypeId);
            var masterInputFactory = registry.getEditorInputFactory(deserialized.masterTypeId);
            if (detailsInputFactory && masterInputFactory) {
                var detailsInput = detailsInputFactory.deserialize(instantiationService, deserialized.detailsSerialized);
                var masterInput = masterInputFactory.deserialize(instantiationService, deserialized.masterSerialized);
                if (detailsInput && masterInput) {
                    return new preferencesEditorInput_1.PreferencesEditorInput(deserialized.name, deserialized.description, detailsInput, masterInput);
                }
            }
            return null;
        };
        return PreferencesEditorInputFactory;
    }());
    var KeybindingsEditorInputFactory = /** @class */ (function () {
        function KeybindingsEditorInputFactory() {
        }
        KeybindingsEditorInputFactory.prototype.serialize = function (editorInput) {
            var input = editorInput;
            return JSON.stringify({
                name: input.getName(),
                typeId: input.getTypeId()
            });
        };
        KeybindingsEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            return instantiationService.createInstance(preferencesEditorInput_1.KeybindingsEditorInput);
        };
        return KeybindingsEditorInputFactory;
    }());
    var SettingsEditor2InputFactory = /** @class */ (function () {
        function SettingsEditor2InputFactory() {
        }
        SettingsEditor2InputFactory.prototype.serialize = function (input) {
            var serialized = {};
            return JSON.stringify(serialized);
        };
        SettingsEditor2InputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            return instantiationService.createInstance(preferencesEditorInput_1.SettingsEditor2Input);
        };
        return SettingsEditor2InputFactory;
    }());
    // Register Default Preferences Editor Input Factory
    var DefaultPreferencesEditorInputFactory = /** @class */ (function () {
        function DefaultPreferencesEditorInputFactory() {
        }
        DefaultPreferencesEditorInputFactory.prototype.serialize = function (editorInput) {
            var input = editorInput;
            var serialized = { resource: input.getResource().toString() };
            return JSON.stringify(serialized);
        };
        DefaultPreferencesEditorInputFactory.prototype.deserialize = function (instantiationService, serializedEditorInput) {
            var deserialized = JSON.parse(serializedEditorInput);
            return instantiationService.createInstance(preferencesEditorInput_1.DefaultPreferencesEditorInput, uri_1.URI.parse(deserialized.resource));
        };
        return DefaultPreferencesEditorInputFactory;
    }());
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerEditorInputFactory(preferencesEditorInput_1.PreferencesEditorInput.ID, PreferencesEditorInputFactory);
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerEditorInputFactory(preferencesEditorInput_1.DefaultPreferencesEditorInput.ID, DefaultPreferencesEditorInputFactory);
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerEditorInputFactory(preferencesEditorInput_1.KeybindingsEditorInput.ID, KeybindingsEditorInputFactory);
    platform_1.Registry.as(editor_1.Extensions.EditorInputFactories).registerEditorInputFactory(preferencesEditorInput_1.SettingsEditor2Input.ID, SettingsEditor2InputFactory);
    // Contribute Global Actions
    var category = nls.localize('preferences', "Preferences");
    var registry = platform_1.Registry.as(actions_1.Extensions.WorkbenchActions);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenRawDefaultSettingsAction, preferencesActions_1.OpenRawDefaultSettingsAction.ID, preferencesActions_1.OpenRawDefaultSettingsAction.LABEL), 'Preferences: Open Raw Default Settings', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenSettingsAction, preferencesActions_1.OpenSettingsAction.ID, preferencesActions_1.OpenSettingsAction.LABEL, { primary: 2048 /* CtrlCmd */ | 82 /* US_COMMA */ }), 'Preferences: Open Settings', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenSettingsJsonAction, preferencesActions_1.OpenSettingsJsonAction.ID, preferencesActions_1.OpenSettingsJsonAction.LABEL), 'Preferences: Open Settings (JSON)', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenSettings2Action, preferencesActions_1.OpenSettings2Action.ID, preferencesActions_1.OpenSettings2Action.LABEL), 'Preferences: Open Settings (UI)', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenGlobalSettingsAction, preferencesActions_1.OpenGlobalSettingsAction.ID, preferencesActions_1.OpenGlobalSettingsAction.LABEL), 'Preferences: Open User Settings', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenGlobalKeybindingsAction, preferencesActions_1.OpenGlobalKeybindingsAction.ID, preferencesActions_1.OpenGlobalKeybindingsAction.LABEL, { primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 49 /* KEY_S */) }), 'Preferences: Open Keyboard Shortcuts', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenDefaultKeybindingsFileAction, preferencesActions_1.OpenDefaultKeybindingsFileAction.ID, preferencesActions_1.OpenDefaultKeybindingsFileAction.LABEL), 'Preferences: Open Default Keyboard Shortcuts File', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.OpenGlobalKeybindingsFileAction, preferencesActions_1.OpenGlobalKeybindingsFileAction.ID, preferencesActions_1.OpenGlobalKeybindingsFileAction.LABEL, { primary: null }), 'Preferences: Open Keyboard Shortcuts File', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(preferencesActions_1.ConfigureLanguageBasedSettingsAction, preferencesActions_1.ConfigureLanguageBasedSettingsAction.ID, preferencesActions_1.ConfigureLanguageBasedSettingsAction.LABEL), 'Preferences: Configure Language Specific Settings...', category);
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_DEFINE,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 41 /* KEY_K */),
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.defineKeybinding(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_REMOVE,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: 20 /* Delete */,
        mac: {
            primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 1 /* Backspace */)
        },
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.removeKeybinding(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_RESET,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: null,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.resetKeybinding(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_SEARCH,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDINGS_SEARCH_FOCUS.toNegated()),
        primary: 2048 /* CtrlCmd */ | 36 /* KEY_F */,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.focusSearch();
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_RECORD_SEARCH_KEYS,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDINGS_SEARCH_FOCUS),
        primary: 512 /* Alt */ | 41 /* KEY_K */,
        mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 41 /* KEY_K */ },
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.recordSearchKeys();
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_SORTBY_PRECEDENCE,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR),
        primary: 512 /* Alt */ | 46 /* KEY_P */,
        mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 46 /* KEY_P */ },
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control && control instanceof keybindingsEditor_1.KeybindingsEditor) {
                control.toggleSortByPrecedence();
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_SHOW_SIMILAR,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: null,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control) {
                control.showSimilarKeybindings(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control) {
                control.copyKeybinding(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_COPY_COMMAND,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDING_FOCUS),
        primary: null,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control) {
                control.copyKeybindingCommand(control.activeKeybindingEntry);
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_FOCUS_KEYBINDINGS,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDINGS_SEARCH_FOCUS),
        primary: 18 /* DownArrow */,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control) {
                control.focusKeybindings();
            }
        }
    });
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(preferencesContribution_1.PreferencesContribution, 1 /* Starting */);
    commands_1.CommandsRegistry.registerCommand(preferencesActions_1.OPEN_FOLDER_SETTINGS_COMMAND, function (accessor, resource) {
        var preferencesService = accessor.get(preferences_2.IPreferencesService);
        return preferencesService.openFolderSettings(resource);
    });
    commands_1.CommandsRegistry.registerCommand(preferencesActions_1.OpenFolderSettingsAction.ID, function (serviceAccessor) {
        serviceAccessor.get(instantiation_1.IInstantiationService).createInstance(preferencesActions_1.OpenFolderSettingsAction, preferencesActions_1.OpenFolderSettingsAction.ID, preferencesActions_1.OpenFolderSettingsAction.LABEL).run();
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.CommandPalette, {
        command: {
            id: preferencesActions_1.OpenFolderSettingsAction.ID,
            title: { value: category + ": " + preferencesActions_1.OpenFolderSettingsAction.LABEL, original: 'Preferences: Open Folder Settings' },
        },
        when: new contextkey_1.RawContextKey('workbenchState', '').isEqualTo('workspace')
    });
    commands_1.CommandsRegistry.registerCommand(preferencesActions_1.OpenWorkspaceSettingsAction.ID, function (serviceAccessor) {
        serviceAccessor.get(instantiation_1.IInstantiationService).createInstance(preferencesActions_1.OpenWorkspaceSettingsAction, preferencesActions_1.OpenWorkspaceSettingsAction.ID, preferencesActions_1.OpenWorkspaceSettingsAction.LABEL).run();
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.CommandPalette, {
        command: {
            id: preferencesActions_1.OpenWorkspaceSettingsAction.ID,
            title: { value: category + ": " + preferencesActions_1.OpenWorkspaceSettingsAction.LABEL, original: 'Preferences: Open Workspace Settings' },
        },
        when: new contextkey_1.RawContextKey('workbenchState', '').notEqualsTo('empty')
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_CLEAR_SEARCH_RESULTS,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR, preferences_1.CONTEXT_KEYBINDINGS_SEARCH_FOCUS),
        primary: 9 /* Escape */,
        handler: function (accessor, args) {
            var control = accessor.get(editorService_1.IEditorService).activeControl;
            if (control) {
                control.clearSearchResults();
            }
        }
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.EditorTitle, {
        command: {
            id: preferences_1.KEYBINDINGS_EDITOR_COMMAND_CLEAR_SEARCH_RESULTS,
            title: nls.localize('clearInput', "Clear Keybindings Search Input"),
            iconLocation: {
                light: uri_1.URI.parse(require.toUrl("vs/workbench/parts/preferences/browser/media/clear.svg")),
                dark: uri_1.URI.parse(require.toUrl("vs/workbench/parts/preferences/browser/media/clear-inverse.svg"))
            },
            precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_SEARCH_VALUE)
        },
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR),
        group: 'navigation',
    });
    commands_1.CommandsRegistry.registerCommand(preferencesActions_1.OpenGlobalKeybindingsFileAction.ID, function (serviceAccessor) {
        serviceAccessor.get(instantiation_1.IInstantiationService).createInstance(preferencesActions_1.OpenGlobalKeybindingsFileAction, preferencesActions_1.OpenGlobalKeybindingsFileAction.ID, preferencesActions_1.OpenGlobalKeybindingsFileAction.LABEL).run();
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.EditorTitle, {
        command: {
            id: preferencesActions_1.OpenGlobalKeybindingsFileAction.ID,
            title: preferencesActions_1.OpenGlobalKeybindingsFileAction.LABEL,
            iconLocation: {
                light: uri_1.URI.parse(require.toUrl("vs/workbench/parts/preferences/browser/media/open-file.svg")),
                dark: uri_1.URI.parse(require.toUrl("vs/workbench/parts/preferences/browser/media/open-file-inverse.svg"))
            }
        },
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR),
        group: 'navigation',
    });
    commands_1.CommandsRegistry.registerCommand(preferences_1.KEYBINDINGS_EDITOR_SHOW_DEFAULT_KEYBINDINGS, function (serviceAccessor) {
        var control = serviceAccessor.get(editorService_1.IEditorService).activeControl;
        if (control) {
            control.search('@source:default');
        }
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.EditorTitle, {
        command: {
            id: preferences_1.KEYBINDINGS_EDITOR_SHOW_DEFAULT_KEYBINDINGS,
            title: nls.localize('showDefaultKeybindings', "Show Default Keybindings")
        },
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR),
        group: '1_keyboard_preferences_actions'
    });
    commands_1.CommandsRegistry.registerCommand(preferences_1.KEYBINDINGS_EDITOR_SHOW_USER_KEYBINDINGS, function (serviceAccessor) {
        var control = serviceAccessor.get(editorService_1.IEditorService).activeControl;
        if (control) {
            control.search('@source:user');
        }
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.EditorTitle, {
        command: {
            id: preferences_1.KEYBINDINGS_EDITOR_SHOW_USER_KEYBINDINGS,
            title: nls.localize('showUserKeybindings', "Show User Keybindings")
        },
        when: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_KEYBINDINGS_EDITOR),
        group: '1_keyboard_preferences_actions'
    });
    var SettingsCommand = /** @class */ (function (_super) {
        __extends(SettingsCommand, _super);
        function SettingsCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SettingsCommand.prototype.getPreferencesEditor = function (accessor) {
            var activeControl = accessor.get(editorService_1.IEditorService).activeControl;
            if (activeControl instanceof preferencesEditor_1.PreferencesEditor || activeControl instanceof settingsEditor2_1.SettingsEditor2) {
                return activeControl;
            }
            return null;
        };
        return SettingsCommand;
    }(editorExtensions_1.Command));
    var StartSearchDefaultSettingsCommand = /** @class */ (function (_super) {
        __extends(StartSearchDefaultSettingsCommand, _super);
        function StartSearchDefaultSettingsCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StartSearchDefaultSettingsCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor) {
                preferencesEditor.focusSearch();
            }
        };
        return StartSearchDefaultSettingsCommand;
    }(SettingsCommand));
    var startSearchCommand = new StartSearchDefaultSettingsCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_SEARCH,
        precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_SETTINGS_EDITOR),
        kbOpts: { primary: 2048 /* CtrlCmd */ | 36 /* KEY_F */, weight: 100 /* EditorContrib */ }
    });
    startSearchCommand.register();
    var ClearSearchResultsCommand = /** @class */ (function (_super) {
        __extends(ClearSearchResultsCommand, _super);
        function ClearSearchResultsCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ClearSearchResultsCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor) {
                preferencesEditor.clearSearchResults();
            }
        };
        return ClearSearchResultsCommand;
    }(SettingsCommand));
    var clearSearchResultsCommand = new ClearSearchResultsCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_CLEAR_SEARCH_RESULTS,
        precondition: preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS,
        kbOpts: { primary: 9 /* Escape */, weight: 100 /* EditorContrib */ }
    });
    clearSearchResultsCommand.register();
    var FocusSettingsFileEditorCommand = /** @class */ (function (_super) {
        __extends(FocusSettingsFileEditorCommand, _super);
        function FocusSettingsFileEditorCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FocusSettingsFileEditorCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof preferencesEditor_1.PreferencesEditor) {
                preferencesEditor.focusSettingsFileEditor();
            }
            else {
                preferencesEditor.focusSettings();
            }
        };
        return FocusSettingsFileEditorCommand;
    }(SettingsCommand));
    var focusSettingsFileEditorCommand = new FocusSettingsFileEditorCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_FOCUS_FILE,
        precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS, suggest_1.Context.Visible.toNegated()),
        kbOpts: { primary: 18 /* DownArrow */, weight: 100 /* EditorContrib */ }
    });
    focusSettingsFileEditorCommand.register();
    var focusSettingsFromSearchCommand = new FocusSettingsFileEditorCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_FOCUS_SETTINGS_FROM_SEARCH,
        precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS, suggest_1.Context.Visible.toNegated()),
        kbOpts: { primary: 18 /* DownArrow */, weight: 200 /* WorkbenchContrib */ }
    });
    focusSettingsFromSearchCommand.register();
    var FocusNextSearchResultCommand = /** @class */ (function (_super) {
        __extends(FocusNextSearchResultCommand, _super);
        function FocusNextSearchResultCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FocusNextSearchResultCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof preferencesEditor_1.PreferencesEditor) {
                preferencesEditor.focusNextResult();
            }
        };
        return FocusNextSearchResultCommand;
    }(SettingsCommand));
    var focusNextSearchResultCommand = new FocusNextSearchResultCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_FOCUS_NEXT_SETTING,
        precondition: preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS,
        kbOpts: { primary: 3 /* Enter */, weight: 100 /* EditorContrib */ }
    });
    focusNextSearchResultCommand.register();
    var FocusPreviousSearchResultCommand = /** @class */ (function (_super) {
        __extends(FocusPreviousSearchResultCommand, _super);
        function FocusPreviousSearchResultCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FocusPreviousSearchResultCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof preferencesEditor_1.PreferencesEditor) {
                preferencesEditor.focusPreviousResult();
            }
        };
        return FocusPreviousSearchResultCommand;
    }(SettingsCommand));
    var focusPreviousSearchResultCommand = new FocusPreviousSearchResultCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_FOCUS_PREVIOUS_SETTING,
        precondition: preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS,
        kbOpts: { primary: 1024 /* Shift */ | 3 /* Enter */, weight: 100 /* EditorContrib */ }
    });
    focusPreviousSearchResultCommand.register();
    var EditFocusedSettingCommand = /** @class */ (function (_super) {
        __extends(EditFocusedSettingCommand, _super);
        function EditFocusedSettingCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EditFocusedSettingCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof preferencesEditor_1.PreferencesEditor) {
                preferencesEditor.editFocusedPreference();
            }
        };
        return EditFocusedSettingCommand;
    }(SettingsCommand));
    var editFocusedSettingCommand = new EditFocusedSettingCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_EDIT_FOCUSED_SETTING,
        precondition: preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS,
        kbOpts: { primary: 2048 /* CtrlCmd */ | 84 /* US_DOT */, weight: 100 /* EditorContrib */ }
    });
    editFocusedSettingCommand.register();
    var FocusSettingsListCommand = /** @class */ (function (_super) {
        __extends(FocusSettingsListCommand, _super);
        function FocusSettingsListCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FocusSettingsListCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof settingsEditor2_1.SettingsEditor2) {
                preferencesEditor.focusSettings();
            }
        };
        return FocusSettingsListCommand;
    }(SettingsCommand));
    var focusSettingsListCommand = new FocusSettingsListCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_FOCUS_SETTINGS_LIST,
        precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_SETTINGS_EDITOR, preferences_1.CONTEXT_TOC_ROW_FOCUS),
        kbOpts: { primary: 3 /* Enter */, weight: 200 /* WorkbenchContrib */ }
    });
    focusSettingsListCommand.register();
    var ShowContextMenuCommand = /** @class */ (function (_super) {
        __extends(ShowContextMenuCommand, _super);
        function ShowContextMenuCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ShowContextMenuCommand.prototype.runCommand = function (accessor, args) {
            var preferencesEditor = this.getPreferencesEditor(accessor);
            if (preferencesEditor instanceof settingsEditor2_1.SettingsEditor2) {
                preferencesEditor.showContextMenu();
            }
        };
        return ShowContextMenuCommand;
    }(SettingsCommand));
    var showContextMenuCommand = new ShowContextMenuCommand({
        id: preferences_1.SETTINGS_EDITOR_COMMAND_SHOW_CONTEXT_MENU,
        precondition: contextkey_1.ContextKeyExpr.and(preferences_1.CONTEXT_SETTINGS_EDITOR),
        kbOpts: { primary: 1024 /* Shift */ | 67 /* F9 */, weight: 200 /* WorkbenchContrib */ }
    });
    showContextMenuCommand.register();
    // Preferences menu
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarPreferencesMenu, {
        group: '1_settings',
        command: {
            id: preferencesActions_1.OpenSettingsAction.ID,
            title: nls.localize({ key: 'miOpenSettings', comment: ['&& denotes a mnemonic'] }, "&&Settings")
        },
        order: 1
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarPreferencesMenu, {
        group: '2_keybindings',
        command: {
            id: preferencesActions_1.OpenGlobalKeybindingsAction.ID,
            title: nls.localize({ key: 'miOpenKeymap', comment: ['&& denotes a mnemonic'] }, "&&Keyboard Shortcuts")
        },
        order: 1
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[248/*vs/workbench/parts/search/browser/searchView*/], __M([0/*require*/,1/*exports*/,111/*vs/base/browser/browser*/,8/*vs/base/browser/dom*/,68/*vs/base/browser/keyboardEvent*/,352/*vs/base/browser/ui/aria/aria*/,17/*vs/base/common/async*/,25/*vs/base/common/errors*/,6/*vs/base/common/event*/,4/*vs/base/common/lifecycle*/,24/*vs/base/common/paths*/,18/*vs/base/common/platform*/,22/*vs/base/common/strings*/,5/*vs/base/common/winjs.base*/,45/*vs/editor/browser/editorBrowser*/,2/*vs/nls*/,7/*vs/platform/configuration/common/configuration*/,10/*vs/platform/contextkey/common/contextkey*/,34/*vs/platform/contextview/browser/contextView*/,92/*vs/platform/dialogs/common/dialogs*/,16/*vs/platform/files/common/files*/,3/*vs/platform/instantiation/common/instantiation*/,51/*vs/platform/list/browser/listService*/,28/*vs/platform/notification/common/notification*/,99/*vs/platform/progress/common/progress*/,71/*vs/platform/search/common/search*/,44/*vs/platform/storage/common/storage*/,32/*vs/platform/telemetry/common/telemetry*/,30/*vs/platform/theme/common/colorRegistry*/,14/*vs/platform/theme/common/themeService*/,20/*vs/platform/workspace/common/workspace*/,181/*vs/workbench/browser/actions/workspaceActions*/,84/*vs/workbench/browser/dnd*/,76/*vs/workbench/browser/viewlet*/,252/*vs/workbench/parts/search/browser/patternInputWidget*/,141/*vs/workbench/parts/search/browser/searchActions*/,389/*vs/workbench/parts/search/browser/searchResultsView*/,217/*vs/workbench/parts/search/browser/searchWidget*/,148/*vs/workbench/parts/search/common/constants*/,231/*vs/workbench/parts/search/common/queryBuilder*/,119/*vs/workbench/parts/search/common/replace*/,143/*vs/workbench/parts/search/common/search*/,106/*vs/workbench/parts/search/common/searchModel*/,11/*vs/workbench/services/editor/common/editorService*/,33/*vs/workbench/services/group/common/editorGroupsService*/,49/*vs/workbench/services/part/common/partService*/,61/*vs/workbench/services/preferences/common/preferences*/,52/*vs/workbench/services/untitled/common/untitledEditorService*/,274/*vs/css!vs/workbench/parts/search/browser/media/searchview*/]), function (require, exports, browser, dom, keyboardEvent_1, aria, async_1, errors, event_1, lifecycle_1, paths, env, strings, winjs_base_1, editorBrowser_1, nls, configuration_1, contextkey_1, contextView_1, dialogs_1, files_1, instantiation_1, listService_1, notification_1, progress_1, search_1, storage_1, telemetry_1, colorRegistry_1, themeService_1, workspace_1, workspaceActions_1, dnd_1, viewlet_1, patternInputWidget_1, searchActions_1, searchResultsView_1, searchWidget_1, Constants, queryBuilder_1, replace_1, search_2, searchModel_1, editorService_1, editorGroupsService_1, partService_1, preferences_1, untitledEditorService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var $ = dom.$;
    var SearchView = /** @class */ (function (_super) {
        __extends(SearchView, _super);
        function SearchView(partService, telemetryService, fileService, editorService, progressService, notificationService, dialogService, storageService, contextViewService, instantiationService, configurationService, contextService, searchWorkbenchService, contextKeyService, replaceService, untitledEditorService, preferencesService, themeService, searchHistoryService, editorGroupsService) {
            var _this = _super.call(this, search_1.VIEW_ID, configurationService, partService, telemetryService, themeService) || this;
            _this.fileService = fileService;
            _this.editorService = editorService;
            _this.progressService = progressService;
            _this.notificationService = notificationService;
            _this.dialogService = dialogService;
            _this.storageService = storageService;
            _this.contextViewService = contextViewService;
            _this.instantiationService = instantiationService;
            _this.contextService = contextService;
            _this.searchWorkbenchService = searchWorkbenchService;
            _this.contextKeyService = contextKeyService;
            _this.replaceService = replaceService;
            _this.untitledEditorService = untitledEditorService;
            _this.preferencesService = preferencesService;
            _this.themeService = themeService;
            _this.searchHistoryService = searchHistoryService;
            _this.editorGroupsService = editorGroupsService;
            _this.actions = [];
            _this.messageDisposables = [];
            _this.viewletVisible = Constants.SearchViewVisibleKey.bindTo(contextKeyService);
            _this.viewletFocused = Constants.SearchViewFocusedKey.bindTo(contextKeyService);
            _this.inputBoxFocused = Constants.InputBoxFocusedKey.bindTo(_this.contextKeyService);
            _this.inputPatternIncludesFocused = Constants.PatternIncludesFocusedKey.bindTo(_this.contextKeyService);
            _this.inputPatternExclusionsFocused = Constants.PatternExcludesFocusedKey.bindTo(_this.contextKeyService);
            _this.firstMatchFocused = Constants.FirstMatchFocusKey.bindTo(contextKeyService);
            _this.fileMatchOrMatchFocused = Constants.FileMatchOrMatchFocusKey.bindTo(contextKeyService);
            _this.fileMatchOrFolderMatchFocus = Constants.FileMatchOrFolderMatchFocusKey.bindTo(contextKeyService);
            _this.fileMatchFocused = Constants.FileFocusKey.bindTo(contextKeyService);
            _this.folderMatchFocused = Constants.FolderFocusKey.bindTo(contextKeyService);
            _this.matchFocused = Constants.MatchFocusKey.bindTo(_this.contextKeyService);
            _this.hasSearchResultsKey = Constants.HasSearchResults.bindTo(_this.contextKeyService);
            _this.queryBuilder = _this.instantiationService.createInstance(queryBuilder_1.QueryBuilder);
            _this.viewletSettings = _this.getMemento(storageService, 1 /* WORKSPACE */);
            _this._register(_this.fileService.onFileChanges(function (e) { return _this.onFilesChanged(e); }));
            _this._register(_this.untitledEditorService.onDidChangeDirty(function (e) { return _this.onUntitledDidChangeDirty(e); }));
            _this._register(_this.contextService.onDidChangeWorkbenchState(function () { return _this.onDidChangeWorkbenchState(); }));
            _this._register(_this.searchHistoryService.onDidClearHistory(function () { return _this.clearHistory(); }));
            _this.selectCurrentMatchEmitter = new event_1.Emitter();
            event_1.debounceEvent(_this.selectCurrentMatchEmitter.event, function (l, e) { return e; }, 100, /*leading=*/ true)(function () { return _this.selectCurrentMatch(); });
            _this.delayedRefresh = new async_1.Delayer(250);
            return _this;
        }
        SearchView.prototype.onDidChangeWorkbenchState = function () {
            if (this.contextService.getWorkbenchState() !== 1 /* EMPTY */ && this.searchWithoutFolderMessageElement) {
                dom.hide(this.searchWithoutFolderMessageElement);
            }
        };
        SearchView.prototype.create = function (parent) {
            var _this = this;
            _super.prototype.create.call(this, parent);
            this.viewModel = this._register(this.searchWorkbenchService.searchModel);
            var containerElement = dom.append(parent, $('.search-view'));
            this.searchWidgetsContainerElement = dom.append(containerElement, $('.search-widgets-container'));
            this.createSearchWidget(this.searchWidgetsContainerElement);
            var history = this.searchHistoryService.load();
            var filePatterns = this.viewletSettings['query.filePatterns'] || '';
            var patternExclusions = this.viewletSettings['query.folderExclusions'] || '';
            var patternExclusionsHistory = history.exclude || [];
            var patternIncludes = this.viewletSettings['query.folderIncludes'] || '';
            var patternIncludesHistory = history.include || [];
            var queryDetailsExpanded = this.viewletSettings['query.queryDetailsExpanded'] || '';
            var useExcludesAndIgnoreFiles = typeof this.viewletSettings['query.useExcludesAndIgnoreFiles'] === 'boolean' ?
                this.viewletSettings['query.useExcludesAndIgnoreFiles'] : true;
            this.queryDetails = dom.append(this.searchWidgetsContainerElement, $('.query-details'));
            // Toggle query details button
            this.toggleQueryDetailsButton = dom.append(this.queryDetails, $('.more', { tabindex: 0, role: 'button', title: nls.localize('moreSearch', "Toggle Search Details") }));
            this._register(dom.addDisposableListener(this.toggleQueryDetailsButton, dom.EventType.CLICK, function (e) {
                dom.EventHelper.stop(e);
                _this.toggleQueryDetails(!_this.isScreenReaderOptimized());
            }));
            this._register(dom.addDisposableListener(this.toggleQueryDetailsButton, dom.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                    dom.EventHelper.stop(e);
                    _this.toggleQueryDetails(false);
                }
            }));
            this._register(dom.addDisposableListener(this.toggleQueryDetailsButton, dom.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                if (event.equals(1024 /* Shift */ | 2 /* Tab */)) {
                    if (_this.searchWidget.isReplaceActive()) {
                        _this.searchWidget.focusReplaceAllAction();
                    }
                    else {
                        _this.searchWidget.focusRegexAction();
                    }
                    dom.EventHelper.stop(e);
                }
            }));
            // folder includes list
            var folderIncludesList = dom.append(this.queryDetails, $('.file-types.includes'));
            var filesToIncludeTitle = nls.localize('searchScope.includes', "files to include");
            dom.append(folderIncludesList, $('h4', undefined, filesToIncludeTitle));
            this.inputPatternIncludes = this._register(this.instantiationService.createInstance(patternInputWidget_1.PatternInputWidget, folderIncludesList, this.contextViewService, {
                ariaLabel: nls.localize('label.includes', 'Search Include Patterns'),
                history: patternIncludesHistory,
            }));
            this.inputPatternIncludes.setValue(patternIncludes);
            this.inputPatternIncludes.onSubmit(function () { return _this.onQueryChanged(true); });
            this.inputPatternIncludes.onCancel(function () { return _this.viewModel.cancelSearch(); }); // Cancel search without focusing the search widget
            this.trackInputBox(this.inputPatternIncludes.inputFocusTracker, this.inputPatternIncludesFocused);
            // excludes list
            var excludesList = dom.append(this.queryDetails, $('.file-types.excludes'));
            var excludesTitle = nls.localize('searchScope.excludes', "files to exclude");
            dom.append(excludesList, $('h4', undefined, excludesTitle));
            this.inputPatternExcludes = this._register(this.instantiationService.createInstance(patternInputWidget_1.ExcludePatternInputWidget, excludesList, this.contextViewService, {
                ariaLabel: nls.localize('label.excludes', 'Search Exclude Patterns'),
                history: patternExclusionsHistory,
            }));
            this.inputPatternExcludes.setValue(patternExclusions);
            this.inputPatternExcludes.setUseExcludesAndIgnoreFiles(useExcludesAndIgnoreFiles);
            this.inputPatternExcludes.onSubmit(function () { return _this.onQueryChanged(true); });
            this.inputPatternExcludes.onCancel(function () { return _this.viewModel.cancelSearch(); }); // Cancel search without focusing the search widget
            this.trackInputBox(this.inputPatternExcludes.inputFocusTracker, this.inputPatternExclusionsFocused);
            this.messagesElement = dom.append(containerElement, $('.messages'));
            if (this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
                this.showSearchWithoutFolderMessage();
            }
            this.createSearchResultsView(containerElement);
            this.actions = [
                this.instantiationService.createInstance(searchActions_1.RefreshAction, searchActions_1.RefreshAction.ID, searchActions_1.RefreshAction.LABEL),
                this.instantiationService.createInstance(searchActions_1.CollapseDeepestExpandedLevelAction, searchActions_1.CollapseDeepestExpandedLevelAction.ID, searchActions_1.CollapseDeepestExpandedLevelAction.LABEL),
                this.instantiationService.createInstance(searchActions_1.ClearSearchResultsAction, searchActions_1.ClearSearchResultsAction.ID, searchActions_1.ClearSearchResultsAction.LABEL)
            ];
            if (filePatterns !== '' || patternExclusions !== '' || patternIncludes !== '' || queryDetailsExpanded !== '' || !useExcludesAndIgnoreFiles) {
                this.toggleQueryDetails(true, true, true);
            }
            this._register(this.viewModel.searchResult.onChange(function (event) { return _this.onSearchResultsChanged(event); }));
            this._register(this.onDidFocus(function () { return _this.viewletFocused.set(true); }));
            this._register(this.onDidBlur(function () { return _this.viewletFocused.set(false); }));
            return winjs_base_1.TPromise.as(null);
        };
        Object.defineProperty(SearchView.prototype, "searchAndReplaceWidget", {
            get: function () {
                return this.searchWidget;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchView.prototype, "searchIncludePattern", {
            get: function () {
                return this.inputPatternIncludes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchView.prototype, "searchExcludePattern", {
            get: function () {
                return this.inputPatternExcludes;
            },
            enumerable: true,
            configurable: true
        });
        SearchView.prototype.updateActions = function () {
            for (var _i = 0, _a = this.actions; _i < _a.length; _i++) {
                var action = _a[_i];
                action.update();
            }
        };
        SearchView.prototype.isScreenReaderOptimized = function () {
            var detected = browser.getAccessibilitySupport() === 2 /* Enabled */;
            var config = this.configurationService.getValue('editor').accessibilitySupport;
            return config === 'on' || (config === 'auto' && detected);
        };
        SearchView.prototype.createSearchWidget = function (container) {
            var _this = this;
            var contentPattern = this.viewletSettings['query.contentPattern'] || '';
            var isRegex = this.viewletSettings['query.regex'] === true;
            var isWholeWords = this.viewletSettings['query.wholeWords'] === true;
            var isCaseSensitive = this.viewletSettings['query.caseSensitive'] === true;
            var history = this.searchHistoryService.load();
            var searchHistory = history.search || this.viewletSettings['query.searchHistory'] || [];
            var replaceHistory = history.replace || this.viewletSettings['query.replaceHistory'] || [];
            this.searchWidget = this._register(this.instantiationService.createInstance(searchWidget_1.SearchWidget, container, {
                value: contentPattern,
                isRegex: isRegex,
                isCaseSensitive: isCaseSensitive,
                isWholeWords: isWholeWords,
                searchHistory: searchHistory,
                replaceHistory: replaceHistory
            }));
            if (this.storageService.getBoolean(SearchView.SHOW_REPLACE_STORAGE_KEY, 1 /* WORKSPACE */, true)) {
                this.searchWidget.toggleReplace(true);
            }
            this._register(this.searchWidget.onSearchSubmit(function () { return _this.onQueryChanged(); }));
            this._register(this.searchWidget.onSearchCancel(function () { return _this.cancelSearch(); }));
            this._register(this.searchWidget.searchInput.onDidOptionChange(function () { return _this.onQueryChanged(true); }));
            this._register(this.searchWidget.onReplaceToggled(function () { return _this.onReplaceToggled(); }));
            this._register(this.searchWidget.onReplaceStateChange(function (state) {
                _this.viewModel.replaceActive = state;
                _this.tree.refresh();
            }));
            this._register(this.searchWidget.onReplaceValueChanged(function (value) {
                _this.viewModel.replaceString = _this.searchWidget.getReplaceValue();
                _this.delayedRefresh.trigger(function () { return _this.tree.refresh(); });
            }));
            this._register(this.searchWidget.onBlur(function () {
                _this.toggleQueryDetailsButton.focus();
            }));
            this._register(this.searchWidget.onReplaceAll(function () { return _this.replaceAll(); }));
            this.trackInputBox(this.searchWidget.searchInputFocusTracker);
            this.trackInputBox(this.searchWidget.replaceInputFocusTracker);
        };
        SearchView.prototype.trackInputBox = function (inputFocusTracker, contextKey) {
            var _this = this;
            this._register(inputFocusTracker.onDidFocus(function () {
                _this.inputBoxFocused.set(true);
                if (contextKey) {
                    contextKey.set(true);
                }
            }));
            this._register(inputFocusTracker.onDidBlur(function () {
                _this.inputBoxFocused.set(_this.searchWidget.searchInputHasFocus()
                    || _this.searchWidget.replaceInputHasFocus()
                    || _this.inputPatternIncludes.inputHasFocus()
                    || _this.inputPatternExcludes.inputHasFocus());
                if (contextKey) {
                    contextKey.set(false);
                }
            }));
        };
        SearchView.prototype.onReplaceToggled = function () {
            this.layout(this.size);
            var isReplaceShown = this.searchAndReplaceWidget.isReplaceShown();
            if (!isReplaceShown) {
                this.storageService.store(SearchView.SHOW_REPLACE_STORAGE_KEY, false, 1 /* WORKSPACE */);
            }
            else {
                this.storageService.remove(SearchView.SHOW_REPLACE_STORAGE_KEY, 1 /* WORKSPACE */);
            }
        };
        SearchView.prototype.onSearchResultsChanged = function (event) {
            if (this.isVisible()) {
                return this.refreshAndUpdateCount(event);
            }
            else {
                this.changedWhileHidden = true;
                return winjs_base_1.TPromise.wrap(null);
            }
        };
        SearchView.prototype.refreshAndUpdateCount = function (event) {
            var _this = this;
            return this.refreshTree(event).then(function () {
                _this.searchWidget.setReplaceAllActionState(!_this.viewModel.searchResult.isEmpty());
                _this.updateSearchResultCount();
            });
        };
        SearchView.prototype.refreshTree = function (event) {
            if (!event || event.added || event.removed) {
                return this.tree.refresh(this.viewModel.searchResult);
            }
            else {
                if (event.elements.length === 1) {
                    return this.tree.refresh(event.elements[0]);
                }
                else {
                    return this.tree.refresh(event.elements);
                }
            }
        };
        SearchView.prototype.replaceAll = function () {
            var _this = this;
            if (this.viewModel.searchResult.count() === 0) {
                return;
            }
            var progressRunner = this.progressService.show(100);
            var occurrences = this.viewModel.searchResult.count();
            var fileCount = this.viewModel.searchResult.fileCount();
            var replaceValue = this.searchWidget.getReplaceValue() || '';
            var afterReplaceAllMessage = this.buildAfterReplaceAllMessage(occurrences, fileCount, replaceValue);
            var confirmation = {
                title: nls.localize('replaceAll.confirmation.title', "Replace All"),
                message: this.buildReplaceAllConfirmationMessage(occurrences, fileCount, replaceValue),
                primaryButton: nls.localize('replaceAll.confirm.button', "&&Replace"),
                type: 'question'
            };
            this.dialogService.confirm(confirmation).then(function (res) {
                if (res.confirmed) {
                    _this.searchWidget.setReplaceAllActionState(false);
                    _this.viewModel.searchResult.replaceAll(progressRunner).then(function () {
                        progressRunner.done();
                        var messageEl = _this.clearMessage();
                        dom.append(messageEl, $('p', undefined, afterReplaceAllMessage));
                    }, function (error) {
                        progressRunner.done();
                        errors.isPromiseCanceledError(error);
                        _this.notificationService.error(error);
                    });
                }
            });
        };
        SearchView.prototype.buildAfterReplaceAllMessage = function (occurrences, fileCount, replaceValue) {
            if (occurrences === 1) {
                if (fileCount === 1) {
                    if (replaceValue) {
                        return nls.localize('replaceAll.occurrence.file.message', "Replaced {0} occurrence across {1} file with '{2}'.", occurrences, fileCount, replaceValue);
                    }
                    return nls.localize('removeAll.occurrence.file.message', "Replaced {0} occurrence across {1} file'.", occurrences, fileCount);
                }
                if (replaceValue) {
                    return nls.localize('replaceAll.occurrence.files.message', "Replaced {0} occurrence across {1} files with '{2}'.", occurrences, fileCount, replaceValue);
                }
                return nls.localize('removeAll.occurrence.files.message', "Replaced {0} occurrence across {1} files.", occurrences, fileCount);
            }
            if (fileCount === 1) {
                if (replaceValue) {
                    return nls.localize('replaceAll.occurrences.file.message', "Replaced {0} occurrences across {1} file with '{2}'.", occurrences, fileCount, replaceValue);
                }
                return nls.localize('removeAll.occurrences.file.message', "Replaced {0} occurrences across {1} file'.", occurrences, fileCount);
            }
            if (replaceValue) {
                return nls.localize('replaceAll.occurrences.files.message', "Replaced {0} occurrences across {1} files with '{2}'.", occurrences, fileCount, replaceValue);
            }
            return nls.localize('removeAll.occurrences.files.message', "Replaced {0} occurrences across {1} files.", occurrences, fileCount);
        };
        SearchView.prototype.buildReplaceAllConfirmationMessage = function (occurrences, fileCount, replaceValue) {
            if (occurrences === 1) {
                if (fileCount === 1) {
                    if (replaceValue) {
                        return nls.localize('removeAll.occurrence.file.confirmation.message', "Replace {0} occurrence across {1} file with '{2}'?", occurrences, fileCount, replaceValue);
                    }
                    return nls.localize('replaceAll.occurrence.file.confirmation.message', "Replace {0} occurrence across {1} file'?", occurrences, fileCount);
                }
                if (replaceValue) {
                    return nls.localize('removeAll.occurrence.files.confirmation.message', "Replace {0} occurrence across {1} files with '{2}'?", occurrences, fileCount, replaceValue);
                }
                return nls.localize('replaceAll.occurrence.files.confirmation.message', "Replace {0} occurrence across {1} files?", occurrences, fileCount);
            }
            if (fileCount === 1) {
                if (replaceValue) {
                    return nls.localize('removeAll.occurrences.file.confirmation.message', "Replace {0} occurrences across {1} file with '{2}'?", occurrences, fileCount, replaceValue);
                }
                return nls.localize('replaceAll.occurrences.file.confirmation.message', "Replace {0} occurrences across {1} file'?", occurrences, fileCount);
            }
            if (replaceValue) {
                return nls.localize('removeAll.occurrences.files.confirmation.message', "Replace {0} occurrences across {1} files with '{2}'?", occurrences, fileCount, replaceValue);
            }
            return nls.localize('replaceAll.occurrences.files.confirmation.message', "Replace {0} occurrences across {1} files?", occurrences, fileCount);
        };
        SearchView.prototype.clearMessage = function () {
            this.searchWithoutFolderMessageElement = void 0;
            dom.clearNode(this.messagesElement);
            dom.show(this.messagesElement);
            lifecycle_1.dispose(this.messageDisposables);
            this.messageDisposables = [];
            return dom.append(this.messagesElement, $('.message'));
        };
        SearchView.prototype.createSearchResultsView = function (container) {
            var _this = this;
            this.resultsElement = dom.append(container, $('.results.show-file-icons'));
            var dataSource = this._register(this.instantiationService.createInstance(searchResultsView_1.SearchDataSource));
            var renderer = this._register(this.instantiationService.createInstance(searchResultsView_1.SearchRenderer, this.getActionRunner(), this));
            var dnd = this.instantiationService.createInstance(dnd_1.SimpleFileResourceDragAndDrop, function (obj) { return obj instanceof searchModel_1.FileMatch ? obj.resource() : void 0; });
            this.tree = this._register(this.instantiationService.createInstance(listService_1.WorkbenchTree, this.resultsElement, {
                dataSource: dataSource,
                renderer: renderer,
                sorter: new searchResultsView_1.SearchSorter(),
                filter: new searchResultsView_1.SearchFilter(),
                controller: this.instantiationService.createInstance(searchResultsView_1.SearchTreeController),
                accessibilityProvider: this.instantiationService.createInstance(searchResultsView_1.SearchAccessibilityProvider),
                dnd: dnd
            }, {
                ariaLabel: nls.localize('treeAriaLabel', "Search Results"),
                showLoading: false
            }));
            this.tree.setInput(this.viewModel.searchResult);
            var searchResultsNavigator = this._register(new listService_1.TreeResourceNavigator(this.tree, { openOnFocus: true }));
            this._register(event_1.debounceEvent(searchResultsNavigator.openResource, function (last, event) { return event; }, 75, true)(function (options) {
                if (options.element instanceof searchModel_1.Match) {
                    var selectedMatch = options.element;
                    if (_this.currentSelectedFileMatch) {
                        _this.currentSelectedFileMatch.setSelectedMatch(null);
                    }
                    _this.currentSelectedFileMatch = selectedMatch.parent();
                    _this.currentSelectedFileMatch.setSelectedMatch(selectedMatch);
                    if (!(options.payload && options.payload.preventEditorOpen)) {
                        _this.onFocus(selectedMatch, options.editorOptions.preserveFocus, options.sideBySide, options.editorOptions.pinned);
                    }
                }
            }));
            this._register(event_1.anyEvent(this.tree.onDidFocus, this.tree.onDidChangeFocus)(function () {
                if (_this.tree.isDOMFocused()) {
                    var focus_1 = _this.tree.getFocus();
                    _this.firstMatchFocused.set(_this.tree.getNavigator().first() === focus_1);
                    _this.fileMatchOrMatchFocused.set(!!focus_1);
                    _this.fileMatchFocused.set(focus_1 instanceof searchModel_1.FileMatch);
                    _this.folderMatchFocused.set(focus_1 instanceof searchModel_1.FolderMatch);
                    _this.matchFocused.set(focus_1 instanceof searchModel_1.Match);
                    _this.fileMatchOrFolderMatchFocus.set(focus_1 instanceof searchModel_1.FileMatch || focus_1 instanceof searchModel_1.FolderMatch);
                }
            }));
            this._register(this.tree.onDidBlur(function (e) {
                _this.firstMatchFocused.reset();
                _this.fileMatchOrMatchFocused.reset();
                _this.fileMatchFocused.reset();
                _this.folderMatchFocused.reset();
                _this.matchFocused.reset();
                _this.fileMatchOrFolderMatchFocus.reset();
            }));
        };
        SearchView.prototype.selectCurrentMatch = function () {
            var focused = this.tree.getFocus();
            var eventPayload = { focusEditor: true };
            this.tree.setSelection([focused], eventPayload);
        };
        SearchView.prototype.selectNextMatch = function () {
            var selected = this.tree.getSelection()[0];
            // Expand the initial selected node, if needed
            if (selected instanceof searchModel_1.FileMatch) {
                if (!this.tree.isExpanded(selected)) {
                    this.tree.expand(selected);
                }
            }
            var navigator = this.tree.getNavigator(selected, /*subTreeOnly=*/ false);
            var next = navigator.next();
            if (!next) {
                // Reached the end - get a new navigator from the root.
                // .first and .last only work when subTreeOnly = true. Maybe there's a simpler way.
                navigator = this.tree.getNavigator(this.tree.getInput(), /*subTreeOnly*/ true);
                next = navigator.first();
            }
            // Expand and go past FileMatch nodes
            while (!(next instanceof searchModel_1.Match)) {
                if (!this.tree.isExpanded(next)) {
                    this.tree.expand(next);
                }
                // Select the FileMatch's first child
                next = navigator.next();
            }
            // Reveal the newly selected element
            if (next) {
                var eventPayload = { preventEditorOpen: true };
                this.tree.setFocus(next, eventPayload);
                this.tree.setSelection([next], eventPayload);
                this.tree.reveal(next);
                this.selectCurrentMatchEmitter.fire();
            }
        };
        SearchView.prototype.selectPreviousMatch = function () {
            var selected = this.tree.getSelection()[0];
            var navigator = this.tree.getNavigator(selected, /*subTreeOnly=*/ false);
            var prev = navigator.previous();
            // Expand and go past FileMatch nodes
            if (!(prev instanceof searchModel_1.Match)) {
                prev = navigator.previous();
                if (!prev) {
                    // Wrap around. Get a new tree starting from the root
                    navigator = this.tree.getNavigator(this.tree.getInput(), /*subTreeOnly*/ true);
                    prev = navigator.last();
                    // This is complicated because .last will set the navigator to the last FileMatch,
                    // so expand it and FF to its last child
                    this.tree.expand(prev);
                    var tmp = void 0;
                    while (tmp = navigator.next()) {
                        prev = tmp;
                    }
                }
                if (!(prev instanceof searchModel_1.Match)) {
                    // There is a second non-Match result, which must be a collapsed FileMatch.
                    // Expand it then select its last child.
                    navigator.next();
                    this.tree.expand(prev);
                    prev = navigator.previous();
                }
            }
            // Reveal the newly selected element
            if (prev) {
                var eventPayload = { preventEditorOpen: true };
                this.tree.setFocus(prev, eventPayload);
                this.tree.setSelection([prev], eventPayload);
                this.tree.reveal(prev);
                this.selectCurrentMatchEmitter.fire();
            }
        };
        SearchView.prototype.setVisible = function (visible) {
            var promise;
            this.viewletVisible.set(visible);
            if (visible) {
                if (this.changedWhileHidden) {
                    // Render if results changed while viewlet was hidden - #37818
                    this.refreshAndUpdateCount();
                    this.changedWhileHidden = false;
                }
                promise = _super.prototype.setVisible.call(this, visible);
                this.tree.onVisible();
            }
            else {
                this.tree.onHidden();
                promise = _super.prototype.setVisible.call(this, visible);
            }
            // Enable highlights if there are searchresults
            if (this.viewModel) {
                this.viewModel.searchResult.toggleHighlights(visible);
            }
            // Open focused element from results in case the editor area is otherwise empty
            if (visible && !this.editorService.activeEditor) {
                var focus_2 = this.tree.getFocus();
                if (focus_2) {
                    this.onFocus(focus_2, true);
                }
            }
            return promise;
        };
        SearchView.prototype.moveFocusToResults = function () {
            this.tree.domFocus();
        };
        SearchView.prototype.focus = function () {
            _super.prototype.focus.call(this);
            var updatedText = this.updateTextFromSelection();
            this.searchWidget.focus(undefined, undefined, updatedText);
        };
        SearchView.prototype.updateTextFromSelection = function (allowUnselectedWord) {
            if (allowUnselectedWord === void 0) { allowUnselectedWord = true; }
            var updatedText = false;
            var seedSearchStringFromSelection = this.configurationService.getValue('editor').find.seedSearchStringFromSelection;
            if (seedSearchStringFromSelection) {
                var selectedText = this.getSearchTextFromEditor(allowUnselectedWord);
                if (selectedText) {
                    if (this.searchWidget.searchInput.getRegex()) {
                        selectedText = strings.escapeRegExpCharacters(selectedText);
                    }
                    this.searchWidget.searchInput.setValue(selectedText);
                    updatedText = true;
                }
            }
            return updatedText;
        };
        SearchView.prototype.focusNextInputBox = function () {
            if (this.searchWidget.searchInputHasFocus()) {
                if (this.searchWidget.isReplaceShown()) {
                    this.searchWidget.focus(true, true);
                }
                else {
                    this.moveFocusFromSearchOrReplace();
                }
                return;
            }
            if (this.searchWidget.replaceInputHasFocus()) {
                this.moveFocusFromSearchOrReplace();
                return;
            }
            if (this.inputPatternIncludes.inputHasFocus()) {
                this.inputPatternExcludes.focus();
                this.inputPatternExcludes.select();
                return;
            }
            if (this.inputPatternExcludes.inputHasFocus()) {
                this.selectTreeIfNotSelected();
                return;
            }
        };
        SearchView.prototype.moveFocusFromSearchOrReplace = function () {
            if (this.showsFileTypes()) {
                this.toggleQueryDetails(true, this.showsFileTypes());
            }
            else {
                this.selectTreeIfNotSelected();
            }
        };
        SearchView.prototype.focusPreviousInputBox = function () {
            if (this.searchWidget.searchInputHasFocus()) {
                return;
            }
            if (this.searchWidget.replaceInputHasFocus()) {
                this.searchWidget.focus(true);
                return;
            }
            if (this.inputPatternIncludes.inputHasFocus()) {
                this.searchWidget.focus(true, true);
                return;
            }
            if (this.inputPatternExcludes.inputHasFocus()) {
                this.inputPatternIncludes.focus();
                this.inputPatternIncludes.select();
                return;
            }
            if (this.tree.isDOMFocused()) {
                this.moveFocusFromResults();
                return;
            }
        };
        SearchView.prototype.moveFocusFromResults = function () {
            if (this.showsFileTypes()) {
                this.toggleQueryDetails(true, true, false, true);
            }
            else {
                this.searchWidget.focus(true, true);
            }
        };
        SearchView.prototype.reLayout = function () {
            if (this.isDisposed) {
                return;
            }
            if (this.size.width >= SearchView.WIDE_VIEW_SIZE) {
                dom.addClass(this.getContainer(), SearchView.WIDE_CLASS_NAME);
            }
            else {
                dom.removeClass(this.getContainer(), SearchView.WIDE_CLASS_NAME);
            }
            this.searchWidget.setWidth(this.size.width - 28 /* container margin */);
            this.inputPatternExcludes.setWidth(this.size.width - 28 /* container margin */);
            this.inputPatternIncludes.setWidth(this.size.width - 28 /* container margin */);
            var messagesSize = this.messagesElement.style.display === 'none' ?
                0 :
                dom.getTotalHeight(this.messagesElement);
            var searchResultContainerSize = this.size.height -
                messagesSize -
                dom.getTotalHeight(this.searchWidgetsContainerElement);
            this.resultsElement.style.height = searchResultContainerSize + 'px';
            this.tree.layout(searchResultContainerSize);
        };
        SearchView.prototype.layout = function (dimension) {
            this.size = dimension;
            this.reLayout();
        };
        SearchView.prototype.getControl = function () {
            return this.tree;
        };
        SearchView.prototype.isSearchSubmitted = function () {
            return this.searchSubmitted;
        };
        SearchView.prototype.isSearching = function () {
            return this.searching;
        };
        SearchView.prototype.hasSearchResults = function () {
            return !this.viewModel.searchResult.isEmpty();
        };
        SearchView.prototype.clearSearchResults = function () {
            this.viewModel.searchResult.clear();
            this.showEmptyStage();
            if (this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
                this.showSearchWithoutFolderMessage();
            }
            this.searchWidget.clear();
            this.viewModel.cancelSearch();
        };
        SearchView.prototype.cancelSearch = function () {
            if (this.viewModel.cancelSearch()) {
                this.searchWidget.focus();
                return true;
            }
            return false;
        };
        SearchView.prototype.selectTreeIfNotSelected = function () {
            if (this.tree.getInput()) {
                this.tree.domFocus();
                var selection = this.tree.getSelection();
                if (selection.length === 0) {
                    this.tree.focusNext();
                }
            }
        };
        SearchView.prototype.getSearchTextFromEditor = function (allowUnselectedWord) {
            if (!this.editorService.activeEditor) {
                return null;
            }
            if (dom.isAncestor(document.activeElement, this.getContainer())) {
                return null;
            }
            var activeTextEditorWidget = this.editorService.activeTextEditorWidget;
            if (editorBrowser_1.isDiffEditor(activeTextEditorWidget)) {
                if (activeTextEditorWidget.getOriginalEditor().hasTextFocus()) {
                    activeTextEditorWidget = activeTextEditorWidget.getOriginalEditor();
                }
                else {
                    activeTextEditorWidget = activeTextEditorWidget.getModifiedEditor();
                }
            }
            if (!editorBrowser_1.isCodeEditor(activeTextEditorWidget)) {
                return null;
            }
            var range = activeTextEditorWidget.getSelection();
            if (!range) {
                return null;
            }
            if (range.isEmpty() && !this.searchWidget.searchInput.getValue() && allowUnselectedWord) {
                var wordAtPosition = activeTextEditorWidget.getModel().getWordAtPosition(range.getStartPosition());
                if (wordAtPosition) {
                    return wordAtPosition.word;
                }
            }
            if (!range.isEmpty() && range.startLineNumber === range.endLineNumber) {
                var searchText = activeTextEditorWidget.getModel().getLineContent(range.startLineNumber);
                searchText = searchText.substring(range.startColumn - 1, range.endColumn - 1);
                return searchText;
            }
            return null;
        };
        SearchView.prototype.showsFileTypes = function () {
            return dom.hasClass(this.queryDetails, 'more');
        };
        SearchView.prototype.toggleCaseSensitive = function () {
            this.searchWidget.searchInput.setCaseSensitive(!this.searchWidget.searchInput.getCaseSensitive());
            this.onQueryChanged(true);
        };
        SearchView.prototype.toggleWholeWords = function () {
            this.searchWidget.searchInput.setWholeWords(!this.searchWidget.searchInput.getWholeWords());
            this.onQueryChanged(true);
        };
        SearchView.prototype.toggleRegex = function () {
            this.searchWidget.searchInput.setRegex(!this.searchWidget.searchInput.getRegex());
            this.onQueryChanged(true);
        };
        SearchView.prototype.toggleQueryDetails = function (moveFocus, show, skipLayout, reverse) {
            if (moveFocus === void 0) { moveFocus = true; }
            var cls = 'more';
            show = typeof show === 'undefined' ? !dom.hasClass(this.queryDetails, cls) : Boolean(show);
            this.viewletSettings['query.queryDetailsExpanded'] = show;
            skipLayout = Boolean(skipLayout);
            if (show) {
                this.toggleQueryDetailsButton.setAttribute('aria-expanded', 'true');
                dom.addClass(this.queryDetails, cls);
                if (moveFocus) {
                    if (reverse) {
                        this.inputPatternExcludes.focus();
                        this.inputPatternExcludes.select();
                    }
                    else {
                        this.inputPatternIncludes.focus();
                        this.inputPatternIncludes.select();
                    }
                }
            }
            else {
                this.toggleQueryDetailsButton.setAttribute('aria-expanded', 'false');
                dom.removeClass(this.queryDetails, cls);
                if (moveFocus) {
                    this.searchWidget.focus();
                }
            }
            if (!skipLayout && this.size) {
                this.layout(this.size);
            }
        };
        SearchView.prototype.searchInFolders = function (resources, pathToRelative) {
            var _this = this;
            var folderPaths = [];
            var workspace = this.contextService.getWorkspace();
            if (resources) {
                resources.forEach(function (resource) {
                    var folderPath;
                    if (_this.contextService.getWorkbenchState() === 2 /* FOLDER */) {
                        // Show relative path from the root for single-root mode
                        folderPath = paths.normalize(pathToRelative(workspace.folders[0].uri.fsPath, resource.fsPath));
                        if (folderPath && folderPath !== '.') {
                            folderPath = './' + folderPath;
                        }
                    }
                    else {
                        var owningFolder = _this.contextService.getWorkspaceFolder(resource);
                        if (owningFolder) {
                            var owningRootName_1 = owningFolder.name;
                            // If this root is the only one with its basename, use a relative ./ path. If there is another, use an absolute path
                            var isUniqueFolder = workspace.folders.filter(function (folder) { return folder.name === owningRootName_1; }).length === 1;
                            if (isUniqueFolder) {
                                var relativePath = paths.normalize(pathToRelative(owningFolder.uri.fsPath, resource.fsPath));
                                if (relativePath === '.') {
                                    folderPath = "./" + owningFolder.name;
                                }
                                else {
                                    folderPath = "./" + owningFolder.name + "/" + relativePath;
                                }
                            }
                            else {
                                folderPath = resource.fsPath;
                            }
                        }
                    }
                    if (folderPath) {
                        folderPaths.push(folderPath);
                    }
                });
            }
            if (!folderPaths.length || folderPaths.some(function (folderPath) { return folderPath === '.'; })) {
                this.inputPatternIncludes.setValue('');
                this.searchWidget.focus();
                return;
            }
            // Show 'files to include' box
            if (!this.showsFileTypes()) {
                this.toggleQueryDetails(true, true);
            }
            this.inputPatternIncludes.setValue(folderPaths.join(', '));
            this.searchWidget.focus(false);
        };
        SearchView.prototype.onQueryChanged = function (preserveFocus) {
            var _this = this;
            var isRegex = this.searchWidget.searchInput.getRegex();
            var isWholeWords = this.searchWidget.searchInput.getWholeWords();
            var isCaseSensitive = this.searchWidget.searchInput.getCaseSensitive();
            var contentPattern = this.searchWidget.searchInput.getValue();
            var excludePatternText = this.inputPatternExcludes.getValue().trim();
            var includePatternText = this.inputPatternIncludes.getValue().trim();
            var useExcludesAndIgnoreFiles = this.inputPatternExcludes.useExcludesAndIgnoreFiles();
            if (contentPattern.length === 0) {
                return;
            }
            // Validate regex is OK
            if (isRegex) {
                var regExp = void 0;
                try {
                    regExp = new RegExp(contentPattern);
                }
                catch (e) {
                    return; // malformed regex
                }
                if (strings.regExpLeadsToEndlessLoop(regExp)) {
                    return; // endless regex
                }
            }
            var content = {
                pattern: contentPattern,
                isRegExp: isRegex,
                isCaseSensitive: isCaseSensitive,
                isWordMatch: isWholeWords,
                isSmartCase: this.configurationService.getValue().search.smartCase
            };
            var excludePattern = this.inputPatternExcludes.getValue();
            var includePattern = this.inputPatternIncludes.getValue();
            // Need the full match line to correctly calculate replace text, if this is a search/replace with regex group references ($1, $2, ...).
            // 10000 chars is enough to avoid sending huge amounts of text around, if you do a replace with a longer match, it may or may not resolve the group refs correctly.
            // https://github.com/Microsoft/vscode/issues/58374
            var charsPerLine = content.isRegExp ? 10000 :
                250;
            var options = {
                extraFileResources: search_2.getOutOfWorkspaceEditorResources(this.editorService, this.contextService),
                maxResults: SearchView.MAX_TEXT_RESULTS,
                disregardIgnoreFiles: !useExcludesAndIgnoreFiles,
                disregardExcludeSettings: !useExcludesAndIgnoreFiles,
                excludePattern: excludePattern,
                includePattern: includePattern,
                previewOptions: {
                    matchLines: 1,
                    charsPerLine: charsPerLine
                }
            };
            var folderResources = this.contextService.getWorkspace().folders;
            var onQueryValidationError = function (err) {
                _this.searchWidget.searchInput.showMessage({ content: err.message, type: 3 /* ERROR */ });
                _this.viewModel.searchResult.clear();
            };
            var query;
            try {
                query = this.queryBuilder.text(content, folderResources.map(function (folder) { return folder.uri; }), options);
            }
            catch (err) {
                onQueryValidationError(err);
                return;
            }
            this.validateQuery(query).then(function () {
                _this.onQueryTriggered(query, excludePatternText, includePatternText);
                if (!preserveFocus) {
                    _this.searchWidget.focus(false); // focus back to input field
                }
            }, onQueryValidationError);
        };
        SearchView.prototype.validateQuery = function (query) {
            var _this = this;
            // Validate folderQueries
            var folderQueriesExistP = query.folderQueries.map(function (fq) {
                return _this.fileService.existsFile(fq.folder);
            });
            return winjs_base_1.TPromise.join(folderQueriesExistP).then(function (existResults) {
                // If no folders exist, show an error message about the first one
                var existingFolderQueries = query.folderQueries.filter(function (folderQuery, i) { return existResults[i]; });
                if (!query.folderQueries.length || existingFolderQueries.length) {
                    query.folderQueries = existingFolderQueries;
                }
                else {
                    var nonExistantPath = query.folderQueries[0].folder.fsPath;
                    var searchPathNotFoundError = nls.localize('searchPathNotFoundError', "Search path not found: {0}", nonExistantPath);
                    return winjs_base_1.TPromise.wrapError(new Error(searchPathNotFoundError));
                }
                return undefined;
            });
        };
        SearchView.prototype.onQueryTriggered = function (query, excludePatternText, includePatternText) {
            var _this = this;
            this.inputPatternExcludes.onSearchSubmit();
            this.inputPatternIncludes.onSearchSubmit();
            this.viewModel.cancelSearch();
            // Progress total is 100.0% for more progress bar granularity
            var progressTotal = 1000;
            var progressWorked = 0;
            var progressRunner = query.useRipgrep ?
                this.progressService.show(/*infinite=*/ true) :
                this.progressService.show(progressTotal);
            this.searchWidget.searchInput.clearMessage();
            this.searching = true;
            setTimeout(function () {
                if (_this.searching) {
                    _this.changeActionAtPosition(0, _this.instantiationService.createInstance(searchActions_1.CancelSearchAction, searchActions_1.CancelSearchAction.ID, searchActions_1.CancelSearchAction.LABEL));
                }
            }, 2000);
            this.showEmptyStage();
            var onComplete = function (completed) {
                _this.searching = false;
                _this.changeActionAtPosition(0, _this.instantiationService.createInstance(searchActions_1.RefreshAction, searchActions_1.RefreshAction.ID, searchActions_1.RefreshAction.LABEL));
                // Complete up to 100% as needed
                if (completed && !query.useRipgrep) {
                    progressRunner.worked(progressTotal - progressWorked);
                    setTimeout(function () { return progressRunner.done(); }, 200);
                }
                else {
                    progressRunner.done();
                }
                // Do final render, then expand if just 1 file with less than 50 matches
                _this.onSearchResultsChanged().then(function () {
                    if (_this.viewModel.searchResult.count() === 1) {
                        var onlyMatch = _this.viewModel.searchResult.matches()[0];
                        if (onlyMatch.count() < 50) {
                            return _this.tree.expand(onlyMatch);
                        }
                    }
                    return null;
                });
                _this.viewModel.replaceString = _this.searchWidget.getReplaceValue();
                var hasResults = !_this.viewModel.searchResult.isEmpty();
                _this.searchSubmitted = true;
                _this.updateActions();
                if (completed && completed.limitHit) {
                    _this.searchWidget.searchInput.showMessage({
                        content: nls.localize('searchMaxResultsWarning', "The result set only contains a subset of all matches. Please be more specific in your search to narrow down the results."),
                        type: 2 /* WARNING */
                    });
                }
                if (!hasResults) {
                    var hasExcludes = !!excludePatternText;
                    var hasIncludes = !!includePatternText;
                    var message = void 0;
                    if (!completed) {
                        message = nls.localize('searchCanceled', "Search was canceled before any results could be found - ");
                    }
                    else if (hasIncludes && hasExcludes) {
                        message = nls.localize('noResultsIncludesExcludes', "No results found in '{0}' excluding '{1}' - ", includePatternText, excludePatternText);
                    }
                    else if (hasIncludes) {
                        message = nls.localize('noResultsIncludes', "No results found in '{0}' - ", includePatternText);
                    }
                    else if (hasExcludes) {
                        message = nls.localize('noResultsExcludes', "No results found excluding '{0}' - ", excludePatternText);
                    }
                    else {
                        message = nls.localize('noResultsFound', "No results found. Review your settings for configured exclusions and ignore files - ");
                    }
                    // Indicate as status to ARIA
                    aria.status(message);
                    _this.tree.onHidden();
                    dom.hide(_this.resultsElement);
                    var messageEl = _this.clearMessage();
                    var p = dom.append(messageEl, $('p', undefined, message));
                    if (!completed) {
                        var searchAgainLink = dom.append(p, $('a.pointer.prominent', undefined, nls.localize('rerunSearch.message', "Search again")));
                        _this.messageDisposables.push(dom.addDisposableListener(searchAgainLink, dom.EventType.CLICK, function (e) {
                            dom.EventHelper.stop(e, false);
                            _this.onQueryChanged();
                        }));
                    }
                    else if (hasIncludes || hasExcludes) {
                        var searchAgainLink = dom.append(p, $('a.pointer.prominent', { tabindex: 0 }, nls.localize('rerunSearchInAll.message', "Search again in all files")));
                        _this.messageDisposables.push(dom.addDisposableListener(searchAgainLink, dom.EventType.CLICK, function (e) {
                            dom.EventHelper.stop(e, false);
                            _this.inputPatternExcludes.setValue('');
                            _this.inputPatternIncludes.setValue('');
                            _this.onQueryChanged();
                        }));
                    }
                    else {
                        var openSettingsLink = dom.append(p, $('a.pointer.prominent', { tabindex: 0 }, nls.localize('openSettings.message', "Open Settings")));
                        _this.messageDisposables.push(dom.addDisposableListener(openSettingsLink, dom.EventType.CLICK, function (e) {
                            dom.EventHelper.stop(e, false);
                            var options = { query: '.exclude' };
                            _this.contextService.getWorkbenchState() !== 1 /* EMPTY */ ?
                                _this.preferencesService.openWorkspaceSettings(undefined, options) :
                                _this.preferencesService.openGlobalSettings(undefined, options);
                        }));
                    }
                    if (completed) {
                        dom.append(p, $('span', undefined, ' - '));
                        var learnMoreLink = dom.append(p, $('a.pointer.prominent', { tabindex: 0 }, nls.localize('openSettings.learnMore', "Learn More")));
                        _this.messageDisposables.push(dom.addDisposableListener(learnMoreLink, dom.EventType.CLICK, function (e) {
                            dom.EventHelper.stop(e, false);
                            window.open('https://go.microsoft.com/fwlink/?linkid=853977');
                        }));
                    }
                    if (_this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
                        _this.showSearchWithoutFolderMessage();
                    }
                }
                else {
                    _this.viewModel.searchResult.toggleHighlights(_this.isVisible()); // show highlights
                    // Indicate final search result count for ARIA
                    aria.status(nls.localize('ariaSearchResultsStatus', "Search returned {0} results in {1} files", _this.viewModel.searchResult.count(), _this.viewModel.searchResult.fileCount()));
                }
            };
            var onError = function (e) {
                if (errors.isPromiseCanceledError(e)) {
                    onComplete(null);
                }
                else {
                    _this.searching = false;
                    _this.changeActionAtPosition(0, _this.instantiationService.createInstance(searchActions_1.RefreshAction, searchActions_1.RefreshAction.ID, searchActions_1.RefreshAction.LABEL));
                    progressRunner.done();
                    _this.searchWidget.searchInput.showMessage({ content: e.message, type: 3 /* ERROR */ });
                    _this.viewModel.searchResult.clear();
                }
            };
            var total = 0;
            var worked = 0;
            var visibleMatches = 0;
            var onProgress = function (p) {
                // Progress
                if (p.total) {
                    total = p.total;
                }
                if (p.worked) {
                    worked = p.worked;
                }
            };
            // Handle UI updates in an interval to show frequent progress and results
            var uiRefreshHandle = setInterval(function () {
                if (!_this.searching) {
                    window.clearInterval(uiRefreshHandle);
                    return;
                }
                if (!query.useRipgrep) {
                    // Progress bar update
                    var fakeProgress = true;
                    if (total > 0 && worked > 0) {
                        var ratio = Math.round((worked / total) * progressTotal);
                        if (ratio > progressWorked) { // never show less progress than what we have already
                            progressRunner.worked(ratio - progressWorked);
                            progressWorked = ratio;
                            fakeProgress = false;
                        }
                    }
                    // Fake progress up to 90%, or when actual progress beats it
                    var fakeMax = 900;
                    var fakeMultiplier = 12;
                    if (fakeProgress && progressWorked < fakeMax) {
                        // Linearly decrease the rate of fake progress.
                        // 1 is the smallest allowed amount of progress.
                        var fakeAmt = Math.round((fakeMax - progressWorked) / fakeMax * fakeMultiplier) || 1;
                        progressWorked += fakeAmt;
                        progressRunner.worked(fakeAmt);
                    }
                }
                // Search result tree update
                var fileCount = _this.viewModel.searchResult.fileCount();
                if (visibleMatches !== fileCount) {
                    visibleMatches = fileCount;
                    _this.tree.refresh();
                    _this.updateSearchResultCount();
                }
                if (fileCount > 0) {
                    _this.updateActions();
                }
            }, 100);
            this.searchWidget.setReplaceAllActionState(false);
            this.viewModel.search(query, onProgress).then(onComplete, onError);
        };
        SearchView.prototype.updateSearchResultCount = function () {
            var fileCount = this.viewModel.searchResult.fileCount();
            this.hasSearchResultsKey.set(fileCount > 0);
            var msgWasHidden = this.messagesElement.style.display === 'none';
            if (fileCount > 0) {
                var messageEl = this.clearMessage();
                dom.append(messageEl, $('p', undefined, this.buildResultCountMessage(this.viewModel.searchResult.count(), fileCount)));
                if (msgWasHidden) {
                    this.reLayout();
                }
            }
            else if (!msgWasHidden) {
                dom.hide(this.messagesElement);
            }
        };
        SearchView.prototype.buildResultCountMessage = function (resultCount, fileCount) {
            if (resultCount === 1 && fileCount === 1) {
                return nls.localize('search.file.result', "{0} result in {1} file", resultCount, fileCount);
            }
            else if (resultCount === 1) {
                return nls.localize('search.files.result', "{0} result in {1} files", resultCount, fileCount);
            }
            else if (fileCount === 1) {
                return nls.localize('search.file.results', "{0} results in {1} file", resultCount, fileCount);
            }
            else {
                return nls.localize('search.files.results', "{0} results in {1} files", resultCount, fileCount);
            }
        };
        SearchView.prototype.showSearchWithoutFolderMessage = function () {
            var _this = this;
            this.searchWithoutFolderMessageElement = this.clearMessage();
            var textEl = dom.append(this.searchWithoutFolderMessageElement, $('p', undefined, nls.localize('searchWithoutFolder', "You have not yet opened a folder. Only open files are currently searched - ")));
            var openFolderLink = dom.append(textEl, $('a.pointer.prominent', { tabindex: 0 }, nls.localize('openFolder', "Open Folder")));
            this.messageDisposables.push(dom.addDisposableListener(openFolderLink, dom.EventType.CLICK, function (e) {
                dom.EventHelper.stop(e, false);
                var actionClass = env.isMacintosh ? workspaceActions_1.OpenFileFolderAction : workspaceActions_1.OpenFolderAction;
                var action = _this.instantiationService.createInstance(actionClass, actionClass.ID, actionClass.LABEL);
                _this.actionRunner.run(action).then(function () {
                    action.dispose();
                }, function (err) {
                    action.dispose();
                    errors.onUnexpectedError(err);
                });
            }));
        };
        SearchView.prototype.showEmptyStage = function () {
            // disable 'result'-actions
            this.searchSubmitted = false;
            this.updateActions();
            // clean up ui
            // this.replaceService.disposeAllReplacePreviews();
            dom.hide(this.messagesElement);
            dom.show(this.resultsElement);
            this.tree.onVisible();
            this.currentSelectedFileMatch = null;
        };
        SearchView.prototype.onFocus = function (lineMatch, preserveFocus, sideBySide, pinned) {
            if (!(lineMatch instanceof searchModel_1.Match)) {
                this.viewModel.searchResult.rangeHighlightDecorations.removeHighlightRange();
                return winjs_base_1.TPromise.as(true);
            }
            return (this.viewModel.isReplaceActive() && !!this.viewModel.replaceString) ?
                this.replaceService.openReplacePreview(lineMatch, preserveFocus, sideBySide, pinned) :
                this.open(lineMatch, preserveFocus, sideBySide, pinned);
        };
        SearchView.prototype.open = function (element, preserveFocus, sideBySide, pinned) {
            var _this = this;
            var selection = this.getSelectionFrom(element);
            var resource = element instanceof searchModel_1.Match ? element.parent().resource() : element.resource();
            return this.editorService.openEditor({
                resource: resource,
                options: {
                    preserveFocus: preserveFocus,
                    pinned: pinned,
                    selection: selection,
                    revealIfVisible: true
                }
            }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP).then(function (editor) {
                if (editor && element instanceof searchModel_1.Match && preserveFocus) {
                    _this.viewModel.searchResult.rangeHighlightDecorations.highlightRange(editor.getControl().getModel(), element.range());
                }
                else {
                    _this.viewModel.searchResult.rangeHighlightDecorations.removeHighlightRange();
                }
                return _this.editorGroupsService.activateGroup(editor.group);
            }, errors.onUnexpectedError);
        };
        SearchView.prototype.getSelectionFrom = function (element) {
            var match = null;
            if (element instanceof searchModel_1.Match) {
                match = element;
            }
            if (element instanceof searchModel_1.FileMatch && element.count() > 0) {
                match = element.matches()[element.matches().length - 1];
            }
            if (match) {
                var range = match.range();
                if (this.viewModel.isReplaceActive() && !!this.viewModel.replaceString) {
                    var replaceString = match.replaceString;
                    return {
                        startLineNumber: range.startLineNumber,
                        startColumn: range.startColumn,
                        endLineNumber: range.startLineNumber,
                        endColumn: range.startColumn + replaceString.length
                    };
                }
                return range;
            }
            return void 0;
        };
        SearchView.prototype.onUntitledDidChangeDirty = function (resource) {
            if (!this.viewModel) {
                return;
            }
            // remove search results from this resource as it got disposed
            if (!this.untitledEditorService.isDirty(resource)) {
                var matches = this.viewModel.searchResult.matches();
                for (var i = 0, len = matches.length; i < len; i++) {
                    if (resource.toString() === matches[i].resource().toString()) {
                        this.viewModel.searchResult.remove(matches[i]);
                    }
                }
            }
        };
        SearchView.prototype.onFilesChanged = function (e) {
            if (!this.viewModel) {
                return;
            }
            var matches = this.viewModel.searchResult.matches();
            for (var i = 0, len = matches.length; i < len; i++) {
                if (e.contains(matches[i].resource(), 2 /* DELETED */)) {
                    this.viewModel.searchResult.remove(matches[i]);
                }
            }
        };
        SearchView.prototype.getActions = function () {
            return this.actions;
        };
        SearchView.prototype.changeActionAtPosition = function (index, newAction) {
            this.actions.splice(index, 1, newAction);
            this.updateTitleArea();
        };
        SearchView.prototype.clearHistory = function () {
            this.searchWidget.clearHistory();
            this.inputPatternExcludes.clearHistory();
            this.inputPatternIncludes.clearHistory();
        };
        SearchView.prototype.shutdown = function () {
            var isRegex = this.searchWidget.searchInput.getRegex();
            var isWholeWords = this.searchWidget.searchInput.getWholeWords();
            var isCaseSensitive = this.searchWidget.searchInput.getCaseSensitive();
            var contentPattern = this.searchWidget.searchInput.getValue();
            var patternExcludes = this.inputPatternExcludes.getValue().trim();
            var patternIncludes = this.inputPatternIncludes.getValue().trim();
            var useExcludesAndIgnoreFiles = this.inputPatternExcludes.useExcludesAndIgnoreFiles();
            // store memento
            this.viewletSettings['query.contentPattern'] = contentPattern;
            this.viewletSettings['query.regex'] = isRegex;
            this.viewletSettings['query.wholeWords'] = isWholeWords;
            this.viewletSettings['query.caseSensitive'] = isCaseSensitive;
            this.viewletSettings['query.folderExclusions'] = patternExcludes;
            this.viewletSettings['query.folderIncludes'] = patternIncludes;
            this.viewletSettings['query.useExcludesAndIgnoreFiles'] = useExcludesAndIgnoreFiles;
            var searchHistory = this.searchWidget.getSearchHistory();
            var replaceHistory = this.searchWidget.getReplaceHistory();
            var patternExcludesHistory = this.inputPatternExcludes.getHistory();
            var patternIncludesHistory = this.inputPatternIncludes.getHistory();
            this.searchHistoryService.save({
                search: searchHistory,
                replace: replaceHistory,
                exclude: patternExcludesHistory,
                include: patternIncludesHistory
            });
            _super.prototype.shutdown.call(this);
        };
        SearchView.prototype.dispose = function () {
            this.isDisposed = true;
            _super.prototype.dispose.call(this);
        };
        SearchView.MAX_TEXT_RESULTS = 10000;
        SearchView.SHOW_REPLACE_STORAGE_KEY = 'vs.search.show.replace';
        SearchView.WIDE_CLASS_NAME = 'wide';
        SearchView.WIDE_VIEW_SIZE = 600;
        SearchView = __decorate([
            __param(0, partService_1.IPartService),
            __param(1, telemetry_1.ITelemetryService),
            __param(2, files_1.IFileService),
            __param(3, editorService_1.IEditorService),
            __param(4, progress_1.IProgressService),
            __param(5, notification_1.INotificationService),
            __param(6, dialogs_1.IDialogService),
            __param(7, storage_1.IStorageService),
            __param(8, contextView_1.IContextViewService),
            __param(9, instantiation_1.IInstantiationService),
            __param(10, configuration_1.IConfigurationService),
            __param(11, workspace_1.IWorkspaceContextService),
            __param(12, searchModel_1.ISearchWorkbenchService),
            __param(13, contextkey_1.IContextKeyService),
            __param(14, replace_1.IReplaceService),
            __param(15, untitledEditorService_1.IUntitledEditorService),
            __param(16, preferences_1.IPreferencesService),
            __param(17, themeService_1.IThemeService),
            __param(18, search_1.ISearchHistoryService),
            __param(19, editorGroupsService_1.IEditorGroupsService)
        ], SearchView);
        return SearchView;
    }(viewlet_1.Viewlet));
    exports.SearchView = SearchView;
    themeService_1.registerThemingParticipant(function (theme, collector) {
        var matchHighlightColor = theme.getColor(colorRegistry_1.editorFindMatchHighlight);
        if (matchHighlightColor) {
            collector.addRule(".monaco-workbench .search-view .findInFileMatch { background-color: " + matchHighlightColor + "; }");
        }
        var diffInsertedColor = theme.getColor(colorRegistry_1.diffInserted);
        if (diffInsertedColor) {
            collector.addRule(".monaco-workbench .search-view .replaceMatch { background-color: " + diffInsertedColor + "; }");
        }
        var diffRemovedColor = theme.getColor(colorRegistry_1.diffRemoved);
        if (diffRemovedColor) {
            collector.addRule(".monaco-workbench .search-view .replace.findInFileMatch { background-color: " + diffRemovedColor + "; }");
        }
        var diffInsertedOutlineColor = theme.getColor(colorRegistry_1.diffInsertedOutline);
        if (diffInsertedOutlineColor) {
            collector.addRule(".monaco-workbench .search-view .replaceMatch:not(:empty) { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + diffInsertedOutlineColor + "; }");
        }
        var diffRemovedOutlineColor = theme.getColor(colorRegistry_1.diffRemovedOutline);
        if (diffRemovedOutlineColor) {
            collector.addRule(".monaco-workbench .search-view .replace.findInFileMatch { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + diffRemovedOutlineColor + "; }");
        }
        var findMatchHighlightBorder = theme.getColor(colorRegistry_1.editorFindMatchHighlightBorder);
        if (findMatchHighlightBorder) {
            collector.addRule(".monaco-workbench .search-view .findInFileMatch { border: 1px " + (theme.type === 'hc' ? 'dashed' : 'solid') + " " + findMatchHighlightBorder + "; }");
        }
        var outlineSelectionColor = theme.getColor(colorRegistry_1.listActiveSelectionForeground);
        if (outlineSelectionColor) {
            collector.addRule(".monaco-workbench .search-view .monaco-tree.focused .monaco-tree-row.focused.selected:not(.highlighted) .action-label:focus { outline-color: " + outlineSelectionColor + " }");
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[287/*vs/workbench/parts/search/electron-browser/search.contribution*/], __M([0/*require*/,1/*exports*/,9/*vs/platform/registry/common/platform*/,80/*vs/platform/instantiation/common/extensions*/,76/*vs/workbench/browser/viewlet*/,90/*vs/platform/configuration/common/configurationRegistry*/,2/*vs/nls*/,5/*vs/base/common/winjs.base*/,15/*vs/base/common/actions*/,38/*vs/base/common/objects*/,18/*vs/base/common/platform*/,57/*vs/workbench/parts/files/common/files*/,23/*vs/platform/actions/common/actions*/,47/*vs/workbench/common/actions*/,53/*vs/workbench/browser/quickopen*/,64/*vs/platform/keybinding/common/keybindingsRegistry*/,3/*vs/platform/instantiation/common/instantiation*/,46/*vs/platform/quickOpen/common/quickOpen*/,96/*vs/editor/browser/services/codeEditorService*/,380/*vs/editor/contrib/find/findController*/,54/*vs/workbench/services/viewlet/browser/viewlet*/,148/*vs/workbench/parts/search/common/constants*/,387/*vs/workbench/parts/search/browser/replaceContributions*/,217/*vs/workbench/parts/search/browser/searchWidget*/,10/*vs/platform/contextkey/common/contextkey*/,381/*vs/editor/contrib/find/findModel*/,106/*vs/workbench/parts/search/common/searchModel*/,37/*vs/platform/commands/common/commands*/,248/*vs/workbench/parts/search/browser/searchView*/,102/*vs/workbench/browser/parts/quickopen/quickopen*/,179/*vs/workbench/parts/search/browser/openSymbolHandler*/,426/*vs/workbench/parts/search/browser/openAnythingHandler*/,56/*vs/editor/browser/editorExtensions*/,143/*vs/workbench/parts/search/common/search*/,25/*vs/base/common/errors*/,51/*vs/platform/list/browser/listService*/,78/*path*/,35/*vs/base/common/resources*/,82/*vs/workbench/common/resources*/,16/*vs/platform/files/common/files*/,19/*vs/base/common/arrays*/,178/*vs/workbench/parts/files/browser/files*/,26/*vs/base/common/network*/,180/*vs/workbench/browser/panel*/,81/*vs/workbench/services/panel/common/panelService*/,141/*vs/workbench/parts/search/browser/searchActions*/,71/*vs/platform/search/common/search*/,107/*vs/workbench/common/contributions*/,383/*vs/workbench/parts/search/browser/searchViewLocationUpdater*/,7/*vs/platform/configuration/common/configuration*/,11/*vs/workbench/services/editor/common/editorService*/,275/*vs/css!vs/workbench/parts/search/electron-browser/media/search.contribution*/]), function (require, exports, platform_1, extensions_1, viewlet_1, configurationRegistry_1, nls, winjs_base_1, actions_1, objects, platform, files_1, actions_2, actions_3, quickopen_1, keybindingsRegistry_1, instantiation_1, quickOpen_1, codeEditorService_1, findController_1, viewlet_2, Constants, replaceContributions_1, searchWidget_1, contextkey_1, findModel_1, searchModel_1, commands_1, searchView_1, quickopen_2, openSymbolHandler_1, openAnythingHandler_1, editorExtensions_1, search_1, errors_1, listService_1, path_1, resources_1, resources_2, files_2, arrays_1, files_3, network_1, panel_1, panelService_1, searchActions_1, search_2, contributions_1, searchViewLocationUpdater_1, configuration_1, editorService_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    extensions_1.registerSingleton(searchModel_1.ISearchWorkbenchService, searchModel_1.SearchWorkbenchService);
    replaceContributions_1.registerContributions();
    searchWidget_1.registerContributions();
    var category = nls.localize('search', "Search");
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'workbench.action.search.toggleQueryDetails',
        weight: 200 /* WorkbenchContrib */,
        when: Constants.SearchViewVisibleKey,
        primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 40 /* KEY_J */,
        handler: function (accessor) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            if (searchView) {
                searchView.toggleQueryDetails();
            }
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.FocusSearchFromResults,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.FirstMatchFocusKey),
        primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */,
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            searchView.focusPreviousInputBox();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.OpenMatchToSide,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.FileMatchOrMatchFocusKey),
        primary: 2048 /* CtrlCmd */ | 3 /* Enter */,
        mac: {
            primary: 256 /* WinCtrl */ | 3 /* Enter */
        },
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            var tree = searchView.getControl();
            searchView.open(tree.getFocus(), false, true, true);
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.CancelActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, listService_1.WorkbenchListFocusContextKey),
        primary: 9 /* Escape */,
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            searchView.cancelSearch();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.RemoveActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.FileMatchOrMatchFocusKey),
        primary: 20 /* Delete */,
        mac: {
            primary: 2048 /* CtrlCmd */ | 1 /* Backspace */,
        },
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            var tree = searchView.getControl();
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.RemoveAction, tree, tree.getFocus(), searchView).run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.ReplaceActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.ReplaceActiveKey, Constants.MatchFocusKey),
        primary: 1024 /* Shift */ | 2048 /* CtrlCmd */ | 22 /* KEY_1 */,
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            var tree = searchView.getControl();
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.ReplaceAction, tree, tree.getFocus(), searchView).run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.ReplaceAllInFileActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.ReplaceActiveKey, Constants.FileFocusKey),
        primary: 1024 /* Shift */ | 2048 /* CtrlCmd */ | 22 /* KEY_1 */,
        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 3 /* Enter */],
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            var tree = searchView.getControl();
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.ReplaceAllAction, tree, tree.getFocus(), searchView).run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.ReplaceAllInFolderActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.ReplaceActiveKey, Constants.FolderFocusKey),
        primary: 1024 /* Shift */ | 2048 /* CtrlCmd */ | 22 /* KEY_1 */,
        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 3 /* Enter */],
        handler: function (accessor, args) {
            var searchView = searchActions_1.getSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService));
            var tree = searchView.getControl();
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.ReplaceAllInFolderAction, tree, tree.getFocus()).run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.CloseReplaceWidgetActionId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.ReplaceInputBoxFocusedKey),
        primary: 9 /* Escape */,
        handler: function (accessor, args) {
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.CloseReplaceAction, Constants.CloseReplaceWidgetActionId, '').run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: searchActions_1.FocusNextInputAction.ID,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.InputBoxFocusedKey),
        primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */,
        handler: function (accessor, args) {
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.FocusNextInputAction, searchActions_1.FocusNextInputAction.ID, '').run();
        }
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: searchActions_1.FocusPreviousInputAction.ID,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.InputBoxFocusedKey, Constants.SearchInputBoxFocusedKey.toNegated()),
        primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */,
        handler: function (accessor, args) {
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.FocusPreviousInputAction, searchActions_1.FocusPreviousInputAction.ID, '').run();
        }
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.ReplaceActionId,
            title: searchActions_1.ReplaceAction.LABEL
        },
        when: contextkey_1.ContextKeyExpr.and(Constants.ReplaceActiveKey, Constants.MatchFocusKey),
        group: 'search',
        order: 1
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.ReplaceAllInFolderActionId,
            title: searchActions_1.ReplaceAllInFolderAction.LABEL
        },
        when: contextkey_1.ContextKeyExpr.and(Constants.ReplaceActiveKey, Constants.FolderFocusKey),
        group: 'search',
        order: 1
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.ReplaceAllInFileActionId,
            title: searchActions_1.ReplaceAllAction.LABEL
        },
        when: contextkey_1.ContextKeyExpr.and(Constants.ReplaceActiveKey, Constants.FileFocusKey),
        group: 'search',
        order: 1
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.RemoveActionId,
            title: searchActions_1.RemoveAction.LABEL
        },
        when: Constants.FileMatchOrMatchFocusKey,
        group: 'search',
        order: 2
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.CopyMatchCommandId,
        weight: 200 /* WorkbenchContrib */,
        when: Constants.FileMatchOrMatchFocusKey,
        primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */,
        handler: searchActions_1.copyMatchCommand
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.CopyMatchCommandId,
            title: nls.localize('copyMatchLabel', "Copy")
        },
        when: Constants.FileMatchOrMatchFocusKey,
        group: 'search_2',
        order: 1
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: Constants.CopyPathCommandId,
        weight: 200 /* WorkbenchContrib */,
        when: Constants.FileMatchOrFolderMatchFocusKey,
        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */,
        win: {
            primary: 1024 /* Shift */ | 512 /* Alt */ | 33 /* KEY_C */
        },
        handler: searchActions_1.copyPathCommand
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.CopyPathCommandId,
            title: nls.localize('copyPathLabel', "Copy Path")
        },
        when: Constants.FileMatchOrFolderMatchFocusKey,
        group: 'search_2',
        order: 2
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: {
            id: Constants.CopyAllCommandId,
            title: nls.localize('copyAllLabel', "Copy All")
        },
        when: Constants.HasSearchResults,
        group: 'search_2',
        order: 3
    });
    commands_1.CommandsRegistry.registerCommand({
        id: Constants.CopyAllCommandId,
        handler: searchActions_1.copyAllCommand
    });
    commands_1.CommandsRegistry.registerCommand({
        id: Constants.ClearSearchHistoryCommandId,
        handler: searchActions_1.clearHistoryCommand
    });
    var clearSearchHistoryLabel = nls.localize('clearSearchHistoryLabel', "Clear Search History");
    var ClearSearchHistoryCommand = {
        id: Constants.ClearSearchHistoryCommandId,
        title: clearSearchHistoryLabel,
        category: category
    };
    actions_2.MenuRegistry.addCommand(ClearSearchHistoryCommand);
    commands_1.CommandsRegistry.registerCommand({
        id: Constants.ToggleSearchViewPositionCommandId,
        handler: function (accessor) {
            var configurationService = accessor.get(configuration_1.IConfigurationService);
            var currentValue = configurationService.getValue('search').location;
            var toggleValue = currentValue === 'sidebar' ? 'panel' : 'sidebar';
            configurationService.updateValue('search.location', toggleValue);
        }
    });
    var toggleSearchViewPositionLabel = nls.localize('toggleSearchViewPositionLabel', "Toggle Search View Position");
    var ToggleSearchViewPositionCommand = {
        id: Constants.ToggleSearchViewPositionCommandId,
        title: toggleSearchViewPositionLabel,
        category: category
    };
    actions_2.MenuRegistry.addCommand(ToggleSearchViewPositionCommand);
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.SearchContext, {
        command: ToggleSearchViewPositionCommand,
        when: Constants.SearchViewVisibleKey,
        group: 'search_9',
        order: 1
    });
    commands_1.CommandsRegistry.registerCommand({
        id: Constants.FocusSearchListCommandID,
        handler: searchActions_1.focusSearchListCommand
    });
    var focusSearchListCommandLabel = nls.localize('focusSearchListCommandLabel', "Focus List");
    var FocusSearchListCommand = {
        id: Constants.FocusSearchListCommandID,
        title: focusSearchListCommandLabel,
        category: category
    };
    actions_2.MenuRegistry.addCommand(FocusSearchListCommand);
    var FIND_IN_FOLDER_ID = 'filesExplorer.findInFolder';
    commands_1.CommandsRegistry.registerCommand({
        id: FIND_IN_FOLDER_ID,
        handler: function (accessor, resource) {
            var listService = accessor.get(listService_1.IListService);
            var viewletService = accessor.get(viewlet_2.IViewletService);
            var panelService = accessor.get(panelService_1.IPanelService);
            var fileService = accessor.get(files_2.IFileService);
            var resources = files_3.getMultiSelectedResources(resource, listService, accessor.get(editorService_1.IEditorService));
            return searchActions_1.openSearchView(viewletService, panelService, true).then(function (searchView) {
                if (resources && resources.length) {
                    return fileService.resolveFiles(resources.map(function (resource) { return ({ resource: resource }); })).then(function (results) {
                        var folders = [];
                        results.forEach(function (result) {
                            if (result.success) {
                                folders.push(result.stat.isDirectory ? result.stat.resource : resources_1.dirname(result.stat.resource));
                            }
                        });
                        searchView.searchInFolders(arrays_1.distinct(folders, function (folder) { return folder.toString(); }), function (from, to) { return path_1.relative(from, to); });
                    });
                }
                return void 0;
            });
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: searchActions_1.ClearSearchResultsAction.ID,
        handler: function (accessor, args) {
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.ClearSearchResultsAction, searchActions_1.ClearSearchResultsAction.ID, '').run();
        }
    });
    commands_1.CommandsRegistry.registerCommand({
        id: searchActions_1.RefreshAction.ID,
        handler: function (accessor, args) {
            accessor.get(instantiation_1.IInstantiationService).createInstance(searchActions_1.RefreshAction, searchActions_1.RefreshAction.ID, '').run();
        }
    });
    var FIND_IN_WORKSPACE_ID = 'filesExplorer.findInWorkspace';
    commands_1.CommandsRegistry.registerCommand({
        id: FIND_IN_WORKSPACE_ID,
        handler: function (accessor) {
            return searchActions_1.openSearchView(accessor.get(viewlet_2.IViewletService), accessor.get(panelService_1.IPanelService), true).then(function (searchView) {
                searchView.searchInFolders(null, function (from, to) { return path_1.relative(from, to); });
            });
        }
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.ExplorerContext, {
        group: '4_search',
        order: 10,
        command: {
            id: FIND_IN_FOLDER_ID,
            title: nls.localize('findInFolder', "Find in Folder...")
        },
        when: contextkey_1.ContextKeyExpr.and(files_1.ExplorerFolderContext, resources_2.ResourceContextKey.Scheme.isEqualTo(network_1.Schemas.file)) // todo@remote
    });
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.ExplorerContext, {
        group: '4_search',
        order: 10,
        command: {
            id: FIND_IN_WORKSPACE_ID,
            title: nls.localize('findInWorkspace', "Find in Workspace...")
        },
        when: contextkey_1.ContextKeyExpr.and(files_1.ExplorerRootContext, files_1.ExplorerFolderContext.toNegated())
    });
    var ShowAllSymbolsAction = /** @class */ (function (_super) {
        __extends(ShowAllSymbolsAction, _super);
        function ShowAllSymbolsAction(actionId, actionLabel, quickOpenService, editorService) {
            var _this = _super.call(this, actionId, actionLabel) || this;
            _this.quickOpenService = quickOpenService;
            _this.editorService = editorService;
            _this.enabled = !!_this.quickOpenService;
            return _this;
        }
        ShowAllSymbolsAction.prototype.run = function (context) {
            var prefix = ShowAllSymbolsAction.ALL_SYMBOLS_PREFIX;
            var inputSelection = void 0;
            var editor = this.editorService.getFocusedCodeEditor();
            var word = editor && findController_1.getSelectionSearchString(editor);
            if (word) {
                prefix = prefix + word;
                inputSelection = { start: 1, end: word.length + 1 };
            }
            this.quickOpenService.show(prefix, { inputSelection: inputSelection });
            return winjs_base_1.TPromise.as(null);
        };
        ShowAllSymbolsAction.ID = 'workbench.action.showAllSymbols';
        ShowAllSymbolsAction.LABEL = nls.localize('showTriggerActions', "Go to Symbol in Workspace...");
        ShowAllSymbolsAction.ALL_SYMBOLS_PREFIX = '#';
        ShowAllSymbolsAction = __decorate([
            __param(2, quickOpen_1.IQuickOpenService),
            __param(3, codeEditorService_1.ICodeEditorService)
        ], ShowAllSymbolsAction);
        return ShowAllSymbolsAction;
    }(actions_1.Action));
    // Register View in Viewlet and Panel area
    platform_1.Registry.as(viewlet_1.Extensions.Viewlets).registerViewlet(new viewlet_1.ViewletDescriptor(searchView_1.SearchView, search_2.VIEW_ID, nls.localize('name', "Search"), 'search', 1));
    platform_1.Registry.as(panel_1.Extensions.Panels).registerPanel(new panel_1.PanelDescriptor(searchView_1.SearchView, search_2.VIEW_ID, nls.localize('name', "Search"), 'search', 10));
    // Register view location updater
    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(searchViewLocationUpdater_1.SearchViewLocationUpdater, 2 /* Restoring */);
    // Actions
    var registry = platform_1.Registry.as(actions_3.Extensions.WorkbenchActions);
    // Show Search and Find in Files are redundant, but we can't break keybindings by removing one. So it's the same action, same keybinding, registered to different IDs.
    // Show Search 'when' is redundant but if the two conflict with exactly the same keybinding and 'when' clause, then they can show up as "unbound" - #51780
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.OpenSearchViewletAction, search_2.VIEW_ID, searchActions_1.OpenSearchViewletAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 36 /* KEY_F */ }, Constants.SearchViewVisibleKey.toNegated()), 'View: Show Search', nls.localize('view', "View"));
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.FindInFilesAction, Constants.FindInFilesActionId, nls.localize('findInFiles', "Find in Files"), { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 36 /* KEY_F */ }), 'Find in Files', category);
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarEditMenu, {
        group: '4_find_global',
        command: {
            id: Constants.FindInFilesActionId,
            title: nls.localize({ key: 'miFindInFiles', comment: ['&& denotes a mnemonic'] }, "Find &&in Files")
        },
        order: 1
    });
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.FocusNextSearchResultAction, searchActions_1.FocusNextSearchResultAction.ID, searchActions_1.FocusNextSearchResultAction.LABEL, { primary: 62 /* F4 */ }, contextkey_1.ContextKeyExpr.and(Constants.HasSearchResults)), 'Focus Next Search Result', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.FocusPreviousSearchResultAction, searchActions_1.FocusPreviousSearchResultAction.ID, searchActions_1.FocusPreviousSearchResultAction.LABEL, { primary: 1024 /* Shift */ | 62 /* F4 */ }, contextkey_1.ContextKeyExpr.and(Constants.HasSearchResults)), 'Focus Previous Search Result', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.ReplaceInFilesAction, searchActions_1.ReplaceInFilesAction.ID, searchActions_1.ReplaceInFilesAction.LABEL, { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 38 /* KEY_H */ }), 'Replace in Files', category);
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarEditMenu, {
        group: '4_find_global',
        command: {
            id: searchActions_1.ReplaceInFilesAction.ID,
            title: nls.localize({ key: 'miReplaceInFiles', comment: ['&& denotes a mnemonic'] }, "Replace &&in Files")
        },
        order: 2
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(objects.assign({
        id: Constants.ToggleCaseSensitiveCommandId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.SearchViewFocusedKey, Constants.FileMatchOrFolderMatchFocusKey.toNegated()),
        handler: searchActions_1.toggleCaseSensitiveCommand
    }, findModel_1.ToggleCaseSensitiveKeybinding));
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(objects.assign({
        id: Constants.ToggleWholeWordCommandId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.SearchViewFocusedKey),
        handler: searchActions_1.toggleWholeWordCommand
    }, findModel_1.ToggleWholeWordKeybinding));
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(objects.assign({
        id: Constants.ToggleRegexCommandId,
        weight: 200 /* WorkbenchContrib */,
        when: contextkey_1.ContextKeyExpr.and(Constants.SearchViewVisibleKey, Constants.SearchViewFocusedKey),
        handler: searchActions_1.toggleRegexCommand
    }, findModel_1.ToggleRegexKeybinding));
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.CollapseDeepestExpandedLevelAction, searchActions_1.CollapseDeepestExpandedLevelAction.ID, searchActions_1.CollapseDeepestExpandedLevelAction.LABEL), 'Search: Collapse All', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(ShowAllSymbolsAction, ShowAllSymbolsAction.ID, ShowAllSymbolsAction.LABEL, { primary: 2048 /* CtrlCmd */ | 50 /* KEY_T */ }), 'Go to Symbol in Workspace...');
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.RefreshAction, searchActions_1.RefreshAction.ID, searchActions_1.RefreshAction.LABEL), 'Search: Refresh', category);
    registry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(searchActions_1.ClearSearchResultsAction, searchActions_1.ClearSearchResultsAction.ID, searchActions_1.ClearSearchResultsAction.LABEL), 'Search: Clear', category);
    // Register Quick Open Handler
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerDefaultQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(openAnythingHandler_1.OpenAnythingHandler, openAnythingHandler_1.OpenAnythingHandler.ID, '', quickopen_2.defaultQuickOpenContextKey, nls.localize('openAnythingHandlerDescription', "Go to File")));
    platform_1.Registry.as(quickopen_1.Extensions.Quickopen).registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(openSymbolHandler_1.OpenSymbolHandler, openSymbolHandler_1.OpenSymbolHandler.ID, ShowAllSymbolsAction.ALL_SYMBOLS_PREFIX, 'inWorkspaceSymbolsPicker', [
        {
            prefix: ShowAllSymbolsAction.ALL_SYMBOLS_PREFIX,
            needsEditor: false,
            description: nls.localize('openSymbolDescriptionNormal', "Go to Symbol in Workspace")
        }
    ]));
    // Configuration
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    configurationRegistry.registerConfiguration({
        id: 'search',
        order: 13,
        title: nls.localize('searchConfigurationTitle', "Search"),
        type: 'object',
        properties: {
            'search.exclude': {
                type: 'object',
                markdownDescription: nls.localize('exclude', "Configure glob patterns for excluding files and folders in searches. Inherits all glob patterns from the `#files.exclude#` setting. Read more about glob patterns [here](https://code.visualstudio.com/docs/editor/codebasics#_advanced-search-options)."),
                default: { '**/node_modules': true, '**/bower_components': true },
                additionalProperties: {
                    anyOf: [
                        {
                            type: 'boolean',
                            description: nls.localize('exclude.boolean', "The glob pattern to match file paths against. Set to true or false to enable or disable the pattern."),
                        },
                        {
                            type: 'object',
                            properties: {
                                when: {
                                    type: 'string',
                                    pattern: '\\w*\\$\\(basename\\)\\w*',
                                    default: '$(basename).ext',
                                    description: nls.localize('exclude.when', 'Additional check on the siblings of a matching file. Use $(basename) as variable for the matching file name.')
                                }
                            }
                        }
                    ]
                },
                scope: 3 /* RESOURCE */
            },
            'search.useRipgrep': {
                type: 'boolean',
                description: nls.localize('useRipgrep', "Controls whether to use ripgrep in text and file search."),
                default: true
            },
            'search.useIgnoreFiles': {
                type: 'boolean',
                markdownDescription: nls.localize('useIgnoreFiles', "Controls whether to use `.gitignore` and `.ignore` files when searching for files."),
                default: true,
                scope: 3 /* RESOURCE */
            },
            'search.quickOpen.includeSymbols': {
                type: 'boolean',
                description: nls.localize('search.quickOpen.includeSymbols', "Whether to include results from a global symbol search in the file results for Quick Open."),
                default: false
            },
            'search.quickOpen.includeHistory': {
                type: 'boolean',
                description: nls.localize('search.quickOpen.includeHistory', "Whether to include results from recently opened files in the file results for Quick Open."),
                default: true
            },
            'search.followSymlinks': {
                type: 'boolean',
                description: nls.localize('search.followSymlinks', "Controls whether to follow symlinks while searching."),
                default: true
            },
            'search.smartCase': {
                type: 'boolean',
                description: nls.localize('search.smartCase', "Search case-insensitively if the pattern is all lowercase, otherwise, search case-sensitively."),
                default: false
            },
            'search.globalFindClipboard': {
                type: 'boolean',
                default: false,
                description: nls.localize('search.globalFindClipboard', "Controls whether the search view should read or modify the shared find clipboard on macOS."),
                included: platform.isMacintosh
            },
            'search.location': {
                type: 'string',
                enum: ['sidebar', 'panel'],
                default: 'sidebar',
                description: nls.localize('search.location', "Controls whether the search will be shown as a view in the sidebar or as a panel in the panel area for more horizontal space."),
            },
            'search.collapseResults': {
                type: 'string',
                enum: ['auto', 'alwaysCollapse', 'alwaysExpand'],
                enumDescriptions: [
                    'Files with less than 10 results are expanded. Others are collapsed.',
                    '',
                    ''
                ],
                default: 'auto',
                description: nls.localize('search.collapseAllResults', "Controls whether the search results will be collapsed or expanded."),
            }
        }
    });
    editorExtensions_1.registerLanguageCommand('_executeWorkspaceSymbolProvider', function (accessor, args) {
        var query = args.query;
        if (typeof query !== 'string') {
            throw errors_1.illegalArgument();
        }
        return search_1.getWorkspaceSymbols(query);
    });
    // View menu
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarViewMenu, {
        group: '3_views',
        command: {
            id: search_2.VIEW_ID,
            title: nls.localize({ key: 'miViewSearch', comment: ['&& denotes a mnemonic'] }, "&&Search")
        },
        order: 2
    });
    // Go to menu
    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarGoMenu, {
        group: 'z_go_to',
        command: {
            id: 'workbench.action.showAllSymbols',
            title: nls.localize({ key: 'miGotoSymbolInWorkspace', comment: ['&& denotes a mnemonic'] }, "Go to Symbol in &&Workspace...")
        },
        order: 3
    });
});

define(__m[347/*vs/codesandbox/codesandbox.all*/], __M([0/*require*/,1/*exports*/,423/*vs/workbench/browser/parts/quickopen/quickopen.contribution*/,395/*vs/workbench/parts/quickopen/browser/quickopen.contribution*/,229/*vs/workbench/browser/parts/editor/editorPicker*/,345/*vs/workbench/browser/parts/quickinput/quickInput.contribution*/,287/*vs/workbench/parts/search/electron-browser/search.contribution*/,378/*vs/codesandbox/configuration.contribution*/,249/*vs/workbench/parts/preferences/electron-browser/preferences.contribution*/,260/*vs/workbench/parts/files/electron-browser/files.contribution*/,314/*vs/codesandbox/services/codesandbox/codesandbox.contribution*/,390/*vs/workbench/parts/codeEditor/electron-browser/largeFileOptimizations*/,172/*vs/workbench/parts/codeEditor/browser/menuPreventer*/,171/*vs/workbench/parts/codeEditor/electron-browser/selectionClipboard*/,410/*vs/workbench/parts/codeEditor/electron-browser/toggleMinimap*/,411/*vs/workbench/parts/codeEditor/electron-browser/toggleMultiCursorModifier*/,413/*vs/workbench/parts/codeEditor/electron-browser/toggleRenderControlCharacter*/,415/*vs/workbench/parts/codeEditor/electron-browser/toggleRenderWhitespace*/,416/*vs/workbench/parts/codeEditor/electron-browser/toggleWordWrap*/,427/*vs/workbench/parts/codeEditor/electron-browser/workbenchReferenceSearch*/,117/*vs/workbench/parts/snippets/electron-browser/snippets.contribution*/,192/*vs/workbench/parts/snippets/electron-browser/snippetsService*/,268/*vs/workbench/parts/snippets/electron-browser/insertSnippet*/,263/*vs/workbench/parts/snippets/electron-browser/configureSnippets*/,333/*vs/workbench/parts/snippets/electron-browser/tabCompletion*/,103/*vs/workbench/browser/parts/editor/breadcrumbs*/,338/*vs/workbench/browser/actions/toggleZenMode*/,315/*vs/workbench/browser/actions/toggleTabsVisibility*/,328/*vs/workbench/parts/preferences/browser/keybindingsEditorContribution*/,226/*vs/codesandbox/services/codesandbox/browser/codesandboxService*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});

define(__m[488/*vs/editor/codesandbox.editor.main*/], __M([0/*require*/,1/*exports*/,310/*vs/editor/codesandbox.editor.api*/,489/*vs/editor/editor.all*/,490/*vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp*/,491/*vs/editor/standalone/browser/inspectTokens/inspectTokens*/,492/*vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard*/,347/*vs/codesandbox/codesandbox.all*/]), function (require, exports, codesandbox_editor_api_1) {
    'use strict';
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(codesandbox_editor_api_1);
});

}).call(this);
//# sourceMappingURL=codesandbox.editor.main.js.map
