(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tty'), require('util'), require('os'), require('assert'), require('path'), require('fs'), require('buffer'), require('module')) :
  typeof define === 'function' && define.amd ? define(['exports', 'tty', 'util', 'os', 'assert', 'path', 'fs', 'buffer', 'module'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Babel = {}, global.tty, global.util$5, global.os, global.assert$2, global.path$1, global.fs, global.buffer, global.module));
}(this, (function (exports, tty, util$5, os, assert$2, path$1, fs, buffer, module) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var tty__default = /*#__PURE__*/_interopDefaultLegacy(tty);
  var util__default = /*#__PURE__*/_interopDefaultLegacy(util$5);
  var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
  var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert$2);
  var path__default = /*#__PURE__*/_interopDefaultLegacy(path$1);
  var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
  var buffer__default = /*#__PURE__*/_interopDefaultLegacy(buffer);
  var module__default = /*#__PURE__*/_interopDefaultLegacy(module);

  var context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get types () { return t; },
    get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
    get OptionManager () { return OptionManager; },
    get Plugin () { return Plugin$1; },
    get File () { return File$1; },
    get buildExternalHelpers () { return babelBuildExternalHelpers; },
    get resolvePlugin () { return resolvePlugin; },
    get resolvePreset () { return resolvePreset; },
    get version () { return version; },
    get getEnv () { return getEnv; },
    get tokTypes () { return types; },
    get traverse () { return traverse$1; },
    get template () { return template; },
    get createConfigItem () { return createConfigItem; },
    get loadPartialConfig () { return loadPartialConfig$1; },
    get loadPartialConfigSync () { return loadPartialConfigSync; },
    get loadPartialConfigAsync () { return loadPartialConfigAsync; },
    get loadOptions () { return loadOptions; },
    get loadOptionsSync () { return loadOptionsSync; },
    get loadOptionsAsync () { return loadOptionsAsync; },
    get transform () { return transform; },
    get transformSync () { return transformSync; },
    get transformAsync () { return transformAsync; },
    get transformFile () { return transformFile$1; },
    get transformFileSync () { return transformFileSync; },
    get transformFileAsync () { return transformFileAsync; },
    get transformFromAst () { return transformFromAst; },
    get transformFromAstSync () { return transformFromAstSync; },
    get transformFromAstAsync () { return transformFromAstAsync; },
    get parse () { return parse$2; },
    get parseSync () { return parseSync; },
    get parseAsync () { return parseAsync; }
  });

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var REACT_ELEMENT_TYPE;

  function _jsx(type, props, key, children) {
    if (!REACT_ELEMENT_TYPE) {
      REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 0xeac7;
    }

    var defaultProps = type && type.defaultProps;
    var childrenLength = arguments.length - 3;

    if (!props && childrenLength !== 0) {
      props = {
        children: void 0
      };
    }

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = new Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 3];
      }

      props.children = childArray;
    }

    if (props && defaultProps) {
      for (var propName in defaultProps) {
        if (props[propName] === void 0) {
          props[propName] = defaultProps[propName];
        }
      }
    } else if (!props) {
      props = defaultProps || {};
    }

    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key === undefined ? null : '' + key,
      ref: null,
      props: props,
      _owner: null
    };
  }

  function _asyncIterator(iterable) {
    var method;

    if (typeof Symbol !== "undefined") {
      if (Symbol.asyncIterator) {
        method = iterable[Symbol.asyncIterator];
        if (method != null) return method.call(iterable);
      }

      if (Symbol.iterator) {
        method = iterable[Symbol.iterator];
        if (method != null) return method.call(iterable);
      }
    }

    throw new TypeError("Object is not async iterable");
  }

  function _AwaitValue(value) {
    this.wrapped = value;
  }

  function _AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;
        var wrappedAwait = value instanceof _AwaitValue;
        Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
          if (wrappedAwait) {
            resume(key === "return" ? "return" : "next", arg);
            return;
          }

          settle(result.done ? "return" : "normal", arg);
        }, function (err) {
          resume("throw", err);
        });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  _AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  _AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  _AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  function _wrapAsyncGenerator(fn) {
    return function () {
      return new _AsyncGenerator(fn.apply(this, arguments));
    };
  }

  function _awaitAsyncGenerator(value) {
    return new _AwaitValue(value);
  }

  function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {},
        waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) {
        resolve(inner[key](value));
      });
      return {
        done: false,
        value: awaitWrap(value)
      };
    }

    if (typeof Symbol === "function" && Symbol.iterator) {
      iter[Symbol.iterator] = function () {
        return this;
      };
    }

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }

        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }

        return pump("return", value);
      };
    }

    return iter;
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);

      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }

    return obj;
  }

  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function () {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
      return {
        default: obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj.default = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  function _readOnlyError(name) {
    throw new Error("\"" + name + "\" is read-only");
  }

  function _classNameTDZError(name) {
    throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
  }

  function _temporalUndefined() {}

  function _tdz(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }

  function _temporalRef(val, name) {
    return val === _temporalUndefined ? _tdz(name) : val;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _slicedToArrayLoose(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return _arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }

    return next(arr, i);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _iterableToArrayLimitLoose(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];

    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
      _arr.push(_step.value);

      if (i && _arr.length === i) break;
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = o[Symbol.iterator]();
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it;

    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    it = o[Symbol.iterator]();
    return it.next.bind(it);
  }

  function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    };
  }

  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];

    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }

    return (hint === "string" ? String : Number)(input);
  }

  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");

    return typeof key === "symbol" ? key : String(key);
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
  }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  var id = 0;

  function _classPrivateFieldLooseKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  function _classPrivateFieldLooseBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
  }

  function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = privateMap.get(receiver);

    if (!descriptor) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      descriptor.value = value;
    }

    return value;
  }

  function _classPrivateFieldDestructureSet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }

    var descriptor = privateMap.get(receiver);

    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v);
          }

        };
      }

      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }

  function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }

    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }

    return descriptor.value;
  }

  function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }

    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        throw new TypeError("attempted to set read only private field");
      }

      descriptor.value = value;
    }

    return value;
  }

  function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }

    return method;
  }

  function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }

  function _decorate(decorators, factory, superClass, mixins) {
    var api = _getDecoratorsApi();

    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);
    api.initializeClassElements(r.F, decorated.elements);
    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function () {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],
      initializeInstanceElements: function (O, elements) {
        ["method", "field"].forEach(function (kind) {
          elements.forEach(function (element) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },
      initializeClassElements: function (F, elements) {
        var proto = F.prototype;
        ["method", "field"].forEach(function (kind) {
          elements.forEach(function (element) {
            var placement = element.placement;

            if (element.kind === kind && (placement === "static" || placement === "prototype")) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },
      defineClassElement: function (receiver, element) {
        var descriptor = element.descriptor;

        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver)
          };
        }

        Object.defineProperty(receiver, element.key, descriptor);
      },
      decorateClass: function (elements, decorators) {
        var newElements = [];
        var finishers = [];
        var placements = {
          static: [],
          prototype: [],
          own: []
        };
        elements.forEach(function (element) {
          this.addElementPlacement(element, placements);
        }, this);
        elements.forEach(function (element) {
          if (!_hasDecorators(element)) return newElements.push(element);
          var elementFinishersExtras = this.decorateElement(element, placements);
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return {
            elements: newElements,
            finishers: finishers
          };
        }

        var result = this.decorateConstructor(newElements, decorators);
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;
        return result;
      },
      addElementPlacement: function (element, placements, silent) {
        var keys = placements[element.placement];

        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }

        keys.push(element.key);
      },
      decorateElement: function (element, placements) {
        var extras = [];
        var finishers = [];

        for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);
          var elementObject = this.fromElementDescriptor(element);
          var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);
          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras = elementFinisherExtras.extras;

          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }

            extras.push.apply(extras, newExtras);
          }
        }

        return {
          element: element,
          finishers: finishers,
          extras: extras
        };
      },
      decorateConstructor: function (elements, decorators) {
        var finishers = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj = this.fromClassDescriptor(elements);
          var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {
                  throw new TypeError("Duplicated element (" + elements[j].key + ")");
                }
              }
            }
          }
        }

        return {
          elements: elements,
          finishers: finishers
        };
      },
      fromElementDescriptor: function (element) {
        var obj = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor
        };
        var desc = {
          value: "Descriptor",
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        if (element.kind === "field") obj.initializer = element.initializer;
        return obj;
      },
      toElementDescriptors: function (elementObjects) {
        if (elementObjects === undefined) return;
        return _toArray(elementObjects).map(function (elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },
      toElementDescriptor: function (elementObject) {
        var kind = String(elementObject.kind);

        if (kind !== "method" && kind !== "field") {
          throw new TypeError('An element descriptor\'s .kind property must be either "method" or' + ' "field", but a decorator created an element descriptor with' + ' .kind "' + kind + '"');
        }

        var key = _toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);

        if (placement !== "static" && placement !== "prototype" && placement !== "own") {
          throw new TypeError('An element descriptor\'s .placement property must be one of "static",' + ' "prototype" or "own", but a decorator created an element descriptor' + ' with .placement "' + placement + '"');
        }

        var descriptor = elementObject.descriptor;
        this.disallowProperty(elementObject, "elements", "An element descriptor");
        var element = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor)
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(descriptor, "get", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "set", "The property descriptor of a field descriptor");
          this.disallowProperty(descriptor, "value", "The property descriptor of a field descriptor");
          element.initializer = elementObject.initializer;
        }

        return element;
      },
      toElementFinisherExtras: function (elementObject) {
        var element = this.toElementDescriptor(elementObject);

        var finisher = _optionalCallableProperty(elementObject, "finisher");

        var extras = this.toElementDescriptors(elementObject.extras);
        return {
          element: element,
          finisher: finisher,
          extras: extras
        };
      },
      fromClassDescriptor: function (elements) {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this)
        };
        var desc = {
          value: "Descriptor",
          configurable: true
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);
        return obj;
      },
      toClassDescriptor: function (obj) {
        var kind = String(obj.kind);

        if (kind !== "class") {
          throw new TypeError('A class descriptor\'s .kind property must be "class", but a decorator' + ' created a class descriptor with .kind "' + kind + '"');
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");

        var elements = this.toElementDescriptors(obj.elements);
        return {
          elements: elements,
          finisher: finisher
        };
      },
      runClassFinishers: function (constructor, finishers) {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor = (0, finishers[i])(constructor);

          if (newConstructor !== undefined) {
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }

            constructor = newConstructor;
          }
        }

        return constructor;
      },
      disallowProperty: function (obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };
    return api;
  }

  function _createElementDescriptor(def) {
    var key = _toPropertyKey(def.key);

    var descriptor;

    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "get") {
      descriptor = {
        get: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "set") {
      descriptor = {
        set: def.value,
        configurable: true,
        enumerable: false
      };
    } else if (def.kind === "field") {
      descriptor = {
        configurable: true,
        writable: true,
        enumerable: true
      };
    }

    var element = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static ? "static" : def.kind === "field" ? "own" : "prototype",
      descriptor: descriptor
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;
    return element;
  }

  function _coalesceGetterSetter(element, other) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  function _coalesceClassElements(elements) {
    var newElements = [];

    var isSameElement = function (other) {
      return other.kind === "method" && other.key === element.key && other.placement === element.placement;
    };

    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var other;

      if (element.kind === "method" && (other = newElements.find(isSameElement))) {
        if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError("Duplicated methods (" + element.key + ") can't be decorated.");
          }

          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError("Decorators can't be placed on different accessors with for " + "the same property (" + element.key + ").");
            }

            other.decorators = element.decorators;
          }

          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element) {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc) {
    return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);
  }

  function _optionalCallableProperty(obj, name) {
    var value = obj[name];

    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }

    return value;
  }

  function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }

    return fn;
  }

  function _classPrivateMethodSet() {
    throw new TypeError("attempted to reassign private method");
  }

  function _wrapRegExp(re, groups) {
    _wrapRegExp = function (re, groups) {
      return new BabelRegExp(re, undefined, groups);
    };

    var _RegExp = _wrapNativeSuper(RegExp);

    var _super = RegExp.prototype;

    var _groups = new WeakMap();

    function BabelRegExp(re, flags, groups) {
      var _this = _RegExp.call(this, re, flags);

      _groups.set(_this, groups || _groups.get(re));

      return _this;
    }

    _inherits(BabelRegExp, _RegExp);

    BabelRegExp.prototype.exec = function (str) {
      var result = _super.exec.call(this, str);

      if (result) result.groups = buildGroups(result, this);
      return result;
    };

    BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
      if (typeof substitution === "string") {
        var groups = _groups.get(this);

        return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
          return "$" + groups[name];
        }));
      } else if (typeof substitution === "function") {
        var _this = this;

        return _super[Symbol.replace].call(this, str, function () {
          var args = [];
          args.push.apply(args, arguments);

          if (typeof args[args.length - 1] !== "object") {
            args.push(buildGroups(args, _this));
          }

          return substitution.apply(this, args);
        });
      } else {
        return _super[Symbol.replace].call(this, str, substitution);
      }
    };

    function buildGroups(result, re) {
      var g = _groups.get(re);

      return Object.keys(g).reduce(function (groups, name) {
        groups[name] = result[g[name]];
        return groups;
      }, Object.create(null));
    }

    return _wrapRegExp.apply(this, arguments);
  }

  var _rollupPluginBabelHelpers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get typeof () { return _typeof; },
    jsx: _jsx,
    asyncIterator: _asyncIterator,
    AwaitValue: _AwaitValue,
    AsyncGenerator: _AsyncGenerator,
    wrapAsyncGenerator: _wrapAsyncGenerator,
    awaitAsyncGenerator: _awaitAsyncGenerator,
    asyncGeneratorDelegate: _asyncGeneratorDelegate,
    asyncToGenerator: _asyncToGenerator,
    classCallCheck: _classCallCheck,
    createClass: _createClass,
    defineEnumerableProperties: _defineEnumerableProperties,
    defaults: _defaults,
    defineProperty: _defineProperty,
    get extends () { return _extends; },
    objectSpread: _objectSpread,
    objectSpread2: _objectSpread2,
    inherits: _inherits,
    inheritsLoose: _inheritsLoose,
    get getPrototypeOf () { return _getPrototypeOf; },
    get setPrototypeOf () { return _setPrototypeOf; },
    isNativeReflectConstruct: _isNativeReflectConstruct,
    get construct () { return _construct; },
    isNativeFunction: _isNativeFunction,
    get wrapNativeSuper () { return _wrapNativeSuper; },
    'instanceof': _instanceof,
    interopRequireDefault: _interopRequireDefault,
    interopRequireWildcard: _interopRequireWildcard,
    newArrowCheck: _newArrowCheck,
    objectDestructuringEmpty: _objectDestructuringEmpty,
    objectWithoutPropertiesLoose: _objectWithoutPropertiesLoose,
    objectWithoutProperties: _objectWithoutProperties,
    assertThisInitialized: _assertThisInitialized,
    possibleConstructorReturn: _possibleConstructorReturn,
    createSuper: _createSuper,
    superPropBase: _superPropBase,
    get get () { return _get; },
    set: _set,
    taggedTemplateLiteral: _taggedTemplateLiteral,
    taggedTemplateLiteralLoose: _taggedTemplateLiteralLoose,
    readOnlyError: _readOnlyError,
    classNameTDZError: _classNameTDZError,
    temporalUndefined: _temporalUndefined,
    tdz: _tdz,
    temporalRef: _temporalRef,
    slicedToArray: _slicedToArray,
    slicedToArrayLoose: _slicedToArrayLoose,
    toArray: _toArray,
    toConsumableArray: _toConsumableArray,
    arrayWithoutHoles: _arrayWithoutHoles,
    arrayWithHoles: _arrayWithHoles,
    maybeArrayLike: _maybeArrayLike,
    iterableToArray: _iterableToArray,
    iterableToArrayLimit: _iterableToArrayLimit,
    iterableToArrayLimitLoose: _iterableToArrayLimitLoose,
    unsupportedIterableToArray: _unsupportedIterableToArray,
    arrayLikeToArray: _arrayLikeToArray,
    nonIterableSpread: _nonIterableSpread,
    nonIterableRest: _nonIterableRest,
    createForOfIteratorHelper: _createForOfIteratorHelper,
    createForOfIteratorHelperLoose: _createForOfIteratorHelperLoose,
    skipFirstGeneratorNext: _skipFirstGeneratorNext,
    toPrimitive: _toPrimitive,
    toPropertyKey: _toPropertyKey,
    initializerWarningHelper: _initializerWarningHelper,
    initializerDefineProperty: _initializerDefineProperty,
    applyDecoratedDescriptor: _applyDecoratedDescriptor,
    classPrivateFieldLooseKey: _classPrivateFieldLooseKey,
    classPrivateFieldLooseBase: _classPrivateFieldLooseBase,
    classPrivateFieldGet: _classPrivateFieldGet,
    classPrivateFieldSet: _classPrivateFieldSet,
    classPrivateFieldDestructureSet: _classPrivateFieldDestructureSet,
    classStaticPrivateFieldSpecGet: _classStaticPrivateFieldSpecGet,
    classStaticPrivateFieldSpecSet: _classStaticPrivateFieldSpecSet,
    classStaticPrivateMethodGet: _classStaticPrivateMethodGet,
    classStaticPrivateMethodSet: _classStaticPrivateMethodSet,
    decorate: _decorate,
    classPrivateMethodGet: _classPrivateMethodGet,
    classPrivateMethodSet: _classPrivateMethodSet,
    get wrapRegExp () { return _wrapRegExp; }
  });

  function shallowEqual(actual, expected) {
    var keys = Object.keys(expected);

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];

      if (actual[key] !== expected[key]) {
        return false;
      }
    }

    return true;
  }

  function isArrayExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BinaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterpreterDirective") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Directive") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DirectiveLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BlockStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BreakStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CatchClause") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ConditionalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ContinueStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DebuggerStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoWhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExpressionStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "File") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForInStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Identifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LabeledStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumericLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegExpLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LogicalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNewExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NewExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProgram(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Program") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ReturnStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSequenceExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SequenceExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ParenthesizedExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchCase") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThrowStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TryStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUpdateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UpdateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclarator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WithStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrowFunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamedDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForOfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForOfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMetaProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MetaProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSuper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Super") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TaggedTemplateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isYieldExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "YieldExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AwaitExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImport(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Import") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BigIntLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalCallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AnyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassImplements") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareClass") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareInterface") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModule") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModuleExports") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareTypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareOpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareVariable") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclaredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExistsTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeParam") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "GenericTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InferredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceExtends") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IntersectionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MixedTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullableTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeInternalSlot") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeCallProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeIndexer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeSpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "QualifiedTypeIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SymbolTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeofTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeCastExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariance(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Variance") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VoidTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumSymbolBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDefaultedMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXEmptyExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXExpressionContainer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadChild") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXNamespacedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXText") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNoop(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Noop") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Placeholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "V8IntrinsicIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArgumentPlaceholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BindExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineTopicExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineBareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelinePrimaryTopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDecorator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Decorator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivateName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PrivateName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRecordExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RecordExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DecimalLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStaticBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StaticBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParameterProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSQualifiedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSCallSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSPropertySignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMethodSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAnyKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBooleanKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBigIntKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIntrinsicKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNeverKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNullKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNumberKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSObjectKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSStringKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSSymbolKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUndefinedKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnknownKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSVoidKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSThisType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSFunctionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructorType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypePredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeQuery") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSArrayType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSArrayType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTupleType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSOptionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSRestType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNamedTupleMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIntersectionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConditionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInferType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParenthesizedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeOperator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMappedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSLiteralType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExpressionWithTypeArguments") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAliasDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAsExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAsExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAssertion") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportEqualsDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExternalModuleReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNonNullExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExportAssignment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNamespaceExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinary(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isScopable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditional(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLoop(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFor(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForXStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPureish(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLVal(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlow(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSX(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBaseType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegexLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }

  function matchesPattern(member, match, allowPartial) {
    if (!isMemberExpression(member)) return false;
    var parts = Array.isArray(match) ? match : match.split(".");
    var nodes = [];
    var node;

    for (node = member; isMemberExpression(node); node = node.object) {
      nodes.push(node.property);
    }

    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;

    for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      var _node = nodes[j];
      var value = void 0;

      if (isIdentifier(_node)) {
        value = _node.name;
      } else if (isStringLiteral(_node)) {
        value = _node.value;
      } else {
        return false;
      }

      if (parts[i] !== value) return false;
    }

    return true;
  }

  function buildMatchMemberExpression(match, allowPartial) {
    var parts = match.split(".");
    return function (member) {
      return matchesPattern(member, parts, allowPartial);
    };
  }

  var isReactComponent = buildMatchMemberExpression("React.Component");

  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;

  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  	  path: basedir,
  	  exports: {},
  	  require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
  	}, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  var Symbol$1 = _root.Symbol;
  var _Symbol = Symbol$1;

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  var objectProto$1 = Object.prototype;
  var nativeObjectToString$1 = objectProto$1.toString;

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  function isFunction$1(value) {
    if (!isObject_1(value)) {
      return false;
    }

    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$1;

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;

  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  var funcToString$1 = funcProto$1.toString;
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  var Map$1 = _getNative(_root, 'Map');
  var _Map = Map$1;

  var nativeCreate = _getNative(Object, 'create');
  var _nativeCreate = nativeCreate;

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var objectProto$3 = Object.prototype;
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
  }

  var _hashHas = hashHas;

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;

  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;

  var LARGE_ARRAY_SIZE = 200;

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  }

  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;

  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty$1 = defineProperty;

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty$1) {
      _defineProperty$1(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  var objectProto$5 = Object.prototype;
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;

  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;

  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  var argsTag = '[object Arguments]';

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  var objectProto$6 = Object.prototype;
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;

  var isArray = Array.isArray;
  var isArray_1 = isArray;

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? _root.Buffer : undefined;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse_1;
  module.exports = isBuffer;
  });

  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;

  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && _freeGlobal.process;

  var nodeUtil = function () {
    try {
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  module.exports = nodeUtil;
  });

  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;

  var objectProto$7 = Object.prototype;
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  var objectProto$8 = Object.prototype;

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;
    return value === proto;
  }

  var _isPrototype = isPrototype;

  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  var nativeKeys = _overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys;

  var objectProto$9 = Object.prototype;
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  function baseAssign(object, source) {
    return object && _copyObject(source, keys_1(source), object);
  }

  var _baseAssign = baseAssign;

  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;

  var objectProto$a = Object.prototype;
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;

  function keysIn(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn;

  function baseAssignIn(object, source) {
    return object && _copyObject(source, keysIn_1(source), object);
  }

  var _baseAssignIn = baseAssignIn;

  var _cloneBuffer = createCommonjsModule(function (module, exports) {
  var freeExports =  exports && !exports.nodeType && exports;
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? _root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }

    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }

  module.exports = cloneBuffer;
  });

  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;

  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;

  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  var objectProto$b = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;

  function copySymbols(source, object) {
    return _copyObject(source, _getSymbols(source), object);
  }

  var _copySymbols = copySymbols;

  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;

  var getPrototype = _overArg(Object.getPrototypeOf, Object);
  var _getPrototype = getPrototype;

  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function (object) {
    var result = [];

    while (object) {
      _arrayPush(result, _getSymbols(object));
      object = _getPrototype(object);
    }

    return result;
  };
  var _getSymbolsIn = getSymbolsIn;

  function copySymbolsIn(source, object) {
    return _copyObject(source, _getSymbolsIn(source), object);
  }

  var _copySymbolsIn = copySymbolsIn;

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  function getAllKeysIn(object) {
    return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
  }

  var _getAllKeysIn = getAllKeysIn;

  var DataView = _getNative(_root, 'DataView');
  var _DataView = DataView;

  var Promise$1 = _getNative(_root, 'Promise');
  var _Promise = Promise$1;

  var Set$1 = _getNative(_root, 'Set');
  var _Set = Set$1;

  var WeakMap$1 = _getNative(_root, 'WeakMap');
  var _WeakMap = WeakMap$1;

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  var getTag = _baseGetTag;

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;

  var objectProto$c = Object.prototype;
  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  var _initCloneArray = initCloneArray;

  var Uint8Array = _root.Uint8Array;
  var _Uint8Array = Uint8Array;

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer;

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  var _cloneDataView = cloneDataView;

  var reFlags = /\w*$/;

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  var _cloneRegExp = cloneRegExp;

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  var _cloneSymbol = cloneSymbol;

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var _cloneTypedArray = cloneTypedArray;

  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag$1:
        return _cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$2:
        return _cloneDataView(object, isDeep);

      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return _cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor();

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return _cloneRegExp(object);

      case setTag$2:
        return new Ctor();

      case symbolTag:
        return _cloneSymbol(object);
    }
  }

  var _initCloneByTag = initCloneByTag;

  var objectCreate = Object.create;

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject_1(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  var _baseCreate = baseCreate;

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
  }

  var _initCloneObject = initCloneObject;

  var mapTag$3 = '[object Map]';

  function baseIsMap(value) {
    return isObjectLike_1(value) && _getTag(value) == mapTag$3;
  }

  var _baseIsMap = baseIsMap;

  var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
  var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
  var isMap_1 = isMap;

  var setTag$3 = '[object Set]';

  function baseIsSet(value) {
    return isObjectLike_1(value) && _getTag(value) == setTag$3;
  }

  var _baseIsSet = baseIsSet;

  var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
  var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
  var isSet_1 = isSet;

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]',
      weakMapTag$2 = '[object WeakMap]';
  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';
  var cloneableTags = {};
  cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject_1(value)) {
      return value;
    }

    var isArr = isArray_1(value);

    if (isArr) {
      result = _initCloneArray(value);

      if (!isDeep) {
        return _copyArray(value, result);
      }
    } else {
      var tag = _getTag(value),
          isFunc = tag == funcTag$2 || tag == genTag$1;

      if (isBuffer_1(value)) {
        return _cloneBuffer(value, isDeep);
      }

      if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
        result = isFlat || isFunc ? {} : _initCloneObject(value);

        if (!isDeep) {
          return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = _initCloneByTag(value, tag, isDeep);
      }
    }

    stack || (stack = new _Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet_1(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_1(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;
    var props = isArr ? undefined : keysFunc(value);
    _arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }

      _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var _baseClone = baseClone;

  var CLONE_SYMBOLS_FLAG$1 = 4;

  function clone(value) {
    return _baseClone(value, CLONE_SYMBOLS_FLAG$1);
  }

  var clone_1 = clone;

  var fastProto = null;

  function FastObject(o) {
    if (fastProto !== null && typeof fastProto.property) {
      var result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }

    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject();
  }

  FastObject();

  var toFastProperties = function toFastproperties(o) {
    return FastObject(o);
  };

  function isType(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (ALIAS_KEYS[targetType]) return false;
    var aliases = FLIPPED_ALIAS_KEYS[targetType];

    if (aliases) {
      if (aliases[0] === nodeType) return true;

      for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
        var alias = _step.value;
        if (nodeType === alias) return true;
      }
    }

    return false;
  }

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    var aliases = PLACEHOLDERS_ALIAS[placeholderType];

    if (aliases) {
      for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
        var alias = _step.value;
        if (targetType === alias) return true;
      }
    }

    return false;
  }

  function is(type, node, opts) {
    if (!node) return false;
    var matches = isType(node.type, type);

    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS) {
        return isPlaceholderType(node.expectedNode, type);
      }

      return false;
    }

    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;

    for (var i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    var isFirst = true;

    for (var _i2 = 0, _Array$from2 = Array.from(name); _i2 < _Array$from2.length; _i2++) {
      var _char = _Array$from2[_i2];

      var cp = _char.codePointAt(0);

      if (isFirst) {
        if (!isIdentifierStart(cp)) {
          return false;
        }

        isFirst = false;
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }

    return !isFirst;
  }

  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }

  function isValidIdentifier(name, reserved) {
    if (reserved === void 0) {
      reserved = true;
    }

    if (typeof name !== "string") return false;

    if (reserved) {
      if (isKeyword(name) || isStrictReservedWord(name, true)) {
        return false;
      }
    }

    return isIdentifierName(name);
  }

  var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
  var BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);
  var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);
  var ASSIGNMENT_OPERATORS = ["=", "+="].concat(NUMBER_BINARY_OPERATORS.map(function (op) {
    return op + "=";
  }), LOGICAL_OPERATORS.map(function (op) {
    return op + "=";
  }));
  var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
  var INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
  var NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");

  function validate(node, key, val) {
    if (!node) return;
    var fields = NODE_FIELDS[node.type];
    if (!fields) return;
    var field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateField(node, key, val, field) {
    if (!(field == null ? void 0 : field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    if (val == null) return;
    var validate = NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }

  var VISITOR_KEYS = {};
  var ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = {};
  var BUILDER_KEYS = {};
  var DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = {};

  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }

  function validate$1(validate) {
    return {
      validate: validate
    };
  }
  function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, typeName);
  }
  function validateType(typeName) {
    return validate$1(typeIs(typeName));
  }
  function validateOptional(validate) {
    return {
      validate: validate,
      optional: true
    };
  }
  function validateOptionalType(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function validateArrayOfType(typeName) {
    return validate$1(arrayOfType(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;

      for (var i = 0; i < val.length; i++) {
        var subkey = key + "[" + i + "]";
        var v = val[i];
        callback(node, subkey, v);
        if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);
      }
    }

    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
      }
    }

    validate.oneOf = values;
    return validate;
  }
  function assertNodeType() {
    for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }

    function validate(node, key, val) {
      for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
        var type = _step.value;

        if (is(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
    }

    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }

    function validate(node, key, val) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
        var type = _step2.value;

        if (getType(val) === type || is(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
    }

    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      var valid = getType(val) === type;

      if (!valid) {
        throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType(val));
      }
    }

    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      var errors = [];

      for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
        var property = _Object$keys[_i];

        try {
          validateField(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }

          throw error;
        }
      }

      if (errors.length) {
        throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
      }
    }

    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current2;

      var current = node;

      while (node) {
        var _current = current,
            type = _current.type;

        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }

        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }

        break;
      }

      throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
    }

    return validate;
  }
  function chain() {
    for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }

    var validate = function validate() {
      for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
        var fn = _step3.value;
        fn.apply(void 0, arguments);
      }
    };

    validate.chainOf = fns;
    return validate;
  }
  var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  var validFieldKeys = ["default", "optional", "validate"];
  function defineType(type, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var inherits = opts.inherits && store[opts.inherits] || {};
    var fields = opts.fields;

    if (!fields) {
      fields = {};

      if (inherits.fields) {
        var keys = Object.getOwnPropertyNames(inherits.fields);

        for (var _iterator4 = _createForOfIteratorHelperLoose(keys), _step4; !(_step4 = _iterator4()).done;) {
          var _key5 = _step4.value;
          var field = inherits.fields[_key5];
          fields[_key5] = {
            "default": field["default"],
            optional: field.optional,
            validate: field.validate
          };
        }
      }
    }

    var visitor = opts.visitor || inherits.visitor || [];
    var aliases = opts.aliases || inherits.aliases || [];
    var builder = opts.builder || inherits.builder || opts.visitor || [];

    for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];

      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error("Unknown type option \"" + k + "\" on " + type);
      }
    }

    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }

    for (var _iterator5 = _createForOfIteratorHelperLoose(visitor.concat(builder)), _step5; !(_step5 = _iterator5()).done;) {
      var _key7 = _step5.value;
      fields[_key7] = fields[_key7] || {};
    }

    for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {
      var _key6 = _Object$keys3[_i3];
      var _field = fields[_key6];

      if (_field["default"] !== undefined && builder.indexOf(_key6) === -1) {
        _field.optional = true;
      }

      if (_field["default"] === undefined) {
        _field["default"] = null;
      } else if (!_field.validate && _field["default"] != null) {
        _field.validate = assertValueType(getType(_field["default"]));
      }

      for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {
        var _k = _Object$keys4[_i4];

        if (validFieldKeys.indexOf(_k) === -1) {
          throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key6);
        }
      }
    }

    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(function (alias) {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });

    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }

    store[type] = opts;
  }
  var store = {};

  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
        "default": !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertValueType("string");
          }

          var identifier = assertOneOf.apply(void 0, ASSIGNMENT_OPERATORS);
          var pattern = assertOneOf("=");
          return function (node, key, val) {
            var validator = is("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }()
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, BINARY_OPERATORS)
      },
      left: {
        validate: function () {
          var expression = assertNodeType("Expression");
          var inOp = assertNodeType("Expression", "PrivateName");

          var validator = function validator(node, key, val) {
            var validator = node.operator === "in" ? inOp : expression;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "PrivateName"];
          return validator;
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: assertNodeType("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: assertNodeType("Expression", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Expression")
      },
      alternate: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: assertNodeType("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : assertEach(assertNodeType("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: assertEach(Object.assign(function () {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: assertNodeType("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      update: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  var functionCommon = {
    params: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    generator: {
      "default": false
    },
    async: {
      "default": false
    }
  };
  var functionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  var functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
      validate: assertValueType("boolean"),
      optional: true
    },
    id: {
      validate: assertNodeType("Identifier"),
      optional: true
    }
  });
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function () {
      if (!process.env.BABEL_TYPES_8_BREAKING) return function () {};
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  var patternLikeCommon = {
    typeAnnotation: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator")))
    }
  };
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon, {
      name: {
        validate: chain(assertValueType("string"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (!isValidIdentifier(val, false)) {
            throw new TypeError("\"" + val + "\" is not a valid identifier name");
          }
        }, {
          type: "string"
        }))
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      }
    }),
    validate: function validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      var match = /\.(\w+)$/.exec(key);
      if (!match) return;
      var parentKey = match[1];
      var nonComp = {
        computed: false
      };

      if (parentKey === "property") {
        if (is("MemberExpression", parent, nonComp)) return;
        if (is("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if (is("Property", parent, nonComp)) return;
        if (is("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if (is("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if (is("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if (is("MetaProperty", parent, {
          meta: node
        })) return;
      }

      if ((isKeyword(node.name) || isReservedWord(node.name, false)) && node.name !== "this") {
        throw new TypeError("\"" + node.name + "\" is not a valid identifier");
      }
    }
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Statement")
      },
      alternate: {
        optional: true,
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: assertNodeType("Identifier")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: assertValueType("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: assertValueType("string")
      },
      flags: {
        validate: chain(assertValueType("string"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          var invalid = /[^gimsuy]/.exec(val);

          if (invalid) {
            throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
          }
        }, {
          type: "string"
        })),
        "default": ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, LOGICAL_OPERATORS)
      },
      left: {
        validate: assertNodeType("Expression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier", "PrivateName");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        "default": false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: assertValueType("string")
      },
      sourceType: {
        validate: assertOneOf("script", "module"),
        "default": "script"
      },
      interpreter: {
        validate: assertNodeType("InterpreterDirective"),
        "default": null,
        optional: true
      },
      directives: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      kind: Object.assign({
        validate: assertOneOf("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        "default": "method"
      } : {}),
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand"].concat(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []),
    fields: {
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      value: {
        validate: assertNodeType("Expression", "PatternLike")
      },
      shorthand: {
        validate: chain(assertValueType("boolean"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, {
          type: "boolean"
        }), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !is("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        "default": false
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function () {
      var pattern = assertNodeType("Identifier", "Pattern");
      var expression = assertNodeType("Expression");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        var validator = is("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "Pattern", "MemberExpression")
      }
    }),
    validate: function validate(parent, key) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      var match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      var listKey = match[1],
          index = match[2];

      if (parent[listKey].length > index + 1) {
        throw new TypeError("RestElement must be last element of " + listKey);
      }
    }
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      consequent: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: assertNodeType("Expression")
      },
      cases: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
      }
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: chain(assertNodeType("BlockStatement"), Object.assign(function (node) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: assertNodeType("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": true
      },
      argument: {
        validate: assertNodeType("Expression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      kind: {
        validate: assertOneOf("var", "let", "const")
      },
      declarations: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
      }
    },
    validate: function validate(parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!is("ForXStatement", parent, {
        left: node
      })) return;

      if (node.declarations.length !== 1) {
        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
      }
    }
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("LVal");
          }

          var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
          var without = assertNodeType("Identifier");
          return function (node, key, val) {
            var validator = node.init ? normal : without;
            validator(node, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: assertValueType("boolean")
      },
      init: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      left: {
        validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      expression: {
        validate: assertValueType("boolean")
      },
      body: {
        validate: assertNodeType("BlockStatement", "Expression")
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
      }
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      "implements": {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      mixins: {
        validate: assertNodeType("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      "implements": {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      mixins: {
        validate: assertNodeType("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      "abstract": {
        validate: assertValueType("boolean"),
        optional: true
      }
    },
    validate: function () {
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!is("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: assertNodeType("StringLiteral")
      },
      exportKind: validateOptional(assertOneOf("type", "value")),
      assertions: {
        optional: true,
        validate: chain(assertValueType("array"), assertNodeType("ImportAttribute"))
      }
    }
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: assertNodeType("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
      }
    }
  });
  defineType("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: chain(assertNodeType("Declaration"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      assertions: {
        optional: true,
        validate: chain(assertValueType("array"), assertNodeType("ImportAttribute"))
      },
      specifiers: {
        "default": [],
        validate: chain(assertValueType("array"), assertEach(function () {
          var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          var sourceless = assertNodeType("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
          return function (node, key, val) {
            var validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          };
        }()))
      },
      source: {
        validate: assertNodeType("StringLiteral"),
        optional: true
      },
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      exported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("VariableDeclaration", "LVal");
          }

          var declaration = assertNodeType("VariableDeclaration");
          var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function (node, key, val) {
            if (is("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      },
      "await": {
        "default": false
      }
    }
  });
  defineType("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: chain(assertValueType("array"), assertNodeType("ImportAttribute"))
      },
      specifiers: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: assertNodeType("StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      imported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: chain(assertNodeType("Identifier"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;
          var property;

          switch (val.name) {
            case "function":
              property = "sent";
              break;

            case "new":
              property = "target";
              break;

            case "import":
              property = "meta";
              break;
          }

          if (!is("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = {
    "abstract": {
      validate: assertValueType("boolean"),
      optional: true
    },
    accessibility: {
      validate: assertOneOf("public", "private", "protected"),
      optional: true
    },
    "static": {
      "default": false
    },
    computed: {
      "default": false
    },
    optional: {
      validate: assertValueType("boolean"),
      optional: true
    },
    key: {
      validate: chain(function () {
        var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
        var computed = assertNodeType("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
  };
  var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
    kind: {
      validate: assertOneOf("get", "set", "method", "constructor"),
      "default": "method"
    },
    access: {
      validate: chain(assertValueType("string"), assertOneOf("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
      optional: true
    }
  });
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
      }
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: assertNodeType("Expression")
      },
      quasi: {
        validate: assertNodeType("TemplateLiteral")
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: assertShape({
          raw: {
            validate: assertValueType("string")
          },
          cooked: {
            validate: assertValueType("string"),
            optional: true
          }
        })
      },
      tail: {
        "default": false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
      },
      expressions: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: chain(assertValueType("boolean"), Object.assign(function (node, key, val) {
          if (!process.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })),
        "default": false
      },
      argument: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier"];
          return validator;
        }()
      },
      computed: {
        "default": false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      },
      arguments: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain(assertValueType("boolean"), assertOptionalChainStart())
      },
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });

  var defineInterfaceishType = function defineInterfaceishType(name, typeParameterType) {
    if (typeParameterType === void 0) {
      typeParameterType = "TypeParameterDeclaration";
    }

    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType(typeParameterType),
        "extends": validateOptional(arrayOfType("InterfaceExtends")),
        mixins: validateOptional(arrayOfType("InterfaceExtends")),
        "implements": validateOptional(arrayOfType("ClassImplements")),
        body: validateType("ObjectTypeAnnotation")
      }
    });
  };

  defineType("AnyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      elementType: validateType("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      predicate: validateOptionalType("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType("BlockStatement"),
      kind: validateOptional(assertOneOf("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: validateOptionalType("Flow"),
      specifiers: validateOptional(arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: validateOptionalType("StringLiteral"),
      "default": validateOptional(assertValueType("boolean"))
    }
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: validateType("StringLiteral"),
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["Flow", "FlowPredicate"],
    fields: {
      value: validateType("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["Flow", "FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      params: validate$1(arrayOfType("FunctionTypeParam")),
      rest: validateOptionalType("FunctionTypeParam"),
      returnType: validateType("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    aliases: ["Flow"],
    fields: {
      name: validateOptionalType("Identifier"),
      typeAnnotation: validateType("FlowType"),
      optional: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow", "FlowType"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["Flow", "FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["Flow", "FlowType"],
    fields: {
      "extends": validateOptional(arrayOfType("InterfaceExtends")),
      body: validateType("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["Flow", "FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: validate$1(arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
      callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
      internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
      exact: {
        validate: assertValueType("boolean"),
        "default": false
      },
      inexact: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateType("Identifier"),
      value: validateType("FlowType"),
      optional: validate$1(assertValueType("boolean")),
      "static": validate$1(assertValueType("boolean")),
      method: validate$1(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      value: validateType("FlowType"),
      "static": validate$1(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateOptionalType("Identifier"),
      key: validateType("FlowType"),
      value: validateType("FlowType"),
      "static": validate$1(assertValueType("boolean")),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      key: validateType(["Identifier", "StringLiteral"]),
      value: validateType("FlowType"),
      kind: validate$1(assertOneOf("init", "get", "set")),
      "static": validate$1(assertValueType("boolean")),
      proto: validate$1(assertValueType("boolean")),
      optional: validate$1(assertValueType("boolean")),
      variance: validateOptionalType("Variance"),
      method: validate$1(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType"),
      impltype: validateType("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      qualification: validateType(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$1(assertValueType("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["Flow", "FlowType"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    aliases: ["Flow"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["Flow", "ExpressionWrapper", "Expression"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    aliases: ["Flow"],
    visitor: ["bound", "default", "variance"],
    fields: {
      name: validate$1(assertValueType("string")),
      bound: validateOptionalType("TypeAnnotation"),
      "default": validateOptionalType("FlowType"),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$1(arrayOfType("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$1(arrayOfType("FlowType"))
    }
  });
  defineType("Variance", {
    aliases: ["Flow"],
    builder: ["kind"],
    fields: {
      kind: validate$1(assertOneOf("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: validateType("Identifier"),
      body: validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$1(assertValueType("boolean")),
      members: validateArrayOfType("EnumBooleanMember")
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$1(assertValueType("boolean")),
      members: validateArrayOfType("EnumNumberMember")
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$1(assertValueType("boolean")),
      members: validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"])
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("EnumDefaultedMember")
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });

  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingElement: {
        validate: assertNodeType("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: assertNodeType("JSXClosingElement")
      },
      children: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      },
      selfClosing: {
        validate: assertValueType("boolean"),
        optional: true
      }
    }
  });
  defineType("JSXEmptyExpression", {
    aliases: ["JSX"]
  });
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    aliases: ["JSX"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    aliases: ["JSX"],
    fields: {
      object: {
        validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    aliases: ["JSX"],
    fields: {
      namespace: {
        validate: assertNodeType("JSXIdentifier")
      },
      name: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        "default": false
      },
      attributes: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    aliases: ["JSX"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["JSX", "Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: assertNodeType("JSXOpeningFragment")
      },
      closingFragment: {
        validate: assertNodeType("JSXClosingFragment")
      },
      children: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["JSX", "Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["JSX", "Immutable"]
  });

  var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };

  for (var _i = 0, _PLACEHOLDERS = PLACEHOLDERS; _i < _PLACEHOLDERS.length; _i++) {
    var type = _PLACEHOLDERS[_i];
    var alias = ALIAS_KEYS[type];
    if (alias == null ? void 0 : alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }

  var PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
    PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }

      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });

  defineType("Noop", {
    visitor: []
  });
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: assertNodeType("Identifier")
      },
      expectedNode: {
        validate: assertOneOf.apply(void 0, PLACEHOLDERS)
      }
    }
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });

  defineType("ArgumentPlaceholder", {});
  defineType("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: assertNodeType("Expression")
      },
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon, {
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      }
    })
  });
  defineType("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: assertNodeType("PrivateName")
      },
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
      key: {
        validate: assertNodeType("PrivateName")
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      value: {
        validate: assertNodeType("StringLiteral")
      }
    }
  });
  defineType("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("DoExpression", {
    visitor: ["body"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("TupleExpression", {
    fields: {
      elements: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement"))),
        "default": []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });

  var bool = assertValueType("boolean");
  var tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      parameter: {
        validate: assertNodeType("Identifier", "AssignmentPattern")
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: validateType("TSEntityName"),
      right: validateType("Identifier")
    }
  });
  var signatureDeclarationCommon = {
    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
    parameters: validateArrayOfType(["Identifier", "RestElement"]),
    typeAnnotation: validateOptionalType("TSTypeAnnotation")
  };
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = {
    key: validateType("Expression"),
    computed: validate$1(bool),
    optional: validateOptional(bool)
  };
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      initializer: validateOptionalType("Expression")
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: validateOptional(bool),
      parameters: validateArrayOfType("Identifier"),
      typeAnnotation: validateOptionalType("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

  for (var _i$1 = 0, _tsKeywordTypes = tsKeywordTypes; _i$1 < _tsKeywordTypes.length; _i$1++) {
    var type$1 = _tsKeywordTypes[_i$1];
    defineType(type$1, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }

  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtr = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  defineType("TSFunctionType", fnOrCtr);
  defineType("TSConstructorType", fnOrCtr);
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: validateType(["Identifier", "TSThisType"]),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      asserts: validateOptional(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName"],
    fields: {
      exprName: validateType(["TSEntityName", "TSImportType"])
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: validateType("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: validateArrayOfType(["TSType", "TSNamedTupleMember"])
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: validateType("Identifier"),
      optional: {
        validate: bool,
        "default": false
      },
      elementType: validateType("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: validateArrayOfType("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: validateType("TSType"),
      extendsType: validateType("TSType"),
      trueType: validateType("TSType"),
      falseType: validateType("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: validateType("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: validate$1(assertValueType("string")),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: validateType("TSType"),
      indexType: validateType("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: validateOptional(bool),
      typeParameter: validateType("TSTypeParameter"),
      optional: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSType"),
      nameType: validateOptionalType("TSType")
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: validateType(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
    }
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
      body: validateType("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSAsExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeAssertion", {
    aliases: ["Expression"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: validateType("TSType"),
      expression: validateType("Expression")
    }
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: validateOptional(bool),
      "const": validateOptional(bool),
      id: validateType("Identifier"),
      members: validateArrayOfType("TSEnumMember"),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: validateOptional(bool),
      global: validateOptional(bool),
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: validateType("StringLiteral"),
      qualifier: validateOptionalType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: validate$1(bool),
      id: validateType("Identifier"),
      moduleReference: validateType(["TSEntityName", "TSExternalModuleReference"])
    }
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: validateType("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: assertNodeType("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSType")))
      }
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
      }
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: assertValueType("string")
      },
      constraint: {
        validate: assertNodeType("TSType"),
        optional: true
      },
      "default": {
        validate: assertNodeType("TSType"),
        optional: true
      }
    }
  });

  toFastProperties(VISITOR_KEYS);
  toFastProperties(ALIAS_KEYS);
  toFastProperties(FLIPPED_ALIAS_KEYS);
  toFastProperties(NODE_FIELDS);
  toFastProperties(BUILDER_KEYS);
  toFastProperties(DEPRECATED_KEYS);
  toFastProperties(PLACEHOLDERS_ALIAS);
  toFastProperties(PLACEHOLDERS_FLIPPED_ALIAS);
  var TYPES = Object.keys(VISITOR_KEYS).concat(Object.keys(FLIPPED_ALIAS_KEYS)).concat(Object.keys(DEPRECATED_KEYS));

  function builder(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var keys = BUILDER_KEYS[type];
    var countArgs = args.length;

    if (countArgs > keys.length) {
      throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
    }

    var node = {
      type: type
    };
    var i = 0;
    keys.forEach(function (key) {
      var field = NODE_FIELDS[type][key];
      var arg;
      if (i < countArgs) arg = args[i];
      if (arg === undefined) arg = clone_1(field["default"]);
      node[key] = arg;
      i++;
    });

    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      validate(node, key, node[key]);
    }

    return node;
  }

  function arrayExpression(elements) {
    return builder.apply(void 0, ["ArrayExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function assignmentExpression(operator, left, right) {
    return builder.apply(void 0, ["AssignmentExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function binaryExpression(operator, left, right) {
    return builder.apply(void 0, ["BinaryExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function interpreterDirective(value) {
    return builder.apply(void 0, ["InterpreterDirective"].concat(Array.prototype.slice.call(arguments)));
  }
  function directive(value) {
    return builder.apply(void 0, ["Directive"].concat(Array.prototype.slice.call(arguments)));
  }
  function directiveLiteral(value) {
    return builder.apply(void 0, ["DirectiveLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function blockStatement(body, directives) {
    return builder.apply(void 0, ["BlockStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function breakStatement(label) {
    return builder.apply(void 0, ["BreakStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function callExpression(callee, _arguments) {
    return builder.apply(void 0, ["CallExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function catchClause(param, body) {
    return builder.apply(void 0, ["CatchClause"].concat(Array.prototype.slice.call(arguments)));
  }
  function conditionalExpression(test, consequent, alternate) {
    return builder.apply(void 0, ["ConditionalExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function continueStatement(label) {
    return builder.apply(void 0, ["ContinueStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function debuggerStatement() {
    return builder.apply(void 0, ["DebuggerStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function doWhileStatement(test, body) {
    return builder.apply(void 0, ["DoWhileStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function emptyStatement() {
    return builder.apply(void 0, ["EmptyStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function expressionStatement(expression) {
    return builder.apply(void 0, ["ExpressionStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function file(program, comments, tokens) {
    return builder.apply(void 0, ["File"].concat(Array.prototype.slice.call(arguments)));
  }
  function forInStatement(left, right, body) {
    return builder.apply(void 0, ["ForInStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function forStatement(init, test, update, body) {
    return builder.apply(void 0, ["ForStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionDeclaration(id, params, body, generator, async) {
    return builder.apply(void 0, ["FunctionDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionExpression(id, params, body, generator, async) {
    return builder.apply(void 0, ["FunctionExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function identifier(name) {
    return builder.apply(void 0, ["Identifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function ifStatement(test, consequent, alternate) {
    return builder.apply(void 0, ["IfStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function labeledStatement(label, body) {
    return builder.apply(void 0, ["LabeledStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringLiteral(value) {
    return builder.apply(void 0, ["StringLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function numericLiteral(value) {
    return builder.apply(void 0, ["NumericLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullLiteral() {
    return builder.apply(void 0, ["NullLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanLiteral(value) {
    return builder.apply(void 0, ["BooleanLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function regExpLiteral(pattern, flags) {
    return builder.apply(void 0, ["RegExpLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function logicalExpression(operator, left, right) {
    return builder.apply(void 0, ["LogicalExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function memberExpression(object, property, computed, optional) {
    return builder.apply(void 0, ["MemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function newExpression(callee, _arguments) {
    return builder.apply(void 0, ["NewExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function program(body, directives, sourceType, interpreter) {
    return builder.apply(void 0, ["Program"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectExpression(properties) {
    return builder.apply(void 0, ["ObjectExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectMethod(kind, key, params, body, computed, generator, async) {
    return builder.apply(void 0, ["ObjectMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectProperty(key, value, computed, shorthand, decorators) {
    return builder.apply(void 0, ["ObjectProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function restElement(argument) {
    return builder.apply(void 0, ["RestElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function returnStatement(argument) {
    return builder.apply(void 0, ["ReturnStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function sequenceExpression(expressions) {
    return builder.apply(void 0, ["SequenceExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function parenthesizedExpression(expression) {
    return builder.apply(void 0, ["ParenthesizedExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function switchCase(test, consequent) {
    return builder.apply(void 0, ["SwitchCase"].concat(Array.prototype.slice.call(arguments)));
  }
  function switchStatement(discriminant, cases) {
    return builder.apply(void 0, ["SwitchStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function thisExpression() {
    return builder.apply(void 0, ["ThisExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function throwStatement(argument) {
    return builder.apply(void 0, ["ThrowStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function tryStatement(block, handler, finalizer) {
    return builder.apply(void 0, ["TryStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function unaryExpression(operator, argument, prefix) {
    return builder.apply(void 0, ["UnaryExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function updateExpression(operator, argument, prefix) {
    return builder.apply(void 0, ["UpdateExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function variableDeclaration(kind, declarations) {
    return builder.apply(void 0, ["VariableDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function variableDeclarator(id, init) {
    return builder.apply(void 0, ["VariableDeclarator"].concat(Array.prototype.slice.call(arguments)));
  }
  function whileStatement(test, body) {
    return builder.apply(void 0, ["WhileStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function withStatement(object, body) {
    return builder.apply(void 0, ["WithStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function assignmentPattern(left, right) {
    return builder.apply(void 0, ["AssignmentPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrayPattern(elements) {
    return builder.apply(void 0, ["ArrayPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrowFunctionExpression(params, body, async) {
    return builder.apply(void 0, ["ArrowFunctionExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classBody(body) {
    return builder.apply(void 0, ["ClassBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function classExpression(id, superClass, body, decorators) {
    return builder.apply(void 0, ["ClassExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classDeclaration(id, superClass, body, decorators) {
    return builder.apply(void 0, ["ClassDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportAllDeclaration(source) {
    return builder.apply(void 0, ["ExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportDefaultDeclaration(declaration) {
    return builder.apply(void 0, ["ExportDefaultDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportNamedDeclaration(declaration, specifiers, source) {
    return builder.apply(void 0, ["ExportNamedDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportSpecifier(local, exported) {
    return builder.apply(void 0, ["ExportSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function forOfStatement(left, right, body, _await) {
    return builder.apply(void 0, ["ForOfStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function importDeclaration(specifiers, source) {
    return builder.apply(void 0, ["ImportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function importDefaultSpecifier(local) {
    return builder.apply(void 0, ["ImportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function importNamespaceSpecifier(local) {
    return builder.apply(void 0, ["ImportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function importSpecifier(local, imported) {
    return builder.apply(void 0, ["ImportSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function metaProperty(meta, property) {
    return builder.apply(void 0, ["MetaProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return builder.apply(void 0, ["ClassMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectPattern(properties) {
    return builder.apply(void 0, ["ObjectPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function spreadElement(argument) {
    return builder.apply(void 0, ["SpreadElement"].concat(Array.prototype.slice.call(arguments)));
  }

  function _super() {
    return builder.apply(void 0, ["Super"].concat(Array.prototype.slice.call(arguments)));
  }
  function taggedTemplateExpression(tag, quasi) {
    return builder.apply(void 0, ["TaggedTemplateExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function templateElement(value, tail) {
    return builder.apply(void 0, ["TemplateElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function templateLiteral(quasis, expressions) {
    return builder.apply(void 0, ["TemplateLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function yieldExpression(argument, delegate) {
    return builder.apply(void 0, ["YieldExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function awaitExpression(argument) {
    return builder.apply(void 0, ["AwaitExpression"].concat(Array.prototype.slice.call(arguments)));
  }

  function _import() {
    return builder.apply(void 0, ["Import"].concat(Array.prototype.slice.call(arguments)));
  }
  function bigIntLiteral(value) {
    return builder.apply(void 0, ["BigIntLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportNamespaceSpecifier(exported) {
    return builder.apply(void 0, ["ExportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function optionalMemberExpression(object, property, computed, optional) {
    return builder.apply(void 0, ["OptionalMemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function optionalCallExpression(callee, _arguments, optional) {
    return builder.apply(void 0, ["OptionalCallExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function anyTypeAnnotation() {
    return builder.apply(void 0, ["AnyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrayTypeAnnotation(elementType) {
    return builder.apply(void 0, ["ArrayTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanTypeAnnotation() {
    return builder.apply(void 0, ["BooleanTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullLiteralTypeAnnotation() {
    return builder.apply(void 0, ["NullLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function classImplements(id, typeParameters) {
    return builder.apply(void 0, ["ClassImplements"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareClass(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["DeclareClass"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareFunction(id) {
    return builder.apply(void 0, ["DeclareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareInterface(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["DeclareInterface"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareModule(id, body, kind) {
    return builder.apply(void 0, ["DeclareModule"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareModuleExports(typeAnnotation) {
    return builder.apply(void 0, ["DeclareModuleExports"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareTypeAlias(id, typeParameters, right) {
    return builder.apply(void 0, ["DeclareTypeAlias"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareOpaqueType(id, typeParameters, supertype) {
    return builder.apply(void 0, ["DeclareOpaqueType"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareVariable(id) {
    return builder.apply(void 0, ["DeclareVariable"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareExportDeclaration(declaration, specifiers, source) {
    return builder.apply(void 0, ["DeclareExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareExportAllDeclaration(source) {
    return builder.apply(void 0, ["DeclareExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function declaredPredicate(value) {
    return builder.apply(void 0, ["DeclaredPredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function existsTypeAnnotation() {
    return builder.apply(void 0, ["ExistsTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return builder.apply(void 0, ["FunctionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionTypeParam(name, typeAnnotation) {
    return builder.apply(void 0, ["FunctionTypeParam"].concat(Array.prototype.slice.call(arguments)));
  }
  function genericTypeAnnotation(id, typeParameters) {
    return builder.apply(void 0, ["GenericTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function inferredPredicate() {
    return builder.apply(void 0, ["InferredPredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceExtends(id, typeParameters) {
    return builder.apply(void 0, ["InterfaceExtends"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceDeclaration(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["InterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceTypeAnnotation(_extends, body) {
    return builder.apply(void 0, ["InterfaceTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function intersectionTypeAnnotation(types) {
    return builder.apply(void 0, ["IntersectionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function mixedTypeAnnotation() {
    return builder.apply(void 0, ["MixedTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function emptyTypeAnnotation() {
    return builder.apply(void 0, ["EmptyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullableTypeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["NullableTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function numberLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function numberTypeAnnotation() {
    return builder.apply(void 0, ["NumberTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return builder.apply(void 0, ["ObjectTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    return builder.apply(void 0, ["ObjectTypeInternalSlot"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeCallProperty(value) {
    return builder.apply(void 0, ["ObjectTypeCallProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeIndexer(id, key, value, variance) {
    return builder.apply(void 0, ["ObjectTypeIndexer"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeProperty(key, value, variance) {
    return builder.apply(void 0, ["ObjectTypeProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeSpreadProperty(argument) {
    return builder.apply(void 0, ["ObjectTypeSpreadProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function opaqueType(id, typeParameters, supertype, impltype) {
    return builder.apply(void 0, ["OpaqueType"].concat(Array.prototype.slice.call(arguments)));
  }
  function qualifiedTypeIdentifier(id, qualification) {
    return builder.apply(void 0, ["QualifiedTypeIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["StringLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringTypeAnnotation() {
    return builder.apply(void 0, ["StringTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function symbolTypeAnnotation() {
    return builder.apply(void 0, ["SymbolTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function thisTypeAnnotation() {
    return builder.apply(void 0, ["ThisTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tupleTypeAnnotation(types) {
    return builder.apply(void 0, ["TupleTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeofTypeAnnotation(argument) {
    return builder.apply(void 0, ["TypeofTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeAlias(id, typeParameters, right) {
    return builder.apply(void 0, ["TypeAlias"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["TypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeCastExpression(expression, typeAnnotation) {
    return builder.apply(void 0, ["TypeCastExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameter(bound, _default, variance) {
    return builder.apply(void 0, ["TypeParameter"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameterDeclaration(params) {
    return builder.apply(void 0, ["TypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameterInstantiation(params) {
    return builder.apply(void 0, ["TypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
  }
  function unionTypeAnnotation(types) {
    return builder.apply(void 0, ["UnionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function variance(kind) {
    return builder.apply(void 0, ["Variance"].concat(Array.prototype.slice.call(arguments)));
  }
  function voidTypeAnnotation() {
    return builder.apply(void 0, ["VoidTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumDeclaration(id, body) {
    return builder.apply(void 0, ["EnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumBooleanBody(members) {
    return builder.apply(void 0, ["EnumBooleanBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumNumberBody(members) {
    return builder.apply(void 0, ["EnumNumberBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumStringBody(members) {
    return builder.apply(void 0, ["EnumStringBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumSymbolBody(members) {
    return builder.apply(void 0, ["EnumSymbolBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumBooleanMember(id) {
    return builder.apply(void 0, ["EnumBooleanMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumNumberMember(id, init) {
    return builder.apply(void 0, ["EnumNumberMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumStringMember(id, init) {
    return builder.apply(void 0, ["EnumStringMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumDefaultedMember(id) {
    return builder.apply(void 0, ["EnumDefaultedMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxAttribute(name, value) {
    return builder.apply(void 0, ["JSXAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxClosingElement(name) {
    return builder.apply(void 0, ["JSXClosingElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxElement(openingElement, closingElement, children, selfClosing) {
    return builder.apply(void 0, ["JSXElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxEmptyExpression() {
    return builder.apply(void 0, ["JSXEmptyExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxExpressionContainer(expression) {
    return builder.apply(void 0, ["JSXExpressionContainer"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxSpreadChild(expression) {
    return builder.apply(void 0, ["JSXSpreadChild"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxIdentifier(name) {
    return builder.apply(void 0, ["JSXIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxMemberExpression(object, property) {
    return builder.apply(void 0, ["JSXMemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxNamespacedName(namespace, name) {
    return builder.apply(void 0, ["JSXNamespacedName"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxOpeningElement(name, attributes, selfClosing) {
    return builder.apply(void 0, ["JSXOpeningElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxSpreadAttribute(argument) {
    return builder.apply(void 0, ["JSXSpreadAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxText(value) {
    return builder.apply(void 0, ["JSXText"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    return builder.apply(void 0, ["JSXFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxOpeningFragment() {
    return builder.apply(void 0, ["JSXOpeningFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxClosingFragment() {
    return builder.apply(void 0, ["JSXClosingFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function noop() {
    return builder.apply(void 0, ["Noop"].concat(Array.prototype.slice.call(arguments)));
  }
  function placeholder(expectedNode, name) {
    return builder.apply(void 0, ["Placeholder"].concat(Array.prototype.slice.call(arguments)));
  }
  function v8IntrinsicIdentifier(name) {
    return builder.apply(void 0, ["V8IntrinsicIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function argumentPlaceholder() {
    return builder.apply(void 0, ["ArgumentPlaceholder"].concat(Array.prototype.slice.call(arguments)));
  }
  function bindExpression(object, callee) {
    return builder.apply(void 0, ["BindExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return builder.apply(void 0, ["ClassProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelineTopicExpression(expression) {
    return builder.apply(void 0, ["PipelineTopicExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelineBareFunction(callee) {
    return builder.apply(void 0, ["PipelineBareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelinePrimaryTopicReference() {
    return builder.apply(void 0, ["PipelinePrimaryTopicReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function classPrivateProperty(key, value, decorators, _static) {
    return builder.apply(void 0, ["ClassPrivateProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function classPrivateMethod(kind, key, params, body, _static) {
    return builder.apply(void 0, ["ClassPrivateMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function importAttribute(key, value) {
    return builder.apply(void 0, ["ImportAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function decorator(expression) {
    return builder.apply(void 0, ["Decorator"].concat(Array.prototype.slice.call(arguments)));
  }
  function doExpression(body) {
    return builder.apply(void 0, ["DoExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportDefaultSpecifier(exported) {
    return builder.apply(void 0, ["ExportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function privateName(id) {
    return builder.apply(void 0, ["PrivateName"].concat(Array.prototype.slice.call(arguments)));
  }
  function recordExpression(properties) {
    return builder.apply(void 0, ["RecordExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tupleExpression(elements) {
    return builder.apply(void 0, ["TupleExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function decimalLiteral(value) {
    return builder.apply(void 0, ["DecimalLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function staticBlock(body) {
    return builder.apply(void 0, ["StaticBlock"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsParameterProperty(parameter) {
    return builder.apply(void 0, ["TSParameterProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsDeclareFunction(id, typeParameters, params, returnType) {
    return builder.apply(void 0, ["TSDeclareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return builder.apply(void 0, ["TSDeclareMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsQualifiedName(left, right) {
    return builder.apply(void 0, ["TSQualifiedName"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSCallSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSConstructSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsPropertySignature(key, typeAnnotation, initializer) {
    return builder.apply(void 0, ["TSPropertySignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSMethodSignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIndexSignature(parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSIndexSignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsAnyKeyword() {
    return builder.apply(void 0, ["TSAnyKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsBooleanKeyword() {
    return builder.apply(void 0, ["TSBooleanKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsBigIntKeyword() {
    return builder.apply(void 0, ["TSBigIntKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIntrinsicKeyword() {
    return builder.apply(void 0, ["TSIntrinsicKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNeverKeyword() {
    return builder.apply(void 0, ["TSNeverKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNullKeyword() {
    return builder.apply(void 0, ["TSNullKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNumberKeyword() {
    return builder.apply(void 0, ["TSNumberKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsObjectKeyword() {
    return builder.apply(void 0, ["TSObjectKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsStringKeyword() {
    return builder.apply(void 0, ["TSStringKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsSymbolKeyword() {
    return builder.apply(void 0, ["TSSymbolKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUndefinedKeyword() {
    return builder.apply(void 0, ["TSUndefinedKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUnknownKeyword() {
    return builder.apply(void 0, ["TSUnknownKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsVoidKeyword() {
    return builder.apply(void 0, ["TSVoidKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsThisType() {
    return builder.apply(void 0, ["TSThisType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSFunctionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSConstructorType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeReference(typeName, typeParameters) {
    return builder.apply(void 0, ["TSTypeReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return builder.apply(void 0, ["TSTypePredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeQuery(exprName) {
    return builder.apply(void 0, ["TSTypeQuery"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeLiteral(members) {
    return builder.apply(void 0, ["TSTypeLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsArrayType(elementType) {
    return builder.apply(void 0, ["TSArrayType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTupleType(elementTypes) {
    return builder.apply(void 0, ["TSTupleType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsOptionalType(typeAnnotation) {
    return builder.apply(void 0, ["TSOptionalType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsRestType(typeAnnotation) {
    return builder.apply(void 0, ["TSRestType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNamedTupleMember(label, elementType, optional) {
    return builder.apply(void 0, ["TSNamedTupleMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUnionType(types) {
    return builder.apply(void 0, ["TSUnionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIntersectionType(types) {
    return builder.apply(void 0, ["TSIntersectionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return builder.apply(void 0, ["TSConditionalType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInferType(typeParameter) {
    return builder.apply(void 0, ["TSInferType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsParenthesizedType(typeAnnotation) {
    return builder.apply(void 0, ["TSParenthesizedType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeOperator(typeAnnotation) {
    return builder.apply(void 0, ["TSTypeOperator"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIndexedAccessType(objectType, indexType) {
    return builder.apply(void 0, ["TSIndexedAccessType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return builder.apply(void 0, ["TSMappedType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsLiteralType(literal) {
    return builder.apply(void 0, ["TSLiteralType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExpressionWithTypeArguments(expression, typeParameters) {
    return builder.apply(void 0, ["TSExpressionWithTypeArguments"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["TSInterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInterfaceBody(body) {
    return builder.apply(void 0, ["TSInterfaceBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return builder.apply(void 0, ["TSTypeAliasDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsAsExpression(expression, typeAnnotation) {
    return builder.apply(void 0, ["TSAsExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    return builder.apply(void 0, ["TSTypeAssertion"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsEnumDeclaration(id, members) {
    return builder.apply(void 0, ["TSEnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsEnumMember(id, initializer) {
    return builder.apply(void 0, ["TSEnumMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsModuleDeclaration(id, body) {
    return builder.apply(void 0, ["TSModuleDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsModuleBlock(body) {
    return builder.apply(void 0, ["TSModuleBlock"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsImportType(argument, qualifier, typeParameters) {
    return builder.apply(void 0, ["TSImportType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    return builder.apply(void 0, ["TSImportEqualsDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExternalModuleReference(expression) {
    return builder.apply(void 0, ["TSExternalModuleReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNonNullExpression(expression) {
    return builder.apply(void 0, ["TSNonNullExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExportAssignment(expression) {
    return builder.apply(void 0, ["TSExportAssignment"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNamespaceExportDeclaration(id) {
    return builder.apply(void 0, ["TSNamespaceExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["TSTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameterInstantiation(params) {
    return builder.apply(void 0, ["TSTypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameterDeclaration(params) {
    return builder.apply(void 0, ["TSTypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameter(constraint, _default, name) {
    return builder.apply(void 0, ["TSTypeParameter"].concat(Array.prototype.slice.call(arguments)));
  }

  function NumberLiteral() {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return builder.apply(void 0, ["NumberLiteral"].concat(args));
  }

  function RegexLiteral() {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return builder.apply(void 0, ["RegexLiteral"].concat(args));
  }

  function RestProperty() {
    console.trace("The node type RestProperty has been renamed to RestElement");

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return builder.apply(void 0, ["RestProperty"].concat(args));
  }

  function SpreadProperty() {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return builder.apply(void 0, ["SpreadProperty"].concat(args));
  }

  function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    var str = "";

    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        str += trimmedLine;
      }
    }

    if (str) args.push(stringLiteral(str));
  }

  function buildChildren(node) {
    var elements = [];

    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];

      if (isJSXText(child)) {
        cleanJSXElementLiteralChild(child, elements);
        continue;
      }

      if (isJSXExpressionContainer(child)) child = child.expression;
      if (isJSXEmptyExpression(child)) continue;
      elements.push(child);
    }

    return elements;
  }

  function isNode(node) {
    return !!(node && VISITOR_KEYS[node.type]);
  }

  function assertNode(node) {
    if (!isNode(node)) {
      var _node$type;

      var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError("Not a valid node of type \"" + type + "\"");
    }
  }

  function assert(type, node, opts) {
    if (!is(type, node, opts)) {
      throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
    }
  }

  function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
  }
  function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
  }
  function assertExpression(node, opts) {
    assert("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
  }
  function assertFunction(node, opts) {
    assert("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert("Class", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
  }
  function assertFlow(node, opts) {
    assert("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert("JSX", node, opts);
  }
  function assertPrivate(node, opts) {
    assert("Private", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
  }

  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === "string") {
      return stringTypeAnnotation();
    } else if (type === "number") {
      return numberTypeAnnotation();
    } else if (type === "undefined") {
      return voidTypeAnnotation();
    } else if (type === "boolean") {
      return booleanTypeAnnotation();
    } else if (type === "function") {
      return genericTypeAnnotation(identifier("Function"));
    } else if (type === "object") {
      return genericTypeAnnotation(identifier("Object"));
    } else if (type === "symbol") {
      return genericTypeAnnotation(identifier("Symbol"));
    } else {
      throw new Error("Invalid typeof value");
    }
  }

  function getQualifiedName(node) {
    return isIdentifier(node) ? node.name : node.id.name + "." + getQualifiedName(node.qualification);
  }

  function removeTypeDuplicates(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if (isAnyTypeAnnotation(node)) {
        return [node];
      }

      if (isFlowBaseAnnotation(node)) {
        bases[node.type] = node;
        continue;
      }

      if (isUnionTypeAnnotation(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      if (isGenericTypeAnnotation(node)) {
        var name = getQualifiedName(node.id);

        if (generics[name]) {
          var existing = generics[name];

          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }

        continue;
      }

      types.push(node);
    }

    for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      types.push(bases[type]);
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
      var _name = _Object$keys2[_i2];
      types.push(generics[_name]);
    }

    return types;
  }

  function createFlowUnionType(types) {
    var flattened = removeTypeDuplicates(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return unionTypeAnnotation(flattened);
    }
  }

  function removeTypeDuplicates$1(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if (isTSAnyKeyword(node)) {
        return [node];
      }

      if (isTSBaseType(node)) {
        bases[node.type] = node;
        continue;
      }

      if (isTSUnionType(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      types.push(node);
    }

    for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      types.push(bases[type]);
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
      var name = _Object$keys2[_i2];
      types.push(generics[name]);
    }

    return types;
  }

  function createTSUnionType(typeAnnotations) {
    var types = typeAnnotations.map(function (type) {
      return type.typeAnnotation;
    });
    var flattened = removeTypeDuplicates$1(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return tsUnionType(flattened);
    }
  }

  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") {
      return cloneNode(obj, deep, withoutLoc);
    }

    return obj;
  }

  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) {
      return obj.map(function (node) {
        return cloneIfNode(node, deep, withoutLoc);
      });
    }

    return cloneIfNode(obj, deep, withoutLoc);
  }

  function cloneNode(node, deep, withoutLoc) {
    if (deep === void 0) {
      deep = true;
    }

    if (withoutLoc === void 0) {
      withoutLoc = false;
    }

    if (!node) return node;
    var type = node.type;
    var newNode = {
      type: node.type
    };

    if (isIdentifier(node)) {
      newNode.name = node.name;

      if (has(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }

      if (has(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
      }
    } else if (!has(NODE_FIELDS, type)) {
      throw new Error("Unknown node type: \"" + type + "\"");
    } else {
      for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];

        if (has(node, field)) {
          if (deep) {
            newNode[field] = isFile(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }

    if (has(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }

    if (has(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    }

    if (has(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    }

    if (has(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    }

    if (has(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }

    return newNode;
  }

  function cloneCommentsWithoutLoc(comments) {
    return comments.map(function (_ref) {
      var type = _ref.type,
          value = _ref.value;
      return {
        type: type,
        value: value,
        loc: null
      };
    });
  }

  function maybeCloneComments(comments, deep, withoutLoc) {
    return deep && withoutLoc && comments ? cloneCommentsWithoutLoc(comments) : comments;
  }

  function clone$1(node) {
    return cloneNode(node, false);
  }

  function cloneDeep(node) {
    return cloneNode(node);
  }

  function cloneDeepWithoutLoc(node) {
    return cloneNode(node, true, true);
  }

  function cloneWithoutLoc(node) {
    return cloneNode(node, false, true);
  }

  function addComments(node, type, comments) {
    if (!comments || !node) return node;
    var key = type + "Comments";

    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key] = node[key].concat(comments);
      }
    } else {
      node[key] = comments;
    }

    return node;
  }

  function addComment(node, type, content, line) {
    return addComments(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }

  function inheritInnerComments(child, parent) {
    inherit("innerComments", child, parent);
  }

  function inheritLeadingComments(child, parent) {
    inherit("leadingComments", child, parent);
  }

  function inheritTrailingComments(child, parent) {
    inherit("trailingComments", child, parent);
  }

  function inheritsComments(child, parent) {
    inheritTrailingComments(child, parent);
    inheritLeadingComments(child, parent);
    inheritInnerComments(child, parent);
    return child;
  }

  function removeComments(node) {
    COMMENT_KEYS.forEach(function (key) {
      node[key] = null;
    });
    return node;
  }

  var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
  var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
  var MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
  var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
  var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
  var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];
  var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS["TSBaseType"];

  function toBlock(node, parent) {
    if (isBlockStatement(node)) {
      return node;
    }

    var blockNodes = [];

    if (isEmptyStatement(node)) {
      blockNodes = [];
    } else {
      if (!isStatement(node)) {
        if (isFunction(parent)) {
          node = returnStatement(node);
        } else {
          node = expressionStatement(node);
        }
      }

      blockNodes = [node];
    }

    return blockStatement(blockNodes);
  }

  function ensureBlock(node, key) {
    if (key === void 0) {
      key = "body";
    }

    return node[key] = toBlock(node[key], node);
  }

  function toIdentifier(input) {
    input = input + "";
    var name = "";

    for (var _iterator = _createForOfIteratorHelperLoose(input), _step; !(_step = _iterator()).done;) {
      var c = _step.value;
      name += isIdentifierChar(c.codePointAt(0)) ? c : "-";
    }

    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });

    if (!isValidIdentifier(name)) {
      name = "_" + name;
    }

    return name || "_";
  }

  function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }

  function toComputedKey(node, key) {
    if (key === void 0) {
      key = node.key || node.property;
    }

    if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);
    return key;
  }

  function toExpression(node) {
    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    if (isExpression(node)) {
      return node;
    }

    if (isClass(node)) {
      node.type = "ClassExpression";
    } else if (isFunction(node)) {
      node.type = "FunctionExpression";
    }

    if (!isExpression(node)) {
      throw new Error("cannot turn " + node.type + " to an expression");
    }

    return node;
  }

  function traverseFast(node, enter, opts) {
    if (!node) return;
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(subNode), _step2; !(_step2 = _iterator2()).done;) {
          var _node = _step2.value;
          traverseFast(_node, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  }

  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
  function removeProperties(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

    for (var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;
      if (node[_key] != null) node[_key] = undefined;
    }

    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }

    var symbols = Object.getOwnPropertySymbols(node);

    for (var _iterator2 = _createForOfIteratorHelperLoose(symbols), _step2; !(_step2 = _iterator2()).done;) {
      var sym = _step2.value;
      node[sym] = null;
    }
  }

  function removePropertiesDeep(tree, opts) {
    traverseFast(tree, removeProperties, opts);
    return tree;
  }

  function toKeyAlias(node, key) {
    if (key === void 0) {
      key = node.key;
    }

    var alias;

    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if (isIdentifier(key)) {
      alias = key.name;
    } else if (isStringLiteral(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));
    }

    if (node.computed) {
      alias = "[" + alias + "]";
    }

    if (node["static"]) {
      alias = "static:" + alias;
    }

    return alias;
  }
  toKeyAlias.uid = 0;

  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };

  function getBindingIdentifiers(node, duplicates, outerOnly) {
    var search = [].concat(node);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      var keys = getBindingIdentifiers.keys[id.type];

      if (isIdentifier(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];

          _ids.push(id);
        } else {
          ids[id.name] = id;
        }

        continue;
      }

      if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {
        if (isDeclaration(id.declaration)) {
          search.push(id.declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (isFunctionDeclaration(id)) {
          search.push(id.id);
          continue;
        }

        if (isFunctionExpression(id)) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }

    return ids;
  }

  getBindingIdentifiers.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };

  function gatherSequenceExpressions(nodes, scope, declars) {
    var exprs = [];
    var ensureLastUndefined = true;

    for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;

      if (!isEmptyStatement(node)) {
        ensureLastUndefined = false;
      }

      if (isExpression(node)) {
        exprs.push(node);
      } else if (isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (isVariableDeclaration(node)) {
        if (node.kind !== "var") return;

        for (var _iterator2 = _createForOfIteratorHelperLoose(node.declarations), _step2; !(_step2 = _iterator2()).done;) {
          var declar = _step2.value;
          var bindings = getBindingIdentifiers(declar);

          for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            declars.push({
              kind: node.kind,
              id: cloneNode(bindings[key])
            });
          }

          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
      } else if (isIfStatement(node)) {
        var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(conditionalExpression(node.test, consequent, alternate));
      } else if (isBlockStatement(node)) {
        var body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if (isEmptyStatement(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }

    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }

  function toSequenceExpression(nodes, scope) {
    if (!(nodes == null ? void 0 : nodes.length)) return;
    var declars = [];
    var result = gatherSequenceExpressions(nodes, scope, declars);
    if (!result) return;

    for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
      var declar = _declars[_i];
      scope.push(declar);
    }

    return result;
  }

  function toStatement(node, ignore) {
    if (isStatement(node)) {
      return node;
    }

    var mustHaveId = false;
    var newType;

    if (isClass(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if (isFunction(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if (isAssignmentExpression(node)) {
      return expressionStatement(node);
    }

    if (mustHaveId && !node.id) {
      newType = false;
    }

    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn " + node.type + " to a statement");
      }
    }

    node.type = newType;
    return node;
  }

  var objectTag$3 = '[object Object]';
  var funcProto$2 = Function.prototype,
      objectProto$d = Object.prototype;
  var funcToString$2 = funcProto$2.toString;
  var hasOwnProperty$a = objectProto$d.hasOwnProperty;
  var objectCtorString = funcToString$2.call(Object);

  function isPlainObject(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject;

  var regexpTag$3 = '[object RegExp]';

  function baseIsRegExp(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == regexpTag$3;
  }

  var _baseIsRegExp = baseIsRegExp;

  var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;
  var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;
  var isRegExp_1 = isRegExp;

  function valueToNode(value) {
    if (value === undefined) {
      return identifier("undefined");
    }

    if (value === true || value === false) {
      return booleanLiteral(value);
    }

    if (value === null) {
      return nullLiteral();
    }

    if (typeof value === "string") {
      return stringLiteral(value);
    }

    if (typeof value === "number") {
      var result;

      if (Number.isFinite(value)) {
        result = numericLiteral(Math.abs(value));
      } else {
        var numerator;

        if (Number.isNaN(value)) {
          numerator = numericLiteral(0);
        } else {
          numerator = numericLiteral(1);
        }

        result = binaryExpression("/", numerator, numericLiteral(0));
      }

      if (value < 0 || Object.is(value, -0)) {
        result = unaryExpression("-", result);
      }

      return result;
    }

    if (isRegExp_1(value)) {
      var pattern = value.source;
      var flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return regExpLiteral(pattern, flags);
    }

    if (Array.isArray(value)) {
      return arrayExpression(value.map(valueToNode));
    }

    if (isPlainObject_1(value)) {
      var props = [];

      for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var nodeKey = void 0;

        if (isValidIdentifier(key)) {
          nodeKey = identifier(key);
        } else {
          nodeKey = stringLiteral(key);
        }

        props.push(objectProperty(nodeKey, valueToNode(value[key])));
      }

      return objectExpression(props);
    }

    throw new Error("don't know how to turn this value into a node");
  }

  function appendToMemberExpression(member, append, computed) {
    if (computed === void 0) {
      computed = false;
    }

    member.object = memberExpression(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  function inherits(child, parent) {
    if (!child || !parent) return child;

    for (var _iterator = _createForOfIteratorHelperLoose(INHERIT_KEYS.optional), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;

      if (child[_key] == null) {
        child[_key] = parent[_key];
      }
    }

    for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(INHERIT_KEYS.force), _step2; !(_step2 = _iterator2()).done;) {
      var _key2 = _step2.value;
      child[_key2] = parent[_key2];
    }

    inheritsComments(child, parent);
    return child;
  }

  function prependToMemberExpression(member, prepend) {
    member.object = memberExpression(prepend, member.object);
    return member;
  }

  function getOuterBindingIdentifiers(node, duplicates) {
    return getBindingIdentifiers(node, duplicates, true);
  }

  function traverse(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }

    var _ref = handlers,
        enter = _ref.enter,
        exit = _ref.exit;
    traverseSimpleImpl(node, enter, exit, state, []);
  }

  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var i = 0; i < subNode.length; i++) {
          var child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node,
            key: key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node,
          key: key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }

    if (exit) exit(node, ancestors, state);
  }

  function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }

    var keys = getBindingIdentifiers.keys[parent.type];

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];

        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }

    return false;
  }

  function isLet(node) {
    return isVariableDeclaration(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
  }

  function isBlockScoped(node) {
    return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);
  }

  function isImmutable(node) {
    if (isType(node.type, "Immutable")) return true;

    if (isIdentifier(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }

    if (a.type !== b.type) {
      return false;
    }

    var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
    var visitorKeys = VISITOR_KEYS[a.type];

    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var field = _fields[_i];

      if (typeof a[field] !== typeof b[field]) {
        return false;
      }

      if (a[field] == null && b[field] == null) {
        continue;
      } else if (a[field] == null || b[field] == null) {
        return false;
      }

      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }

        if (a[field].length !== b[field].length) {
          return false;
        }

        for (var i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }

        continue;
      }

      if (typeof a[field] === "object" && !(visitorKeys == null ? void 0 : visitorKeys.includes(field))) {
        for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];

          if (a[field][key] !== b[field][key]) {
            return false;
          }
        }

        continue;
      }

      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }

    return true;
  }

  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "JSXMemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }

        return parent.object === node;

      case "VariableDeclarator":
        return parent.init === node;

      case "ArrowFunctionExpression":
        return parent.body === node;

      case "PrivateName":
        return false;

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.params.includes(node)) {
          return false;
        }

      case "ObjectProperty":
      case "ClassProperty":
      case "ClassPrivateProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }

        if (parent.value === node) {
          return !grandparent || grandparent.type !== "ObjectPattern";
        }

        return true;

      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;

      case "AssignmentExpression":
        return parent.right === node;

      case "AssignmentPattern":
        return parent.right === node;

      case "LabeledStatement":
        return false;

      case "CatchClause":
        return false;

      case "RestElement":
        return false;

      case "BreakStatement":
      case "ContinueStatement":
        return false;

      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;

      case "ExportSpecifier":
        if (grandparent == null ? void 0 : grandparent.source) {
          return false;
        }

        return parent.local === node;

      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;

      case "JSXAttribute":
        return false;

      case "ObjectPattern":
      case "ArrayPattern":
        return false;

      case "MetaProperty":
        return false;

      case "ObjectTypeProperty":
        return parent.key !== node;

      case "TSEnumMember":
        return parent.id !== node;

      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }

        return true;
    }

    return true;
  }

  function isScope(node, parent) {
    if (isBlockStatement(node) && (isFunction(parent) || isCatchClause(parent))) {
      return false;
    }

    if (isPattern(node) && (isFunction(parent) || isCatchClause(parent))) {
      return true;
    }

    return isScopable(node);
  }

  function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier(specifier) || isIdentifier(specifier.imported || specifier.exported, {
      name: "default"
    });
  }

  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier(name) {
    return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }

  function isVar(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !node[BLOCK_SCOPED_SYMBOL];
  }

  var react = {
    isReactComponent: isReactComponent,
    isCompatTag: isCompatTag,
    buildChildren: buildChildren
  };

  var t = /*#__PURE__*/Object.freeze({
    __proto__: null,
    react: react,
    assertNode: assertNode,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof,
    createUnionTypeAnnotation: createFlowUnionType,
    createFlowUnionType: createFlowUnionType,
    createTSUnionType: createTSUnionType,
    cloneNode: cloneNode,
    clone: clone$1,
    cloneDeep: cloneDeep,
    cloneDeepWithoutLoc: cloneDeepWithoutLoc,
    cloneWithoutLoc: cloneWithoutLoc,
    addComment: addComment,
    addComments: addComments,
    inheritInnerComments: inheritInnerComments,
    inheritLeadingComments: inheritLeadingComments,
    inheritsComments: inheritsComments,
    inheritTrailingComments: inheritTrailingComments,
    removeComments: removeComments,
    ensureBlock: ensureBlock,
    toBindingIdentifierName: toBindingIdentifierName,
    toBlock: toBlock,
    toComputedKey: toComputedKey,
    toExpression: toExpression,
    toIdentifier: toIdentifier,
    toKeyAlias: toKeyAlias,
    toSequenceExpression: toSequenceExpression,
    toStatement: toStatement,
    valueToNode: valueToNode,
    appendToMemberExpression: appendToMemberExpression,
    inherits: inherits,
    prependToMemberExpression: prependToMemberExpression,
    removeProperties: removeProperties,
    removePropertiesDeep: removePropertiesDeep,
    removeTypeDuplicates: removeTypeDuplicates,
    getBindingIdentifiers: getBindingIdentifiers,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers,
    traverse: traverse,
    traverseFast: traverseFast,
    shallowEqual: shallowEqual,
    is: is,
    isBinding: isBinding,
    isBlockScoped: isBlockScoped,
    isImmutable: isImmutable,
    isLet: isLet,
    isNode: isNode,
    isNodesEquivalent: isNodesEquivalent,
    isPlaceholderType: isPlaceholderType,
    isReferenced: isReferenced,
    isScope: isScope,
    isSpecifierDefault: isSpecifierDefault,
    isType: isType,
    isValidES3Identifier: isValidES3Identifier,
    isValidIdentifier: isValidIdentifier,
    isVar: isVar,
    matchesPattern: matchesPattern,
    validate: validate,
    buildMatchMemberExpression: buildMatchMemberExpression,
    assertArrayExpression: assertArrayExpression,
    assertAssignmentExpression: assertAssignmentExpression,
    assertBinaryExpression: assertBinaryExpression,
    assertInterpreterDirective: assertInterpreterDirective,
    assertDirective: assertDirective,
    assertDirectiveLiteral: assertDirectiveLiteral,
    assertBlockStatement: assertBlockStatement,
    assertBreakStatement: assertBreakStatement,
    assertCallExpression: assertCallExpression,
    assertCatchClause: assertCatchClause,
    assertConditionalExpression: assertConditionalExpression,
    assertContinueStatement: assertContinueStatement,
    assertDebuggerStatement: assertDebuggerStatement,
    assertDoWhileStatement: assertDoWhileStatement,
    assertEmptyStatement: assertEmptyStatement,
    assertExpressionStatement: assertExpressionStatement,
    assertFile: assertFile,
    assertForInStatement: assertForInStatement,
    assertForStatement: assertForStatement,
    assertFunctionDeclaration: assertFunctionDeclaration,
    assertFunctionExpression: assertFunctionExpression,
    assertIdentifier: assertIdentifier,
    assertIfStatement: assertIfStatement,
    assertLabeledStatement: assertLabeledStatement,
    assertStringLiteral: assertStringLiteral,
    assertNumericLiteral: assertNumericLiteral,
    assertNullLiteral: assertNullLiteral,
    assertBooleanLiteral: assertBooleanLiteral,
    assertRegExpLiteral: assertRegExpLiteral,
    assertLogicalExpression: assertLogicalExpression,
    assertMemberExpression: assertMemberExpression,
    assertNewExpression: assertNewExpression,
    assertProgram: assertProgram,
    assertObjectExpression: assertObjectExpression,
    assertObjectMethod: assertObjectMethod,
    assertObjectProperty: assertObjectProperty,
    assertRestElement: assertRestElement,
    assertReturnStatement: assertReturnStatement,
    assertSequenceExpression: assertSequenceExpression,
    assertParenthesizedExpression: assertParenthesizedExpression,
    assertSwitchCase: assertSwitchCase,
    assertSwitchStatement: assertSwitchStatement,
    assertThisExpression: assertThisExpression,
    assertThrowStatement: assertThrowStatement,
    assertTryStatement: assertTryStatement,
    assertUnaryExpression: assertUnaryExpression,
    assertUpdateExpression: assertUpdateExpression,
    assertVariableDeclaration: assertVariableDeclaration,
    assertVariableDeclarator: assertVariableDeclarator,
    assertWhileStatement: assertWhileStatement,
    assertWithStatement: assertWithStatement,
    assertAssignmentPattern: assertAssignmentPattern,
    assertArrayPattern: assertArrayPattern,
    assertArrowFunctionExpression: assertArrowFunctionExpression,
    assertClassBody: assertClassBody,
    assertClassExpression: assertClassExpression,
    assertClassDeclaration: assertClassDeclaration,
    assertExportAllDeclaration: assertExportAllDeclaration,
    assertExportDefaultDeclaration: assertExportDefaultDeclaration,
    assertExportNamedDeclaration: assertExportNamedDeclaration,
    assertExportSpecifier: assertExportSpecifier,
    assertForOfStatement: assertForOfStatement,
    assertImportDeclaration: assertImportDeclaration,
    assertImportDefaultSpecifier: assertImportDefaultSpecifier,
    assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
    assertImportSpecifier: assertImportSpecifier,
    assertMetaProperty: assertMetaProperty,
    assertClassMethod: assertClassMethod,
    assertObjectPattern: assertObjectPattern,
    assertSpreadElement: assertSpreadElement,
    assertSuper: assertSuper,
    assertTaggedTemplateExpression: assertTaggedTemplateExpression,
    assertTemplateElement: assertTemplateElement,
    assertTemplateLiteral: assertTemplateLiteral,
    assertYieldExpression: assertYieldExpression,
    assertAwaitExpression: assertAwaitExpression,
    assertImport: assertImport,
    assertBigIntLiteral: assertBigIntLiteral,
    assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
    assertOptionalMemberExpression: assertOptionalMemberExpression,
    assertOptionalCallExpression: assertOptionalCallExpression,
    assertAnyTypeAnnotation: assertAnyTypeAnnotation,
    assertArrayTypeAnnotation: assertArrayTypeAnnotation,
    assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
    assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
    assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
    assertClassImplements: assertClassImplements,
    assertDeclareClass: assertDeclareClass,
    assertDeclareFunction: assertDeclareFunction,
    assertDeclareInterface: assertDeclareInterface,
    assertDeclareModule: assertDeclareModule,
    assertDeclareModuleExports: assertDeclareModuleExports,
    assertDeclareTypeAlias: assertDeclareTypeAlias,
    assertDeclareOpaqueType: assertDeclareOpaqueType,
    assertDeclareVariable: assertDeclareVariable,
    assertDeclareExportDeclaration: assertDeclareExportDeclaration,
    assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
    assertDeclaredPredicate: assertDeclaredPredicate,
    assertExistsTypeAnnotation: assertExistsTypeAnnotation,
    assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
    assertFunctionTypeParam: assertFunctionTypeParam,
    assertGenericTypeAnnotation: assertGenericTypeAnnotation,
    assertInferredPredicate: assertInferredPredicate,
    assertInterfaceExtends: assertInterfaceExtends,
    assertInterfaceDeclaration: assertInterfaceDeclaration,
    assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
    assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
    assertMixedTypeAnnotation: assertMixedTypeAnnotation,
    assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
    assertNullableTypeAnnotation: assertNullableTypeAnnotation,
    assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: assertNumberTypeAnnotation,
    assertObjectTypeAnnotation: assertObjectTypeAnnotation,
    assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
    assertObjectTypeCallProperty: assertObjectTypeCallProperty,
    assertObjectTypeIndexer: assertObjectTypeIndexer,
    assertObjectTypeProperty: assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
    assertOpaqueType: assertOpaqueType,
    assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
    assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: assertStringTypeAnnotation,
    assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
    assertThisTypeAnnotation: assertThisTypeAnnotation,
    assertTupleTypeAnnotation: assertTupleTypeAnnotation,
    assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
    assertTypeAlias: assertTypeAlias,
    assertTypeAnnotation: assertTypeAnnotation,
    assertTypeCastExpression: assertTypeCastExpression,
    assertTypeParameter: assertTypeParameter,
    assertTypeParameterDeclaration: assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: assertTypeParameterInstantiation,
    assertUnionTypeAnnotation: assertUnionTypeAnnotation,
    assertVariance: assertVariance,
    assertVoidTypeAnnotation: assertVoidTypeAnnotation,
    assertEnumDeclaration: assertEnumDeclaration,
    assertEnumBooleanBody: assertEnumBooleanBody,
    assertEnumNumberBody: assertEnumNumberBody,
    assertEnumStringBody: assertEnumStringBody,
    assertEnumSymbolBody: assertEnumSymbolBody,
    assertEnumBooleanMember: assertEnumBooleanMember,
    assertEnumNumberMember: assertEnumNumberMember,
    assertEnumStringMember: assertEnumStringMember,
    assertEnumDefaultedMember: assertEnumDefaultedMember,
    assertJSXAttribute: assertJSXAttribute,
    assertJSXClosingElement: assertJSXClosingElement,
    assertJSXElement: assertJSXElement,
    assertJSXEmptyExpression: assertJSXEmptyExpression,
    assertJSXExpressionContainer: assertJSXExpressionContainer,
    assertJSXSpreadChild: assertJSXSpreadChild,
    assertJSXIdentifier: assertJSXIdentifier,
    assertJSXMemberExpression: assertJSXMemberExpression,
    assertJSXNamespacedName: assertJSXNamespacedName,
    assertJSXOpeningElement: assertJSXOpeningElement,
    assertJSXSpreadAttribute: assertJSXSpreadAttribute,
    assertJSXText: assertJSXText,
    assertJSXFragment: assertJSXFragment,
    assertJSXOpeningFragment: assertJSXOpeningFragment,
    assertJSXClosingFragment: assertJSXClosingFragment,
    assertNoop: assertNoop,
    assertPlaceholder: assertPlaceholder,
    assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
    assertArgumentPlaceholder: assertArgumentPlaceholder,
    assertBindExpression: assertBindExpression,
    assertClassProperty: assertClassProperty,
    assertPipelineTopicExpression: assertPipelineTopicExpression,
    assertPipelineBareFunction: assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
    assertClassPrivateProperty: assertClassPrivateProperty,
    assertClassPrivateMethod: assertClassPrivateMethod,
    assertImportAttribute: assertImportAttribute,
    assertDecorator: assertDecorator,
    assertDoExpression: assertDoExpression,
    assertExportDefaultSpecifier: assertExportDefaultSpecifier,
    assertPrivateName: assertPrivateName,
    assertRecordExpression: assertRecordExpression,
    assertTupleExpression: assertTupleExpression,
    assertDecimalLiteral: assertDecimalLiteral,
    assertStaticBlock: assertStaticBlock,
    assertTSParameterProperty: assertTSParameterProperty,
    assertTSDeclareFunction: assertTSDeclareFunction,
    assertTSDeclareMethod: assertTSDeclareMethod,
    assertTSQualifiedName: assertTSQualifiedName,
    assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
    assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
    assertTSPropertySignature: assertTSPropertySignature,
    assertTSMethodSignature: assertTSMethodSignature,
    assertTSIndexSignature: assertTSIndexSignature,
    assertTSAnyKeyword: assertTSAnyKeyword,
    assertTSBooleanKeyword: assertTSBooleanKeyword,
    assertTSBigIntKeyword: assertTSBigIntKeyword,
    assertTSIntrinsicKeyword: assertTSIntrinsicKeyword,
    assertTSNeverKeyword: assertTSNeverKeyword,
    assertTSNullKeyword: assertTSNullKeyword,
    assertTSNumberKeyword: assertTSNumberKeyword,
    assertTSObjectKeyword: assertTSObjectKeyword,
    assertTSStringKeyword: assertTSStringKeyword,
    assertTSSymbolKeyword: assertTSSymbolKeyword,
    assertTSUndefinedKeyword: assertTSUndefinedKeyword,
    assertTSUnknownKeyword: assertTSUnknownKeyword,
    assertTSVoidKeyword: assertTSVoidKeyword,
    assertTSThisType: assertTSThisType,
    assertTSFunctionType: assertTSFunctionType,
    assertTSConstructorType: assertTSConstructorType,
    assertTSTypeReference: assertTSTypeReference,
    assertTSTypePredicate: assertTSTypePredicate,
    assertTSTypeQuery: assertTSTypeQuery,
    assertTSTypeLiteral: assertTSTypeLiteral,
    assertTSArrayType: assertTSArrayType,
    assertTSTupleType: assertTSTupleType,
    assertTSOptionalType: assertTSOptionalType,
    assertTSRestType: assertTSRestType,
    assertTSNamedTupleMember: assertTSNamedTupleMember,
    assertTSUnionType: assertTSUnionType,
    assertTSIntersectionType: assertTSIntersectionType,
    assertTSConditionalType: assertTSConditionalType,
    assertTSInferType: assertTSInferType,
    assertTSParenthesizedType: assertTSParenthesizedType,
    assertTSTypeOperator: assertTSTypeOperator,
    assertTSIndexedAccessType: assertTSIndexedAccessType,
    assertTSMappedType: assertTSMappedType,
    assertTSLiteralType: assertTSLiteralType,
    assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
    assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
    assertTSInterfaceBody: assertTSInterfaceBody,
    assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
    assertTSAsExpression: assertTSAsExpression,
    assertTSTypeAssertion: assertTSTypeAssertion,
    assertTSEnumDeclaration: assertTSEnumDeclaration,
    assertTSEnumMember: assertTSEnumMember,
    assertTSModuleDeclaration: assertTSModuleDeclaration,
    assertTSModuleBlock: assertTSModuleBlock,
    assertTSImportType: assertTSImportType,
    assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
    assertTSExternalModuleReference: assertTSExternalModuleReference,
    assertTSNonNullExpression: assertTSNonNullExpression,
    assertTSExportAssignment: assertTSExportAssignment,
    assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
    assertTSTypeAnnotation: assertTSTypeAnnotation,
    assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
    assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
    assertTSTypeParameter: assertTSTypeParameter,
    assertExpression: assertExpression,
    assertBinary: assertBinary,
    assertScopable: assertScopable,
    assertBlockParent: assertBlockParent,
    assertBlock: assertBlock,
    assertStatement: assertStatement,
    assertTerminatorless: assertTerminatorless,
    assertCompletionStatement: assertCompletionStatement,
    assertConditional: assertConditional,
    assertLoop: assertLoop,
    assertWhile: assertWhile,
    assertExpressionWrapper: assertExpressionWrapper,
    assertFor: assertFor,
    assertForXStatement: assertForXStatement,
    assertFunction: assertFunction,
    assertFunctionParent: assertFunctionParent,
    assertPureish: assertPureish,
    assertDeclaration: assertDeclaration,
    assertPatternLike: assertPatternLike,
    assertLVal: assertLVal,
    assertTSEntityName: assertTSEntityName,
    assertLiteral: assertLiteral,
    assertImmutable: assertImmutable,
    assertUserWhitespacable: assertUserWhitespacable,
    assertMethod: assertMethod,
    assertObjectMember: assertObjectMember,
    assertProperty: assertProperty,
    assertUnaryLike: assertUnaryLike,
    assertPattern: assertPattern,
    assertClass: assertClass,
    assertModuleDeclaration: assertModuleDeclaration,
    assertExportDeclaration: assertExportDeclaration,
    assertModuleSpecifier: assertModuleSpecifier,
    assertFlow: assertFlow,
    assertFlowType: assertFlowType,
    assertFlowBaseAnnotation: assertFlowBaseAnnotation,
    assertFlowDeclaration: assertFlowDeclaration,
    assertFlowPredicate: assertFlowPredicate,
    assertEnumBody: assertEnumBody,
    assertEnumMember: assertEnumMember,
    assertJSX: assertJSX,
    assertPrivate: assertPrivate,
    assertTSTypeElement: assertTSTypeElement,
    assertTSType: assertTSType,
    assertTSBaseType: assertTSBaseType,
    assertNumberLiteral: assertNumberLiteral,
    assertRegexLiteral: assertRegexLiteral,
    assertRestProperty: assertRestProperty,
    assertSpreadProperty: assertSpreadProperty,
    arrayExpression: arrayExpression,
    assignmentExpression: assignmentExpression,
    binaryExpression: binaryExpression,
    interpreterDirective: interpreterDirective,
    directive: directive,
    directiveLiteral: directiveLiteral,
    blockStatement: blockStatement,
    breakStatement: breakStatement,
    callExpression: callExpression,
    catchClause: catchClause,
    conditionalExpression: conditionalExpression,
    continueStatement: continueStatement,
    debuggerStatement: debuggerStatement,
    doWhileStatement: doWhileStatement,
    emptyStatement: emptyStatement,
    expressionStatement: expressionStatement,
    file: file,
    forInStatement: forInStatement,
    forStatement: forStatement,
    functionDeclaration: functionDeclaration,
    functionExpression: functionExpression,
    identifier: identifier,
    ifStatement: ifStatement,
    labeledStatement: labeledStatement,
    stringLiteral: stringLiteral,
    numericLiteral: numericLiteral,
    nullLiteral: nullLiteral,
    booleanLiteral: booleanLiteral,
    regExpLiteral: regExpLiteral,
    logicalExpression: logicalExpression,
    memberExpression: memberExpression,
    newExpression: newExpression,
    program: program,
    objectExpression: objectExpression,
    objectMethod: objectMethod,
    objectProperty: objectProperty,
    restElement: restElement,
    returnStatement: returnStatement,
    sequenceExpression: sequenceExpression,
    parenthesizedExpression: parenthesizedExpression,
    switchCase: switchCase,
    switchStatement: switchStatement,
    thisExpression: thisExpression,
    throwStatement: throwStatement,
    tryStatement: tryStatement,
    unaryExpression: unaryExpression,
    updateExpression: updateExpression,
    variableDeclaration: variableDeclaration,
    variableDeclarator: variableDeclarator,
    whileStatement: whileStatement,
    withStatement: withStatement,
    assignmentPattern: assignmentPattern,
    arrayPattern: arrayPattern,
    arrowFunctionExpression: arrowFunctionExpression,
    classBody: classBody,
    classExpression: classExpression,
    classDeclaration: classDeclaration,
    exportAllDeclaration: exportAllDeclaration,
    exportDefaultDeclaration: exportDefaultDeclaration,
    exportNamedDeclaration: exportNamedDeclaration,
    exportSpecifier: exportSpecifier,
    forOfStatement: forOfStatement,
    importDeclaration: importDeclaration,
    importDefaultSpecifier: importDefaultSpecifier,
    importNamespaceSpecifier: importNamespaceSpecifier,
    importSpecifier: importSpecifier,
    metaProperty: metaProperty,
    classMethod: classMethod,
    objectPattern: objectPattern,
    spreadElement: spreadElement,
    'super': _super,
    taggedTemplateExpression: taggedTemplateExpression,
    templateElement: templateElement,
    templateLiteral: templateLiteral,
    yieldExpression: yieldExpression,
    awaitExpression: awaitExpression,
    'import': _import,
    bigIntLiteral: bigIntLiteral,
    exportNamespaceSpecifier: exportNamespaceSpecifier,
    optionalMemberExpression: optionalMemberExpression,
    optionalCallExpression: optionalCallExpression,
    anyTypeAnnotation: anyTypeAnnotation,
    arrayTypeAnnotation: arrayTypeAnnotation,
    booleanTypeAnnotation: booleanTypeAnnotation,
    booleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation,
    classImplements: classImplements,
    declareClass: declareClass,
    declareFunction: declareFunction,
    declareInterface: declareInterface,
    declareModule: declareModule,
    declareModuleExports: declareModuleExports,
    declareTypeAlias: declareTypeAlias,
    declareOpaqueType: declareOpaqueType,
    declareVariable: declareVariable,
    declareExportDeclaration: declareExportDeclaration,
    declareExportAllDeclaration: declareExportAllDeclaration,
    declaredPredicate: declaredPredicate,
    existsTypeAnnotation: existsTypeAnnotation,
    functionTypeAnnotation: functionTypeAnnotation,
    functionTypeParam: functionTypeParam,
    genericTypeAnnotation: genericTypeAnnotation,
    inferredPredicate: inferredPredicate,
    interfaceExtends: interfaceExtends,
    interfaceDeclaration: interfaceDeclaration,
    interfaceTypeAnnotation: interfaceTypeAnnotation,
    intersectionTypeAnnotation: intersectionTypeAnnotation,
    mixedTypeAnnotation: mixedTypeAnnotation,
    emptyTypeAnnotation: emptyTypeAnnotation,
    nullableTypeAnnotation: nullableTypeAnnotation,
    numberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    numberTypeAnnotation: numberTypeAnnotation,
    objectTypeAnnotation: objectTypeAnnotation,
    objectTypeInternalSlot: objectTypeInternalSlot,
    objectTypeCallProperty: objectTypeCallProperty,
    objectTypeIndexer: objectTypeIndexer,
    objectTypeProperty: objectTypeProperty,
    objectTypeSpreadProperty: objectTypeSpreadProperty,
    opaqueType: opaqueType,
    qualifiedTypeIdentifier: qualifiedTypeIdentifier,
    stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    stringTypeAnnotation: stringTypeAnnotation,
    symbolTypeAnnotation: symbolTypeAnnotation,
    thisTypeAnnotation: thisTypeAnnotation,
    tupleTypeAnnotation: tupleTypeAnnotation,
    typeofTypeAnnotation: typeofTypeAnnotation,
    typeAlias: typeAlias,
    typeAnnotation: typeAnnotation,
    typeCastExpression: typeCastExpression,
    typeParameter: typeParameter,
    typeParameterDeclaration: typeParameterDeclaration,
    typeParameterInstantiation: typeParameterInstantiation,
    unionTypeAnnotation: unionTypeAnnotation,
    variance: variance,
    voidTypeAnnotation: voidTypeAnnotation,
    enumDeclaration: enumDeclaration,
    enumBooleanBody: enumBooleanBody,
    enumNumberBody: enumNumberBody,
    enumStringBody: enumStringBody,
    enumSymbolBody: enumSymbolBody,
    enumBooleanMember: enumBooleanMember,
    enumNumberMember: enumNumberMember,
    enumStringMember: enumStringMember,
    enumDefaultedMember: enumDefaultedMember,
    jsxAttribute: jsxAttribute,
    jSXAttribute: jsxAttribute,
    jsxClosingElement: jsxClosingElement,
    jSXClosingElement: jsxClosingElement,
    jsxElement: jsxElement,
    jSXElement: jsxElement,
    jsxEmptyExpression: jsxEmptyExpression,
    jSXEmptyExpression: jsxEmptyExpression,
    jsxExpressionContainer: jsxExpressionContainer,
    jSXExpressionContainer: jsxExpressionContainer,
    jsxSpreadChild: jsxSpreadChild,
    jSXSpreadChild: jsxSpreadChild,
    jsxIdentifier: jsxIdentifier,
    jSXIdentifier: jsxIdentifier,
    jsxMemberExpression: jsxMemberExpression,
    jSXMemberExpression: jsxMemberExpression,
    jsxNamespacedName: jsxNamespacedName,
    jSXNamespacedName: jsxNamespacedName,
    jsxOpeningElement: jsxOpeningElement,
    jSXOpeningElement: jsxOpeningElement,
    jsxSpreadAttribute: jsxSpreadAttribute,
    jSXSpreadAttribute: jsxSpreadAttribute,
    jsxText: jsxText,
    jSXText: jsxText,
    jsxFragment: jsxFragment,
    jSXFragment: jsxFragment,
    jsxOpeningFragment: jsxOpeningFragment,
    jSXOpeningFragment: jsxOpeningFragment,
    jsxClosingFragment: jsxClosingFragment,
    jSXClosingFragment: jsxClosingFragment,
    noop: noop,
    placeholder: placeholder,
    v8IntrinsicIdentifier: v8IntrinsicIdentifier,
    argumentPlaceholder: argumentPlaceholder,
    bindExpression: bindExpression,
    classProperty: classProperty,
    pipelineTopicExpression: pipelineTopicExpression,
    pipelineBareFunction: pipelineBareFunction,
    pipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    classPrivateProperty: classPrivateProperty,
    classPrivateMethod: classPrivateMethod,
    importAttribute: importAttribute,
    decorator: decorator,
    doExpression: doExpression,
    exportDefaultSpecifier: exportDefaultSpecifier,
    privateName: privateName,
    recordExpression: recordExpression,
    tupleExpression: tupleExpression,
    decimalLiteral: decimalLiteral,
    staticBlock: staticBlock,
    tsParameterProperty: tsParameterProperty,
    tSParameterProperty: tsParameterProperty,
    tsDeclareFunction: tsDeclareFunction,
    tSDeclareFunction: tsDeclareFunction,
    tsDeclareMethod: tsDeclareMethod,
    tSDeclareMethod: tsDeclareMethod,
    tsQualifiedName: tsQualifiedName,
    tSQualifiedName: tsQualifiedName,
    tsCallSignatureDeclaration: tsCallSignatureDeclaration,
    tSCallSignatureDeclaration: tsCallSignatureDeclaration,
    tsConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tsPropertySignature: tsPropertySignature,
    tSPropertySignature: tsPropertySignature,
    tsMethodSignature: tsMethodSignature,
    tSMethodSignature: tsMethodSignature,
    tsIndexSignature: tsIndexSignature,
    tSIndexSignature: tsIndexSignature,
    tsAnyKeyword: tsAnyKeyword,
    tSAnyKeyword: tsAnyKeyword,
    tsBooleanKeyword: tsBooleanKeyword,
    tSBooleanKeyword: tsBooleanKeyword,
    tsBigIntKeyword: tsBigIntKeyword,
    tSBigIntKeyword: tsBigIntKeyword,
    tsIntrinsicKeyword: tsIntrinsicKeyword,
    tSIntrinsicKeyword: tsIntrinsicKeyword,
    tsNeverKeyword: tsNeverKeyword,
    tSNeverKeyword: tsNeverKeyword,
    tsNullKeyword: tsNullKeyword,
    tSNullKeyword: tsNullKeyword,
    tsNumberKeyword: tsNumberKeyword,
    tSNumberKeyword: tsNumberKeyword,
    tsObjectKeyword: tsObjectKeyword,
    tSObjectKeyword: tsObjectKeyword,
    tsStringKeyword: tsStringKeyword,
    tSStringKeyword: tsStringKeyword,
    tsSymbolKeyword: tsSymbolKeyword,
    tSSymbolKeyword: tsSymbolKeyword,
    tsUndefinedKeyword: tsUndefinedKeyword,
    tSUndefinedKeyword: tsUndefinedKeyword,
    tsUnknownKeyword: tsUnknownKeyword,
    tSUnknownKeyword: tsUnknownKeyword,
    tsVoidKeyword: tsVoidKeyword,
    tSVoidKeyword: tsVoidKeyword,
    tsThisType: tsThisType,
    tSThisType: tsThisType,
    tsFunctionType: tsFunctionType,
    tSFunctionType: tsFunctionType,
    tsConstructorType: tsConstructorType,
    tSConstructorType: tsConstructorType,
    tsTypeReference: tsTypeReference,
    tSTypeReference: tsTypeReference,
    tsTypePredicate: tsTypePredicate,
    tSTypePredicate: tsTypePredicate,
    tsTypeQuery: tsTypeQuery,
    tSTypeQuery: tsTypeQuery,
    tsTypeLiteral: tsTypeLiteral,
    tSTypeLiteral: tsTypeLiteral,
    tsArrayType: tsArrayType,
    tSArrayType: tsArrayType,
    tsTupleType: tsTupleType,
    tSTupleType: tsTupleType,
    tsOptionalType: tsOptionalType,
    tSOptionalType: tsOptionalType,
    tsRestType: tsRestType,
    tSRestType: tsRestType,
    tsNamedTupleMember: tsNamedTupleMember,
    tSNamedTupleMember: tsNamedTupleMember,
    tsUnionType: tsUnionType,
    tSUnionType: tsUnionType,
    tsIntersectionType: tsIntersectionType,
    tSIntersectionType: tsIntersectionType,
    tsConditionalType: tsConditionalType,
    tSConditionalType: tsConditionalType,
    tsInferType: tsInferType,
    tSInferType: tsInferType,
    tsParenthesizedType: tsParenthesizedType,
    tSParenthesizedType: tsParenthesizedType,
    tsTypeOperator: tsTypeOperator,
    tSTypeOperator: tsTypeOperator,
    tsIndexedAccessType: tsIndexedAccessType,
    tSIndexedAccessType: tsIndexedAccessType,
    tsMappedType: tsMappedType,
    tSMappedType: tsMappedType,
    tsLiteralType: tsLiteralType,
    tSLiteralType: tsLiteralType,
    tsExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tsInterfaceDeclaration: tsInterfaceDeclaration,
    tSInterfaceDeclaration: tsInterfaceDeclaration,
    tsInterfaceBody: tsInterfaceBody,
    tSInterfaceBody: tsInterfaceBody,
    tsTypeAliasDeclaration: tsTypeAliasDeclaration,
    tSTypeAliasDeclaration: tsTypeAliasDeclaration,
    tsAsExpression: tsAsExpression,
    tSAsExpression: tsAsExpression,
    tsTypeAssertion: tsTypeAssertion,
    tSTypeAssertion: tsTypeAssertion,
    tsEnumDeclaration: tsEnumDeclaration,
    tSEnumDeclaration: tsEnumDeclaration,
    tsEnumMember: tsEnumMember,
    tSEnumMember: tsEnumMember,
    tsModuleDeclaration: tsModuleDeclaration,
    tSModuleDeclaration: tsModuleDeclaration,
    tsModuleBlock: tsModuleBlock,
    tSModuleBlock: tsModuleBlock,
    tsImportType: tsImportType,
    tSImportType: tsImportType,
    tsImportEqualsDeclaration: tsImportEqualsDeclaration,
    tSImportEqualsDeclaration: tsImportEqualsDeclaration,
    tsExternalModuleReference: tsExternalModuleReference,
    tSExternalModuleReference: tsExternalModuleReference,
    tsNonNullExpression: tsNonNullExpression,
    tSNonNullExpression: tsNonNullExpression,
    tsExportAssignment: tsExportAssignment,
    tSExportAssignment: tsExportAssignment,
    tsNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tsTypeAnnotation: tsTypeAnnotation,
    tSTypeAnnotation: tsTypeAnnotation,
    tsTypeParameterInstantiation: tsTypeParameterInstantiation,
    tSTypeParameterInstantiation: tsTypeParameterInstantiation,
    tsTypeParameterDeclaration: tsTypeParameterDeclaration,
    tSTypeParameterDeclaration: tsTypeParameterDeclaration,
    tsTypeParameter: tsTypeParameter,
    tSTypeParameter: tsTypeParameter,
    numberLiteral: NumberLiteral,
    regexLiteral: RegexLiteral,
    restProperty: RestProperty,
    spreadProperty: SpreadProperty,
    ArrayExpression: arrayExpression,
    AssignmentExpression: assignmentExpression,
    BinaryExpression: binaryExpression,
    InterpreterDirective: interpreterDirective,
    Directive: directive,
    DirectiveLiteral: directiveLiteral,
    BlockStatement: blockStatement,
    BreakStatement: breakStatement,
    CallExpression: callExpression,
    CatchClause: catchClause,
    ConditionalExpression: conditionalExpression,
    ContinueStatement: continueStatement,
    DebuggerStatement: debuggerStatement,
    DoWhileStatement: doWhileStatement,
    EmptyStatement: emptyStatement,
    ExpressionStatement: expressionStatement,
    File: file,
    ForInStatement: forInStatement,
    ForStatement: forStatement,
    FunctionDeclaration: functionDeclaration,
    FunctionExpression: functionExpression,
    Identifier: identifier,
    IfStatement: ifStatement,
    LabeledStatement: labeledStatement,
    StringLiteral: stringLiteral,
    NumericLiteral: numericLiteral,
    NullLiteral: nullLiteral,
    BooleanLiteral: booleanLiteral,
    RegExpLiteral: regExpLiteral,
    LogicalExpression: logicalExpression,
    MemberExpression: memberExpression,
    NewExpression: newExpression,
    Program: program,
    ObjectExpression: objectExpression,
    ObjectMethod: objectMethod,
    ObjectProperty: objectProperty,
    RestElement: restElement,
    ReturnStatement: returnStatement,
    SequenceExpression: sequenceExpression,
    ParenthesizedExpression: parenthesizedExpression,
    SwitchCase: switchCase,
    SwitchStatement: switchStatement,
    ThisExpression: thisExpression,
    ThrowStatement: throwStatement,
    TryStatement: tryStatement,
    UnaryExpression: unaryExpression,
    UpdateExpression: updateExpression,
    VariableDeclaration: variableDeclaration,
    VariableDeclarator: variableDeclarator,
    WhileStatement: whileStatement,
    WithStatement: withStatement,
    AssignmentPattern: assignmentPattern,
    ArrayPattern: arrayPattern,
    ArrowFunctionExpression: arrowFunctionExpression,
    ClassBody: classBody,
    ClassExpression: classExpression,
    ClassDeclaration: classDeclaration,
    ExportAllDeclaration: exportAllDeclaration,
    ExportDefaultDeclaration: exportDefaultDeclaration,
    ExportNamedDeclaration: exportNamedDeclaration,
    ExportSpecifier: exportSpecifier,
    ForOfStatement: forOfStatement,
    ImportDeclaration: importDeclaration,
    ImportDefaultSpecifier: importDefaultSpecifier,
    ImportNamespaceSpecifier: importNamespaceSpecifier,
    ImportSpecifier: importSpecifier,
    MetaProperty: metaProperty,
    ClassMethod: classMethod,
    ObjectPattern: objectPattern,
    SpreadElement: spreadElement,
    Super: _super,
    TaggedTemplateExpression: taggedTemplateExpression,
    TemplateElement: templateElement,
    TemplateLiteral: templateLiteral,
    YieldExpression: yieldExpression,
    AwaitExpression: awaitExpression,
    Import: _import,
    BigIntLiteral: bigIntLiteral,
    ExportNamespaceSpecifier: exportNamespaceSpecifier,
    OptionalMemberExpression: optionalMemberExpression,
    OptionalCallExpression: optionalCallExpression,
    AnyTypeAnnotation: anyTypeAnnotation,
    ArrayTypeAnnotation: arrayTypeAnnotation,
    BooleanTypeAnnotation: booleanTypeAnnotation,
    BooleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    NullLiteralTypeAnnotation: nullLiteralTypeAnnotation,
    ClassImplements: classImplements,
    DeclareClass: declareClass,
    DeclareFunction: declareFunction,
    DeclareInterface: declareInterface,
    DeclareModule: declareModule,
    DeclareModuleExports: declareModuleExports,
    DeclareTypeAlias: declareTypeAlias,
    DeclareOpaqueType: declareOpaqueType,
    DeclareVariable: declareVariable,
    DeclareExportDeclaration: declareExportDeclaration,
    DeclareExportAllDeclaration: declareExportAllDeclaration,
    DeclaredPredicate: declaredPredicate,
    ExistsTypeAnnotation: existsTypeAnnotation,
    FunctionTypeAnnotation: functionTypeAnnotation,
    FunctionTypeParam: functionTypeParam,
    GenericTypeAnnotation: genericTypeAnnotation,
    InferredPredicate: inferredPredicate,
    InterfaceExtends: interfaceExtends,
    InterfaceDeclaration: interfaceDeclaration,
    InterfaceTypeAnnotation: interfaceTypeAnnotation,
    IntersectionTypeAnnotation: intersectionTypeAnnotation,
    MixedTypeAnnotation: mixedTypeAnnotation,
    EmptyTypeAnnotation: emptyTypeAnnotation,
    NullableTypeAnnotation: nullableTypeAnnotation,
    NumberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    NumberTypeAnnotation: numberTypeAnnotation,
    ObjectTypeAnnotation: objectTypeAnnotation,
    ObjectTypeInternalSlot: objectTypeInternalSlot,
    ObjectTypeCallProperty: objectTypeCallProperty,
    ObjectTypeIndexer: objectTypeIndexer,
    ObjectTypeProperty: objectTypeProperty,
    ObjectTypeSpreadProperty: objectTypeSpreadProperty,
    OpaqueType: opaqueType,
    QualifiedTypeIdentifier: qualifiedTypeIdentifier,
    StringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    StringTypeAnnotation: stringTypeAnnotation,
    SymbolTypeAnnotation: symbolTypeAnnotation,
    ThisTypeAnnotation: thisTypeAnnotation,
    TupleTypeAnnotation: tupleTypeAnnotation,
    TypeofTypeAnnotation: typeofTypeAnnotation,
    TypeAlias: typeAlias,
    TypeAnnotation: typeAnnotation,
    TypeCastExpression: typeCastExpression,
    TypeParameter: typeParameter,
    TypeParameterDeclaration: typeParameterDeclaration,
    TypeParameterInstantiation: typeParameterInstantiation,
    UnionTypeAnnotation: unionTypeAnnotation,
    Variance: variance,
    VoidTypeAnnotation: voidTypeAnnotation,
    EnumDeclaration: enumDeclaration,
    EnumBooleanBody: enumBooleanBody,
    EnumNumberBody: enumNumberBody,
    EnumStringBody: enumStringBody,
    EnumSymbolBody: enumSymbolBody,
    EnumBooleanMember: enumBooleanMember,
    EnumNumberMember: enumNumberMember,
    EnumStringMember: enumStringMember,
    EnumDefaultedMember: enumDefaultedMember,
    JSXAttribute: jsxAttribute,
    JSXClosingElement: jsxClosingElement,
    JSXElement: jsxElement,
    JSXEmptyExpression: jsxEmptyExpression,
    JSXExpressionContainer: jsxExpressionContainer,
    JSXSpreadChild: jsxSpreadChild,
    JSXIdentifier: jsxIdentifier,
    JSXMemberExpression: jsxMemberExpression,
    JSXNamespacedName: jsxNamespacedName,
    JSXOpeningElement: jsxOpeningElement,
    JSXSpreadAttribute: jsxSpreadAttribute,
    JSXText: jsxText,
    JSXFragment: jsxFragment,
    JSXOpeningFragment: jsxOpeningFragment,
    JSXClosingFragment: jsxClosingFragment,
    Noop: noop,
    Placeholder: placeholder,
    V8IntrinsicIdentifier: v8IntrinsicIdentifier,
    ArgumentPlaceholder: argumentPlaceholder,
    BindExpression: bindExpression,
    ClassProperty: classProperty,
    PipelineTopicExpression: pipelineTopicExpression,
    PipelineBareFunction: pipelineBareFunction,
    PipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    ClassPrivateProperty: classPrivateProperty,
    ClassPrivateMethod: classPrivateMethod,
    ImportAttribute: importAttribute,
    Decorator: decorator,
    DoExpression: doExpression,
    ExportDefaultSpecifier: exportDefaultSpecifier,
    PrivateName: privateName,
    RecordExpression: recordExpression,
    TupleExpression: tupleExpression,
    DecimalLiteral: decimalLiteral,
    StaticBlock: staticBlock,
    TSParameterProperty: tsParameterProperty,
    TSDeclareFunction: tsDeclareFunction,
    TSDeclareMethod: tsDeclareMethod,
    TSQualifiedName: tsQualifiedName,
    TSCallSignatureDeclaration: tsCallSignatureDeclaration,
    TSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    TSPropertySignature: tsPropertySignature,
    TSMethodSignature: tsMethodSignature,
    TSIndexSignature: tsIndexSignature,
    TSAnyKeyword: tsAnyKeyword,
    TSBooleanKeyword: tsBooleanKeyword,
    TSBigIntKeyword: tsBigIntKeyword,
    TSIntrinsicKeyword: tsIntrinsicKeyword,
    TSNeverKeyword: tsNeverKeyword,
    TSNullKeyword: tsNullKeyword,
    TSNumberKeyword: tsNumberKeyword,
    TSObjectKeyword: tsObjectKeyword,
    TSStringKeyword: tsStringKeyword,
    TSSymbolKeyword: tsSymbolKeyword,
    TSUndefinedKeyword: tsUndefinedKeyword,
    TSUnknownKeyword: tsUnknownKeyword,
    TSVoidKeyword: tsVoidKeyword,
    TSThisType: tsThisType,
    TSFunctionType: tsFunctionType,
    TSConstructorType: tsConstructorType,
    TSTypeReference: tsTypeReference,
    TSTypePredicate: tsTypePredicate,
    TSTypeQuery: tsTypeQuery,
    TSTypeLiteral: tsTypeLiteral,
    TSArrayType: tsArrayType,
    TSTupleType: tsTupleType,
    TSOptionalType: tsOptionalType,
    TSRestType: tsRestType,
    TSNamedTupleMember: tsNamedTupleMember,
    TSUnionType: tsUnionType,
    TSIntersectionType: tsIntersectionType,
    TSConditionalType: tsConditionalType,
    TSInferType: tsInferType,
    TSParenthesizedType: tsParenthesizedType,
    TSTypeOperator: tsTypeOperator,
    TSIndexedAccessType: tsIndexedAccessType,
    TSMappedType: tsMappedType,
    TSLiteralType: tsLiteralType,
    TSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    TSInterfaceDeclaration: tsInterfaceDeclaration,
    TSInterfaceBody: tsInterfaceBody,
    TSTypeAliasDeclaration: tsTypeAliasDeclaration,
    TSAsExpression: tsAsExpression,
    TSTypeAssertion: tsTypeAssertion,
    TSEnumDeclaration: tsEnumDeclaration,
    TSEnumMember: tsEnumMember,
    TSModuleDeclaration: tsModuleDeclaration,
    TSModuleBlock: tsModuleBlock,
    TSImportType: tsImportType,
    TSImportEqualsDeclaration: tsImportEqualsDeclaration,
    TSExternalModuleReference: tsExternalModuleReference,
    TSNonNullExpression: tsNonNullExpression,
    TSExportAssignment: tsExportAssignment,
    TSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    TSTypeAnnotation: tsTypeAnnotation,
    TSTypeParameterInstantiation: tsTypeParameterInstantiation,
    TSTypeParameterDeclaration: tsTypeParameterDeclaration,
    TSTypeParameter: tsTypeParameter,
    NumberLiteral: NumberLiteral,
    RegexLiteral: RegexLiteral,
    RestProperty: RestProperty,
    SpreadProperty: SpreadProperty,
    EXPRESSION_TYPES: EXPRESSION_TYPES,
    BINARY_TYPES: BINARY_TYPES,
    SCOPABLE_TYPES: SCOPABLE_TYPES,
    BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
    BLOCK_TYPES: BLOCK_TYPES,
    STATEMENT_TYPES: STATEMENT_TYPES,
    TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
    COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: CONDITIONAL_TYPES,
    LOOP_TYPES: LOOP_TYPES,
    WHILE_TYPES: WHILE_TYPES,
    EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
    FOR_TYPES: FOR_TYPES,
    FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
    FUNCTION_TYPES: FUNCTION_TYPES,
    FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
    PUREISH_TYPES: PUREISH_TYPES,
    DECLARATION_TYPES: DECLARATION_TYPES,
    PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
    LVAL_TYPES: LVAL_TYPES,
    TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
    LITERAL_TYPES: LITERAL_TYPES,
    IMMUTABLE_TYPES: IMMUTABLE_TYPES,
    USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
    METHOD_TYPES: METHOD_TYPES,
    OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
    PROPERTY_TYPES: PROPERTY_TYPES,
    UNARYLIKE_TYPES: UNARYLIKE_TYPES,
    PATTERN_TYPES: PATTERN_TYPES,
    CLASS_TYPES: CLASS_TYPES,
    MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
    EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
    FLOW_TYPES: FLOW_TYPES,
    FLOWTYPE_TYPES: FLOWTYPE_TYPES,
    FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
    ENUMBODY_TYPES: ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
    JSX_TYPES: JSX_TYPES,
    PRIVATE_TYPES: PRIVATE_TYPES,
    TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: TSTYPE_TYPES,
    TSBASETYPE_TYPES: TSBASETYPE_TYPES,
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS,
    FLATTENABLE_KEYS: FLATTENABLE_KEYS,
    FOR_INIT_KEYS: FOR_INIT_KEYS,
    COMMENT_KEYS: COMMENT_KEYS,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS,
    UPDATE_OPERATORS: UPDATE_OPERATORS,
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS,
    EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
    COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS,
    BINARY_OPERATORS: BINARY_OPERATORS,
    ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS,
    UNARY_OPERATORS: UNARY_OPERATORS,
    INHERIT_KEYS: INHERIT_KEYS,
    BLOCK_SCOPED_SYMBOL: BLOCK_SCOPED_SYMBOL,
    NOT_LOCAL_BINDING: NOT_LOCAL_BINDING,
    VISITOR_KEYS: VISITOR_KEYS,
    ALIAS_KEYS: ALIAS_KEYS,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS,
    NODE_FIELDS: NODE_FIELDS,
    BUILDER_KEYS: BUILDER_KEYS,
    DEPRECATED_KEYS: DEPRECATED_KEYS,
    NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
    PLACEHOLDERS: PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
    TYPES: TYPES,
    isArrayExpression: isArrayExpression,
    isAssignmentExpression: isAssignmentExpression,
    isBinaryExpression: isBinaryExpression,
    isInterpreterDirective: isInterpreterDirective,
    isDirective: isDirective,
    isDirectiveLiteral: isDirectiveLiteral,
    isBlockStatement: isBlockStatement,
    isBreakStatement: isBreakStatement,
    isCallExpression: isCallExpression,
    isCatchClause: isCatchClause,
    isConditionalExpression: isConditionalExpression,
    isContinueStatement: isContinueStatement,
    isDebuggerStatement: isDebuggerStatement,
    isDoWhileStatement: isDoWhileStatement,
    isEmptyStatement: isEmptyStatement,
    isExpressionStatement: isExpressionStatement,
    isFile: isFile,
    isForInStatement: isForInStatement,
    isForStatement: isForStatement,
    isFunctionDeclaration: isFunctionDeclaration,
    isFunctionExpression: isFunctionExpression,
    isIdentifier: isIdentifier,
    isIfStatement: isIfStatement,
    isLabeledStatement: isLabeledStatement,
    isStringLiteral: isStringLiteral,
    isNumericLiteral: isNumericLiteral,
    isNullLiteral: isNullLiteral,
    isBooleanLiteral: isBooleanLiteral,
    isRegExpLiteral: isRegExpLiteral,
    isLogicalExpression: isLogicalExpression,
    isMemberExpression: isMemberExpression,
    isNewExpression: isNewExpression,
    isProgram: isProgram,
    isObjectExpression: isObjectExpression,
    isObjectMethod: isObjectMethod,
    isObjectProperty: isObjectProperty,
    isRestElement: isRestElement,
    isReturnStatement: isReturnStatement,
    isSequenceExpression: isSequenceExpression,
    isParenthesizedExpression: isParenthesizedExpression,
    isSwitchCase: isSwitchCase,
    isSwitchStatement: isSwitchStatement,
    isThisExpression: isThisExpression,
    isThrowStatement: isThrowStatement,
    isTryStatement: isTryStatement,
    isUnaryExpression: isUnaryExpression,
    isUpdateExpression: isUpdateExpression,
    isVariableDeclaration: isVariableDeclaration,
    isVariableDeclarator: isVariableDeclarator,
    isWhileStatement: isWhileStatement,
    isWithStatement: isWithStatement,
    isAssignmentPattern: isAssignmentPattern,
    isArrayPattern: isArrayPattern,
    isArrowFunctionExpression: isArrowFunctionExpression,
    isClassBody: isClassBody,
    isClassExpression: isClassExpression,
    isClassDeclaration: isClassDeclaration,
    isExportAllDeclaration: isExportAllDeclaration,
    isExportDefaultDeclaration: isExportDefaultDeclaration,
    isExportNamedDeclaration: isExportNamedDeclaration,
    isExportSpecifier: isExportSpecifier,
    isForOfStatement: isForOfStatement,
    isImportDeclaration: isImportDeclaration,
    isImportDefaultSpecifier: isImportDefaultSpecifier,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier,
    isImportSpecifier: isImportSpecifier,
    isMetaProperty: isMetaProperty,
    isClassMethod: isClassMethod,
    isObjectPattern: isObjectPattern,
    isSpreadElement: isSpreadElement,
    isSuper: isSuper,
    isTaggedTemplateExpression: isTaggedTemplateExpression,
    isTemplateElement: isTemplateElement,
    isTemplateLiteral: isTemplateLiteral,
    isYieldExpression: isYieldExpression,
    isAwaitExpression: isAwaitExpression,
    isImport: isImport,
    isBigIntLiteral: isBigIntLiteral,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier,
    isOptionalMemberExpression: isOptionalMemberExpression,
    isOptionalCallExpression: isOptionalCallExpression,
    isAnyTypeAnnotation: isAnyTypeAnnotation,
    isArrayTypeAnnotation: isArrayTypeAnnotation,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation,
    isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
    isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
    isClassImplements: isClassImplements,
    isDeclareClass: isDeclareClass,
    isDeclareFunction: isDeclareFunction,
    isDeclareInterface: isDeclareInterface,
    isDeclareModule: isDeclareModule,
    isDeclareModuleExports: isDeclareModuleExports,
    isDeclareTypeAlias: isDeclareTypeAlias,
    isDeclareOpaqueType: isDeclareOpaqueType,
    isDeclareVariable: isDeclareVariable,
    isDeclareExportDeclaration: isDeclareExportDeclaration,
    isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
    isDeclaredPredicate: isDeclaredPredicate,
    isExistsTypeAnnotation: isExistsTypeAnnotation,
    isFunctionTypeAnnotation: isFunctionTypeAnnotation,
    isFunctionTypeParam: isFunctionTypeParam,
    isGenericTypeAnnotation: isGenericTypeAnnotation,
    isInferredPredicate: isInferredPredicate,
    isInterfaceExtends: isInterfaceExtends,
    isInterfaceDeclaration: isInterfaceDeclaration,
    isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
    isIntersectionTypeAnnotation: isIntersectionTypeAnnotation,
    isMixedTypeAnnotation: isMixedTypeAnnotation,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation,
    isNullableTypeAnnotation: isNullableTypeAnnotation,
    isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: isNumberTypeAnnotation,
    isObjectTypeAnnotation: isObjectTypeAnnotation,
    isObjectTypeInternalSlot: isObjectTypeInternalSlot,
    isObjectTypeCallProperty: isObjectTypeCallProperty,
    isObjectTypeIndexer: isObjectTypeIndexer,
    isObjectTypeProperty: isObjectTypeProperty,
    isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
    isOpaqueType: isOpaqueType,
    isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
    isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: isStringTypeAnnotation,
    isSymbolTypeAnnotation: isSymbolTypeAnnotation,
    isThisTypeAnnotation: isThisTypeAnnotation,
    isTupleTypeAnnotation: isTupleTypeAnnotation,
    isTypeofTypeAnnotation: isTypeofTypeAnnotation,
    isTypeAlias: isTypeAlias,
    isTypeAnnotation: isTypeAnnotation,
    isTypeCastExpression: isTypeCastExpression,
    isTypeParameter: isTypeParameter,
    isTypeParameterDeclaration: isTypeParameterDeclaration,
    isTypeParameterInstantiation: isTypeParameterInstantiation,
    isUnionTypeAnnotation: isUnionTypeAnnotation,
    isVariance: isVariance,
    isVoidTypeAnnotation: isVoidTypeAnnotation,
    isEnumDeclaration: isEnumDeclaration,
    isEnumBooleanBody: isEnumBooleanBody,
    isEnumNumberBody: isEnumNumberBody,
    isEnumStringBody: isEnumStringBody,
    isEnumSymbolBody: isEnumSymbolBody,
    isEnumBooleanMember: isEnumBooleanMember,
    isEnumNumberMember: isEnumNumberMember,
    isEnumStringMember: isEnumStringMember,
    isEnumDefaultedMember: isEnumDefaultedMember,
    isJSXAttribute: isJSXAttribute,
    isJSXClosingElement: isJSXClosingElement,
    isJSXElement: isJSXElement,
    isJSXEmptyExpression: isJSXEmptyExpression,
    isJSXExpressionContainer: isJSXExpressionContainer,
    isJSXSpreadChild: isJSXSpreadChild,
    isJSXIdentifier: isJSXIdentifier,
    isJSXMemberExpression: isJSXMemberExpression,
    isJSXNamespacedName: isJSXNamespacedName,
    isJSXOpeningElement: isJSXOpeningElement,
    isJSXSpreadAttribute: isJSXSpreadAttribute,
    isJSXText: isJSXText,
    isJSXFragment: isJSXFragment,
    isJSXOpeningFragment: isJSXOpeningFragment,
    isJSXClosingFragment: isJSXClosingFragment,
    isNoop: isNoop,
    isPlaceholder: isPlaceholder,
    isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
    isArgumentPlaceholder: isArgumentPlaceholder,
    isBindExpression: isBindExpression,
    isClassProperty: isClassProperty,
    isPipelineTopicExpression: isPipelineTopicExpression,
    isPipelineBareFunction: isPipelineBareFunction,
    isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
    isClassPrivateProperty: isClassPrivateProperty,
    isClassPrivateMethod: isClassPrivateMethod,
    isImportAttribute: isImportAttribute,
    isDecorator: isDecorator,
    isDoExpression: isDoExpression,
    isExportDefaultSpecifier: isExportDefaultSpecifier,
    isPrivateName: isPrivateName,
    isRecordExpression: isRecordExpression,
    isTupleExpression: isTupleExpression,
    isDecimalLiteral: isDecimalLiteral,
    isStaticBlock: isStaticBlock,
    isTSParameterProperty: isTSParameterProperty,
    isTSDeclareFunction: isTSDeclareFunction,
    isTSDeclareMethod: isTSDeclareMethod,
    isTSQualifiedName: isTSQualifiedName,
    isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
    isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
    isTSPropertySignature: isTSPropertySignature,
    isTSMethodSignature: isTSMethodSignature,
    isTSIndexSignature: isTSIndexSignature,
    isTSAnyKeyword: isTSAnyKeyword,
    isTSBooleanKeyword: isTSBooleanKeyword,
    isTSBigIntKeyword: isTSBigIntKeyword,
    isTSIntrinsicKeyword: isTSIntrinsicKeyword,
    isTSNeverKeyword: isTSNeverKeyword,
    isTSNullKeyword: isTSNullKeyword,
    isTSNumberKeyword: isTSNumberKeyword,
    isTSObjectKeyword: isTSObjectKeyword,
    isTSStringKeyword: isTSStringKeyword,
    isTSSymbolKeyword: isTSSymbolKeyword,
    isTSUndefinedKeyword: isTSUndefinedKeyword,
    isTSUnknownKeyword: isTSUnknownKeyword,
    isTSVoidKeyword: isTSVoidKeyword,
    isTSThisType: isTSThisType,
    isTSFunctionType: isTSFunctionType,
    isTSConstructorType: isTSConstructorType,
    isTSTypeReference: isTSTypeReference,
    isTSTypePredicate: isTSTypePredicate,
    isTSTypeQuery: isTSTypeQuery,
    isTSTypeLiteral: isTSTypeLiteral,
    isTSArrayType: isTSArrayType,
    isTSTupleType: isTSTupleType,
    isTSOptionalType: isTSOptionalType,
    isTSRestType: isTSRestType,
    isTSNamedTupleMember: isTSNamedTupleMember,
    isTSUnionType: isTSUnionType,
    isTSIntersectionType: isTSIntersectionType,
    isTSConditionalType: isTSConditionalType,
    isTSInferType: isTSInferType,
    isTSParenthesizedType: isTSParenthesizedType,
    isTSTypeOperator: isTSTypeOperator,
    isTSIndexedAccessType: isTSIndexedAccessType,
    isTSMappedType: isTSMappedType,
    isTSLiteralType: isTSLiteralType,
    isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
    isTSInterfaceDeclaration: isTSInterfaceDeclaration,
    isTSInterfaceBody: isTSInterfaceBody,
    isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
    isTSAsExpression: isTSAsExpression,
    isTSTypeAssertion: isTSTypeAssertion,
    isTSEnumDeclaration: isTSEnumDeclaration,
    isTSEnumMember: isTSEnumMember,
    isTSModuleDeclaration: isTSModuleDeclaration,
    isTSModuleBlock: isTSModuleBlock,
    isTSImportType: isTSImportType,
    isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
    isTSExternalModuleReference: isTSExternalModuleReference,
    isTSNonNullExpression: isTSNonNullExpression,
    isTSExportAssignment: isTSExportAssignment,
    isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
    isTSTypeAnnotation: isTSTypeAnnotation,
    isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
    isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
    isTSTypeParameter: isTSTypeParameter,
    isExpression: isExpression,
    isBinary: isBinary,
    isScopable: isScopable,
    isBlockParent: isBlockParent,
    isBlock: isBlock,
    isStatement: isStatement,
    isTerminatorless: isTerminatorless,
    isCompletionStatement: isCompletionStatement,
    isConditional: isConditional,
    isLoop: isLoop,
    isWhile: isWhile,
    isExpressionWrapper: isExpressionWrapper,
    isFor: isFor,
    isForXStatement: isForXStatement,
    isFunction: isFunction,
    isFunctionParent: isFunctionParent,
    isPureish: isPureish,
    isDeclaration: isDeclaration,
    isPatternLike: isPatternLike,
    isLVal: isLVal,
    isTSEntityName: isTSEntityName,
    isLiteral: isLiteral,
    isUserWhitespacable: isUserWhitespacable,
    isMethod: isMethod,
    isObjectMember: isObjectMember,
    isProperty: isProperty,
    isUnaryLike: isUnaryLike,
    isPattern: isPattern,
    isClass: isClass,
    isModuleDeclaration: isModuleDeclaration,
    isExportDeclaration: isExportDeclaration,
    isModuleSpecifier: isModuleSpecifier,
    isFlow: isFlow,
    isFlowType: isFlowType,
    isFlowBaseAnnotation: isFlowBaseAnnotation,
    isFlowDeclaration: isFlowDeclaration,
    isFlowPredicate: isFlowPredicate,
    isEnumBody: isEnumBody,
    isEnumMember: isEnumMember,
    isJSX: isJSX,
    isPrivate: isPrivate,
    isTSTypeElement: isTSTypeElement,
    isTSType: isTSType,
    isTSBaseType: isTSBaseType,
    isNumberLiteral: isNumberLiteral,
    isRegexLiteral: isRegexLiteral,
    isRestProperty: isRestProperty,
    isSpreadProperty: isSpreadProperty
  });

  var ReferencedIdentifier = {
    types: ["Identifier", "JSXIdentifier"],
    checkPath: function checkPath(path, opts) {
      var node = path.node,
          parent = path.parent;

      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (react.isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }

      return isReferenced(node, parent, path.parentPath.parent);
    }
  };
  var ReferencedMemberExpression = {
    types: ["MemberExpression"],
    checkPath: function checkPath(_ref) {
      var node = _ref.node,
          parent = _ref.parent;
      return isMemberExpression(node) && isReferenced(node, parent);
    }
  };
  var BindingIdentifier = {
    types: ["Identifier"],
    checkPath: function checkPath(path) {
      var node = path.node,
          parent = path.parent;
      var grandparent = path.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
  };
  var Statement = {
    types: ["Statement"],
    checkPath: function checkPath(_ref2) {
      var node = _ref2.node,
          parent = _ref2.parent;

      if (isStatement(node)) {
        if (isVariableDeclaration(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }

        return true;
      } else {
        return false;
      }
    }
  };
  var Expression = {
    types: ["Expression"],
    checkPath: function checkPath(path) {
      if (path.isIdentifier()) {
        return path.isReferencedIdentifier();
      } else {
        return isExpression(path.node);
      }
    }
  };
  var Scope = {
    types: ["Scopable", "Pattern"],
    checkPath: function checkPath(path) {
      return isScope(path.node, path.parent);
    }
  };
  var Referenced = {
    checkPath: function checkPath(path) {
      return isReferenced(path.node, path.parent);
    }
  };
  var BlockScoped = {
    checkPath: function checkPath(path) {
      return isBlockScoped(path.node);
    }
  };
  var Var = {
    types: ["VariableDeclaration"],
    checkPath: function checkPath(path) {
      return isVar(path.node);
    }
  };
  var User = {
    checkPath: function checkPath(path) {
      return path.node && !!path.node.loc;
    }
  };
  var Generated = {
    checkPath: function checkPath(path) {
      return !path.isUser();
    }
  };
  var Pure = {
    checkPath: function checkPath(path, opts) {
      return path.scope.isPure(path.node, opts);
    }
  };
  var Flow = {
    types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
    checkPath: function checkPath(_ref3) {
      var node = _ref3.node;

      if (isFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
  };
  var RestProperty$1 = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectPattern();
    }
  };
  var SpreadProperty$1 = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectExpression();
    }
  };
  var ExistentialTypeParam = {
    types: ["ExistsTypeAnnotation"]
  };
  var NumericLiteralTypeAnnotation = {
    types: ["NumberLiteralTypeAnnotation"]
  };
  var ForAwaitStatement = {
    types: ["ForOfStatement"],
    checkPath: function checkPath(_ref4) {
      var node = _ref4.node;
      return node["await"] === true;
    }
  };

  var virtualTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ReferencedIdentifier: ReferencedIdentifier,
    ReferencedMemberExpression: ReferencedMemberExpression,
    BindingIdentifier: BindingIdentifier,
    Statement: Statement,
    Expression: Expression,
    Scope: Scope,
    Referenced: Referenced,
    BlockScoped: BlockScoped,
    Var: Var,
    User: User,
    Generated: Generated,
    Pure: Pure,
    Flow: Flow,
    RestProperty: RestProperty$1,
    SpreadProperty: SpreadProperty$1,
    ExistentialTypeParam: ExistentialTypeParam,
    NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
    ForAwaitStatement: ForAwaitStatement
  });

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  var ms = function (val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  function parse(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }

    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }

    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }

    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }

    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }

    return ms + ' ms';
  }

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;

    function createDebug(namespace) {
      var prevTime;

      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!debug.enabled) {
          return;
        }

        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return match;
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }

          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = createDebug.enabled(namespace);
      debug.useColors = createDebug.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      debug.extend = extend;

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      createDebug.instances.push(debug);
      return debug;
    }

    function destroy() {
      var index = createDebug.instances.indexOf(this);

      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }

      return false;
    }

    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }

      for (i = 0; i < createDebug.instances.length; i++) {
        var instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }

    function disable() {
      var namespaces = [].concat(createDebug.names.map(toNamespace), createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      })).join(',');
      createDebug.enable('');
      return namespaces;
    }

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common = setup;

  var browser = createCommonjsModule(function (module, exports) {
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

  function useColors() {
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    }

    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }

    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }

  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

    if (!this.useColors) {
      return;
    }

    var c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function (match) {
      if (match === '%%') {
        return;
      }

      index++;

      if (match === '%c') {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }

  function log() {
    var _console;

    return typeof console === 'object' && console.log && (_console = console).log.apply(_console, arguments);
  }

  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {}
  }

  function load() {
    var r;

    try {
      r = exports.storage.getItem('debug');
    } catch (error) {}

    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }

    return r;
  }

  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }

  module.exports = common(exports);
  var formatters = module.exports.formatters;

  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  });

  var hasFlag = function (flag, argv) {
    if (argv === void 0) {
      argv = process.argv;
    }

    var prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    var position = argv.indexOf(prefix + flag);
    var terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };

  var _process = process,
      env = _process.env;
  var forceColor;

  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
  }

  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }

  function translateLevel(level) {
    if (level === 0) {
      return false;
    }

    return {
      level: level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }

  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }

    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }

    if (hasFlag('color=256')) {
      return 2;
    }

    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }

    var min = forceColor || 0;

    if (env.TERM === 'dumb') {
      return min;
    }

    if (process.platform === 'win32') {
      var osRelease = os__default['default'].release().split('.');

      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
        return sign in env;
      }) || env.CI_NAME === 'codeship') {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }

    if ('GITHUB_ACTIONS' in env) {
      return 1;
    }

    if (env.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env) {
      var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
      }
    }

    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }

    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }

    if ('COLORTERM' in env) {
      return 1;
    }

    return min;
  }

  function getSupportLevel(stream) {
    var level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }

  var supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty__default['default'].isatty(1))),
    stderr: translateLevel(supportsColor(true, tty__default['default'].isatty(2)))
  };

  var node = createCommonjsModule(function (module, exports) {
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];

  try {
    var supportsColor = supportsColor_1;

    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
    }
  } catch (error) {}

  exports.inspectOpts = Object.keys(process.env).filter(function (key) {
    return /^debug_/i.test(key);
  }).reduce(function (obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];

    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === 'null') {
      val = null;
    } else {
      val = Number(val);
    }

    obj[prop] = val;
    return obj;
  }, {});

  function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty__default['default'].isatty(process.stderr.fd);
  }

  function formatArgs(args) {
    var name = this.namespace,
        useColors = this.useColors;

    if (useColors) {
      var c = this.color;
      var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
      var prefix = "  " + colorCode + ";1m" + name + " \x1B[0m";
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
      args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + ' ' + args[0];
    }
  }

  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return '';
    }

    return new Date().toISOString() + ' ';
  }

  function log() {
    return process.stderr.write(util__default['default'].format.apply(util__default['default'], arguments) + '\n');
  }

  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }

  function load() {
    return process.env.DEBUG;
  }

  function init(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);

    for (var i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }

  module.exports = common(exports);
  var formatters = module.exports.formatters;

  formatters.o = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util__default['default'].inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, ' ');
  };

  formatters.O = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util__default['default'].inspect(v, this.inspectOpts);
  };
  });

  var src = createCommonjsModule(function (module) {
  if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    module.exports = browser;
  } else {
    module.exports = node;
  }
  });

  var Binding = function () {
    function Binding(_ref) {
      var identifier = _ref.identifier,
          scope = _ref.scope,
          path = _ref.path,
          kind = _ref.kind;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      this.clearValue();
    }

    var _proto = Binding.prototype;

    _proto.deoptValue = function deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    };

    _proto.setValue = function setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    };

    _proto.clearValue = function clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    };

    _proto.reassign = function reassign(path) {
      this.constant = false;

      if (this.constantViolations.indexOf(path) !== -1) {
        return;
      }

      this.constantViolations.push(path);
    };

    _proto.reference = function reference(path) {
      if (this.referencePaths.indexOf(path) !== -1) {
        return;
      }

      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    };

    _proto.dereference = function dereference() {
      this.references--;
      this.referenced = !!this.references;
    };

    return Binding;
  }();

  function splitExportDeclaration(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) {
      throw new Error("Only export declarations can be split.");
    }

    var isDefault = exportDeclaration.isExportDefaultDeclaration();
    var declaration = exportDeclaration.get("declaration");
    var isClassDeclaration = declaration.isClassDeclaration();

    if (isDefault) {
      var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
      var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      var id = declaration.node.id;
      var needBindingRegistration = false;

      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");

        if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
          declaration.node.id = cloneNode(id);
        }
      }

      var updatedDeclaration = standaloneDeclaration ? declaration : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
      var updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);

      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }

      return exportDeclaration;
    }

    if (exportDeclaration.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }

    var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
      return exportSpecifier(identifier(name), identifier(name));
    });
    var aliasDeclar = exportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  }

  var renameVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
      var node = _ref.node;

      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.skip();
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {
      if (path.isVariableDeclaration()) return;
      var ids = path.getOuterBindingIdentifiers();

      for (var name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };

  var Renamer = function () {
    function Renamer(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }

    var _proto = Renamer.prototype;

    _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
      var maybeExportDeclar = parentDeclar.parentPath;

      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }

      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
        return;
      }

      splitExportDeclaration(maybeExportDeclar);
    };

    _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
      return;
    };

    _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
      return;
    };

    _proto.rename = function rename(block) {
      var _this = this;

      var binding = this.binding,
          oldName = this.oldName,
          newName = this.newName;
      var scope = binding.scope,
          path = binding.path;
      var parentDeclar = path.find(function (path) {
        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
      });

      if (parentDeclar) {
        var bindingIds = parentDeclar.getOuterBindingIdentifiers();

        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }

      var blockToTraverse = block || scope.block;

      if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
        blockToTraverse.cases.forEach(function (c) {
          scope.traverse(c, renameVisitor, _this);
        });
      } else {
        scope.traverse(blockToTraverse, renameVisitor, this);
      }

      if (!block) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }

      if (binding.type === "hoisted") ;

      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
        this.maybeConvertFromClassFunctionExpression(parentDeclar);
      }
    };

    return Renamer;
  }();

  var builtin = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	BigInt: false,
  	BigInt64Array: false,
  	BigUint64Array: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	globalThis: false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es5 = {
  	"Array": false,
  	"Boolean": false,
  	constructor: false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	propertyIsEnumerable: false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"RegExp": false,
  	"String": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false
  };
  var es2015 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es2017 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var browser$1 = {
  	AbortController: false,
  	AbortSignal: false,
  	addEventListener: false,
  	alert: false,
  	AnalyserNode: false,
  	Animation: false,
  	AnimationEffectReadOnly: false,
  	AnimationEffectTiming: false,
  	AnimationEffectTimingReadOnly: false,
  	AnimationEvent: false,
  	AnimationPlaybackEvent: false,
  	AnimationTimeline: false,
  	applicationCache: false,
  	ApplicationCache: false,
  	ApplicationCacheErrorEvent: false,
  	atob: false,
  	Attr: false,
  	Audio: false,
  	AudioBuffer: false,
  	AudioBufferSourceNode: false,
  	AudioContext: false,
  	AudioDestinationNode: false,
  	AudioListener: false,
  	AudioNode: false,
  	AudioParam: false,
  	AudioProcessingEvent: false,
  	AudioScheduledSourceNode: false,
  	"AudioWorkletGlobalScope ": false,
  	AudioWorkletNode: false,
  	AudioWorkletProcessor: false,
  	BarProp: false,
  	BaseAudioContext: false,
  	BatteryManager: false,
  	BeforeUnloadEvent: false,
  	BiquadFilterNode: false,
  	Blob: false,
  	BlobEvent: false,
  	blur: false,
  	BroadcastChannel: false,
  	btoa: false,
  	BudgetService: false,
  	ByteLengthQueuingStrategy: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	cancelAnimationFrame: false,
  	cancelIdleCallback: false,
  	CanvasCaptureMediaStreamTrack: false,
  	CanvasGradient: false,
  	CanvasPattern: false,
  	CanvasRenderingContext2D: false,
  	ChannelMergerNode: false,
  	ChannelSplitterNode: false,
  	CharacterData: false,
  	clearInterval: false,
  	clearTimeout: false,
  	clientInformation: false,
  	ClipboardEvent: false,
  	close: false,
  	closed: false,
  	CloseEvent: false,
  	Comment: false,
  	CompositionEvent: false,
  	confirm: false,
  	console: false,
  	ConstantSourceNode: false,
  	ConvolverNode: false,
  	CountQueuingStrategy: false,
  	createImageBitmap: false,
  	Credential: false,
  	CredentialsContainer: false,
  	crypto: false,
  	Crypto: false,
  	CryptoKey: false,
  	CSS: false,
  	CSSConditionRule: false,
  	CSSFontFaceRule: false,
  	CSSGroupingRule: false,
  	CSSImportRule: false,
  	CSSKeyframeRule: false,
  	CSSKeyframesRule: false,
  	CSSMediaRule: false,
  	CSSNamespaceRule: false,
  	CSSPageRule: false,
  	CSSRule: false,
  	CSSRuleList: false,
  	CSSStyleDeclaration: false,
  	CSSStyleRule: false,
  	CSSStyleSheet: false,
  	CSSSupportsRule: false,
  	CustomElementRegistry: false,
  	customElements: false,
  	CustomEvent: false,
  	DataTransfer: false,
  	DataTransferItem: false,
  	DataTransferItemList: false,
  	defaultstatus: false,
  	defaultStatus: false,
  	DelayNode: false,
  	DeviceMotionEvent: false,
  	DeviceOrientationEvent: false,
  	devicePixelRatio: false,
  	dispatchEvent: false,
  	document: false,
  	Document: false,
  	DocumentFragment: false,
  	DocumentType: false,
  	DOMError: false,
  	DOMException: false,
  	DOMImplementation: false,
  	DOMMatrix: false,
  	DOMMatrixReadOnly: false,
  	DOMParser: false,
  	DOMPoint: false,
  	DOMPointReadOnly: false,
  	DOMQuad: false,
  	DOMRect: false,
  	DOMRectReadOnly: false,
  	DOMStringList: false,
  	DOMStringMap: false,
  	DOMTokenList: false,
  	DragEvent: false,
  	DynamicsCompressorNode: false,
  	Element: false,
  	ErrorEvent: false,
  	event: false,
  	Event: false,
  	EventSource: false,
  	EventTarget: false,
  	external: false,
  	fetch: false,
  	File: false,
  	FileList: false,
  	FileReader: false,
  	find: false,
  	focus: false,
  	FocusEvent: false,
  	FontFace: false,
  	FontFaceSetLoadEvent: false,
  	FormData: false,
  	frameElement: false,
  	frames: false,
  	GainNode: false,
  	Gamepad: false,
  	GamepadButton: false,
  	GamepadEvent: false,
  	getComputedStyle: false,
  	getSelection: false,
  	HashChangeEvent: false,
  	Headers: false,
  	history: false,
  	History: false,
  	HTMLAllCollection: false,
  	HTMLAnchorElement: false,
  	HTMLAreaElement: false,
  	HTMLAudioElement: false,
  	HTMLBaseElement: false,
  	HTMLBodyElement: false,
  	HTMLBRElement: false,
  	HTMLButtonElement: false,
  	HTMLCanvasElement: false,
  	HTMLCollection: false,
  	HTMLContentElement: false,
  	HTMLDataElement: false,
  	HTMLDataListElement: false,
  	HTMLDetailsElement: false,
  	HTMLDialogElement: false,
  	HTMLDirectoryElement: false,
  	HTMLDivElement: false,
  	HTMLDListElement: false,
  	HTMLDocument: false,
  	HTMLElement: false,
  	HTMLEmbedElement: false,
  	HTMLFieldSetElement: false,
  	HTMLFontElement: false,
  	HTMLFormControlsCollection: false,
  	HTMLFormElement: false,
  	HTMLFrameElement: false,
  	HTMLFrameSetElement: false,
  	HTMLHeadElement: false,
  	HTMLHeadingElement: false,
  	HTMLHRElement: false,
  	HTMLHtmlElement: false,
  	HTMLIFrameElement: false,
  	HTMLImageElement: false,
  	HTMLInputElement: false,
  	HTMLLabelElement: false,
  	HTMLLegendElement: false,
  	HTMLLIElement: false,
  	HTMLLinkElement: false,
  	HTMLMapElement: false,
  	HTMLMarqueeElement: false,
  	HTMLMediaElement: false,
  	HTMLMenuElement: false,
  	HTMLMetaElement: false,
  	HTMLMeterElement: false,
  	HTMLModElement: false,
  	HTMLObjectElement: false,
  	HTMLOListElement: false,
  	HTMLOptGroupElement: false,
  	HTMLOptionElement: false,
  	HTMLOptionsCollection: false,
  	HTMLOutputElement: false,
  	HTMLParagraphElement: false,
  	HTMLParamElement: false,
  	HTMLPictureElement: false,
  	HTMLPreElement: false,
  	HTMLProgressElement: false,
  	HTMLQuoteElement: false,
  	HTMLScriptElement: false,
  	HTMLSelectElement: false,
  	HTMLShadowElement: false,
  	HTMLSlotElement: false,
  	HTMLSourceElement: false,
  	HTMLSpanElement: false,
  	HTMLStyleElement: false,
  	HTMLTableCaptionElement: false,
  	HTMLTableCellElement: false,
  	HTMLTableColElement: false,
  	HTMLTableElement: false,
  	HTMLTableRowElement: false,
  	HTMLTableSectionElement: false,
  	HTMLTemplateElement: false,
  	HTMLTextAreaElement: false,
  	HTMLTimeElement: false,
  	HTMLTitleElement: false,
  	HTMLTrackElement: false,
  	HTMLUListElement: false,
  	HTMLUnknownElement: false,
  	HTMLVideoElement: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	IdleDeadline: false,
  	IIRFilterNode: false,
  	Image: false,
  	ImageBitmap: false,
  	ImageBitmapRenderingContext: false,
  	ImageCapture: false,
  	ImageData: false,
  	indexedDB: false,
  	innerHeight: false,
  	innerWidth: false,
  	InputEvent: false,
  	IntersectionObserver: false,
  	IntersectionObserverEntry: false,
  	"Intl": false,
  	isSecureContext: false,
  	KeyboardEvent: false,
  	KeyframeEffect: false,
  	KeyframeEffectReadOnly: false,
  	length: false,
  	localStorage: false,
  	location: true,
  	Location: false,
  	locationbar: false,
  	matchMedia: false,
  	MediaDeviceInfo: false,
  	MediaDevices: false,
  	MediaElementAudioSourceNode: false,
  	MediaEncryptedEvent: false,
  	MediaError: false,
  	MediaKeyMessageEvent: false,
  	MediaKeySession: false,
  	MediaKeyStatusMap: false,
  	MediaKeySystemAccess: false,
  	MediaList: false,
  	MediaQueryList: false,
  	MediaQueryListEvent: false,
  	MediaRecorder: false,
  	MediaSettingsRange: false,
  	MediaSource: false,
  	MediaStream: false,
  	MediaStreamAudioDestinationNode: false,
  	MediaStreamAudioSourceNode: false,
  	MediaStreamEvent: false,
  	MediaStreamTrack: false,
  	MediaStreamTrackEvent: false,
  	menubar: false,
  	MessageChannel: false,
  	MessageEvent: false,
  	MessagePort: false,
  	MIDIAccess: false,
  	MIDIConnectionEvent: false,
  	MIDIInput: false,
  	MIDIInputMap: false,
  	MIDIMessageEvent: false,
  	MIDIOutput: false,
  	MIDIOutputMap: false,
  	MIDIPort: false,
  	MimeType: false,
  	MimeTypeArray: false,
  	MouseEvent: false,
  	moveBy: false,
  	moveTo: false,
  	MutationEvent: false,
  	MutationObserver: false,
  	MutationRecord: false,
  	name: false,
  	NamedNodeMap: false,
  	NavigationPreloadManager: false,
  	navigator: false,
  	Navigator: false,
  	NetworkInformation: false,
  	Node: false,
  	NodeFilter: false,
  	NodeIterator: false,
  	NodeList: false,
  	Notification: false,
  	OfflineAudioCompletionEvent: false,
  	OfflineAudioContext: false,
  	offscreenBuffering: false,
  	OffscreenCanvas: true,
  	onabort: true,
  	onafterprint: true,
  	onanimationend: true,
  	onanimationiteration: true,
  	onanimationstart: true,
  	onappinstalled: true,
  	onauxclick: true,
  	onbeforeinstallprompt: true,
  	onbeforeprint: true,
  	onbeforeunload: true,
  	onblur: true,
  	oncancel: true,
  	oncanplay: true,
  	oncanplaythrough: true,
  	onchange: true,
  	onclick: true,
  	onclose: true,
  	oncontextmenu: true,
  	oncuechange: true,
  	ondblclick: true,
  	ondevicemotion: true,
  	ondeviceorientation: true,
  	ondeviceorientationabsolute: true,
  	ondrag: true,
  	ondragend: true,
  	ondragenter: true,
  	ondragleave: true,
  	ondragover: true,
  	ondragstart: true,
  	ondrop: true,
  	ondurationchange: true,
  	onemptied: true,
  	onended: true,
  	onerror: true,
  	onfocus: true,
  	ongotpointercapture: true,
  	onhashchange: true,
  	oninput: true,
  	oninvalid: true,
  	onkeydown: true,
  	onkeypress: true,
  	onkeyup: true,
  	onlanguagechange: true,
  	onload: true,
  	onloadeddata: true,
  	onloadedmetadata: true,
  	onloadstart: true,
  	onlostpointercapture: true,
  	onmessage: true,
  	onmessageerror: true,
  	onmousedown: true,
  	onmouseenter: true,
  	onmouseleave: true,
  	onmousemove: true,
  	onmouseout: true,
  	onmouseover: true,
  	onmouseup: true,
  	onmousewheel: true,
  	onoffline: true,
  	ononline: true,
  	onpagehide: true,
  	onpageshow: true,
  	onpause: true,
  	onplay: true,
  	onplaying: true,
  	onpointercancel: true,
  	onpointerdown: true,
  	onpointerenter: true,
  	onpointerleave: true,
  	onpointermove: true,
  	onpointerout: true,
  	onpointerover: true,
  	onpointerup: true,
  	onpopstate: true,
  	onprogress: true,
  	onratechange: true,
  	onrejectionhandled: true,
  	onreset: true,
  	onresize: true,
  	onscroll: true,
  	onsearch: true,
  	onseeked: true,
  	onseeking: true,
  	onselect: true,
  	onstalled: true,
  	onstorage: true,
  	onsubmit: true,
  	onsuspend: true,
  	ontimeupdate: true,
  	ontoggle: true,
  	ontransitionend: true,
  	onunhandledrejection: true,
  	onunload: true,
  	onvolumechange: true,
  	onwaiting: true,
  	onwheel: true,
  	open: false,
  	openDatabase: false,
  	opener: false,
  	Option: false,
  	origin: false,
  	OscillatorNode: false,
  	outerHeight: false,
  	outerWidth: false,
  	PageTransitionEvent: false,
  	pageXOffset: false,
  	pageYOffset: false,
  	PannerNode: false,
  	parent: false,
  	Path2D: false,
  	PaymentAddress: false,
  	PaymentRequest: false,
  	PaymentRequestUpdateEvent: false,
  	PaymentResponse: false,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceLongTaskTiming: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceNavigationTiming: false,
  	PerformanceObserver: false,
  	PerformanceObserverEntryList: false,
  	PerformancePaintTiming: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	PeriodicWave: false,
  	Permissions: false,
  	PermissionStatus: false,
  	personalbar: false,
  	PhotoCapabilities: false,
  	Plugin: false,
  	PluginArray: false,
  	PointerEvent: false,
  	PopStateEvent: false,
  	postMessage: false,
  	Presentation: false,
  	PresentationAvailability: false,
  	PresentationConnection: false,
  	PresentationConnectionAvailableEvent: false,
  	PresentationConnectionCloseEvent: false,
  	PresentationConnectionList: false,
  	PresentationReceiver: false,
  	PresentationRequest: false,
  	print: false,
  	ProcessingInstruction: false,
  	ProgressEvent: false,
  	PromiseRejectionEvent: false,
  	prompt: false,
  	PushManager: false,
  	PushSubscription: false,
  	PushSubscriptionOptions: false,
  	queueMicrotask: false,
  	RadioNodeList: false,
  	Range: false,
  	ReadableStream: false,
  	registerProcessor: false,
  	RemotePlayback: false,
  	removeEventListener: false,
  	Request: false,
  	requestAnimationFrame: false,
  	requestIdleCallback: false,
  	resizeBy: false,
  	ResizeObserver: false,
  	ResizeObserverEntry: false,
  	resizeTo: false,
  	Response: false,
  	RTCCertificate: false,
  	RTCDataChannel: false,
  	RTCDataChannelEvent: false,
  	RTCDtlsTransport: false,
  	RTCIceCandidate: false,
  	RTCIceGatherer: false,
  	RTCIceTransport: false,
  	RTCPeerConnection: false,
  	RTCPeerConnectionIceEvent: false,
  	RTCRtpContributingSource: false,
  	RTCRtpReceiver: false,
  	RTCRtpSender: false,
  	RTCSctpTransport: false,
  	RTCSessionDescription: false,
  	RTCStatsReport: false,
  	RTCTrackEvent: false,
  	screen: false,
  	Screen: false,
  	screenLeft: false,
  	ScreenOrientation: false,
  	screenTop: false,
  	screenX: false,
  	screenY: false,
  	ScriptProcessorNode: false,
  	scroll: false,
  	scrollbars: false,
  	scrollBy: false,
  	scrollTo: false,
  	scrollX: false,
  	scrollY: false,
  	SecurityPolicyViolationEvent: false,
  	Selection: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerRegistration: false,
  	sessionStorage: false,
  	setInterval: false,
  	setTimeout: false,
  	ShadowRoot: false,
  	SharedWorker: false,
  	SourceBuffer: false,
  	SourceBufferList: false,
  	speechSynthesis: false,
  	SpeechSynthesisEvent: false,
  	SpeechSynthesisUtterance: false,
  	StaticRange: false,
  	status: false,
  	statusbar: false,
  	StereoPannerNode: false,
  	stop: false,
  	Storage: false,
  	StorageEvent: false,
  	StorageManager: false,
  	styleMedia: false,
  	StyleSheet: false,
  	StyleSheetList: false,
  	SubtleCrypto: false,
  	SVGAElement: false,
  	SVGAngle: false,
  	SVGAnimatedAngle: false,
  	SVGAnimatedBoolean: false,
  	SVGAnimatedEnumeration: false,
  	SVGAnimatedInteger: false,
  	SVGAnimatedLength: false,
  	SVGAnimatedLengthList: false,
  	SVGAnimatedNumber: false,
  	SVGAnimatedNumberList: false,
  	SVGAnimatedPreserveAspectRatio: false,
  	SVGAnimatedRect: false,
  	SVGAnimatedString: false,
  	SVGAnimatedTransformList: false,
  	SVGAnimateElement: false,
  	SVGAnimateMotionElement: false,
  	SVGAnimateTransformElement: false,
  	SVGAnimationElement: false,
  	SVGCircleElement: false,
  	SVGClipPathElement: false,
  	SVGComponentTransferFunctionElement: false,
  	SVGDefsElement: false,
  	SVGDescElement: false,
  	SVGDiscardElement: false,
  	SVGElement: false,
  	SVGEllipseElement: false,
  	SVGFEBlendElement: false,
  	SVGFEColorMatrixElement: false,
  	SVGFEComponentTransferElement: false,
  	SVGFECompositeElement: false,
  	SVGFEConvolveMatrixElement: false,
  	SVGFEDiffuseLightingElement: false,
  	SVGFEDisplacementMapElement: false,
  	SVGFEDistantLightElement: false,
  	SVGFEDropShadowElement: false,
  	SVGFEFloodElement: false,
  	SVGFEFuncAElement: false,
  	SVGFEFuncBElement: false,
  	SVGFEFuncGElement: false,
  	SVGFEFuncRElement: false,
  	SVGFEGaussianBlurElement: false,
  	SVGFEImageElement: false,
  	SVGFEMergeElement: false,
  	SVGFEMergeNodeElement: false,
  	SVGFEMorphologyElement: false,
  	SVGFEOffsetElement: false,
  	SVGFEPointLightElement: false,
  	SVGFESpecularLightingElement: false,
  	SVGFESpotLightElement: false,
  	SVGFETileElement: false,
  	SVGFETurbulenceElement: false,
  	SVGFilterElement: false,
  	SVGForeignObjectElement: false,
  	SVGGElement: false,
  	SVGGeometryElement: false,
  	SVGGradientElement: false,
  	SVGGraphicsElement: false,
  	SVGImageElement: false,
  	SVGLength: false,
  	SVGLengthList: false,
  	SVGLinearGradientElement: false,
  	SVGLineElement: false,
  	SVGMarkerElement: false,
  	SVGMaskElement: false,
  	SVGMatrix: false,
  	SVGMetadataElement: false,
  	SVGMPathElement: false,
  	SVGNumber: false,
  	SVGNumberList: false,
  	SVGPathElement: false,
  	SVGPatternElement: false,
  	SVGPoint: false,
  	SVGPointList: false,
  	SVGPolygonElement: false,
  	SVGPolylineElement: false,
  	SVGPreserveAspectRatio: false,
  	SVGRadialGradientElement: false,
  	SVGRect: false,
  	SVGRectElement: false,
  	SVGScriptElement: false,
  	SVGSetElement: false,
  	SVGStopElement: false,
  	SVGStringList: false,
  	SVGStyleElement: false,
  	SVGSVGElement: false,
  	SVGSwitchElement: false,
  	SVGSymbolElement: false,
  	SVGTextContentElement: false,
  	SVGTextElement: false,
  	SVGTextPathElement: false,
  	SVGTextPositioningElement: false,
  	SVGTitleElement: false,
  	SVGTransform: false,
  	SVGTransformList: false,
  	SVGTSpanElement: false,
  	SVGUnitTypes: false,
  	SVGUseElement: false,
  	SVGViewElement: false,
  	TaskAttributionTiming: false,
  	Text: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	TextEvent: false,
  	TextMetrics: false,
  	TextTrack: false,
  	TextTrackCue: false,
  	TextTrackCueList: false,
  	TextTrackList: false,
  	TimeRanges: false,
  	toolbar: false,
  	top: false,
  	Touch: false,
  	TouchEvent: false,
  	TouchList: false,
  	TrackEvent: false,
  	TransitionEvent: false,
  	TreeWalker: false,
  	UIEvent: false,
  	URL: false,
  	URLSearchParams: false,
  	ValidityState: false,
  	visualViewport: false,
  	VisualViewport: false,
  	VTTCue: false,
  	WaveShaperNode: false,
  	WebAssembly: false,
  	WebGL2RenderingContext: false,
  	WebGLActiveInfo: false,
  	WebGLBuffer: false,
  	WebGLContextEvent: false,
  	WebGLFramebuffer: false,
  	WebGLProgram: false,
  	WebGLQuery: false,
  	WebGLRenderbuffer: false,
  	WebGLRenderingContext: false,
  	WebGLSampler: false,
  	WebGLShader: false,
  	WebGLShaderPrecisionFormat: false,
  	WebGLSync: false,
  	WebGLTexture: false,
  	WebGLTransformFeedback: false,
  	WebGLUniformLocation: false,
  	WebGLVertexArrayObject: false,
  	WebSocket: false,
  	WheelEvent: false,
  	window: false,
  	Window: false,
  	Worker: false,
  	WritableStream: false,
  	XMLDocument: false,
  	XMLHttpRequest: false,
  	XMLHttpRequestEventTarget: false,
  	XMLHttpRequestUpload: false,
  	XMLSerializer: false,
  	XPathEvaluator: false,
  	XPathExpression: false,
  	XPathResult: false,
  	XSLTProcessor: false
  };
  var worker = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	clearInterval: false,
  	clearTimeout: false,
  	close: true,
  	console: false,
  	fetch: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: true,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onoffline: true,
  	ononline: true,
  	onrejectionhandled: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: true,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var node$1 = {
  	__dirname: false,
  	__filename: false,
  	Buffer: false,
  	clearImmediate: false,
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	exports: true,
  	global: false,
  	"Intl": false,
  	module: false,
  	process: false,
  	queueMicrotask: false,
  	require: false,
  	setImmediate: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false
  };
  var commonjs = {
  	exports: true,
  	global: false,
  	module: false,
  	require: false
  };
  var amd = {
  	define: false,
  	require: false
  };
  var mocha = {
  	after: false,
  	afterEach: false,
  	before: false,
  	beforeEach: false,
  	context: false,
  	describe: false,
  	it: false,
  	mocha: false,
  	run: false,
  	setup: false,
  	specify: false,
  	suite: false,
  	suiteSetup: false,
  	suiteTeardown: false,
  	teardown: false,
  	test: false,
  	xcontext: false,
  	xdescribe: false,
  	xit: false,
  	xspecify: false
  };
  var jasmine = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fail: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jasmine: false,
  	pending: false,
  	runs: false,
  	spyOn: false,
  	spyOnProperty: false,
  	waits: false,
  	waitsFor: false,
  	xdescribe: false,
  	xit: false
  };
  var jest = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jest: false,
  	pit: false,
  	require: false,
  	test: false,
  	xdescribe: false,
  	xit: false,
  	xtest: false
  };
  var qunit = {
  	asyncTest: false,
  	deepEqual: false,
  	equal: false,
  	expect: false,
  	module: false,
  	notDeepEqual: false,
  	notEqual: false,
  	notOk: false,
  	notPropEqual: false,
  	notStrictEqual: false,
  	ok: false,
  	propEqual: false,
  	QUnit: false,
  	raises: false,
  	start: false,
  	stop: false,
  	strictEqual: false,
  	test: false,
  	throws: false
  };
  var phantomjs = {
  	console: true,
  	exports: true,
  	phantom: true,
  	require: true,
  	WebPage: true
  };
  var couch = {
  	emit: false,
  	exports: false,
  	getRow: false,
  	log: false,
  	module: false,
  	provides: false,
  	require: false,
  	respond: false,
  	send: false,
  	start: false,
  	sum: false
  };
  var rhino = {
  	defineClass: false,
  	deserialize: false,
  	gc: false,
  	help: false,
  	importClass: false,
  	importPackage: false,
  	java: false,
  	load: false,
  	loadClass: false,
  	Packages: false,
  	print: false,
  	quit: false,
  	readFile: false,
  	readUrl: false,
  	runCommand: false,
  	seal: false,
  	serialize: false,
  	spawn: false,
  	sync: false,
  	toint32: false,
  	version: false
  };
  var nashorn = {
  	__DIR__: false,
  	__FILE__: false,
  	__LINE__: false,
  	com: false,
  	edu: false,
  	exit: false,
  	java: false,
  	Java: false,
  	javafx: false,
  	JavaImporter: false,
  	javax: false,
  	JSAdapter: false,
  	load: false,
  	loadWithNewGlobal: false,
  	org: false,
  	Packages: false,
  	print: false,
  	quit: false
  };
  var wsh = {
  	ActiveXObject: true,
  	Enumerator: true,
  	GetObject: true,
  	ScriptEngine: true,
  	ScriptEngineBuildVersion: true,
  	ScriptEngineMajorVersion: true,
  	ScriptEngineMinorVersion: true,
  	VBArray: true,
  	WScript: true,
  	WSH: true,
  	XDomainRequest: true
  };
  var jquery = {
  	$: false,
  	jQuery: false
  };
  var yui = {
  	YAHOO: false,
  	YAHOO_config: false,
  	YUI: false,
  	YUI_config: false
  };
  var shelljs = {
  	cat: false,
  	cd: false,
  	chmod: false,
  	config: false,
  	cp: false,
  	dirs: false,
  	echo: false,
  	env: false,
  	error: false,
  	exec: false,
  	exit: false,
  	find: false,
  	grep: false,
  	ln: false,
  	ls: false,
  	mkdir: false,
  	mv: false,
  	popd: false,
  	pushd: false,
  	pwd: false,
  	rm: false,
  	sed: false,
  	set: false,
  	target: false,
  	tempdir: false,
  	test: false,
  	touch: false,
  	which: false
  };
  var prototypejs = {
  	$: false,
  	$$: false,
  	$A: false,
  	$break: false,
  	$continue: false,
  	$F: false,
  	$H: false,
  	$R: false,
  	$w: false,
  	Abstract: false,
  	Ajax: false,
  	Autocompleter: false,
  	Builder: false,
  	Class: false,
  	Control: false,
  	Draggable: false,
  	Draggables: false,
  	Droppables: false,
  	Effect: false,
  	Element: false,
  	Enumerable: false,
  	Event: false,
  	Field: false,
  	Form: false,
  	Hash: false,
  	Insertion: false,
  	ObjectRange: false,
  	PeriodicalExecuter: false,
  	Position: false,
  	Prototype: false,
  	Scriptaculous: false,
  	Selector: false,
  	Sortable: false,
  	SortableObserver: false,
  	Sound: false,
  	Template: false,
  	Toggle: false,
  	Try: false
  };
  var meteor = {
  	_: false,
  	$: false,
  	Accounts: false,
  	AccountsClient: false,
  	AccountsCommon: false,
  	AccountsServer: false,
  	App: false,
  	Assets: false,
  	Blaze: false,
  	check: false,
  	Cordova: false,
  	DDP: false,
  	DDPRateLimiter: false,
  	DDPServer: false,
  	Deps: false,
  	EJSON: false,
  	Email: false,
  	HTTP: false,
  	Log: false,
  	Match: false,
  	Meteor: false,
  	Mongo: false,
  	MongoInternals: false,
  	Npm: false,
  	Package: false,
  	Plugin: false,
  	process: false,
  	Random: false,
  	ReactiveDict: false,
  	ReactiveVar: false,
  	Router: false,
  	ServiceConfiguration: false,
  	Session: false,
  	share: false,
  	Spacebars: false,
  	Template: false,
  	Tinytest: false,
  	Tracker: false,
  	UI: false,
  	Utils: false,
  	WebApp: false,
  	WebAppInternals: false
  };
  var mongo = {
  	_isWindows: false,
  	_rand: false,
  	BulkWriteResult: false,
  	cat: false,
  	cd: false,
  	connect: false,
  	db: false,
  	getHostName: false,
  	getMemInfo: false,
  	hostname: false,
  	ISODate: false,
  	listFiles: false,
  	load: false,
  	ls: false,
  	md5sumFile: false,
  	mkdir: false,
  	Mongo: false,
  	NumberInt: false,
  	NumberLong: false,
  	ObjectId: false,
  	PlanCache: false,
  	print: false,
  	printjson: false,
  	pwd: false,
  	quit: false,
  	removeFile: false,
  	rs: false,
  	sh: false,
  	UUID: false,
  	version: false,
  	WriteResult: false
  };
  var applescript = {
  	$: false,
  	Application: false,
  	Automation: false,
  	console: false,
  	delay: false,
  	Library: false,
  	ObjC: false,
  	ObjectSpecifier: false,
  	Path: false,
  	Progress: false,
  	Ref: false
  };
  var serviceworker = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	clearInterval: false,
  	clearTimeout: false,
  	Client: false,
  	clients: false,
  	Clients: false,
  	close: true,
  	console: false,
  	ExtendableEvent: false,
  	ExtendableMessageEvent: false,
  	fetch: false,
  	FetchEvent: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: false,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onfetch: true,
  	oninstall: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onmessageerror: true,
  	onnotificationclick: true,
  	onnotificationclose: true,
  	onoffline: true,
  	ononline: true,
  	onpush: true,
  	onpushsubscriptionchange: true,
  	onrejectionhandled: true,
  	onsync: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	registration: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerGlobalScope: false,
  	ServiceWorkerMessageEvent: false,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	skipWaiting: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	WindowClient: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var atomtest = {
  	advanceClock: false,
  	fakeClearInterval: false,
  	fakeClearTimeout: false,
  	fakeSetInterval: false,
  	fakeSetTimeout: false,
  	resetTimeouts: false,
  	waitsForPromise: false
  };
  var embertest = {
  	andThen: false,
  	click: false,
  	currentPath: false,
  	currentRouteName: false,
  	currentURL: false,
  	fillIn: false,
  	find: false,
  	findAll: false,
  	findWithAssert: false,
  	keyEvent: false,
  	pauseTest: false,
  	resumeTest: false,
  	triggerEvent: false,
  	visit: false,
  	wait: false
  };
  var protractor = {
  	$: false,
  	$$: false,
  	browser: false,
  	by: false,
  	By: false,
  	DartObject: false,
  	element: false,
  	protractor: false
  };
  var webextensions = {
  	browser: false,
  	chrome: false,
  	opr: false
  };
  var greasemonkey = {
  	cloneInto: false,
  	createObjectIn: false,
  	exportFunction: false,
  	GM: false,
  	GM_addStyle: false,
  	GM_deleteValue: false,
  	GM_getResourceText: false,
  	GM_getResourceURL: false,
  	GM_getValue: false,
  	GM_info: false,
  	GM_listValues: false,
  	GM_log: false,
  	GM_openInTab: false,
  	GM_registerMenuCommand: false,
  	GM_setClipboard: false,
  	GM_setValue: false,
  	GM_xmlhttpRequest: false,
  	unsafeWindow: false
  };
  var devtools = {
  	$: false,
  	$_: false,
  	$$: false,
  	$0: false,
  	$1: false,
  	$2: false,
  	$3: false,
  	$4: false,
  	$x: false,
  	chrome: false,
  	clear: false,
  	copy: false,
  	debug: false,
  	dir: false,
  	dirxml: false,
  	getEventListeners: false,
  	inspect: false,
  	keys: false,
  	monitor: false,
  	monitorEvents: false,
  	profile: false,
  	profileEnd: false,
  	queryObjects: false,
  	table: false,
  	undebug: false,
  	unmonitor: false,
  	unmonitorEvents: false,
  	values: false
  };
  var globals = {
  	builtin: builtin,
  	es5: es5,
  	es2015: es2015,
  	es2017: es2017,
  	browser: browser$1,
  	worker: worker,
  	node: node$1,
  	commonjs: commonjs,
  	amd: amd,
  	mocha: mocha,
  	jasmine: jasmine,
  	jest: jest,
  	qunit: qunit,
  	phantomjs: phantomjs,
  	couch: couch,
  	rhino: rhino,
  	nashorn: nashorn,
  	wsh: wsh,
  	jquery: jquery,
  	yui: yui,
  	shelljs: shelljs,
  	prototypejs: prototypejs,
  	meteor: meteor,
  	mongo: mongo,
  	applescript: applescript,
  	serviceworker: serviceworker,
  	atomtest: atomtest,
  	embertest: embertest,
  	protractor: protractor,
  	"shared-node-browser": {
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	setInterval: false,
  	setTimeout: false,
  	URL: false,
  	URLSearchParams: false
  },
  	webextensions: webextensions,
  	greasemonkey: greasemonkey,
  	devtools: devtools
  };

  var globals$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    builtin: builtin,
    es5: es5,
    es2015: es2015,
    es2017: es2017,
    browser: browser$1,
    worker: worker,
    node: node$1,
    commonjs: commonjs,
    amd: amd,
    mocha: mocha,
    jasmine: jasmine,
    jest: jest,
    qunit: qunit,
    phantomjs: phantomjs,
    couch: couch,
    rhino: rhino,
    nashorn: nashorn,
    wsh: wsh,
    jquery: jquery,
    yui: yui,
    shelljs: shelljs,
    prototypejs: prototypejs,
    meteor: meteor,
    mongo: mongo,
    applescript: applescript,
    serviceworker: serviceworker,
    atomtest: atomtest,
    embertest: embertest,
    protractor: protractor,
    webextensions: webextensions,
    greasemonkey: greasemonkey,
    devtools: devtools,
    'default': globals
  });

  var require$$0 = getCjsExportFromNamespace(globals$1);

  var globals$2 = require$$0;

  var path = new WeakMap();
  var scope = new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    path = new WeakMap();
  }
  function clearScope() {
    scope = new WeakMap();
  }

  var cache = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get path () { return path; },
    get scope () { return scope; },
    clear: clear,
    clearPath: clearPath,
    clearScope: clearScope
  });

  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (isModuleDeclaration(node)) {
          if (node.source) {
            gatherNodeParts(node.source, parts);
          } else if (node.specifiers && node.specifiers.length) {
            for (var _iterator = _createForOfIteratorHelperLoose(node.specifiers), _step; !(_step = _iterator()).done;) {
              var e = _step.value;
              gatherNodeParts(e, parts);
            }
          } else if (node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral(node)) {
          parts.push(node.value);
        }

        break;

      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;

      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;

      case "ObjectExpression":
      case "ObjectPattern":
        for (var _iterator2 = _createForOfIteratorHelperLoose(node.properties), _step2; !(_step2 = _iterator2()).done;) {
          var _e = _step2.value;
          gatherNodeParts(_e, parts);
        }

        break;

      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;

      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;

      case "ThisExpression":
        parts.push("this");
        break;

      case "Super":
        parts.push("super");
        break;

      case "Import":
        parts.push("import");
        break;

      case "DoExpression":
        parts.push("do");
        break;

      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;

      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;

      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;

      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;

      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;

      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;

      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;

      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;

      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;

      case "JSXOpeningElement":
        parts.push(node.name);
        break;

      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;

      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;

      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }

  var collectorVisitor = {
    For: function For(path) {
      for (var _i = 0, _arr = FOR_INIT_KEYS; _i < _arr.length; _i++) {
        var key = _arr[_i];
        var declar = path.get(key);

        if (declar.isVar()) {
          var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      }
    },
    Declaration: function Declaration(path) {
      if (path.isBlockScoped()) return;

      if (path.isExportDeclaration() && path.get("declaration").isDeclaration()) {
        return;
      }

      var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      state.references.push(path);
    },
    ForXStatement: function ForXStatement(path, state) {
      var left = path.get("left");

      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      }
    },
    ExportDeclaration: {
      exit: function exit(path) {
        var node = path.node,
            scope = path.scope;
        var declar = node.declaration;

        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          var id = declar.id;
          if (!id) return;
          var binding = scope.getBinding(id.name);
          if (binding) binding.reference(path);
        } else if (isVariableDeclaration(declar)) {
          for (var _i2 = 0, _arr2 = declar.declarations; _i2 < _arr2.length; _i2++) {
            var decl = _arr2[_i2];

            for (var _i3 = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i3 < _Object$keys.length; _i3++) {
              var name = _Object$keys[_i3];

              var _binding = scope.getBinding(name);

              if (_binding) _binding.reference(path);
            }
          }
        }
      }
    },
    LabeledStatement: function LabeledStatement(path) {
      path.scope.getProgramParent().addGlobal(path.node);
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression: function UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression: function UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped: function BlockScoped(path) {
      var scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      var parent = scope.getBlockParent();
      parent.registerDeclaration(path);

      if (path.isClassDeclaration() && path.node.id) {
        var id = path.node.id;
        var name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    Block: function Block(path) {
      var paths = path.get("body");

      for (var _i4 = 0, _arr3 = paths; _i4 < _arr3.length; _i4++) {
        var bodyPath = _arr3[_i4];

        if (bodyPath.isFunctionDeclaration()) {
          path.scope.getBlockParent().registerDeclaration(bodyPath);
        }
      }
    },
    CatchClause: function CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function: function Function(path) {
      if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }

      var params = path.get("params");

      for (var _iterator3 = _createForOfIteratorHelperLoose(params), _step3; !(_step3 = _iterator3()).done;) {
        var param = _step3.value;
        path.scope.registerBinding("param", param);
      }
    },
    ClassExpression: function ClassExpression(path) {
      if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path);
      }
    }
  };
  var uid = 0;

  var Scope$1 = function () {
    function Scope(path) {
      var node = path.node;
      var cached = scope.get(node);

      if ((cached == null ? void 0 : cached.path) === path) {
        return cached;
      }

      scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
      this.inited = false;
    }

    var _proto = Scope.prototype;

    _proto.traverse = function traverse(node, opts, state) {
      traverse$1(node, opts, this, state, this.path);
    };

    _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return cloneNode(id);
    };

    _proto.generateUidIdentifier = function generateUidIdentifier(name) {
      return identifier(this.generateUid(name));
    };

    _proto.generateUid = function generateUid(name) {
      if (name === void 0) {
        name = "temp";
      }

      name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      var uid;
      var i = 1;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      var program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    };

    _proto._generateUid = function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_" + id;
    };

    _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    };

    _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
      return identifier(this.generateUidBasedOnNode(node, defaultName));
    };

    _proto.isStatic = function isStatic(node) {
      if (isThisExpression(node) || isSuper(node)) {
        return true;
      }

      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    };

    _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id: id
          });
          return cloneNode(id);
        }

        return id;
      }
    };

    _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

      if (duplicate) {
        throw this.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
      }
    };

    _proto.rename = function rename(oldName, newName, block) {
      var binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new Renamer(binding, oldName, newName).rename(block);
      }
    };

    _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };

    _proto.dump = function dump() {
      var sep = "-".repeat(60);
      console.log(sep);
      var scope = this;

      do {
        console.log("#", scope.block.type);

        for (var _i5 = 0, _Object$keys2 = Object.keys(scope.bindings); _i5 < _Object$keys2.length; _i5++) {
          var name = _Object$keys2[_i5];
          var binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    };

    _proto.toArray = function toArray(node, i, allowArrayLike) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if ((binding == null ? void 0 : binding.constant) && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (isArrayExpression(node)) {
        return node;
      }

      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      }

      var helperName;
      var args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      if (allowArrayLike) {
        args.unshift(this.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }

      return callExpression(this.hub.addHelper(helperName), args);
    };

    _proto.hasLabel = function hasLabel(name) {
      return !!this.getLabel(name);
    };

    _proto.getLabel = function getLabel(name) {
      return this.labels.get(name);
    };

    _proto.registerLabel = function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    };

    _proto.registerDeclaration = function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");

        for (var _i6 = 0, _arr4 = declarations; _i6 < _arr4.length; _i6++) {
          var declar = _arr4[_i6];
          this.registerBinding(path.node.kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var specifiers = path.get("specifiers");

        for (var _i7 = 0, _arr5 = specifiers; _i7 < _arr5.length; _i7++) {
          var specifier = _arr5[_i7];
          this.registerBinding("module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");

        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    };

    _proto.buildUndefinedNode = function buildUndefinedNode() {
      return unaryExpression("void", numericLiteral(0), true);
    };

    _proto.registerConstantViolation = function registerConstantViolation(path) {
      var ids = path.getBindingIdentifiers();

      for (var _i8 = 0, _Object$keys3 = Object.keys(ids); _i8 < _Object$keys3.length; _i8++) {
        var name = _Object$keys3[_i8];
        var binding = this.getBinding(name);
        if (binding) binding.reassign(path);
      }
    };

    _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
      if (bindingPath === void 0) {
        bindingPath = path;
      }

      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");

        for (var _iterator4 = _createForOfIteratorHelperLoose(declarators), _step4; !(_step4 = _iterator4()).done;) {
          var declar = _step4.value;
          this.registerBinding(kind, declar);
        }

        return;
      }

      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);

      for (var _i9 = 0, _Object$keys4 = Object.keys(ids); _i9 < _Object$keys4.length; _i9++) {
        var name = _Object$keys4[_i9];
        parent.references[name] = true;

        for (var _i10 = 0, _arr6 = ids[name]; _i10 < _arr6.length; _i10++) {
          var id = _arr6[_i10];
          var local = this.getOwnBinding(name);

          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }

          if (local) {
            this.registerConstantViolation(bindingPath);
          } else {
            this.bindings[name] = new Binding({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      }
    };

    _proto.addGlobal = function addGlobal(node) {
      this.globals[node.name] = node;
    };

    _proto.hasUid = function hasUid(name) {
      var scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasGlobal = function hasGlobal(name) {
      var scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasReference = function hasReference(name) {
      return !!this.getProgramParent().references[name];
    };

    _proto.isPure = function isPure(node, constantsOnly) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (isClass(node)) {
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody(node)) {
        for (var _iterator5 = _createForOfIteratorHelperLoose(node.body), _step5; !(_step5 = _iterator5()).done;) {
          var method = _step5.value;
          if (!this.isPure(method, constantsOnly)) return false;
        }

        return true;
      } else if (isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression(node)) {
        for (var _i11 = 0, _arr7 = node.elements; _i11 < _arr7.length; _i11++) {
          var elem = _arr7[_i11];
          if (!this.isPure(elem, constantsOnly)) return false;
        }

        return true;
      } else if (isObjectExpression(node)) {
        for (var _i12 = 0, _arr8 = node.properties; _i12 < _arr8.length; _i12++) {
          var prop = _arr8[_i12];
          if (!this.isPure(prop, constantsOnly)) return false;
        }

        return true;
      } else if (isMethod(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (node.kind === "get" || node.kind === "set") return false;
        return true;
      } else if (isProperty(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        return this.isPure(node.value, constantsOnly);
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        for (var _i13 = 0, _arr9 = node.expressions; _i13 < _arr9.length; _i13++) {
          var expression = _arr9[_i13];
          if (!this.isPure(expression, constantsOnly)) return false;
        }

        return true;
      } else {
        return isPureish(node);
      }
    };

    _proto.setData = function setData(key, val) {
      return this.data[key] = val;
    };

    _proto.getData = function getData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    };

    _proto.removeData = function removeData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    };

    _proto.init = function init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    };

    _proto.crawl = function crawl() {
      var path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);

      if (path.isFunction()) {
        if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
          this.registerBinding("local", path.get("id"), path);
        }

        var params = path.get("params");

        for (var _iterator6 = _createForOfIteratorHelperLoose(params), _step6; !(_step6 = _iterator6()).done;) {
          var param = _step6.value;
          this.registerBinding("param", param);
        }
      }

      var programParent = this.getProgramParent();
      if (programParent.crawling) return;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;
      path.traverse(collectorVisitor, state);
      this.crawling = false;

      for (var _iterator7 = _createForOfIteratorHelperLoose(state.assignments), _step7; !(_step7 = _iterator7()).done;) {
        var _path = _step7.value;

        var ids = _path.getBindingIdentifiers();

        for (var _i14 = 0, _Object$keys5 = Object.keys(ids); _i14 < _Object$keys5.length; _i14++) {
          var name = _Object$keys5[_i14];
          if (_path.scope.getBinding(name)) continue;
          programParent.addGlobal(ids[name]);
        }

        _path.scope.registerConstantViolation(_path);
      }

      for (var _iterator8 = _createForOfIteratorHelperLoose(state.references), _step8; !(_step8 = _iterator8()).done;) {
        var ref = _step8.value;
        var binding = ref.scope.getBinding(ref.node.name);

        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }

      for (var _iterator9 = _createForOfIteratorHelperLoose(state.constantViolations), _step9; !(_step9 = _iterator9()).done;) {
        var _path2 = _step9.value;

        _path2.scope.registerConstantViolation(_path2);
      }
    };

    _proto.push = function push(opts) {
      var path = this.path;

      if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      var unique = opts.unique;
      var kind = opts.kind || "var";
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:" + kind + ":" + blockHoist;
      var declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        var declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;

        var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

        declarPath = _path$unshiftContaine[0];
        if (!unique) path.setData(dataKey, declarPath);
      }

      var declarator = variableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator);
      this.registerBinding(kind, declarPath.get("declarations").pop());
    };

    _proto.getProgramParent = function getProgramParent() {
      var scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    };

    _proto.getFunctionParent = function getFunctionParent() {
      var scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    };

    _proto.getBlockParent = function getBlockParent() {
      var scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    };

    _proto.getAllBindings = function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;

      do {
        for (var _i15 = 0, _Object$keys6 = Object.keys(scope.bindings); _i15 < _Object$keys6.length; _i15++) {
          var key = _Object$keys6[_i15];

          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }

        scope = scope.parent;
      } while (scope);

      return ids;
    };

    _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
      var ids = Object.create(null);

      for (var _i16 = 0, _arr10 = arguments; _i16 < _arr10.length; _i16++) {
        var kind = _arr10[_i16];
        var scope = this;

        do {
          for (var _i17 = 0, _Object$keys7 = Object.keys(scope.bindings); _i17 < _Object$keys7.length; _i17++) {
            var name = _Object$keys7[_i17];
            var binding = scope.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }

          scope = scope.parent;
        } while (scope);
      }

      return ids;
    };

    _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    };

    _proto.getBinding = function getBinding(name) {
      var scope = this;
      var previousPath;

      do {
        var binding = scope.getOwnBinding(name);

        if (binding) {
          var _previousPath;

          if (((_previousPath = previousPath) == null ? void 0 : _previousPath.isPattern()) && binding.kind !== "param") ; else {
            return binding;
          }
        }

        previousPath = scope.path;
      } while (scope = scope.parent);
    };

    _proto.getOwnBinding = function getOwnBinding(name) {
      return this.bindings[name];
    };

    _proto.getBindingIdentifier = function getBindingIdentifier(name) {
      var _this$getBinding;

      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
    };

    _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding == null ? void 0 : binding.identifier;
    };

    _proto.hasOwnBinding = function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    };

    _proto.hasBinding = function hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    };

    _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {
      var _this$parent;

      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
    };

    _proto.moveBindingTo = function moveBindingTo(name, scope) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    };

    _proto.removeOwnBinding = function removeOwnBinding(name) {
      delete this.bindings[name];
    };

    _proto.removeBinding = function removeBinding(name) {
      var _this$getBinding2;

      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
      var scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    };

    _createClass(Scope, [{
      key: "parent",
      get: function get() {
        var parent = this.path.findParent(function (p) {
          return p.isScope();
        });
        return parent == null ? void 0 : parent.scope;
      }
    }, {
      key: "parentBlock",
      get: function get() {
        return this.path.parent;
      }
    }, {
      key: "hub",
      get: function get() {
        return this.path.hub;
      }
    }]);

    return Scope;
  }();

  Scope$1.globals = Object.keys(globals$2.builtin);
  Scope$1.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };

  var decode = function (charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode == plus) {
      return 62;
    }

    if (charCode == slash) {
      return 63;
    }

    return -1;
  };

  var base64 = {
  	encode: encode,
  	decode: decode
  };

  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  var encode$1 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
  	encode: encode$1,
  	decode: decode$1
  };

  var util = createCommonjsModule(function (module, exports) {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }

  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);

    if (!match) {
      return null;
    }

    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }

  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';

    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }

    url += '//';

    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }

    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }

    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }

    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }

    return url;
  }

  exports.urlGenerate = urlGenerate;

  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);

    if (url) {
      if (!url.path) {
        return aPath;
      }

      path = url.path;
    }

    var isAbsolute = exports.isAbsolute(path);
    var parts = path.split(/\/+/);

    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];

      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }

    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }

    return path;
  }

  exports.normalize = normalize;

  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    if (aPath === "") {
      aPath = ".";
    }

    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);

    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }

      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }

    return joined;
  }

  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };

  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');
    var level = 0;

    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");

      if (index < 0) {
        return aPath;
      }

      aRoot = aRoot.slice(0, index);

      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }

  exports.relative = relative;

  var supportsNullProto = function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }();

  function identity(s) {
    return s;
  }

  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }

  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }

  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9) {
        return false;
      }

    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36) {
          return false;
        }
    }

    return true;
  }

  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }

  exports.compareByOriginalPositions = compareByOriginalPositions;

  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }

  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;

    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;

    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }

  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  });

  var has$1 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };

  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has$1.call(this._set, sStr);
    }
  };

  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);

      if (has$1.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };

  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet;

  var arraySet = {
  	ArraySet: ArraySet_1
  };

  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };

  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1 = MappingList;

  var mappingList = {
  	MappingList: MappingList_1
  };

  var ArraySet$1 = arraySet.ArraySet;

  var MappingList$1 = mappingList.MappingList;

  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList$1();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot;

    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }

    var newSources = new ArraySet$1();
    var newNames = new ArraySet$1();

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }

      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1 = SourceMapGenerator;

  var sourceMapGenerator = {
  	SourceMapGenerator: SourceMapGenerator_1
  };

  var binarySearch = createCommonjsModule(function (module, exports) {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);

    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

    if (index < 0) {
      return -1;
    }

    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }

      --index;
    }

    return index;
  };
  });

  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort = {
  	quickSort: quickSort_1
  };

  var ArraySet$2 = arraySet.ArraySet;



  var quickSort$1 = quickSort.quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };

  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function get() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function get() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);

      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }

      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }

    if (!this._sources.has(needle.source)) {
      return [];
    }

    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1 = SourceMapConsumer;

  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources.map(String).map(util.normalize).map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet$2.fromArray(names.map(String), true);
    this._sources = ArraySet$2.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };

  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort$1(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      mapping.lastGeneratedColumn = Infinity;
    }
  };

  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);

          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }

        var name = util.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;

    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');

    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }

    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$2();
    this._names = new ArraySet$2();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }

        this._sources.add(source);

        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
  	SourceMapConsumer: SourceMapConsumer_1,
  	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;



  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";

  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function shiftNextLine() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }

      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this);

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }

      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };

  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };

  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  var SourceNode_1 = SourceNode;

  var sourceNode = {
  	SourceNode: SourceNode_1
  };

  var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
  var SourceNode$1 = sourceNode.SourceNode;

  var sourceMap = {
  	SourceMapGenerator: SourceMapGenerator$2,
  	SourceMapConsumer: SourceMapConsumer$1,
  	SourceNode: SourceNode$1
  };

  var SourceMap = function () {
    function SourceMap(opts, code) {
      this._cachedMap = null;
      this._code = code;
      this._opts = opts;
      this._rawMappings = [];
    }

    var _proto = SourceMap.prototype;

    _proto.get = function get() {
      if (!this._cachedMap) {
        var map = this._cachedMap = new sourceMap.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        });
        var code = this._code;

        if (typeof code === "string") {
          map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
        } else if (typeof code === "object") {
          Object.keys(code).forEach(function (sourceFileName) {
            map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          });
        }

        this._rawMappings.forEach(function (mapping) {
          return map.addMapping(mapping);
        }, map);
      }

      return this._cachedMap.toJSON();
    };

    _proto.getRawMappings = function getRawMappings() {
      return this._rawMappings.slice();
    };

    _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      if (this._lastGenLine !== generatedLine && line === null) return;

      if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
        return;
      }

      this._cachedMap = null;
      this._lastGenLine = generatedLine;
      this._lastSourceLine = line;
      this._lastSourceColumn = column;

      this._rawMappings.push({
        name: identifierName || undefined,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: line == null ? undefined : {
          line: line,
          column: column
        }
      });
    };

    return SourceMap;
  }();

  var SPACES_RE = /^[ \t]+$/;

  var Buffer$1 = function () {
    function Buffer(map) {
      this._map = null;
      this._buf = [];
      this._last = "";
      this._queue = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: null,
        line: null,
        column: null,
        filename: null
      };
      this._disallowedPop = null;
      this._map = map;
    }

    var _proto = Buffer.prototype;

    _proto.get = function get() {
      this._flush();

      var map = this._map;
      var result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: map == null ? void 0 : map.getRawMappings()
      };

      if (map) {
        Object.defineProperty(result, "map", {
          configurable: true,
          enumerable: true,
          get: function get() {
            return this.map = map.get();
          },
          set: function set(value) {
            Object.defineProperty(this, "map", {
              value: value,
              writable: true
            });
          }
        });
      }

      return result;
    };

    _proto.append = function append(str) {
      this._flush();

      var _this$_sourcePosition = this._sourcePosition,
          line = _this$_sourcePosition.line,
          column = _this$_sourcePosition.column,
          filename = _this$_sourcePosition.filename,
          identifierName = _this$_sourcePosition.identifierName,
          force = _this$_sourcePosition.force;

      this._append(str, line, column, identifierName, filename, force);
    };

    _proto.queue = function queue(str) {
      if (str === "\n") {
        while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      var _this$_sourcePosition2 = this._sourcePosition,
          line = _this$_sourcePosition2.line,
          column = _this$_sourcePosition2.column,
          filename = _this$_sourcePosition2.filename,
          identifierName = _this$_sourcePosition2.identifierName,
          force = _this$_sourcePosition2.force;

      this._queue.unshift([str, line, column, identifierName, filename, force]);
    };

    _proto._flush = function _flush() {
      var item;

      while (item = this._queue.pop()) {
        this._append.apply(this, item);
      }
    };

    _proto._append = function _append(str, line, column, identifierName, filename, force) {
      this._buf.push(str);

      this._last = str[str.length - 1];
      var i = str.indexOf("\n");
      var last = 0;

      if (i !== 0) {
        this._mark(line, column, identifierName, filename, force);
      }

      while (i !== -1) {
        this._position.line++;
        this._position.column = 0;
        last = i + 1;

        if (last < str.length) {
          this._mark(++line, 0, identifierName, filename, force);
        }

        i = str.indexOf("\n", last);
      }

      this._position.column += str.length - last;
    };

    _proto._mark = function _mark(line, column, identifierName, filename, force) {
      var _this$_map;

      (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === "\n") {
        this._queue.shift();
      }
    };

    _proto.removeLastSemicolon = function removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ";") {
        this._queue.shift();
      }
    };

    _proto.endsWith = function endsWith(suffix) {
      if (suffix.length === 1) {
        var last;

        if (this._queue.length > 0) {
          var str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this._last;
        }

        return last === suffix;
      }

      var end = this._last + this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    };

    _proto.hasContent = function hasContent() {
      return this._queue.length > 0 || !!this._last;
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this.source("start", loc, true);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    };

    _proto.source = function source(prop, loc, force) {
      if (prop && !loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition, force);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      if (!this._map) return cb();
      var originalLine = this._sourcePosition.line;
      var originalColumn = this._sourcePosition.column;
      var originalFilename = this._sourcePosition.filename;
      var originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._sourcePosition.force = false;
        this._disallowedPop = null;
      }
    };

    _proto._disallowPop = function _disallowPop(prop, loc) {
      if (prop && !loc) return;
      this._disallowedPop = this._normalizePosition(prop, loc);
    };

    _proto._normalizePosition = function _normalizePosition(prop, loc, targetObj, force) {
      var pos = loc ? loc[prop] : null;

      if (targetObj === undefined) {
        targetObj = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
          force: false
        };
      }

      var origLine = targetObj.line;
      var origColumn = targetObj.column;
      var origFilename = targetObj.filename;
      targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;
      targetObj.line = pos == null ? void 0 : pos.line;
      targetObj.column = pos == null ? void 0 : pos.column;
      targetObj.filename = loc == null ? void 0 : loc.filename;

      if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
        targetObj.force = force;
      }

      return targetObj;
    };

    _proto.getCurrentColumn = function getCurrentColumn() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var lastIndex = extra.lastIndexOf("\n");
      return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    };

    _proto.getCurrentLine = function getCurrentLine() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var count = 0;

      for (var i = 0; i < extra.length; i++) {
        if (extra[i] === "\n") count++;
      }

      return this._position.line + count;
    };

    return Buffer;
  }();

  function crawl(node, state) {
    if (state === void 0) {
      state = {};
    }

    if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
      crawl(node.object, state);
      if (node.computed) crawl(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      crawl(node.left, state);
      crawl(node.right, state);
    } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
      state.hasCall = true;
      crawl(node.callee, state);
    } else if (isFunction(node)) {
      state.hasFunction = true;
    } else if (isIdentifier(node)) {
      state.hasHelper = state.hasHelper || isHelper(node.callee);
    }

    return state;
  }

  function isHelper(node) {
    if (isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier(node)) {
      return node.name === "require" || node.name[0] === "_";
    } else if (isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }

  function isType$1(node) {
    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
  }

  var nodes = {
    AssignmentExpression: function AssignmentExpression(node) {
      var state = crawl(node.right);

      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return {
          before: state.hasFunction,
          after: true
        };
      }
    },
    SwitchCase: function SwitchCase(node, parent) {
      return {
        before: node.consequent.length || parent.cases[0] === node,
        after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
      };
    },
    LogicalExpression: function LogicalExpression(node) {
      if (isFunction(node.left) || isFunction(node.right)) {
        return {
          after: true
        };
      }
    },
    Literal: function Literal(node) {
      if (node.value === "use strict") {
        return {
          after: true
        };
      }
    },
    CallExpression: function CallExpression(node) {
      if (isFunction(node.callee) || isHelper(node)) {
        return {
          before: true,
          after: true
        };
      }
    },
    OptionalCallExpression: function OptionalCallExpression(node) {
      if (isFunction(node.callee)) {
        return {
          before: true,
          after: true
        };
      }
    },
    VariableDeclaration: function VariableDeclaration(node) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        var enabled = isHelper(declar.id) && !isType$1(declar.init);

        if (!enabled) {
          var state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }

        if (enabled) {
          return {
            before: true,
            after: true
          };
        }
      }
    },
    IfStatement: function IfStatement(node) {
      if (isBlockStatement(node.consequent)) {
        return {
          before: true,
          after: true
        };
      }
    }
  };

  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeCallProperty = function (node, parent) {
    var _parent$properties;

    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) == null ? void 0 : _parent$properties.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeIndexer = function (node, parent) {
    var _parent$properties2, _parent$callPropertie;

    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) == null ? void 0 : _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) == null ? void 0 : _parent$callPropertie.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeInternalSlot = function (node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;

    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) == null ? void 0 : _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) == null ? void 0 : _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) == null ? void 0 : _parent$indexers.length)) {
      return {
        before: true
      };
    }
  };

  var list = {
    VariableDeclaration: function VariableDeclaration(node) {
      return node.declarations.map(function (decl) {
        return decl.init;
      });
    },
    ArrayExpression: function ArrayExpression(node) {
      return node.elements;
    },
    ObjectExpression: function ObjectExpression(node) {
      return node.properties;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
    var type = _ref[0],
        amounts = _ref[1];

    if (typeof amounts === "boolean") {
      amounts = {
        after: amounts,
        before: amounts
      };
    }

    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
      nodes[type] = function () {
        return amounts;
      };
    });
  });

  var PRECEDENCE = {
    "||": 0,
    "??": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    "in": 6,
    "instanceof": 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  };

  var isClassExtendsClause = function isClassExtendsClause(node, parent) {
    return (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;
  };

  var hasPostfixPart = function hasPostfixPart(node, parent) {
    return (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
  };

  function NullableTypeAnnotation(node, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation(node, parent, printStack) {
    return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
  }
  function UpdateExpression(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }
  function ObjectExpression(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerArrow: true
    });
  }
  function DoExpression(node, parent, printStack) {
    return isFirstInStatement(printStack);
  }
  function Binary(node, parent) {
    if (node.operator === "**" && isBinaryExpression(parent, {
      operator: "**"
    })) {
      return parent.left === node;
    }

    if (isClassExtendsClause(node, parent)) {
      return true;
    }

    if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
      return true;
    }

    if (isBinary(parent)) {
      var parentOp = parent.operator;
      var parentPos = PRECEDENCE[parentOp];
      var nodeOp = node.operator;
      var nodePos = PRECEDENCE[nodeOp];

      if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
        return true;
      }
    }
  }
  function UnionTypeAnnotation(node, parent) {
    return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
  }
  function TSAsExpression() {
    return true;
  }
  function TSTypeAssertion() {
    return true;
  }
  function TSUnionType(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
  }
  function TSInferType(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent);
  }
  function BinaryExpression(node, parent) {
    return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
  }
  function SequenceExpression(node, parent) {
    if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
      return false;
    }

    return true;
  }
  function YieldExpression(node, parent) {
    return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
  }
  function ClassExpression(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: true
    });
  }
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
      operator: "**",
      left: node
    }) || isClassExtendsClause(node, parent);
  }
  function FunctionExpression(node, parent, printStack) {
    return isFirstInStatement(printStack, {
      considerDefaultExports: true
    });
  }
  function ArrowFunctionExpression(node, parent) {
    return isExportDeclaration(parent) || ConditionalExpression(node, parent);
  }
  function ConditionalExpression(node, parent) {
    if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
      test: node
    }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
      return true;
    }

    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression(node, parent) {
    return isCallExpression(parent, {
      callee: node
    }) || isMemberExpression(parent, {
      object: node
    });
  }
  function AssignmentExpression(node, parent, printStack) {
    if (isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression(node, parent);
    }
  }
  function LogicalExpression(node, parent) {
    switch (node.operator) {
      case "||":
        if (!isLogicalExpression(parent)) return false;
        return parent.operator === "??" || parent.operator === "&&";

      case "&&":
        return isLogicalExpression(parent, {
          operator: "??"
        });

      case "??":
        return isLogicalExpression(parent) && parent.operator !== "??";
    }
  }

  function isFirstInStatement(printStack, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$considerArrow = _ref.considerArrow,
        considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,
        _ref$considerDefaultE = _ref.considerDefaultExports,
        considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;

    var i = printStack.length - 1;
    var node = printStack[i];
    i--;
    var parent = printStack[i];

    while (i >= 0) {
      if (isExpressionStatement(parent, {
        expression: node
      }) || considerDefaultExports && isExportDefaultDeclaration(parent, {
        declaration: node
      }) || considerArrow && isArrowFunctionExpression(parent, {
        body: node
      })) {
        return true;
      }

      if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
        test: node
      }) || isBinary(parent, {
        left: node
      }) || isAssignmentExpression(parent, {
        left: node
      })) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  var parens = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NullableTypeAnnotation: NullableTypeAnnotation,
    FunctionTypeAnnotation: FunctionTypeAnnotation,
    UpdateExpression: UpdateExpression,
    ObjectExpression: ObjectExpression,
    DoExpression: DoExpression,
    Binary: Binary,
    UnionTypeAnnotation: UnionTypeAnnotation,
    IntersectionTypeAnnotation: UnionTypeAnnotation,
    TSAsExpression: TSAsExpression,
    TSTypeAssertion: TSTypeAssertion,
    TSUnionType: TSUnionType,
    TSIntersectionType: TSUnionType,
    TSInferType: TSInferType,
    BinaryExpression: BinaryExpression,
    SequenceExpression: SequenceExpression,
    YieldExpression: YieldExpression,
    AwaitExpression: YieldExpression,
    ClassExpression: ClassExpression,
    UnaryLike: UnaryLike,
    FunctionExpression: FunctionExpression,
    ArrowFunctionExpression: ArrowFunctionExpression,
    ConditionalExpression: ConditionalExpression,
    OptionalMemberExpression: OptionalMemberExpression,
    OptionalCallExpression: OptionalMemberExpression,
    AssignmentExpression: AssignmentExpression,
    LogicalExpression: LogicalExpression
  });

  function expandAliases(obj) {
    var newObj = {};

    function add(type, func) {
      var fn = newObj[type];
      newObj[type] = fn ? function (node, parent, stack) {
        var result = fn(node, parent, stack);
        return result == null ? func(node, parent, stack) : result;
      } : func;
    }

    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      var aliases = FLIPPED_ALIAS_KEYS[type];

      if (aliases) {
        for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
          var alias = _step.value;
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }

    return newObj;
  }

  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(nodes);
  var expandedWhitespaceList = expandAliases(list);

  function find(obj, node, parent, printStack) {
    var fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }

  function isOrHasCallExpression(node) {
    if (isCallExpression(node)) {
      return true;
    }

    return isMemberExpression(node) && isOrHasCallExpression(node.object);
  }

  function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    var linesInfo = find(expandedWhitespaceNodes, node, parent);

    if (!linesInfo) {
      var items = find(expandedWhitespaceList, node, parent);

      if (items) {
        for (var i = 0; i < items.length; i++) {
          linesInfo = needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    if (typeof linesInfo === "object" && linesInfo !== null) {
      return linesInfo[type] || 0;
    }

    return 0;
  }
  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, "before");
  }
  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, "after");
  }
  function needsParens(node, parent, printStack) {
    if (!parent) return false;

    if (isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }

    return find(expandedParens, node, parent, printStack);
  }

  function TaggedTemplateExpression(node) {
    this.print(node.tag, node);
    this.print(node.typeParameters, node);
    this.print(node.quasi, node);
  }
  function TemplateElement(node, parent) {
    var isFirst = parent.quasis[0] === node;
    var isLast = parent.quasis[parent.quasis.length - 1] === node;
    var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    this.token(value);
  }
  function TemplateLiteral(node) {
    var quasis = node.quasis;

    for (var i = 0; i < quasis.length; i++) {
      this.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        this.print(node.expressions[i], node);
      }
    }
  }

  function UnaryExpression(node) {
    if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
      this.word(node.operator);
      this.space();
    } else {
      this.token(node.operator);
    }

    this.print(node.argument, node);
  }
  function DoExpression$1(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
  }
  function ParenthesizedExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.token(")");
  }
  function UpdateExpression$1(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument, node);
    } else {
      this.startTerminatorless(true);
      this.print(node.argument, node);
      this.endTerminatorless();
      this.token(node.operator);
    }
  }
  function ConditionalExpression$1(node) {
    this.print(node.test, node);
    this.space();
    this.token("?");
    this.space();
    this.print(node.consequent, node);
    this.space();
    this.token(":");
    this.space();
    this.print(node.alternate, node);
  }
  function NewExpression(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee, node);

    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
      callee: node
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }

    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function SequenceExpression$1(node) {
    this.printList(node.expressions, node);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function Decorator(node) {
    this.token("@");
    this.print(node.expression, node);
    this.newline();
  }
  function OptionalMemberExpression$1(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (node.optional) {
      this.token("?.");
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      if (!node.optional) {
        this.token(".");
      }

      this.print(node.property, node);
    }
  }
  function OptionalCallExpression(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function CallExpression(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function Import() {
    this.word("import");
  }

  function buildYieldAwait(keyword) {
    return function (node) {
      this.word(keyword);

      if (node.delegate) {
        this.token("*");
      }

      if (node.argument) {
        this.space();
        var terminatorState = this.startTerminatorless();
        this.print(node.argument, node);
        this.endTerminatorless(terminatorState);
      }
    };
  }

  var YieldExpression$1 = buildYieldAwait("yield");
  var AwaitExpression = buildYieldAwait("await");
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node) {
    this.print(node.expression, node);
    this.semicolon();
  }
  function AssignmentPattern(node) {
    this.print(node.left, node);
    if (node.left.optional) this.token("?");
    this.print(node.left.typeAnnotation, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
  }
  function AssignmentExpression$1(node, parent) {
    var parens = this.inForStatementInitCounter && node.operator === "in" && !needsParens(node, parent);

    if (parens) {
      this.token("(");
    }

    this.print(node.left, node);
    this.space();

    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
    }

    this.space();
    this.print(node.right, node);

    if (parens) {
      this.token(")");
    }
  }
  function BindExpression(node) {
    this.print(node.object, node);
    this.token("::");
    this.print(node.callee, node);
  }
  function MemberExpression(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      this.token(".");
      this.print(node.property, node);
    }
  }
  function MetaProperty(node) {
    this.print(node.meta, node);
    this.token(".");
    this.print(node.property, node);
  }
  function PrivateName(node) {
    this.token("#");
    this.print(node.id, node);
  }
  function V8IntrinsicIdentifier(node) {
    this.token("%");
    this.word(node.name);
  }

  function WithStatement(node) {
    this.word("with");
    this.space();
    this.token("(");
    this.print(node.object, node);
    this.token(")");
    this.printBlock(node);
  }
  function IfStatement(node) {
    this.word("if");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.space();
    var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));

    if (needsBlock) {
      this.token("{");
      this.newline();
      this.indent();
    }

    this.printAndIndentOnComments(node.consequent, node);

    if (needsBlock) {
      this.dedent();
      this.newline();
      this.token("}");
    }

    if (node.alternate) {
      if (this.endsWith("}")) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate, node);
    }
  }

  function getLastStatement(statement) {
    if (!isStatement(statement.body)) return statement;
    return getLastStatement(statement.body);
  }

  function ForStatement(node) {
    this.word("for");
    this.space();
    this.token("(");
    this.inForStatementInitCounter++;
    this.print(node.init, node);
    this.inForStatementInitCounter--;
    this.token(";");

    if (node.test) {
      this.space();
      this.print(node.test, node);
    }

    this.token(";");

    if (node.update) {
      this.space();
      this.print(node.update, node);
    }

    this.token(")");
    this.printBlock(node);
  }
  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.printBlock(node);
  }

  var buildForXStatement = function buildForXStatement(op) {
    return function (node) {
      this.word("for");
      this.space();

      if (op === "of" && node["await"]) {
        this.word("await");
        this.space();
      }

      this.token("(");
      this.print(node.left, node);
      this.space();
      this.word(op);
      this.space();
      this.print(node.right, node);
      this.token(")");
      this.printBlock(node);
    };
  };

  var ForInStatement = buildForXStatement("in");
  var ForOfStatement = buildForXStatement("of");
  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
    this.space();
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.semicolon();
  }

  function buildLabelStatement(prefix, key) {
    if (key === void 0) {
      key = "label";
    }

    return function (node) {
      this.word(prefix);
      var label = node[key];

      if (label) {
        this.space();
        var isLabel = key == "label";
        var terminatorState = this.startTerminatorless(isLabel);
        this.print(label, node);
        this.endTerminatorless(terminatorState);
      }

      this.semicolon();
    };
  }

  var ContinueStatement = buildLabelStatement("continue");
  var ReturnStatement = buildLabelStatement("return", "argument");
  var BreakStatement = buildLabelStatement("break");
  var ThrowStatement = buildLabelStatement("throw", "argument");
  function LabeledStatement(node) {
    this.print(node.label, node);
    this.token(":");
    this.space();
    this.print(node.body, node);
  }
  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block, node);
    this.space();

    if (node.handlers) {
      this.print(node.handlers[0], node);
    } else {
      this.print(node.handler, node);
    }

    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer, node);
    }
  }
  function CatchClause(node) {
    this.word("catch");
    this.space();

    if (node.param) {
      this.token("(");
      this.print(node.param, node);
      this.print(node.param.typeAnnotation, node);
      this.token(")");
      this.space();
    }

    this.print(node.body, node);
  }
  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.token("(");
    this.print(node.discriminant, node);
    this.token(")");
    this.space();
    this.token("{");
    this.printSequence(node.cases, node, {
      indent: true,
      addNewlines: function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      }
    });
    this.token("}");
  }
  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test, node);
      this.token(":");
    } else {
      this.word("default");
      this.token(":");
    }

    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, node, {
        indent: true
      });
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }

  function variableDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
      this.space(true);
    }
  }

  function constDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
      this.space(true);
    }
  }

  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this.word(node.kind);
    this.space();
    var hasInits = false;

    if (!isFor(parent)) {
      for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
        var declar = _arr[_i];

        if (declar.init) {
          hasInits = true;
        }
      }
    }

    var separator;

    if (hasInits) {
      separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
    }

    this.printList(node.declarations, node, {
      separator: separator
    });

    if (isFor(parent)) {
      if (parent.left === node || parent.init === node) return;
    }

    this.semicolon();
  }
  function VariableDeclarator(node) {
    this.print(node.id, node);
    if (node.definite) this.token("!");
    this.print(node.id.typeAnnotation, node);

    if (node.init) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.init, node);
    }
  }

  function ClassDeclaration(node, parent) {
    if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
      this.printJoin(node.decorators, node);
    }

    if (node.declare) {
      this.word("declare");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    this.word("class");

    if (node.id) {
      this.space();
      this.print(node.id, node);
    }

    this.print(node.typeParameters, node);

    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass, node);
      this.print(node.superTypeParameters, node);
    }

    if (node["implements"]) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function ClassBody(node) {
    this.token("{");
    this.printInnerComments(node);

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.indent();
      this.printSequence(node.body, node);
      this.dedent();
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    }
  }
  function ClassProperty(node) {
    this.printJoin(node.decorators, node);
    this.tsPrintClassMemberModifiers(node, true);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      this._variance(node);

      this.print(node.key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    if (node.definite) {
      this.token("!");
    }

    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators, node);

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.key, node);
    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ClassPrivateMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators, node);
    this.tsPrintClassMemberModifiers(node, false);

    this._methodHead(node);
  }
  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.token("{");

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.rightBrace();
    }
  }

  function _params(node) {
    this.print(node.typeParameters, node);
    this.token("(");

    this._parameters(node.params, node);

    this.token(")");
    this.print(node.returnType, node);
  }
  function _parameters(parameters, parent) {
    for (var i = 0; i < parameters.length; i++) {
      this._param(parameters[i], parent);

      if (i < parameters.length - 1) {
        this.token(",");
        this.space();
      }
    }
  }
  function _param(parameter, parent) {
    this.printJoin(parameter.decorators, parameter);
    this.print(parameter, parent);
    if (parameter.optional) this.token("?");
    this.print(parameter.typeAnnotation, parameter);
  }
  function _methodHead(node) {
    var kind = node.kind;
    var key = node.key;

    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }

    if (node.async) {
      this._catchUp("start", key.loc);

      this.word("async");
      this.space();
    }

    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.token("*");
      }
    }

    if (node.computed) {
      this.token("[");
      this.print(key, node);
      this.token("]");
    } else {
      this.print(key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    this._params(node);
  }
  function _predicate(node) {
    if (node.predicate) {
      if (!node.returnType) {
        this.token(":");
      }

      this.space();
      this.print(node.predicate, node);
    }
  }
  function _functionHead(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("function");
    if (node.generator) this.token("*");
    this.space();

    if (node.id) {
      this.print(node.id, node);
    }

    this._params(node);

    this._predicate(node);
  }
  function FunctionExpression$1(node) {
    this._functionHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ArrowFunctionExpression$1(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    var firstParam = node.params[0];

    if (node.params.length === 1 && isIdentifier(firstParam) && !hasTypes(node, firstParam)) {
      if ((this.format.retainLines || node.async) && node.loc && node.body.loc && node.loc.start.line < node.body.loc.start.line) {
        this.token("(");

        if (firstParam.loc && firstParam.loc.start.line > node.loc.start.line) {
          this.indent();
          this.print(firstParam, node);
          this.dedent();

          this._catchUp("start", node.body.loc);
        } else {
          this.print(firstParam, node);
        }

        this.token(")");
      } else {
        this.print(firstParam, node);
      }
    } else {
      this._params(node);
    }

    this._predicate(node);

    this.space();
    this.token("=>");
    this.space();
    this.print(node.body, node);
  }

  function hasTypes(node, param) {
    return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;
  }

  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    this.print(node.imported, node);

    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
  }
  function ImportDefaultSpecifier(node) {
    this.print(node.local, node);
  }
  function ExportDefaultSpecifier(node) {
    this.print(node.exported, node);
  }
  function ExportSpecifier(node) {
    this.print(node.local, node);

    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
  }
  function ExportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
  function ExportAllDeclaration(node) {
    this.word("export");
    this.space();

    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    this.token("*");
    this.space();
    this.word("from");
    this.space();
    this.print(node.source, node);
    this.printAssertions(node);
    this.semicolon();
  }
  function ExportNamedDeclaration(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }
  function ExportDefaultDeclaration(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    this.word("default");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }

      var specifiers = node.specifiers.slice(0);
      var hasSpecial = false;

      for (;;) {
        var first = specifiers[0];

        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        this.token("{");

        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node);
          this.space();
        }

        this.token("}");
      }

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
        this.printAssertions(node);
      }

      this.semicolon();
    }
  }

  function ImportDeclaration(node) {
    var _node$attributes;

    this.word("import");
    this.space();

    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    var specifiers = node.specifiers.slice(0);

    if (specifiers == null ? void 0 : specifiers.length) {
      for (;;) {
        var first = specifiers[0];

        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length) {
        this.token("{");
        this.space();
        this.printList(specifiers, node);
        this.space();
        this.token("}");
      }

      this.space();
      this.word("from");
      this.space();
    }

    this.print(node.source, node);
    this.printAssertions(node);

    if ((_node$attributes = node.attributes) == null ? void 0 : _node$attributes.length) {
      this.space();
      this.word("with");
      this.space();
      this.printList(node.attributes, node);
    }

    this.semicolon();
  }
  function ImportAttribute(node) {
    this.print(node.key);
    this.token(":");
    this.space();
    this.print(node.value);
  }
  function ImportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }

  var object = {};
  var hasOwnProperty$b = object.hasOwnProperty;

  var forOwn = function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty$b.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };

  var extend = function extend(destination, source) {
    if (!source) {
      return destination;
    }

    forOwn(source, function (key, value) {
      destination[key] = value;
    });
    return destination;
  };

  var forEach = function forEach(array, callback) {
    var length = array.length;
    var index = -1;

    while (++index < length) {
      callback(array[index]);
    }
  };

  var toString = object.toString;
  var isArray$1 = Array.isArray;
  var isBuffer = Buffer.isBuffer;

  var isObject$1 = function isObject(value) {
    return toString.call(value) == '[object Object]';
  };

  var isString = function isString(value) {
    return typeof value == 'string' || toString.call(value) == '[object String]';
  };

  var isNumber = function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == '[object Number]';
  };

  var isFunction$2 = function isFunction(value) {
    return typeof value == 'function';
  };

  var isMap$1 = function isMap(value) {
    return toString.call(value) == '[object Map]';
  };

  var isSet$1 = function isSet(value) {
    return toString.call(value) == '[object Set]';
  };

  var singleEscapes = {
    '"': '\\"',
    '\'': '\\\'',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
  };
  var regexSingleEscape = /["'\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

  var jsesc = function jsesc(argument, options) {
    var increaseIndentation = function increaseIndentation() {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };

    var defaults = {
      'escapeEverything': false,
      'minimal': false,
      'isScriptContext': false,
      'quotes': 'single',
      'wrap': false,
      'es6': false,
      'json': false,
      'compact': true,
      'lowercaseHex': false,
      'numbers': 'decimal',
      'indent': '\t',
      'indentLevel': 0,
      '__inline1__': false,
      '__inline2__': false
    };
    var json = options && options.json;

    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }

    options = extend(defaults, options);

    if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
      options.quotes = 'single';
    }

    var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
    var compact = options.compact;
    var lowercaseHex = options.lowercaseHex;
    var indent = options.indent.repeat(options.indentLevel);
    var oldIndent = '';
    var inline1 = options.__inline1__;
    var inline2 = options.__inline2__;
    var newLine = compact ? '' : '\n';
    var result;
    var isEmpty = true;
    var useBinNumbers = options.numbers == 'binary';
    var useOctNumbers = options.numbers == 'octal';
    var useDecNumbers = options.numbers == 'decimal';
    var useHexNumbers = options.numbers == 'hexadecimal';

    if (json && argument && isFunction$2(argument.toJSON)) {
      argument = argument.toJSON();
    }

    if (!isString(argument)) {
      if (isMap$1(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }

        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }

        return 'new Map(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isSet$1(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }

        return 'new Set(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }

        return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isArray$1(argument)) {
        result = [];
        options.wrap = true;

        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }

        if (!inline2) {
          increaseIndentation();
        }

        forEach(argument, function (value) {
          isEmpty = false;

          if (inline2) {
            options.__inline2__ = false;
          }

          result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
        });

        if (isEmpty) {
          return '[]';
        }

        if (inline2) {
          return '[' + result.join(', ') + ']';
        }

        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }

        if (useDecNumbers) {
          return String(argument);
        }

        if (useHexNumbers) {
          var hexadecimal = argument.toString(16);

          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }

          return '0x' + hexadecimal;
        }

        if (useBinNumbers) {
          return '0b' + argument.toString(2);
        }

        if (useOctNumbers) {
          return '0o' + argument.toString(8);
        }
      } else if (!isObject$1(argument)) {
        if (json) {
          return JSON.stringify(argument) || 'null';
        }

        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, function (key, value) {
          isEmpty = false;
          result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
        });

        if (isEmpty) {
          return '{}';
        }

        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
      }
    }

    var string = argument;
    var index = -1;
    var length = string.length;
    result = '';

    while (++index < length) {
      var character = string.charAt(index);

      if (options.es6) {
        var first = string.charCodeAt(index);

        if (first >= 0xD800 && first <= 0xDBFF && length > index + 1) {
            var second = string.charCodeAt(index + 1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

              var _hexadecimal2 = codePoint.toString(16);

              if (!lowercaseHex) {
                _hexadecimal2 = _hexadecimal2.toUpperCase();
              }

              result += "\\u{" + _hexadecimal2 + '}';
              ++index;
              continue;
            }
          }
      }

      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }

        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }

        if (character == '`') {
          result += quote == character ? '\\`' : character;
          continue;
        }

        if (character == '\'') {
          result += quote == character ? '\\\'' : character;
          continue;
        }
      }

      if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
        result += '\\0';
        continue;
      }

      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }

      var charCode = character.charCodeAt(0);

      if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
        result += character;
        continue;
      }

      var _hexadecimal = charCode.toString(16);

      if (!lowercaseHex) {
        _hexadecimal = _hexadecimal.toUpperCase();
      }

      var longhand = _hexadecimal.length > 2 || json;

      var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

      result += escaped;
      continue;
    }

    if (options.wrap) {
      result = quote + result + quote;
    }

    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\\$\{');
    }

    if (options.isScriptContext) {
      return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
    }

    return result;
  };

  jsesc.version = '2.5.2';
  var jsesc_1 = jsesc;

  function Identifier(node) {
    var _this = this;

    this.exactSource(node.loc, function () {
      _this.word(node.name);
    });
  }
  function ArgumentPlaceholder() {
    this.token("?");
  }
  function RestElement(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function ObjectExpression$1(node) {
    var props = node.properties;
    this.token("{");
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token("}");
  }
  function ObjectMethod(node) {
    this.printJoin(node.decorators, node);

    this._methodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ObjectProperty(node) {
    this.printJoin(node.decorators, node);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value, node);
        return;
      }

      this.print(node.key, node);

      if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }

    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ArrayExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    this.token("[");
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      } else {
        this.token(",");
      }
    }

    this.token("]");
  }
  function RecordExpression(node) {
    var props = node.properties;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "{|";
      endToken = "|}";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#{";
      endToken = "}";
    } else {
      throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
    }

    this.token(startToken);
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token(endToken);
  }
  function TupleExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "[|";
      endToken = "|]";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#[";
      endToken = "]";
    } else {
      throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
    }

    this.token(startToken);
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      }
    }

    this.token(endToken);
  }
  function RegExpLiteral(node) {
    this.word("/" + node.pattern + "/" + node.flags);
  }
  function BooleanLiteral(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral() {
    this.word("null");
  }
  function NumericLiteral(node) {
    var raw = this.getPossibleRaw(node);
    var opts = this.format.jsescOption;
    var value = node.value + "";

    if (opts.numbers) {
      this.number(jsesc_1(node.value, opts));
    } else if (raw == null) {
      this.number(value);
    } else if (this.format.minified) {
      this.number(raw.length < value.length ? raw : value);
    } else {
      this.number(raw);
    }
  }
  function StringLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    var val = jsesc_1(node.value, process.env.BABEL_8_BREAKING ? this.format.jsescOption : Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
      json: true
    }));
    return this.token(val);
  }
  function BigIntLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "n");
  }
  function DecimalLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "m");
  }
  function PipelineTopicExpression(node) {
    this.print(node.expression, node);
  }
  function PipelineBareFunction(node) {
    this.print(node.callee, node);
  }
  function PipelinePrimaryTopicReference() {
    this.token("#");
  }

  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("class");
    this.space();

    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);

    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }

    this.semicolon();
  }
  function InferredPredicate() {
    this.token("%");
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();

    if (node["default"]) {
      this.word("default");
      this.space();
    }

    FlowExportDeclaration.apply(this, arguments);
  }
  function DeclareExportAllDeclaration() {
    this.word("declare");
    this.space();
    ExportAllDeclaration.apply(this, arguments);
  }
  function EnumDeclaration(node) {
    var id = node.id,
        body = node.body;
    this.word("enum");
    this.space();
    this.print(id, node);
    this.print(body, node);
  }

  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }

    context.space();
  }

  function enumBody(context, node) {
    var members = node.members;
    context.token("{");
    context.indent();
    context.newline();

    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      context.print(member, node);
      context.newline();
    }

    context.dedent();
    context.token("}");
  }

  function EnumBooleanBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }
  function EnumNumberBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }
  function EnumStringBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }
  function EnumSymbolBody(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }
  function EnumDefaultedMember(node) {
    var id = node.id;
    this.print(id, node);
    this.token(",");
  }

  function enumInitializedMember(context, node) {
    var id = node.id,
        init = node.init;
    context.print(id, node);
    context.space();
    context.token("=");
    context.space();
    context.print(init, node);
    context.token(",");
  }

  function EnumBooleanMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumNumberMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumStringMember(node) {
    enumInitializedMember(this, node);
  }

  function FlowExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      this.token("{");

      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }

      this.token("}");

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }

      this.semicolon();
    }
  }

  function ExistsTypeAnnotation() {
    this.token("*");
  }
  function FunctionTypeAnnotation$1(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.params, node);

    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }

      this.token("...");
      this.print(node.rest, node);
    }

    this.token(")");

    if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }

    this.space();
    this.print(node.returnType, node);
  }
  function FunctionTypeParam(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");

    if (node.name) {
      this.token(":");
      this.space();
    }

    this.print(node.typeAnnotation, node);
  }
  function InterfaceExtends(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }
  function _interfaceish(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node["extends"].length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }

    if (node["implements"] && node["implements"].length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();

    this._interfaceish(node);
  }

  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }

  function InterfaceTypeAnnotation(node) {
    this.word("interface");

    if (node["extends"] && node["extends"].length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, node, {
      separator: andSeparator
    });
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation$1(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }
  function TypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TypeParameter(node) {
    this._variance(node);

    this.word(node.name);

    if (node.bound) {
      this.print(node.bound, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }

    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }

    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    var _this = this;

    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }

    var props = node.properties.concat(node.callProperties || [], node.indexers || [], node.internalSlots || []);

    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines: function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },
        indent: true,
        statement: true,
        iterator: function iterator() {
          if (props.length !== 1 || node.inexact) {
            _this.token(",");

            _this.space();
          }
        }
      });
      this.space();
    }

    if (node.inexact) {
      this.indent();
      this.token("...");

      if (props.length) {
        this.newline();
      }

      this.dedent();
    }

    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeCallProperty(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeIndexer(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this._variance(node);

    this.token("[");

    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }

    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    if (node.kind === "get" || node.kind === "set") {
      this.word(node.kind);
      this.space();
    }

    this._variance(node);

    this.print(node.key, node);
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }
  function SymbolTypeAnnotation() {
    this.word("symbol");
  }

  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }

  function UnionTypeAnnotation$1(node) {
    this.printJoin(node.types, node, {
      separator: orSeparator
    });
  }
  function TypeCastExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }

  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }
  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
  function BlockStatement(node) {
    var _node$directives;

    this.token("{");
    this.printInnerComments(node);
    var hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;

    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, {
        indent: true
      });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }
  function Noop() {}
  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
      return;
    }

    var value = node.value;

    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token("\"" + value + "\"");
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token("'" + value + "'");
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node) {
    this.token("#!" + node.value + "\n");
  }
  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");

    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }

  function JSXAttribute(node) {
    this.print(node.name, node);

    if (node.value) {
      this.token("=");
      this.print(node.value, node);
    }
  }
  function JSXIdentifier(node) {
    this.word(node.name);
  }
  function JSXNamespacedName(node) {
    this.print(node.namespace, node);
    this.token(":");
    this.print(node.name, node);
  }
  function JSXMemberExpression(node) {
    this.print(node.object, node);
    this.token(".");
    this.print(node.property, node);
  }
  function JSXSpreadAttribute(node) {
    this.token("{");
    this.token("...");
    this.print(node.argument, node);
    this.token("}");
  }
  function JSXExpressionContainer(node) {
    this.token("{");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXSpreadChild(node) {
    this.token("{");
    this.token("...");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXText(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
    } else {
      this.token(node.value);
    }
  }
  function JSXElement(node) {
    var open = node.openingElement;
    this.print(open, node);
    if (open.selfClosing) return;
    this.indent();

    for (var _i = 0, _arr = node.children; _i < _arr.length; _i++) {
      var child = _arr[_i];
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingElement, node);
  }

  function spaceSeparator() {
    this.space();
  }

  function JSXOpeningElement(node) {
    this.token("<");
    this.print(node.name, node);
    this.print(node.typeParameters, node);

    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, node, {
        separator: spaceSeparator
      });
    }

    if (node.selfClosing) {
      this.space();
      this.token("/>");
    } else {
      this.token(">");
    }
  }
  function JSXClosingElement(node) {
    this.token("</");
    this.print(node.name, node);
    this.token(">");
  }
  function JSXEmptyExpression(node) {
    this.printInnerComments(node);
  }
  function JSXFragment(node) {
    this.print(node.openingFragment, node);
    this.indent();

    for (var _i2 = 0, _arr2 = node.children; _i2 < _arr2.length; _i2++) {
      var child = _arr2[_i2];
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingFragment, node);
  }
  function JSXOpeningFragment() {
    this.token("<");
    this.token(">");
  }
  function JSXClosingFragment() {
    this.token("</");
    this.token(">");
  }

  function TSTypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TSTypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TSTypeParameter(node) {
    this.word(node.name);

    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node.readonly) {
      this.word("readonly");
      this.space();
    }

    this._param(node.parameter);
  }
  function TSDeclareFunction(node) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this._functionHead(node);

    this.token(";");
  }
  function TSDeclareMethod(node) {
    this._classMethodHead(node);

    this.token(";");
  }
  function TSQualifiedName(node) {
    this.print(node.left, node);
    this.token(".");
    this.print(node.right, node);
  }
  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSPropertySignature(node) {
    var readonly = node.readonly,
        initializer = node.initializer;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(";");
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.token("[");
    }

    this.print(node.key, node);

    if (node.computed) {
      this.token("]");
    }

    if (node.optional) {
      this.token("?");
    }
  }
  function TSMethodSignature(node) {
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSIndexSignature(node) {
    var readonly = node.readonly;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.token("[");

    this._parameters(node.parameters, node);

    this.token("]");
    this.print(node.typeAnnotation, node);
    this.token(";");
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType(node) {
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.space();
    this.token("=>");
    this.space();
    this.print(node.typeAnnotation.typeAnnotation, node);
  }
  function TSTypeReference(node) {
    this.print(node.typeName, node);
    this.print(node.typeParameters, node);
  }
  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }

    this.print(node.parameterName);

    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
  }
  function TSTypeLiteral(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
  }
  function tsPrintTypeLiteralOrInterfaceBody(members, node) {
    this.tsPrintBraced(members, node);
  }
  function tsPrintBraced(members, node) {
    this.token("{");

    if (members.length) {
      this.indent();
      this.newline();

      for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
        var member = _step.value;
        this.print(member, node);
        this.newline();
      }

      this.dedent();
      this.rightBrace();
    } else {
      this.token("}");
    }
  }
  function TSArrayType(node) {
    this.print(node.elementType, node);
    this.token("[]");
  }
  function TSTupleType(node) {
    this.token("[");
    this.printList(node.elementTypes, node);
    this.token("]");
  }
  function TSOptionalType(node) {
    this.print(node.typeAnnotation, node);
    this.token("?");
  }
  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation, node);
  }
  function TSNamedTupleMember(node) {
    this.print(node.label, node);
    if (node.optional) this.token("?");
    this.token(":");
    this.space();
    this.print(node.elementType, node);
  }
  function TSUnionType$1(node) {
    this.tsPrintUnionOrIntersectionType(node, "|");
  }
  function TSIntersectionType(node) {
    this.tsPrintUnionOrIntersectionType(node, "&");
  }
  function tsPrintUnionOrIntersectionType(node, sep) {
    this.printJoin(node.types, node, {
      separator: function separator() {
        this.space();
        this.token(sep);
        this.space();
      }
    });
  }
  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.token("?");
    this.space();
    this.print(node.trueType);
    this.space();
    this.token(":");
    this.space();
    this.print(node.falseType);
  }
  function TSInferType$1(node) {
    this.token("infer");
    this.space();
    this.print(node.typeParameter);
  }
  function TSParenthesizedType(node) {
    this.token("(");
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation, node);
  }
  function TSIndexedAccessType(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }
  function TSMappedType(node) {
    var nameType = node.nameType,
        optional = node.optional,
        readonly = node.readonly,
        typeParameter = node.typeParameter;
    this.token("{");
    this.space();

    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }

    this.token("[");
    this.word(typeParameter.name);
    this.space();
    this.word("in");
    this.space();
    this.print(typeParameter.constraint, typeParameter);

    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType, node);
    }

    this.token("]");

    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.token("?");
    }

    this.token(":");
    this.space();
    this.print(node.typeAnnotation, node);
    this.space();
    this.token("}");
  }

  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }

  function TSLiteralType(node) {
    this.print(node.literal, node);
  }
  function TSExpressionWithTypeArguments(node) {
    this.print(node.expression, node);
    this.print(node.typeParameters, node);
  }
  function TSInterfaceDeclaration(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        extendz = node["extends"],
        body = node.body;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("interface");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);

    if (extendz) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz, node);
    }

    this.space();
    this.print(body, node);
  }
  function TSInterfaceBody(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
  }
  function TSTypeAliasDeclaration(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        typeAnnotation = node.typeAnnotation;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("type");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(typeAnnotation, node);
    this.token(";");
  }
  function TSAsExpression$1(node) {
    var expression = node.expression,
        typeAnnotation = node.typeAnnotation;
    this.print(expression, node);
    this.space();
    this.word("as");
    this.space();
    this.print(typeAnnotation, node);
  }
  function TSTypeAssertion$1(node) {
    var typeAnnotation = node.typeAnnotation,
        expression = node.expression;
    this.token("<");
    this.print(typeAnnotation, node);
    this.token(">");
    this.space();
    this.print(expression, node);
  }
  function TSEnumDeclaration(node) {
    var declare = node.declare,
        isConst = node["const"],
        id = node.id,
        members = node.members;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (isConst) {
      this.word("const");
      this.space();
    }

    this.word("enum");
    this.space();
    this.print(id, node);
    this.space();
    this.tsPrintBraced(members, node);
  }
  function TSEnumMember(node) {
    var id = node.id,
        initializer = node.initializer;
    this.print(id, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(",");
  }
  function TSModuleDeclaration(node) {
    var declare = node.declare,
        id = node.id;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (!node.global) {
      this.word(id.type === "Identifier" ? "namespace" : "module");
      this.space();
    }

    this.print(id, node);

    if (!node.body) {
      this.token(";");
      return;
    }

    var body = node.body;

    while (body.type === "TSModuleDeclaration") {
      this.token(".");
      this.print(body.id, body);
      body = body.body;
    }

    this.space();
    this.print(body, node);
  }
  function TSModuleBlock(node) {
    this.tsPrintBraced(node.body, node);
  }
  function TSImportType(node) {
    var argument = node.argument,
        qualifier = node.qualifier,
        typeParameters = node.typeParameters;
    this.word("import");
    this.token("(");
    this.print(argument, node);
    this.token(")");

    if (qualifier) {
      this.token(".");
      this.print(qualifier, node);
    }

    if (typeParameters) {
      this.print(typeParameters, node);
    }
  }
  function TSImportEqualsDeclaration(node) {
    var isExport = node.isExport,
        id = node.id,
        moduleReference = node.moduleReference;

    if (isExport) {
      this.word("export");
      this.space();
    }

    this.word("import");
    this.space();
    this.print(id, node);
    this.space();
    this.token("=");
    this.space();
    this.print(moduleReference, node);
    this.token(";");
  }
  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression, node);
    this.token(")");
  }
  function TSNonNullExpression(node) {
    this.print(node.expression, node);
    this.token("!");
  }
  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.token("=");
    this.space();
    this.print(node.expression, node);
    this.token(";");
  }
  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id, node);
  }
  function tsPrintSignatureDeclarationBase(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.print(node.typeAnnotation, node);
  }
  function tsPrintClassMemberModifiers(node, isField) {
    if (isField && node.declare) {
      this.word("declare");
      this.space();
    }

    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    if (isField && node.readonly) {
      this.word("readonly");
      this.space();
    }
  }

  var generatorFunctions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TaggedTemplateExpression: TaggedTemplateExpression,
    TemplateElement: TemplateElement,
    TemplateLiteral: TemplateLiteral,
    UnaryExpression: UnaryExpression,
    DoExpression: DoExpression$1,
    ParenthesizedExpression: ParenthesizedExpression,
    UpdateExpression: UpdateExpression$1,
    ConditionalExpression: ConditionalExpression$1,
    NewExpression: NewExpression,
    SequenceExpression: SequenceExpression$1,
    ThisExpression: ThisExpression,
    Super: Super,
    Decorator: Decorator,
    OptionalMemberExpression: OptionalMemberExpression$1,
    OptionalCallExpression: OptionalCallExpression,
    CallExpression: CallExpression,
    Import: Import,
    YieldExpression: YieldExpression$1,
    AwaitExpression: AwaitExpression,
    EmptyStatement: EmptyStatement,
    ExpressionStatement: ExpressionStatement,
    AssignmentPattern: AssignmentPattern,
    AssignmentExpression: AssignmentExpression$1,
    BindExpression: BindExpression,
    BinaryExpression: AssignmentExpression$1,
    LogicalExpression: AssignmentExpression$1,
    MemberExpression: MemberExpression,
    MetaProperty: MetaProperty,
    PrivateName: PrivateName,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier,
    WithStatement: WithStatement,
    IfStatement: IfStatement,
    ForStatement: ForStatement,
    WhileStatement: WhileStatement,
    ForInStatement: ForInStatement,
    ForOfStatement: ForOfStatement,
    DoWhileStatement: DoWhileStatement,
    ContinueStatement: ContinueStatement,
    ReturnStatement: ReturnStatement,
    BreakStatement: BreakStatement,
    ThrowStatement: ThrowStatement,
    LabeledStatement: LabeledStatement,
    TryStatement: TryStatement,
    CatchClause: CatchClause,
    SwitchStatement: SwitchStatement,
    SwitchCase: SwitchCase,
    DebuggerStatement: DebuggerStatement,
    VariableDeclaration: VariableDeclaration,
    VariableDeclarator: VariableDeclarator,
    ClassDeclaration: ClassDeclaration,
    ClassExpression: ClassDeclaration,
    ClassBody: ClassBody,
    ClassProperty: ClassProperty,
    ClassPrivateProperty: ClassPrivateProperty,
    ClassMethod: ClassMethod,
    ClassPrivateMethod: ClassPrivateMethod,
    _classMethodHead: _classMethodHead,
    StaticBlock: StaticBlock,
    _params: _params,
    _parameters: _parameters,
    _param: _param,
    _methodHead: _methodHead,
    _predicate: _predicate,
    _functionHead: _functionHead,
    FunctionExpression: FunctionExpression$1,
    FunctionDeclaration: FunctionExpression$1,
    ArrowFunctionExpression: ArrowFunctionExpression$1,
    ImportSpecifier: ImportSpecifier,
    ImportDefaultSpecifier: ImportDefaultSpecifier,
    ExportDefaultSpecifier: ExportDefaultSpecifier,
    ExportSpecifier: ExportSpecifier,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier,
    ExportAllDeclaration: ExportAllDeclaration,
    ExportNamedDeclaration: ExportNamedDeclaration,
    ExportDefaultDeclaration: ExportDefaultDeclaration,
    ImportDeclaration: ImportDeclaration,
    ImportAttribute: ImportAttribute,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier,
    Identifier: Identifier,
    ArgumentPlaceholder: ArgumentPlaceholder,
    RestElement: RestElement,
    SpreadElement: RestElement,
    ObjectExpression: ObjectExpression$1,
    ObjectPattern: ObjectExpression$1,
    ObjectMethod: ObjectMethod,
    ObjectProperty: ObjectProperty,
    ArrayExpression: ArrayExpression,
    ArrayPattern: ArrayExpression,
    RecordExpression: RecordExpression,
    TupleExpression: TupleExpression,
    RegExpLiteral: RegExpLiteral,
    BooleanLiteral: BooleanLiteral,
    NullLiteral: NullLiteral,
    NumericLiteral: NumericLiteral,
    StringLiteral: StringLiteral,
    BigIntLiteral: BigIntLiteral,
    DecimalLiteral: DecimalLiteral,
    PipelineTopicExpression: PipelineTopicExpression,
    PipelineBareFunction: PipelineBareFunction,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
    NumberLiteralTypeAnnotation: NumericLiteral,
    StringLiteralTypeAnnotation: StringLiteral,
    AnyTypeAnnotation: AnyTypeAnnotation,
    ArrayTypeAnnotation: ArrayTypeAnnotation,
    BooleanTypeAnnotation: BooleanTypeAnnotation,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
    DeclareClass: DeclareClass,
    DeclareFunction: DeclareFunction,
    InferredPredicate: InferredPredicate,
    DeclaredPredicate: DeclaredPredicate,
    DeclareInterface: DeclareInterface,
    DeclareModule: DeclareModule,
    DeclareModuleExports: DeclareModuleExports,
    DeclareTypeAlias: DeclareTypeAlias,
    DeclareOpaqueType: DeclareOpaqueType,
    DeclareVariable: DeclareVariable,
    DeclareExportDeclaration: DeclareExportDeclaration,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration,
    EnumDeclaration: EnumDeclaration,
    EnumBooleanBody: EnumBooleanBody,
    EnumNumberBody: EnumNumberBody,
    EnumStringBody: EnumStringBody,
    EnumSymbolBody: EnumSymbolBody,
    EnumDefaultedMember: EnumDefaultedMember,
    EnumBooleanMember: EnumBooleanMember,
    EnumNumberMember: EnumNumberMember,
    EnumStringMember: EnumStringMember,
    ExistsTypeAnnotation: ExistsTypeAnnotation,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    FunctionTypeParam: FunctionTypeParam,
    InterfaceExtends: InterfaceExtends,
    ClassImplements: InterfaceExtends,
    GenericTypeAnnotation: InterfaceExtends,
    _interfaceish: _interfaceish,
    _variance: _variance,
    InterfaceDeclaration: InterfaceDeclaration,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation,
    MixedTypeAnnotation: MixedTypeAnnotation,
    EmptyTypeAnnotation: EmptyTypeAnnotation,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    NumberTypeAnnotation: NumberTypeAnnotation,
    StringTypeAnnotation: StringTypeAnnotation,
    ThisTypeAnnotation: ThisTypeAnnotation,
    TupleTypeAnnotation: TupleTypeAnnotation,
    TypeofTypeAnnotation: TypeofTypeAnnotation,
    TypeAlias: TypeAlias,
    TypeAnnotation: TypeAnnotation,
    TypeParameterInstantiation: TypeParameterInstantiation,
    TypeParameterDeclaration: TypeParameterInstantiation,
    TypeParameter: TypeParameter,
    OpaqueType: OpaqueType,
    ObjectTypeAnnotation: ObjectTypeAnnotation,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot,
    ObjectTypeCallProperty: ObjectTypeCallProperty,
    ObjectTypeIndexer: ObjectTypeIndexer,
    ObjectTypeProperty: ObjectTypeProperty,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier,
    SymbolTypeAnnotation: SymbolTypeAnnotation,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    TypeCastExpression: TypeCastExpression,
    Variance: Variance,
    VoidTypeAnnotation: VoidTypeAnnotation,
    File: File,
    Program: Program,
    BlockStatement: BlockStatement,
    Noop: Noop,
    Directive: Directive,
    DirectiveLiteral: DirectiveLiteral,
    InterpreterDirective: InterpreterDirective,
    Placeholder: Placeholder,
    JSXAttribute: JSXAttribute,
    JSXIdentifier: JSXIdentifier,
    JSXNamespacedName: JSXNamespacedName,
    JSXMemberExpression: JSXMemberExpression,
    JSXSpreadAttribute: JSXSpreadAttribute,
    JSXExpressionContainer: JSXExpressionContainer,
    JSXSpreadChild: JSXSpreadChild,
    JSXText: JSXText,
    JSXElement: JSXElement,
    JSXOpeningElement: JSXOpeningElement,
    JSXClosingElement: JSXClosingElement,
    JSXEmptyExpression: JSXEmptyExpression,
    JSXFragment: JSXFragment,
    JSXOpeningFragment: JSXOpeningFragment,
    JSXClosingFragment: JSXClosingFragment,
    TSTypeAnnotation: TSTypeAnnotation,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation,
    TSTypeParameterDeclaration: TSTypeParameterInstantiation,
    TSTypeParameter: TSTypeParameter,
    TSParameterProperty: TSParameterProperty,
    TSDeclareFunction: TSDeclareFunction,
    TSDeclareMethod: TSDeclareMethod,
    TSQualifiedName: TSQualifiedName,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
    TSPropertySignature: TSPropertySignature,
    tsPrintPropertyOrMethodName: tsPrintPropertyOrMethodName,
    TSMethodSignature: TSMethodSignature,
    TSIndexSignature: TSIndexSignature,
    TSAnyKeyword: TSAnyKeyword,
    TSBigIntKeyword: TSBigIntKeyword,
    TSUnknownKeyword: TSUnknownKeyword,
    TSNumberKeyword: TSNumberKeyword,
    TSObjectKeyword: TSObjectKeyword,
    TSBooleanKeyword: TSBooleanKeyword,
    TSStringKeyword: TSStringKeyword,
    TSSymbolKeyword: TSSymbolKeyword,
    TSVoidKeyword: TSVoidKeyword,
    TSUndefinedKeyword: TSUndefinedKeyword,
    TSNullKeyword: TSNullKeyword,
    TSNeverKeyword: TSNeverKeyword,
    TSIntrinsicKeyword: TSIntrinsicKeyword,
    TSThisType: TSThisType,
    TSFunctionType: TSFunctionType,
    TSConstructorType: TSConstructorType,
    tsPrintFunctionOrConstructorType: tsPrintFunctionOrConstructorType,
    TSTypeReference: TSTypeReference,
    TSTypePredicate: TSTypePredicate,
    TSTypeQuery: TSTypeQuery,
    TSTypeLiteral: TSTypeLiteral,
    tsPrintTypeLiteralOrInterfaceBody: tsPrintTypeLiteralOrInterfaceBody,
    tsPrintBraced: tsPrintBraced,
    TSArrayType: TSArrayType,
    TSTupleType: TSTupleType,
    TSOptionalType: TSOptionalType,
    TSRestType: TSRestType,
    TSNamedTupleMember: TSNamedTupleMember,
    TSUnionType: TSUnionType$1,
    TSIntersectionType: TSIntersectionType,
    tsPrintUnionOrIntersectionType: tsPrintUnionOrIntersectionType,
    TSConditionalType: TSConditionalType,
    TSInferType: TSInferType$1,
    TSParenthesizedType: TSParenthesizedType,
    TSTypeOperator: TSTypeOperator,
    TSIndexedAccessType: TSIndexedAccessType,
    TSMappedType: TSMappedType,
    TSLiteralType: TSLiteralType,
    TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    TSInterfaceDeclaration: TSInterfaceDeclaration,
    TSInterfaceBody: TSInterfaceBody,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration,
    TSAsExpression: TSAsExpression$1,
    TSTypeAssertion: TSTypeAssertion$1,
    TSEnumDeclaration: TSEnumDeclaration,
    TSEnumMember: TSEnumMember,
    TSModuleDeclaration: TSModuleDeclaration,
    TSModuleBlock: TSModuleBlock,
    TSImportType: TSImportType,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration,
    TSExternalModuleReference: TSExternalModuleReference,
    TSNonNullExpression: TSNonNullExpression,
    TSExportAssignment: TSExportAssignment,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
    tsPrintSignatureDeclarationBase: tsPrintSignatureDeclarationBase,
    tsPrintClassMemberModifiers: tsPrintClassMemberModifiers
  });

  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var NON_DECIMAL_LITERAL = /^0[box]/;
  var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

  var Printer = function () {
    function Printer(format, map) {
      this.inForStatementInitCounter = 0;
      this._printStack = [];
      this._indent = 0;
      this._insideAux = false;
      this._printedCommentStarts = {};
      this._parenPushNewlineState = null;
      this._noLineTerminator = false;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new WeakSet();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this.format = format || {};
      this._buf = new Buffer$1(map);
    }

    var _proto = Printer.prototype;

    _proto.generate = function generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    };

    _proto.indent = function indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    };

    _proto.dedent = function dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    };

    _proto.semicolon = function semicolon(force) {
      if (force === void 0) {
        force = false;
      }

      this._maybeAddAuxComment();

      this._append(";", !force);
    };

    _proto.rightBrace = function rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    };

    _proto.space = function space(force) {
      if (force === void 0) {
        force = false;
      }

      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    };

    _proto.word = function word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    };

    _proto.number = function number(str) {
      this.word(str);
      this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    };

    _proto.token = function token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    };

    _proto.newline = function newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (var j = 0; j < i; j++) {
        this._newline();
      }
    };

    _proto.endsWith = function endsWith(str) {
      return this._buf.endsWith(str);
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    };

    _proto.source = function source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    };

    _proto._space = function _space() {
      this._append(" ", true);
    };

    _proto._newline = function _newline() {
      this._append("\n", true);
    };

    _proto._append = function _append(str, queue) {
      if (queue === void 0) {
        queue = false;
      }

      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    };

    _proto._maybeIndent = function _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    };

    _proto._maybeAddParen = function _maybeAddParen(str) {
      var parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      var i;

      for (i = 0; i < str.length && str[i] === " "; i++) {
        continue;
      }

      if (i === str.length) {
        return;
      }

      var cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/" || i + 1 === str.length) {
          this._parenPushNewlineState = null;
          return;
        }

        var chaPost = str[i + 1];

        if (chaPost === "*") {
          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
            return;
          }
        } else if (chaPost !== "/") {
          this._parenPushNewlineState = null;
          return;
        }
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    };

    _proto._catchUp = function _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      var pos = loc ? loc[prop] : null;

      if ((pos == null ? void 0 : pos.line) != null) {
        var count = pos.line - this._buf.getCurrentLine();

        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    };

    _proto._getIndent = function _getIndent() {
      return this.format.indent.style.repeat(this._indent);
    };

    _proto.startTerminatorless = function startTerminatorless(isLabel) {
      if (isLabel === void 0) {
        isLabel = false;
      }

      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    };

    _proto.endTerminatorless = function endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state == null ? void 0 : state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    };

    _proto.print = function print(node, parent) {
      var _this = this;

      if (!node) return;
      var oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      var printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node == null ? void 0 : node.constructor.name));
      }

      this._printStack.push(node);

      var oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      var needsParens$1 = needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens$1 = true;
      }

      if (needsParens$1) this.token("(");

      this._printLeadingComments(node);

      var loc = isProgram(node) || isFile(node) ? null : node.loc;
      this.withSource("start", loc, function () {
        printMethod.call(_this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens$1) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    };

    _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    };

    _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto._printAuxAfterComment = function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto.getPossibleRaw = function getPossibleRaw(node) {
      var extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    };

    _proto.printJoin = function printJoin(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (!(nodes == null ? void 0 : nodes.length)) return;
      if (opts.indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    };

    _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    };

    _proto.printBlock = function printBlock(parent) {
      var node = parent.body;

      if (!isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    };

    _proto._printTrailingComments = function _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    };

    _proto._printLeadingComments = function _printLeadingComments(node) {
      this._printComments(this._getComments(true, node), true);
    };

    _proto.printInnerComments = function printInnerComments(node, indent) {
      var _node$innerComments;

      if (indent === void 0) {
        indent = true;
      }

      if (!((_node$innerComments = node.innerComments) == null ? void 0 : _node$innerComments.length)) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    };

    _proto.printSequence = function printSequence(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    };

    _proto.printList = function printList(items, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    };

    _proto._printNewline = function _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      var lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        var needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    };

    _proto._getComments = function _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    };

    _proto._printComment = function _printComment(comment, skipNewLines) {
      var _this2 = this;

      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      if (comment.start != null) {
        if (this._printedCommentStarts[comment.start]) return;
        this._printedCommentStarts[comment.start] = true;
      }

      var isBlockComment = comment.type === "CommentBlock";
      var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent()) this.newline(1);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var _comment$loc;

        var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;

        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n" + " ".repeat(indentSize));
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, function () {
        _this2._append(val);
      });
      if (printNewLines) this.newline(1);
    };

    _proto._printComments = function _printComments(comments, inlinePureAnnotation) {
      if (!(comments == null ? void 0 : comments.length)) return;

      if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
        this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n"));
      } else {
        for (var _iterator = _createForOfIteratorHelperLoose(comments), _step; !(_step = _iterator()).done;) {
          var _comment = _step.value;

          this._printComment(_comment);
        }
      }
    };

    _proto.printAssertions = function printAssertions(node) {
      var _node$assertions;

      if ((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) {
        this.space();
        this.word("assert");
        this.space();
        this.token("{");
        this.space();
        this.printList(node.assertions, node);
        this.space();
        this.token("}");
      }
    };

    return Printer;
  }();
  Object.assign(Printer.prototype, generatorFunctions);

  function commaSeparator() {
    this.token(",");
    this.space();
  }

  var Generator = function (_Printer) {
    _inheritsLoose(Generator, _Printer);

    function Generator(ast, opts, code) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      var format = normalizeOptions(code, opts);
      var map = opts.sourceMaps ? new SourceMap(opts, code) : null;
      _this = _Printer.call(this, format, map) || this;
      _this.ast = void 0;
      _this.ast = ast;
      return _this;
    }

    var _proto = Generator.prototype;

    _proto.generate = function generate() {
      return _Printer.prototype.generate.call(this, this.ast);
    };

    return Generator;
  }(Printer);

  function normalizeOptions(code, opts) {
    var format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  ",
        base: 0
      },
      decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true
      }, opts.jsescOption),
      recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
    };

    if (!process.env.BABEL_8_BREAKING) {
      format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
    }

    if (format.minified) {
      format.compact = true;

      format.shouldPrintComment = format.shouldPrintComment || function () {
        return format.comments;
      };
    } else {
      format.shouldPrintComment = format.shouldPrintComment || function (value) {
        return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
      };
    }

    if (format.compact === "auto") {
      format.compact = code.length > 500000;

      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
      }
    }

    if (format.compact) {
      format.indent.adjustMultilineComment = false;
    }

    return format;
  }
  function generateCode (ast, opts, code) {
    var gen = new Generator(ast, opts, code);
    return gen.generate();
  }

  function findParent(callback) {
    var path = this;

    while (path = path.parentPath) {
      if (callback(path)) return path;
    }

    return null;
  }
  function find$1(callback) {
    var path = this;

    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);

    return null;
  }
  function getFunctionParent() {
    return this.findParent(function (p) {
      return p.isFunction();
    });
  }
  function getStatementParent() {
    var path = this;

    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }

    return path;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      var earliest;
      var keys = VISITOR_KEYS[deepest.type];

      for (var _i = 0, _arr = ancestries; _i < _arr.length; _i++) {
        var ancestry = _arr[_i];
        var path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        var earliestKeyIndex = keys.indexOf(earliest.parentKey);
        var currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }

      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    var _this = this;

    if (!paths.length) {
      return this;
    }

    if (paths.length === 1) {
      return paths[0];
    }

    var minDepth = Infinity;
    var lastCommonIndex, lastCommon;
    var ancestries = paths.map(function (path) {
      var ancestry = [];

      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== _this);

      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }

      return ancestry;
    });
    var first = ancestries[0];

    depthLoop: for (var i = 0; i < minDepth; i++) {
      var shouldMatch = first[i];

      for (var _i2 = 0, _arr2 = ancestries; _i2 < _arr2.length; _i2++) {
        var ancestry = _arr2[_i2];

        if (ancestry[i] !== shouldMatch) {
          break depthLoop;
        }
      }

      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }

    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    var path = this;
    var paths = [];

    do {
      paths.push(path);
    } while (path = path.parentPath);

    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent(function (parent) {
      return parent === maybeAncestor;
    });
  }
  function inType() {
    var path = this;

    while (path) {
      for (var _i3 = 0, _arr3 = arguments; _i3 < _arr3.length; _i3++) {
        var type = _arr3[_i3];
        if (path.node.type === type) return true;
      }

      path = path.parentPath;
    }

    return false;
  }

  var NodePath_ancestry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    findParent: findParent,
    find: find$1,
    getFunctionParent: getFunctionParent,
    getStatementParent: getStatementParent,
    getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom,
    getAncestry: getAncestry,
    isAncestor: isAncestor,
    isDescendant: isDescendant,
    inType: inType
  });

  function infererReference (node) {
    if (!this.isReferenced()) return;
    var binding = this.scope.getBinding(node.name);

    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }

    if (node.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node.name === "arguments") ;
  }

  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    var types = [];
    var functionConstantViolations = [];
    var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    var testType = getConditionalAnnotation(binding, path, name);

    if (testType) {
      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter(function (path) {
        return testConstantViolations.indexOf(path) < 0;
      });
      types.push(testType.typeAnnotation);
    }

    if (constantViolations.length) {
      constantViolations = constantViolations.concat(functionConstantViolations);

      for (var _i = 0, _arr = constantViolations; _i < _arr.length; _i++) {
        var violation = _arr[_i];
        types.push(violation.getTypeAnnotation());
      }
    }

    if (!types.length) {
      return;
    }

    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
      return createTSUnionType(types);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(types);
    }

    return createFlowUnionType(types);
  }

  function getConstantViolationsBefore(binding, path, functions) {
    var violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter(function (violation) {
      violation = violation.resolve();

      var status = violation._guessExecutionStatusRelativeTo(path);

      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }

  function inferAnnotationFromBinaryExpression(name, path) {
    var operator = path.node.operator;
    var right = path.get("right").resolve();
    var left = path.get("left").resolve();
    var target;

    if (left.isIdentifier({
      name: name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name: name
    })) {
      target = left;
    }

    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }

      if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return numberTypeAnnotation();
      }

      return;
    }

    if (operator !== "===" && operator !== "==") return;
    var typeofPath;
    var typePath;

    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }

    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name: name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    var typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  }

  function getParentConditionalPath(binding, path, name) {
    var parentPath;

    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }

        return parentPath;
      }

      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }

      path = parentPath;
    }
  }

  function getConditionalAnnotation(binding, path, name) {
    var ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    var test = ifStatement.get("test");
    var paths = [test];
    var types = [];

    for (var i = 0; i < paths.length; i++) {
      var _path = paths[i];

      if (_path.isLogicalExpression()) {
        if (_path.node.operator === "&&") {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
      } else if (_path.isBinaryExpression()) {
        var type = inferAnnotationFromBinaryExpression(name, _path);
        if (type) types.push(type);
      }
    }

    if (types.length) {
      if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
        return {
          typeAnnotation: createTSUnionType(types),
          ifStatement: ifStatement
        };
      }

      if (createFlowUnionType) {
        return {
          typeAnnotation: createFlowUnionType(types),
          ifStatement: ifStatement
        };
      }

      return {
        typeAnnotation: createFlowUnionType(types),
        ifStatement: ifStatement
      };
    }

    return getConditionalAnnotation(ifStatement, name);
  }

  function VariableDeclarator$1() {
    var _type;

    var id = this.get("id");
    if (!id.isIdentifier()) return;
    var init = this.get("init");
    var type = init.getTypeAnnotation();

    if (((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation") {
      if (init.isCallExpression() && init.get("callee").isIdentifier({
        name: "Array"
      }) && !init.scope.hasBinding("Array", true)) {
        type = ArrayExpression$1();
      }
    }

    return type;
  }
  function TypeCastExpression$1(node) {
    return node.typeAnnotation;
  }
  TypeCastExpression$1.validParent = true;
  function NewExpression$1(node) {
    if (this.get("callee").isIdentifier()) {
      return genericTypeAnnotation(node.callee);
    }
  }
  function TemplateLiteral$1() {
    return stringTypeAnnotation();
  }
  function UnaryExpression$1(node) {
    var operator = node.operator;

    if (operator === "void") {
      return voidTypeAnnotation();
    } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return stringTypeAnnotation();
    } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    }
  }
  function BinaryExpression$1(node) {
    var operator = node.operator;

    if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    } else if (operator === "+") {
      var right = this.get("right");
      var left = this.get("left");

      if (left.isBaseType("number") && right.isBaseType("number")) {
        return numberTypeAnnotation();
      } else if (left.isBaseType("string") || right.isBaseType("string")) {
        return stringTypeAnnotation();
      }

      return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
    }
  }
  function LogicalExpression$1() {
    var argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];

    if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
      return createTSUnionType(argumentTypes);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(argumentTypes);
    }

    return createFlowUnionType(argumentTypes);
  }
  function ConditionalExpression$2() {
    var argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];

    if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
      return createTSUnionType(argumentTypes);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(argumentTypes);
    }

    return createFlowUnionType(argumentTypes);
  }
  function SequenceExpression$2() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function ParenthesizedExpression$1() {
    return this.get("expression").getTypeAnnotation();
  }
  function AssignmentExpression$2() {
    return this.get("right").getTypeAnnotation();
  }
  function UpdateExpression$2(node) {
    var operator = node.operator;

    if (operator === "++" || operator === "--") {
      return numberTypeAnnotation();
    }
  }
  function StringLiteral$1() {
    return stringTypeAnnotation();
  }
  function NumericLiteral$1() {
    return numberTypeAnnotation();
  }
  function BooleanLiteral$1() {
    return booleanTypeAnnotation();
  }
  function NullLiteral$1() {
    return nullLiteralTypeAnnotation();
  }
  function RegExpLiteral$1() {
    return genericTypeAnnotation(identifier("RegExp"));
  }
  function ObjectExpression$2() {
    return genericTypeAnnotation(identifier("Object"));
  }
  function ArrayExpression$1() {
    return genericTypeAnnotation(identifier("Array"));
  }
  function RestElement$1() {
    return ArrayExpression$1();
  }
  RestElement$1.validParent = true;

  function Func() {
    return genericTypeAnnotation(identifier("Function"));
  }
  var isArrayFrom = buildMatchMemberExpression("Array.from");
  var isObjectKeys = buildMatchMemberExpression("Object.keys");
  var isObjectValues = buildMatchMemberExpression("Object.values");
  var isObjectEntries = buildMatchMemberExpression("Object.entries");
  function CallExpression$1() {
    var callee = this.node.callee;

    if (isObjectKeys(callee)) {
      return arrayTypeAnnotation(stringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee)) {
      return arrayTypeAnnotation(anyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
    }

    return resolveCall(this.get("callee"));
  }
  function TaggedTemplateExpression$1() {
    return resolveCall(this.get("tag"));
  }

  function resolveCall(callee) {
    callee = callee.resolve();

    if (callee.isFunction()) {
      if (callee.is("async")) {
        if (callee.is("generator")) {
          return genericTypeAnnotation(identifier("AsyncIterator"));
        } else {
          return genericTypeAnnotation(identifier("Promise"));
        }
      } else {
        if (callee.node.returnType) {
          return callee.node.returnType;
        }
      }
    }
  }

  var inferers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VariableDeclarator: VariableDeclarator$1,
    TypeCastExpression: TypeCastExpression$1,
    NewExpression: NewExpression$1,
    TemplateLiteral: TemplateLiteral$1,
    UnaryExpression: UnaryExpression$1,
    BinaryExpression: BinaryExpression$1,
    LogicalExpression: LogicalExpression$1,
    ConditionalExpression: ConditionalExpression$2,
    SequenceExpression: SequenceExpression$2,
    ParenthesizedExpression: ParenthesizedExpression$1,
    AssignmentExpression: AssignmentExpression$2,
    UpdateExpression: UpdateExpression$2,
    StringLiteral: StringLiteral$1,
    NumericLiteral: NumericLiteral$1,
    BooleanLiteral: BooleanLiteral$1,
    NullLiteral: NullLiteral$1,
    RegExpLiteral: RegExpLiteral$1,
    ObjectExpression: ObjectExpression$2,
    ArrayExpression: ArrayExpression$1,
    RestElement: RestElement$1,
    FunctionExpression: Func,
    ArrowFunctionExpression: Func,
    FunctionDeclaration: Func,
    ClassExpression: Func,
    ClassDeclaration: Func,
    CallExpression: CallExpression$1,
    TaggedTemplateExpression: TaggedTemplateExpression$1,
    Identifier: infererReference
  });

  function getTypeAnnotation() {
    if (this.typeAnnotation) return this.typeAnnotation;
    var type = this._getTypeAnnotation() || anyTypeAnnotation();
    if (isTypeAnnotation(type)) type = type.typeAnnotation;
    return this.typeAnnotation = type;
  }
  var typeAnnotationInferringNodes = new WeakSet();
  function _getTypeAnnotation() {
    var node = this.node;

    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        var declar = this.parentPath.parentPath;
        var declarParent = declar.parentPath;

        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }

        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }

        return voidTypeAnnotation();
      } else {
        return;
      }
    }

    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }

    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }

    typeAnnotationInferringNodes.add(node);

    try {
      var _inferer;

      var inferer = inferers[node.type];

      if (inferer) {
        return inferer.call(this, node);
      }

      inferer = inferers[this.parentPath.type];

      if ((_inferer = inferer) == null ? void 0 : _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes["delete"](node);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }

  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error("Unknown base type " + baseName);
      }
    }
  }

  function couldBeBaseType(name) {
    var type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;

    if (isUnionTypeAnnotation(type)) {
      for (var _i = 0, _arr = type.types; _i < _arr.length; _i++) {
        var type2 = _arr[_i];

        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }

      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(right) {
    var left = this.getTypeAnnotation();
    right = right.getTypeAnnotation();

    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
  }
  function isGenericType(genericName) {
    var type = this.getTypeAnnotation();
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    });
  }

  var NodePath_inference = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getTypeAnnotation: getTypeAnnotation,
    _getTypeAnnotation: _getTypeAnnotation,
    isBaseType: isBaseType,
    couldBeBaseType: couldBeBaseType,
    baseTypeStrictlyMatches: baseTypeStrictlyMatches,
    isGenericType: isGenericType
  });

  var jsTokens = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

  exports.matchToToken = function (match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
    return token;
  };
  });

  var jsTokens$1 = /*@__PURE__*/unwrapExports(jsTokens);

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function (str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  var reverseKeywords = {};

  for (var _i$2 = 0, _Object$keys = Object.keys(colorName); _i$2 < _Object$keys.length; _i$2++) {
    var key = _Object$keys[_i$2];
    reverseKeywords[colorName[key]] = key;
  }

  var convert = {
    rgb: {
      channels: 3,
      labels: 'rgb'
    },
    hsl: {
      channels: 3,
      labels: 'hsl'
    },
    hsv: {
      channels: 3,
      labels: 'hsv'
    },
    hwb: {
      channels: 3,
      labels: 'hwb'
    },
    cmyk: {
      channels: 4,
      labels: 'cmyk'
    },
    xyz: {
      channels: 3,
      labels: 'xyz'
    },
    lab: {
      channels: 3,
      labels: 'lab'
    },
    lch: {
      channels: 3,
      labels: 'lch'
    },
    hex: {
      channels: 1,
      labels: ['hex']
    },
    keyword: {
      channels: 1,
      labels: ['keyword']
    },
    ansi16: {
      channels: 1,
      labels: ['ansi16']
    },
    ansi256: {
      channels: 1,
      labels: ['ansi256']
    },
    hcg: {
      channels: 3,
      labels: ['h', 'c', 'g']
    },
    apple: {
      channels: 3,
      labels: ['r16', 'g16', 'b16']
    },
    gray: {
      channels: 1,
      labels: ['gray']
    }
  };
  var conversions = convert;

  for (var _i2 = 0, _Object$keys2 = Object.keys(convert); _i2 < _Object$keys2.length; _i2++) {
    var model = _Object$keys2[_i2];

    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }

    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }

    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }

    var _convert$model = convert[model],
        channels = _convert$model.channels,
        labels = _convert$model.labels;
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', {
      value: channels
    });
    Object.defineProperty(convert[model], 'labels', {
      value: labels
    });
  }

  convert.rgb.hsl = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;

    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }

    h = Math.min(h * 60, 360);

    if (h < 0) {
      h += 360;
    }

    var l = (min + max) / 2;

    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }

    return [h, s * 100, l * 100];
  };

  convert.rgb.hsv = function (rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);

    var diffc = function diffc(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };

    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);

      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }

      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }

    return [h * 360, s * 100, v * 100];
  };

  convert.rgb.hwb = function (rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };

  convert.rgb.cmyk = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var k = Math.min(1 - r, 1 - g, 1 - b);
    var c = (1 - r - k) / (1 - k) || 0;
    var m = (1 - g - k) / (1 - k) || 0;
    var y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };

  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }

  convert.rgb.keyword = function (rgb) {
    var reversed = reverseKeywords[rgb];

    if (reversed) {
      return reversed;
    }

    var currentClosestDistance = Infinity;
    var currentClosestKeyword;

    for (var _i3 = 0, _Object$keys3 = Object.keys(colorName); _i3 < _Object$keys3.length; _i3++) {
      var keyword = _Object$keys3[_i3];
      var value = colorName[keyword];
      var distance = comparativeDistance(rgb, value);

      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }

    return currentClosestKeyword;
  };

  convert.keyword.rgb = function (keyword) {
    return colorName[keyword];
  };

  convert.rgb.xyz = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };

  convert.rgb.lab = function (rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    var l = 116 * y - 16;
    var a = 500 * (x - y);
    var b = 200 * (y - z);
    return [l, a, b];
  };

  convert.hsl.rgb = function (hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t2;
    var t3;
    var val;

    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }

    var t1 = 2 * l - t2;
    var rgb = [0, 0, 0];

    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);

      if (t3 < 0) {
        t3++;
      }

      if (t3 > 1) {
        t3--;
      }

      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }

      rgb[i] = val * 255;
    }

    return rgb;
  };

  convert.hsl.hsv = function (hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    var v = (l + s) / 2;
    var sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };

  convert.hsv.rgb = function (hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;

    switch (hi) {
      case 0:
        return [v, t, p];

      case 1:
        return [q, v, p];

      case 2:
        return [p, v, t];

      case 3:
        return [p, q, v];

      case 4:
        return [t, p, v];

      case 5:
        return [v, p, q];
    }
  };

  convert.hsv.hsl = function (hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var sl;
    var l;
    l = (2 - s) * v;
    var lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };

  convert.hwb.rgb = function (hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var f;

    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    var i = Math.floor(6 * h);
    var v = 1 - bl;
    f = 6 * h - i;

    if ((i & 0x01) !== 0) {
      f = 1 - f;
    }

    var n = wh + f * (v - wh);
    var r;
    var g;
    var b;

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;

      case 1:
        r = n;
        g = v;
        b = wh;
        break;

      case 2:
        r = wh;
        g = v;
        b = n;
        break;

      case 3:
        r = wh;
        g = n;
        b = v;
        break;

      case 4:
        r = n;
        g = wh;
        b = v;
        break;

      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }

    return [r * 255, g * 255, b * 255];
  };

  convert.cmyk.rgb = function (cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r = 1 - Math.min(1, c * (1 - k) + k);
    var g = 1 - Math.min(1, m * (1 - k) + k);
    var b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.rgb = function (xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };

  convert.xyz.lab = function (xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    var l = 116 * y - 16;
    var a = 500 * (x - y);
    var b = 200 * (y - z);
    return [l, a, b];
  };

  convert.lab.xyz = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };

  convert.lab.lch = function (lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var h;
    var hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;

    if (h < 0) {
      h += 360;
    }

    var c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };

  convert.lch.lab = function (lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var hr = h / 360 * 2 * Math.PI;
    var a = c * Math.cos(hr);
    var b = c * Math.sin(hr);
    return [l, a, b];
  };

  convert.rgb.ansi16 = function (args, saturation) {
    if (saturation === void 0) {
      saturation = null;
    }

    var r = args[0],
        g = args[1],
        b = args[2];
    var value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);

    if (value === 0) {
      return 30;
    }

    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

    if (value === 2) {
      ansi += 60;
    }

    return ansi;
  };

  convert.hsv.ansi16 = function (args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };

  convert.rgb.ansi256 = function (args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];

    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }

      if (r > 248) {
        return 231;
      }

      return Math.round((r - 8) / 247 * 24) + 232;
    }

    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };

  convert.ansi16.rgb = function (args) {
    var color = args % 10;

    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }

      color = color / 10.5 * 255;
      return [color, color, color];
    }

    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color & 1) * mult * 255;
    var g = (color >> 1 & 1) * mult * 255;
    var b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };

  convert.ansi256.rgb = function (args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }

    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };

  convert.rgb.hex = function (args) {
    var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.hex.rgb = function (args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

    if (!match) {
      return [0, 0, 0];
    }

    var colorString = match[0];

    if (match[0].length === 3) {
      colorString = colorString.split('').map(function (_char) {
        return _char + _char;
      }).join('');
    }

    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 0xFF;
    var g = integer >> 8 & 0xFF;
    var b = integer & 0xFF;
    return [r, g, b];
  };

  convert.rgb.hcg = function (rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale;
    var hue;

    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }

    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }

    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };

  convert.hsl.hcg = function (hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = l < 0.5 ? 2.0 * s * l : 2.0 * s * (1.0 - l);
    var f = 0;

    if (c < 1.0) {
      f = (l - 0.5 * c) / (1.0 - c);
    }

    return [hsl[0], c * 100, f * 100];
  };

  convert.hsv.hcg = function (hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;

    if (c < 1.0) {
      f = (v - c) / (1 - c);
    }

    return [hsv[0], c * 100, f * 100];
  };

  convert.hcg.rgb = function (hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;

    if (c === 0.0) {
      return [g * 255, g * 255, g * 255];
    }

    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;

    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;

      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;

      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;

      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;

      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;

      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }

    mg = (1.0 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };

  convert.hcg.hsv = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    var f = 0;

    if (v > 0.0) {
      f = c / v;
    }

    return [hcg[0], f * 100, v * 100];
  };

  convert.hcg.hsl = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1.0 - c) + 0.5 * c;
    var s = 0;

    if (l > 0.0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1.0) {
      s = c / (2 * (1 - l));
    }

    return [hcg[0], s * 100, l * 100];
  };

  convert.hcg.hwb = function (hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1.0 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };

  convert.hwb.hcg = function (hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;

    if (c < 1) {
      g = (v - c) / (1 - c);
    }

    return [hwb[0], c * 100, g * 100];
  };

  convert.apple.rgb = function (apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };

  convert.rgb.apple = function (rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };

  convert.gray.rgb = function (args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };

  convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };

  convert.gray.hsv = convert.gray.hsl;

  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };

  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };

  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };

  convert.gray.hex = function (gray) {
    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };

  convert.rgb.gray = function (rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };

  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }

    return graph;
  }

  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function (fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert$1 = {};
  var models = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var arg0 = args[0];

      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }

      if (arg0.length > 1) {
        args = arg0;
      }

      return fn(args);
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var arg0 = args[0];

      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }

      if (arg0.length > 1) {
        args = arg0;
      }

      var result = fn(args);

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert$1[fromModel] = {};
    Object.defineProperty(convert$1[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert$1[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert$1[fromModel][toModel] = wrapRounded(fn);
      convert$1[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert$1;

  var ansiStyles = createCommonjsModule(function (module) {



  var wrapAnsi16 = function wrapAnsi16(fn, offset) {
    return function () {
      var code = fn.apply(colorConvert, arguments);
      return "\x1B[" + (code + offset) + "m";
    };
  };

  var wrapAnsi256 = function wrapAnsi256(fn, offset) {
    return function () {
      var code = fn.apply(colorConvert, arguments);
      return "\x1B[" + (38 + offset) + ";5;" + code + "m";
    };
  };

  var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
    return function () {
      var rgb = fn.apply(colorConvert, arguments);
      return "\x1B[" + (38 + offset) + ";2;" + rgb[0] + ";" + rgb[1] + ";" + rgb[2] + "m";
    };
  };

  function assembleStyles() {
    var codes = new Map();
    var styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;

    for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
      var groupName = _Object$keys[_i];
      var group = styles[groupName];

      for (var _i2 = 0, _Object$keys2 = Object.keys(group); _i2 < _Object$keys2.length; _i2++) {
        var styleName = _Object$keys2[_i2];
        var style = group[styleName];
        styles[styleName] = {
          open: "\x1B[" + style[0] + "m",
          close: "\x1B[" + style[1] + "m"
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }

      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, 'codes', {
        value: codes,
        enumerable: false
      });
    }

    var ansi2ansi = function ansi2ansi(n) {
      return n;
    };

    var rgb2rgb = function rgb2rgb(r, g, b) {
      return [r, g, b];
    };

    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };

    for (var _i3 = 0, _Object$keys3 = Object.keys(colorConvert); _i3 < _Object$keys3.length; _i3++) {
      var key = _Object$keys3[_i3];

      if (typeof colorConvert[key] !== 'object') {
        continue;
      }

      var suite = colorConvert[key];

      if (key === 'ansi16') {
        key = 'ansi';
      }

      if ('ansi16' in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }

      if ('ansi256' in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }

      if ('rgb' in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }

    return styles;
  }

  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles
  });
  });

  var env$1 = process.env;
  var forceColor$1;

  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
    forceColor$1 = false;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor$1 = true;
  }

  if ('FORCE_COLOR' in env$1) {
    forceColor$1 = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel$1(level) {
    if (level === 0) {
      return false;
    }

    return {
      level: level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }

  function supportsColor$1(stream) {
    if (forceColor$1 === false) {
      return 0;
    }

    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }

    if (hasFlag('color=256')) {
      return 2;
    }

    if (stream && !stream.isTTY && forceColor$1 !== true) {
      return 0;
    }

    var min = forceColor$1 ? 1 : 0;

    if (process.platform === 'win32') {
      var osRelease = os__default['default'].release().split('.');

      if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env$1) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
        return sign in env$1;
      }) || env$1.CI_NAME === 'codeship') {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env$1) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
    }

    if (env$1.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env$1) {
      var version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

      switch (env$1.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
      }
    }

    if (/-256(color)?$/i.test(env$1.TERM)) {
      return 2;
    }

    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
      return 1;
    }

    if ('COLORTERM' in env$1) {
      return 1;
    }

    if (env$1.TERM === 'dumb') {
      return min;
    }

    return min;
  }

  function getSupportLevel$1(stream) {
    var level = supportsColor$1(stream);
    return translateLevel$1(level);
  }

  var supportsColor_1$1 = {
    supportsColor: getSupportLevel$1,
    stdout: getSupportLevel$1(process.stdout),
    stderr: getSupportLevel$1(process.stderr)
  };

  var require$$0$1 = getCjsExportFromNamespace(_rollupPluginBabelHelpers);

  var _createForOfIteratorHelperLoose$1 = require$$0$1.createForOfIteratorHelperLoose;

  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

  function unescape(c) {
    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
    var results = [];
    var chunks = args.trim().split(/\s*,\s*/g);
    var matches;

    for (var _iterator = _createForOfIteratorHelperLoose$1(chunks), _step; !(_step = _iterator()).done;) {
      var chunk = _step.value;

      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
          return escape ? unescape(escape) : chr;
        }));
      } else {
        throw new Error("Invalid Chalk template style argument: " + chunk + " (in style '" + name + "')");
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    var results = [];
    var matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      var name = matches[1];

      if (matches[2]) {
        var args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    var enabled = {};

    for (var _iterator2 = _createForOfIteratorHelperLoose$1(styles), _step2; !(_step2 = _iterator2()).done;) {
      var layer = _step2.value;

      for (var _iterator3 = _createForOfIteratorHelperLoose$1(layer.styles), _step3; !(_step3 = _iterator3()).done;) {
        var style = _step3.value;
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }

    var current = chalk;

    for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
      var styleName = _Object$keys[_i];

      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error("Unknown Chalk style: " + styleName);
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = function (chalk, tmp) {
    var styles = [];
    var chunks = [];
    var chunk = [];
    tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        var str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse: inverse,
          styles: parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      var errMsg = "Chalk template literal is missing " + styles.length + " closing bracket" + (styles.length === 1 ? '' : 's') + " (`}`)";
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {

  var _createForOfIteratorHelperLoose = require$$0$1.createForOfIteratorHelperLoose;





  var stdoutColor = supportsColor_1$1.stdout;



  var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm');
  var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
  var skipModels = new Set(['gray']);
  var styles = Object.create(null);

  function applyOptions(obj, options) {
    options = options || {};
    var scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === undefined ? scLevel : options.level;
    obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
  }

  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      var chalk = {};
      applyOptions(chalk, options);

      chalk.template = function () {
        var args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };

      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }

    applyOptions(this, options);
  }

  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "\x1B[94m";
  }

  var _loop = function _loop() {
    var key = _Object$keys[_i];
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
    styles[key] = {
      get: function get() {
        var codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  };

  for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
    _loop();
  }

  styles.visible = {
    get: function get() {
      return build.call(this, this._styles || [], true, 'visible');
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

  var _loop2 = function _loop2() {
    var model = _Object$keys2[_i2];

    if (skipModels.has(model)) {
      return "continue";
    }

    styles[model] = {
      get: function get() {
        var level = this.level;
        return function () {
          var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          var codes = {
            open: open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  };

  for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
    var _ret = _loop2();

    if (_ret === "continue") continue;
  }

  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

  var _loop3 = function _loop3() {
    var model = _Object$keys3[_i3];

    if (skipModels.has(model)) {
      return "continue";
    }

    var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get: function get() {
        var level = this.level;
        return function () {
          var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          var codes = {
            open: open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  };

  for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
    var _ret2 = _loop3();

    if (_ret2 === "continue") continue;
  }

  var proto = Object.defineProperties(function () {}, styles);

  function build(_styles, _empty, key) {
    var builder = function builder() {
      return applyStyle.apply(builder, arguments);
    };

    builder._styles = _styles;
    builder._empty = _empty;
    var self = this;
    Object.defineProperty(builder, 'level', {
      enumerable: true,
      get: function get() {
        return self.level;
      },
      set: function set(level) {
        self.level = level;
      }
    });
    Object.defineProperty(builder, 'enabled', {
      enumerable: true,
      get: function get() {
        return self.enabled;
      },
      set: function set(enabled) {
        self.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
    builder.__proto__ = proto;
    return builder;
  }

  function applyStyle() {
    var args = arguments;
    var argsLen = args.length;
    var str = String(arguments[0]);

    if (argsLen === 0) {
      return '';
    }

    if (argsLen > 1) {
      for (var a = 1; a < argsLen; a++) {
        str += ' ' + args[a];
      }
    }

    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? '' : str;
    }

    var originalDim = ansiStyles.dim.open;

    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = '';
    }

    for (var _iterator = _createForOfIteratorHelperLoose(this._styles.slice().reverse()), _step; !(_step = _iterator()).done;) {
      var code = _step.value;
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
    }

    ansiStyles.dim.open = originalDim;
    return str;
  }

  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(' ');
    }

    var args = [].slice.call(arguments, 2);
    var parts = [strings.raw[0]];

    for (var i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
      parts.push(String(strings.raw[i]));
    }

    return templates(chalk, parts.join(''));
  }

  Object.defineProperties(Chalk.prototype, styles);
  module.exports = Chalk();
  module.exports.supportsColor = stdoutColor;
  module.exports["default"] = module.exports;
  });

  function getDefs(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsx_tag: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }

  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  var JSX_TAG = /^[a-z][\w-]*$/i;
  var BRACKET = /^[()[\]{}]$/;

  function getTokenType(match) {
    var _match$slice = match.slice(-2),
        offset = _match$slice[0],
        text = _match$slice[1];

    var token = jsTokens$1.matchToToken(match);

    if (token.type === "name") {
      if (isKeyword(token.value) || isReservedWord(token.value)) {
        return "keyword";
      }

      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
        return "jsx_tag";
      }

      if (token.value[0] !== token.value[0].toLowerCase()) {
        return "capitalized";
      }
    }

    if (token.type === "punctuator" && BRACKET.test(token.value)) {
      return "bracket";
    }

    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
      return "punctuator";
    }

    return token.type;
  }

  function highlightTokens(defs, text) {
    return text.replace(jsTokens$1, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var type = getTokenType(args);
      var colorize = defs[type];

      if (colorize) {
        return args[0].split(NEWLINE).map(function (str) {
          return colorize(str);
        }).join("\n");
      } else {
        return args[0];
      }
    });
  }

  function shouldHighlight(options) {
    return chalk.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    var chalk$1 = chalk;

    if (options.forceColor) {
      chalk$1 = new chalk.constructor({
        enabled: true,
        level: 1
      });
    }

    return chalk$1;
  }
  function highlight(code, options) {
    if (options === void 0) {
      options = {};
    }

    if (shouldHighlight(options)) {
      var chalk = getChalk(options);
      var defs = getDefs(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  function getDefs$1(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }

  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    var startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    var endLoc = Object.assign({}, startLoc, loc.end);

    var _ref = opts || {},
        _ref$linesAbove = _ref.linesAbove,
        linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
        _ref$linesBelow = _ref.linesBelow,
        linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

    var startLine = startLoc.line;
    var startColumn = startLoc.column;
    var endLine = endLoc.line;
    var endColumn = endLoc.column;
    var start = Math.max(startLine - (linesAbove + 1), 0);
    var end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    var lineDiff = endLine - startLine;
    var markerLines = {};

    if (lineDiff) {
      for (var i = 0; i <= lineDiff; i++) {
        var lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          var sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          var _sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, _sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start: start,
      end: end,
      markerLines: markerLines
    };
  }

  function codeFrameColumns(rawLines, loc, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
    var chalk = getChalk(opts);
    var defs = getDefs$1(chalk);

    var maybeHighlight = function maybeHighlight(chalkFn, string) {
      return highlighted ? chalkFn(string) : string;
    };

    var lines = rawLines.split(NEWLINE$1);

    var _getMarkerLines = getMarkerLines(loc, lines, opts),
        start = _getMarkerLines.start,
        end = _getMarkerLines.end,
        markerLines = _getMarkerLines.markerLines;

    var hasColumns = loc.start && typeof loc.start.column === "number";
    var numberMaxWidth = String(end).length;
    var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
    var frame = highlightedLines.split(NEWLINE$1).slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var paddedNumber = (" " + number).slice(-numberMaxWidth);
      var gutter = " " + paddedNumber + " |";
      var hasMarker = markerLines[number];
      var lastMarkerLine = !markerLines[number + 1];

      if (hasMarker) {
        var markerLine = "";

        if (Array.isArray(hasMarker)) {
          var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          var numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }

        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? " " + line : "", markerLine].join("");
      } else {
        return " " + maybeHighlight(defs.gutter, gutter) + (line.length > 0 ? " " + line : "");
      }
    }).join("\n");

    if (opts.message && !hasColumns) {
      frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  var beforeExpr = true;
  var startsExpr = true;
  var isLoop$1 = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;
  var TokenType = function TokenType(label, conf) {
    if (conf === void 0) {
      conf = {};
    }

    this.label = void 0;
    this.keyword = void 0;
    this.beforeExpr = void 0;
    this.startsExpr = void 0;
    this.rightAssociative = void 0;
    this.isLoop = void 0;
    this.isAssign = void 0;
    this.prefix = void 0;
    this.postfix = void 0;
    this.binop = void 0;
    this.updateContext = void 0;
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    this.updateContext = null;
  };
  var keywords$1 = new Map();

  function createKeyword(name, options) {
    if (options === void 0) {
      options = {};
    }

    options.keyword = name;
    var token = new TokenType(name, options);
    keywords$1.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr: beforeExpr,
      binop: binop
    });
  }

  var types = {
    num: new TokenType("num", {
      startsExpr: startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr: startsExpr
    }),
    decimal: new TokenType("decimal", {
      startsExpr: startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr: startsExpr
    }),
    string: new TokenType("string", {
      startsExpr: startsExpr
    }),
    name: new TokenType("name", {
      startsExpr: startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceR: new TokenType("}"),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr: beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr: beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr: beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr: beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr: beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr: beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr: beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr: startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr: startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix: prefix,
      postfix: postfix,
      startsExpr: startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: beforeExpr,
      binop: 9,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    modulo: new TokenType("%", {
      beforeExpr: beforeExpr,
      binop: 10,
      startsExpr: startsExpr
    }),
    star: new TokenType("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr: beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr: beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr: beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop: isLoop$1,
      beforeExpr: beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr: beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop: isLoop$1
    }),
    _function: createKeyword("function", {
      startsExpr: startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr: beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop: isLoop$1
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr: startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr: startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr: startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr: beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr: startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr: startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr: startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr: startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    })
  };

  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  var Position = function Position(line, col) {
    this.line = void 0;
    this.column = void 0;
    this.line = line;
    this.column = col;
  };
  var SourceLocation = function SourceLocation(start, end) {
    this.start = void 0;
    this.end = void 0;
    this.filename = void 0;
    this.identifierName = void 0;
    this.start = start;
    this.end = end;
  };
  function getLineInfo(input, offset) {
    var line = 1;
    var lineStart = 0;
    var match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  var BaseParser = function () {
    function BaseParser() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    var _proto = BaseParser.prototype;

    _proto.hasPlugin = function hasPlugin(name) {
      return this.plugins.has(name);
    };

    _proto.getPluginOption = function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    };

    return BaseParser;
  }();

  function last(stack) {
    return stack[stack.length - 1];
  }

  var CommentsParser = function (_BaseParser) {
    _inheritsLoose(CommentsParser, _BaseParser);

    function CommentsParser() {
      return _BaseParser.apply(this, arguments) || this;
    }

    var _proto = CommentsParser.prototype;

    _proto.addComment = function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    };

    _proto.adjustCommentsAfterTrailingComma = function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      var lastElement = null;
      var i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (var j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      var newTrailingComments = [];

      for (var _i = 0; _i < this.state.leadingComments.length; _i++) {
        var leadingComment = this.state.leadingComments[_i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(_i, 1);
            _i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    };

    _proto.processComment = function processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      var stack = this.state.commentStack;
      var firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        var lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          var leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          var firstTrailingCommentIndex = trailingComments.findIndex(function (comment) {
            return comment.end >= node.end;
          });

          if (firstTrailingCommentIndex > 0) {
            node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
            node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
          } else {
            node.trailingComments = trailingComments;
          }
        }
      }

      stack.push(node);
    };

    return CommentsParser;
  }(BaseParser);

  var ErrorMessages = Object.freeze({
    AccessorIsGenerator: "A %0ter cannot be a generator",
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function",
    AwaitExpressionFormalParameter: "await is not allowed in async function parameters",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions",
    BadGetterArity: "getter must not have any formal parameters",
    BadSetterArity: "setter must have exactly one formal parameter",
    BadSetterRestParameter: "setter function argument must not be a rest parameter",
    ConstructorClassField: "Classes may not have a field named 'constructor'",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'",
    ConstructorIsAccessor: "Class constructor may not be an accessor",
    ConstructorIsAsync: "Constructor can't be an async function",
    ConstructorIsGenerator: "Constructor can't be a generator",
    DeclarationMissingInitializer: "%0 require an initialization value",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon",
    DecoratorStaticBlock: "Decorators can't be used with a static block",
    DeletePrivateField: "Deleting a private field is not allowed",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property",
    DuplicateRegExpFlags: "Duplicate regular expression flag",
    DuplicateStaticBlock: "Duplicate static block in the same class",
    ElementAfterRest: "Rest element must be last element",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape",
    ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'",
    ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block",
    IllegalBreakContinue: "Unsyntactic %0",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
    IllegalReturn: "'return' outside of function",
    ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments",
    ImportCallArity: "import() requires exactly %0",
    ImportCallNotNewExpression: "Cannot use new with import(...)",
    ImportCallSpreadArgument: "... is not allowed in import()",
    ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
    ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'",
    InvalidBigIntLiteral: "Invalid BigIntLiteral",
    InvalidCodePoint: "Code point out of bounds",
    InvalidDecimal: "Invalid decimal",
    InvalidDigit: "Expected number in radix %0",
    InvalidEscapeSequence: "Bad character escape sequence",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0",
    InvalidIdentifier: "Invalid identifier %0",
    InvalidLhs: "Invalid left-hand side in %0",
    InvalidLhsBinding: "Binding invalid left-hand side in %0",
    InvalidNumber: "Invalid number",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'",
    InvalidOrUnexpectedToken: "Unexpected character '%0'",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined",
    InvalidPropertyBindingPattern: "Binding member expression",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument",
    LabelRedeclaration: "Label '%0' is already declared",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'",
    MalformedRegExpFlags: "Invalid regular expression flag",
    MissingClassName: "A class name is required",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes',
    ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'",
    ModuleExportUndefined: "Export '%0' is not defined",
    MultipleDefaultsInSwitch: "Multiple default clauses",
    NewlineAfterThrow: "Illegal newline after throw",
    NoCatchOrFinally: "Missing catch or finally clause",
    NumberIdentifier: "Identifier directly after number",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences",
    ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain",
    ParamDupe: "Argument name clash",
    PatternHasAccessor: "Object pattern can't contain getter or setter",
    PatternHasMethod: "Object pattern can't contain methods",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)",
    PrivateNameRedeclaration: "Duplicate private name #%0",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    RecordNoProto: "'__proto__' is not allowed in Record expressions",
    RestTrailingComma: "Unexpected trailing comma after rest element",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement",
    StaticPrototype: "Classes may not have static property named prototype",
    StrictDelete: "Deleting local variable in strict mode",
    StrictEvalArguments: "Assigning to '%0' in strict mode",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode",
    StrictWith: "'with' in strict mode",
    SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super",
    TrailingDecorator: "Decorators must be attached to a class element",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level",
    UnexpectedKeyword: "Unexpected keyword '%0'",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context",
    UnexpectedNewTarget: "new.target can only be used in functions",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'",
    UnexpectedSuper: "super is only allowed in object methods and classes",
    UnexpectedToken: "Unexpected token '%0'",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "import can only be used in import() or import.meta",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties",
    UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])",
    UnterminatedComment: "Unterminated comment",
    UnterminatedRegExp: "Unterminated regular expression",
    UnterminatedString: "Unterminated string constant",
    UnterminatedTemplate: "Unterminated template",
    VarRedeclaration: "Identifier '%0' has already been declared",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator",
    YieldInParameter: "Yield expression is not allowed in formal parameters",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0"
  });

  var ParserError = function (_CommentsParser) {
    _inheritsLoose(ParserError, _CommentsParser);

    function ParserError() {
      return _CommentsParser.apply(this, arguments) || this;
    }

    var _proto = ParserError.prototype;

    _proto.getLocationForPosition = function getLocationForPosition(pos) {
      var loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    };

    _proto.raise = function raise(pos, errorTemplate) {
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }

      return this.raiseWithData.apply(this, [pos, undefined, errorTemplate].concat(params));
    };

    _proto.raiseWithData = function raiseWithData(pos, data, errorTemplate) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
        params[_key2 - 3] = arguments[_key2];
      }

      var loc = this.getLocationForPosition(pos);
      var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + (" (" + loc.line + ":" + loc.column + ")");
      return this._raise(Object.assign({
        loc: loc,
        pos: pos
      }, data), message);
    };

    _proto._raise = function _raise(errorContext, message) {
      var err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    };

    return ParserError;
  }(CommentsParser);

  var estree = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {
        var pattern = _ref.pattern,
            flags = _ref.flags;
        var regex = null;

        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}

        var node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern: pattern,
          flags: flags
        };
        return node;
      };

      _proto.estreeParseBigIntLiteral = function estreeParseBigIntLiteral(value) {
        var bigInt;

        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }

        var node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      };

      _proto.estreeParseDecimalLiteral = function estreeParseDecimalLiteral(value) {
        var decimal = null;
        var node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      };

      _proto.estreeParseLiteral = function estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      };

      _proto.directiveToStmt = function directiveToStmt(directive) {
        var directiveLiteral = directive.value;
        var stmt = this.startNodeAt(directive.start, directive.loc.start);
        var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.extra.expressionValue;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      };

      _proto.initFunction = function initFunction(node, isAsync) {
        _superClass.prototype.initFunction.call(this, node, isAsync);

        node.expression = false;
      };

      _proto.checkDeclaration = function checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          _superClass.prototype.checkDeclaration.call(this, node);
        }
      };

      _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
        return method.value.params;
      };

      _proto.isValidDirective = function isValidDirective(stmt) {
        var _stmt$expression$extr;

        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) == null ? void 0 : _stmt$expression$extr.parenthesized);
      };

      _proto.stmtToDirective = function stmtToDirective(stmt) {
        var directive = _superClass.prototype.stmtToDirective.call(this, stmt);

        var value = stmt.expression.value;
        this.addExtra(directive.value, "expressionValue", value);
        return directive;
      };

      _proto.parseBlockBody = function parseBlockBody(node) {
        var _superClass$prototype,
            _this = this;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_superClass$prototype = _superClass.prototype.parseBlockBody).call.apply(_superClass$prototype, [this, node].concat(args));

        var directiveStatements = node.directives.map(function (d) {
          return _this.directiveToStmt(d);
        });
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }

        classBody.body.push(method);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        switch (this.state.type) {
          case types.num:
          case types.string:
            return this.estreeParseLiteral(this.state.value);

          case types.regexp:
            return this.estreeParseRegExpLiteral(this.state.value);

          case types.bigint:
            return this.estreeParseBigIntLiteral(this.state.value);

          case types.decimal:
            return this.estreeParseDecimalLiteral(this.state.value);

          case types._null:
            return this.estreeParseLiteral(null);

          case types._true:
            return this.estreeParseLiteral(true);

          case types._false:
            return this.estreeParseLiteral(false);

          default:
            return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };

      _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
        var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);

        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);

        node.expression = node.body.type !== "BlockStatement";
      };

      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        if (inClassScope === void 0) {
          inClassScope = false;
        }

        var funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        type = type === "ClassMethod" ? "MethodDefinition" : type;
        return this.finishNode(node, type);
      };

      _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, isAccessor);

        if (node) {
          node.type = "Property";
          if (node.kind === "method") node.kind = "init";
          node.shorthand = false;
        }

        return node;
      };

      _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

        if (node) {
          node.kind = "init";
          node.type = "Property";
        }

        return node;
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        if (node != null && this.isObjectProperty(node)) {
          this.toAssignable(node.value, isLHS);
          return node;
        }

        return _superClass.prototype.toAssignable.call(this, node, isLHS);
      };

      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
        } else if (prop.method) {
          this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
        } else {
          var _superClass$prototype2;

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          (_superClass$prototype2 = _superClass.prototype.toAssignableObjectExpressionProp).call.apply(_superClass$prototype2, [this, prop].concat(args));
        }
      };

      _proto.finishCallExpression = function finishCallExpression(node, optional) {
        _superClass.prototype.finishCallExpression.call(this, node, optional);

        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          delete node.arguments;
          delete node.callee;
        }

        return node;
      };

      _proto.toReferencedArguments = function toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }

        _superClass.prototype.toReferencedArguments.call(this, node);
      };

      _proto.parseExport = function parseExport(node) {
        _superClass.prototype.parseExport.call(this, node);

        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;

          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }

            break;
        }

        return node;
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var node = _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);

        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }

          if (state.stop) {
            var chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }

        return node;
      };

      _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }

        return _superClass.prototype.hasPropertyAsPrivateName.call(this, node);
      };

      _proto.isOptionalChain = function isOptionalChain(node) {
        return node.type === "ChainExpression";
      };

      _proto.isObjectProperty = function isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      };

      _proto.isObjectMethod = function isObjectMethod(node) {
        return node.method || node.kind === "get" || node.kind === "set";
      };

      return _class;
    }(superClass);
  });

  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
    this.token = void 0;
    this.isExpr = void 0;
    this.preserveSpace = void 0;
    this.override = void 0;
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
  };
  var types$1 = {
    braceStatement: new TokContext("{", false),
    braceExpression: new TokContext("{", true),
    recordExpression: new TokContext("#{", true),
    templateQuasi: new TokContext("${", false),
    parenStatement: new TokContext("(", false),
    parenExpression: new TokContext("(", true),
    template: new TokContext("`", true, true, function (p) {
      return p.readTmplToken();
    }),
    functionExpression: new TokContext("function", true),
    functionStatement: new TokContext("function", false)
  };

  types.parenR.updateContext = types.braceR.updateContext = function () {
    if (this.state.context.length === 1) {
      this.state.exprAllowed = true;
      return;
    }

    var out = this.state.context.pop();

    if (out === types$1.braceStatement && this.curContext().token === "function") {
      out = this.state.context.pop();
    }

    this.state.exprAllowed = !out.isExpr;
  };

  types.name.updateContext = function (prevType) {
    var allowed = false;

    if (prevType !== types.dot) {
      if (this.state.value === "of" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class) {
        allowed = true;
      }
    }

    this.state.exprAllowed = allowed;

    if (this.state.isIterator) {
      this.state.isIterator = false;
    }
  };

  types.braceL.updateContext = function (prevType) {
    this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
    this.state.exprAllowed = true;
  };

  types.dollarBraceL.updateContext = function () {
    this.state.context.push(types$1.templateQuasi);
    this.state.exprAllowed = true;
  };

  types.parenL.updateContext = function (prevType) {
    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
    this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
    this.state.exprAllowed = true;
  };

  types.incDec.updateContext = function () {};

  types._function.updateContext = types._class.updateContext = function (prevType) {
    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && this.hasPrecedingLineBreak()) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
      this.state.context.push(types$1.functionExpression);
    } else {
      this.state.context.push(types$1.functionStatement);
    }

    this.state.exprAllowed = false;
  };

  types.backQuote.updateContext = function () {
    if (this.curContext() === types$1.template) {
      this.state.context.pop();
    } else {
      this.state.context.push(types$1.template);
    }

    this.state.exprAllowed = false;
  };

  types.braceHashL.updateContext = function () {
    this.state.context.push(types$1.recordExpression);
    this.state.exprAllowed = true;
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;
  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }

  var SCOPE_OTHER = 0,
      SCOPE_PROGRAM = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ARROW = 4,
      SCOPE_SIMPLE_CATCH = 8,
      SCOPE_SUPER = 16,
      SCOPE_DIRECT_SUPER = 32,
      SCOPE_CLASS = 64,
      SCOPE_TS_MODULE = 128,
      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  var BIND_KIND_VALUE = 1,
      BIND_KIND_TYPE = 2,
      BIND_SCOPE_VAR = 4,
      BIND_SCOPE_LEXICAL = 8,
      BIND_SCOPE_FUNCTION = 16,
      BIND_FLAGS_NONE = 64,
      BIND_FLAGS_CLASS = 128,
      BIND_FLAGS_TS_ENUM = 256,
      BIND_FLAGS_TS_CONST_ENUM = 512,
      BIND_FLAGS_TS_EXPORT_ONLY = 1024;
  var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;
  var CLASS_ELEMENT_FLAG_STATIC = 4,
      CLASS_ELEMENT_KIND_GETTER = 2,
      CLASS_ELEMENT_KIND_SETTER = 1,
      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
      CLASS_ELEMENT_OTHER = 0;

  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = Object.freeze({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module",
    AssignReservedType: "Cannot overwrite reserved type %0",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions",
    InexactVariance: "Explicit inexact syntax cannot have variance",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SpreadVariance: "Spread properties cannot have variance",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object",
    UnexpectedReservedType: "Unexpected reserved type %0",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module",
    UnterminatedFlowComment: "Unterminated flow-comment"
  });

  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }

  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }

  function isMaybeDefaultImport(state) {
    return (state.type === types.name || !!state.type.keyword) && state.value !== "from";
  }

  var exportSuggestions = {
    "const": "declare export var",
    "let": "declare export var",
    type: "export type",
    "interface": "export interface"
  };

  function partition(list, test) {
    var list1 = [];
    var list2 = [];

    for (var i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (function (superClass) {
    var _temp;

    return _temp = function (_superClass) {
      _inheritsLoose(_temp, _superClass);

      function _temp(options, input) {
        var _this;

        _this = _superClass.call(this, options, input) || this;
        _this.flowPragma = void 0;
        _this.flowPragma = undefined;
        return _this;
      }

      var _proto = _temp.prototype;

      _proto.shouldParseTypes = function shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      };

      _proto.shouldParseEnums = function shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      };

      _proto.finishToken = function finishToken(type, val) {
        if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }

        return _superClass.prototype.finishToken.call(this, type, val);
      };

      _proto.addComment = function addComment(comment) {
        if (this.flowPragma === undefined) {
          var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

          if (!matches) ; else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }

        return _superClass.prototype.addComment.call(this, comment);
      };

      _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types.colon);
        var type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      };

      _proto.flowParsePredicate = function flowParsePredicate() {
        var node = this.startNode();
        var moduloLoc = this.state.startLoc;
        var moduloPos = this.state.start;
        this.expect(types.modulo);
        var checksLoc = this.state.startLoc;
        this.expectContextual("checks");

        if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
          this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
        }

        if (this.eat(types.parenL)) {
          node.value = this.parseExpression();
          this.expect(types.parenR);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      };

      _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types.colon);
        var type = null;
        var predicate = null;

        if (this.match(types.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;

          if (this.match(types.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }

        return [type, predicate];
      };

      _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      };

      _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
        this.next();
        var id = node.id = this.parseIdentifier();
        var typeNode = this.startNode();
        var typeContainer = this.startNode();

        if (this.isRelational("<")) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }

        this.expect(types.parenL);
        var tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        this.expect(types.parenR);

        var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

        typeNode.returnType = _this$flowParseTypeAn[0];
        node.predicate = _this$flowParseTypeAn[1];
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        return this.finishNode(node, "DeclareFunction");
      };

      _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
        if (this.match(types._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual("module")) {
          if (this.match(types.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
            }

            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual("type")) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual("opaque")) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual("interface")) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      };

      _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      };

      _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
        var _this2 = this;

        this.scope.enter(SCOPE_OTHER);

        if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }

        var bodyNode = node.body = this.startNode();
        var body = bodyNode.body = [];
        this.expect(types.braceL);

        while (!this.match(types.braceR)) {
          var _bodyNode = this.startNode();

          if (this.match(types._import)) {
            this.next();

            if (!this.isContextual("type") && !this.match(types._typeof)) {
              this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
            }

            this.parseImport(_bodyNode);
          } else {
            this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
            _bodyNode = this.flowParseDeclare(_bodyNode, true);
          }

          body.push(_bodyNode);
        }

        this.scope.exit();
        this.expect(types.braceR);
        this.finishNode(bodyNode, "BlockStatement");
        var kind = null;
        var hasModuleExport = false;
        body.forEach(function (bodyElement) {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              _this2.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
            }

            if (kind === "ES") {
              _this2.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      };

      _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types._export);

        if (this.eat(types._default)) {
          if (this.match(types._function) || this.match(types._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }

          node["default"] = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(types._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
            var label = this.state.value;
            var suggestion = exportSuggestions[label];
            throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
          }

          if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual("opaque")) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node["default"] = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node["default"] = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
        }

        throw this.unexpected();
      };

      _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual("exports");
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      };

      _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      };

      _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      };

      _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      };

      _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
        if (isClass === void 0) {
          isClass = false;
        }

        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node["extends"] = [];
        node["implements"] = [];
        node.mixins = [];

        if (this.eat(types._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(types.comma));
        }

        if (this.isContextual("mixins")) {
          this.next();

          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        if (this.isContextual("implements")) {
          this.next();

          do {
            node["implements"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      };

      _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
        var node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        return this.finishNode(node, "InterfaceExtends");
      };

      _proto.flowParseInterface = function flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      };

      _proto.checkNotUnderscore = function checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
      };

      _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
      };

      _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      };

      _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.right = this.flowParseTypeInitialiser(types.eq);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      };

      _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
        this.expectContextual("type");
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.supertype = null;

        if (this.match(types.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types.colon);
        }

        node.impltype = null;

        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types.eq);
        }

        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      };

      _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
        if (requireDefault === void 0) {
          requireDefault = false;
        }

        var nodeStart = this.state.start;
        var node = this.startNode();
        var variance = this.flowParseVariance();
        var ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;

        if (this.match(types.eq)) {
          this.eat(types.eq);
          node["default"] = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
          }
        }

        return this.finishNode(node, "TypeParameter");
      };

      _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
        var oldInType = this.state.inType;
        var node = this.startNode();
        node.params = [];
        this.state.inType = true;

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        var defaultRequired = false;

        do {
          var typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);

          if (typeParameter["default"]) {
            defaultRequired = true;
          }

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        } while (!this.isRelational(">"));

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      };

      _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseType());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());

          if (!this.isRelational(">")) {
            this.expect(types.comma);
          }
        }

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseInterfaceType = function flowParseInterfaceType() {
        var node = this.startNode();
        this.expectContextual("interface");
        node["extends"] = [];

        if (this.eat(types._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      };

      _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
        return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      };

      _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
        node["static"] = isStatic;

        if (this.lookahead().type === types.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }

        this.expect(types.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      };

      _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
        node["static"] = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types.bracketR);
        this.expect(types.bracketR);

        if (this.isRelational("<") || this.match(types.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;

          if (this.eat(types.question)) {
            node.optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
        }

        return this.finishNode(node, "ObjectTypeInternalSlot");
      };

      _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        this.expect(types.parenL);

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam();
        }

        this.expect(types.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      };

      _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
        var valueNode = this.startNode();
        node["static"] = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      };

      _proto.flowParseObjectType = function flowParseObjectType(_ref) {
        var allowStatic = _ref.allowStatic,
            allowExact = _ref.allowExact,
            allowSpread = _ref.allowSpread,
            allowProto = _ref.allowProto,
            allowInexact = _ref.allowInexact;
        var oldInType = this.state.inType;
        this.state.inType = true;
        var nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        var endDelim;
        var exact;
        var inexact = false;

        if (allowExact && this.match(types.braceBarL)) {
          this.expect(types.braceBarL);
          endDelim = types.braceBarR;
          exact = true;
        } else {
          this.expect(types.braceL);
          endDelim = types.braceR;
          exact = false;
        }

        nodeStart.exact = exact;

        while (!this.match(endDelim)) {
          var isStatic = false;
          var protoStart = null;
          var inexactStart = null;
          var node = this.startNode();

          if (allowProto && this.isContextual("proto")) {
            var lookahead = this.lookahead();

            if (lookahead.type !== types.colon && lookahead.type !== types.question) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }

          if (allowStatic && this.isContextual("static")) {
            var _lookahead = this.lookahead();

            if (_lookahead.type !== types.colon && _lookahead.type !== types.question) {
              this.next();
              isStatic = true;
            }
          }

          var variance = this.flowParseVariance();

          if (this.eat(types.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (this.eat(types.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(types.parenL) || this.isRelational("<")) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            var kind = "init";

            if (this.isContextual("get") || this.isContextual("set")) {
              var _lookahead2 = this.lookahead();

              if (_lookahead2.type === types.name || _lookahead2.type === types.string || _lookahead2.type === types.num) {
                kind = this.state.value;
                this.next();
              }
            }

            var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }

          this.flowObjectTypeSemicolon();

          if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {
            this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
          }
        }

        this.expect(endDelim);

        if (allowSpread) {
          nodeStart.inexact = inexact;
        }

        var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      };

      _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types.ellipsis)) {
          var isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);

          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
            } else if (!allowInexact) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.InexactVariance);
            }

            return null;
          }

          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
          }

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.SpreadVariance);
          }

          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node["static"] = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          var optional = false;

          if (this.isRelational("<") || this.match(types.parenL)) {
            node.method = true;

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;

            if (this.eat(types.question)) {
              optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }

          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      };

      _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
        var paramCount = property.kind === "get" ? 0 : 1;
        var start = property.start;
        var length = property.value.params.length + (property.value.rest ? 1 : 0);

        if (length !== paramCount) {
          if (property.kind === "get") {
            this.raise(start, ErrorMessages.BadGetterArity);
          } else {
            this.raise(start, ErrorMessages.BadSetterArity);
          }
        }

        if (property.kind === "set" && property.value.rest) {
          this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
      };

      _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
        if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
          this.unexpected();
        }
      };

      _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        var node = id || this.flowParseRestrictedIdentifier(true);

        while (this.eat(types.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }

        return node;
      };

      _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
        var node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }

        return this.finishNode(node, "GenericTypeAnnotation");
      };

      _proto.flowParseTypeofType = function flowParseTypeofType() {
        var node = this.startNode();
        this.expect(types._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      };

      _proto.flowParseTupleType = function flowParseTupleType() {
        var node = this.startNode();
        node.types = [];
        this.expect(types.bracketL);

        while (this.state.pos < this.length && !this.match(types.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types.bracketR)) break;
          this.expect(types.comma);
        }

        this.expect(types.bracketR);
        return this.finishNode(node, "TupleTypeAnnotation");
      };

      _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {
        var name = null;
        var optional = false;
        var typeAnnotation = null;
        var node = this.startNode();
        var lh = this.lookahead();

        if (lh.type === types.colon || lh.type === types.question) {
          name = this.parseIdentifier();

          if (this.eat(types.question)) {
            optional = true;
          }

          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }

        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
        var node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
        if (params === void 0) {
          params = [];
        }

        var rest = null;

        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam());

          if (!this.match(types.parenR)) {
            this.expect(types.comma);
          }
        }

        if (this.eat(types.ellipsis)) {
          rest = this.flowParseFunctionTypeParam();
        }

        return {
          params: params,
          rest: rest
        };
      };

      _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");

          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");

          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");

          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");

          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");

          case "string":
            return this.finishNode(node, "StringTypeAnnotation");

          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");

          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      };

      _proto.flowParsePrimaryType = function flowParsePrimaryType() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.startNode();
        var tmp;
        var type;
        var isGroupedType = false;
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;

        switch (this.state.type) {
          case types.name:
            if (this.isContextual("interface")) {
              return this.flowParseInterfaceType();
            }

            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

          case types.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });

          case types.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });

          case types.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;

          case types.relational:
            if (this.state.value === "<") {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              this.expect(types.parenR);
              this.expect(types.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            }

            break;

          case types.parenL:
            this.next();

            if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
              if (this.match(types.name)) {
                var token = this.lookahead().type;
                isGroupedType = token !== types.question && token !== types.colon;
              } else {
                isGroupedType = true;
              }
            }

            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;

              if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
                this.expect(types.parenR);
                return type;
              } else {
                this.eat(types.comma);
              }
            }

            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }

            node.params = tmp.params;
            node.rest = tmp.rest;
            this.expect(types.parenR);
            this.expect(types.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");

          case types.string:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

          case types._true:
          case types._false:
            node.value = this.match(types._true);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");

          case types.plusMin:
            if (this.state.value === "-") {
              this.next();

              if (this.match(types.num)) {
                return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
              }

              if (this.match(types.bigint)) {
                return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", node.start, node.loc.start);
              }

              throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
            }

            throw this.unexpected();

          case types.num:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

          case types.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

          case types._void:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");

          case types._null:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");

          case types._this:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");

          case types.star:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");

          default:
            if (this.state.type.keyword === "typeof") {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              var label = this.state.type.label;
              this.next();
              return _superClass.prototype.createIdentifier.call(this, node, label);
            }

        }

        throw this.unexpected();
      };

      _proto.flowParsePostfixType = function flowParsePostfixType() {
        var startPos = this.state.start,
            startLoc = this.state.startLoc;
        var type = this.flowParsePrimaryType();

        while (this.match(types.bracketL) && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(startPos, startLoc);
          node.elementType = type;
          this.expect(types.bracketL);
          this.expect(types.bracketR);
          type = this.finishNode(node, "ArrayTypeAnnotation");
        }

        return type;
      };

      _proto.flowParsePrefixType = function flowParsePrefixType() {
        var node = this.startNode();

        if (this.eat(types.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      };

      _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
        var param = this.flowParsePrefixType();

        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
          var node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        return param;
      };

      _proto.flowParseIntersectionType = function flowParseIntersectionType() {
        var node = this.startNode();
        this.eat(types.bitwiseAND);
        var type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];

        while (this.eat(types.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      };

      _proto.flowParseUnionType = function flowParseUnionType() {
        var node = this.startNode();
        this.eat(types.bitwiseOR);
        var type = this.flowParseIntersectionType();
        node.types = [type];

        while (this.eat(types.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      };

      _proto.flowParseType = function flowParseType() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        var type = this.flowParseUnionType();
        this.state.inType = oldInType;
        this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;
        return type;
      };

      _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types.name && this.state.value === "_") {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      };

      _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
        var node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      };

      _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

        if (this.match(types.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }

        return ident;
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.flowParseVariance = function flowParseVariance() {
        var variance = null;

        if (this.match(types.plusMin)) {
          variance = this.startNode();

          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }

          this.next();
          this.finishNode(variance, "Variance");
        }

        return variance;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
        var _this3 = this;

        if (isMethod === void 0) {
          isMethod = false;
        }

        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, function () {
            return _superClass.prototype.parseFunctionBody.call(_this3, node, true, isMethod);
          });
        }

        return _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types.colon)) {
          var typeNode = this.startNode();

          var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

          typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.parseStatement = function parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
          var lookahead = this.lookahead();

          if (lookahead.type === types.name || isKeyword(lookahead.value)) {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          var _node = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_node);
        }

        var stmt = _superClass.prototype.parseStatement.call(this, context, topLevel);

        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }

        return stmt;
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }

        return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
          return false;
        }

        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          var node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
        var _this4 = this;

        if (!this.match(types.question)) return expr;

        if (refNeedsArrowPos) {
          var result = this.tryParse(function () {
            return _superClass.prototype.parseConditional.call(_this4, expr, startPos, startLoc);
          });

          if (!result.node) {
            refNeedsArrowPos.start = result.error.pos || this.state.start;
            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }

        this.expect(types.question);
        var state = this.state.clone();
        var originalNoArrowAt = this.state.noArrowAt;
        var node = this.startNodeAt(startPos, startLoc);

        var _this$tryParseConditi = this.tryParseConditionalConsequent(),
            consequent = _this$tryParseConditi.consequent,
            failed = _this$tryParseConditi.failed;

        var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
            valid = _this$getArrowLikeExp[0],
            invalid = _this$getArrowLikeExp[1];

        if (failed || invalid.length > 0) {
          var noArrowAt = [].concat(originalNoArrowAt);

          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;

            for (var i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }

            var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi2.consequent;
            failed = _this$tryParseConditi2.failed;

            var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

            valid = _this$getArrowLikeExp2[0];
            invalid = _this$getArrowLikeExp2[1];
          }

          if (failed && valid.length > 1) {
            this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
          }

          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);

            var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi3.consequent;
            failed = _this$tryParseConditi3.failed;
          }
        }

        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
          return _this4.parseMaybeAssign(undefined, undefined, undefined);
        });
        return this.finishNode(node, "ConditionalExpression");
      };

      _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        var consequent = this.parseMaybeAssignAllowIn();
        var failed = !this.match(types.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent: consequent,
          failed: failed
        };
      };

      _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
        var _this5 = this;

        var stack = [node];
        var arrows = [];

        while (stack.length !== 0) {
          var _node2 = stack.pop();

          if (_node2.type === "ArrowFunctionExpression") {
            if (_node2.typeParameters || !_node2.returnType) {
              this.finishArrowValidation(_node2);
            } else {
              arrows.push(_node2);
            }

            stack.push(_node2.body);
          } else if (_node2.type === "ConditionalExpression") {
            stack.push(_node2.consequent);
            stack.push(_node2.alternate);
          }
        }

        if (disallowInvalid) {
          arrows.forEach(function (node) {
            return _this5.finishArrowValidation(node);
          });
          return [arrows, []];
        }

        return partition(arrows, function (node) {
          return node.params.every(function (param) {
            return _this5.isAssignable(param, true);
          });
        });
      };

      _proto.finishArrowValidation = function finishArrowValidation(node) {
        var _node$extra;

        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

        _superClass.prototype.checkParams.call(this, node, false, true);

        this.scope.exit();
      };

      _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
        var result;

        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }

        return result;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }

        return node;
      };

      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }

        _superClass.prototype.assertModuleNodeAllowed.call(this, node);
      };

      _proto.parseExport = function parseExport(node) {
        var decl = _superClass.prototype.parseExport.call(this, node);

        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }

        return decl;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();

          if (this.match(types.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("opaque")) {
          node.exportKind = "type";

          var _declarationNode = this.startNode();

          this.next();
          return this.flowParseOpaqueType(_declarationNode, false);
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";

          var _declarationNode2 = this.startNode();

          this.next();
          return this.flowParseInterface(_declarationNode2);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";

          var _declarationNode3 = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_declarationNode3);
        } else {
          return _superClass.prototype.parseExportDeclaration.call(this, node);
        }
      };

      _proto.eatExportStar = function eatExportStar(node) {
        if (_superClass.prototype.eatExportStar.apply(this, arguments)) return true;

        if (this.isContextual("type") && this.lookahead().type === types.star) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }

        return false;
      };

      _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
        var pos = this.state.start;

        var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);

        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(pos);
        }

        return hasNamespace;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var pos = this.state.start;

        if (this.isContextual("declare")) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }

          member.declare = true;
        }

        _superClass.prototype.parseClassMember.call(this, classBody, member, state);

        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty") {
            this.raise(pos, FlowErrors.DeclareClassElement);
          } else if (member.value) {
            this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
          }
        }
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 123 && next === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else if (this.state.inType && code === 63) {
          return this.finishOp(types.question, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.isIterator = true;
          return _superClass.prototype.readWord.call(this);
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.isAssignable = function isAssignable(node, isBinding) {
        var _this6 = this;

        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            return true;

          case "ObjectExpression":
            {
              var last = node.properties.length - 1;
              return node.properties.every(function (prop, i) {
                return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && _this6.isAssignable(prop);
              });
            }

          case "ObjectProperty":
            return this.isAssignable(node.value);

          case "SpreadElement":
            return this.isAssignable(node.argument);

          case "ArrayExpression":
            return node.elements.every(function (element) {
              return _this6.isAssignable(element);
            });

          case "AssignmentExpression":
            return node.operator === "=";

          case "ParenthesizedExpression":
          case "TypeCastExpression":
            return this.isAssignable(node.expression);

          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;

          default:
            return false;
        }
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        if (node.type === "TypeCastExpression") {
          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);
        } else {
          return _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }

        return _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaPos, isLHS);
      };

      _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
        for (var i = 0; i < exprList.length; i++) {
          var _expr$extra;

          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) == null ? void 0 : _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
          }
        }

        return exprList;
      };

      _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        var node = _superClass.prototype.parseArrayLike.call(this, close, canBePattern, isTuple, refExpressionErrors);

        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }

        return node;
      };

      _proto.checkLVal = function checkLVal(expr) {
        if (expr.type !== "TypeCastExpression") {
          var _superClass$prototype;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return (_superClass$prototype = _superClass.prototype.checkLVal).call.apply(_superClass$prototype, [this, expr].concat(args));
        }
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (this.match(types.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
        return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }

        if (this.isContextual("implements")) {
          this.next();
          var implemented = node["implements"] = [];

          do {
            var _node3 = this.startNode();

            _node3.id = this.flowParseRestrictedIdentifier(true);

            if (this.isRelational("<")) {
              _node3.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node3.typeParameters = null;
            }

            implemented.push(this.finishNode(_node3, "ClassImplements"));
          } while (this.eat(types.comma));
        }
      };

      _proto.parsePropertyName = function parsePropertyName(node, isPrivateNameAllowed) {
        var variance = this.flowParseVariance();

        var key = _superClass.prototype.parsePropertyName.call(this, node, isPrivateNameAllowed);

        node.variance = variance;
        return key;
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }

        delete prop.variance;
        var typeParameters;

        if (this.isRelational("<") && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types.parenL)) this.unexpected();
        }

        _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, FlowErrors.OptionalBindingPattern);
          }

          param.optional = true;
        }

        if (this.match(types.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        }

        this.resetEndLocation(param);
        return param;
      };

      _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
        var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
        }

        return node;
      };

      _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return _superClass.prototype.shouldParseDefaultImport.call(this, node);
        }

        return isMaybeDefaultImport(this.state);
      };

      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      };

      _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        var kind = null;

        if (this.match(types._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }

        if (kind) {
          var lh = this.lookahead();

          if (kind === "type" && lh.type === types.star) {
            this.unexpected(lh.start);
          }

          if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {
            this.next();
            node.importKind = kind;
          }
        }

        return _superClass.prototype.maybeParseDefaultImportSpecifier.call(this, node);
      };

      _proto.parseImportSpecifier = function parseImportSpecifier(node) {
        var specifier = this.startNode();
        var firstIdentLoc = this.state.start;
        var firstIdent = this.parseModuleExportName();
        var specifierTypeKind = null;

        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }

        var isBinding = false;

        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          var as_ident = this.parseIdentifier(true);

          if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = as_ident.__clone();
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;

          if (this.eatContextual("as")) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = specifier.imported.__clone();
          }
        } else {
          if (firstIdent.type === "StringLiteral") {
            throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
          }

          isBinding = true;
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = specifier.imported.__clone();
        }

        var nodeIsTypeImport = hasTypeImportKind(node);
        var specifierIsTypeImport = hasTypeImportKind(specifier);

        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);
        }

        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.start, true);
        }

        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.start, true, true);
        }

        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var kind = node.kind;

        if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (this.match(types.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
        var _this7 = this,
            _jsx;

        var state = null;
        var jsx;

        if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this7, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (((_jsx = jsx) == null ? void 0 : _jsx.error) || this.isRelational("<")) {
          var _jsx2, _jsx3;

          state = state || this.state.clone();
          var typeParameters;
          var arrow = this.tryParse(function (abort) {
            var _arrowExpression$extr;

            typeParameters = _this7.flowParseTypeParameterDeclaration();

            var arrowExpression = _this7.forwardNoArrowParamsConversionAt(typeParameters, function () {
              var result = _superClass.prototype.parseMaybeAssign.call(_this7, refExpressionErrors, afterLeftParse, refNeedsArrowPos);

              _this7.resetStartLocationFromNode(result, typeParameters);

              return result;
            });

            if (arrowExpression.type !== "ArrowFunctionExpression" && ((_arrowExpression$extr = arrowExpression.extra) == null ? void 0 : _arrowExpression$extr.parenthesized)) {
              abort();
            }

            var expr = _this7.maybeUnwrapTypeCastExpression(arrowExpression);

            expr.typeParameters = typeParameters;

            _this7.resetStartLocationFromNode(expr, typeParameters);

            return arrowExpression;
          }, state);
          var arrowExpression = null;

          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
              }

              return arrow.node;
            }

            arrowExpression = arrow.node;
          }

          if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }

          if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
        }

        return _superClass.prototype.parseMaybeAssign.call(this, refExpressionErrors, afterLeftParse, refNeedsArrowPos);
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this8 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function () {
            var oldNoAnonFunctionType = _this8.state.noAnonFunctionType;
            _this8.state.noAnonFunctionType = true;

            var typeNode = _this8.startNode();

            var _this8$flowParseTypeA = _this8.flowParseTypeAndPredicateInitialiser();

            typeNode.typeAnnotation = _this8$flowParseTypeA[0];
            node.predicate = _this8$flowParseTypeA[1];
            _this8.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_this8.canInsertSemicolon()) _this8.unexpected();
            if (!_this8.match(types.arrow)) _this8.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
        }
      };

      _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }

        return _superClass.prototype.checkParams.apply(this, arguments);
      };

      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
        return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      };

      _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
        var _this9 = this;

        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
          var state = this.state.clone();
          var arrow = this.tryParse(function (abort) {
            return _this9.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          var result = this.tryParse(function () {
            return _superClass.prototype.parseSubscripts.call(_this9, base, startPos, startLoc, noCalls);
          }, state);
          if (result.node && !result.error) return result.node;

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (result.node) {
            this.state = result.failState;
            return result.node;
          }

          throw arrow.error || result.error;
        }

        return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        var _this10 = this;

        if (this.match(types.questionDot) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;

          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }

          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types.parenL);
          node.arguments = this.parseCallExpressionArguments(types.parenR, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          var _node4 = this.startNodeAt(startPos, startLoc);

          _node4.callee = base;
          var result = this.tryParse(function () {
            _node4.typeArguments = _this10.flowParseTypeParameterInstantiationCallOrNew();

            _this10.expect(types.parenL);

            _node4.arguments = _this10.parseCallExpressionArguments(types.parenR, false);
            if (subscriptState.optionalChainMember) _node4.optional = false;
            return _this10.finishCallExpression(_node4, subscriptState.optionalChainMember);
          });

          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this11 = this;

        var targs = null;

        if (this.shouldParseTypes() && this.isRelational("<")) {
          targs = this.tryParse(function () {
            return _this11.flowParseTypeParameterInstantiationCallOrNew();
          }).node;
        }

        node.typeArguments = targs;

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node)) return;
        return this.parseArrowExpression(node, undefined, true);
      };

      _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }

        _superClass.prototype.readToken_mult_modulo.call(this, code);
      };

      _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 124 && next === 125) {
          this.finishOp(types.braceBarR, 2);
          return;
        }

        _superClass.prototype.readToken_pipe_amp.call(this, code);
      };

      _proto.parseTopLevel = function parseTopLevel(file, program) {
        var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);

        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
        }

        return fileNode;
      };

      _proto.skipBlockComment = function skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, FlowErrors.NestedFlowComment);
          }

          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }

        if (this.state.hasFlowComment) {
          var end = this.input.indexOf("*-/", this.state.pos += 2);

          if (end === -1) {
            throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
          }

          this.state.pos = end + 3;
          return;
        }

        _superClass.prototype.skipBlockComment.call(this);
      };

      _proto.skipFlowComment = function skipFlowComment() {
        var pos = this.state.pos;
        var shiftToFirstNonWhiteSpace = 2;

        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }

        var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }

        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }

        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }

        return false;
      };

      _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
        var end = this.input.indexOf("*/", this.state.pos);

        if (end === -1) {
          throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
        }
      };

      _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(pos, _ref2) {
        var enumName = _ref2.enumName,
            memberName = _ref2.memberName;
        this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
      };

      _proto.flowEnumErrorInvalidMemberName = function flowEnumErrorInvalidMemberName(pos, _ref3) {
        var enumName = _ref3.enumName,
            memberName = _ref3.memberName;
        var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
      };

      _proto.flowEnumErrorDuplicateMemberName = function flowEnumErrorDuplicateMemberName(pos, _ref4) {
        var enumName = _ref4.enumName,
            memberName = _ref4.memberName;
        this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
      };

      _proto.flowEnumErrorInconsistentMemberValues = function flowEnumErrorInconsistentMemberValues(pos, _ref5) {
        var enumName = _ref5.enumName;
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      };

      _proto.flowEnumErrorInvalidExplicitType = function flowEnumErrorInvalidExplicitType(pos, _ref6) {
        var enumName = _ref6.enumName,
            suppliedType = _ref6.suppliedType;
        return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
      };

      _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(pos, _ref7) {
        var enumName = _ref7.enumName,
            explicitType = _ref7.explicitType,
            memberName = _ref7.memberName;
        var message = null;

        switch (explicitType) {
          case "boolean":
          case "number":
          case "string":
            message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
            break;

          case "symbol":
            message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
            break;

          default:
            message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }

        return this.raise(pos, message, enumName, memberName, explicitType);
      };

      _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(pos, _ref8) {
        var enumName = _ref8.enumName,
            memberName = _ref8.memberName;
        this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
      };

      _proto.flowEnumErrorStringMemberInconsistentlyInitailized = function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref9) {
        var enumName = _ref9.enumName;
        this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
      };

      _proto.flowEnumMemberInit = function flowEnumMemberInit() {
        var _this12 = this;

        var startPos = this.state.start;

        var endOfInit = function endOfInit() {
          return _this12.match(types.comma) || _this12.match(types.braceR);
        };

        switch (this.state.type) {
          case types.num:
            {
              var literal = this.parseLiteral(this.state.value, "NumericLiteral");

              if (endOfInit()) {
                return {
                  type: "number",
                  pos: literal.start,
                  value: literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types.string:
            {
              var _literal = this.parseLiteral(this.state.value, "StringLiteral");

              if (endOfInit()) {
                return {
                  type: "string",
                  pos: _literal.start,
                  value: _literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types._true:
          case types._false:
            {
              var _literal2 = this.parseBooleanLiteral();

              if (endOfInit()) {
                return {
                  type: "boolean",
                  pos: _literal2.start,
                  value: _literal2
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          default:
            return {
              type: "invalid",
              pos: startPos
            };
        }
      };

      _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
        var pos = this.state.start;
        var id = this.parseIdentifier(true);
        var init = this.eat(types.eq) ? this.flowEnumMemberInit() : {
          type: "none",
          pos: pos
        };
        return {
          id: id,
          init: init
        };
      };

      _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        var explicitType = context.explicitType;

        if (explicitType === null) {
          return;
        }

        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      };

      _proto.flowEnumMembers = function flowEnumMembers(_ref10) {
        var enumName = _ref10.enumName,
            explicitType = _ref10.explicitType;
        var seenNames = new Set();
        var members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };

        while (!this.match(types.braceR)) {
          var memberNode = this.startNode();

          var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
              id = _this$flowEnumMemberR.id,
              init = _this$flowEnumMemberR.init;

          var memberName = id.name;

          if (memberName === "") {
            continue;
          }

          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          seenNames.add(memberName);
          var context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          memberNode.id = id;

          switch (init.type) {
            case "boolean":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }

            case "number":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }

            case "string":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }

            case "invalid":
              {
                throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
              }

            case "none":
              {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                    break;

                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                    break;

                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
          }

          if (!this.match(types.braceR)) {
            this.expect(types.comma);
          }
        }

        return members;
      };

      _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref11) {
        var enumName = _ref11.enumName;

        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
            var member = initializedMembers[_i2];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName: enumName
            });
          }

          return defaultedMembers;
        } else {
          for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
            var _member = defaultedMembers[_i4];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
              enumName: enumName
            });
          }

          return initializedMembers;
        }
      };

      _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref12) {
        var enumName = _ref12.enumName;

        if (this.eatContextual("of")) {
          if (!this.match(types.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: null
            });
          }

          var value = this.state.value;
          this.next();

          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: value
            });
          }

          return value;
        }

        return null;
      };

      _proto.flowEnumBody = function flowEnumBody(node, _ref13) {
        var _this13 = this;

        var enumName = _ref13.enumName,
            nameLoc = _ref13.nameLoc;
        var explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(types.braceL);
        var members = this.flowEnumMembers({
          enumName: enumName,
          explicitType: explicitType
        });

        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumBooleanBody");

          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumNumberBody");

          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName: enumName
            });
            this.expect(types.braceR);
            return this.finishNode(node, "EnumStringBody");

          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(types.braceR);
            return this.finishNode(node, "EnumSymbolBody");

          default:
            {
              var empty = function empty() {
                node.members = [];

                _this13.expect(types.braceR);

                return _this13.finishNode(node, "EnumStringBody");
              };

              node.explicitType = false;
              var boolsLen = members.booleanMembers.length;
              var numsLen = members.numberMembers.length;
              var strsLen = members.stringMembers.length;
              var defaultedLen = members.defaultedMembers.length;

              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName: enumName
                });
                this.expect(types.braceR);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
                  var member = _members$defaultedMem2[_i6];
                  this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                    enumName: enumName,
                    memberName: member.id.name
                  });
                }

                node.members = members.booleanMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
                  var _member2 = _members$defaultedMem4[_i8];
                  this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                    enumName: enumName,
                    memberName: _member2.id.name
                  });
                }

                node.members = members.numberMembers;
                this.expect(types.braceR);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                  enumName: enumName
                });
                return empty();
              }
            }
        }
      };

      _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
        var id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        });
        return this.finishNode(node, "EnumDeclaration");
      };

      _proto.updateContext = function updateContext(prevType) {
        if (this.match(types.name) && this.state.value === "of" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === "interface") {
          this.state.exprAllowed = false;
        } else {
          _superClass.prototype.updateContext.call(this, prevType);
        }
      };

      _proto.isLookaheadToken_lt = function isLookaheadToken_lt() {
        var next = this.nextTokenStart();

        if (this.input.charCodeAt(next) === 60) {
          var afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }

        return false;
      };

      _proto.maybeUnwrapTypeCastExpression = function maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      };

      return _temp;
    }(superClass), _temp;
  });

  var entities = {
    quot: "\"",
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  var HEX_NUMBER = /^[\da-fA-F]+$/;
  var DECIMAL_NUMBER = /^\d+$/;
  var JsxErrors = Object.freeze({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text",
    UnterminatedJsxContent: "Unterminated JSX contents",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  types$1.j_oTag = new TokContext("<tag", false);
  types$1.j_cTag = new TokContext("</tag", false);
  types$1.j_expr = new TokContext("<tag>...</tag>", true, true);
  types.jsxName = new TokenType("jsxName");
  types.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types.jsxTagEnd = new TokenType("jsxTagEnd");

  types.jsxTagStart.updateContext = function () {
    this.state.context.push(types$1.j_expr);
    this.state.context.push(types$1.j_oTag);
    this.state.exprAllowed = false;
  };

  types.jsxTagEnd.updateContext = function (prevType) {
    var out = this.state.context.pop();

    if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
      this.state.context.pop();
      this.state.exprAllowed = this.curContext() === types$1.j_expr;
    } else {
      this.state.exprAllowed = true;
    }
  };

  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }

    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }

    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }

    throw new Error("Node had unexpected type: " + object.type);
  }

  var jsx = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.jsxReadToken = function jsxReadToken() {
        var out = "";
        var chunkStart = this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
          }

          var ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types.jsxTagStart);
                }

                return _superClass.prototype.getTokenFromCode.call(this, ch);
              }

              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types.jsxText, out);

            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;

            case 62:
            case 125:
              if (process.env.BABEL_8_BREAKING) {
                var htmlEntity = ch === 125 ? "&rbrace;" : "&gt;";
                var _char = this.input[this.state.pos];
                this.raise(this.state.pos, "Unexpected token `" + _char + "`. Did you mean `" + htmlEntity + "` or `{'" + _char + "'}`?");
              }

            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }

          }
        }
      };

      _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
        var ch = this.input.charCodeAt(this.state.pos);
        var out;
        ++this.state.pos;

        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      };

      _proto.jsxReadString = function jsxReadString(quote) {
        var out = "";
        var chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          }

          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types.string, out);
      };

      _proto.jsxReadEntity = function jsxReadEntity() {
        var str = "";
        var count = 0;
        var entity;
        var ch = this.input[this.state.pos];
        var startPos = ++this.state.pos;

        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];

          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);

                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);

                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }

            break;
          }

          str += ch;
        }

        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }

        return entity;
      };

      _proto.jsxReadWord = function jsxReadWord() {
        var ch;
        var start = this.state.pos;

        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);

        return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
      };

      _proto.jsxParseIdentifier = function jsxParseIdentifier() {
        var node = this.startNode();

        if (this.match(types.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }

        this.next();
        return this.finishNode(node, "JSXIdentifier");
      };

      _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var name = this.jsxParseIdentifier();
        if (!this.eat(types.colon)) return name;
        var node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      };

      _proto.jsxParseElementName = function jsxParseElementName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.jsxParseNamespacedName();

        if (node.type === "JSXNamespacedName") {
          return node;
        }

        while (this.eat(types.dot)) {
          var newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }

        return node;
      };

      _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
        var node;

        switch (this.state.type) {
          case types.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);

            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(node.start, JsxErrors.AttributeIsEmpty);
            }

            return node;

          case types.jsxTagStart:
          case types.string:
            return this.parseExprAtom();

          default:
            throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      };

      _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
        var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      };

      _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types.braceR);
        return this.finishNode(node, "JSXSpreadChild");
      };

      _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node) {
        if (this.match(types.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          var expression = this.parseExpression();

          if (process.env.BABEL_8_BREAKING) {
            var _expression$extra;

            if (expression.type === "SequenceExpression" && !((_expression$extra = expression.extra) == null ? void 0 : _expression$extra.parenthesized)) {
              this.raise(expression.expressions[1].start, JsxErrors.UnexpectedSequenceExpression);
            }
          }

          node.expression = expression;
        }

        this.expect(types.braceR);
        return this.finishNode(node, "JSXExpressionContainer");
      };

      _proto.jsxParseAttribute = function jsxParseAttribute() {
        var node = this.startNode();

        if (this.eat(types.braceL)) {
          this.expect(types.ellipsis);
          node.argument = this.parseMaybeAssignAllowIn();
          this.expect(types.braceR);
          return this.finishNode(node, "JSXSpreadAttribute");
        }

        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      };

      _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningFragment");
        }

        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var attributes = [];

        while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }

        node.attributes = attributes;
        node.selfClosing = this.eat(types.slash);
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningElement");
      };

      _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types.jsxTagEnd)) {
          this.expect(types.jsxTagEnd);
          return this.finishNode(node, "JSXClosingFragment");
        }

        node.name = this.jsxParseElementName();
        this.expect(types.jsxTagEnd);
        return this.finishNode(node, "JSXClosingElement");
      };

      _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        var children = [];
        var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        var closingElement = null;

        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case types.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();

                if (this.eat(types.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }

                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

              case types.jsxText:
                children.push(this.parseExprAtom());
                break;

              case types.braceL:
                {
                  var _node = this.startNode();

                  this.next();

                  if (this.match(types.ellipsis)) {
                    children.push(this.jsxParseSpreadChild(_node));
                  } else {
                    children.push(this.jsxParseExpressionContainer(_node));
                  }

                  break;
                }

              default:
                throw this.unexpected();
            }
          }

          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            }
          }
        }

        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }

        node.children = children;

        if (this.isRelational("<")) {
          throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
        }

        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      };

      _proto.jsxParseElement = function jsxParseElement() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        if (this.match(types.jsxText)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(types.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
          this.finishToken(types.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inPropertyName) return _superClass.prototype.getTokenFromCode.call(this, code);
        var context = this.curContext();

        if (context === types$1.j_expr) {
          return this.jsxReadToken();
        }

        if (context === types$1.j_oTag || context === types$1.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }

          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context === types$1.j_oTag) {
            return this.jsxReadString(code);
          }
        }

        if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagStart);
        }

        return _superClass.prototype.getTokenFromCode.call(this, code);
      };

      _proto.updateContext = function updateContext(prevType) {
        if (this.match(types.braceL)) {
          var curContext = this.curContext();

          if (curContext === types$1.j_oTag) {
            this.state.context.push(types$1.braceExpression);
          } else if (curContext === types$1.j_expr) {
            this.state.context.push(types$1.templateQuasi);
          } else {
            _superClass.prototype.updateContext.call(this, prevType);
          }

          this.state.exprAllowed = true;
        } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
          this.state.context.length -= 2;
          this.state.context.push(types$1.j_cTag);
          this.state.exprAllowed = false;
        } else {
          return _superClass.prototype.updateContext.call(this, prevType);
        }
      };

      return _class;
    }(superClass);
  });

  var Scope$2 = function Scope(flags) {
    this.flags = void 0;
    this["var"] = [];
    this.lexical = [];
    this.functions = [];
    this.flags = flags;
  };

  var ScopeHandler = function () {
    function ScopeHandler(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    var _proto = ScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new Scope$2(flags);
    };

    _proto.enter = function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    };

    _proto.exit = function exit() {
      this.scopeStack.pop();
    };

    _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.push(name);
        } else {
          scope.lexical.push(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope["var"].push(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope["var"].indexOf(name) > -1;
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope["var"].indexOf(name) > -1;
      }

      return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0]["var"].indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {
        this.undefinedExports.set(id.name, id.start);
      }
    };

    _proto.currentScope = function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    };

    _proto.currentVarScope = function currentVarScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if (scope.flags & SCOPE_VAR) {
          return scope;
        }
      }
    };

    _proto.currentThisScope = function currentThisScope() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var scope = this.scopeStack[i];

        if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };

    _createClass(ScopeHandler, [{
      key: "inFunction",
      get: function get() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "allowSuper",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_SUPER) > 0;
      }
    }, {
      key: "allowDirectSuper",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      }
    }, {
      key: "inClass",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_CLASS) > 0;
      }
    }, {
      key: "inNonArrowFunction",
      get: function get() {
        return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "treatFunctionsAsVar",
      get: function get() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
    }]);

    return ScopeHandler;
  }();

  var TypeScriptScope = function (_Scope) {
    _inheritsLoose(TypeScriptScope, _Scope);

    function TypeScriptScope() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.types = [];
      _this.enums = [];
      _this.constEnums = [];
      _this.classes = [];
      _this.exportOnlyBindings = [];
      return _this;
    }

    return TypeScriptScope;
  }(Scope$2);

  var TypeScriptScopeHandler = function (_ScopeHandler) {
    _inheritsLoose(TypeScriptScopeHandler, _ScopeHandler);

    function TypeScriptScopeHandler() {
      return _ScopeHandler.apply(this, arguments) || this;
    }

    var _proto = TypeScriptScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new TypeScriptScope(flags);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.push(name);
        return;
      }

      _ScopeHandler.prototype.declareName.apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.push(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.indexOf(name) > -1) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.indexOf(name) > -1;
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {
        if (scope.lexical.indexOf(name) > -1) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {
        return true;
      }

      return _ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments);
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {
        _ScopeHandler.prototype.checkLocalExport.call(this, id);
      }
    };

    return TypeScriptScopeHandler;
  }(ScopeHandler);

  var PARAM = 0,
      PARAM_YIELD = 1,
      PARAM_AWAIT = 2,
      PARAM_RETURN = 4,
      PARAM_IN = 8;

  var ProductionParameterHandler = function () {
    function ProductionParameterHandler() {
      this.stacks = [];
    }

    var _proto = ProductionParameterHandler.prototype;

    _proto.enter = function enter(flags) {
      this.stacks.push(flags);
    };

    _proto.exit = function exit() {
      this.stacks.pop();
    };

    _proto.currentFlags = function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    };

    _createClass(ProductionParameterHandler, [{
      key: "hasAwait",
      get: function get() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
    }, {
      key: "hasYield",
      get: function get() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
    }, {
      key: "hasReturn",
      get: function get() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
    }, {
      key: "hasIn",
      get: function get() {
        return (this.currentFlags() & PARAM_IN) > 0;
      }
    }]);

    return ProductionParameterHandler;
  }();
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error("Unexpected " + x + " value.");
    }

    return x;
  }

  function assert$1(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }

  var TSErrors = Object.freeze({
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateModifier: "Duplicate modifier: '%0'",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier",
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0"
  });

  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";

      case "boolean":
        return "TSBooleanKeyword";

      case "bigint":
        return "TSBigIntKeyword";

      case "never":
        return "TSNeverKeyword";

      case "number":
        return "TSNumberKeyword";

      case "object":
        return "TSObjectKeyword";

      case "string":
        return "TSStringKeyword";

      case "symbol":
        return "TSSymbolKeyword";

      case "undefined":
        return "TSUndefinedKeyword";

      case "unknown":
        return "TSUnknownKeyword";

      default:
        return undefined;
    }
  }

  var typescript = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.getScopeHandler = function getScopeHandler() {
        return TypeScriptScopeHandler;
      };

      _proto.tsIsIdentifier = function tsIsIdentifier() {
        return this.match(types.name);
      };

      _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
        this.next();
        return (this.match(types.bracketL) || this.match(types.braceL) || this.match(types.star) || this.match(types.ellipsis) || this.match(types.hash) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      };

      _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {
        if (!this.match(types.name)) {
          return undefined;
        }

        var modifier = this.state.value;

        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }

        return undefined;
      };

      _proto.tsParseModifiers = function tsParseModifiers(modified, allowedModifiers) {
        for (;;) {
          var startPos = this.state.start;
          var modifier = this.tsParseModifier(allowedModifiers);
          if (!modifier) break;

          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(startPos, TSErrors.DuplicateModifier, modifier);
          }

          modified[modifier] = true;
        }
      };

      _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(types.braceR);

          case "HeritageClauseElement":
            return this.match(types.braceL);

          case "TupleElementTypes":
            return this.match(types.bracketR);

          case "TypeParametersOrArguments":
            return this.isRelational(">");
        }

        throw new Error("Unreachable");
      };

      _proto.tsParseList = function tsParseList(kind, parseElement) {
        var result = [];

        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }

        return result;
      };

      _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
      };

      _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        var result = [];

        for (;;) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }

          var element = parseElement();

          if (element == null) {
            return undefined;
          }

          result.push(element);

          if (this.eat(types.comma)) {
            continue;
          }

          if (this.tsIsListTerminator(kind)) {
            break;
          }

          if (expectSuccess) {
            this.expect(types.comma);
          }

          return undefined;
        }

        return result;
      };

      _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types.bracketL);
          } else {
            this.expectRelational("<");
          }
        }

        var result = this.tsParseDelimitedList(kind, parseElement);

        if (bracket) {
          this.expect(types.bracketR);
        } else {
          this.expectRelational(">");
        }

        return result;
      };

      _proto.tsParseImportType = function tsParseImportType() {
        var node = this.startNode();
        this.expect(types._import);
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
        }

        node.argument = this.parseExprAtom();
        this.expect(types.parenR);

        if (this.eat(types.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSImportType");
      };

      _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
        var entity = this.parseIdentifier();

        while (this.eat(types.dot)) {
          var node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }

        return entity;
      };

      _proto.tsParseTypeReference = function tsParseTypeReference() {
        var node = this.startNode();
        node.typeName = this.tsParseEntityName(false);

        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSTypeReference");
      };

      _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
        this.next();
        var node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      };

      _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
        var node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      };

      _proto.tsParseTypeQuery = function tsParseTypeQuery() {
        var node = this.startNode();
        this.expect(types._typeof);

        if (this.match(types._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }

        return this.finishNode(node, "TSTypeQuery");
      };

      _proto.tsParseTypeParameter = function tsParseTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsEatThenParseType(types._extends);
        node["default"] = this.tsEatThenParseType(types.eq);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
        if (this.isRelational("<")) {
          return this.tsParseTypeParameters();
        }
      };

      _proto.tsParseTypeParameters = function tsParseTypeParameters() {
        var node = this.startNode();

        if (this.isRelational("<") || this.match(types.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeParameters);
        }

        return this.finishNode(node, "TSTypeParameterDeclaration");
      };

      _proto.tsTryNextParseConstantContext = function tsTryNextParseConstantContext() {
        if (this.lookahead().type === types._const) {
          this.next();
          return this.tsParseTypeReference();
        }

        return null;
      };

      _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
        var returnTokenRequired = returnToken === types.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types.parenL);
        signature.parameters = this.tsParseBindingListForSignature();

        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      };

      _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
        var _this = this;

        return this.parseBindingList(types.parenR, 41).map(function (pattern) {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            _this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
          }

          return pattern;
        });
      };

      _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
        if (!this.eat(types.comma)) {
          this.semicolon();
        }
      };

      _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      };

      _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types.name) && this.match(types.colon);
      };

      _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
        if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return undefined;
        }

        this.expect(types.bracketL);
        var id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types.bracketR);
        node.parameters = [id];
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      };

      _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types.question)) node.optional = true;
        var nodeAny = node;

        if (!readonly && (this.match(types.parenL) || this.isRelational("<"))) {
          var method = nodeAny;
          this.tsFillSignature(types.colon, method);
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(method, "TSMethodSignature");
        } else {
          var property = nodeAny;
          if (readonly) property.readonly = true;
          var type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      };

      _proto.tsParseTypeMember = function tsParseTypeMember() {
        var node = this.startNode();

        if (this.match(types.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }

        if (this.match(types._new)) {
          var id = this.startNode();
          this.next();

          if (this.match(types.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }

        var readonly = !!this.tsParseModifier(["readonly"]);
        var idx = this.tsTryParseIndexSignature(node);

        if (idx) {
          if (readonly) node.readonly = true;
          return idx;
        }

        this.parsePropertyName(node, false);
        return this.tsParsePropertyOrMethodSignature(node, readonly);
      };

      _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
        var node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      };

      _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
        this.expect(types.braceL);
        var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(types.braceR);
        return members;
      };

      _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
        this.next();

        if (this.eat(types.plusMin)) {
          return this.isContextual("readonly");
        }

        if (this.isContextual("readonly")) {
          this.next();
        }

        if (!this.match(types.bracketL)) {
          return false;
        }

        this.next();

        if (!this.tsIsIdentifier()) {
          return false;
        }

        this.next();
        return this.match(types._in);
      };

      _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsExpectThenParseType(types._in);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsParseMappedType = function tsParseMappedType() {
        var node = this.startNode();
        this.expect(types.braceL);

        if (this.match(types.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }

        this.expect(types.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(types.bracketR);

        if (this.match(types.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types.question);
        } else if (this.eat(types.question)) {
          node.optional = true;
        }

        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types.braceR);
        return this.finishNode(node, "TSMappedType");
      };

      _proto.tsParseTupleType = function tsParseTupleType() {
        var _this2 = this;

        var node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var seenOptionalElement = false;
        var labeledElements = null;
        node.elementTypes.forEach(function (elementNode) {
          var _labeledElements;

          var _elementNode = elementNode,
              type = _elementNode.type;

          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            _this2.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
          }

          seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            type = elementNode.type;
          }

          var isLabeled = type === "TSNamedTupleMember";
          labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

          if (labeledElements !== isLabeled) {
            _this2.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
          }
        });
        return this.finishNode(node, "TSTupleType");
      };

      _proto.tsParseTupleElementType = function tsParseTupleElementType() {
        var _this$state = this.state,
            startPos = _this$state.start,
            startLoc = _this$state.startLoc;
        var rest = this.eat(types.ellipsis);
        var type = this.tsParseType();
        var optional = this.eat(types.question);
        var labeled = this.eat(types.colon);

        if (labeled) {
          var labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;

          if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }

          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          var optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }

        if (rest) {
          var restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }

        return type;
      };

      _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
        var node = this.startNode();
        this.expect(types.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      };

      _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {
        var node = this.startNode();

        if (type === "TSConstructorType") {
          this.expect(types._new);
        }

        this.tsFillSignature(types.arrow, node);
        return this.finishNode(node, type);
      };

      _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
        var _this3 = this;

        var node = this.startNode();

        node.literal = function () {
          switch (_this3.state.type) {
            case types.num:
            case types.bigint:
            case types.string:
            case types._true:
            case types._false:
              return _this3.parseExprAtom();

            default:
              throw _this3.unexpected();
          }
        }();

        return this.finishNode(node, "TSLiteralType");
      };

      _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
        var node = this.startNode();
        node.literal = this.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      };

      _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return _superClass.prototype.parseTemplateSubstitution.call(this);
      };

      _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
        var thisKeyword = this.tsParseThisTypeNode();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      };

      _proto.tsParseNonArrayType = function tsParseNonArrayType() {
        switch (this.state.type) {
          case types.name:
          case types._void:
          case types._null:
            {
              var type = this.match(types._void) ? "TSVoidKeyword" : this.match(types._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

              if (type !== undefined && this.lookaheadCharCode() !== 46) {
                var node = this.startNode();
                this.next();
                return this.finishNode(node, type);
              }

              return this.tsParseTypeReference();
            }

          case types.string:
          case types.num:
          case types.bigint:
          case types._true:
          case types._false:
            return this.tsParseLiteralTypeNode();

          case types.plusMin:
            if (this.state.value === "-") {
              var _node = this.startNode();

              var nextToken = this.lookahead();

              if (nextToken.type !== types.num && nextToken.type !== types.bigint) {
                throw this.unexpected();
              }

              _node.literal = this.parseMaybeUnary();
              return this.finishNode(_node, "TSLiteralType");
            }

            break;

          case types._this:
            return this.tsParseThisTypeOrThisTypePredicate();

          case types._typeof:
            return this.tsParseTypeQuery();

          case types._import:
            return this.tsParseImportType();

          case types.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

          case types.bracketL:
            return this.tsParseTupleType();

          case types.parenL:
            if (process.env.BABEL_8_BREAKING) {
              if (!this.options.createParenthesizedExpressions) {
                var startPos = this.state.start;
                this.next();

                var _type = this.tsParseType();

                this.expect(types.parenR);
                this.addExtra(_type, "parenthesized", true);
                this.addExtra(_type, "parenStart", startPos);
                return _type;
              }
            }

            return this.tsParseParenthesizedType();

          case types.backQuote:
            return this.tsParseTemplateLiteralType();
        }

        throw this.unexpected();
      };

      _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
        var type = this.tsParseNonArrayType();

        while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {
          if (this.match(types.bracketR)) {
            var node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            var _node2 = this.startNodeAtNode(type);

            _node2.objectType = type;
            _node2.indexType = this.tsParseType();
            this.expect(types.bracketR);
            type = this.finishNode(_node2, "TSIndexedAccessType");
          }
        }

        return type;
      };

      _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {
        var node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }

        return this.finishNode(node, "TSTypeOperator");
      };

      _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;

          default:
            this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      };

      _proto.tsParseInferType = function tsParseInferType() {
        var node = this.startNode();
        this.expectContextual("infer");
        var typeParameter = this.startNode();
        typeParameter.name = this.parseIdentifierName(typeParameter.start);
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      };

      _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
        var _this4 = this;

        var operator = ["keyof", "unique", "readonly"].find(function (kw) {
          return _this4.isContextual(kw);
        });
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      };

      _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        this.eat(operator);
        var type = parseConstituentType();

        if (this.match(operator)) {
          var types = [type];

          while (this.eat(operator)) {
            types.push(parseConstituentType());
          }

          var node = this.startNodeAtNode(type);
          node.types = types;
          type = this.finishNode(node, kind);
        }

        return type;
      };

      _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);
      };

      _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);
      };

      _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
        if (this.isRelational("<")) {
          return true;
        }

        return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      };

      _proto.tsSkipParameterStart = function tsSkipParameterStart() {
        if (this.match(types.name) || this.match(types._this)) {
          this.next();
          return true;
        }

        if (this.match(types.braceL)) {
          var braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types.braceR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        if (this.match(types.bracketL)) {
          var _braceStackCounter = 1;
          this.next();

          while (_braceStackCounter > 0) {
            if (this.match(types.bracketL)) {
              ++_braceStackCounter;
            } else if (this.match(types.bracketR)) {
              --_braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        return false;
      };

      _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
        this.next();

        if (this.match(types.parenR) || this.match(types.ellipsis)) {
          return true;
        }

        if (this.tsSkipParameterStart()) {
          if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {
            return true;
          }

          if (this.match(types.parenR)) {
            this.next();

            if (this.match(types.arrow)) {
              return true;
            }
          }
        }

        return false;
      };

      _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
        var _this5 = this;

        return this.tsInType(function () {
          var t = _this5.startNode();

          _this5.expect(returnToken);

          var asserts = !!_this5.tsTryParse(_this5.tsParseTypePredicateAsserts.bind(_this5));

          if (asserts && _this5.match(types._this)) {
            var thisTypePredicate = _this5.tsParseThisTypeOrThisTypePredicate();

            if (thisTypePredicate.type === "TSThisType") {
              var _node3 = _this5.startNodeAtNode(t);

              _node3.parameterName = thisTypePredicate;
              _node3.asserts = true;
              thisTypePredicate = _this5.finishNode(_node3, "TSTypePredicate");
            } else {
              thisTypePredicate.asserts = true;
            }

            t.typeAnnotation = thisTypePredicate;
            return _this5.finishNode(t, "TSTypeAnnotation");
          }

          var typePredicateVariable = _this5.tsIsIdentifier() && _this5.tsTryParse(_this5.tsParseTypePredicatePrefix.bind(_this5));

          if (!typePredicateVariable) {
            if (!asserts) {
              return _this5.tsParseTypeAnnotation(false, t);
            }

            var _node4 = _this5.startNodeAtNode(t);

            _node4.parameterName = _this5.parseIdentifier();
            _node4.asserts = asserts;
            t.typeAnnotation = _this5.finishNode(_node4, "TSTypePredicate");
            return _this5.finishNode(t, "TSTypeAnnotation");
          }

          var type = _this5.tsParseTypeAnnotation(false);

          var node = _this5.startNodeAtNode(t);

          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = _this5.finishNode(node, "TSTypePredicate");
          return _this5.finishNode(t, "TSTypeAnnotation");
        });
      };

      _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;
      };

      _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
        return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;
      };

      _proto.tsTryParseType = function tsTryParseType() {
        return this.tsEatThenParseType(types.colon);
      };

      _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
        var id = this.parseIdentifier();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      };

      _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
        if (!this.match(types.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
          return false;
        }

        var containsEsc = this.state.containsEsc;
        this.next();

        if (!this.match(types.name) && !this.match(types._this)) {
          return false;
        }

        if (containsEsc) {
          this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
        }

        return true;
      };

      _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
        var _this6 = this;

        if (eatColon === void 0) {
          eatColon = true;
        }

        if (t === void 0) {
          t = this.startNode();
        }

        this.tsInType(function () {
          if (eatColon) _this6.expect(types.colon);
          t.typeAnnotation = _this6.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      };

      _proto.tsParseType = function tsParseType() {
        assert$1(this.state.inType);
        var type = this.tsParseNonConditionalType();

        if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {
          return type;
        }

        var node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types.question);
        node.trueType = this.tsParseType();
        this.expect(types.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      };

      _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }

        if (this.match(types._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        }

        return this.tsParseUnionTypeOrHigher();
      };

      _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
        var node = this.startNode();

        var _const = this.tsTryNextParseConstantContext();

        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational(">");
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      };

      _proto.tsParseHeritageClause = function tsParseHeritageClause(descriptor) {
        var originalStart = this.state.start;
        var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

        if (!delimitedList.length) {
          this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
        }

        return delimitedList;
      };

      _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
        var node = this.startNode();
        node.expression = this.tsParseEntityName(false);

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSExpressionWithTypeArguments");
      };

      _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
        node.typeParameters = this.tsTryParseTypeParameters();

        if (this.eat(types._extends)) {
          node["extends"] = this.tsParseHeritageClause("extends");
        }

        var body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      };

      _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
        var _this7 = this;

        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsInType(function () {
          _this7.expect(types.eq);

          if (_this7.isContextual("intrinsic") && _this7.lookahead().type !== types.dot) {
            var _node5 = _this7.startNode();

            _this7.next();

            return _this7.finishNode(_node5, "TSIntrinsicKeyword");
          }

          return _this7.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      };

      _proto.tsInNoContext = function tsInNoContext(cb) {
        var oldContext = this.state.context;
        this.state.context = [oldContext[0]];

        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      };

      _proto.tsInType = function tsInType(cb) {
        var oldInType = this.state.inType;
        this.state.inType = true;

        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      };

      _proto.tsEatThenParseType = function tsEatThenParseType(token) {
        return !this.match(token) ? undefined : this.tsNextThenParseType();
      };

      _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
        var _this8 = this;

        return this.tsDoThenParseType(function () {
          return _this8.expect(token);
        });
      };

      _proto.tsNextThenParseType = function tsNextThenParseType() {
        var _this9 = this;

        return this.tsDoThenParseType(function () {
          return _this9.next();
        });
      };

      _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
        var _this10 = this;

        return this.tsInType(function () {
          cb();
          return _this10.tsParseType();
        });
      };

      _proto.tsParseEnumMember = function tsParseEnumMember() {
        var node = this.startNode();
        node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);

        if (this.eat(types.eq)) {
          node.initializer = this.parseMaybeAssignAllowIn();
        }

        return this.finishNode(node, "TSEnumMember");
      };

      _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
        if (isConst) node["const"] = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
        this.expect(types.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(types.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      };

      _proto.tsParseModuleBlock = function tsParseModuleBlock() {
        var node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types.braceL);
        this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      };

      _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
        if (nested === void 0) {
          nested = false;
        }

        node.id = this.parseIdentifier();

        if (!nested) {
          this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
        }

        if (this.eat(types.dot)) {
          var inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual("global")) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }

        if (this.match(types.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
        this.expect(types.eq);
        node.moduleReference = this.tsParseModuleReference();
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      };

      _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      };

      _proto.tsParseModuleReference = function tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      };

      _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
        var node = this.startNode();
        this.expectContextual("require");
        this.expect(types.parenL);

        if (!this.match(types.string)) {
          throw this.unexpected();
        }

        node.expression = this.parseExprAtom();
        this.expect(types.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      };

      _proto.tsLookAhead = function tsLookAhead(f) {
        var state = this.state.clone();
        var res = f();
        this.state = state;
        return res;
      };

      _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
        var result = this.tryParse(function (abort) {
          return f() || abort();
        });
        if (result.aborted || !result.node) return undefined;
        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.tsTryParse = function tsTryParse(f) {
        var state = this.state.clone();
        var result = f();

        if (result !== undefined && result !== false) {
          return result;
        } else {
          this.state = state;
          return undefined;
        }
      };

      _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
        var _this11 = this;

        if (this.isLineTerminator()) {
          return;
        }

        var starttype = this.state.type;
        var kind;

        if (this.isContextual("let")) {
          starttype = types._var;
          kind = "let";
        }

        return this.tsInDeclareContext(function () {
          switch (starttype) {
            case types._function:
              nany.declare = true;
              return _this11.parseFunctionStatement(nany, false, true);

            case types._class:
              nany.declare = true;
              return _this11.parseClass(nany, true, false);

            case types._const:
              if (_this11.match(types._const) && _this11.isLookaheadContextual("enum")) {
                _this11.expect(types._const);

                _this11.expectContextual("enum");

                return _this11.tsParseEnumDeclaration(nany, true);
              }

            case types._var:
              kind = kind || _this11.state.value;
              return _this11.parseVarStatement(nany, kind);

            case types.name:
              {
                var value = _this11.state.value;

                if (value === "global") {
                  return _this11.tsParseAmbientExternalModuleDeclaration(nany);
                } else {
                  return _this11.tsParseDeclaration(nany, value, true);
                }
              }
          }
        });
      };

      _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      };

      _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare":
            {
              var declaration = this.tsTryParseDeclare(node);

              if (declaration) {
                declaration.declare = true;
                return declaration;
              }

              break;
            }

          case "global":
            if (this.match(types.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              var mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }

            break;

          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      };

      _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {
              var cls = node;
              cls["abstract"] = true;

              if (next) {
                this.next();

                if (!this.match(types._class)) {
                  this.unexpected(null, types._class);
                }
              }

              return this.parseClass(cls, true, false);
            }

            break;

          case "enum":
            if (next || this.match(types.name)) {
              if (next) this.next();
              return this.tsParseEnumDeclaration(node, false);
            }

            break;

          case "interface":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseInterfaceDeclaration(node);
            }

            break;

          case "module":
            if (next) this.next();

            if (this.match(types.string)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "namespace":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "type":
            if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {
              if (next) this.next();
              return this.tsParseTypeAliasDeclaration(node);
            }

            break;
        }
      };

      _proto.tsCheckLineTerminatorAndMatch = function tsCheckLineTerminatorAndMatch(tokenType, next) {
        return (next || this.match(tokenType)) && !this.isLineTerminator();
      };

      _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        var _this12 = this;

        if (!this.isRelational("<")) {
          return undefined;
        }

        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        var res = this.tsTryParseAndCatch(function () {
          var node = _this12.startNodeAt(startPos, startLoc);

          node.typeParameters = _this12.tsParseTypeParameters();

          _superClass.prototype.parseFunctionParams.call(_this12, node);

          node.returnType = _this12.tsTryParseTypeOrTypePredicateAnnotation();

          _this12.expect(types.arrow);

          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

        if (!res) {
          return undefined;
        }

        return this.parseArrowExpression(res, null, true);
      };

      _proto.tsParseTypeArguments = function tsParseTypeArguments() {
        var _this13 = this;

        var node = this.startNode();
        node.params = this.tsInType(function () {
          return _this13.tsInNoContext(function () {
            _this13.expectRelational("<");

            return _this13.tsParseDelimitedList("TypeParametersOrArguments", _this13.tsParseType.bind(_this13));
          });
        });

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeArguments);
        }

        this.state.exprAllowed = false;
        this.expectRelational(">");
        return this.finishNode(node, "TSTypeParameterInstantiation");
      };

      _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
        if (this.match(types.name)) {
          switch (this.state.value) {
            case "abstract":
            case "declare":
            case "enum":
            case "interface":
            case "module":
            case "namespace":
            case "type":
              return true;
          }
        }

        return false;
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var accessibility;
        var readonly = false;

        if (allowModifiers !== undefined) {
          accessibility = this.parseAccessModifier();
          readonly = !!this.tsParseModifier(["readonly"]);

          if (allowModifiers === false && (accessibility || readonly)) {
            this.raise(startPos, TSErrors.UnexpectedParameterModifier);
          }
        }

        var left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (accessibility || readonly) {
          var pp = this.startNodeAt(startPos, startLoc);

          if (decorators.length) {
            pp.decorators = decorators;
          }

          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;

          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
          }

          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);
        }

        var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

        if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }

        if (bodilessType === "TSDeclareFunction" && this.state.isDeclareContext) {
          this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

          if (node.declare) {
            _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, bodilessType, isMethod);

            return;
          }
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
        } else {
          _superClass.prototype.registerFunctionStatementId.apply(this, arguments);
        }
      };

      _proto.tsCheckForInvalidTypeCasts = function tsCheckForInvalidTypeCasts(items) {
        var _this14 = this;

        items.forEach(function (node) {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            _this14.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
          }
        });
      };

      _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      };

      _proto.parseArrayLike = function parseArrayLike() {
        var _superClass$prototype;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var node = (_superClass$prototype = _superClass.prototype.parseArrayLike).call.apply(_superClass$prototype, [this].concat(args));

        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }

        return node;
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var _this15 = this;

        if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {
          this.state.exprAllowed = false;
          this.next();
          var nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }

        if (this.isRelational("<")) {
          var result = this.tsTryParseAndCatch(function () {
            if (!noCalls && _this15.atPossibleAsyncArrow(base)) {
              var asyncArrowFn = _this15.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }

            var node = _this15.startNodeAt(startPos, startLoc);

            node.callee = base;

            var typeArguments = _this15.tsParseTypeArguments();

            if (typeArguments) {
              if (!noCalls && _this15.eat(types.parenL)) {
                node.arguments = _this15.parseCallExpressionArguments(types.parenR, false);

                _this15.tsCheckForInvalidTypeCasts(node.arguments);

                node.typeParameters = typeArguments;

                if (state.optionalChainMember) {
                  node.optional = false;
                }

                return _this15.finishCallExpression(node, state.optionalChainMember);
              } else if (_this15.match(types.backQuote)) {
                var _result = _this15.parseTaggedTemplateExpression(base, startPos, startLoc, state);

                _result.typeParameters = typeArguments;
                return _result;
              }
            }

            _this15.unexpected();
          });
          if (result) return result;
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this16 = this;

        if (this.isRelational("<")) {
          var typeParameters = this.tsTryParseAndCatch(function () {
            var args = _this16.tsParseTypeArguments();

            if (!_this16.match(types.parenL)) _this16.unexpected();
            return args;
          });

          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;

          var _const = this.tsTryNextParseConstantContext();

          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }

          this.finishNode(node, "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }

        return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec);
      };

      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

      _proto.checkDuplicateExports = function checkDuplicateExports() {};

      _proto.parseImport = function parseImport(node) {
        if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {
          var ahead = this.lookahead();

          if (this.match(types.name) && ahead.type === types.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }

          if (this.isContextual("type") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === "from")) {
            node.importKind = "type";
            this.next();
          }
        }

        if (!node.importKind) {
          node.importKind = "value";
        }

        var importNode = _superClass.prototype.parseImport.call(this, node);

        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(importNode.start, "A type-only import can specify a default import or named bindings, but not both.");
        }

        return importNode;
      };

      _proto.parseExport = function parseExport(node) {
        if (this.match(types._import)) {
          this.expect(types._import);
          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types.eq)) {
          var assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual("as")) {
          var decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual("type") && this.lookahead().type === types.braceL) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }

          return _superClass.prototype.parseExport.call(this, node);
        }
      };

      _proto.isAbstractClass = function isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types._class;
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          var cls = this.startNode();
          this.next();
          this.parseClass(cls, true, true);
          cls["abstract"] = true;
          return cls;
        }

        if (this.state.value === "interface") {
          var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
          if (result) return result;
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
        if (this.state.type === types._const) {
          var ahead = this.lookahead();

          if (ahead.type === types.name && ahead.value === "enum") {
            var node = this.startNode();
            this.expect(types._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(node, true);
          }
        }

        return _superClass.prototype.parseStatementContent.call(this, context, topLevel);
      };

      _proto.parseAccessModifier = function parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var _this17 = this;

        this.tsParseModifiers(member, ["declare"]);
        var accessibility = this.parseAccessModifier();
        if (accessibility) member.accessibility = accessibility;
        this.tsParseModifiers(member, ["declare"]);

        var callParseClassMember = function callParseClassMember() {
          _superClass.prototype.parseClassMember.call(_this17, classBody, member, state);
        };

        if (member.declare) {
          this.tsInDeclareContext(callParseClassMember);
        } else {
          callParseClassMember();
        }
      };

      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        this.tsParseModifiers(member, ["abstract", "readonly", "declare"]);
        var idx = this.tsTryParseIndexSignature(member);

        if (idx) {
          classBody.body.push(idx);

          if (member["abstract"]) {
            this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
          }

          if (isStatic) {
            this.raise(member.start, TSErrors.IndexSignatureHasStatic);
          }

          if (member.accessibility) {
            this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
          }

          if (member.declare) {
            this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
          }

          return;
        }

        _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);
      };

      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
        var optional = this.eat(types.question);
        if (optional) methodOrProp.optional = true;

        if (methodOrProp.readonly && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
        }

        if (methodOrProp.declare && this.match(types.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
        return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
        var _this18 = this;

        if (!refNeedsArrowPos || !this.match(types.question)) {
          return _superClass.prototype.parseConditional.call(this, expr, startPos, startLoc, refNeedsArrowPos);
        }

        var result = this.tryParse(function () {
          return _superClass.prototype.parseConditional.call(_this18, expr, startPos, startLoc);
        });

        if (!result.node) {
          refNeedsArrowPos.start = result.error.pos || this.state.start;
          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }

        return node;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var isDeclare = this.eatContextual("declare");
        var declaration;

        if (this.match(types.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }

        if (!declaration) {
          declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
        }

        if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
          node.exportKind = "type";
        }

        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }

        return declaration;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) {
          return;
        }

        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
      };

      _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types.bang)) {
          node.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);

        if (this.state.isDeclareContext && this.match(types.eq)) {
          this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (node["abstract"]) {
          this.raise(node.start, TSErrors.PrivateElementHasAbstract);
        }

        if (node.accessibility) {
          this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
        }

        this.parseClassPropertyAnnotation(node);
        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        var typeParameters = this.tsTryParseTypeParameters();

        if (typeParameters && isConstructor) {
          this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
        }

        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }

        if (this.eatContextual("implements")) {
          node["implements"] = this.tsParseHeritageClause("implements");
        }
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop) {
        var _superClass$prototype2;

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) prop.typeParameters = typeParameters;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        (_superClass$prototype2 = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype2, [this, prop].concat(args));
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (decl.id.type === "Identifier" && this.eat(types.bang)) {
          decl.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign() {
        var _this19 = this,
            _jsx,
            _jsx2,
            _typeCast,
            _jsx3,
            _typeCast2,
            _jsx4,
            _typeCast3;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var state;
        var jsx;
        var typeCast;

        if (this.hasPlugin("jsx") && (this.match(types.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            var _superClass$prototype3;

            return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [_this19].concat(args));
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;

          if (context[context.length - 1] === types$1.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types$1.j_expr) {
            context.length -= 1;
          }
        }

        if (!((_jsx = jsx) == null ? void 0 : _jsx.error) && !this.isRelational("<")) {
          var _superClass$prototype4;

          return (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));
        }

        var typeParameters;
        state = state || this.state.clone();
        var arrow = this.tryParse(function (abort) {
          var _superClass$prototype5, _typeParameters;

          typeParameters = _this19.tsParseTypeParameters();

          var expr = (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [_this19].concat(args));

          if (expr.type !== "ArrowFunctionExpression" || expr.extra && expr.extra.parenthesized) {
            abort();
          }

          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            _this19.resetStartLocationFromNode(expr, typeParameters);
          }

          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;

        if (!jsx) {
          assert$1(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(function () {
            var _superClass$prototype6;

            return (_superClass$prototype6 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype6, [_this19].concat(args));
          }, state);
          if (!typeCast.error) return typeCast.node;
        }

        if ((_jsx2 = jsx) == null ? void 0 : _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if ((_typeCast = typeCast) == null ? void 0 : _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }

        if ((_jsx3 = jsx) == null ? void 0 : _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.thrown) throw typeCast.error;
        throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
      };

      _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
          return this.tsParseTypeAssertion();
        } else {
          return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors);
        }
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this20 = this;

        if (this.match(types.colon)) {
          var result = this.tryParse(function (abort) {
            var returnType = _this20.tsParseTypeOrTypePredicateAnnotation(types.colon);

            if (_this20.canInsertSemicolon() || !_this20.match(types.arrow)) abort();
            return returnType;
          });
          if (result.aborted) return;

          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types.question)) {
          if (param.type !== "Identifier" && !this.state.isDeclareContext && !this.state.inType) {
            this.raise(param.start, TSErrors.PatternIsOptional);
          }

          param.optional = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        switch (node.type) {
          case "TSTypeCastExpression":
            return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);

          case "TSParameterProperty":
            return _superClass.prototype.toAssignable.call(this, node, isLHS);

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;

          default:
            return _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };

      _proto.checkLVal = function checkLVal(expr, contextDescription) {
        var _superClass$prototype7;

        for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
          args[_key4 - 2] = arguments[_key4];
        }

        switch (expr.type) {
          case "TSTypeCastExpression":
            return;

          case "TSParameterProperty":
            this.checkLVal.apply(this, [expr.parameter, "parameter property"].concat(args));
            return;

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            this.checkLVal.apply(this, [expr.expression, contextDescription].concat(args));
            return;

          default:
            (_superClass$prototype7 = _superClass.prototype.checkLVal).call.apply(_superClass$prototype7, [this, expr, contextDescription].concat(args));

            return;
        }
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case types._this:
            return this.parseIdentifier(true);

          default:
            return _superClass.prototype.parseBindingAtom.call(this);
        }
      };

      _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          var typeArguments = this.tsParseTypeArguments();

          if (this.match(types.parenL)) {
            var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);

            call.typeParameters = typeArguments;
            return call;
          }

          this.unexpected(this.state.start, types.parenL);
        }

        return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types.bang) || this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.parseMaybeDefault = function parseMaybeDefault() {
        var _superClass$prototype8;

        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var node = (_superClass$prototype8 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype8, [this].concat(args));

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
        }

        return node;
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types.relational, 1);
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.reScan_lt_gt = function reScan_lt_gt() {
        if (this.match(types.relational)) {
          var code = this.input.charCodeAt(this.state.start);

          if (code === 60 || code === 62) {
            this.state.pos -= 1;
            this.readToken_lt_gt(code);
          }
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (!expr) continue;

          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;

            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
              }

              break;
          }
        }

        return _superClass.prototype.toAssignableList.apply(this, arguments);
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
        return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var _this21 = this;

        if (this.isRelational("<")) {
          var typeArguments = this.tsTryParseAndCatch(function () {
            return _this21.tsParseTypeArguments();
          });
          if (typeArguments) node.typeParameters = typeArguments;
        }

        return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
      };

      _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
        var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);

        var params = this.getObjectOrClassMethodParams(method);
        var firstParam = params[0];
        var hasContextParam = firstParam && firstParam.type === "Identifier" && firstParam.name === "this";
        return hasContextParam ? baseCount + 1 : baseCount;
      };

      _proto.parseCatchClauseParam = function parseCatchClauseParam() {
        var param = _superClass.prototype.parseCatchClauseParam.call(this);

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }

        return param;
      };

      _proto.tsInDeclareContext = function tsInDeclareContext(cb) {
        var oldIsDeclareContext = this.state.isDeclareContext;
        this.state.isDeclareContext = true;

        try {
          return cb();
        } finally {
          this.state.isDeclareContext = oldIsDeclareContext;
        }
      };

      return _class;
    }(superClass);
  });

  types.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  var placeholders = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
        if (this.match(types.placeholder)) {
          var node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = _superClass.prototype.parseIdentifier.call(this, true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(types.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      };

      _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
        var isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types.placeholder, 2);
        }

        return _superClass.prototype.getTokenFromCode.apply(this, arguments);
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      _proto.parseIdentifier = function parseIdentifier() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.apply(this, arguments);
      };

      _proto.checkReservedWord = function checkReservedWord(word) {
        if (word !== undefined) _superClass.prototype.checkReservedWord.apply(this, arguments);
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.apply(this, arguments);
      };

      _proto.checkLVal = function checkLVal(expr) {
        if (expr.type !== "Placeholder") _superClass.prototype.checkLVal.apply(this, arguments);
      };

      _proto.toAssignable = function toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }

        return _superClass.prototype.toAssignable.apply(this, arguments);
      };

      _proto.verifyBreakContinue = function verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder") return;

        _superClass.prototype.verifyBreakContinue.apply(this, arguments);
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return _superClass.prototype.parseExpressionStatement.apply(this, arguments);
        }

        if (this.match(types.colon)) {
          var stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }

        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      };

      _proto.parseBlock = function parseBlock() {
        return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.apply(this, arguments);
      };

      _proto.parseFunctionId = function parseFunctionId() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.apply(this, arguments);
      };

      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        var type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        var oldStrict = this.state.strict;
        var placeholder = this.parsePlaceholder("Identifier");

        if (placeholder) {
          if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, "A class name is required");
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }

        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      };

      _proto.parseExport = function parseExport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseExport.apply(this, arguments);

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }

        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return _superClass.prototype.parseExport.call(this, node);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types._default)) {
          var next = this.nextTokenStart();

          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(types.placeholder.label, this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }

        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }

        return _superClass.prototype.maybeParseExportDefaultSpecifier.apply(this, arguments);
      };

      _proto.checkExport = function checkExport(node) {
        var specifiers = node.specifiers;

        if (specifiers == null ? void 0 : specifiers.length) {
          node.specifiers = specifiers.filter(function (node) {
            return node.exported.type === "Placeholder";
          });
        }

        _superClass.prototype.checkExport.call(this, node);

        node.specifiers = specifiers;
      };

      _proto.parseImport = function parseImport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseImport.apply(this, arguments);
        node.specifiers = [];

        if (!this.isContextual("from") && !this.match(types.comma)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }

        var specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);

        if (this.eat(types.comma)) {
          var hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }

        this.expectContextual("from");
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      _proto.parseImportSource = function parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  var v8intrinsic = (function (superClass) {
    return function (_superClass) {
      _inheritsLoose(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parseV8Intrinsic = function parseV8Intrinsic() {
        if (this.match(types.modulo)) {
          var v8IntrinsicStart = this.state.start;
          var node = this.startNode();
          this.eat(types.modulo);

          if (this.match(types.name)) {
            var name = this.parseIdentifierName(this.state.start);
            var identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";

            if (this.match(types.parenL)) {
              return identifier;
            }
          }

          this.unexpected(v8IntrinsicStart);
        }
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  function hasPlugin(plugins, name) {
    return plugins.some(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    var plugin = plugins.find(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }
  var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }

      var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }

    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }

    if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
      throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }

    if (hasPlugin(plugins, "moduleAttributes")) {
      if (hasPlugin(plugins, "importAssertions")) {
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      }

      var moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

      if (moduleAttributesVerionPluginOption !== "may-2020") {
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
      }
    }

    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }
  }
  var mixinPlugins = {
    estree: estree,
    jsx: jsx,
    flow: flow,
    typescript: typescript,
    v8intrinsic: v8intrinsic,
    placeholders: placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);

  var defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false
  };
  function getOptions(opts) {
    var options = {};

    for (var _i2 = 0, _Object$keys2 = Object.keys(defaultOptions); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  var State = function () {
    function State() {
      this.strict = void 0;
      this.curLine = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isIterator = false;
      this.isDeclareContext = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types$1.braceStatement];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.strictErrors = new Map();
      this.exportedIdentifiers = [];
      this.tokensLength = 0;
    }

    var _proto = State.prototype;

    _proto.init = function init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    };

    _proto.curPosition = function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    };

    _proto.clone = function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    };

    return State;
  }();

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var VALID_REGEX_FLAGS = new Set(["g", "m", "s", "i", "y", "u"]);
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  var allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);
  allowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);
  allowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
  var Token = function Token(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  };

  var Tokenizer = function (_ParserErrors) {
    _inheritsLoose(Tokenizer, _ParserErrors);

    function Tokenizer(options, input) {
      var _this;

      _this = _ParserErrors.call(this) || this;
      _this.isLookahead = void 0;
      _this.tokens = [];
      _this.state = new State();

      _this.state.init(options);

      _this.input = input;
      _this.length = input.length;
      _this.isLookahead = false;
      return _this;
    }

    var _proto = Tokenizer.prototype;

    _proto.pushToken = function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    };

    _proto.next = function next() {
      if (!this.isLookahead) {
        this.checkKeywordEscapes();

        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    };

    _proto.eat = function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    };

    _proto.match = function match(type) {
      return this.state.type === type;
    };

    _proto.lookahead = function lookahead() {
      var old = this.state;
      this.state = old.clone(true);
      this.isLookahead = true;
      this.next();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    };

    _proto.nextTokenStart = function nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    };

    _proto.nextTokenStartSince = function nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      var skip = skipWhiteSpace.exec(this.input);
      return pos + skip[0].length;
    };

    _proto.lookaheadCharCode = function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    };

    _proto.setStrict = function setStrict(strict) {
      var _this2 = this;

      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach(function (message, pos) {
          return _this2.raise(pos, message);
        });
        this.state.strictErrors.clear();
      }
    };

    _proto.curContext = function curContext() {
      return this.state.context[this.state.context.length - 1];
    };

    _proto.nextToken = function nextToken() {
      var curContext = this.curContext();
      if (!(curContext == null ? void 0 : curContext.preserveSpace)) this.skipSpace();
      this.state.start = this.state.pos;
      this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types.eof);
        return;
      }

      var override = curContext == null ? void 0 : curContext.override;

      if (override) {
        override(this);
      } else {
        this.getTokenFromCode(this.input.codePointAt(this.state.pos));
      }
    };

    _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    };

    _proto.skipBlockComment = function skipBlockComment() {
      var startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      var match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipLineComment = function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipSpace = function skipSpace() {
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    };

    _proto.finishToken = function finishToken(type, val) {
      this.state.end = this.state.pos;
      this.state.endLoc = this.state.curPosition();
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;
      if (!this.isLookahead) this.updateContext(prevType);
    };

    _proto.readToken_numberSign = function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.input.charCodeAt(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }

        if (next === 123) {
          this.finishToken(types.braceHashL);
        } else {
          this.finishToken(types.bracketHashL);
        }

        this.state.pos += 2;
      } else {
        this.finishOp(types.hash, 1);
      }
    };

    _proto.readToken_dot = function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types.dot);
      }
    };

    _proto.readToken_slash = function readToken_slash() {
      if (this.state.exprAllowed && !this.state.inType) {
        ++this.state.pos;
        this.readRegexp();
        return;
      }

      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.slash, 1);
      }
    };

    _proto.readToken_interpreter = function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types.interpreterDirective, value);
      return true;
    };

    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
      var type = code === 42 ? types.star : types.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);
      var exprAllowed = this.state.exprAllowed;

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types.exponent;
      }

      if (next === 61 && !exprAllowed) {
        width++;
        type = types.assign;
      }

      this.finishOp(type, width);
    };

    _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.braceBarR, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.finishOp(types.bracketBarR, 2);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
    };

    _proto.readToken_caret = function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.bitwiseXOR, 1);
      }
    };

    _proto.readToken_plus_min = function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types.assign, 2);
      } else {
        this.finishOp(types.plusMin, 1);
      }
    };

    _proto.readToken_lt_gt = function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types.assign, size + 1);
          return;
        }

        this.finishOp(types.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types.relational, size);
    };

    _proto.readToken_eq_excl = function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types.arrow);
        return;
      }

      this.finishOp(code === 61 ? types.eq : types.bang, 1);
    };

    _proto.readToken_question = function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types.assign, 3);
        } else {
          this.finishOp(types.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types.question);
      }
    };

    _proto.getTokenFromCode = function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.bracketBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.finishToken(types.braceBarL);
            this.state.pos += 2;
          } else {
            ++this.state.pos;
            this.finishToken(types.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord();
            return;
          }

      }

      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    };

    _proto.finishOp = function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    };

    _proto.readRegexp = function readRegexp() {
      var start = this.state.pos;
      var escaped, inClass;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        var ch = this.input.charAt(this.state.pos);

        if (lineBreak.test(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }

          escaped = ch === "\\";
        }

        ++this.state.pos;
      }

      var content = this.input.slice(start, this.state.pos);
      ++this.state.pos;
      var mods = "";

      while (this.state.pos < this.length) {
        var _char = this.input[this.state.pos];
        var charCode = this.input.codePointAt(this.state.pos);

        if (VALID_REGEX_FLAGS.has(_char)) {
          if (mods.indexOf(_char) > -1) {
            this.raise(this.state.pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(charCode) || charCode === 92) {
          this.raise(this.state.pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++this.state.pos;
        mods += _char;
      }

      this.finishToken(types.regexp, {
        pattern: content,
        flags: mods
      });
    };

    _proto.readInt = function readInt(radix, len, forceLen, allowNumSeparator) {
      if (allowNumSeparator === void 0) {
        allowNumSeparator = true;
      }

      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (code === 95) {
          var prev = this.input.charCodeAt(this.state.pos - 1);
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    };

    _proto.readRadixNumber = function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types.bigint, str);
        return;
      }

      this.finishToken(types.num, val);
    };

    _proto.readNumber = function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isDecimal = false;
      var hasExponent = false;
      var isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        var integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

        if (!this.state.strict) {
          var underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(types.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types.decimal, str);
        return;
      }

      var val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types.num, val);
    };

    _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    };

    _proto.readString = function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types.string, out);
    };

    _proto.readTmplToken = function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    };

    _proto.recordStrictModeErrors = function recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    };

    _proto.readEscapedChar = function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);

            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\x0B";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var codePos = this.state.pos - 1;
            var match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            var octalStr = match[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    };

    _proto.readHexChar = function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    };

    _proto.readWord1 = function readWord1() {
      var word = "";
      this.state.containsEsc = false;
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      while (this.state.pos < this.length) {
        var ch = this.input.codePointAt(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (this.state.isIterator && ch === 64) {
          ++this.state.pos;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    };

    _proto.isIterator = function isIterator(word) {
      return word === "@@iterator" || word === "@@asyncIterator";
    };

    _proto.readWord = function readWord() {
      var word = this.readWord1();
      var type = keywords$1.get(word) || types.name;

      if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {
        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, word);
      }

      this.finishToken(type, word);
    };

    _proto.checkKeywordEscapes = function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    };

    _proto.braceIsBlock = function braceIsBlock(prevType) {
      var parent = this.curContext();

      if (parent === types$1.functionExpression || parent === types$1.functionStatement) {
        return true;
      }

      if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {
        return !parent.isExpr;
      }

      if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {
        return this.hasPrecedingLineBreak();
      }

      if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {
        return true;
      }

      if (prevType === types.braceL) {
        return parent === types$1.braceStatement;
      }

      if (prevType === types._var || prevType === types._const || prevType === types.name) {
        return false;
      }

      if (prevType === types.relational) {
        return true;
      }

      return !this.state.exprAllowed;
    };

    _proto.updateContext = function updateContext(prevType) {
      var type = this.state.type;
      var update;

      if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {
        this.state.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    };

    return Tokenizer;
  }(ParserError);

  var UtilParser = function (_Tokenizer) {
    _inheritsLoose(UtilParser, _Tokenizer);

    function UtilParser() {
      return _Tokenizer.apply(this, arguments) || this;
    }

    var _proto = UtilParser.prototype;

    _proto.addExtra = function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    };

    _proto.isRelational = function isRelational(op) {
      return this.match(types.relational) && this.state.value === op;
    };

    _proto.expectRelational = function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types.relational);
      }
    };

    _proto.isContextual = function isContextual(name) {
      return this.match(types.name) && this.state.value === name && !this.state.containsEsc;
    };

    _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;
      return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));
    };

    _proto.isLookaheadContextual = function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    };

    _proto.eatContextual = function eatContextual(name) {
      return this.isContextual(name) && this.eat(types.name);
    };

    _proto.expectContextual = function expectContextual(name, message) {
      if (!this.eatContextual(name)) this.unexpected(null, message);
    };

    _proto.canInsertSemicolon = function canInsertSemicolon() {
      return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();
    };

    _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    };

    _proto.isLineTerminator = function isLineTerminator() {
      return this.eat(types.semi) || this.canInsertSemicolon();
    };

    _proto.semicolon = function semicolon() {
      if (!this.isLineTerminator()) this.unexpected(null, types.semi);
    };

    _proto.expect = function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    };

    _proto.assertNoSpace = function assertNoSpace(message) {
      if (message === void 0) {
        message = "Unexpected space.";
      }

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, message);
      }
    };

    _proto.unexpected = function unexpected(pos, messageOrType) {
      if (messageOrType === void 0) {
        messageOrType = "Unexpected token";
      }

      if (typeof messageOrType !== "string") {
        messageOrType = "Unexpected token, expected \"" + messageOrType.label + "\"";
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    };

    _proto.expectPlugin = function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, "This experimental syntax requires enabling the parser plugin: '" + name + "'");
      }

      return true;
    };

    _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
      var _this = this;

      if (!names.some(function (n) {
        return _this.hasPlugin(n);
      })) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, "This experimental syntax requires enabling one of the following parser plugin(s): '" + names.join(", ") + "'");
      }
    };

    _proto.tryParse = function tryParse(fn, oldState) {
      if (oldState === void 0) {
        oldState = this.state.clone();
      }

      var abortSignal = {
        node: null
      };

      try {
        var _node = fn(function (node) {
          if (node === void 0) {
            node = null;
          }

          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          return {
            node: _node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: _node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    };

    _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssign = refExpressionErrors.shorthandAssign,
          doubleProto = refExpressionErrors.doubleProto;
      if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }
    };

    _proto.isLiteralPropertyName = function isLiteralPropertyName() {
      return this.match(types.name) || !!this.state.type.keyword || this.match(types.string) || this.match(types.num) || this.match(types.bigint) || this.match(types.decimal);
    };

    _proto.isPrivateName = function isPrivateName(node) {
      return node.type === "PrivateName";
    };

    _proto.getPrivateNameSV = function getPrivateNameSV(node) {
      return node.id.name;
    };

    _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    };

    _proto.isOptionalChain = function isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    };

    _proto.isObjectProperty = function isObjectProperty(node) {
      return node.type === "ObjectProperty";
    };

    _proto.isObjectMethod = function isObjectMethod(node) {
      return node.type === "ObjectMethod";
    };

    return UtilParser;
  }(Tokenizer);
  var ExpressionErrors = function ExpressionErrors() {
    this.shorthandAssign = -1;
    this.doubleProto = -1;
  };

  var Node = function () {
    function Node(parser, pos, loc) {
      this.type = void 0;
      this.start = void 0;
      this.end = void 0;
      this.loc = void 0;
      this.range = void 0;
      this.leadingComments = void 0;
      this.trailingComments = void 0;
      this.innerComments = void 0;
      this.extra = void 0;
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser == null ? void 0 : parser.options.ranges) this.range = [pos, 0];
      if (parser == null ? void 0 : parser.filename) this.loc.filename = parser.filename;
    }

    var _proto = Node.prototype;

    _proto.__clone = function __clone() {
      var newNode = new Node();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var _key = keys[i];

        if (_key !== "leadingComments" && _key !== "trailingComments" && _key !== "innerComments") {
          newNode[_key] = this[_key];
        }
      }

      return newNode;
    };

    return Node;
  }();

  var NodeUtils = function (_UtilParser) {
    _inheritsLoose(NodeUtils, _UtilParser);

    function NodeUtils() {
      return _UtilParser.apply(this, arguments) || this;
    }

    var _proto2 = NodeUtils.prototype;

    _proto2.startNode = function startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    };

    _proto2.startNodeAt = function startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    };

    _proto2.startNodeAtNode = function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    };

    _proto2.finishNode = function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    };

    _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
      if ( node.end > 0) {
        throw new Error("Do not call finishNode*() twice on the same node." + " Instead use resetEndLocation() or change type directly.");
      }

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    };

    _proto2.resetStartLocation = function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    };

    _proto2.resetEndLocation = function resetEndLocation(node, end, endLoc) {
      if (end === void 0) {
        end = this.state.lastTokEnd;
      }

      if (endLoc === void 0) {
        endLoc = this.state.lastTokEndLoc;
      }

      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    };

    _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    };

    return NodeUtils;
  }(UtilParser);

  var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  var LValParser = function (_NodeUtils) {
    _inheritsLoose(LValParser, _NodeUtils);

    function LValParser() {
      return _NodeUtils.apply(this, arguments) || this;
    }

    var _proto = LValParser.prototype;

    _proto.toAssignable = function toAssignable(node, isLHS) {
      var _node$extra, _node$extra3;

      if (isLHS === void 0) {
        isLHS = false;
      }

      var parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            var prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (isLast && prop.type === "RestElement" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value, isLHS);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            var arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }

      return node;
    };

    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    };

    _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
      var end = exprList.length;

      if (end) {
        var last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isLHS);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    };

    _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    };

    _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (var _i2 = 0; _i2 < exprList.length; _i2++) {
        var expr = exprList[_i2];

        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    };

    _proto.parseSpread = function parseSpread(refExpressionErrors, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    };

    _proto.parseRestBinding = function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };

    _proto.parseBindingAtom = function parseBindingAtom() {
      switch (this.state.type) {
        case types.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types.braceL:
          return this.parseObjectLike(types.braceR, true);
      }

      return this.parseIdentifier();
    };

    _proto.parseBindingList = function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
        }

        if (allowEmpty && this.match(types.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }

          while (this.match(types.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    };

    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    };

    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
      return param;
    };

    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    };

    _proto.checkLVal = function checkLVal(expr, contextDescription, bindingType, checkClashes, disallowLetBinding, strictModeChanged) {
      if (bindingType === void 0) {
        bindingType = BIND_NONE;
      }

      if (strictModeChanged === void 0) {
        strictModeChanged = false;
      }

      switch (expr.type) {
        case "Identifier":
          {
            var name = expr.name;

            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
            }

            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(expr.start, ErrorMessages.ParamDupe);
              } else {
                checkClashes.add(name);
              }
            }

            if (disallowLetBinding && name === "let") {
              this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
            }

            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.start);
            }

            break;
          }

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          for (var _i4 = 0, _expr$properties2 = expr.properties; _i4 < _expr$properties2.length; _i4++) {
            var prop = _expr$properties2[_i4];
            if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
            this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (var _i6 = 0, _expr$elements2 = expr.elements; _i6 < _expr$elements2.length; _i6++) {
            var elem = _expr$elements2[_i6];

            if (elem) {
              this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
          break;

        case "RestElement":
          this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
      }
    };

    _proto.checkToRestConversion = function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    };

    _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
      if (this.match(types.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    };

    _proto.raiseRestNotLast = function raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    };

    _proto.raiseTrailingCommaAfterRest = function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    };

    return LValParser;
  }(NodeUtils);

  var kExpression = 0,
      kMaybeArrowParameterDeclaration = 1,
      kMaybeAsyncArrowParameterDeclaration = 2,
      kParameterDeclaration = 3;

  var ExpressionScope = function () {
    function ExpressionScope(type) {
      if (type === void 0) {
        type = kExpression;
      }

      this.type = void 0;
      this.type = type;
    }

    var _proto = ExpressionScope.prototype;

    _proto.canBeArrowParameterDeclaration = function canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    };

    _proto.isCertainlyParameterDeclaration = function isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    };

    return ExpressionScope;
  }();

  var ArrowHeadParsingScope = function (_ExpressionScope) {
    _inheritsLoose(ArrowHeadParsingScope, _ExpressionScope);

    function ArrowHeadParsingScope(type) {
      var _this;

      _this = _ExpressionScope.call(this, type) || this;
      _this.errors = new Map();
      return _this;
    }

    var _proto2 = ArrowHeadParsingScope.prototype;

    _proto2.recordDeclarationError = function recordDeclarationError(pos, message) {
      this.errors.set(pos, message);
    };

    _proto2.clearDeclarationError = function clearDeclarationError(pos) {
      this.errors["delete"](pos);
    };

    _proto2.iterateErrors = function iterateErrors(iterator) {
      this.errors.forEach(iterator);
    };

    return ArrowHeadParsingScope;
  }(ExpressionScope);

  var ExpressionScopeHandler = function () {
    function ExpressionScopeHandler(raise) {
      this.stack = [new ExpressionScope()];
      this.raise = raise;
    }

    var _proto3 = ExpressionScopeHandler.prototype;

    _proto3.enter = function enter(scope) {
      this.stack.push(scope);
    };

    _proto3.exit = function exit() {
      this.stack.pop();
    };

    _proto3.recordParameterInitializerError = function recordParameterInitializerError(pos, message) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, message);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.raise(pos, message);
    };

    _proto3.recordParenthesizedIdentifierError = function recordParenthesizedIdentifierError(pos, message) {
      var stack = this.stack;
      var scope = stack[stack.length - 1];

      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, message);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, message);
      } else {
        return;
      }
    };

    _proto3.recordAsyncArrowParametersError = function recordAsyncArrowParametersError(pos, message) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, message);
        }

        scope = stack[--i];
      }
    };

    _proto3.validateAsPattern = function validateAsPattern() {
      var _this2 = this;

      var stack = this.stack;
      var currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(function (message, pos) {
        _this2.raise(pos, message);

        var i = stack.length - 2;
        var scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    };

    return ExpressionScopeHandler;
  }();
  function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }

  var ExpressionParser = function (_LValParser) {
    _inheritsLoose(ExpressionParser, _LValParser);

    function ExpressionParser() {
      return _LValParser.apply(this, arguments) || this;
    }

    var _proto = ExpressionParser.prototype;

    _proto.checkProto = function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    };

    _proto.shouldExitDescending = function shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    };

    _proto.getExpression = function getExpression() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;
      return expr;
    };

    _proto.parseExpression = function parseExpression(disallowIn, refExpressionErrors) {
      var _this = this;

      if (disallowIn) {
        return this.disallowInAnd(function () {
          return _this.parseExpressionBase(refExpressionErrors);
        });
      }

      return this.allowInAnd(function () {
        return _this.parseExpressionBase(refExpressionErrors);
      });
    };

    _proto.parseExpressionBase = function parseExpressionBase(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    };

    _proto.parseMaybeAssignDisallowIn = function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      var _this2 = this;

      return this.disallowInAnd(function () {
        return _this2.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
      });
    };

    _proto.parseMaybeAssignAllowIn = function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      var _this3 = this;

      return this.allowInAnd(function () {
        return _this3.parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos);
      });
    };

    _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          this.state.exprAllowed = true;

          var _left = this.parseYield();

          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startPos, startLoc);
          }

          return _left;
        }
      }

      var ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types.parenL) || this.match(types.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(refExpressionErrors, refNeedsArrowPos);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (this.match(types.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    };

    _proto.parseMaybeConditional = function parseMaybeConditional(refExpressionErrors, refNeedsArrowPos) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);
    };

    _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refNeedsArrowPos) {
      if (this.eat(types.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    };

    _proto.parseExprOps = function parseExprOps(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    };

    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      var prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types._in))) {
        if (prec > minPrec) {
          var op = this.state.type;

          if (op === types.pipeline) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;

          if (op === types.exponent && left.type === "UnaryExpression" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {
            this.raise(left.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
          }

          var logical = op === types.logicalOR || op === types.logicalAND;
          var coalesce = op === types.nullishCoalescing;

          if (coalesce) {
            prec = types.logicalAND.binop;
          }

          this.next();

          if (op === types.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;

          if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    };

    _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec) {
      var _this4 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(function () {
                return _this4.parseSmartPipelineBody(_this4.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this4.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    };

    _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    };

    _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
      if (this.isContextual("await") && this.isAwaitAllowed()) {
        return this.parseAwait();
      }

      var update = this.match(types.incDec);
      var node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types._throw)) {
          this.expectPlugin("throwExpressions");
        }

        var isDelete = this.match(types._delete);
        this.next();
        node.argument = this.parseMaybeUnary();
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          return this.finishNode(node, "UnaryExpression");
        }
      }

      return this.parseUpdate(node, update, refExpressionErrors);
    };

    _proto.parseUpdate = function parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node = this.startNodeAt(startPos, startLoc);

        _node.operator = this.state.value;
        _node.prefix = false;
        _node.argument = expr;
        this.checkLVal(expr, "postfix operation");
        this.next();
        expr = this.finishNode(_node, "UpdateExpression");
      }

      return expr;
    };

    _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    };

    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    };

    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      var optional = false;

      if (this.match(types.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(types.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types.bracketL) || this.eat(types.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    };

    _proto.parseMember = function parseMember(base, startPos, startLoc, state, optional) {
      var node = this.startNodeAt(startPos, startLoc);
      var computed = this.eat(types.bracketL);
      node.object = base;
      node.computed = computed;
      var property = computed ? this.parseExpression() : this.parseMaybePrivateName(true);

      if (this.isPrivateName(property)) {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(this.getPrivateNameSV(property), property.start);
      }

      node.property = property;

      if (computed) {
        this.expect(types.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    };

    _proto.parseBind = function parseBind(base, startPos, startLoc, noCalls, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    };

    _proto.parseCoverCallAndAsyncArrowHead = function parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
      }

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
      } else {
        node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === "Import", base.type !== "Super", node);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
      } else {
        if (state.maybeAsyncArrow) {
          this.expressionScope.exit();
        }

        this.toReferencedArguments(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    };

    _proto.toReferencedArguments = function toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    };

    _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    };

    _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    };

    _proto.finishCallExpression = function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          if (!this.hasPlugin("moduleAttributes")) {
            this.expectPlugin("importAssertions");
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          for (var _i2 = 0, _node$arguments2 = node.arguments; _i2 < _node$arguments2.length; _i2++) {
            var arg = _node$arguments2[_i2];

            if (arg.type === "SpreadElement") {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    };

    _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {
      var elts = [];
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {
          start: 0
        } : undefined, allowPlaceholder));
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    };

    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
      return this.match(types.arrow) && !this.canInsertSemicolon();
    };

    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    };

    _proto.parseNoCallExpr = function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    };

    _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
      if (this.state.type === types.slash) this.readRegexp();
      var canBeArrow = this.state.potentialArrowAt === this.state.start;
      var node;

      switch (this.state.type) {
        case types._super:
          return this.parseSuper();

        case types._import:
          node = this.startNode();
          this.next();

          if (this.match(types.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types.name:
          {
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types._function)) {
                var last = this.state.context.length - 1;

                if (this.state.context[last] !== types$1.functionStatement) {
                  throw new Error("Internal error");
                }

                this.state.context[last] = types$1.functionExpression;
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (this.match(types.name)) {
                return this.parseAsyncArrowUnaryFunction(id);
              }
            }

            if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          }

        case types._do:
          {
            return this.parseDo();
          }

        case types.regexp:
          {
            var value = this.state.value;
            node = this.parseLiteral(value.value, "RegExpLiteral");
            node.pattern = value.pattern;
            node.flags = value.flags;
            return node;
          }

        case types.num:
          return this.parseLiteral(this.state.value, "NumericLiteral");

        case types.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteral");

        case types.decimal:
          return this.parseLiteral(this.state.value, "DecimalLiteral");

        case types.string:
          return this.parseLiteral(this.state.value, "StringLiteral");

        case types._null:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "NullLiteral");

        case types._true:
        case types._false:
          return this.parseBooleanLiteral();

        case types.parenL:
          return this.parseParenAndDistinguishExpression(canBeArrow);

        case types.bracketBarL:
        case types.bracketHashL:
          {
            return this.parseArrayLike(this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR, false, true, refExpressionErrors);
          }

        case types.bracketL:
          {
            return this.parseArrayLike(types.bracketR, true, false, refExpressionErrors);
          }

        case types.braceBarL:
        case types.braceHashL:
          {
            return this.parseObjectLike(this.state.type === types.braceBarL ? types.braceBarR : types.braceR, false, true, refExpressionErrors);
          }

        case types.braceL:
          {
            return this.parseObjectLike(types.braceR, false, false, refExpressionErrors);
          }

        case types._function:
          return this.parseFunctionOrFunctionSent();

        case types.at:
          this.parseDecorators();

        case types._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types._new:
          return this.parseNewOrNewTarget();

        case types.backQuote:
          return this.parseTemplate(false);

        case types.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }

        case types.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }

            var nextCh = this.input.codePointAt(this.state.end);

            if (isIdentifierStart(nextCh) || nextCh === 92) {
              var start = this.state.start;
              node = this.parseMaybePrivateName(true);

              if (this.match(types._in)) {
                this.expectPlugin("privateIn");
                this.classScope.usePrivateName(node.id.name, node.start);
              } else if (this.hasPlugin("privateIn")) {
                this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, node.id.name);
              } else {
                throw this.unexpected(start);
              }

              return node;
            }
          }

        case types.relational:
          {
            if (this.state.value === "<") {
              var lookaheadCh = this.input.codePointAt(this.nextTokenStart());

              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                }
            }
          }

        default:
          throw this.unexpected();
      }
    };

    _proto.parseAsyncArrowUnaryFunction = function parseAsyncArrowUnaryFunction(id) {
      var node = this.startNodeAtNode(id);
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      var params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    };

    _proto.parseDo = function parseDo() {
      this.expectPlugin("doExpressions");
      var node = this.startNode();
      this.next();
      var oldLabels = this.state.labels;
      this.state.labels = [];
      node.body = this.parseBlock();
      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    };

    _proto.parseSuper = function parseSuper() {
      var node = this.startNode();
      this.next();

      if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, "Super");
    };

    _proto.parseBooleanLiteral = function parseBooleanLiteral() {
      var node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    };

    _proto.parseMaybePrivateName = function parseMaybePrivateName(isPrivateNameAllowed) {
      var isPrivate = this.match(types.hash);

      if (isPrivate) {
        this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]);

        if (!isPrivateNameAllowed) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedPrivateField);
        }

        var node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space between # and identifier");
        node.id = this.parseIdentifier(true);
        return this.finishNode(node, "PrivateName");
      } else {
        return this.parseIdentifier(true);
      }
    };

    _proto.parseFunctionOrFunctionSent = function parseFunctionOrFunctionSent() {
      var node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    };

    _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    };

    _proto.parseImportMetaProperty = function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raiseWithData(id.start, {
            code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
          }, ErrorMessages.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    };

    _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      var node = this.startNodeAt(startPos, startLoc);
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    };

    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var refNeedsArrowPos = {
        start: 0
      };
      var first = true;
      var spreadStart;
      var optionalCommaStart;

      while (!this.match(types.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma, refNeedsArrowPos.start || null);

          if (this.match(types.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos));
        }
      }

      var innerEndPos = this.state.lastTokEnd;
      var innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    };

    _proto.shouldParseArrow = function shouldParseArrow() {
      return !this.canInsertSemicolon();
    };

    _proto.parseArrow = function parseArrow(node) {
      if (this.eat(types.arrow)) {
        return node;
      }
    };

    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
      return node;
    };

    _proto.parseNewOrNewTarget = function parseNewOrNewTarget() {
      var node = this.startNode();
      this.next();

      if (this.match(types.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          var error = ErrorMessages.UnexpectedNewTarget;

          if (this.hasPlugin("classProperties")) {
            error += " or class properties";
          }

          this.raise(metaProp.start, error);
        }

        return metaProp;
      }

      return this.parseNew(node);
    };

    _proto.parseNew = function parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    };

    _proto.parseNewArguments = function parseNewArguments(node) {
      if (this.eat(types.parenL)) {
        var args = this.parseExprList(types.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    };

    _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types.backQuote);
      return this.finishNode(elem, "TemplateElement");
    };

    _proto.parseTemplate = function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };

    _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
      return this.parseExpression();
    };

    _proto.parseObjectLike = function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            break;
          }
        }

        var prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.state.exprAllowed = false;
      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    };

    _proto.maybeAsyncOrAccessorProp = function maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types.bracketL) || this.match(types.star));
    };

    _proto.parsePropertyDefinition = function parsePropertyDefinition(isPattern, refExpressionErrors) {
      var decorators = [];

      if (this.match(types.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }

        while (this.match(types.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var isAccessor = false;
      var startPos;
      var startLoc;

      if (this.match(types.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types.star);
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parsePropertyName(prop, false);

      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        var keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          isGenerator = this.eat(types.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          prop.kind = keyName;

          if (this.match(types.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    };

    _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    };

    _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
      return method.params;
    };

    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
      var _params;

      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var params = this.getObjectOrClassMethodParams(method);
      var start = method.start;

      if (params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    };

    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    };

    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    };

    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    };

    _proto.parsePropertyName = function parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) || this.match(types.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (!this.isPrivateName(prop.key)) {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    };

    _proto.initFunction = function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    };

    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      if (inClassScope === void 0) {
        inClassScope = false;
      }

      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    };

    _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    };

    _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      var flags = functionFlags(isAsync, false);

      if (!this.match(types.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    };

    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    };

    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
      if (isMethod === void 0) {
        isMethod = false;
      }

      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    };

    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
      var _this5 = this;

      if (isMethod === void 0) {
        isMethod = false;
      }

      var isExpression = allowExpression && !this.match(types.braceL);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this5.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

            _this5.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          var strictModeChanged = !oldStrict && _this5.state.strict;

          _this5.checkParams(node, !_this5.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (_this5.state.strict && node.id) {
            _this5.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    };

    _proto.isSimpleParamList = function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    };

    _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
      if (strictModeChanged === void 0) {
        strictModeChanged = true;
      }

      var checkClashes = new Set();

      for (var _i4 = 0, _node$params2 = node.params; _i4 < _node$params2.length; _i4++) {
        var param = _node$params2[_i4];
        this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
      }
    };

    _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    };

    _proto.parseExprListItem = function parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {
      var elt;

      if (this.match(types.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }

        elt = null;
      } else if (this.match(types.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem, refNeedsArrowPos);
      }

      return elt;
    };

    _proto.parseIdentifier = function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    };

    _proto.createIdentifier = function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    };

    _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
      var name;
      var _this$state = this.state,
          start = _this$state.start,
          type = _this$state.type;

      if (type === types.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
        var curContext = this.curContext();

        if ((type === types._class || type === types._function) && (curContext === types$1.functionStatement || curContext === types$1.functionExpression)) {
          this.state.context.pop();
        }
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    };

    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (this.prodParam.hasYield && word === "yield") {
        this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
        return;
      }

      if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
        }
      }

      if (this.scope.inClass && !this.scope.inNonArrowFunction && word === "arguments") {
        this.raise(startLoc, ErrorMessages.ArgumentsInClass);
        return;
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        if (!this.prodParam.hasAwait && word === "await") {
          this.raise(startLoc, this.hasPlugin("topLevelAwait") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);
        } else {
          this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
        }
      }
    };

    _proto.isAwaitAllowed = function isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    };

    _proto.parseAwait = function parseAwait() {
      var node = this.startNode();
      this.next();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);

      if (this.eat(types.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin("v8intrinsic") && this.match(types.modulo)) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary();
      }

      return this.finishNode(node, "AwaitExpression");
    };

    _proto.parseYield = function parseYield() {
      var node = this.startNode();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
      this.next();

      if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types.star);
        node.argument = this.parseMaybeAssign();
      }

      return this.finishNode(node, "YieldExpression");
    };

    _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    };

    _proto.parseSmartPipelineBody = function parseSmartPipelineBody(childExpression, startPos, startLoc) {
      this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
    };

    _proto.checkSmartPipelineBodyEarlyErrors = function checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
      if (this.match(types.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (childExpression.type === "SequenceExpression") {
        this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
      }
    };

    _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);
      var isSimpleReference = this.isSimpleReference(childExpression);

      if (isSimpleReference) {
        bodyNode.callee = childExpression;
      } else {
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
      }

      return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
    };

    _proto.isSimpleReference = function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    };

    _proto.withTopicPermittingContext = function withTopicPermittingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withTopicForbiddingContext = function withTopicForbiddingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    };

    _proto.allowInAnd = function allowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    };

    _proto.disallowInAnd = function disallowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    };

    _proto.registerTopicReference = function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    };

    _proto.primaryTopicReferenceIsAllowedInCurrentTopicContext = function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    };

    _proto.topicReferenceWasUsedInCurrentTopicContext = function topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    };

    _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    };

    return ExpressionParser;
  }(LValParser);

  var loopLabel = {
    kind: "loop"
  },
      switchLabel = {
    kind: "switch"
  };
  var FUNC_NO_FLAGS = 0,
      FUNC_STATEMENT = 1,
      FUNC_HANGING_STATEMENT = 2,
      FUNC_NULLABLE_ID = 4;
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

  var StatementParser = function (_ExpressionParser) {
    _inheritsLoose(StatementParser, _ExpressionParser);

    function StatementParser() {
      return _ExpressionParser.apply(this, arguments) || this;
    }

    var _proto = StatementParser.prototype;

    _proto.parseTopLevel = function parseTopLevel(file, program) {
      program.sourceType = this.options.sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, types.eof);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
          var _Array$from2$_i = _Array$from2[_i2],
              name = _Array$from2$_i[0];
          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      file.program = this.finishNode(program, "Program");
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = this.tokens;
      return this.finishNode(file, "File");
    };

    _proto.stmtToDirective = function stmtToDirective(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    };

    _proto.parseInterpreterDirective = function parseInterpreterDirective() {
      if (!this.match(types.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    };

    _proto.isLet = function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      var next = this.nextTokenStart();
      var nextCh = this.input.charCodeAt(next);
      if (nextCh === 91) return true;
      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        var pos = next + 1;

        while (isIdentifierChar(this.input.charCodeAt(pos))) {
          ++pos;
        }

        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) return true;
      }

      return false;
    };

    _proto.parseStatement = function parseStatement(context, topLevel) {
      if (this.match(types.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    };

    _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = types._var;
        kind = "let";
      }

      switch (starttype) {
        case types._break:
        case types._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types._debugger:
          return this.parseDebuggerStatement(node);

        case types._do:
          return this.parseDoStatement(node);

        case types._for:
          return this.parseForStatement(node);

        case types._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types._if:
          return this.parseIfStatement(node);

        case types._return:
          return this.parseReturnStatement(node);

        case types._switch:
          return this.parseSwitchStatement(node);

        case types._throw:
          return this.parseThrowStatement(node);

        case types._try:
          return this.parseTryStatement(node);

        case types._const:
        case types._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types._while:
          return this.parseWhileStatement(node);

        case types._with:
          return this.parseWithStatement(node);

        case types.braceL:
          return this.parseBlock();

        case types.semi:
          return this.parseEmptyStatement(node);

        case types._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
          }

        case types._export:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }

            this.next();
            var result;

            if (starttype === types._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    };

    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raiseWithData(node.start, {
          code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
        }, ErrorMessages.ImportOutsideModule);
      }
    };

    _proto.takeDecorators = function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    };

    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
      return this.match(types._class);
    };

    _proto.parseDecorators = function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    };

    _proto.parseDecorator = function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.eat(types.parenL)) {
          expr = this.parseExpression();
          this.expect(types.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types.dot)) {
            var _node = this.startNodeAt(startPos, startLoc);

            _node.object = expr;
            _node.property = this.parseIdentifier(true);
            _node.computed = false;
            expr = this.finishNode(_node, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    };

    _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    };

    _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };

    _proto.verifyBreakContinue = function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    };

    _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };

    _proto.parseHeaderExpression = function parseHeaderExpression() {
      this.expect(types.parenL);
      var val = this.parseExpression();
      this.expect(types.parenR);
      return val;
    };

    _proto.parseDoStatement = function parseDoStatement(node) {
      var _this = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types._while);
      node.test = this.parseHeaderExpression();
      this.eat(types.semi);
      return this.finishNode(node, "DoWhileStatement");
    };

    _proto.parseForStatement = function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types.parenL);

      if (this.match(types.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var isLet = this.isLet();

      if (this.match(types._var) || this.match(types._const) || isLet) {
        var _init = this.startNode();

        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);

      if (this.match(types._in) || this.isContextual("of")) {
        this.toAssignable(init, true);
        var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    };

    _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    };

    _proto.parseIfStatement = function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };

    _proto.parseReturnStatement = function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    };

    _proto.parseSwitchStatement = function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(types.braceR);) {
        if (this.match(types._case) || this.match(types._default)) {
          var isCase = this.match(types._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };

    _proto.parseThrowStatement = function parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };

    _proto.parseCatchClauseParam = function parseCatchClauseParam() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, "catch clause", BIND_LEXICAL);
      return param;
    };

    _proto.parseTryStatement = function parseTryStatement(node) {
      var _this2 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types.parenL)) {
          this.expect(types.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(function () {
          return _this2.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    };

    _proto.parseVarStatement = function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };

    _proto.parseWhileStatement = function parseWhileStatement(node) {
      var _this3 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this3.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };

    _proto.parseWithStatement = function parseWithStatement(node) {
      var _this4 = this;

      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(function () {
        return _this4.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    };

    _proto.parseEmptyStatement = function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };

    _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, context) {
      for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
        var label = _this$state$labels2[_i4];

        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];

        if (_label.statementStart === node.start) {
          _label.statementStart = this.state.start;
          _label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };

    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };

    _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      if (allowDirectives === void 0) {
        allowDirectives = false;
      }

      if (createNewLexicalScope === void 0) {
        createNewLexicalScope = true;
      }

      var node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(types.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    };

    _proto.isValidDirective = function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    };

    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    };

    _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;

      while (!this.match(end)) {
        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    };

    _proto.parseFor = function parseFor(node, init) {
      var _this5 = this;

      node.init = init;
      this.expect(types.semi);
      node.test = this.match(types.semi) ? null : this.parseExpression();
      this.expect(types.semi);
      node.update = this.match(types.parenR) ? null : this.parseExpression();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this5.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    };

    _proto.parseForIn = function parseForIn(node, init, awaitAt) {
      var _this6 = this;

      var isForIn = this.match(types._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this6.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };

    _proto.parseVar = function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types.comma)) break;
      }

      return node;
    };

    _proto.parseVarId = function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
    };

    _proto.parseFunction = function parseFunction(node, statement, isAsync) {
      var _this7 = this;

      if (statement === void 0) {
        statement = FUNC_NO_FLAGS;
      }

      if (isAsync === void 0) {
        isAsync = false;
      }

      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withTopicForbiddingContext(function () {
        _this7.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    };

    _proto.parseFunctionId = function parseFunctionId(requireId) {
      return requireId || this.match(types.name) ? this.parseIdentifier() : null;
    };

    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
      this.expect(types.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);
      this.expressionScope.exit();
    };

    _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    };

    _proto.parseClass = function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };

    _proto.isClassProperty = function isClassProperty() {
      return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
    };

    _proto.isClassMethod = function isClassMethod() {
      return this.match(types.parenL);
    };

    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
    };

    _proto.parseClassBody = function parseClassBody(constructorAllowsSuper, oldStrict) {
      var _this8 = this;

      this.classScope.enter();
      var state = {
        constructorAllowsSuper: constructorAllowsSuper,
        hadConstructor: false,
        hadStaticBlock: false
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types.braceL);
      this.withTopicForbiddingContext(function () {
        while (!_this8.match(types.braceR)) {
          if (_this8.eat(types.semi)) {
            if (decorators.length > 0) {
              throw _this8.raise(_this8.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }

            continue;
          }

          if (_this8.match(types.at)) {
            decorators.push(_this8.parseDecorator());
            continue;
          }

          var member = _this8.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this8.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this8.parseClassMember(classBody, member, state);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this8.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    };

    _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
      var key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      return false;
    };

    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
      var isStatic = this.isContextual("static");

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(types.braceL)) {
          this.parseClassStaticBlock(classBody, member, state);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    };

    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;

      if (this.eat(types.star)) {
        method.kind = "method";
        this.parseClassElementName(method);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parseClassElementName(member);
      var isPrivate = this.isPrivateName(key);
      var isSimple = key.type === "Identifier";
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.constructorAllowsSuper;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        var isGenerator = this.eat(types.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {
        method.kind = key.name;
        this.parseClassElementName(publicMethod);

        if (this.isPrivateName(method.key)) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    };

    _proto.parseClassElementName = function parseClassElementName(member) {
      var key = this.parsePropertyName(member, true);

      if (!member.computed && member["static"] && (key.name === "prototype" || key.value === "prototype")) {
        this.raise(key.start, ErrorMessages.StaticPrototype);
      }

      if (this.isPrivateName(key) && this.getPrivateNameSV(key) === "constructor") {
        this.raise(key.start, ErrorMessages.ConstructorClassPrivateField);
      }

      return key;
    };

    _proto.parseClassStaticBlock = function parseClassStaticBlock(classBody, member, state) {
      var _member$decorators;

      this.expectPlugin("classStaticBlock", member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      var oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      var body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, types.braceR);
      this.prodParam.exit();
      this.expressionScope.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));

      if (state.hadStaticBlock) {
        this.raise(member.start, ErrorMessages.DuplicateStaticBlock);
      }

      if ((_member$decorators = member.decorators) == null ? void 0 : _member$decorators.length) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }

      state.hadStaticBlock = true;
    };

    _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    };

    _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
      this.expectPlugin("classPrivateProperties", prop.key.start);
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    };

    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    };

    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      this.expectPlugin("classPrivateMethods", method.key.start);
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
    };

    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    };

    _proto.parseClassProperty = function parseClassProperty(node) {
      if (!node.typeAnnotation || this.match(types.eq)) {
        this.expectPlugin("classProperties");
      }

      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    };

    _proto.parseInitializer = function parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    };

    _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
      if (bindingType === void 0) {
        bindingType = BIND_CLASS;
      }

      if (this.match(types.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, "class name", bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    };

    _proto.parseClassSuper = function parseClassSuper(node) {
      node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
    };

    _proto.parseExport = function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types.braceL);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types.braceL);
    };

    _proto.eatExportStar = function eatExportStar(node) {
      return this.eat(types.star);
    };

    _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types.braceL)) {
        var _node$specifiers;

        if (!node.specifiers) node.specifiers = [];

        (_node$specifiers = node.specifiers).push.apply(_node$specifiers, this.parseExportSpecifiers());

        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    };

    _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    };

    _proto.isAsyncFunction = function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    };

    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        var res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    };

    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
      return this.parseStatement(null);
    };

    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
      if (this.match(types.name)) {
        var value = this.state.value;

        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }

        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          var l = this.lookahead();

          if (l.type === types.name && l.value !== "from" || l.type === types.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      var hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || this.match(types.name) && hasFrom) {
        return true;
      }

      if (this.match(types._default) && hasFrom) {
        var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    };

    _proto.parseExportFrom = function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        var assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    };

    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
      if (this.match(types.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    };

    _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            var declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) == null ? void 0 : _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (var _i6 = 0, _node$specifiers3 = node.specifiers; _i6 < _node$specifiers3.length; _i6++) {
            var specifier = _node$specifiers3[_i6];
            var exported = specifier.exported;
            var exportedName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportedName);

            if (!isFrom && specifier.local) {
              var local = specifier.local;

              if (local.type === "StringLiteral") {
                this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
              } else {
                this.checkReservedWord(local.name, local.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _i8 = 0, _node$declaration$dec2 = node.declaration.declarations; _i8 < _node$declaration$dec2.length; _i8++) {
              var _declaration = _node$declaration$dec2[_i8];
              this.checkDeclaration(_declaration.id);
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    };

    _proto.checkDeclaration = function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i10 = 0, _node$properties2 = node.properties; _i10 < _node$properties2.length; _i10++) {
          var prop = _node$properties2[_i10];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i12 = 0, _node$elements2 = node.elements; _i12 < _node$elements2.length; _i12++) {
          var elem = _node$elements2[_i12];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    };

    _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
      if (this.state.exportedIdentifiers.indexOf(name) > -1) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }

      this.state.exportedIdentifiers.push(name);
    };

    _proto.parseExportSpecifiers = function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    };

    _proto.parseModuleExportName = function parseModuleExportName() {
      if (this.match(types.string)) {
        this.expectPlugin("moduleStringNames");
        var result = this.parseLiteral(this.state.value, "StringLiteral");
        var surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
        }

        return result;
      }

      return this.parseIdentifier(true);
    };

    _proto.parseImport = function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      var assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
          var attributes = this.maybeParseModuleAttributes();

          if (attributes) {
            node.attributes = attributes;
          }
        }

      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };

    _proto.parseImportSource = function parseImportSource() {
      if (!this.match(types.string)) this.unexpected();
      return this.parseExprAtom();
    };

    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
      return this.match(types.name);
    };

    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    };

    _proto.parseAssertEntries = function parseAssertEntries() {
      var attrs = [];
      var attrNames = new Set();

      do {
        if (this.match(types.braceR)) {
          break;
        }

        var node = this.startNode();
        var keyName = this.state.value;

        if (this.match(types.string)) {
          node.key = this.parseLiteral(keyName, "StringLiteral");
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(types.colon);

        if (keyName !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, keyName);
        }

        if (attrNames.has(keyName)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
        }

        attrNames.add(keyName);

        if (!this.match(types.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseLiteral(this.state.value, "StringLiteral");
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types.comma));

      return attrs;
    };

    _proto.maybeParseModuleAttributes = function maybeParseModuleAttributes() {
      if (this.match(types._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      var attrs = [];
      var attributes = new Set();

      do {
        var node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }

        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }

        attributes.add(node.key.name);
        this.expect(types.colon);

        if (!this.match(types.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseLiteral(this.state.value, "StringLiteral");
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types.comma));

      return attrs;
    };

    _proto.maybeParseImportAssertions = function maybeParseImportAssertions() {
      if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions")) return [];
        return null;
      }

      this.eat(types.braceL);
      var attrs = this.parseAssertEntries();
      this.eat(types.braceR);
      return attrs;
    };

    _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    };

    _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
      if (this.match(types.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    };

    _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types.braceL);

      while (!this.eat(types.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }

          this.expect(types.comma);
          if (this.eat(types.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    };

    _proto.parseImportSpecifier = function parseImportSpecifier(node) {
      var specifier = this.startNode();
      specifier.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        var imported = specifier.imported;

        if (imported.type === "StringLiteral") {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
        }

        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = imported.__clone();
      }

      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };

    return StatementParser;
  }(ExpressionParser);

  var ClassScope = function ClassScope() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  };

  var ClassScopeHandler = function () {
    function ClassScopeHandler(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    var _proto = ClassScopeHandler.prototype;

    _proto.current = function current() {
      return this.stack[this.stack.length - 1];
    };

    _proto.enter = function enter() {
      this.stack.push(new ClassScope());
    };

    _proto.exit = function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();

      for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
        var _Array$from2$_i = _Array$from2[_i2],
            name = _Array$from2$_i[0],
            pos = _Array$from2$_i[1];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    };

    _proto.declarePrivateName = function declarePrivateName(name, elementType, pos) {
      var classScope = this.current();
      var redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        var accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors["delete"](name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames["delete"](name);
    };

    _proto.usePrivateName = function usePrivateName(name, pos) {
      var classScope;

      for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
        classScope = _this$stack2[_i4];
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    };

    return ClassScopeHandler;
  }();

  var Parser = function (_StatementParser) {
    _inheritsLoose(Parser, _StatementParser);

    function Parser(options, input) {
      var _this;

      options = getOptions(options);
      _this = _StatementParser.call(this, options, input) || this;

      var ScopeHandler = _this.getScopeHandler();

      _this.options = options;
      _this.inModule = _this.options.sourceType === "module";
      _this.scope = new ScopeHandler(_this.raise.bind(_assertThisInitialized(_this)), _this.inModule);
      _this.prodParam = new ProductionParameterHandler();
      _this.classScope = new ClassScopeHandler(_this.raise.bind(_assertThisInitialized(_this)));
      _this.expressionScope = new ExpressionScopeHandler(_this.raise.bind(_assertThisInitialized(_this)));
      _this.plugins = pluginsMap(_this.options.plugins);
      _this.filename = options.sourceFilename;
      return _this;
    }

    var _proto = Parser.prototype;

    _proto.getScopeHandler = function getScopeHandler() {
      return ScopeHandler;
    };

    _proto.parse = function parse() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    };

    return Parser;
  }(StatementParser);

  function pluginsMap(plugins) {
    var pluginMap = new Map();

    for (var _i2 = 0; _i2 < plugins.length; _i2++) {
      var plugin = plugins[_i2];

      var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
          name = _ref[0],
          options = _ref[1];

      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse$1(input, options) {
    var _options;

    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);

      try {
        options.sourceType = "module";
        var parser = getParser(options, input);
        var ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }

  function getParser(options, input) {
    var cls = Parser;

    if (options == null ? void 0 : options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  var parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    var pluginList = mixinPluginNames.filter(function (name) {
      return hasPlugin(pluginsFromOptions, name);
    });
    var key = pluginList.join("/");
    var cls = parserClassCache[key];

    if (!cls) {
      cls = Parser;

      for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
        var plugin = pluginList[_i2];
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  var hoistVariablesVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    VariableDeclaration: function VariableDeclaration(path) {
      if (path.node.kind !== "var") return;
      var bindings = path.getBindingIdentifiers();

      for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        path.scope.push({
          id: bindings[key]
        });
      }

      var exprs = [];

      for (var _i2 = 0, _arr = path.node.declarations; _i2 < _arr.length; _i2++) {
        var declar = _arr[_i2];

        if (declar.init) {
          exprs.push(expressionStatement(assignmentExpression("=", declar.id, declar.init)));
        }
      }

      path.replaceWithMultiple(exprs);
    }
  };
  function replaceWithMultiple(nodes) {
    var _pathCache$get;

    this.resync();
    nodes = this._verifyNodeList(nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_pathCache$get = path.get(this.parent)) == null ? void 0 : _pathCache$get["delete"](this.node);
    this.node = this.container[this.key] = null;
    var paths = this.insertAfter(nodes);

    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }

    return paths;
  }
  function replaceWithSourceString(replacement) {
    this.resync();

    try {
      replacement = "(" + replacement + ")";
      replacement = parse$1(replacement);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }

      throw err;
    }

    replacement = replacement.program.body[0].expression;
    traverse$1.removeProperties(replacement);
    return this.replaceWith(replacement);
  }
  function replaceWith(replacement) {
    this.resync();

    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }

    if (replacement instanceof NodePath) {
      replacement = replacement.node;
    }

    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }

    if (this.node === replacement) {
      return [this];
    }

    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }

    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }

    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }

    var nodePath = "";

    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = expressionStatement(replacement);
        nodePath = "expression";
      }
    }

    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }

    var oldNode = this.node;

    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }

    this._replaceWith(replacement);

    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node) {
    var _pathCache$get2;

    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }

    if (this.inList) {
      validate(this.parent, this.key, [node]);
    } else {
      validate(this.parent, this.key, node);
    }

    this.debug("Replace with " + (node == null ? void 0 : node.type));
    (_pathCache$get2 = path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this)["delete"](this.node);
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    this.resync();
    var toSequenceExpression$1 = toSequenceExpression(nodes, this.scope);

    if (toSequenceExpression$1) {
      return this.replaceWith(toSequenceExpression$1)[0].get("expressions");
    }

    var functionParent = this.getFunctionParent();
    var isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
    var container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    this.traverse(hoistVariablesVisitor);
    var completionRecords = this.get("callee").getCompletionRecords();

    for (var _iterator = _createForOfIteratorHelperLoose(completionRecords), _step; !(_step = _iterator()).done;) {
      var path = _step.value;
      if (!path.isExpressionStatement()) continue;
      var loop = path.findParent(function (path) {
        return path.isLoop();
      });

      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          var _callee = this.get("callee");

          uid = _callee.scope.generateDeclaredUidIdentifier("ret");

          _callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));

          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier(uid.name);
        }

        path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(returnStatement(path.node.expression));
      }
    }

    var callee = this.get("callee");
    callee.arrowFunctionToExpression();

    if (isParentAsync && traverse$1.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES)) {
      callee.set("async", true);
      this.replaceWith(awaitExpression(this.node));
    }

    return callee.get("body.body");
  }
  function replaceInline(nodes) {
    this.resync();

    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);

        var paths = this._containerInsertAfter(nodes);

        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }

  var NodePath_replacement = /*#__PURE__*/Object.freeze({
    __proto__: null,
    replaceWithMultiple: replaceWithMultiple,
    replaceWithSourceString: replaceWithSourceString,
    replaceWith: replaceWith,
    _replaceWith: _replaceWith,
    replaceExpressionWithStatements: replaceExpressionWithStatements,
    replaceInline: replaceInline
  });

  var VALID_CALLEES = ["String", "Number", "Math"];
  var INVALID_METHODS = ["random"];
  function evaluateTruthy() {
    var res = this.evaluate();
    if (res.confident) return !!res.value;
  }

  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }

  function evaluateCached(path, state) {
    var node = path.node;
    var seen = state.seen;

    if (seen.has(node)) {
      var existing = seen.get(node);

      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      var item = {
        resolved: false
      };
      seen.set(node, item);

      var val = _evaluate(path, state);

      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }

      return val;
    }
  }

  function _evaluate(path, state) {
    if (!state.confident) return;
    var node = path.node;

    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, node.quasis, state);
    }

    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      var object = path.get("tag.object");
      var name = object.node.name;
      var property = path.get("tag.property");

      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === "raw") {
        return evaluateQuasis(path, node.quasi.quasis, state, true);
      }
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluateCached(path.get("test"), state);
      if (!state.confident) return;

      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: node
    })) {
      var _property = path.get("property");

      var _object = path.get("object");

      if (_object.isLiteral() && _property.isIdentifier()) {
        var value = _object.node.value;
        var type = typeof value;

        if (type === "number" || type === "string") {
          return value[_property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path, state);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path, state);
      }

      if (binding == null ? void 0 : binding.hasValue) {
        return binding.value;
      } else {
        if (node.name === "undefined") {
          return binding ? deopt(binding.path, state) : undefined;
        } else if (node.name === "Infinity") {
          return binding ? deopt(binding.path, state) : Infinity;
        } else if (node.name === "NaN") {
          return binding ? deopt(binding.path, state) : NaN;
        }

        var resolved = path.resolve();

        if (resolved === path) {
          return deopt(path, state);
        } else {
          return evaluateCached(resolved, state);
        }
      }
    }

    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");

      if (node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluateCached(argument, state);
      if (!state.confident) return;

      switch (node.operator) {
        case "!":
          return !arg;

        case "+":
          return +arg;

        case "-":
          return -arg;

        case "~":
          return ~arg;

        case "typeof":
          return typeof arg;
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");

      for (var _iterator = _createForOfIteratorHelperLoose(elems), _step; !(_step = _iterator()).done;) {
        var elem = _step.value;
        var elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elemValue.deopt, state);
        }
      }

      return arr;
    }

    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");

      for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;

        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        var keyPath = prop.get("key");
        var key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(key.deopt, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        var valuePath = prop.get("value");

        var _value = valuePath.evaluate();

        if (!_value.confident) {
          return deopt(_value.deopt, state);
        }

        _value = _value.value;
        obj[key] = _value;
      }

      return obj;
    }

    if (path.isLogicalExpression()) {
      var wasConfident = state.confident;
      var left = evaluateCached(path.get("left"), state);
      var leftConfident = state.confident;
      state.confident = wasConfident;
      var right = evaluateCached(path.get("right"), state);
      var rightConfident = state.confident;

      switch (node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;

        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluateCached(path.get("left"), state);

      if (!state.confident) return;

      var _right = evaluateCached(path.get("right"), state);

      if (!state.confident) return;

      switch (node.operator) {
        case "-":
          return _left - _right;

        case "+":
          return _left + _right;

        case "/":
          return _left / _right;

        case "*":
          return _left * _right;

        case "%":
          return _left % _right;

        case "**":
          return Math.pow(_left, _right);

        case "<":
          return _left < _right;

        case ">":
          return _left > _right;

        case "<=":
          return _left <= _right;

        case ">=":
          return _left >= _right;

        case "==":
          return _left == _right;

        case "!=":
          return _left != _right;

        case "===":
          return _left === _right;

        case "!==":
          return _left !== _right;

        case "|":
          return _left | _right;

        case "&":
          return _left & _right;

        case "^":
          return _left ^ _right;

        case "<<":
          return _left << _right;

        case ">>":
          return _left >> _right;

        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context;
      var func;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global[node.callee.name];
      }

      if (callee.isMemberExpression()) {
        var _object2 = callee.get("object");

        var _property2 = callee.get("property");

        if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
          context = global[_object2.node.name];
          func = context[_property2.node.name];
        }

        if (_object2.isLiteral() && _property2.isIdentifier()) {
          var _type = typeof _object2.node.value;

          if (_type === "string" || _type === "number") {
            context = _object2.node.value;
            func = context[_property2.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(function (arg) {
          return evaluateCached(arg, state);
        });
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }

    deopt(path, state);
  }

  function evaluateQuasis(path, quasis, state, raw) {
    if (raw === void 0) {
      raw = false;
    }

    var str = "";
    var i = 0;
    var exprs = path.get("expressions");

    for (var _iterator3 = _createForOfIteratorHelperLoose(quasis), _step3; !(_step3 = _iterator3()).done;) {
      var elem = _step3.value;
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      var expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }

    if (!state.confident) return;
    return str;
  }

  function evaluate() {
    var state = {
      confident: true,
      deoptPath: null,
      seen: new Map()
    };
    var value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  }

  var NodePath_evaluation = /*#__PURE__*/Object.freeze({
    __proto__: null,
    evaluateTruthy: evaluateTruthy,
    evaluate: evaluate
  });

  function getFunctionArity (node) {
    var params = node.params;

    for (var i = 0; i < params.length; i++) {
      var param = params[i];

      if (isAssignmentPattern(param) || isRestElement(param)) {
        return i;
      }
    }

    return params.length;
  }

  function makeStatementFormatter(fn) {
    return {
      code: function code(str) {
        return "/* @babel/template */;\n" + str;
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return fn(ast.program.body.slice(1));
      }
    };
  }

  var smart = makeStatementFormatter(function (body) {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  var statements = makeStatementFormatter(function (body) {
    return body;
  });
  var statement = makeStatementFormatter(function (body) {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }

    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    return body[0];
  });
  var expression = {
    code: function code(str) {
      return "(\n" + str + "\n)";
    },
    validate: function validate(ast) {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }

      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: function unwrap(_ref) {
      var program = _ref.program;
      var _program$body = program.body,
          stmt = _program$body[0];
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  var program$1 = {
    code: function code(str) {
      return str;
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return ast.program;
    }
  };

  function merge(a, b) {
    var _b$placeholderWhiteli = b.placeholderWhitelist,
        placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
        _b$placeholderPattern = b.placeholderPattern,
        placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
        _b$preserveComments = b.preserveComments,
        preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
        _b$syntacticPlacehold = b.syntacticPlaceholders,
        syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }
  function validate$2(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }

    var _ref = opts || {},
        placeholderWhitelist = _ref.placeholderWhitelist,
        placeholderPattern = _ref.placeholderPattern,
        preserveComments = _ref.preserveComments,
        syntacticPlaceholders = _ref.syntacticPlaceholders,
        parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);

    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }

    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }

    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce(function (acc, replacement, i) {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }

    throw new Error("Template replacements must be an array, object, null, or undefined");
  }

  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    var placeholderWhitelist = opts.placeholderWhitelist,
        placeholderPattern = opts.placeholderPattern,
        preserveComments = opts.preserveComments,
        syntacticPlaceholders = opts.syntacticPlaceholders;
    var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments: preserveComments
    });
    formatter.validate(ast);
    var syntactic = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var legacy = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var isLegacyRef = {
      value: undefined
    };
    traverse(ast, placeholderVisitorHandler, {
      syntactic: syntactic,
      legacy: legacy,
      isLegacyRef: isLegacyRef,
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    });
    return Object.assign({
      ast: ast
    }, isLegacyRef.value ? legacy : syntactic);
  }

  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;

    var name;

    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      } else {
        name = node.name.name;
        state.isLegacyRef.value = false;
      }
    } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
      name = node.name;
      state.isLegacyRef.value = true;
    } else if (isStringLiteral(node)) {
      name = node.value;
      state.isLegacyRef.value = true;
    } else {
      return;
    }

    if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) == null ? void 0 : _state$placeholderWhi.has(name))) {
      return;
    }

    ancestors = ancestors.slice();
    var _ancestors = ancestors[ancestors.length - 1],
        parent = _ancestors.node,
        key = _ancestors.key;
    var type;

    if (isStringLiteral(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }

    var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
        placeholders = _ref.placeholders,
        placeholderNames = _ref.placeholderNames;

    placeholders.push({
      name: name,
      type: type,
      resolve: function resolve(ast) {
        return resolveAncestors(ast, ancestors);
      },
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }

  function resolveAncestors(ast, ancestors) {
    var parent = ast;

    for (var i = 0; i < ancestors.length - 1; i++) {
      var _ancestors$i = ancestors[i],
          _key = _ancestors$i.key,
          _index = _ancestors$i.index;

      if (_index === undefined) {
        parent = parent[_key];
      } else {
        parent = parent[_key][_index];
      }
    }

    var _ancestors2 = ancestors[ancestors.length - 1],
        key = _ancestors2.key,
        index = _ancestors2.index;
    return {
      parent: parent,
      key: key,
      index: index
    };
  }

  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    var plugins = (parserOpts.plugins || []).slice();

    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }

    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins: plugins
    });

    try {
      return parse$1(code, parserOpts);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += "\n" + codeFrameColumns(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }

      throw err;
    }
  }

  function populatePlaceholders(metadata, replacements) {
    var ast = cloneNode(metadata.ast);

    if (replacements) {
      metadata.placeholders.forEach(function (placeholder) {
        if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
          var placeholderName = placeholder.name;
          throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
        }
      });
      Object.keys(replacements).forEach(function (key) {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error("Unknown substitution \"" + key + "\" given");
        }
      });
    }

    metadata.placeholders.slice().reverse().forEach(function (placeholder) {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
        throw e;
      }
    });
    return ast;
  }

  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(function (node) {
          return cloneNode(node);
        });
      } else if (typeof replacement === "object") {
        replacement = cloneNode(replacement);
      }
    }

    var _placeholder$resolve = placeholder.resolve(ast),
        parent = _placeholder$resolve.parent,
        key = _placeholder$resolve.key,
        index = _placeholder$resolve.index;

    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral(replacement);
      }

      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement(identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }

          if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }

      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }

      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }

    if (index === undefined) {
      validate(parent, key, replacement);
      parent[key] = replacement;
    } else {
      var items = parent[key].slice();

      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice.apply(items, [index, 1].concat(replacement));
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }

      validate(parent, key, items);
      parent[key] = items;
    }
  }

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    var metadata;
    return function (arg) {
      var replacements = normalizeReplacements(arg);
      if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
      return formatter.unwrap(populatePlaceholders(metadata, replacements));
    };
  }

  function literalTemplate(formatter, tpl, opts) {
    var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
        metadata = _buildLiteralData.metadata,
        names = _buildLiteralData.names;

    return function (arg) {
      var defaultReplacements = {};
      arg.forEach(function (replacement, i) {
        defaultReplacements[names[i]] = replacement;
      });
      return function (arg) {
        var replacements = normalizeReplacements(arg);

        if (replacements) {
          Object.keys(replacements).forEach(function (key) {
            if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }

        return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }

  function buildLiteralData(formatter, tpl, opts) {
    var names;
    var nameSet;
    var metadata;
    var prefix = "";

    do {
      prefix += "$";
      var result = buildTemplateCode(tpl, prefix);
      names = result.names;
      nameSet = new Set(names);
      metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
    } while (metadata.placeholders.some(function (placeholder) {
      return placeholder.isDuplicate && nameSet.has(placeholder.name);
    }));

    return {
      metadata: metadata,
      names: names
    };
  }

  function buildTemplateCode(tpl, prefix) {
    var names = [];
    var code = tpl[0];

    for (var i = 1; i < tpl.length; i++) {
      var value = "" + prefix + (i - 1);
      names.push(value);
      code += value + tpl[i];
    }

    return {
      names: names,
      code: code
    };
  }

  var NO_PLACEHOLDER = validate$2({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    var templateFnCache = new WeakMap();
    var templateAstCache = new WeakMap();
    var cachedOpts = defaultOpts || validate$2(null);
    return Object.assign(function (tpl) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace(stringTemplate(formatter, tpl, merge(cachedOpts, validate$2(args[0]))));
      } else if (Array.isArray(tpl)) {
        var builder = templateFnCache.get(tpl);

        if (!builder) {
          builder = literalTemplate(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }

        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, merge(cachedOpts, validate$2(tpl)));
      }

      throw new Error("Unexpected template param " + typeof tpl);
    }, {
      ast: function ast(tpl) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return stringTemplate(formatter, tpl, merge(merge(cachedOpts, validate$2(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          var builder = templateAstCache.get(tpl);

          if (!builder) {
            builder = literalTemplate(formatter, tpl, merge(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }

          return builder(args)();
        }

        throw new Error("Unexpected template param " + typeof tpl);
      }
    });
  }

  function extendedTrace(fn) {
    var rootStack = "";

    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }

    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += "\n    =============\n" + rootStack;
        throw err;
      }
    };
  }

  var smart$1 = createTemplateBuilder(smart);
  var statement$1 = createTemplateBuilder(statement);
  var statements$1 = createTemplateBuilder(statements);
  var expression$1 = createTemplateBuilder(expression);
  var program$2 = createTemplateBuilder(program$1);
  var template = Object.assign(smart$1.bind(undefined), {
    smart: smart$1,
    statement: statement$1,
    statements: statements$1,
    expression: expression$1,
    program: program$2,
    ast: smart$1.ast
  });

  var buildPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var buildGeneratorPropertyMethodAssignmentWrapper = template("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var visitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      if (path.node.name !== state.name) return;
      var localDeclar = path.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar) return;
      state.selfReference = true;
      path.stop();
    }
  };

  function getNameFromLiteralId(id) {
    if (isNullLiteral(id)) {
      return "null";
    }

    if (isRegExpLiteral(id)) {
      return "_" + id.pattern + "_" + id.flags;
    }

    if (isTemplateLiteral(id)) {
      return id.quasis.map(function (quasi) {
        return quasi.value.raw;
      }).join("");
    }

    if (id.value !== undefined) {
      return id.value + "";
    }

    return "";
  }

  function wrap(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!isFunction(method)) return;
        var build = buildPropertyMethodAssignmentWrapper;

        if (method.generator) {
          build = buildGeneratorPropertyMethodAssignmentWrapper;
        }

        var _template = build({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name)
        }).expression;
        var params = _template.callee.body.body[0].params;

        for (var i = 0, len = getFunctionArity(method); i < len; i++) {
          params.push(scope.generateUidIdentifier("x"));
        }

        return _template;
      }
    }

    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  }

  function visit(node, name, scope) {
    var state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      references: [],
      name: name
    };
    var binding = scope.getOwnBinding(name);

    if (binding) {
      if (binding.kind === "param") {
        state.selfReference = true;
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node, visitor, state);
    }

    return state;
  }

  function nameFunction (_ref, localBinding) {
    var node = _ref.node,
        parent = _ref.parent,
        scope = _ref.scope,
        id = _ref.id;

    if (localBinding === void 0) {
      localBinding = false;
    }

    if (node.id) return;

    if ((isObjectProperty(parent) || isObjectMethod(parent, {
      kind: "method"
    })) && (!parent.computed || isLiteral(parent.key))) {
      id = parent.key;
    } else if (isVariableDeclarator(parent)) {
      id = parent.id;

      if (isIdentifier(id) && !localBinding) {
        var binding = scope.parent.getBinding(id.name);

        if (binding && binding.constant && scope.getBinding(id.name) === binding) {
          node.id = cloneNode(id);
          node.id[NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (isAssignmentExpression(parent, {
      operator: "="
    })) {
      id = parent.left;
    } else if (!id) {
      return;
    }

    var name;

    if (id && isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && isIdentifier(id)) {
      name = id.name;
    }

    if (name === undefined) {
      return;
    }

    name = toBindingIdentifierName(name);
    id = identifier(name);
    id[NOT_LOCAL_BINDING] = true;
    var state = visit(node, name, scope);
    return wrap(state, node, id, scope) || node;
  }

  function toComputedKey$1() {
    var node = this.node;
    var key;

    if (this.isMemberExpression()) {
      key = node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = node.key;
    } else {
      throw new ReferenceError("todo");
    }

    if (!node.computed) {
      if (isIdentifier(key)) key = stringLiteral(key.name);
    }

    return key;
  }
  function ensureBlock$1() {
    var body = this.get("body");
    var bodyNode = body.node;

    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }

    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }

    if (body.isBlockStatement()) {
      return bodyNode;
    }

    var statements = [];
    var stringPath = "body";
    var key;
    var listKey;

    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";

      if (this.isFunction()) {
        key = "argument";
        statements.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(expressionStatement(body.node));
      }
    }

    this.node.body = blockStatement(statements);
    var parentPath = this.get(stringPath);
    body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }

    hoistFunctionEnvironment(this);
  }
  function arrowFunctionToExpression(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$allowInsertArrow = _ref.allowInsertArrow,
        allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
        _ref$specCompliant = _ref.specCompliant,
        specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;

    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }

    var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);
    this.ensureBlock();
    this.node.type = "FunctionExpression";

    if (specCompliant) {
      var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

      if (checkBinding) {
        this.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }

      this.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
      this.replaceWith(callExpression(memberExpression(nameFunction(this, true) || this.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    }
  }

  function hoistFunctionEnvironment(fnPath, specCompliant, allowInsertArrow) {
    if (specCompliant === void 0) {
      specCompliant = false;
    }

    if (allowInsertArrow === void 0) {
      allowInsertArrow = true;
    }

    var thisEnvFn = fnPath.findParent(function (p) {
      return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
        "static": false
      });
    });
    var inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === "constructor";

    if (thisEnvFn.isClassProperty()) {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    }

    var _getScopeInformation = getScopeInformation(fnPath),
        thisPaths = _getScopeInformation.thisPaths,
        argumentsPaths = _getScopeInformation.argumentsPaths,
        newTargetPaths = _getScopeInformation.newTargetPaths,
        superProps = _getScopeInformation.superProps,
        superCalls = _getScopeInformation.superCalls;

    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      }

      var allSuperCalls = [];
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          allSuperCalls.push(child);
        }
      });
      var superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach(function (superCall) {
        var callee = identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }

    if (argumentsPaths.length > 0) {
      var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
        return identifier("arguments");
      });
      argumentsPaths.forEach(function (argumentsChild) {
        var argsRef = identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }

    if (newTargetPaths.length > 0) {
      var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
        return metaProperty(identifier("new"), identifier("target"));
      });
      newTargetPaths.forEach(function (targetChild) {
        var targetRef = identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }

    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      }

      var flatSuperProps = superProps.reduce(function (acc, superProp) {
        return acc.concat(standardizeSuperProperty(superProp));
      }, []);
      flatSuperProps.forEach(function (superProp) {
        var key = superProp.node.computed ? "" : superProp.get("property").node.name;
        var isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        });
        var isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node
        });
        var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        var args = [];

        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }

        if (isAssignment) {
          var value = superProp.parentPath.node.right;
          args.push(value);
        }

        var call = callExpression(identifier(superBinding), args);

        if (isCall) {
          superProp.parentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier("call")));
          thisPaths.push(superProp.parentPath.get("arguments.0"));
        } else if (isAssignment) {
          superProp.parentPath.replaceWith(call);
        } else {
          superProp.replaceWith(call);
        }
      });
    }

    var thisBinding;

    if (thisPaths.length > 0 || specCompliant) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);

      if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach(function (thisChild) {
          var thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (specCompliant) thisBinding = null;
      }
    }

    return thisBinding;
  }

  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      var assignmentPath = superProp.parentPath;
      var op = assignmentPath.node.operator.slice(0, -1);
      var value = assignmentPath.node.right;
      assignmentPath.node.operator = "=";

      if (superProp.node.computed) {
        var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        assignmentPath.get("left").replaceWith(memberExpression(superProp.node.object, assignmentExpression("=", tmp, superProp.node.property), true));
        assignmentPath.get("right").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));
      } else {
        assignmentPath.get("left").replaceWith(memberExpression(superProp.node.object, superProp.node.property));
        assignmentPath.get("right").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));
      }

      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      var updateExpr = superProp.parentPath;

      var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

      var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      var parts = [assignmentExpression("=", _tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression("+", identifier(_tmp.name), numericLiteral(1)))];

      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier(_tmp.name));
      }

      updateExpr.replaceWith(sequenceExpression(parts));
      var left = updateExpr.get("expressions.0.right");
      var right = updateExpr.get("expressions.1.left");
      return [left, right];
    }

    return [superProp];
  }

  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }

  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", function (thisBinding) {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
      var supers = new WeakSet();
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          if (supers.has(child.node)) return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
        }
      });
    });
  }

  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", function () {
      var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
    });
  }

  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    var op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, "superprop_" + op + ":" + (propName || ""), function () {
      var argsList = [];
      var fnBody;

      if (propName) {
        fnBody = memberExpression(_super(), identifier(propName));
      } else {
        var method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier(method.name), true);
      }

      if (isAssignment) {
        var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
      }

      return arrowFunctionExpression(argsList, fnBody);
    });
  }

  function getBinding(thisEnvFn, key, init) {
    var cacheKey = "binding:" + key;
    var data = thisEnvFn.getData(cacheKey);

    if (!data) {
      var id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }

    return data;
  }

  function getScopeInformation(fnPath) {
    var thisPaths = [];
    var argumentsPaths = [];
    var newTargetPaths = [];
    var superProps = [];
    var superCalls = [];
    fnPath.traverse({
      ClassProperty: function ClassProperty(child) {
        child.skip();
      },
      Function: function Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ThisExpression: function ThisExpression(child) {
        thisPaths.push(child);
      },
      JSXIdentifier: function JSXIdentifier(child) {
        if (child.node.name !== "this") return;

        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }

        thisPaths.push(child);
      },
      CallExpression: function CallExpression(child) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression: function MemberExpression(child) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        if (child.node.name !== "arguments") return;
        argumentsPaths.push(child);
      },
      MetaProperty: function MetaProperty(child) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    return {
      thisPaths: thisPaths,
      argumentsPaths: argumentsPaths,
      newTargetPaths: newTargetPaths,
      superProps: superProps,
      superCalls: superCalls
    };
  }

  var NodePath_conversion = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toComputedKey: toComputedKey$1,
    ensureBlock: ensureBlock$1,
    arrowFunctionToShadowed: arrowFunctionToShadowed,
    unwrapFunctionEnvironment: unwrapFunctionEnvironment,
    arrowFunctionToExpression: arrowFunctionToExpression
  });

  function matchesPattern$1(pattern, allowPartial) {
    return matchesPattern(this.node, pattern, allowPartial);
  }
  function has$2(key) {
    var val = this.node && this.node[key];

    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }
  function isStatic() {
    return this.scope.isStatic(this.node);
  }
  var is$1 = has$2;
  function isnt(key) {
    return !this.has(key);
  }
  function equals(key, value) {
    return this.node[key] === value;
  }
  function isNodeType(type) {
    return isType(this.type, type);
  }
  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }

    if (this.isExpression()) {
      return isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return isExpression(replacement);
    }

    return false;
  }
  function isCompletionRecord(allowInsideFunction) {
    var path = this;
    var first = true;

    do {
      var container = path.container;

      if (path.isFunction() && !first) {
        return !!allowInsideFunction;
      }

      first = false;

      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());

    return true;
  }
  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
      return false;
    } else {
      return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
  }
  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) return false;
    var binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module") return false;
    var path = binding.path;
    var parent = path.parentPath;
    if (!parent.isImportDeclaration()) return false;

    if (parent.node.source.value === moduleSource) {
      if (!importName) return true;
    } else {
      return false;
    }

    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }

    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }

    if (path.isImportSpecifier() && path.node.imported.name === importName) {
      return true;
    }

    return false;
  }
  function getSource() {
    var node = this.node;

    if (node.end) {
      var code = this.hub.getCode();
      if (code) return code.slice(node.start, node.end);
    }

    return "";
  }
  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }

  function getOuterFunction(path) {
    return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
  }

  function isExecutionUncertain(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";

      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";

      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";

      case "ForStatement":
        return key === "body" || key === "update";

      case "SwitchStatement":
        return key === "cases";

      case "TryStatement":
        return key === "handler";

      case "AssignmentPattern":
        return key === "right";

      case "OptionalMemberExpression":
        return key === "property";

      case "OptionalCallExpression":
        return key === "arguments";

      default:
        return false;
    }
  }

  function isExecutionUncertainInList(paths, maxIndex) {
    for (var i = 0; i < maxIndex; i++) {
      var path = paths[i];

      if (isExecutionUncertain(path.parent.type, path.parentKey)) {
        return true;
      }
    }

    return false;
  }

  function _guessExecutionStatusRelativeTo(target) {
    var funcParent = {
      "this": getOuterFunction(this),
      target: getOuterFunction(target)
    };

    if (funcParent.target.node !== funcParent["this"].node) {
      return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
    }

    var paths = {
      target: target.getAncestry(),
      "this": this.getAncestry()
    };
    if (paths.target.indexOf(this) >= 0) return "after";
    if (paths["this"].indexOf(target) >= 0) return "before";
    var commonPath;
    var commonIndex = {
      target: 0,
      "this": 0
    };

    while (!commonPath && commonIndex["this"] < paths["this"].length) {
      var path = paths["this"][commonIndex["this"]];
      commonIndex.target = paths.target.indexOf(path);

      if (commonIndex.target >= 0) {
        commonPath = path;
      } else {
        commonIndex["this"]++;
      }
    }

    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
    }

    if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }

    var divergence = {
      "this": paths["this"][commonIndex["this"] - 1],
      target: paths.target[commonIndex.target - 1]
    };

    if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
      return divergence.target.key > divergence["this"].key ? "before" : "after";
    }

    var keys = VISITOR_KEYS[commonPath.type];
    var keyPosition = {
      "this": keys.indexOf(divergence["this"].parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition["this"] ? "before" : "after";
  }
  var executionOrderCheckedNodes = new WeakSet();
  function _guessExecutionStatusRelativeToDifferentFunctions(target) {
    if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
      return "unknown";
    }

    var binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references) return "before";
    var referencePaths = binding.referencePaths;
    var allStatus;

    for (var _iterator = _createForOfIteratorHelperLoose(referencePaths), _step; !(_step = _iterator()).done;) {
      var path = _step.value;
      var childOfFunction = !!path.find(function (path) {
        return path.node === target.node;
      });
      if (childOfFunction) continue;

      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }

      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);

      var status = this._guessExecutionStatusRelativeTo(path);

      executionOrderCheckedNodes["delete"](path.node);

      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }

    return allStatus;
  }
  function resolve(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }
  function _resolve(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0) return;
    resolved = resolved || [];
    resolved.push(this);

    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      }
    } else if (this.isReferencedIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return;
      if (!binding.constant) return;
      if (binding.kind === "module") return;

      if (binding.path !== this) {
        var ret = binding.path.resolve(dangerous, resolved);
        if (this.find(function (parent) {
          return parent.node === ret.node;
        })) return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      var targetKey = this.toComputedKey();
      if (!isLiteral(targetKey)) return;
      var targetName = targetKey.value;
      var target = this.get("object").resolve(dangerous, resolved);

      if (target.isObjectExpression()) {
        var props = target.get("properties");

        for (var _i = 0, _arr = props; _i < _arr.length; _i++) {
          var prop = _arr[_i];
          if (!prop.isProperty()) continue;
          var key = prop.get("key");
          var match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match) return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        var elems = target.get("elements");
        var elem = elems[targetName];
        if (elem) return elem.resolve(dangerous, resolved);
      }
    }
  }
  function isConstantExpression() {
    if (this.isIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return false;
      return binding.constant;
    }

    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }

      if (this.isTemplateLiteral()) {
        return this.get("expressions").every(function (expression) {
          return expression.isConstantExpression();
        });
      }

      return true;
    }

    if (this.isUnaryExpression()) {
      if (this.get("operator").node !== "void") {
        return false;
      }

      return this.get("argument").isConstantExpression();
    }

    if (this.isBinaryExpression()) {
      return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }

    return false;
  }
  function isInStrictMode() {
    var start = this.isProgram() ? this : this.parentPath;
    var strictParent = start.find(function (path) {
      if (path.isProgram({
        sourceType: "module"
      })) return true;
      if (path.isClass()) return true;
      if (!path.isProgram() && !path.isFunction()) return false;

      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
        return false;
      }

      var node = path.node;
      if (path.isFunction()) node = node.body;

      for (var _iterator2 = _createForOfIteratorHelperLoose(node.directives), _step2; !(_step2 = _iterator2()).done;) {
        var directive = _step2.value;

        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  }

  var NodePath_introspection = /*#__PURE__*/Object.freeze({
    __proto__: null,
    matchesPattern: matchesPattern$1,
    has: has$2,
    isStatic: isStatic,
    is: is$1,
    isnt: isnt,
    equals: equals,
    isNodeType: isNodeType,
    canHaveVariableDeclarationOrExpression: canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: canSwapBetweenExpressionAndStatement,
    isCompletionRecord: isCompletionRecord,
    isStatementOrBlock: isStatementOrBlock,
    referencesImport: referencesImport,
    getSource: getSource,
    willIMaybeExecuteBefore: willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: _guessExecutionStatusRelativeTo,
    _guessExecutionStatusRelativeToDifferentFunctions: _guessExecutionStatusRelativeToDifferentFunctions,
    resolve: resolve,
    _resolve: _resolve,
    isConstantExpression: isConstantExpression,
    isInStrictMode: isInStrictMode
  });

  function call(key) {
    var opts = this.opts;
    this.debug(key);

    if (this.node) {
      if (this._call(opts[key])) return true;
    }

    if (this.node) {
      return this._call(opts[this.node.type] && opts[this.node.type][key]);
    }

    return false;
  }
  function _call(fns) {
    if (!fns) return false;

    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
      var fn = _step.value;
      if (!fn) continue;
      var node = this.node;
      if (!node) return true;
      var ret = fn.call(this.state, this, this.state);

      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
      }

      if (ret) {
        throw new Error("Unexpected return value from visitor method " + fn);
      }

      if (this.node !== node) return true;
      if (this._traverseFlags > 0) return true;
    }

    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;

    var denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist && denylist.indexOf(this.node.type) > -1;
  }
  function visit$1() {
    if (!this.node) {
      return false;
    }

    if (this.isDenylisted()) {
      return false;
    }

    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
      return false;
    }

    if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
      this.debug("Skip...");
      return this.shouldStop;
    }

    this.debug("Recursing into...");
    traverse$1.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    this.call("exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }

    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
  }
  function setScope() {
    if (this.opts && this.opts.noScope) return;
    var path = this.parentPath;
    var target;

    while (path && !target) {
      if (path.opts && path.opts.noScope) return;
      target = path.scope;
      path = path.parentPath;
    }

    this.scope = this.getScope(target);
    if (this.scope) this.scope.init();
  }
  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }

    this._traverseFlags = 0;

    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }

    this.setScope();
    return this;
  }
  function resync() {
    if (this.removed) return;

    this._resyncParent();

    this._resyncList();

    this._resyncKey();
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) return;

    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }

    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    var newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  }
  function popContext() {
    this.contexts.pop();

    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup$1(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }
  function setKey(key) {
    var _this$node;

    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }
  function requeue(pathToQueue) {
    if (pathToQueue === void 0) {
      pathToQueue = this;
    }

    if (pathToQueue.removed) return;
    var contexts = this.contexts;

    for (var _iterator2 = _createForOfIteratorHelperLoose(contexts), _step2; !(_step2 = _iterator2()).done;) {
      var context = _step2.value;
      context.maybeQueue(pathToQueue);
    }
  }
  function _getQueueContexts() {
    var path = this;
    var contexts = this.contexts;

    while (!contexts.length) {
      path = path.parentPath;
      if (!path) break;
      contexts = path.contexts;
    }

    return contexts;
  }

  var NodePath_context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    call: call,
    _call: _call,
    isDenylisted: isDenylisted,
    isBlacklisted: isDenylisted,
    visit: visit$1,
    skip: skip,
    skipKey: skipKey,
    stop: stop,
    setScope: setScope,
    setContext: setContext,
    resync: resync,
    _resyncParent: _resyncParent,
    _resyncKey: _resyncKey,
    _resyncList: _resyncList,
    _resyncRemoved: _resyncRemoved,
    popContext: popContext,
    pushContext: pushContext,
    setup: setup$1,
    setKey: setKey,
    requeue: requeue,
    _getQueueContexts: _getQueueContexts
  });

  var hooks = [function (self, parent) {
    var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function (self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function (self, parent) {
    if (parent.isBinary()) {
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }

      return true;
    }
  }, function (self, parent) {
    if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];

  function remove() {
    var _this$opts;

    this._assertUnremoved();

    this.resync();

    if (!((_this$opts = this.opts) == null ? void 0 : _this$opts.noScope)) {
      this._removeFromScope();
    }

    if (this._callRemovalHooks()) {
      this._markRemoved();

      return;
    }

    this.shareCommentsWithSiblings();

    this._remove();

    this._markRemoved();
  }
  function _removeFromScope() {
    var _this = this;

    var bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach(function (name) {
      return _this.scope.removeBinding(name);
    });
  }
  function _callRemovalHooks() {
    for (var _i = 0, _arr = hooks; _i < _arr.length; _i++) {
      var fn = _arr[_i];
      if (fn(this, this.parentPath)) return true;
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= SHOULD_SKIP | REMOVED;
    if (this.parent) path.get(this.parent)["delete"](this.node);
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }

  var NodePath_removal = /*#__PURE__*/Object.freeze({
    __proto__: null,
    remove: remove,
    _removeFromScope: _removeFromScope,
    _callRemovalHooks: _callRemovalHooks,
    _remove: _remove,
    _markRemoved: _markRemoved,
    _assertUnremoved: _assertUnremoved
  });

  var referenceVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }

      if (path.node.name === "this") {
        var scope = path.scope;

        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);

        if (scope) state.breakOnScopePaths.push(scope.path);
      }

      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return;

      for (var _iterator = _createForOfIteratorHelperLoose(binding.constantViolations), _step; !(_step = _iterator()).done;) {
        var violation = _step.value;

        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }

      if (binding !== state.scope.getBinding(path.node.name)) return;
      state.bindings[path.node.name] = binding;
    }
  };

  var PathHoister = function () {
    function PathHoister(path, scope) {
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }

    var _proto = PathHoister.prototype;

    _proto.isCompatibleScope = function isCompatibleScope(scope) {
      for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var binding = this.bindings[key];

        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }

      return true;
    };

    _proto.getCompatibleScopes = function getCompatibleScopes() {
      var scope = this.path.scope;

      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }

        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    };

    _proto.getAttachmentPath = function getAttachmentPath() {
      var path = this._getAttachmentPath();

      if (!path) return;
      var targetScope = path.scope;

      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }

      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          if (!targetScope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];

          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }

          var bindingParentPath = this.getAttachmentParentForPath(binding.path);

          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;

            for (var _i3 = 0, _arr = binding.constantViolations; _i3 < _arr.length; _i3++) {
              var violationPath = _arr[_i3];

              if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                path = violationPath;
              }
            }
          }
        }
      }

      return path;
    };

    _proto._getAttachmentPath = function _getAttachmentPath() {
      var scopes = this.scopes;
      var scope = scopes.pop();
      if (!scope) return;

      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope) return;
          var bodies = scope.path.get("body").get("body");

          for (var i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    };

    _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
      var scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    };

    _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    };

    _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
      for (var _i4 = 0, _Object$keys3 = Object.keys(this.bindings); _i4 < _Object$keys3.length; _i4++) {
        var name = _Object$keys3[_i4];
        if (!scope.hasOwnBinding(name)) continue;
        var binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant) return true;
      }

      return false;
    };

    _proto.run = function run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      var attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      var uid = attachTo.scope.generateUidIdentifier("ref");
      var declarator = variableDeclarator(uid, this.path.node);
      var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]),
          attached = _attachTo$insertFn[0];

      var parent = this.path.parentPath;

      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }

      this.path.replaceWith(cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    };

    return PathHoister;
  }();

  function insertBefore(nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [this.node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    var _this$container;

    this.updateSiblingKeys(from, nodes.length);
    var paths = [];

    (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(nodes));

    for (var i = 0; i < nodes.length; i++) {
      var to = from + i;
      var path = this.getSibling(to);
      paths.push(path);

      if (this.context && this.context.queue) {
        path.pushContext(this.context);
      }
    }

    var contexts = this._getQueueContexts();

    for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
      var _path = _paths[_i];

      _path.setScope();

      _path.debug("Inserted.");

      for (var _iterator = _createForOfIteratorHelperLoose(contexts), _step; !(_step = _iterator()).done;) {
        var context = _step.value;
        context.maybeQueue(_path, true);
      }
    }

    return paths;
  }
  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }
  function insertAfter(nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map(function (node) {
        return isExpression(node) ? expressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        var scope = this.scope;

        if (parentPath.isMethod({
          computed: true,
          key: this.node
        })) {
          scope = scope.parent;
        }

        var temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), this.node)));
        nodes.push(expressionStatement(cloneNode(temp)));
      }

      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [this.node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    var paths = path.get(this.parent);

    for (var _iterator2 = _createForOfIteratorHelperLoose(paths), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          path$1 = _step2$value[1];

      if (path$1.key >= fromIndex) {
        path$1.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }

    if (nodes.constructor !== Array) {
      nodes = [nodes];
    }

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var msg = void 0;

      if (!node) {
        msg = "has falsy node";
      } else if (typeof node !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof NodePath) {
        msg = "has a NodePath when it expected a raw object";
      }

      if (msg) {
        var type = Array.isArray(node) ? "array" : typeof node;
        throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
      }
    }

    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    }).setContext(this.context);
    return path._containerInsertBefore(nodes);
  }
  function pushContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var container = this.node[listKey];
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    }).setContext(this.context);
    return path.replaceWithMultiple(nodes);
  }
  function hoist(scope) {
    if (scope === void 0) {
      scope = this.scope;
    }

    var hoister = new PathHoister(this, scope);
    return hoister.run();
  }

  var NodePath_modification = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertBefore: insertBefore,
    _containerInsert: _containerInsert,
    _containerInsertBefore: _containerInsertBefore,
    _containerInsertAfter: _containerInsertAfter,
    insertAfter: insertAfter,
    updateSiblingKeys: updateSiblingKeys,
    _verifyNodeList: _verifyNodeList,
    unshiftContainer: unshiftContainer,
    pushContainer: pushContainer,
    hoist: hoist
  });

  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
  }

  function addCompletionRecords(path, paths) {
    if (path) return paths.concat(path.getCompletionRecords());
    return paths;
  }

  function findBreak(statements) {
    var breakStatement;

    if (!Array.isArray(statements)) {
      statements = [statements];
    }

    for (var _iterator = _createForOfIteratorHelperLoose(statements), _step; !(_step = _iterator()).done;) {
      var statement = _step.value;

      if (statement.isDoExpression() || statement.isProgram() || statement.isBlockStatement() || statement.isCatchClause() || statement.isLabeledStatement()) {
        breakStatement = findBreak(statement.get("body"));
      } else if (statement.isIfStatement()) {
        var _findBreak;

        breakStatement = (_findBreak = findBreak(statement.get("consequent"))) != null ? _findBreak : findBreak(statement.get("alternate"));
      } else if (statement.isTryStatement()) {
        var _findBreak2;

        breakStatement = (_findBreak2 = findBreak(statement.get("block"))) != null ? _findBreak2 : findBreak(statement.get("handler"));
      } else if (statement.isBreakStatement()) {
        breakStatement = statement;
      }

      if (breakStatement) {
        return breakStatement;
      }
    }

    return null;
  }

  function completionRecordForSwitch(cases, paths) {
    var isLastCaseWithConsequent = true;

    for (var i = cases.length - 1; i >= 0; i--) {
      var switchCase = cases[i];
      var consequent = switchCase.get("consequent");
      var breakStatement = findBreak(consequent);

      if (breakStatement) {
        while (breakStatement.key === 0 && breakStatement.parentPath.isBlockStatement()) {
          breakStatement = breakStatement.parentPath;
        }

        var prevSibling = breakStatement.getPrevSibling();

        if (breakStatement.key > 0 && (prevSibling.isExpressionStatement() || prevSibling.isBlockStatement())) {
          paths = addCompletionRecords(prevSibling, paths);
          breakStatement.remove();
        } else {
          breakStatement.replaceWith(breakStatement.scope.buildUndefinedNode());
          paths = addCompletionRecords(breakStatement, paths);
        }
      } else if (isLastCaseWithConsequent) {
        (function () {
          var statementFinder = function statementFinder(statement) {
            return !statement.isBlockStatement() || statement.get("body").some(statementFinder);
          };

          var hasConsequent = consequent.some(statementFinder);

          if (hasConsequent) {
            paths = addCompletionRecords(consequent[consequent.length - 1], paths);
            isLastCaseWithConsequent = false;
          }
        })();
      }
    }

    return paths;
  }

  function getCompletionRecords() {
    var paths = [];

    if (this.isIfStatement()) {
      paths = addCompletionRecords(this.get("consequent"), paths);
      paths = addCompletionRecords(this.get("alternate"), paths);
    } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
      paths = addCompletionRecords(this.get("body"), paths);
    } else if (this.isProgram() || this.isBlockStatement()) {
      paths = addCompletionRecords(this.get("body").pop(), paths);
    } else if (this.isFunction()) {
      return this.get("body").getCompletionRecords();
    } else if (this.isTryStatement()) {
      paths = addCompletionRecords(this.get("block"), paths);
      paths = addCompletionRecords(this.get("handler"), paths);
    } else if (this.isCatchClause()) {
      paths = addCompletionRecords(this.get("body"), paths);
    } else if (this.isSwitchStatement()) {
      paths = completionRecordForSwitch(this.get("cases"), paths);
    } else {
      paths.push(this);
    }

    return paths;
  }
  function getSibling(key) {
    return NodePath.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(++_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }

    return siblings;
  }
  function getAllPrevSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(--_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }

    return siblings;
  }
  function get(key, context) {
    if (context === void 0) {
      context = true;
    }

    if (context === true) context = this.context;
    var parts = key.split(".");

    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }
  function _getKey(key, context) {
    var _this = this;

    var node = this.node;
    var container = node[key];

    if (Array.isArray(container)) {
      return container.map(function (_, i) {
        return NodePath.get({
          listKey: key,
          parentPath: _this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return NodePath.get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    var path = this;

    for (var _iterator2 = _createForOfIteratorHelperLoose(parts), _step2; !(_step2 = _iterator2()).done;) {
      var part = _step2.value;

      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }

    return path;
  }
  function getBindingIdentifiers$1(duplicates) {
    return getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers$1(duplicates) {
    return getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates, outerOnly) {
    if (duplicates === void 0) {
      duplicates = false;
    }

    if (outerOnly === void 0) {
      outerOnly = false;
    }

    var path = this;
    var search = [].concat(path);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      var keys = getBindingIdentifiers.keys[id.node.type];

      if (id.isIdentifier()) {
        if (duplicates) {
          var _ids = ids[id.node.name] = ids[id.node.name] || [];

          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }

        continue;
      }

      if (id.isExportDeclaration()) {
        var declaration = id.get("declaration");

        if (declaration.isDeclaration()) {
          search.push(declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }

        if (id.isFunctionExpression()) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = id.get(key);

          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }

    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }

  var NodePath_family = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getOpposite: getOpposite,
    getCompletionRecords: getCompletionRecords,
    getSibling: getSibling,
    getPrevSibling: getPrevSibling,
    getNextSibling: getNextSibling,
    getAllNextSiblings: getAllNextSiblings,
    getAllPrevSiblings: getAllPrevSiblings,
    get: get,
    _getKey: _getKey,
    _getPattern: _getPattern,
    getBindingIdentifiers: getBindingIdentifiers$1,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
    getBindingIdentifierPaths: getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths
  });

  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    var node = this.node;
    if (!node) return;
    var trailing = node.trailingComments;
    var leading = node.leadingComments;
    if (!trailing && !leading) return;
    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);
    var hasPrev = Boolean(prev.node);
    var hasNext = Boolean(next.node);

    if (hasPrev && !hasNext) {
      prev.addComments("trailing", trailing);
    } else if (hasNext && !hasPrev) {
      next.addComments("leading", leading);
    }
  }
  function addComment$1(type, content, line) {
    addComment(this.node, type, content, line);
  }
  function addComments$1(type, comments) {
    addComments(this.node, type, comments);
  }

  var NodePath_comments = /*#__PURE__*/Object.freeze({
    __proto__: null,
    shareCommentsWithSiblings: shareCommentsWithSiblings,
    addComment: addComment$1,
    addComments: addComments$1
  });

  var _debug = src("babel");

  var REMOVED = 1 << 0;
  var SHOULD_STOP = 1 << 1;
  var SHOULD_SKIP = 1 << 2;

  var NodePath = function () {
    function NodePath(hub, parent) {
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }

    NodePath.get = function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];
      var paths = path.get(parent);

      if (!paths) {
        paths = new Map();
        path.set(parent, paths);
      }

      var path$1 = paths.get(targetNode);

      if (!path$1) {
        path$1 = new NodePath(hub, parent);
        if (targetNode) paths.set(targetNode, path$1);
      }

      path$1.setup(parentPath, container, listKey, key);
      return path$1;
    };

    var _proto = NodePath.prototype;

    _proto.getScope = function getScope(scope) {
      return this.isScope() ? new Scope$1(this) : scope;
    };

    _proto.setData = function setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    };

    _proto.getData = function getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      var val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {
      if (Error === void 0) {
        Error = SyntaxError;
      }

      return this.hub.buildError(this.node, msg, Error);
    };

    _proto.traverse = function traverse(visitor, state) {
      traverse$1(this.node, visitor, this.scope, state, this);
    };

    _proto.set = function set(key, node) {
      validate(this.node, key, node);
      this.node[key] = node;
    };

    _proto.getPathLocation = function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = path.listKey + "[" + key + "]";
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    };

    _proto.debug = function debug(message) {
      if (!_debug.enabled) return;

      _debug(this.getPathLocation() + " " + this.type + ": " + message);
    };

    _proto.toString = function toString() {
      return generateCode(this.node).code;
    };

    _createClass(NodePath, [{
      key: "inList",
      get: function get() {
        return !!this.listKey;
      },
      set: function set(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
    }, {
      key: "parentKey",
      get: function get() {
        return this.listKey || this.key;
      }
    }, {
      key: "shouldSkip",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_SKIP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_SKIP;
        } else {
          this._traverseFlags &= ~SHOULD_SKIP;
        }
      }
    }, {
      key: "shouldStop",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_STOP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_STOP;
        } else {
          this._traverseFlags &= ~SHOULD_STOP;
        }
      }
    }, {
      key: "removed",
      get: function get() {
        return !!(this._traverseFlags & REMOVED);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= REMOVED;
        } else {
          this._traverseFlags &= ~REMOVED;
        }
      }
    }]);

    return NodePath;
  }();
  Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

  var _loop = function _loop() {
    var type = _arr[_i$3];
    var typeKey = "is" + type;
    var fn = t[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert" + type] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type " + type);
      }
    };
  };

  for (var _i$3 = 0, _arr = TYPES; _i$3 < _arr.length; _i$3++) {
    _loop();
  }

  var _loop2 = function _loop2() {
    var type = _Object$keys$1[_i2$1];
    if (type[0] === "_") return "continue";
    if (TYPES.indexOf(type) < 0) TYPES.push(type);
    var virtualType = virtualTypes[type];

    NodePath.prototype["is" + type] = function (opts) {
      return virtualType.checkPath(this, opts);
    };
  };

  for (var _i2$1 = 0, _Object$keys$1 = Object.keys(virtualTypes); _i2$1 < _Object$keys$1.length; _i2$1++) {
    var _ret = _loop2();

    if (_ret === "continue") continue;
  }

  var TraversalContext = function () {
    function TraversalContext(scope, opts, state, parentPath) {
      this.queue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }

    var _proto = TraversalContext.prototype;

    _proto.shouldVisit = function shouldVisit(node) {
      var opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node.type]) return true;
      var keys = VISITOR_KEYS[node.type];
      if (!(keys == null ? void 0 : keys.length)) return false;

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        if (node[key]) return true;
      }

      return false;
    };

    _proto.create = function create(node, obj, key, listKey) {
      return NodePath.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey: listKey
      });
    };

    _proto.maybeQueue = function maybeQueue(path, notPriority) {
      if (this.trap) {
        throw new Error("Infinite cycle detected");
      }

      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    };

    _proto.visitMultiple = function visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      var queue = [];

      for (var key = 0; key < container.length; key++) {
        var node = container[key];

        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }

      return this.visitQueue(queue);
    };

    _proto.visitSingle = function visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    };

    _proto.visitQueue = function visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      var visited = new WeakSet();
      var stop = false;

      for (var _iterator2 = _createForOfIteratorHelperLoose(queue), _step2; !(_step2 = _iterator2()).done;) {
        var path = _step2.value;
        path.resync();

        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
          path.pushContext(this);
        }

        if (path.key === null) continue;

        var node = path.node;
        if (visited.has(node)) continue;
        if (node) visited.add(node);

        if (path.visit()) {
          stop = true;
          break;
        }

        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(queue), _step3; !(_step3 = _iterator3()).done;) {
        var _path = _step3.value;

        _path.popContext();
      }

      this.queue = null;
      return stop;
    };

    _proto.visit = function visit(node, key) {
      var nodes = node[key];
      if (!nodes) return false;

      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    };

    return TraversalContext;
  }();

  function explode(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = true;

    for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
      var nodeType = _Object$keys[_i];
      if (shouldIgnoreKey(nodeType)) continue;
      var parts = nodeType.split("|");
      if (parts.length === 1) continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];

      for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        visitor[part] = fns;
      }
    }

    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);

    for (var _i2 = 0, _arr = Object.keys(visitor); _i2 < _arr.length; _i2++) {
      var _nodeType = _arr[_i2];
      if (shouldIgnoreKey(_nodeType)) continue;
      var wrapper = virtualTypes[_nodeType];
      if (!wrapper) continue;
      var _fns = visitor[_nodeType];

      for (var _i3 = 0, _Object$keys2 = Object.keys(_fns); _i3 < _Object$keys2.length; _i3++) {
        var type = _Object$keys2[_i3];
        _fns[type] = wrapCheck(wrapper, _fns[type]);
      }

      delete visitor[_nodeType];

      if (wrapper.types) {
        for (var _i4 = 0, _arr2 = wrapper.types; _i4 < _arr2.length; _i4++) {
          var _type = _arr2[_i4];

          if (visitor[_type]) {
            mergePair(visitor[_type], _fns);
          } else {
            visitor[_type] = _fns;
          }
        }
      } else {
        mergePair(visitor, _fns);
      }
    }

    for (var _i5 = 0, _Object$keys3 = Object.keys(visitor); _i5 < _Object$keys3.length; _i5++) {
      var _nodeType2 = _Object$keys3[_i5];
      if (shouldIgnoreKey(_nodeType2)) continue;
      var _fns2 = visitor[_nodeType2];
      var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
      var deprecratedKey = DEPRECATED_KEYS[_nodeType2];

      if (deprecratedKey) {
        console.trace("Visitor defined for " + _nodeType2 + " but it has been renamed to " + deprecratedKey);
        aliases = [deprecratedKey];
      }

      if (!aliases) continue;
      delete visitor[_nodeType2];

      for (var _iterator2 = _createForOfIteratorHelperLoose(aliases), _step2; !(_step2 = _iterator2()).done;) {
        var alias = _step2.value;
        var existing = visitor[alias];

        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = Object.assign({}, _fns2);
        }
      }
    }

    for (var _i6 = 0, _Object$keys4 = Object.keys(visitor); _i6 < _Object$keys4.length; _i6++) {
      var _nodeType3 = _Object$keys4[_i6];
      if (shouldIgnoreKey(_nodeType3)) continue;
      ensureCallbackArrays(visitor[_nodeType3]);
    }

    return visitor;
  }
  function verify(visitor) {
    if (visitor._verified) return;

    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }

    for (var _i7 = 0, _Object$keys5 = Object.keys(visitor); _i7 < _Object$keys5.length; _i7++) {
      var nodeType = _Object$keys5[_i7];

      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }

      if (shouldIgnoreKey(nodeType)) continue;

      if (TYPES.indexOf(nodeType) < 0) {
        throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type");
      }

      var visitors = visitor[nodeType];

      if (typeof visitors === "object") {
        for (var _i8 = 0, _Object$keys6 = Object.keys(visitors); _i8 < _Object$keys6.length; _i8++) {
          var visitorKey = _Object$keys6[_i8];

          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
          }
        }
      }
    }

    visitor._verified = true;
  }

  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);

    for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
      var fn = _step3.value;

      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
      }
    }
  }

  function merge$1(visitors, states, wrapper) {
    if (states === void 0) {
      states = [];
    }

    var rootVisitor = {};

    for (var i = 0; i < visitors.length; i++) {
      var visitor = visitors[i];
      var state = states[i];
      explode(visitor);

      for (var _i9 = 0, _Object$keys7 = Object.keys(visitor); _i9 < _Object$keys7.length; _i9++) {
        var type = _Object$keys7[_i9];
        var visitorType = visitor[type];

        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }

        var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
        mergePair(nodeVisitor, visitorType);
      }
    }

    return rootVisitor;
  }

  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};

    var _loop = function _loop() {
      var key = _Object$keys8[_i10];
      var fns = oldVisitor[key];
      if (!Array.isArray(fns)) return "continue";
      fns = fns.map(function (fn) {
        var newFn = fn;

        if (state) {
          newFn = function newFn(path) {
            return fn.call(state, path, state);
          };
        }

        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }

        if (newFn !== fn) {
          newFn.toString = function () {
            return fn.toString();
          };
        }

        return newFn;
      });
      newVisitor[key] = fns;
    };

    for (var _i10 = 0, _Object$keys8 = Object.keys(oldVisitor); _i10 < _Object$keys8.length; _i10++) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }

    return newVisitor;
  }

  function ensureEntranceObjects(obj) {
    for (var _i11 = 0, _Object$keys9 = Object.keys(obj); _i11 < _Object$keys9.length; _i11++) {
      var key = _Object$keys9[_i11];
      if (shouldIgnoreKey(key)) continue;
      var fns = obj[key];

      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }

  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }

  function wrapCheck(wrapper, fn) {
    var newFn = function newFn(path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };

    newFn.toString = function () {
      return fn.toString();
    };

    return newFn;
  }

  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

    if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
      return true;
    }

    return false;
  }

  function mergePair(dest, src) {
    for (var _i12 = 0, _Object$keys10 = Object.keys(src); _i12 < _Object$keys10.length; _i12++) {
      var key = _Object$keys10[_i12];
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }

  var visitors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    explode: explode,
    verify: verify,
    merge: merge$1
  });

  function traverse$1(parent, opts, scope, state, parentPath) {
    if (!parent) return;
    if (!opts) opts = {};

    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + ("Instead of that you tried to traverse a " + parent.type + " node without ") + "passing scope and parentPath.");
      }
    }

    if (!VISITOR_KEYS[parent.type]) {
      return;
    }

    explode(opts);
    traverse$1.node(parent, opts, scope, state, parentPath);
  }
  traverse$1.visitors = visitors;
  traverse$1.verify = verify;
  traverse$1.explode = explode;

  traverse$1.cheap = function (node, enter) {
    return traverseFast(node, enter);
  };

  traverse$1.node = function (node, opts, scope, state, parentPath, skipKeys) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    var context = new TraversalContext(scope, opts, state, parentPath);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  };

  traverse$1.clearNode = function (node, opts) {
    removeProperties(node, opts);
    path["delete"](node);
  };

  traverse$1.removeProperties = function (tree, opts) {
    traverseFast(tree, traverse$1.clearNode, opts);
    return tree;
  };

  function hasDenylistedType(path, state) {
    if (path.node.type === state.type) {
      state.has = true;
      path.stop();
    }
  }

  traverse$1.hasType = function (tree, type, denylistTypes) {
    if (denylistTypes == null ? void 0 : denylistTypes.includes(tree.type)) return false;
    if (tree.type === type) return true;
    var state = {
      has: false,
      type: type
    };
    traverse$1(tree, {
      noScope: true,
      denylist: denylistTypes,
      enter: hasDenylistedType
    }, null, state);
    return state.has;
  };

  traverse$1.cache = cache;

  function _templateObject80() {
    var data = _taggedTemplateLiteralLoose(["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"], ["\n  import wrapNativeSuper from \"wrapNativeSuper\";\n  import getPrototypeOf from \"getPrototypeOf\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n  import inherits from \"inherits\";\n\n  export default function _wrapRegExp(re, groups) {\n    _wrapRegExp = function(re, groups) {\n      return new BabelRegExp(re, undefined, groups);\n    };\n\n    var _RegExp = wrapNativeSuper(RegExp);\n    var _super = RegExp.prototype;\n    var _groups = new WeakMap();\n\n    function BabelRegExp(re, flags, groups) {\n      var _this = _RegExp.call(this, re, flags);\n      // if the regex is recreated with 'g' flag\n      _groups.set(_this, groups || _groups.get(re));\n      return _this;\n    }\n    inherits(BabelRegExp, _RegExp);\n\n    BabelRegExp.prototype.exec = function(str) {\n      var result = _super.exec.call(this, str);\n      if (result) result.groups = buildGroups(result, this);\n      return result;\n    };\n    BabelRegExp.prototype[Symbol.replace] = function(str, substitution) {\n      if (typeof substitution === \"string\") {\n        var groups = _groups.get(this);\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          substitution.replace(/\\\\$<([^>]+)>/g, function(_, name) {\n            return \"$\" + groups[name];\n          })\n        );\n      } else if (typeof substitution === \"function\") {\n        var _this = this;\n        return _super[Symbol.replace].call(\n          this,\n          str,\n          function() {\n            var args = [];\n            args.push.apply(args, arguments);\n            if (typeof args[args.length - 1] !== \"object\") {\n              // Modern engines already pass result.groups as the last arg.\n              args.push(buildGroups(args, _this));\n            }\n            return substitution.apply(this, args);\n          }\n        );\n      } else {\n        return _super[Symbol.replace].call(this, str, substitution);\n      }\n    }\n\n    function buildGroups(result, re) {\n      // NOTE: This function should return undefined if there are no groups,\n      // but in that case Babel doesn't add the wrapper anyway.\n\n      var g = _groups.get(re);\n      return Object.keys(g).reduce(function(groups, name) {\n        groups[name] = result[g[name]];\n        return groups;\n      }, Object.create(null));\n    }\n\n    return _wrapRegExp.apply(this, arguments);\n  }\n"]);

    _templateObject80 = function _templateObject80() {
      return data;
    };

    return data;
  }

  function _templateObject79() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodSet() {\n    throw new TypeError(\"attempted to reassign private method\");\n  }\n"]);

    _templateObject79 = function _templateObject79() {
      return data;
    };

    return data;
  }

  function _templateObject78() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"]);

    _templateObject78 = function _templateObject78() {
      return data;
    };

    return data;
  }

  function _templateObject77() {
    var data = _taggedTemplateLiteralLoose(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"]);

    _templateObject77 = function _templateObject77() {
      return data;
    };

    return data;
  }

  function _templateObject76() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"]);

    _templateObject76 = function _templateObject76() {
      return data;
    };

    return data;
  }

  function _templateObject75() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    return method;\n  }\n"]);

    _templateObject75 = function _templateObject75() {
      return data;
    };

    return data;
  }

  function _templateObject74() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

    _templateObject74 = function _templateObject74() {
      return data;
    };

    return data;
  }

  function _templateObject73() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

    _templateObject73 = function _templateObject73() {
      return data;
    };

    return data;
  }

  function _templateObject72() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    var descriptor = privateMap.get(receiver);\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"]);

    _templateObject72 = function _templateObject72() {
      return data;
    };

    return data;
  }

  function _templateObject71() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      descriptor.value = value;\n    }\n\n    return value;\n  }\n"]);

    _templateObject71 = function _templateObject71() {
      return data;
    };

    return data;
  }

  function _templateObject70() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = privateMap.get(receiver);\n    if (!descriptor) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"]);

    _templateObject70 = function _templateObject70() {
      return data;
    };

    return data;
  }

  function _templateObject69() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"]);

    _templateObject69 = function _templateObject69() {
      return data;
    };

    return data;
  }

  function _templateObject68() {
    var data = _taggedTemplateLiteralLoose(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"]);

    _templateObject68 = function _templateObject68() {
      return data;
    };

    return data;
  }

  function _templateObject67() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"]);

    _templateObject67 = function _templateObject67() {
      return data;
    };

    return data;
  }

  function _templateObject66() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"]);

    _templateObject66 = function _templateObject66() {
      return data;
    };

    return data;
  }

  function _templateObject65() {
    var data = _taggedTemplateLiteralLoose(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"]);

    _templateObject65 = function _templateObject65() {
      return data;
    };

    return data;
  }

  function _templateObject64() {
    var data = _taggedTemplateLiteralLoose(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"]);

    _templateObject64 = function _templateObject64() {
      return data;
    };

    return data;
  }

  function _templateObject63() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"]);

    _templateObject63 = function _templateObject63() {
      return data;
    };

    return data;
  }

  function _templateObject62() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"]);

    _templateObject62 = function _templateObject62() {
      return data;
    };

    return data;
  }

  function _templateObject61() {
    var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n          if (i >= o.length) return { done: true };\n          return { done: false, value: o[i++] };\n        }\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n"]);

    _templateObject61 = function _templateObject61() {
      return data;
    };

    return data;
  }

  function _templateObject60() {
    var data = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = o[Symbol.iterator]();\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"]);

    _templateObject60 = function _templateObject60() {
      return data;
    };

    return data;
  }

  function _templateObject59() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

    _templateObject59 = function _templateObject59() {
      return data;
    };

    return data;
  }

  function _templateObject58() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"]);

    _templateObject58 = function _templateObject58() {
      return data;
    };

    return data;
  }

  function _templateObject57() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n"]);

    _templateObject57 = function _templateObject57() {
      return data;
    };

    return data;
  }

  function _templateObject56() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n"]);

    _templateObject56 = function _templateObject56() {
      return data;
    };

    return data;
  }

  function _templateObject55() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"]);

    _templateObject55 = function _templateObject55() {
      return data;
    };

    return data;
  }

  function _templateObject54() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"]);

    _templateObject54 = function _templateObject54() {
      return data;
    };

    return data;
  }

  function _templateObject53() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n"]);

    _templateObject53 = function _templateObject53() {
      return data;
    };

    return data;
  }

  function _templateObject52() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _maybeArrayLike(next, arr, i) {\n    if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n      var len = arr.length;\n      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n    }\n    return next(arr, i);\n  }\n"]);

    _templateObject52 = function _templateObject52() {
      return data;
    };

    return data;
  }

  function _templateObject51() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"]);

    _templateObject51 = function _templateObject51() {
      return data;
    };

    return data;
  }

  function _templateObject50() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n"]);

    _templateObject50 = function _templateObject50() {
      return data;
    };

    return data;
  }

  function _templateObject49() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n"]);

    _templateObject49 = function _templateObject49() {
      return data;
    };

    return data;
  }

  function _templateObject48() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject48 = function _templateObject48() {
      return data;
    };

    return data;
  }

  function _templateObject47() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject47 = function _templateObject47() {
      return data;
    };

    return data;
  }

  function _templateObject46() {
    var data = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"]);

    _templateObject46 = function _templateObject46() {
      return data;
    };

    return data;
  }

  function _templateObject45() {
    var data = _taggedTemplateLiteralLoose(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"]);

    _templateObject45 = function _templateObject45() {
      return data;
    };

    return data;
  }

  function _templateObject44() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"]);

    _templateObject44 = function _templateObject44() {
      return data;
    };

    return data;
  }

  function _templateObject43() {
    var data = _taggedTemplateLiteralLoose(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"]);

    _templateObject43 = function _templateObject43() {
      return data;
    };

    return data;
  }

  function _templateObject42() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"]);

    _templateObject42 = function _templateObject42() {
      return data;
    };

    return data;
  }

  function _templateObject41() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"]);

    _templateObject41 = function _templateObject41() {
      return data;
    };

    return data;
  }

  function _templateObject40() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"]);

    _templateObject40 = function _templateObject40() {
      return data;
    };

    return data;
  }

  function _templateObject39() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"]);

    _templateObject39 = function _templateObject39() {
      return data;
    };

    return data;
  }

  function _templateObject38() {
    var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"]);

    _templateObject38 = function _templateObject38() {
      return data;
    };

    return data;
  }

  function _templateObject37() {
    var data = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n"]);

    _templateObject37 = function _templateObject37() {
      return data;
    };

    return data;
  }

  function _templateObject36() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"]);

    _templateObject36 = function _templateObject36() {
      return data;
    };

    return data;
  }

  function _templateObject35() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = getPrototypeOf(Derived), result;\n      if (hasNativeReflectConstruct) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n "]);

    _templateObject35 = function _templateObject35() {
      return data;
    };

    return data;
  }

  function _templateObject34() {
    var data = _taggedTemplateLiteralLoose(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n"]);

    _templateObject34 = function _templateObject34() {
      return data;
    };

    return data;
  }

  function _templateObject33() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"]);

    _templateObject33 = function _templateObject33() {
      return data;
    };

    return data;
  }

  function _templateObject32() {
    var data = _taggedTemplateLiteralLoose(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"]);

    _templateObject32 = function _templateObject32() {
      return data;
    };

    return data;
  }

  function _templateObject31() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"]);

    _templateObject31 = function _templateObject31() {
      return data;
    };

    return data;
  }

  function _templateObject30() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"]);

    _templateObject30 = function _templateObject30() {
      return data;
    };

    return data;
  }

  function _templateObject29() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"]);

    _templateObject29 = function _templateObject29() {
      return data;
    };

    return data;
  }

  function _templateObject28() {
    var data = _taggedTemplateLiteralLoose(["\n  function _getRequireWildcardCache() {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cache = new WeakMap();\n    _getRequireWildcardCache = function () { return cache; };\n    return cache;\n  }\n\n  export default function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache();\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"]);

    _templateObject28 = function _templateObject28() {
      return data;
    };

    return data;
  }

  function _templateObject27() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"]);

    _templateObject27 = function _templateObject27() {
      return data;
    };

    return data;
  }

  function _templateObject26() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"]);

    _templateObject26 = function _templateObject26() {
      return data;
    };

    return data;
  }

  function _templateObject25() {
    var data = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"]);

    _templateObject25 = function _templateObject25() {
      return data;
    };

    return data;
  }

  function _templateObject24() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"]);

    _templateObject24 = function _templateObject24() {
      return data;
    };

    return data;
  }

  function _templateObject23() {
    var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"]);

    _templateObject23 = function _templateObject23() {
      return data;
    };

    return data;
  }

  function _templateObject22() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Date object.\n      Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n"]);

    _templateObject22 = function _templateObject22() {
      return data;
    };

    return data;
  }

  function _templateObject21() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"]);

    _templateObject21 = function _templateObject21() {
      return data;
    };

    return data;
  }

  function _templateObject20() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"]);

    _templateObject20 = function _templateObject20() {
      return data;
    };

    return data;
  }

  function _templateObject19() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n"]);

    _templateObject19 = function _templateObject19() {
      return data;
    };

    return data;
  }

  function _templateObject18() {
    var data = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"]);

    _templateObject18 = function _templateObject18() {
      return data;
    };

    return data;
  }

  function _templateObject17() {
    var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  // This function is different to \"Reflect.ownKeys\". The enumerableOnly\n  // filters on symbol properties only. Returned string properties are always\n  // enumerable. It is good to use in objectSpread.\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n\n  export default function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(\n            target,\n            key,\n            Object.getOwnPropertyDescriptor(source, key)\n          );\n        });\n      }\n    }\n    return target;\n  }\n"]);

    _templateObject17 = function _templateObject17() {
      return data;
    };

    return data;
  }

  function _templateObject16() {
    var data = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"]);

    _templateObject16 = function _templateObject16() {
      return data;
    };

    return data;
  }

  function _templateObject15() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"]);

    _templateObject15 = function _templateObject15() {
      return data;
    };

    return data;
  }

  function _templateObject14() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"]);

    _templateObject14 = function _templateObject14() {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"]);

    _templateObject13 = function _templateObject13() {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"]);

    _templateObject12 = function _templateObject12() {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    var data = _taggedTemplateLiteralLoose(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n"]);

    _templateObject11 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"]);

    _templateObject10 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    var data = _taggedTemplateLiteralLoose(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"]);

    _templateObject9 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    if (typeof Symbol === \"function\" && Symbol.iterator) {\n      iter[Symbol.iterator] = function () { return this; };\n    }\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"]);

    _templateObject8 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"]);

    _templateObject7 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    var data = _taggedTemplateLiteralLoose(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"]);

    _templateObject6 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    var data = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"]);

    _templateObject5 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"]);

    _templateObject4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _asyncIterator(iterable) {\n    var method\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) {\n        method = iterable[Symbol.asyncIterator]\n        if (method != null) return method.call(iterable);\n      }\n      if (Symbol.iterator) {\n        method = iterable[Symbol.iterator]\n        if (method != null) return method.call(iterable);\n      }\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n"]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteralLoose(["\n  var REACT_ELEMENT_TYPE;\n\n  export default function _createRawReactElement(type, props, key, children) {\n    if (!REACT_ELEMENT_TYPE) {\n      REACT_ELEMENT_TYPE = (\n        typeof Symbol === \"function\" && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\")\n      ) || 0xeac7;\n    }\n\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      // If we're going to assign props.children, we create a new object now\n      // to avoid mutating defaultProps.\n      props = {\n        children: void 0,\n      };\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = new Array(childrenLength);\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n      props.children = childArray;\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null,\n    };\n  }\n"]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteralLoose(["\n  export default function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) { return typeof obj; };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? \"symbol\"\n          : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n"]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }
  var helpers = Object.create(null);

  var helper = function helper(minVersion) {
    return function (tpl) {
      return {
        minVersion: minVersion,
        ast: function ast() {
          return template.program.ast(tpl);
        }
      };
    };
  };

  helpers["typeof"] = helper("7.0.0-beta.0")(_templateObject());
  helpers.jsx = helper("7.0.0-beta.0")(_templateObject2());
  helpers.asyncIterator = helper("7.0.0-beta.0")(_templateObject3());
  helpers.AwaitValue = helper("7.0.0-beta.0")(_templateObject4());
  helpers.AsyncGenerator = helper("7.0.0-beta.0")(_templateObject5());
  helpers.wrapAsyncGenerator = helper("7.0.0-beta.0")(_templateObject6());
  helpers.awaitAsyncGenerator = helper("7.0.0-beta.0")(_templateObject7());
  helpers.asyncGeneratorDelegate = helper("7.0.0-beta.0")(_templateObject8());
  helpers.asyncToGenerator = helper("7.0.0-beta.0")(_templateObject9());
  helpers.classCallCheck = helper("7.0.0-beta.0")(_templateObject10());
  helpers.createClass = helper("7.0.0-beta.0")(_templateObject11());
  helpers.defineEnumerableProperties = helper("7.0.0-beta.0")(_templateObject12());
  helpers.defaults = helper("7.0.0-beta.0")(_templateObject13());
  helpers.defineProperty = helper("7.0.0-beta.0")(_templateObject14());
  helpers["extends"] = helper("7.0.0-beta.0")(_templateObject15());
  helpers.objectSpread = helper("7.0.0-beta.0")(_templateObject16());
  helpers.objectSpread2 = helper("7.5.0")(_templateObject17());
  helpers.inherits = helper("7.0.0-beta.0")(_templateObject18());
  helpers.inheritsLoose = helper("7.0.0-beta.0")(_templateObject19());
  helpers.getPrototypeOf = helper("7.0.0-beta.0")(_templateObject20());
  helpers.setPrototypeOf = helper("7.0.0-beta.0")(_templateObject21());
  helpers.isNativeReflectConstruct = helper("7.9.0")(_templateObject22());
  helpers.construct = helper("7.0.0-beta.0")(_templateObject23());
  helpers.isNativeFunction = helper("7.0.0-beta.0")(_templateObject24());
  helpers.wrapNativeSuper = helper("7.0.0-beta.0")(_templateObject25());
  helpers["instanceof"] = helper("7.0.0-beta.0")(_templateObject26());
  helpers.interopRequireDefault = helper("7.0.0-beta.0")(_templateObject27());
  helpers.interopRequireWildcard = helper("7.0.0-beta.0")(_templateObject28());
  helpers.newArrowCheck = helper("7.0.0-beta.0")(_templateObject29());
  helpers.objectDestructuringEmpty = helper("7.0.0-beta.0")(_templateObject30());
  helpers.objectWithoutPropertiesLoose = helper("7.0.0-beta.0")(_templateObject31());
  helpers.objectWithoutProperties = helper("7.0.0-beta.0")(_templateObject32());
  helpers.assertThisInitialized = helper("7.0.0-beta.0")(_templateObject33());
  helpers.possibleConstructorReturn = helper("7.0.0-beta.0")(_templateObject34());
  helpers.createSuper = helper("7.9.0")(_templateObject35());
  helpers.superPropBase = helper("7.0.0-beta.0")(_templateObject36());
  helpers.get = helper("7.0.0-beta.0")(_templateObject37());
  helpers.set = helper("7.0.0-beta.0")(_templateObject38());
  helpers.taggedTemplateLiteral = helper("7.0.0-beta.0")(_templateObject39());
  helpers.taggedTemplateLiteralLoose = helper("7.0.0-beta.0")(_templateObject40());
  helpers.readOnlyError = helper("7.0.0-beta.0")(_templateObject41());
  helpers.classNameTDZError = helper("7.0.0-beta.0")(_templateObject42());
  helpers.temporalUndefined = helper("7.0.0-beta.0")(_templateObject43());
  helpers.tdz = helper("7.5.5")(_templateObject44());
  helpers.temporalRef = helper("7.0.0-beta.0")(_templateObject45());
  helpers.slicedToArray = helper("7.0.0-beta.0")(_templateObject46());
  helpers.slicedToArrayLoose = helper("7.0.0-beta.0")(_templateObject47());
  helpers.toArray = helper("7.0.0-beta.0")(_templateObject48());
  helpers.toConsumableArray = helper("7.0.0-beta.0")(_templateObject49());
  helpers.arrayWithoutHoles = helper("7.0.0-beta.0")(_templateObject50());
  helpers.arrayWithHoles = helper("7.0.0-beta.0")(_templateObject51());
  helpers.maybeArrayLike = helper("7.9.0")(_templateObject52());
  helpers.iterableToArray = helper("7.0.0-beta.0")(_templateObject53());
  helpers.iterableToArrayLimit = helper("7.0.0-beta.0")(_templateObject54());
  helpers.iterableToArrayLimitLoose = helper("7.0.0-beta.0")(_templateObject55());
  helpers.unsupportedIterableToArray = helper("7.9.0")(_templateObject56());
  helpers.arrayLikeToArray = helper("7.9.0")(_templateObject57());
  helpers.nonIterableSpread = helper("7.0.0-beta.0")(_templateObject58());
  helpers.nonIterableRest = helper("7.0.0-beta.0")(_templateObject59());
  helpers.createForOfIteratorHelper = helper("7.9.0")(_templateObject60());
  helpers.createForOfIteratorHelperLoose = helper("7.9.0")(_templateObject61());
  helpers.skipFirstGeneratorNext = helper("7.0.0-beta.0")(_templateObject62());
  helpers.toPrimitive = helper("7.1.5")(_templateObject63());
  helpers.toPropertyKey = helper("7.1.5")(_templateObject64());
  helpers.initializerWarningHelper = helper("7.0.0-beta.0")(_templateObject65());
  helpers.initializerDefineProperty = helper("7.0.0-beta.0")(_templateObject66());
  helpers.applyDecoratedDescriptor = helper("7.0.0-beta.0")(_templateObject67());
  helpers.classPrivateFieldLooseKey = helper("7.0.0-beta.0")(_templateObject68());
  helpers.classPrivateFieldLooseBase = helper("7.0.0-beta.0")(_templateObject69());
  helpers.classPrivateFieldGet = helper("7.0.0-beta.0")(_templateObject70());
  helpers.classPrivateFieldSet = helper("7.0.0-beta.0")(_templateObject71());
  helpers.classPrivateFieldDestructureSet = helper("7.4.4")(_templateObject72());
  helpers.classStaticPrivateFieldSpecGet = helper("7.0.2")(_templateObject73());
  helpers.classStaticPrivateFieldSpecSet = helper("7.0.2")(_templateObject74());
  helpers.classStaticPrivateMethodGet = helper("7.3.2")(_templateObject75());
  helpers.classStaticPrivateMethodSet = helper("7.3.2")(_templateObject76());
  helpers.decorate = helper("7.1.5")(_templateObject77());
  helpers.classPrivateMethodGet = helper("7.1.6")(_templateObject78());
  helpers.classPrivateMethodSet = helper("7.1.6")(_templateObject79());
  helpers.wrapRegExp = helper("7.2.6")(_templateObject80());

  function makePath(path) {
    var parts = [];

    for (; path.parentPath; path = path.parentPath) {
      parts.push(path.key);
      if (path.inList) parts.push(path.listKey);
    }

    return parts.reverse().join(".");
  }

  var fileClass = undefined;

  function getHelperMetadata(file) {
    var globals = new Set();
    var localBindingNames = new Set();
    var dependencies = new Map();
    var exportName;
    var exportPath;
    var exportBindingAssignments = [];
    var importPaths = [];
    var importBindingsReferences = [];
    var dependencyVisitor = {
      ImportDeclaration: function ImportDeclaration(child) {
        var name = child.node.source.value;

        if (!helpers[name]) {
          throw child.buildCodeFrameError("Unknown helper " + name);
        }

        if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
          throw child.buildCodeFrameError("Helpers can only import a default value");
        }

        var bindingIdentifier = child.node.specifiers[0].local;
        dependencies.set(bindingIdentifier, name);
        importPaths.push(makePath(child));
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
        var decl = child.get("declaration");

        if (decl.isFunctionDeclaration()) {
          if (!decl.node.id) {
            throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
          }

          exportName = decl.node.id.name;
        }

        exportPath = makePath(child);
      },
      ExportAllDeclaration: function ExportAllDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      Statement: function Statement(child) {
        if (child.isModuleDeclaration()) return;
        child.skip();
      }
    };
    var referenceVisitor = {
      Program: function Program(path) {
        var bindings = path.scope.getAllBindings();
        Object.keys(bindings).forEach(function (name) {
          if (name === exportName) return;
          if (dependencies.has(bindings[name].identifier)) return;
          localBindingNames.add(name);
        });
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        var name = child.node.name;
        var binding = child.scope.getBinding(name, true);

        if (!binding) {
          globals.add(name);
        } else if (dependencies.has(binding.identifier)) {
          importBindingsReferences.push(makePath(child));
        }
      },
      AssignmentExpression: function AssignmentExpression(child) {
        var left = child.get("left");
        if (!(exportName in left.getBindingIdentifiers())) return;

        if (!left.isIdentifier()) {
          throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        }

        var binding = child.scope.getBinding(exportName);

        if (binding == null ? void 0 : binding.scope.path.isProgram()) {
          exportBindingAssignments.push(makePath(child));
        }
      }
    };
    traverse$1(file.ast, dependencyVisitor, file.scope);
    traverse$1(file.ast, referenceVisitor, file.scope);
    if (!exportPath) throw new Error("Helpers must default-export something.");
    exportBindingAssignments.reverse();
    return {
      globals: Array.from(globals),
      localBindingNames: Array.from(localBindingNames),
      dependencies: dependencies,
      exportBindingAssignments: exportBindingAssignments,
      exportPath: exportPath,
      exportName: exportName,
      importBindingsReferences: importBindingsReferences,
      importPaths: importPaths
    };
  }

  function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
    if (localBindings && !id) {
      throw new Error("Unexpected local bindings for module-based helpers.");
    }

    if (!id) return;
    var localBindingNames = metadata.localBindingNames,
        dependencies = metadata.dependencies,
        exportBindingAssignments = metadata.exportBindingAssignments,
        exportPath = metadata.exportPath,
        exportName = metadata.exportName,
        importBindingsReferences = metadata.importBindingsReferences,
        importPaths = metadata.importPaths;
    var dependenciesRefs = {};
    dependencies.forEach(function (name, id) {
      dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
    });
    var toRename = {};
    var bindings = new Set(localBindings || []);
    localBindingNames.forEach(function (name) {
      var newName = name;

      while (bindings.has(newName)) {
        newName = "_" + newName;
      }

      if (newName !== name) toRename[name] = newName;
    });

    if (id.type === "Identifier" && exportName !== id.name) {
      toRename[exportName] = id.name;
    }

    var visitor = {
      Program: function Program(path) {
        var exp = path.get(exportPath);
        var imps = importPaths.map(function (p) {
          return path.get(p);
        });
        var impsBindingRefs = importBindingsReferences.map(function (p) {
          return path.get(p);
        });
        var decl = exp.get("declaration");

        if (id.type === "Identifier") {
          if (decl.isFunctionDeclaration()) {
            exp.replaceWith(decl);
          } else {
            exp.replaceWith(variableDeclaration("var", [variableDeclarator(id, decl.node)]));
          }
        } else if (id.type === "MemberExpression") {
          if (decl.isFunctionDeclaration()) {
            exportBindingAssignments.forEach(function (assignPath) {
              var assign = path.get(assignPath);
              assign.replaceWith(assignmentExpression("=", id, assign.node));
            });
            exp.replaceWith(decl);
            path.pushContainer("body", expressionStatement(assignmentExpression("=", id, identifier(exportName))));
          } else {
            exp.replaceWith(expressionStatement(assignmentExpression("=", id, decl.node)));
          }
        } else {
          throw new Error("Unexpected helper format.");
        }

        Object.keys(toRename).forEach(function (name) {
          path.scope.rename(name, toRename[name]);
        });

        for (var _iterator = _createForOfIteratorHelperLoose(imps), _step; !(_step = _iterator()).done;) {
          var _path = _step.value;

          _path.remove();
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(impsBindingRefs), _step2; !(_step2 = _iterator2()).done;) {
          var _path2 = _step2.value;
          var node = cloneNode(dependenciesRefs[_path2.node.name]);

          _path2.replaceWith(node);
        }

        path.stop();
      }
    };
    traverse$1(file.ast, visitor, file.scope);
  }

  var helperData = Object.create(null);

  function loadHelper(name) {
    if (!helperData[name]) {
      var helper = helpers[name];

      if (!helper) {
        throw Object.assign(new ReferenceError("Unknown helper " + name), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: name
        });
      }

      var fn = function fn() {
        var file$1 = {
          ast: file(helper.ast())
        };

        if (fileClass) {
          return new fileClass({
            filename: "babel-helper://" + name
          }, file$1);
        }

        return file$1;
      };

      var metadata = getHelperMetadata(fn());
      helperData[name] = {
        build: function build(getDependency, id, localBindings) {
          var file = fn();
          permuteHelperAST(file, metadata, id, localBindings, getDependency);
          return {
            nodes: file.ast.program.body,
            globals: metadata.globals
          };
        },
        minVersion: function minVersion() {
          return helper.minVersion;
        },
        dependencies: metadata.dependencies
      };
    }

    return helperData[name];
  }

  function get$1(name, getDependency, id, localBindings) {
    return loadHelper(name).build(getDependency, id, localBindings);
  }
  function minVersion(name) {
    return loadHelper(name).minVersion();
  }
  function getDependencies(name) {
    return Array.from(loadHelper(name).dependencies.values());
  }
  function ensure(name, newFileClass) {
    if (!fileClass) {
      fileClass = newFileClass;
    }

    loadHelper(name);
  }
  var list$1 = Object.keys(helpers).map(function (name) {
    return name.replace(/^_/, "");
  }).filter(function (name) {
    return name !== "__esModule";
  });

  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = typeof index;

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;

  var symbolTag$2 = '[object Symbol]';

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2;
  }

  var isSymbol_1 = isSymbol;

  var NAN = 0 / 0;
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;

  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;

  var nativeCeil = Math.ceil,
      nativeMax = Math.max;

  function chunk(array, size, guard) {
    if (guard ? _isIterateeCall(array, size, guard) : size === undefined) {
      size = 1;
    } else {
      size = nativeMax(toInteger_1(size), 0);
    }

    var length = array == null ? 0 : array.length;

    if (!length || size < 1) {
      return [];
    }

    var index = 0,
        resIndex = 0,
        result = Array(nativeCeil(length / size));

    while (index < length) {
      result[resIndex++] = _baseSlice(array, index, index += size);
    }

    return result;
  }

  var chunk_1 = chunk;

  var ImportBuilder = function () {
    function ImportBuilder(importedSource, scope, hub) {
      this._statements = [];
      this._resultName = null;
      this._scope = null;
      this._hub = null;
      this._scope = scope;
      this._hub = hub;
      this._importedSource = importedSource;
    }

    var _proto = ImportBuilder.prototype;

    _proto.done = function done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    };

    _proto["import"] = function _import() {
      this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));

      return this;
    };

    _proto.require = function require() {
      this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));

      return this;
    };

    _proto.namespace = function namespace(name) {
      if (name === void 0) {
        name = "namespace";
      }

      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert__default['default'](statement.type === "ImportDeclaration");
      assert__default['default'](statement.specifiers.length === 0);
      statement.specifiers = [importNamespaceSpecifier(name)];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto["default"] = function _default(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert__default['default'](statement.type === "ImportDeclaration");
      assert__default['default'](statement.specifiers.length === 0);
      statement.specifiers = [importDefaultSpecifier(name)];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.named = function named(name, importName) {
      if (importName === "default") return this["default"](name);
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert__default['default'](statement.type === "ImportDeclaration");
      assert__default['default'](statement.specifiers.length === 0);
      statement.specifiers = [importSpecifier(name, identifier(importName))];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto["var"] = function _var(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];

      if (statement.type !== "ExpressionStatement") {
        assert__default['default'](this._resultName);
        statement = expressionStatement(this._resultName);

        this._statements.push(statement);
      }

      this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(name, statement.expression)]);
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.defaultInterop = function defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    };

    _proto.wildcardInterop = function wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    };

    _proto._interop = function _interop(callee) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = callExpression(callee, [statement.expression]);
      } else if (statement.type === "VariableDeclaration") {
        assert__default['default'](statement.declarations.length === 1);
        statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
      } else {
        assert__default['default'].fail("Unexpected type.");
      }

      return this;
    };

    _proto.prop = function prop(name) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = memberExpression(statement.expression, identifier(name));
      } else if (statement.type === "VariableDeclaration") {
        assert__default['default'](statement.declarations.length === 1);
        statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
      } else {
        assert__default['default'].fail("Unexpected type:" + statement.type);
      }

      return this;
    };

    _proto.read = function read(name) {
      this._resultName = memberExpression(this._resultName, identifier(name));
    };

    return ImportBuilder;
  }();

  function isModule(path) {
    var sourceType = path.node.sourceType;

    if (sourceType !== "module" && sourceType !== "script") {
      throw path.buildCodeFrameError("Unknown sourceType \"" + sourceType + "\", cannot transform.");
    }

    return path.node.sourceType === "module";
  }

  var ImportInjector = function () {
    function ImportInjector(path, importedSource, opts) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: false,
        ensureNoContext: false,
        importPosition: "before"
      };
      var programPath = path.find(function (p) {
        return p.isProgram();
      });
      this._programPath = programPath;
      this._programScope = programPath.scope;
      this._hub = programPath.hub;
      this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }

    var _proto = ImportInjector.prototype;

    _proto.addDefault = function addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    };

    _proto.addNamed = function addNamed(importName, importedSourceIn, opts) {
      assert__default['default'](typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    };

    _proto.addNamespace = function addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    };

    _proto.addSideEffect = function addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
    };

    _proto._applyDefaults = function _applyDefaults(importedSource, opts, isInit) {
      if (isInit === void 0) {
        isInit = false;
      }

      var optsList = [];

      if (typeof importedSource === "string") {
        optsList.push({
          importedSource: importedSource
        });
        optsList.push(opts);
      } else {
        assert__default['default'](!opts, "Unexpected secondary arguments.");
        optsList.push(importedSource);
      }

      var newOpts = Object.assign({}, this._defaultOpts);

      var _loop = function _loop() {
        var opts = _optsList[_i];
        if (!opts) return "continue";
        Object.keys(newOpts).forEach(function (key) {
          if (opts[key] !== undefined) newOpts[key] = opts[key];
        });

        if (!isInit) {
          if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
        }
      };

      for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return newOpts;
    };

    _proto._generateImport = function _generateImport(opts, importName) {
      var isDefault = importName === "default";
      var isNamed = !!importName && !isDefault;
      var isNamespace = importName === null;
      var importedSource = opts.importedSource,
          importedType = opts.importedType,
          importedInterop = opts.importedInterop,
          importingInterop = opts.importingInterop,
          ensureLiveReference = opts.ensureLiveReference,
          ensureNoContext = opts.ensureNoContext,
          nameHint = opts.nameHint,
          importPosition = opts.importPosition,
          blockHoist = opts.blockHoist;
      var name = nameHint || importName;
      var isMod = isModule(this._programPath);
      var isModuleForNode = isMod && importingInterop === "node";
      var isModuleForBabel = isMod && importingInterop === "babel";

      if (importPosition === "after" && !isMod) {
        throw new Error("\"importPosition\": \"after\" is only supported in modules");
      }

      var builder = new ImportBuilder(importedSource, this._programScope, this._hub);

      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }

        builder["import"]();

        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error("Unexpected interopType \"" + importedType + "\"");
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          var es6Default = importedSource + "$es6Default";
          builder["import"]();

          if (isNamespace) {
            builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
            } else {
              builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder["default"](es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder["var"](name).read(importName);
              builder.defaultInterop();
            } else {
              builder["var"](importedSource).read(importName);
            }
          } else if (isDefault) {
            builder["var"](name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder["var"](name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault || isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder.prop(importName)["var"](name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }

        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault) {
            builder["var"](name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder["var"](name).prop(importName);
            }
          }
        }
      } else {
        throw new Error("Unknown importedInterop \"" + importedInterop + "\".");
      }

      var _builder$done = builder.done(),
          statements = _builder$done.statements,
          resultName = _builder$done.resultName;

      this._insertStatements(statements, importPosition, blockHoist);

      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return sequenceExpression([numericLiteral(0), resultName]);
      }

      return resultName;
    };

    _proto._insertStatements = function _insertStatements(statements, importPosition, blockHoist) {
      if (importPosition === void 0) {
        importPosition = "before";
      }

      if (blockHoist === void 0) {
        blockHoist = 3;
      }

      var body = this._programPath.get("body");

      if (importPosition === "after") {
        for (var i = body.length - 1; i >= 0; i--) {
          if (body[i].isImportDeclaration()) {
            body[i].insertAfter(statements);
            return;
          }
        }
      } else {
        statements.forEach(function (node) {
          node._blockHoist = blockHoist;
        });
        var targetPath = body.find(function (p) {
          var val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });

        if (targetPath) {
          targetPath.insertBefore(statements);
          return;
        }
      }

      this._programPath.unshiftContainer("body", statements);
    };

    return ImportInjector;
  }();

  function addDefault(path, importedSource, opts) {
    return new ImportInjector(path).addDefault(importedSource, opts);
  }
  function addNamed(path, name, importedSource, opts) {
    return new ImportInjector(path).addNamed(name, importedSource, opts);
  }
  function addNamespace(path, importedSource, opts) {
    return new ImportInjector(path).addNamespace(importedSource, opts);
  }
  function addSideEffect(path, importedSource, opts) {
    return new ImportInjector(path).addSideEffect(importedSource, opts);
  }

  function willPathCastToBoolean(path) {
    var maybeWrapped = path;
    var node = maybeWrapped.node,
        parentPath = maybeWrapped.parentPath;

    if (parentPath.isLogicalExpression()) {
      var _parentPath$node = parentPath.node,
          operator = _parentPath$node.operator,
          right = _parentPath$node.right;

      if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
        return willPathCastToBoolean(parentPath);
      }
    }

    if (parentPath.isSequenceExpression()) {
      var expressions = parentPath.node.expressions;

      if (expressions[expressions.length - 1] === node) {
        return willPathCastToBoolean(parentPath);
      } else {
        return true;
      }
    }

    return parentPath.isConditional({
      test: node
    }) || parentPath.isUnaryExpression({
      operator: "!"
    }) || parentPath.isLoop({
      test: node
    });
  }

  var AssignmentMemoiser = function () {
    function AssignmentMemoiser() {
      this._map = new WeakMap();
    }

    var _proto = AssignmentMemoiser.prototype;

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.get = function get(key) {
      if (!this.has(key)) return;

      var record = this._map.get(key);

      var value = record.value;
      record.count--;

      if (record.count === 0) {
        return assignmentExpression("=", value, key);
      }

      return value;
    };

    _proto.set = function set(key, value, count) {
      return this._map.set(key, {
        count: count,
        value: value
      });
    };

    return AssignmentMemoiser;
  }();

  function toNonOptional(path, base) {
    var node = path.node;

    if (path.isOptionalMemberExpression()) {
      return memberExpression(base, node.property, node.computed);
    }

    if (path.isOptionalCallExpression()) {
      var callee = path.get("callee");

      if (path.node.optional && callee.isOptionalMemberExpression()) {
        var object = callee.node.object;
        var context = path.scope.maybeGenerateMemoised(object) || object;
        callee.get("object").replaceWith(assignmentExpression("=", context, object));
        return callExpression(memberExpression(base, identifier("call")), [context].concat(node.arguments));
      }

      return callExpression(base, node.arguments);
    }

    return path.node;
  }

  function isInDetachedTree(path) {
    while (path) {
      if (path.isProgram()) break;
      var _path = path,
          parentPath = _path.parentPath,
          container = _path.container,
          listKey = _path.listKey;
      var parentNode = parentPath.node;

      if (listKey) {
        if (container !== parentNode[listKey]) return true;
      } else {
        if (container !== parentNode) return true;
      }

      path = parentPath;
    }

    return false;
  }

  var handle = {
    memoise: function memoise() {},
    handle: function handle(member) {
      var node = member.node,
          parent = member.parent,
          parentPath = member.parentPath,
          scope = member.scope;

      if (member.isOptionalMemberExpression()) {
        if (isInDetachedTree(member)) return;
        var endPath = member.find(function (_ref) {
          var node = _ref.node,
              parent = _ref.parent,
              parentPath = _ref.parentPath;

          if (parentPath.isOptionalMemberExpression()) {
            return parent.optional || parent.object !== node;
          }

          if (parentPath.isOptionalCallExpression()) {
            return node !== member.node && parent.optional || parent.callee !== node;
          }

          return true;
        });

        if (scope.path.isPattern()) {
          endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
          return;
        }

        var willEndPathCastToBoolean = willPathCastToBoolean(endPath);
        var rootParentPath = endPath.parentPath;

        if (rootParentPath.isUpdateExpression({
          argument: node
        }) || rootParentPath.isAssignmentExpression({
          left: node
        })) {
          throw member.buildCodeFrameError("can't handle assignment");
        }

        var isDeleteOperation = rootParentPath.isUnaryExpression({
          operator: "delete"
        });

        if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
          throw member.buildCodeFrameError("can't delete a private class element");
        }

        var startingOptional = member;

        for (;;) {
          if (startingOptional.isOptionalMemberExpression()) {
            if (startingOptional.node.optional) break;
            startingOptional = startingOptional.get("object");
            continue;
          } else if (startingOptional.isOptionalCallExpression()) {
            if (startingOptional.node.optional) break;
            startingOptional = startingOptional.get("callee");
            continue;
          }

          throw new Error("Internal error: unexpected " + startingOptional.node.type);
        }

        var startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee";
        var startingNode = startingOptional.node[startingProp];
        var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
        var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
        var parentIsOptionalCall = parentPath.isOptionalCallExpression({
          callee: node
        });
        var parentIsCall = parentPath.isCallExpression({
          callee: node
        });
        startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));

        if (parentIsOptionalCall) {
          if (parent.optional) {
            parentPath.replaceWith(this.optionalCall(member, parent.arguments));
          } else {
            parentPath.replaceWith(this.call(member, parent.arguments));
          }
        } else if (parentIsCall) {
          member.replaceWith(this.boundGet(member));
        } else {
          member.replaceWith(this.get(member));
        }

        var regular = member.node;

        for (var current = member; current !== endPath;) {
          var _current = current,
              _parentPath = _current.parentPath;

          if (_parentPath === endPath && parentIsOptionalCall && parent.optional) {
            regular = _parentPath.node;
            break;
          }

          regular = toNonOptional(_parentPath, regular);
          current = _parentPath;
        }

        var context;
        var endParentPath = endPath.parentPath;

        if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
          callee: endPath.node,
          optional: true
        })) {
          var _regular = regular,
              object = _regular.object;
          context = member.scope.maybeGenerateMemoised(object);

          if (context) {
            regular.object = assignmentExpression("=", context, object);
          }
        }

        var replacementPath = endPath;

        if (isDeleteOperation) {
          replacementPath = endParentPath;
          regular = endParentPath.node;
        }

        if (willEndPathCastToBoolean) {
          var nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef), nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode()));
          replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
        } else {
          var nullishCheck = logicalExpression("||", binaryExpression("===", baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef), nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode()));
          replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
        }

        if (context) {
          var endParent = endParentPath.node;
          endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context)].concat(endParent.arguments), false));
        }

        return;
      }

      if (parentPath.isUpdateExpression({
        argument: node
      })) {
        if (this.simpleSet) {
          member.replaceWith(this.simpleSet(member));
          return;
        }

        var operator = parent.operator,
            prefix = parent.prefix;
        this.memoise(member, 2);
        var value = binaryExpression(operator[0], unaryExpression("+", this.get(member)), numericLiteral(1));

        if (prefix) {
          parentPath.replaceWith(this.set(member, value));
        } else {
          var _scope = member.scope;

          var ref = _scope.generateUidIdentifierBasedOnNode(node);

          _scope.push({
            id: ref
          });

          value.left = assignmentExpression("=", cloneNode(ref), value.left);
          parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref)]));
        }

        return;
      }

      if (parentPath.isAssignmentExpression({
        left: node
      })) {
        if (this.simpleSet) {
          member.replaceWith(this.simpleSet(member));
          return;
        }

        var _operator = parent.operator,
            _value = parent.right;

        if (_operator === "=") {
          parentPath.replaceWith(this.set(member, _value));
        } else {
          var operatorTrunc = _operator.slice(0, -1);

          if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
            this.memoise(member, 1);
            parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, _value)));
          } else {
            this.memoise(member, 2);
            parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), _value)));
          }
        }

        return;
      }

      if (parentPath.isCallExpression({
        callee: node
      })) {
        parentPath.replaceWith(this.call(member, parent.arguments));
        return;
      }

      if (parentPath.isOptionalCallExpression({
        callee: node
      })) {
        if (scope.path.isPattern()) {
          parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
          return;
        }

        parentPath.replaceWith(this.optionalCall(member, parent.arguments));
        return;
      }

      if (parentPath.isForXStatement({
        left: node
      }) || parentPath.isObjectProperty({
        value: node
      }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isObjectProperty({
        value: parent
      }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
        member.replaceWith(this.destructureSet(member));
        return;
      }

      member.replaceWith(this.get(member));
    }
  };
  function memberExpressionToFunctions(path, visitor, state) {
    path.traverse(visitor, Object.assign({}, handle, state, {
      memoiser: new AssignmentMemoiser()
    }));
  }

  function optimiseCallExpression(callee, thisNode, args, optional) {
    if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
      name: "arguments"
    })) {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false);
      }

      return callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]);
    } else {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode].concat(args), false);
      }

      return callExpression(memberExpression(callee, identifier("call")), [thisNode].concat(args));
    }
  }

  var _environmentVisitor;

  function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
    objectRef = cloneNode(objectRef);
    var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
    return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
  }

  function skipAllButComputedKey(path) {
    if (!path.node.computed) {
      path.skip();
      return;
    }

    var keys = VISITOR_KEYS[path.type];

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  }
  var environmentVisitor = (_environmentVisitor = {}, _environmentVisitor[(staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation"] = function ClassPrivatePropertyTypeAnnotation(path) {
    path.skip();
  }, _environmentVisitor.Function = function Function(path) {
    if (path.isMethod()) return;
    if (path.isArrowFunctionExpression()) return;
    path.skip();
  }, _environmentVisitor["Method|ClassProperty"] = function MethodClassProperty(path) {
    skipAllButComputedKey(path);
  }, _environmentVisitor);
  var visitor$1 = traverse$1.visitors.merge([environmentVisitor, {
    Super: function Super(path, state) {
      var node = path.node,
          parentPath = path.parentPath;
      if (!parentPath.isMemberExpression({
        object: node
      })) return;
      state.handle(parentPath);
    }
  }]);
  var unshadowSuperBindingVisitor = traverse$1.visitors.merge([environmentVisitor, {
    Scopable: function Scopable(path, _ref) {
      var refName = _ref.refName;
      var binding = path.scope.getOwnBinding(refName);

      if (binding && binding.identifier.name === refName) {
        path.scope.rename(refName);
      }
    }
  }]);
  var specHandlers = {
    memoise: function memoise(superMember, count) {
      var scope = superMember.scope,
          node = superMember.node;
      var computed = node.computed,
          property = node.property;

      if (!computed) {
        return;
      }

      var memo = scope.maybeGenerateMemoised(property);

      if (!memo) {
        return;
      }

      this.memoiser.set(property, memo, count);
    },
    prop: function prop(superMember) {
      var _superMember$node = superMember.node,
          computed = _superMember$node.computed,
          property = _superMember$node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      if (computed) {
        return cloneNode(property);
      }

      return stringLiteral(property.name);
    },
    get: function get(superMember) {
      return this._get(superMember, this._getThisRefs());
    },
    _get: function _get(superMember, thisRefs) {
      var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
    },
    _getThisRefs: function _getThisRefs() {
      if (!this.isDerivedConstructor) {
        return {
          "this": thisExpression()
        };
      }

      var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
      return {
        memo: assignmentExpression("=", thisRef, thisExpression()),
        "this": cloneNode(thisRef)
      };
    },
    set: function set(superMember, value) {
      var thisRefs = this._getThisRefs();

      var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], booleanLiteral(superMember.isInStrictMode())]);
    },
    destructureSet: function destructureSet(superMember) {
      throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call: function call(superMember, args) {
      var thisRefs = this._getThisRefs();

      return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, false);
    },
    optionalCall: function optionalCall(superMember, args) {
      var thisRefs = this._getThisRefs();

      return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, true);
    }
  };
  var looseHandlers = Object.assign({}, specHandlers, {
    prop: function prop(superMember) {
      var property = superMember.node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      return cloneNode(property);
    },
    get: function get(superMember) {
      var isStatic = this.isStatic,
          superRef = this.superRef;
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      var object;

      if (isStatic) {
        object = superRef ? cloneNode(superRef) : memberExpression(identifier("Function"), identifier("prototype"));
      } else {
        object = superRef ? memberExpression(cloneNode(superRef), identifier("prototype")) : memberExpression(identifier("Object"), identifier("prototype"));
      }

      return memberExpression(object, prop, computed);
    },
    set: function set(superMember, value) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
    },
    destructureSet: function destructureSet(superMember) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return memberExpression(thisExpression(), prop, computed);
    },
    call: function call(superMember, args) {
      return optimiseCallExpression(this.get(superMember), thisExpression(), args, false);
    },
    optionalCall: function optionalCall(superMember, args) {
      return optimiseCallExpression(this.get(superMember), thisExpression(), args, true);
    }
  });

  var ReplaceSupers = function () {
    function ReplaceSupers(opts) {
      var path = opts.methodPath;
      this.methodPath = path;
      this.isDerivedConstructor = path.isClassMethod({
        kind: "constructor"
      }) && !!opts.superRef;
      this.isStatic = path.isObjectMethod() || path.node["static"];
      this.isPrivateMethod = path.isPrivate() && path.isMethod();
      this.file = opts.file;
      this.superRef = opts.superRef;
      this.isLoose = opts.isLoose;
      this.opts = opts;
    }

    var _proto = ReplaceSupers.prototype;

    _proto.getObjectRef = function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    };

    _proto.replace = function replace() {
      if (this.opts.refToPreserve) {
        this.methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }

      var handler = this.isLoose ? looseHandlers : specHandlers;
      memberExpressionToFunctions(this.methodPath, visitor$1, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        superRef: this.superRef
      }, handler));
    };

    return ReplaceSupers;
  }();

  function rewriteThis(programPath) {
    traverse$1(programPath.node, Object.assign({}, rewriteThisVisitor, {
      noScope: true
    }));
  }
  var rewriteThisVisitor = traverse$1.visitors.merge([environmentVisitor, {
    ThisExpression: function ThisExpression(path) {
      path.replaceWith(unaryExpression("void", numericLiteral(0), true));
    }
  }]);

  function simplifyAccess(path, bindingNames) {
    path.traverse(simpleAssignmentVisitor, {
      scope: path.scope,
      bindingNames: bindingNames,
      seen: new WeakSet()
    });
  }
  var simpleAssignmentVisitor = {
    UpdateExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            bindingNames = this.bindingNames;
        var arg = path.get("argument");
        if (!arg.isIdentifier()) return;
        var localName = arg.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
          var operator = path.node.operator == "++" ? "+=" : "-=";
          path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
        } else if (path.node.prefix) {
          path.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
        } else {
          var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
          var varName = old.name;
          path.scope.push({
            id: old
          });
          var binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));
          path.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
        }
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            seen = this.seen,
            bindingNames = this.bindingNames;
        if (path.node.operator === "=") return;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (!left.isIdentifier()) return;
        var localName = left.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        path.node.right = binaryExpression(path.node.operator.slice(0, -1), cloneNode(path.node.left), path.node.right);
        path.node.operator = "=";
      }
    }
  };

  function _templateObject$1() {
    var data = _taggedTemplateLiteralLoose(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "]);

    _templateObject$1 = function _templateObject() {
      return data;
    };

    return data;
  }
  function rewriteLiveReferences(programPath, metadata) {
    var imported = new Map();
    var exported = new Map();

    var requeueInParent = function requeueInParent(path) {
      programPath.requeue(path);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(metadata.source), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          source = _step$value[0],
          data = _step$value[1];

      for (var _iterator3 = _createForOfIteratorHelperLoose(data.imports), _step3; !(_step3 = _iterator3()).done;) {
        var _step3$value = _step3.value,
            localName = _step3$value[0],
            importName = _step3$value[1];
        imported.set(localName, [source, importName, null]);
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(data.importsNamespace), _step4; !(_step4 = _iterator4()).done;) {
        var _localName = _step4.value;
        imported.set(_localName, [source, null, _localName]);
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(metadata.local), _step2; !(_step2 = _iterator2()).done;) {
      var _exportMeta;

      var _step2$value = _step2.value,
          local = _step2$value[0],
          _data = _step2$value[1];
      var exportMeta = exported.get(local);

      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }

      (_exportMeta = exportMeta).push.apply(_exportMeta, _data.names);
    }

    programPath.traverse(rewriteBindingInitVisitor, {
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      exported: exported
    });
    simplifyAccess(programPath, new Set([].concat(Array.from(imported.keys()), Array.from(exported.keys()))));
    programPath.traverse(rewriteReferencesVisitor, {
      seen: new WeakSet(),
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      imported: imported,
      exported: exported,
      buildImportReference: function buildImportReference(_ref, identNode) {
        var source = _ref[0],
            importName = _ref[1],
            localName = _ref[2];
        var meta = metadata.source.get(source);

        if (localName) {
          if (meta.lazy) identNode = callExpression(identNode, []);
          return identNode;
        }

        var namespace = identifier(meta.name);
        if (meta.lazy) namespace = callExpression(namespace, []);
        var computed = metadata.stringSpecifiers.has(importName);
        return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
      }
    });
  }
  var rewriteBindingInitVisitor = {
    Scope: function Scope(path) {
      path.skip();
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      var id = path.node.id;
      if (!id) throw new Error("Expected class to have a name");
      var localName = id.name;
      var exportNames = exported.get(localName) || [];

      if (exportNames.length > 0) {
        var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    },
    VariableDeclaration: function VariableDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
        var exportNames = exported.get(localName) || [];

        if (exportNames.length > 0) {
          var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
          statement._blockHoist = path.node._blockHoist;
          requeueInParent(path.insertAfter(statement)[0]);
        }
      });
    }
  };

  var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
    return (exportNames || []).reduce(function (expr, exportName) {
      var stringSpecifiers = metadata.stringSpecifiers;
      var computed = stringSpecifiers.has(exportName);
      return assignmentExpression("=", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
    }, localExpr);
  };

  var buildImportThrow = function buildImportThrow(localName) {
    return template.expression.ast(_templateObject$1(), localName);
  };

  var rewriteReferencesVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      var seen = this.seen,
          buildImportReference = this.buildImportReference,
          scope = this.scope,
          imported = this.imported,
          requeueInParent = this.requeueInParent;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var localName = path.node.name;
      var localBinding = path.scope.getBinding(localName);
      var rootBinding = scope.getBinding(localName);
      if (rootBinding !== localBinding) return;
      var importData = imported.get(localName);

      if (importData) {
        var ref = buildImportReference(importData, path.node);
        ref.loc = path.node.loc;

        if ((path.parentPath.isCallExpression({
          callee: path.node
        }) || path.parentPath.isOptionalCallExpression({
          callee: path.node
        }) || path.parentPath.isTaggedTemplateExpression({
          tag: path.node
        })) && isMemberExpression(ref)) {
          path.replaceWith(sequenceExpression([numericLiteral(0), ref]));
        } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
          var object = ref.object,
              property = ref.property;
          path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
        } else {
          path.replaceWith(ref);
        }

        requeueInParent(path);
        path.skip();
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var _this = this;

        var scope = this.scope,
            seen = this.seen,
            imported = this.imported,
            exported = this.exported,
            requeueInParent = this.requeueInParent,
            buildImportReference = this.buildImportReference;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (left.isMemberExpression()) return;

        if (left.isIdentifier()) {
          var localName = left.node.name;

          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
            return;
          }

          var exportedNames = exported.get(localName);
          var importData = imported.get(localName);

          if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
            assert__default['default'](path.node.operator === "=", "Path was not simplified");
            var assignment = path.node;

            if (importData) {
              assignment.left = buildImportReference(importData, assignment.left);
              assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);
            }

            path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
            requeueInParent(path);
          }
        } else {
          var ids = left.getOuterBindingIdentifiers();
          var programScopeIds = Object.keys(ids).filter(function (localName) {
            return scope.getBinding(localName) === path.scope.getBinding(localName);
          });
          var id = programScopeIds.find(function (localName) {
            return imported.has(localName);
          });

          if (id) {
            path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);
          }

          var items = [];
          programScopeIds.forEach(function (localName) {
            var exportedNames = exported.get(localName) || [];

            if (exportedNames.length > 0) {
              items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier(localName)));
            }
          });

          if (items.length > 0) {
            var node = sequenceExpression(items);

            if (path.parentPath.isExpressionStatement()) {
              node = expressionStatement(node);
              node._blockHoist = path.parentPath.node._blockHoist;
            }

            var statement = path.insertAfter(node)[0];
            requeueInParent(statement);
          }
        }
      }
    },
    "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
      var scope = path.scope,
          node = path.node;
      var left = node.left;
      var exported = this.exported,
          programScope = this.scope;

      if (!isVariableDeclaration(left)) {
        var didTransform = false;
        var bodyPath = path.get("body");
        var loopBodyScope = bodyPath.scope;

        for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers(left)); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];

          if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {
            didTransform = true;

            if (loopBodyScope.hasOwnBinding(name)) {
              loopBodyScope.rename(name);
            }
          }
        }

        if (!didTransform) {
          return;
        }

        var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
        bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId)));
        path.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))]));
        scope.registerDeclaration(path.get("left"));
      }
    }
  };

  function hasExports(metadata) {
    return metadata.hasExports;
  }
  function isSideEffectImport(source) {
    return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
  }
  function normalizeModuleAndLoadMetadata(programPath, exportName, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$noInterop = _ref.noInterop,
        noInterop = _ref$noInterop === void 0 ? false : _ref$noInterop,
        _ref$loose = _ref.loose,
        loose = _ref$loose === void 0 ? false : _ref$loose,
        _ref$lazy = _ref.lazy,
        lazy = _ref$lazy === void 0 ? false : _ref$lazy,
        _ref$esNamespaceOnly = _ref.esNamespaceOnly,
        esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

    if (!exportName) {
      exportName = programPath.scope.generateUidIdentifier("exports").name;
    }

    var stringSpecifiers = new Set();
    nameAnonymousExports(programPath);

    var _getModuleMetadata = getModuleMetadata(programPath, {
      loose: loose,
      lazy: lazy
    }, stringSpecifiers),
        local = _getModuleMetadata.local,
        source = _getModuleMetadata.source,
        hasExports = _getModuleMetadata.hasExports;

    removeModuleDeclarations(programPath);

    for (var _iterator = _createForOfIteratorHelperLoose(source), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          metadata = _step$value[1];

      if (metadata.importsNamespace.size > 0) {
        metadata.name = metadata.importsNamespace.values().next().value;
      }

      if (noInterop) metadata.interop = "none";else if (esNamespaceOnly) {
        if (metadata.interop === "namespace") {
          metadata.interop = "default";
        }
      }
    }

    return {
      exportName: exportName,
      exportNameListName: null,
      hasExports: hasExports,
      local: local,
      source: source,
      stringSpecifiers: stringSpecifiers
    };
  }

  function getExportSpecifierName(path, stringSpecifiers) {
    if (path.isIdentifier()) {
      return path.node.name;
    } else if (path.isStringLiteral()) {
      var stringValue = path.node.value;

      if (!isIdentifierName(stringValue)) {
        stringSpecifiers.add(stringValue);
      }

      return stringValue;
    } else {
      throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + path.node.type);
    }
  }

  function getModuleMetadata(programPath, _ref2, stringSpecifiers) {
    var loose = _ref2.loose,
        lazy = _ref2.lazy;
    var localData = getLocalExportMetadata(programPath, loose, stringSpecifiers);
    var sourceData = new Map();

    var getData = function getData(sourceNode) {
      var source = sourceNode.value;
      var data = sourceData.get(source);

      if (!data) {
        data = {
          name: programPath.scope.generateUidIdentifier(path$1.basename(source, path$1.extname(source))).name,
          interop: "none",
          loc: null,
          imports: new Map(),
          importsNamespace: new Set(),
          reexports: new Map(),
          reexportNamespace: new Set(),
          reexportAll: null,
          lazy: false
        };
        sourceData.set(source, data);
      }

      return data;
    };

    var hasExports = false;
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        var data = getData(child.node.source);
        if (!data.loc) data.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          if (spec.isImportDefaultSpecifier()) {
            var localName = spec.get("local").node.name;
            data.imports.set(localName, "default");
            var reexport = localData.get(localName);

            if (reexport) {
              localData["delete"](localName);
              reexport.names.forEach(function (name) {
                data.reexports.set(name, "default");
              });
            }
          } else if (spec.isImportNamespaceSpecifier()) {
            var _localName = spec.get("local").node.name;
            data.importsNamespace.add(_localName);

            var _reexport = localData.get(_localName);

            if (_reexport) {
              localData["delete"](_localName);

              _reexport.names.forEach(function (name) {
                data.reexportNamespace.add(name);
              });
            }
          } else if (spec.isImportSpecifier()) {
            var importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
            var _localName2 = spec.get("local").node.name;
            data.imports.set(_localName2, importName);

            var _reexport2 = localData.get(_localName2);

            if (_reexport2) {
              localData["delete"](_localName2);

              _reexport2.names.forEach(function (name) {
                data.reexports.set(name, importName);
              });
            }
          }
        });
      } else if (child.isExportAllDeclaration()) {
        hasExports = true;

        var _data = getData(child.node.source);

        if (!_data.loc) _data.loc = child.node.loc;
        _data.reexportAll = {
          loc: child.node.loc
        };
      } else if (child.isExportNamedDeclaration() && child.node.source) {
        hasExports = true;

        var _data2 = getData(child.node.source);

        if (!_data2.loc) _data2.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          if (!spec.isExportSpecifier()) {
            throw spec.buildCodeFrameError("Unexpected export specifier type");
          }

          var importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
          var exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);

          _data2.reexports.set(exportName, importName);

          if (exportName === "__esModule") {
            throw exportName.buildCodeFrameError('Illegal export "__esModule".');
          }
        });
      } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
        hasExports = true;
      }
    });

    for (var _iterator2 = _createForOfIteratorHelperLoose(sourceData.values()), _step2; !(_step2 = _iterator2()).done;) {
      var metadata = _step2.value;
      var needsDefault = false;
      var needsNamed = false;

      if (metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }

      if (metadata.reexportAll) {
        needsNamed = true;
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.imports.values()), _step4; !(_step4 = _iterator4()).done;) {
        var importName = _step4.value;
        if (importName === "default") needsDefault = true;else needsNamed = true;
      }

      for (var _iterator5 = _createForOfIteratorHelperLoose(metadata.reexports.values()), _step5; !(_step5 = _iterator5()).done;) {
        var _importName = _step5.value;
        if (_importName === "default") needsDefault = true;else needsNamed = true;
      }

      if (needsDefault && needsNamed) {
        metadata.interop = "namespace";
      } else if (needsDefault) {
        metadata.interop = "default";
      }
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(sourceData), _step3; !(_step3 = _iterator3()).done;) {
      var _step3$value = _step3.value,
          source = _step3$value[0],
          _metadata = _step3$value[1];

      if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
        if (lazy === true) {
          _metadata.lazy = !/\./.test(source);
        } else if (Array.isArray(lazy)) {
          _metadata.lazy = lazy.indexOf(source) !== -1;
        } else if (typeof lazy === "function") {
          _metadata.lazy = lazy(source);
        } else {
          throw new Error(".lazy must be a boolean, string array, or function");
        }
      }
    }

    return {
      hasExports: hasExports,
      local: localData,
      source: sourceData
    };
  }

  function getLocalExportMetadata(programPath, loose, stringSpecifiers) {
    var bindingKindLookup = new Map();
    programPath.get("body").forEach(function (child) {
      var kind;

      if (child.isImportDeclaration()) {
        kind = "import";
      } else {
        if (child.isExportDefaultDeclaration()) child = child.get("declaration");

        if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child = child.get("declaration");
          } else if (loose && child.node.source && child.get("source").isStringLiteral()) {
            child.node.specifiers.forEach(function (specifier) {
              bindingKindLookup.set(specifier.local.name, "block");
            });
            return;
          }
        }

        if (child.isFunctionDeclaration()) {
          kind = "hoisted";
        } else if (child.isClassDeclaration()) {
          kind = "block";
        } else if (child.isVariableDeclaration({
          kind: "var"
        })) {
          kind = "var";
        } else if (child.isVariableDeclaration()) {
          kind = "block";
        } else {
          return;
        }
      }

      Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
        bindingKindLookup.set(name, kind);
      });
    });
    var localMetadata = new Map();

    var getLocalMetadata = function getLocalMetadata(idPath) {
      var localName = idPath.node.name;
      var metadata = localMetadata.get(localName);

      if (!metadata) {
        var kind = bindingKindLookup.get(localName);

        if (kind === undefined) {
          throw idPath.buildCodeFrameError("Exporting local \"" + localName + "\", which is not declared.");
        }

        metadata = {
          names: [],
          kind: kind
        };
        localMetadata.set(localName, metadata);
      }

      return metadata;
    };

    programPath.get("body").forEach(function (child) {
      if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {
        if (child.node.declaration) {
          var declaration = child.get("declaration");
          var ids = declaration.getOuterBindingIdentifierPaths();
          Object.keys(ids).forEach(function (name) {
            if (name === "__esModule") {
              throw declaration.buildCodeFrameError('Illegal export "__esModule".');
            }

            getLocalMetadata(ids[name]).names.push(name);
          });
        } else {
          child.get("specifiers").forEach(function (spec) {
            var local = spec.get("local");
            var exported = spec.get("exported");
            var localMetadata = getLocalMetadata(local);
            var exportName = getExportSpecifierName(exported, stringSpecifiers);

            if (exportName === "__esModule") {
              throw exported.buildCodeFrameError('Illegal export "__esModule".');
            }

            localMetadata.names.push(exportName);
          });
        }
      } else if (child.isExportDefaultDeclaration()) {
        var _declaration = child.get("declaration");

        if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
          getLocalMetadata(_declaration.get("id")).names.push("default");
        } else {
          throw _declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      }
    });
    return localMetadata;
  }

  function nameAnonymousExports(programPath) {
    programPath.get("body").forEach(function (child) {
      if (!child.isExportDefaultDeclaration()) return;
      splitExportDeclaration(child);
    });
  }

  function removeModuleDeclarations(programPath) {
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        child.remove();
      } else if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child.node.declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(child.node.declaration);
        } else {
          child.remove();
        }
      } else if (child.isExportDefaultDeclaration()) {
        var declaration = child.get("declaration");

        if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
          declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(declaration);
        } else {
          throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      } else if (child.isExportAllDeclaration()) {
        child.remove();
      }
    });
  }

  function getModuleName(rootOpts, pluginOpts) {
    var _pluginOpts$moduleRoo, _rootOpts$moduleIds, _rootOpts$moduleRoot;

    var filename = rootOpts.filename,
        _rootOpts$filenameRel = rootOpts.filenameRelative,
        filenameRelative = _rootOpts$filenameRel === void 0 ? filename : _rootOpts$filenameRel,
        _rootOpts$sourceRoot = rootOpts.sourceRoot,
        sourceRoot = _rootOpts$sourceRoot === void 0 ? (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot : _rootOpts$sourceRoot;
    var _pluginOpts$moduleId = pluginOpts.moduleId,
        moduleId = _pluginOpts$moduleId === void 0 ? rootOpts.moduleId : _pluginOpts$moduleId,
        _pluginOpts$moduleIds = pluginOpts.moduleIds,
        moduleIds = _pluginOpts$moduleIds === void 0 ? (_rootOpts$moduleIds = rootOpts.moduleIds) != null ? _rootOpts$moduleIds : !!moduleId : _pluginOpts$moduleIds,
        _pluginOpts$getModule = pluginOpts.getModuleId,
        getModuleId = _pluginOpts$getModule === void 0 ? rootOpts.getModuleId : _pluginOpts$getModule,
        _pluginOpts$moduleRoo2 = pluginOpts.moduleRoot,
        moduleRoot = _pluginOpts$moduleRoo2 === void 0 ? (_rootOpts$moduleRoot = rootOpts.moduleRoot) != null ? _rootOpts$moduleRoot : sourceRoot : _pluginOpts$moduleRoo2;
    if (!moduleIds) return null;

    if (moduleId != null && !getModuleId) {
      return moduleId;
    }

    var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

    if (filenameRelative) {
      var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
    }

    moduleName = moduleName.replace(/\\/g, "/");

    if (getModuleId) {
      return getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  }

  function _templateObject13$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = VALUE"]);

    _templateObject13$1 = function _templateObject13() {
      return data;
    };

    return data;
  }

  function _templateObject12$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS[\"NAME\"] = VALUE"]);

    _templateObject12$1 = function _templateObject12() {
      return data;
    };

    return data;
  }

  function _templateObject11$1() {
    var data = _taggedTemplateLiteralLoose(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "]);

    _templateObject11$1 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]);

    _templateObject10$1 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]);

    _templateObject9$1 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8$1() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]);

    _templateObject8$1 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7$1() {
    var data = _taggedTemplateLiteralLoose(["\n        EXPORTS.__esModule = true;\n      "]);

    _templateObject7$1 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6$1() {
    var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    "]);

    _templateObject6$1 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;"]);

    _templateObject5$1 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;"]);

    _templateObject4$1 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$1() {
    var data = _taggedTemplateLiteralLoose(["EXPORTS.NAME = NAMESPACE;"]);

    _templateObject3$1 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$1() {
    var data = _taggedTemplateLiteralLoose(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]);

    _templateObject2$1 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$2() {
    var data = _taggedTemplateLiteralLoose(["var NAME = SOURCE;"]);

    _templateObject$2 = function _templateObject() {
      return data;
    };

    return data;
  }
  function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
    var exportName = _ref.exportName,
        strict = _ref.strict,
        allowTopLevelThis = _ref.allowTopLevelThis,
        strictMode = _ref.strictMode,
        loose = _ref.loose,
        noInterop = _ref.noInterop,
        lazy = _ref.lazy,
        esNamespaceOnly = _ref.esNamespaceOnly;
    assert__default['default'](isModule(path), "Cannot process module statements in a script");
    path.node.sourceType = "script";
    var meta = normalizeModuleAndLoadMetadata(path, exportName, {
      noInterop: noInterop,
      loose: loose,
      lazy: lazy,
      esNamespaceOnly: esNamespaceOnly
    });

    if (!allowTopLevelThis) {
      rewriteThis(path);
    }

    rewriteLiveReferences(path, meta);

    if (strictMode !== false) {
      var hasStrict = path.node.directives.some(function (directive) {
        return directive.value.value === "use strict";
      });

      if (!hasStrict) {
        path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
      }
    }

    var headers = [];

    if (hasExports(meta) && !strict) {
      headers.push(buildESModuleHeader(meta, loose));
    }

    var nameList = buildExportNameListDeclaration(path, meta);

    if (nameList) {
      meta.exportNameListName = nameList.name;
      headers.push(nameList.statement);
    }

    headers.push.apply(headers, buildExportInitializationStatements(path, meta, loose));
    return {
      meta: meta,
      headers: headers
    };
  }
  function ensureStatementsHoisted(statements) {
    statements.forEach(function (header) {
      header._blockHoist = 3;
    });
  }
  function wrapInterop(programPath, expr, type) {
    if (type === "none") {
      return null;
    }

    var helper;

    if (type === "default") {
      helper = "interopRequireDefault";
    } else if (type === "namespace") {
      helper = "interopRequireWildcard";
    } else {
      throw new Error("Unknown interop: " + type);
    }

    return callExpression(programPath.hub.addHelper(helper), [expr]);
  }
  function buildNamespaceInitStatements(metadata, sourceMetadata, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var statements = [];
    var srcNamespace = identifier(sourceMetadata.name);
    if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);

    for (var _iterator = _createForOfIteratorHelperLoose(sourceMetadata.importsNamespace), _step; !(_step = _iterator()).done;) {
      var localName = _step.value;
      if (localName === sourceMetadata.name) continue;
      statements.push(template.statement(_templateObject$2())({
        NAME: localName,
        SOURCE: cloneNode(srcNamespace)
      }));
    }

    if (loose) {
      statements.push.apply(statements, buildReexportsFromMeta(metadata, sourceMetadata, loose));
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(sourceMetadata.reexportNamespace), _step2; !(_step2 = _iterator2()).done;) {
      var exportName = _step2.value;
      statements.push((sourceMetadata.lazy ? template.statement(_templateObject2$1()) : template.statement(_templateObject3$1()))({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: cloneNode(srcNamespace)
      }));
    }

    if (sourceMetadata.reexportAll) {
      var statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), loose);
      statement.loc = sourceMetadata.reexportAll.loc;
      statements.push(statement);
    }

    return statements;
  }
  var ReexportTemplate = {
    loose: template.statement(_templateObject4$1()),
    looseComputed: template.statement(_templateObject5$1()),
    spec: template(_templateObject6$1())
  };

  var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, loose) {
    var namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);
    var stringSpecifiers = meta.stringSpecifiers;
    return Array.from(metadata.reexports, function (_ref2) {
      var exportName = _ref2[0],
          importName = _ref2[1];
      var NAMESPACE_IMPORT;

      if (stringSpecifiers.has(importName)) {
        NAMESPACE_IMPORT = memberExpression(cloneNode(namespace), stringLiteral(importName), true);
      } else {
        NAMESPACE_IMPORT = NAMESPACE_IMPORT = memberExpression(cloneNode(namespace), identifier(importName));
      }

      var astNodes = {
        EXPORTS: meta.exportName,
        EXPORT_NAME: exportName,
        NAMESPACE_IMPORT: NAMESPACE_IMPORT
      };

      if (loose) {
        if (stringSpecifiers.has(exportName)) {
          return ReexportTemplate.looseComputed(astNodes);
        } else {
          return ReexportTemplate.loose(astNodes);
        }
      } else {
        return ReexportTemplate.spec(astNodes);
      }
    });
  };

  function buildESModuleHeader(metadata, enumerable) {
    if (enumerable === void 0) {
      enumerable = false;
    }

    return (enumerable ? template.statement(_templateObject7$1()) : template.statement(_templateObject8$1()))({
      EXPORTS: metadata.exportName
    });
  }

  function buildNamespaceReexport(metadata, namespace, loose) {
    return (loose ? template.statement(_templateObject9$1()) : template.statement(_templateObject10$1()))({
      NAMESPACE: namespace,
      EXPORTS: metadata.exportName,
      VERIFY_NAME_LIST: metadata.exportNameListName ? template(_templateObject11$1())({
        EXPORTS_LIST: metadata.exportNameListName
      }) : null
    });
  }

  function buildExportNameListDeclaration(programPath, metadata) {
    var exportedVars = Object.create(null);

    for (var _iterator3 = _createForOfIteratorHelperLoose(metadata.local.values()), _step3; !(_step3 = _iterator3()).done;) {
      var data = _step3.value;

      for (var _iterator5 = _createForOfIteratorHelperLoose(data.names), _step5; !(_step5 = _iterator5()).done;) {
        var _name = _step5.value;
        exportedVars[_name] = true;
      }
    }

    var hasReexport = false;

    for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.source.values()), _step4; !(_step4 = _iterator4()).done;) {
      var _data = _step4.value;

      for (var _iterator6 = _createForOfIteratorHelperLoose(_data.reexports.keys()), _step6; !(_step6 = _iterator6()).done;) {
        var exportName = _step6.value;
        exportedVars[exportName] = true;
      }

      for (var _iterator7 = _createForOfIteratorHelperLoose(_data.reexportNamespace), _step7; !(_step7 = _iterator7()).done;) {
        var _exportName = _step7.value;
        exportedVars[_exportName] = true;
      }

      hasReexport = hasReexport || _data.reexportAll;
    }

    if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
    var name = programPath.scope.generateUidIdentifier("exportNames");
    delete exportedVars["default"];
    return {
      name: name.name,
      statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))])
    };
  }

  function buildExportInitializationStatements(programPath, metadata, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var initStatements = [];
    var exportNames = [];

    for (var _iterator8 = _createForOfIteratorHelperLoose(metadata.local), _step8; !(_step8 = _iterator8()).done;) {
      var _step8$value = _step8.value,
          localName = _step8$value[0],
          data = _step8$value[1];

      if (data.kind === "import") ; else if (data.kind === "hoisted") {
        initStatements.push(buildInitStatement(metadata, data.names, identifier(localName)));
      } else {
        exportNames.push.apply(exportNames, data.names);
      }
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(metadata.source.values()), _step9; !(_step9 = _iterator9()).done;) {
      var _data2 = _step9.value;

      if (!loose) {
        initStatements.push.apply(initStatements, buildReexportsFromMeta(metadata, _data2, loose));
      }

      for (var _iterator10 = _createForOfIteratorHelperLoose(_data2.reexportNamespace), _step10; !(_step10 = _iterator10()).done;) {
        var exportName = _step10.value;
        exportNames.push(exportName);
      }
    }

    initStatements.push.apply(initStatements, chunk_1(exportNames, 100).map(function (members) {
      return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());
    }));
    return initStatements;
  }

  var InitTemplate = {
    computed: template.expression(_templateObject12$1()),
    "default": template.expression(_templateObject13$1())
  };

  function buildInitStatement(metadata, exportNames, initExpr) {
    var stringSpecifiers = metadata.stringSpecifiers,
        EXPORTS = metadata.exportName;
    return expressionStatement(exportNames.reduce(function (acc, exportName) {
      var params = {
        EXPORTS: EXPORTS,
        NAME: exportName,
        VALUE: acc
      };

      if (stringSpecifiers.has(exportName)) {
        return InitTemplate.computed(params);
      } else {
        return InitTemplate["default"](params);
      }
    }, initExpr));
  }

  var semver = createCommonjsModule(function (module, exports) {
  exports = module.exports = SemVer;
  var debug;

  if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function debug() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };
  } else {
    debug = function debug() {};
  }

  exports.SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports.re = [];
  var src = exports.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
  var MAINVERSION = R++;
  src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASE = R++;
  src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
  var BUILD = R++;
  src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
  var FULL = R++;
  var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
  src[FULL] = '^' + FULLPLAIN + '$';
  var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
  var LOOSE = R++;
  src[LOOSE] = '^' + LOOSEPLAIN + '$';
  var GTLT = R++;
  src[GTLT] = '((?:<|>)?=?)';
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGE = R++;
  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
  var COERCE = R++;
  src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
  var LONETILDE = R++;
  src[LONETILDE] = '(?:~>?)';
  var TILDETRIM = R++;
  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
  var tildeTrimReplace = '$1~';
  var TILDE = R++;
  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
  var TILDELOOSE = R++;
  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
  var LONECARET = R++;
  src[LONECARET] = '(?:\\^)';
  var CARETTRIM = R++;
  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
  var caretTrimReplace = '$1^';
  var CARET = R++;
  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
  var CARETLOOSE = R++;
  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
  var COMPARATOR = R++;
  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
  var comparatorTrimReplace = '$1$2$3';
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
  var STAR = R++;
  src[STAR] = '(<|>)?=?\\s*\\*';

  for (var i = 0; i < R; i++) {
    debug(i, src[i]);

    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }

  exports.parse = parse;

  function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH) {
      return null;
    }

    var r = options.loose ? re[LOOSE] : re[FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }

  exports.valid = valid;

  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }

  exports.clean = clean;

  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  }

  exports.SemVer = SemVer;

  function SemVer(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version);
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

    if (!m) {
      throw new TypeError('Invalid Version: ' + version);
    }

    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch;

    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.');
    }

    return this.version;
  };

  SemVer.prototype.toString = function () {
    return this.version;
  };

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return this.compareMain(other) || this.comparePre(other);
  };

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    var i = 0;

    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  };

  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;

      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;

      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error('invalid increment argument: ' + release);
    }

    this.format();
    this.raw = this.version;
    return this;
  };

  exports.inc = inc;

  function inc(version, release, loose, identifier) {
    if (typeof loose === 'string') {
      identifier = loose;
      loose = undefined;
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }

  exports.diff = diff;

  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = '';

      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre';
        var defaultResult = 'prerelease';
      }

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  }

  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;

  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }

  exports.rcompareIdentifiers = rcompareIdentifiers;

  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }

  exports.major = major;

  function major(a, loose) {
    return new SemVer(a, loose).major;
  }

  exports.minor = minor;

  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }

  exports.patch = patch;

  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }

  exports.compare = compare;

  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }

  exports.compareLoose = compareLoose;

  function compareLoose(a, b) {
    return compare(a, b, true);
  }

  exports.rcompare = rcompare;

  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }

  exports.sort = sort;

  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose);
    });
  }

  exports.rsort = rsort;

  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose);
    });
  }

  exports.gt = gt;

  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }

  exports.lt = lt;

  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }

  exports.eq = eq;

  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }

  exports.neq = neq;

  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }

  exports.gte = gte;

  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }

  exports.lte = lte;

  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }

  exports.cmp = cmp;

  function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq(a, b, loose);

      case '!=':
        return neq(a, b, loose);

      case '>':
        return gt(a, b, loose);

      case '>=':
        return gte(a, b, loose);

      case '<':
        return lt(a, b, loose);

      case '<=':
        return lte(a, b, loose);

      default:
        throw new TypeError('Invalid operator: ' + op);
    }
  }

  exports.Comparator = Comparator;

  function Comparator(comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  var ANY = {};

  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp);
    }

    this.operator = m[1];

    if (this.operator === '=') {
      this.operator = '';
    }

    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };

  Comparator.prototype.toString = function () {
    return this.value;
  };

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose);

    if (this.semver === ANY) {
      return true;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    return cmp(version, this.operator, this.semver, this.options);
  };

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required');
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    var rangeTmp;

    if (this.operator === '') {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === '') {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }

    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };

  exports.Range = Range;

  function Range(range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }

    if (!(this instanceof Range)) {
      return new Range(range, options);
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    });

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range);
    }

    this.format();
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim();
    }).join('||').trim();
    return this.range;
  };

  Range.prototype.toString = function () {
    return this.range;
  };

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug('hyphen replace', range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug('comparator trim', range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(' ');
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options);
    }, this).join(' ').split(/\s+/);

    if (this.options.loose) {
      set = set.filter(function (comp) {
        return !!comp.match(compRe);
      });
    }

    set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required');
    }

    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };

  exports.toComparators = toComparators;

  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  }

  function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  }

  function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  }

  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(' ');
  }

  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      }

      debug('tilde return', ret);
      return ret;
    });
  }

  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(' ');
  }

  function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
        }
      } else {
        debug('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
      }

      debug('caret return', ret);
      return ret;
    });
  }

  function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(' ');
  }

  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        ret = gtlt + M + '.' + m + '.' + p;
      } else if (xm) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      }

      debug('xRange return', ret);
      return ret;
    });
  }

  function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[STAR], '');
  }

  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0';
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0';
    } else {
      from = '>=' + from;
    }

    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0';
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0';
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
    } else {
      to = '<=' + to;
    }

    return (from + ' ' + to).trim();
  }

  Range.prototype.test = function (version) {
    if (!version) {
      return false;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true;
      }
    }

    return false;
  };

  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver);

        if (set[i].semver === ANY) {
          continue;
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  exports.satisfies = satisfies;

  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  }

  exports.maxSatisfying = maxSatisfying;

  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }

  exports.minSatisfying = minSatisfying;

  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }

  exports.minVersion = minVersion;

  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new SemVer('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error('Unexpected operation: ' + comparator.operator);
        }
      });
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  }

  exports.validRange = validRange;

  function validRange(range, options) {
    try {
      return new Range(range, options).range || '*';
    } catch (er) {
      return null;
    }
  }

  exports.ltr = ltr;

  function ltr(version, range, options) {
    return outside(version, range, '<', options);
  }

  exports.gtr = gtr;

  function gtr(version, range, options) {
    return outside(version, range, '>', options);
  }

  exports.outside = outside;

  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies(version, range, options)) {
      return false;
    }

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }

    return true;
  }

  exports.prerelease = prerelease;

  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }

  exports.intersects = intersects;

  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }

  exports.coerce = coerce;

  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    var match = version.match(re[COERCE]);

    if (match == null) {
      return null;
    }

    return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
  }
  });

  var errorVisitor = {
    enter: function enter(path, state) {
      var loc = path.node.loc;

      if (loc) {
        state.loc = loc;
        path.stop();
      }
    }
  };

  var File$1 = function () {
    function File(options, _ref) {
      var _this = this;

      var code = _ref.code,
          ast = _ref.ast,
          inputMap = _ref.inputMap;
      this._map = new Map();
      this.opts = void 0;
      this.declarations = {};
      this.path = null;
      this.ast = {};
      this.scope = void 0;
      this.metadata = {};
      this.code = "";
      this.inputMap = null;
      this.hub = {
        file: this,
        getCode: function getCode() {
          return _this.code;
        },
        getScope: function getScope() {
          return _this.scope;
        },
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      };
      this.opts = options;
      this.code = code;
      this.ast = ast;
      this.inputMap = inputMap;
      this.path = NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext();
      this.scope = this.path.scope;
    }

    var _proto = File.prototype;

    _proto.set = function set(key, val) {
      if (key === "helpersNamespace") {
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
      }

      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.getModuleName = function getModuleName$1() {
      return getModuleName(this.opts, this.opts);
    };

    _proto.addImport = function addImport() {
      throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      var minVersion$1;

      try {
        minVersion$1 = minVersion(name);
      } catch (err) {
        if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
        return false;
      }

      if (typeof versionRange !== "string") return true;
      if (semver.valid(versionRange)) versionRange = "^" + versionRange;
      return !semver.intersects("<" + minVersion$1, versionRange) && !semver.intersects(">=8.0.0", versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      var _this2 = this;

      var declar = this.declarations[name];
      if (declar) return cloneNode(declar);
      var generator = this.get("helperGenerator");

      if (generator) {
        var res = generator(name);
        if (res) return res;
      }

      ensure(name, File);
      var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
      var dependencies = {};

      for (var _iterator = _createForOfIteratorHelperLoose(getDependencies(name)), _step; !(_step = _iterator()).done;) {
        var dep = _step.value;
        dependencies[dep] = this.addHelper(dep);
      }

      var _helpers$get = get$1(name, function (dep) {
        return dependencies[dep];
      }, uid, Object.keys(this.scope.getAllBindings())),
          nodes = _helpers$get.nodes,
          globals = _helpers$get.globals;

      globals.forEach(function (name) {
        if (_this2.path.scope.hasBinding(name, true)) {
          _this2.path.scope.rename(name);
        }
      });
      nodes.forEach(function (node) {
        node._compact = true;
      });
      this.path.unshiftContainer("body", nodes);
      this.path.get("body").forEach(function (path) {
        if (nodes.indexOf(path.node) === -1) return;
        if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
      });
      return uid;
    };

    _proto.addTemplateObject = function addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
      if (Error === void 0) {
        Error = SyntaxError;
      }

      var loc = node && (node.loc || node._loc);

      if (!loc && node) {
        var state = {
          loc: null
        };
        traverse$1(node, errorVisitor, this.scope, state);
        loc = state.loc;
        var txt = "This is an error on an internal node. Probably an internal error.";
        if (loc) txt += " Location has been estimated.";
        msg += " (" + txt + ")";
      }

      if (loc) {
        var _this$opts$highlightC = this.opts.highlightCode,
            highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
        msg += "\n" + codeFrameColumns(this.code, {
          start: {
            line: loc.start.line,
            column: loc.start.column + 1
          },
          end: loc.end && loc.start.line === loc.end.line ? {
            line: loc.end.line,
            column: loc.end.column + 1
          } : undefined
        }, {
          highlightCode: highlightCode
        });
      }

      return new Error(msg);
    };

    _createClass(File, [{
      key: "shebang",
      get: function get() {
        var interpreter = this.path.node.interpreter;
        return interpreter ? interpreter.value : "";
      },
      set: function set(value) {
        if (value) {
          this.path.get("interpreter").replaceWith(interpreterDirective(value));
        } else {
          this.path.get("interpreter").remove();
        }
      }
    }]);

    return File;
  }();

  function _templateObject$3() {
    var data = _taggedTemplateLiteralLoose(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "]);

    _templateObject$3 = function _templateObject() {
      return data;
    };

    return data;
  }

  var buildUmdWrapper = function buildUmdWrapper(replacements) {
    return template(_templateObject$3())(replacements);
  };

  function buildGlobal(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    var container = functionExpression(null, [identifier("global")], blockStatement(body));
    var tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
    body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
    buildHelpers(body, namespace, allowlist);
    return tree;
  }

  function buildModule(allowlist) {
    var body = [];
    var refs = buildHelpers(body, null, allowlist);
    body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(function (name) {
      return exportSpecifier(cloneNode(refs[name]), identifier(name));
    })));
    return program(body, [], "module");
  }

  function buildUmd(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
    buildHelpers(body, namespace, allowlist);
    return program([buildUmdWrapper({
      FACTORY_PARAMETERS: identifier("global"),
      BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
      COMMON_ARGUMENTS: identifier("exports"),
      AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: identifier("this")
    })]);
  }

  function buildVar(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
    var tree = program(body);
    buildHelpers(body, namespace, allowlist);
    body.push(expressionStatement(namespace));
    return tree;
  }

  function buildHelpers(body, namespace, allowlist) {
    var getHelperReference = function getHelperReference(name) {
      return namespace ? memberExpression(namespace, identifier(name)) : identifier("_" + name);
    };

    var refs = {};
    list$1.forEach(function (name) {
      if (allowlist && allowlist.indexOf(name) < 0) return;
      var ref = refs[name] = getHelperReference(name);
      ensure(name, File$1);

      var _helpers$get = get$1(name, getHelperReference, ref),
          nodes = _helpers$get.nodes;

      body.push.apply(body, nodes);
    });
    return refs;
  }

  function babelBuildExternalHelpers (allowlist, outputType) {
    if (outputType === void 0) {
      outputType = "global";
    }

    var tree;
    var build = {
      global: buildGlobal,
      module: buildModule,
      umd: buildUmd,
      "var": buildVar
    }[outputType];

    if (build) {
      tree = build(allowlist);
    } else {
      throw new Error("Unsupported output type " + outputType);
    }

    return generateCode(tree).code;
  }

  var runtime_1 = createCommonjsModule(function (module) {
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap;

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator;

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }

      context.delegate = null;
      return ContinueSentinel;
    }

    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };
    return exports;
  }( module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  var _marked = regenerator.mark(findConfigUpwards),
      _marked2 = regenerator.mark(findPackageData),
      _marked3 = regenerator.mark(findRelativeConfig),
      _marked4 = regenerator.mark(findRootConfig),
      _marked5 = regenerator.mark(loadConfig),
      _marked6 = regenerator.mark(resolveShowConfigPath);

  function findConfigUpwards(rootDir) {
    return regenerator.wrap(function findConfigUpwards$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", null);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
  function findPackageData(filepath) {
    return regenerator.wrap(function findPackageData$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", {
              filepath: filepath,
              directories: [],
              pkg: null,
              isPackage: false
            });

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2);
  }
  function findRelativeConfig(pkgData, envName, caller) {
    return regenerator.wrap(function findRelativeConfig$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", {
              pkg: null,
              config: null,
              ignore: null
            });

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3);
  }
  function findRootConfig(dirname, envName, caller) {
    return regenerator.wrap(function findRootConfig$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", null);

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4);
  }
  function loadConfig(name, dirname, envName, caller) {
    return regenerator.wrap(function loadConfig$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            throw new Error("Cannot load " + name + " relative to " + dirname + " in a browser");

          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked5);
  }
  function resolveShowConfigPath(dirname) {
    return regenerator.wrap(function resolveShowConfigPath$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", null);

          case 1:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked6);
  }
  var ROOT_CONFIG_FILENAMES = [];
  function resolvePlugin(name, dirname) {
    return null;
  }
  function resolvePreset(name, dirname) {
    return null;
  }
  function loadPlugin(name, dirname) {
    throw new Error("Cannot load plugin " + name + " relative to " + dirname + " in a browser");
  }
  function loadPreset(name, dirname) {
    throw new Error("Cannot load preset " + name + " relative to " + dirname + " in a browser");
  }

  var version = "7.12.10";

  function getEnv(defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = "development";
    }

    return process.env.BABEL_ENV || undefined || defaultValue;
  }

  var GENSYNC_START = Symbol["for"]("gensync:v1:start");
  var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
  var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
  var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
  var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
  var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
  var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
  var gensync = Object.assign(function gensync(optsOrFn) {
    var genFn = optsOrFn;

    if (typeof optsOrFn !== "function") {
      genFn = newGenerator(optsOrFn);
    } else {
      genFn = wrapGenerator(optsOrFn);
    }

    return Object.assign(genFn, makeFunctionAPI(genFn));
  }, {
    all: buildOperation({
      name: "all",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);
        return items.map(function (item) {
          return evaluateSync(item);
        });
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);
        var count = 0;
        var results = items.map(function () {
          return undefined;
        });
        items.forEach(function (item, i) {
          evaluateAsync(item, function (val) {
            results[i] = val;
            count += 1;
            if (count === results.length) resolve(results);
          }, reject);
        });
      }
    }),
    race: buildOperation({
      name: "race",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        return evaluateSync(items[0]);
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          evaluateAsync(item, resolve, reject);
        }
      }
    })
  });

  function makeFunctionAPI(genFn) {
    var fns = {
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return evaluateSync(genFn.apply(this, args));
      },
      async: function async() {
        var _this = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return new Promise(function (resolve, reject) {
          evaluateAsync(genFn.apply(_this, args), resolve, reject);
        });
      },
      errback: function errback() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var cb = args.pop();

        if (typeof cb !== "function") {
          throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
        }

        var gen;

        try {
          gen = genFn.apply(this, args);
        } catch (err) {
          cb(err);
          return;
        }

        evaluateAsync(gen, function (val) {
          return cb(undefined, val);
        }, function (err) {
          return cb(err);
        });
      }
    };
    return fns;
  }

  function assertTypeof(type, name, value, allowUndefined) {
    if (typeof value === type || allowUndefined && typeof value === "undefined") {
      return;
    }

    var msg;

    if (allowUndefined) {
      msg = "Expected opts." + name + " to be either a " + type + ", or undefined.";
    } else {
      msg = "Expected opts." + name + " to be a " + type + ".";
    }

    throw makeError(msg, GENSYNC_OPTIONS_ERROR);
  }

  function makeError(msg, code) {
    return Object.assign(new Error(msg), {
      code: code
    });
  }

  function newGenerator(_ref) {
    var name = _ref.name,
        arity = _ref.arity,
        _sync = _ref.sync,
        _async = _ref.async,
        errback = _ref.errback;
    assertTypeof("string", "name", name, true);
    assertTypeof("number", "arity", arity, true);
    assertTypeof("function", "sync", _sync);
    assertTypeof("function", "async", _async, true);
    assertTypeof("function", "errback", errback, true);

    if (_async && errback) {
      throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
    }

    if (typeof name !== "string") {
      var fnName;

      if (errback && errback.name && errback.name !== "errback") {
        fnName = errback.name;
      }

      if (_async && _async.name && _async.name !== "async") {
        fnName = _async.name.replace(/Async$/, "");
      }

      if (_sync && _sync.name && _sync.name !== "sync") {
        fnName = _sync.name.replace(/Sync$/, "");
      }

      if (typeof fnName === "string") {
        name = fnName;
      }
    }

    if (typeof arity !== "number") {
      arity = _sync.length;
    }

    return buildOperation({
      name: name,
      arity: arity,
      sync: function sync(args) {
        return _sync.apply(this, args);
      },
      async: function async(args, resolve, reject) {
        if (_async) {
          _async.apply(this, args).then(resolve, reject);
        } else if (errback) {
          errback.call.apply(errback, [this].concat(args, [function (err, value) {
            if (err == null) resolve(value);else reject(err);
          }]));
        } else {
          resolve(_sync.apply(this, args));
        }
      }
    });
  }

  function wrapGenerator(genFn) {
    return setFunctionMetadata(genFn.name, genFn.length, function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return genFn.apply(this, args);
    });
  }

  function buildOperation(_ref2) {
    var name = _ref2.name,
        arity = _ref2.arity,
        sync = _ref2.sync,
        async = _ref2.async;
    return setFunctionMetadata(name, arity, regenerator.mark(function _callee() {
      var resume,
          _len5,
          args,
          _key5,
          result,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return GENSYNC_START;

            case 2:
              resume = _context.sent;

              for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = _args[_key5];
              }

              if (resume) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", sync.call(this, args));

            case 6:
              try {
                async.call(this, args, function (value) {
                  if (result) return;
                  result = {
                    value: value
                  };
                  resume();
                }, function (err) {
                  if (result) return;
                  result = {
                    err: err
                  };
                  resume();
                });
              } catch (err) {
                result = {
                  err: err
                };
                resume();
              }

              _context.next = 9;
              return GENSYNC_SUSPEND;

            case 9:
              if (!result.hasOwnProperty("err")) {
                _context.next = 11;
                break;
              }

              throw result.err;

            case 11:
              return _context.abrupt("return", result.value);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  }

  function evaluateSync(gen) {
    var value;

    while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
      var _gen$next;

      assertStart(value, gen);
    }

    return value;
  }

  function evaluateAsync(gen, resolve, reject) {
    (function step() {
      try {
        var value;

        var _loop = function _loop() {
          assertStart(value, gen);
          var sync = true;
          var didSyncResume = false;
          var out = gen.next(function () {
            if (sync) {
              didSyncResume = true;
            } else {
              step();
            }
          });
          sync = false;
          assertSuspend(out, gen);

          if (!didSyncResume) {
            return {
              v: void 0
            };
          }
        };

        while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
          var _gen$next2;

          var _ret = _loop();

          if (typeof _ret === "object") return _ret.v;
        }

        return resolve(value);
      } catch (err) {
        return reject(err);
      }
    })();
  }

  function assertStart(value, gen) {
    if (value === GENSYNC_START) return;
    throwError(gen, makeError("Got unexpected yielded value in gensync generator: " + JSON.stringify(value) + ". Did you perhaps mean to use 'yield*' instead of 'yield'?", GENSYNC_EXPECTED_START));
  }

  function assertSuspend(_ref3, gen) {
    var value = _ref3.value,
        done = _ref3.done;
    if (!done && value === GENSYNC_SUSPEND) return;
    throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got " + JSON.stringify(value) + ". If you get this, it is probably a gensync bug.", GENSYNC_EXPECTED_SUSPEND));
  }

  function throwError(gen, err) {
    if (gen["throw"]) gen["throw"](err);
    throw err;
  }

  function setFunctionMetadata(name, arity, fn) {
    if (typeof name === "string") {
      var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

      if (!nameDesc || nameDesc.configurable) {
        Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
          configurable: true,
          value: name
        }));
      }
    }

    if (typeof arity === "number") {
      var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

      if (!lengthDesc || lengthDesc.configurable) {
        Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
          configurable: true,
          value: arity
        }));
      }
    }

    return fn;
  }

  var id$1 = function id(x) {
    return x;
  };

  var runGenerator = gensync(regenerator.mark(function _callee(item) {
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(item, "t0", 1);

          case 1:
            return _context.abrupt("return", _context.t0);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var isAsync = gensync({
    sync: function sync() {
      return false;
    },
    errback: function errback(cb) {
      return cb(null, true);
    }
  });
  function maybeAsync(fn, message) {
    return gensync({
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = fn.apply(this, args);
        if (isThenable(result)) throw new Error(message);
        return result;
      },
      async: function async() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return Promise.resolve(fn.apply(this, args));
      }
    });
  }
  var withKind = gensync({
    sync: function sync(cb) {
      return cb("sync");
    },
    async: function async(cb) {
      return cb("async");
    }
  });
  function forwardAsync(action, cb) {
    var g = gensync(action);
    return withKind(function (kind) {
      var adapted = g[kind];
      return cb(adapted);
    });
  }
  var onFirstPause = gensync({
    name: "onFirstPause",
    arity: 2,
    sync: function sync(item) {
      return runGenerator.sync(item);
    },
    errback: function errback(item, firstPause, cb) {
      var completed = false;
      runGenerator.errback(item, function (err, value) {
        completed = true;
        cb(err, value);
      });

      if (!completed) {
        firstPause();
      }
    }
  });
  var waitFor = gensync({
    sync: id$1,
    async: id$1
  });
  function isThenable(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  function mergeOptions(target, source) {
    for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];

      if (k === "parserOpts" && source.parserOpts) {
        var parserOpts = source.parserOpts;
        var targetObj = target.parserOpts = target.parserOpts || {};
        mergeDefaultFields(targetObj, parserOpts);
      } else if (k === "generatorOpts" && source.generatorOpts) {
        var generatorOpts = source.generatorOpts;

        var _targetObj = target.generatorOpts = target.generatorOpts || {};

        mergeDefaultFields(_targetObj, generatorOpts);
      } else {
        var val = source[k];
        if (val !== undefined) target[k] = val;
      }
    }
  }

  function mergeDefaultFields(target, source) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      var val = source[k];
      if (val !== undefined) target[k] = val;
    }
  }

  function isIterableIterator(value) {
    return !!value && typeof value.next === "function" && typeof value[Symbol.iterator] === "function";
  }

  var _marked$1 = regenerator.mark(genTrue),
      _marked2$1 = regenerator.mark(getCachedValue),
      _marked3$1 = regenerator.mark(getCachedValueOrWait);

  var synchronize = function synchronize(gen) {
    return gensync(gen).sync;
  };

  function genTrue(data) {
    return regenerator.wrap(function genTrue$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", true);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$1);
  }

  function makeWeakCache(handler) {
    return makeCachedFunction(WeakMap, handler);
  }
  function makeWeakCacheSync(handler) {
    return synchronize(makeWeakCache(handler));
  }
  function makeStrongCache(handler) {
    return makeCachedFunction(Map, handler);
  }
  function makeStrongCacheSync(handler) {
    return synchronize(makeStrongCache(handler));
  }

  function makeCachedFunction(CallCache, handler) {
    var callCacheSync = new CallCache();
    var callCacheAsync = new CallCache();
    var futureCache = new CallCache();
    return regenerator.mark(function cachedFunction(arg, data) {
      var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;
      return regenerator.wrap(function cachedFunction$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(isAsync(), "t0", 1);

            case 1:
              asyncContext = _context2.t0;
              callCache = asyncContext ? callCacheAsync : callCacheSync;
              return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), "t1", 4);

            case 4:
              cached = _context2.t1;

              if (!cached.valid) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", cached.value);

            case 7:
              cache = new CacheConfigurator(data);
              handlerResult = handler(arg, cache);

              if (!isIterableIterator(handlerResult)) {
                _context2.next = 15;
                break;
              }

              gen = handlerResult;
              return _context2.delegateYield(onFirstPause(gen, function () {
                finishLock = setupAsyncLocks(cache, futureCache, arg);
              }), "t2", 12);

            case 12:
              value = _context2.t2;
              _context2.next = 16;
              break;

            case 15:
              value = handlerResult;

            case 16:
              updateFunctionCache(callCache, cache, arg, value);

              if (finishLock) {
                futureCache["delete"](arg);
                finishLock.release(value);
              }

              return _context2.abrupt("return", value);

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, cachedFunction);
    });
  }

  function getCachedValue(cache, arg, data) {
    var cachedValue, _iterator, _step, _step$value, _value, valid;

    return regenerator.wrap(function getCachedValue$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            cachedValue = cache.get(arg);

            if (!cachedValue) {
              _context3.next = 10;
              break;
            }

            _iterator = _createForOfIteratorHelperLoose(cachedValue);

          case 3:
            if ((_step = _iterator()).done) {
              _context3.next = 10;
              break;
            }

            _step$value = _step.value, _value = _step$value.value, valid = _step$value.valid;
            return _context3.delegateYield(valid(data), "t0", 6);

          case 6:
            if (!_context3.t0) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt("return", {
              valid: true,
              value: _value
            });

          case 8:
            _context3.next = 3;
            break;

          case 10:
            return _context3.abrupt("return", {
              valid: false,
              value: null
            });

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked2$1);
  }

  function getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
    var cached, _cached, _value2;

    return regenerator.wrap(function getCachedValueOrWait$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.delegateYield(getCachedValue(callCache, arg, data), "t0", 1);

          case 1:
            cached = _context4.t0;

            if (!cached.valid) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return", cached);

          case 4:
            if (!asyncContext) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(getCachedValue(futureCache, arg, data), "t1", 6);

          case 6:
            _cached = _context4.t1;

            if (!_cached.valid) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(waitFor(_cached.value.promise), "t2", 9);

          case 9:
            _value2 = _context4.t2;
            return _context4.abrupt("return", {
              valid: true,
              value: _value2
            });

          case 11:
            return _context4.abrupt("return", {
              valid: false,
              value: null
            });

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked3$1);
  }

  function setupAsyncLocks(config, futureCache, arg) {
    var finishLock = new Lock();
    updateFunctionCache(futureCache, config, arg, finishLock);
    return finishLock;
  }

  function updateFunctionCache(cache, config, arg, value) {
    if (!config.configured()) config.forever();
    var cachedValue = cache.get(arg);
    config.deactivate();

    switch (config.mode()) {
      case "forever":
        cachedValue = [{
          value: value,
          valid: genTrue
        }];
        cache.set(arg, cachedValue);
        break;

      case "invalidate":
        cachedValue = [{
          value: value,
          valid: config.validator()
        }];
        cache.set(arg, cachedValue);
        break;

      case "valid":
        if (cachedValue) {
          cachedValue.push({
            value: value,
            valid: config.validator()
          });
        } else {
          cachedValue = [{
            value: value,
            valid: config.validator()
          }];
          cache.set(arg, cachedValue);
        }

    }
  }

  var CacheConfigurator = function () {
    function CacheConfigurator(data) {
      this._active = true;
      this._never = false;
      this._forever = false;
      this._invalidate = false;
      this._configured = false;
      this._pairs = [];
      this._data = void 0;
      this._data = data;
    }

    var _proto = CacheConfigurator.prototype;

    _proto.simple = function simple() {
      return makeSimpleConfigurator(this);
    };

    _proto.mode = function mode() {
      if (this._never) return "never";
      if (this._forever) return "forever";
      if (this._invalidate) return "invalidate";
      return "valid";
    };

    _proto.forever = function forever() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never) {
        throw new Error("Caching has already been configured with .never()");
      }

      this._forever = true;
      this._configured = true;
    };

    _proto.never = function never() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._forever) {
        throw new Error("Caching has already been configured with .forever()");
      }

      this._never = true;
      this._configured = true;
    };

    _proto.using = function using(handler) {
      var _this = this;

      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }

      this._configured = true;
      var key = handler(this._data);
      var fn = maybeAsync(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");

      if (isThenable(key)) {
        return key.then(function (key) {
          _this._pairs.push([key, fn]);

          return key;
        });
      }

      this._pairs.push([key, fn]);

      return key;
    };

    _proto.invalidate = function invalidate(handler) {
      this._invalidate = true;
      return this.using(handler);
    };

    _proto.validator = function validator() {
      var pairs = this._pairs;
      return regenerator.mark(function _callee(data) {
        var _iterator2, _step2, _step2$value, key, fn;

        return regenerator.wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelperLoose(pairs);

              case 1:
                if ((_step2 = _iterator2()).done) {
                  _context5.next = 10;
                  break;
                }

                _step2$value = _step2.value, key = _step2$value[0], fn = _step2$value[1];
                _context5.t0 = key;
                return _context5.delegateYield(fn(data), "t1", 5);

              case 5:
                _context5.t2 = _context5.t1;

                if (!(_context5.t0 !== _context5.t2)) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return", false);

              case 8:
                _context5.next = 1;
                break;

              case 10:
                return _context5.abrupt("return", true);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee);
      });
    };

    _proto.deactivate = function deactivate() {
      this._active = false;
    };

    _proto.configured = function configured() {
      return this._configured;
    };

    return CacheConfigurator;
  }();

  function makeSimpleConfigurator(cache) {
    function cacheFn(val) {
      if (typeof val === "boolean") {
        if (val) cache.forever();else cache.never();
        return;
      }

      return cache.using(function () {
        return assertSimpleType(val());
      });
    }

    cacheFn.forever = function () {
      return cache.forever();
    };

    cacheFn.never = function () {
      return cache.never();
    };

    cacheFn.using = function (cb) {
      return cache.using(function () {
        return assertSimpleType(cb());
      });
    };

    cacheFn.invalidate = function (cb) {
      return cache.invalidate(function () {
        return assertSimpleType(cb());
      });
    };

    return cacheFn;
  }

  function assertSimpleType(value) {
    if (isThenable(value)) {
      throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
    }

    if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    }

    return value;
  }

  var Lock = function () {
    function Lock() {
      var _this2 = this;

      this.released = false;
      this.promise = void 0;
      this._resolve = void 0;
      this.promise = new Promise(function (resolve) {
        _this2._resolve = resolve;
      });
    }

    var _proto2 = Lock.prototype;

    _proto2.release = function release(value) {
      this.released = true;

      this._resolve(value);
    };

    return Lock;
  }();

  function isEqualDescriptor(a, b) {
    return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
  }

  function createCachedDescriptors(dirname, options, alias) {
    var plugins = options.plugins,
        presets = options.presets,
        passPerPreset = options.passPerPreset;
    return {
      options: options,
      plugins: plugins ? function () {
        return createCachedPluginDescriptors(plugins, dirname)(alias);
      } : function () {
        return [];
      },
      presets: presets ? function () {
        return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
      } : function () {
        return [];
      }
    };
  }
  function createUncachedDescriptors(dirname, options, alias) {
    var _plugins;

    var _presets;

    return {
      options: options,
      plugins: function plugins() {
        if (!_plugins) {
          _plugins = createPluginDescriptors(options.plugins || [], dirname, alias);
        }

        return _plugins;
      },
      presets: function presets() {
        if (!_presets) {
          _presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);
        }

        return _presets;
      }
    };
  }
  var PRESET_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPresetDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCacheSync(function (alias) {
      return makeStrongCacheSync(function (passPerPreset) {
        return createPresetDescriptors(items, dirname, alias, passPerPreset).map(function (desc) {
          return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
        });
      });
    });
  });
  var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPluginDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCacheSync(function (alias) {
      return createPluginDescriptors(items, dirname, alias).map(function (desc) {
        return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
      });
    });
  });
  var DEFAULT_OPTIONS = {};

  function loadCachedDescriptor(cache, desc) {
    var value = desc.value,
        _desc$options = desc.options,
        options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
    if (options === false) return desc;
    var cacheByOptions = cache.get(value);

    if (!cacheByOptions) {
      cacheByOptions = new WeakMap();
      cache.set(value, cacheByOptions);
    }

    var possibilities = cacheByOptions.get(options);

    if (!possibilities) {
      possibilities = [];
      cacheByOptions.set(options, possibilities);
    }

    if (possibilities.indexOf(desc) === -1) {
      var matches = possibilities.filter(function (possibility) {
        return isEqualDescriptor(possibility, desc);
      });

      if (matches.length > 0) {
        return matches[0];
      }

      possibilities.push(desc);
    }

    return desc;
  }

  function createPresetDescriptors(items, dirname, alias, passPerPreset) {
    return createDescriptors("preset", items, dirname, alias, passPerPreset);
  }

  function createPluginDescriptors(items, dirname, alias) {
    return createDescriptors("plugin", items, dirname, alias);
  }

  function createDescriptors(type, items, dirname, alias, ownPass) {
    var descriptors = items.map(function (item, index) {
      return createDescriptor(item, dirname, {
        type: type,
        alias: alias + "$" + index,
        ownPass: !!ownPass
      });
    });
    assertNoDuplicates(descriptors);
    return descriptors;
  }

  function createDescriptor(pair, dirname, _ref) {
    var type = _ref.type,
        alias = _ref.alias,
        ownPass = _ref.ownPass;
    var desc = getItemDescriptor(pair);

    if (desc) {
      return desc;
    }

    var name;
    var options;
    var value = pair;

    if (Array.isArray(value)) {
      if (value.length === 3) {
        var _value = value;
        value = _value[0];
        options = _value[1];
        name = _value[2];
      } else {
        var _value2 = value;
        value = _value2[0];
        options = _value2[1];
      }
    }

    var file = undefined;
    var filepath = null;

    if (typeof value === "string") {
      if (typeof type !== "string") {
        throw new Error("To resolve a string-based item, the type of item must be given");
      }

      var resolver = type === "plugin" ? loadPlugin : loadPreset;
      var request = value;

      var _resolver = resolver(value, dirname);

      filepath = _resolver.filepath;
      value = _resolver.value;
      file = {
        request: request,
        resolved: filepath
      };
    }

    if (!value) {
      throw new Error("Unexpected falsy value: " + String(value));
    }

    if (typeof value === "object" && value.__esModule) {
      if (value["default"]) {
        value = value["default"];
      } else {
        throw new Error("Must export a default export when using ES6 modules.");
      }
    }

    if (typeof value !== "object" && typeof value !== "function") {
      throw new Error("Unsupported format: " + typeof value + ". Expected an object or a function.");
    }

    if (filepath !== null && typeof value === "object" && value) {
      throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);
    }

    return {
      name: name,
      alias: filepath || alias,
      value: value,
      options: options,
      dirname: dirname,
      ownPass: ownPass,
      file: file
    };
  }

  function assertNoDuplicates(items) {
    var map = new Map();

    var _loop = function _loop() {
      var item = _step.value;
      if (typeof item.value !== "function") return "continue";
      var nameMap = map.get(item.value);

      if (!nameMap) {
        nameMap = new Set();
        map.set(item.value, nameMap);
      }

      if (nameMap.has(item.name)) {
        var conflicts = items.filter(function (i) {
          return i.value === item.value;
        });
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "" + JSON.stringify(conflicts, null, 2)].join("\n"));
      }

      nameMap.add(item.name);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  }

  function createItemFromDescriptor(desc) {
    return new ConfigItem(desc);
  }
  function createConfigItem(value, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$dirname = _ref.dirname,
        dirname = _ref$dirname === void 0 ? "." : _ref$dirname,
        type = _ref.type;

    var descriptor = createDescriptor(value, path__default['default'].resolve(dirname), {
      type: type,
      alias: "programmatic item"
    });
    return createItemFromDescriptor(descriptor);
  }
  function getItemDescriptor(item) {
    if (item == null ? void 0 : item[CONFIG_ITEM_BRAND]) {
      return item._descriptor;
    }

    return undefined;
  }
  var CONFIG_ITEM_BRAND = Symbol["for"]("@babel/core@7 - ConfigItem");

  var ConfigItem = function ConfigItem(descriptor) {
    this._descriptor = void 0;
    this[CONFIG_ITEM_BRAND] = true;
    this.value = void 0;
    this.options = void 0;
    this.dirname = void 0;
    this.name = void 0;
    this.file = void 0;
    this._descriptor = descriptor;
    Object.defineProperty(this, "_descriptor", {
      enumerable: false
    });
    Object.defineProperty(this, CONFIG_ITEM_BRAND, {
      enumerable: false
    });
    this.value = this._descriptor.value;
    this.options = this._descriptor.options;
    this.dirname = this._descriptor.dirname;
    this.name = this._descriptor.name;
    this.file = this._descriptor.file ? {
      request: this._descriptor.file.request,
      resolved: this._descriptor.file.resolved
    } : undefined;
    Object.freeze(this);
  };

  Object.freeze(ConfigItem.prototype);

  var Plugin = function Plugin(plugin, options, key) {
    this.key = void 0;
    this.manipulateOptions = void 0;
    this.post = void 0;
    this.pre = void 0;
    this.visitor = void 0;
    this.parserOverride = void 0;
    this.generatorOverride = void 0;
    this.options = void 0;
    this.key = plugin.name || key;
    this.manipulateOptions = plugin.manipulateOptions;
    this.post = plugin.post;
    this.pre = plugin.pre;
    this.visitor = plugin.visitor || {};
    this.parserOverride = plugin.parserOverride;
    this.generatorOverride = plugin.generatorOverride;
    this.options = options;
  };

  var removed = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
    }
  };

  function msg(loc) {
    switch (loc.type) {
      case "root":
        return "";

      case "env":
        return msg(loc.parent) + ".env[\"" + loc.name + "\"]";

      case "overrides":
        return msg(loc.parent) + ".overrides[" + loc.index + "]";

      case "option":
        return msg(loc.parent) + "." + loc.name;

      case "access":
        return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

      default:
        throw new Error("Assertion failure: Unknown type " + loc.type);
    }
  }
  function access(loc, name) {
    return {
      type: "access",
      name: name,
      parent: loc
    };
  }
  function assertRootMode(loc, value) {
    if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
      throw new Error(msg(loc) + " must be a \"root\", \"upward\", \"upward-optional\" or undefined");
    }

    return value;
  }
  function assertSourceMaps(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
      throw new Error(msg(loc) + " must be a boolean, \"inline\", \"both\", or undefined");
    }

    return value;
  }
  function assertCompact(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
      throw new Error(msg(loc) + " must be a boolean, \"auto\", or undefined");
    }

    return value;
  }
  function assertSourceType(loc, value) {
    if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
      throw new Error(msg(loc) + " must be \"module\", \"script\", \"unambiguous\", or undefined");
    }

    return value;
  }
  function assertCallerMetadata(loc, value) {
    var obj = assertObject(loc, value);

    if (obj) {
      if (typeof obj["name"] !== "string") {
        throw new Error(msg(loc) + " set but does not contain \"name\" property string");
      }

      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];
        var propLoc = access(loc, prop);
        var _value = obj[prop];

        if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
          throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
        }
      }
    }

    return value;
  }
  function assertInputSourceMap(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
      throw new Error(msg(loc) + " must be a boolean, object, or undefined");
    }

    return value;
  }
  function assertString(loc, value) {
    if (value !== undefined && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a string, or undefined");
    }

    return value;
  }
  function assertFunction$1(loc, value) {
    if (value !== undefined && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a function, or undefined");
    }

    return value;
  }
  function assertBoolean(loc, value) {
    if (value !== undefined && typeof value !== "boolean") {
      throw new Error(msg(loc) + " must be a boolean, or undefined");
    }

    return value;
  }
  function assertObject(loc, value) {
    if (value !== undefined && (typeof value !== "object" || Array.isArray(value) || !value)) {
      throw new Error(msg(loc) + " must be an object, or undefined");
    }

    return value;
  }
  function assertArray(loc, value) {
    if (value != null && !Array.isArray(value)) {
      throw new Error(msg(loc) + " must be an array, or undefined");
    }

    return value;
  }
  function assertIgnoreList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertIgnoreItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertIgnoreItem(loc, value) {
    if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
      throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");
    }

    return value;
  }

  function assertConfigApplicableTest(loc, value) {
    if (value === undefined) return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");
    }

    return value;
  }

  function checkValidTest(value) {
    return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
  }

  function assertConfigFileSearch(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string, " + ("got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertBabelrcSearch(loc, value) {
    if (value === undefined || typeof value === "boolean") return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp " + ("or an array of those, got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertPluginList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertPluginItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertPluginItem(loc, value) {
    if (Array.isArray(value)) {
      if (value.length === 0) {
        throw new Error(msg(loc) + " must include an object");
      }

      if (value.length > 3) {
        throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");
      }

      assertPluginTarget(access(loc, 0), value[0]);

      if (value.length > 1) {
        var opts = value[1];

        if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
          throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
        }
      }

      if (value.length === 3) {
        var name = value[2];

        if (name !== undefined && typeof name !== "string") {
          throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
        }
      }
    } else {
      assertPluginTarget(loc, value);
    }

    return value;
  }

  function assertPluginTarget(loc, value) {
    if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a string, object, function");
    }

    return value;
  }

  var ROOT_VALIDATORS = {
    cwd: assertString,
    root: assertString,
    rootMode: assertRootMode,
    configFile: assertConfigFileSearch,
    caller: assertCallerMetadata,
    filename: assertString,
    filenameRelative: assertString,
    code: assertBoolean,
    ast: assertBoolean,
    cloneInputAst: assertBoolean,
    envName: assertString
  };
  var BABELRC_VALIDATORS = {
    babelrc: assertBoolean,
    babelrcRoots: assertBabelrcSearch
  };
  var NONPRESET_VALIDATORS = {
    "extends": assertString,
    ignore: assertIgnoreList,
    only: assertIgnoreList
  };
  var COMMON_VALIDATORS = {
    inputSourceMap: assertInputSourceMap,
    presets: assertPluginList,
    plugins: assertPluginList,
    passPerPreset: assertBoolean,
    env: assertEnvSet,
    overrides: assertOverridesList,
    test: assertConfigApplicableTest,
    include: assertConfigApplicableTest,
    exclude: assertConfigApplicableTest,
    retainLines: assertBoolean,
    comments: assertBoolean,
    shouldPrintComment: assertFunction$1,
    compact: assertCompact,
    minified: assertBoolean,
    auxiliaryCommentBefore: assertString,
    auxiliaryCommentAfter: assertString,
    sourceType: assertSourceType,
    wrapPluginVisitorMethod: assertFunction$1,
    highlightCode: assertBoolean,
    sourceMaps: assertSourceMaps,
    sourceMap: assertSourceMaps,
    sourceFileName: assertString,
    sourceRoot: assertString,
    getModuleId: assertFunction$1,
    moduleRoot: assertString,
    moduleIds: assertBoolean,
    moduleId: assertString,
    parserOpts: assertObject,
    generatorOpts: assertObject
  };

  function getSource$1(loc) {
    return loc.type === "root" ? loc.source : getSource$1(loc.parent);
  }

  function validate$3(type, opts) {
    return validateNested({
      type: "root",
      source: type
    }, opts);
  }

  function validateNested(loc, opts) {
    var type = getSource$1(loc);
    assertNoDuplicateSourcemap(opts);
    Object.keys(opts).forEach(function (key) {
      var optLoc = {
        type: "option",
        name: key,
        parent: loc
      };

      if (type === "preset" && NONPRESET_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is not allowed in preset options");
      }

      if (type !== "arguments" && ROOT_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is only allowed in root programmatic options");
      }

      if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
        if (type === "babelrcfile" || type === "extendsfile") {
          throw new Error(msg(optLoc) + " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, " + "or babel.config.js/config file options");
        }

        throw new Error(msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options");
      }

      var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
      validator(optLoc, opts[key]);
    });
    return opts;
  }

  function throwUnknownError(loc) {
    var key = loc.name;

    if (removed[key]) {
      var _removed$key = removed[key],
          message = _removed$key.message,
          _removed$key$version = _removed$key.version,
          version = _removed$key$version === void 0 ? 5 : _removed$key$version;
      throw new Error("Using removed Babel " + version + " option: " + msg(loc) + " - " + message);
    } else {
      var unknownOptErr = new Error("Unknown option: " + msg(loc) + ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
      unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
      throw unknownOptErr;
    }
  }

  function has$3(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function assertNoDuplicateSourcemap(opts) {
    if (has$3(opts, "sourceMap") && has$3(opts, "sourceMaps")) {
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }
  }

  function assertEnvSet(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside of another .env block");
    }

    var parent = loc.parent;
    var obj = assertObject(loc, value);

    if (obj) {
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var envName = _Object$keys[_i];
        var env = assertObject(access(loc, envName), obj[envName]);
        if (!env) continue;
        var envLoc = {
          type: "env",
          name: envName,
          parent: parent
        };
        validateNested(envLoc, env);
      }
    }

    return obj;
  }

  function assertOverridesList(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside an .env block");
    }

    if (loc.parent.type === "overrides") {
      throw new Error(msg(loc) + " is not allowed inside an .overrides block");
    }

    var parent = loc.parent;
    var arr = assertArray(loc, value);

    if (arr) {
      for (var _iterator = _createForOfIteratorHelperLoose(arr.entries()), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            index = _step$value[0],
            item = _step$value[1];
        var objLoc = access(loc, index);
        var env = assertObject(objLoc, item);
        if (!env) throw new Error(msg(objLoc) + " must be an object");
        var overridesLoc = {
          type: "overrides",
          index: index,
          parent: parent
        };
        validateNested(overridesLoc, env);
      }
    }

    return arr;
  }

  function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
    if (index === 0) return;
    var lastItem = items[index - 1];
    var thisItem = items[index];

    if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
      e.message += "\n- Maybe you meant to use\n" + ("\"" + type + "\": [\n  [\"" + lastItem.file.request + "\", " + JSON.stringify(thisItem.value, undefined, 2) + "]\n]\n") + ("To be a valid " + type + ", its name and options should be wrapped in a pair of brackets");
    }
  }

  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;

  var INFINITY$1 = 1 / 0;
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _baseToString = baseToString;

  function toString$1(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString$1;

  var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar$1.source);

  function escapeRegExp(string) {
    string = toString_1(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar$1, '\\$&') : string;
  }

  var escapeRegExp_1 = escapeRegExp;

  var sep = "\\" + path__default['default'].sep;
  var endSep = "(?:" + sep + "|$)";
  var substitution = "[^" + sep + "]+";
  var starPat = "(?:" + substitution + sep + ")";
  var starPatLast = "(?:" + substitution + endSep + ")";
  var starStarPat = starPat + "*?";
  var starStarPatLast = starPat + "*?" + starPatLast + "?";
  function pathToPattern(pattern, dirname) {
    var parts = path__default['default'].resolve(dirname, pattern).split(path__default['default'].sep);
    return new RegExp(["^"].concat(parts.map(function (part, i) {
      var last = i === parts.length - 1;
      if (part === "**") return last ? starStarPatLast : starStarPat;
      if (part === "*") return last ? starPatLast : starPat;

      if (part.indexOf("*.") === 0) {
        return substitution + escapeRegExp_1(part.slice(1)) + (last ? endSep : sep);
      }

      return escapeRegExp_1(part) + (last ? endSep : sep);
    })).join(""));
  }

  var ChainFormatter = {
    Programmatic: 0,
    Config: 1
  };
  var Formatter = {
    title: function title(type, callerName, filepath) {
      var title = "";

      if (type === ChainFormatter.Programmatic) {
        title = "programmatic options";

        if (callerName) {
          title += " from " + callerName;
        }
      } else {
        title = "config " + filepath;
      }

      return title;
    },
    loc: function loc(index, envName) {
      var loc = "";

      if (index != null) {
        loc += ".overrides[" + index + "]";
      }

      if (envName != null) {
        loc += ".env[\"" + envName + "\"]";
      }

      return loc;
    },
    optionsAndDescriptors: function optionsAndDescriptors(opt) {
      var content = Object.assign({}, opt.options);
      delete content.overrides;
      delete content.env;
      var pluginDescriptors = [].concat(opt.plugins());

      if (pluginDescriptors.length) {
        content.plugins = pluginDescriptors.map(function (d) {
          return descriptorToConfig(d);
        });
      }

      var presetDescriptors = [].concat(opt.presets());

      if (presetDescriptors.length) {
        content.presets = [].concat(presetDescriptors).map(function (d) {
          return descriptorToConfig(d);
        });
      }

      return JSON.stringify(content, undefined, 2);
    }
  };

  function descriptorToConfig(d) {
    var _d$file;

    var name = (_d$file = d.file) == null ? void 0 : _d$file.request;

    if (name == null) {
      if (typeof d.value === "object") {
        name = d.value;
      } else if (typeof d.value === "function") {
        name = "[Function: " + d.value.toString().substr(0, 50) + " ... ]";
      }
    }

    if (name == null) {
      name = "[Unknown]";
    }

    if (d.options === undefined) {
      return name;
    } else if (d.name == null) {
      return [name, d.options];
    } else {
      return [name, d.options, d.name];
    }
  }

  var ConfigPrinter = function () {
    function ConfigPrinter() {
      this._stack = [];
    }

    var _proto = ConfigPrinter.prototype;

    _proto.configure = function configure(enabled, type, _ref) {
      var _this = this;

      var callerName = _ref.callerName,
          filepath = _ref.filepath;
      if (!enabled) return function () {};
      return function (content, index, envName) {
        _this._stack.push({
          type: type,
          callerName: callerName,
          filepath: filepath,
          content: content,
          index: index,
          envName: envName
        });
      };
    };

    ConfigPrinter.format = function format(config) {
      var title = Formatter.title(config.type, config.callerName, config.filepath);
      var loc = Formatter.loc(config.index, config.envName);
      if (loc) title += " " + loc;
      var content = Formatter.optionsAndDescriptors(config.content);
      return title + "\n" + content;
    };

    _proto.output = function output() {
      if (this._stack.length === 0) return "";
      return this._stack.map(function (s) {
        return ConfigPrinter.format(s);
      }).join("\n\n");
    };

    return ConfigPrinter;
  }();

  var _marked$2 = regenerator.mark(buildPresetChain),
      _marked2$2 = regenerator.mark(buildRootChain),
      _marked3$2 = regenerator.mark(loadFileChain),
      _marked4$1 = regenerator.mark(mergeExtendsChain);
  var debug = src("babel:config:config-chain");
  function buildPresetChain(arg, context) {
    var chain;
    return regenerator.wrap(function buildPresetChain$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(buildPresetChainWalker(arg, context), "t0", 1);

          case 1:
            chain = _context.t0;

            if (chain) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.abrupt("return", {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options.map(function (o) {
                return normalizeOptions$1(o);
              }),
              files: new Set()
            });

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$2);
  }
  var buildPresetChainWalker = makeChainWalker({
    root: function root(preset) {
      return loadPresetDescriptors(preset);
    },
    env: function env(preset, envName) {
      return loadPresetEnvDescriptors(preset)(envName);
    },
    overrides: function overrides(preset, index) {
      return loadPresetOverridesDescriptors(preset)(index);
    },
    overridesEnv: function overridesEnv(preset, index, envName) {
      return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
    },
    createLogger: function createLogger() {
      return function () {};
    }
  });
  var loadPresetDescriptors = makeWeakCacheSync(function (preset) {
    return buildRootDescriptors(preset, preset.alias, createUncachedDescriptors);
  });
  var loadPresetEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName);
    });
  });
  var loadPresetOverridesDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index);
    });
  });
  var loadPresetOverridesEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName);
      });
    });
  });
  function buildRootChain(opts, context) {
    var configReport, babelRcReport, programmaticLogger, programmaticChain, programmaticReport, configFile, babelrc, babelrcRoots, babelrcRootsDirectory, configFileChain, configFileLogger, validatedFile, result, pkgData, ignoreFile, babelrcFile, isIgnored, fileChain, _yield$findRelativeCo, _validatedFile, babelrcLogger, _result, chain;

    return regenerator.wrap(function buildRootChain$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            programmaticLogger = new ConfigPrinter();
            return _context2.delegateYield(loadProgrammaticChain({
              options: opts,
              dirname: context.cwd
            }, context, undefined, programmaticLogger), "t0", 2);

          case 2:
            programmaticChain = _context2.t0;

            if (programmaticChain) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", null);

          case 5:
            programmaticReport = programmaticLogger.output();

            if (!(typeof opts.configFile === "string")) {
              _context2.next = 11;
              break;
            }

            return _context2.delegateYield(loadConfig(opts.configFile, context.cwd, context.envName, context.caller), "t1", 8);

          case 8:
            configFile = _context2.t1;
            _context2.next = 14;
            break;

          case 11:
            if (!(opts.configFile !== false)) {
              _context2.next = 14;
              break;
            }

            return _context2.delegateYield(findRootConfig(context.root, context.envName, context.caller), "t2", 13);

          case 13:
            configFile = _context2.t2;

          case 14:
            babelrc = opts.babelrc, babelrcRoots = opts.babelrcRoots;
            babelrcRootsDirectory = context.cwd;
            configFileChain = emptyChain();
            configFileLogger = new ConfigPrinter();

            if (!configFile) {
              _context2.next = 28;
              break;
            }

            validatedFile = validateConfigFile(configFile);
            return _context2.delegateYield(loadFileChain(validatedFile, context, undefined, configFileLogger), "t3", 21);

          case 21:
            result = _context2.t3;

            if (result) {
              _context2.next = 24;
              break;
            }

            return _context2.abrupt("return", null);

          case 24:
            configReport = configFileLogger.output();

            if (babelrc === undefined) {
              babelrc = validatedFile.options.babelrc;
            }

            if (babelrcRoots === undefined) {
              babelrcRootsDirectory = validatedFile.dirname;
              babelrcRoots = validatedFile.options.babelrcRoots;
            }

            mergeChain(configFileChain, result);

          case 28:
            if (!(typeof context.filename === "string")) {
              _context2.next = 33;
              break;
            }

            return _context2.delegateYield(findPackageData(context.filename), "t5", 30);

          case 30:
            _context2.t4 = _context2.t5;
            _context2.next = 34;
            break;

          case 33:
            _context2.t4 = null;

          case 34:
            pkgData = _context2.t4;
            isIgnored = false;
            fileChain = emptyChain();

            if (!((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory))) {
              _context2.next = 51;
              break;
            }

            return _context2.delegateYield(findRelativeConfig(pkgData, context.envName, context.caller), "t6", 39);

          case 39:
            _yield$findRelativeCo = _context2.t6;
            ignoreFile = _yield$findRelativeCo.ignore;
            babelrcFile = _yield$findRelativeCo.config;

            if (ignoreFile) {
              fileChain.files.add(ignoreFile.filepath);
            }

            if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
              isIgnored = true;
            }

            if (!(babelrcFile && !isIgnored)) {
              _context2.next = 50;
              break;
            }

            _validatedFile = validateBabelrcFile(babelrcFile);
            babelrcLogger = new ConfigPrinter();
            return _context2.delegateYield(loadFileChain(_validatedFile, context, undefined, babelrcLogger), "t7", 48);

          case 48:
            _result = _context2.t7;

            if (!_result) {
              isIgnored = true;
            } else {
              babelRcReport = babelrcLogger.output();
              mergeChain(fileChain, _result);
            }

          case 50:
            if (babelrcFile && isIgnored) {
              fileChain.files.add(babelrcFile.filepath);
            }

          case 51:
            if (!context.showConfig) {
              _context2.next = 54;
              break;
            }

            console.log("Babel configs on \"" + context.filename + "\" (ascending priority):\n" + [configReport, babelRcReport, programmaticReport].filter(function (x) {
              return !!x;
            }).join("\n\n"));
            return _context2.abrupt("return", null);

          case 54:
            chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
            return _context2.abrupt("return", {
              plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
              presets: isIgnored ? [] : dedupDescriptors(chain.presets),
              options: isIgnored ? [] : chain.options.map(function (o) {
                return normalizeOptions$1(o);
              }),
              fileHandling: isIgnored ? "ignored" : "transpile",
              ignore: ignoreFile || undefined,
              babelrc: babelrcFile || undefined,
              config: configFile || undefined,
              files: chain.files
            });

          case 56:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$2);
  }

  function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
    if (typeof babelrcRoots === "boolean") return babelrcRoots;
    var absoluteRoot = context.root;

    if (babelrcRoots === undefined) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    var babelrcPatterns = babelrcRoots;
    if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];
    babelrcPatterns = babelrcPatterns.map(function (pat) {
      return typeof pat === "string" ? path__default['default'].resolve(babelrcRootsDirectory, pat) : pat;
    });

    if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    return babelrcPatterns.some(function (pat) {
      if (typeof pat === "string") {
        pat = pathToPattern(pat, babelrcRootsDirectory);
      }

      return pkgData.directories.some(function (directory) {
        return matchPattern(pat, babelrcRootsDirectory, directory, context);
      });
    });
  }

  var validateConfigFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("configfile", file.options)
    };
  });
  var validateBabelrcFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("babelrcfile", file.options)
    };
  });
  var validateExtendFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate$3("extendsfile", file.options)
    };
  });
  var loadProgrammaticChain = makeChainWalker({
    root: function root(input) {
      return buildRootDescriptors(input, "base", createCachedDescriptors);
    },
    env: function env(input, envName) {
      return buildEnvDescriptors(input, "base", createCachedDescriptors, envName);
    },
    overrides: function overrides(input, index) {
      return buildOverrideDescriptors(input, "base", createCachedDescriptors, index);
    },
    overridesEnv: function overridesEnv(input, index, envName) {
      return buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName);
    },
    createLogger: function createLogger(input, context, baseLogger) {
      return buildProgrammaticLogger(input, context, baseLogger);
    }
  });
  var loadFileChainWalker = makeChainWalker({
    root: function root(file) {
      return loadFileDescriptors(file);
    },
    env: function env(file, envName) {
      return loadFileEnvDescriptors(file)(envName);
    },
    overrides: function overrides(file, index) {
      return loadFileOverridesDescriptors(file)(index);
    },
    overridesEnv: function overridesEnv(file, index, envName) {
      return loadFileOverridesEnvDescriptors(file)(index)(envName);
    },
    createLogger: function createLogger(file, context, baseLogger) {
      return buildFileLogger(file.filepath, context, baseLogger);
    }
  });

  function loadFileChain(input, context, files, baseLogger) {
    var chain;
    return regenerator.wrap(function loadFileChain$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.delegateYield(loadFileChainWalker(input, context, files, baseLogger), "t0", 1);

          case 1:
            chain = _context3.t0;

            if (chain) {
              chain.files.add(input.filepath);
            }

            return _context3.abrupt("return", chain);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3$2);
  }

  var loadFileDescriptors = makeWeakCacheSync(function (file) {
    return buildRootDescriptors(file, file.filepath, createUncachedDescriptors);
  });
  var loadFileEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName);
    });
  });
  var loadFileOverridesDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index);
    });
  });
  var loadFileOverridesEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName);
      });
    });
  });

  function buildFileLogger(filepath, context, baseLogger) {
    if (!baseLogger) {
      return function () {};
    }

    return baseLogger.configure(context.showConfig, ChainFormatter.Config, {
      filepath: filepath
    });
  }

  function buildRootDescriptors(_ref, alias, descriptors) {
    var dirname = _ref.dirname,
        options = _ref.options;
    return descriptors(dirname, options, alias);
  }

  function buildProgrammaticLogger(_, context, baseLogger) {
    var _context$caller;

    if (!baseLogger) {
      return function () {};
    }

    return baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {
      callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
    });
  }

  function buildEnvDescriptors(_ref2, alias, descriptors, envName) {
    var dirname = _ref2.dirname,
        options = _ref2.options;
    var opts = options.env && options.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".env[\"" + envName + "\"]") : null;
  }

  function buildOverrideDescriptors(_ref3, alias, descriptors, index) {
    var dirname = _ref3.dirname,
        options = _ref3.options;
    var opts = options.overrides && options.overrides[index];
    if (!opts) throw new Error("Assertion failure - missing override");
    return descriptors(dirname, opts, alias + ".overrides[" + index + "]");
  }

  function buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {
    var dirname = _ref4.dirname,
        options = _ref4.options;
    var override = options.overrides && options.overrides[index];
    if (!override) throw new Error("Assertion failure - missing override");
    var opts = override.env && override.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".overrides[" + index + "].env[\"" + envName + "\"]") : null;
  }

  function makeChainWalker(_ref5) {
    var root = _ref5.root,
        env = _ref5.env,
        overrides = _ref5.overrides,
        overridesEnv = _ref5.overridesEnv,
        createLogger = _ref5.createLogger;
    return regenerator.mark(function _callee(input, context, files, baseLogger) {
      var dirname, flattenedConfigs, rootOpts, envOpts, chain, logger, _i, _flattenedConfigs, _flattenedConfigs$_i, config, index, envName;

      return regenerator.wrap(function _callee$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (files === void 0) {
                files = new Set();
              }

              dirname = input.dirname;
              flattenedConfigs = [];
              rootOpts = root(input);

              if (configIsApplicable(rootOpts, dirname, context)) {
                flattenedConfigs.push({
                  config: rootOpts,
                  envName: undefined,
                  index: undefined
                });
                envOpts = env(input, context.envName);

                if (envOpts && configIsApplicable(envOpts, dirname, context)) {
                  flattenedConfigs.push({
                    config: envOpts,
                    envName: context.envName,
                    index: undefined
                  });
                }

                (rootOpts.options.overrides || []).forEach(function (_, index) {
                  var overrideOps = overrides(input, index);

                  if (configIsApplicable(overrideOps, dirname, context)) {
                    flattenedConfigs.push({
                      config: overrideOps,
                      index: index,
                      envName: undefined
                    });
                    var overrideEnvOpts = overridesEnv(input, index, context.envName);

                    if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
                      flattenedConfigs.push({
                        config: overrideEnvOpts,
                        index: index,
                        envName: context.envName
                      });
                    }
                  }
                });
              }

              if (!flattenedConfigs.some(function (_ref6) {
                var _ref6$config$options = _ref6.config.options,
                    ignore = _ref6$config$options.ignore,
                    only = _ref6$config$options.only;
                return shouldIgnore(context, ignore, only, dirname);
              })) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", null);

            case 7:
              chain = emptyChain();
              logger = createLogger(input, context, baseLogger);
              _i = 0, _flattenedConfigs = flattenedConfigs;

            case 10:
              if (!(_i < _flattenedConfigs.length)) {
                _context4.next = 20;
                break;
              }

              _flattenedConfigs$_i = _flattenedConfigs[_i], config = _flattenedConfigs$_i.config, index = _flattenedConfigs$_i.index, envName = _flattenedConfigs$_i.envName;
              return _context4.delegateYield(mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger), "t0", 13);

            case 13:
              if (_context4.t0) {
                _context4.next = 15;
                break;
              }

              return _context4.abrupt("return", null);

            case 15:
              logger(config, index, envName);
              mergeChainOpts(chain, config);

            case 17:
              _i++;
              _context4.next = 10;
              break;

            case 20:
              return _context4.abrupt("return", chain);

            case 21:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee);
    });
  }

  function mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {
    var file, fileChain;
    return regenerator.wrap(function mergeExtendsChain$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(opts["extends"] === undefined)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", true);

          case 2:
            return _context5.delegateYield(loadConfig(opts["extends"], dirname, context.envName, context.caller), "t0", 3);

          case 3:
            file = _context5.t0;

            if (!files.has(file)) {
              _context5.next = 6;
              break;
            }

            throw new Error("Configuration cycle detected loading " + file.filepath + ".\n" + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
              return " - " + file.filepath;
            }).join("\n"));

          case 6:
            files.add(file);
            return _context5.delegateYield(loadFileChain(validateExtendFile(file), context, files, baseLogger), "t1", 8);

          case 8:
            fileChain = _context5.t1;
            files["delete"](file);

            if (fileChain) {
              _context5.next = 12;
              break;
            }

            return _context5.abrupt("return", false);

          case 12:
            mergeChain(chain, fileChain);
            return _context5.abrupt("return", true);

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked4$1);
  }

  function mergeChain(target, source) {
    var _target$options, _target$plugins, _target$presets;

    (_target$options = target.options).push.apply(_target$options, source.options);

    (_target$plugins = target.plugins).push.apply(_target$plugins, source.plugins);

    (_target$presets = target.presets).push.apply(_target$presets, source.presets);

    for (var _iterator = _createForOfIteratorHelperLoose(source.files), _step; !(_step = _iterator()).done;) {
      var file = _step.value;
      target.files.add(file);
    }

    return target;
  }

  function mergeChainOpts(target, _ref7) {
    var _target$plugins2, _target$presets2;

    var options = _ref7.options,
        plugins = _ref7.plugins,
        presets = _ref7.presets;
    target.options.push(options);

    (_target$plugins2 = target.plugins).push.apply(_target$plugins2, plugins());

    (_target$presets2 = target.presets).push.apply(_target$presets2, presets());

    return target;
  }

  function emptyChain() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: new Set()
    };
  }

  function normalizeOptions$1(opts) {
    var options = Object.assign({}, opts);
    delete options["extends"];
    delete options.env;
    delete options.overrides;
    delete options.plugins;
    delete options.presets;
    delete options.passPerPreset;
    delete options.ignore;
    delete options.only;
    delete options.test;
    delete options.include;
    delete options.exclude;

    if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
      options.sourceMaps = options.sourceMap;
      delete options.sourceMap;
    }

    return options;
  }

  function dedupDescriptors(items) {
    var map = new Map();
    var descriptors = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(items), _step2; !(_step2 = _iterator2()).done;) {
      var item = _step2.value;

      if (typeof item.value === "function") {
        var fnKey = item.value;
        var nameMap = map.get(fnKey);

        if (!nameMap) {
          nameMap = new Map();
          map.set(fnKey, nameMap);
        }

        var desc = nameMap.get(item.name);

        if (!desc) {
          desc = {
            value: item
          };
          descriptors.push(desc);
          if (!item.ownPass) nameMap.set(item.name, desc);
        } else {
          desc.value = item;
        }
      } else {
        descriptors.push({
          value: item
        });
      }
    }

    return descriptors.reduce(function (acc, desc) {
      acc.push(desc.value);
      return acc;
    }, []);
  }

  function configIsApplicable(_ref8, dirname, context) {
    var options = _ref8.options;
    return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
  }

  function configFieldIsApplicable(context, test, dirname) {
    var patterns = Array.isArray(test) ? test : [test];
    return matchesPatterns(context, patterns, dirname);
  }

  function shouldIgnore(context, ignore, only, dirname) {
    if (ignore && matchesPatterns(context, ignore, dirname)) {
      var _context$filename;

      var message = "No config is applied to \"" + ((_context$filename = context.filename) != null ? _context$filename : "(unknown)") + "\" because it matches one of `ignore: " + JSON.stringify(ignore) + "` from \"" + dirname + "\"";
      debug(message);

      if (context.showConfig) {
        console.log(message);
      }

      return true;
    }

    if (only && !matchesPatterns(context, only, dirname)) {
      var _context$filename2;

      var _message = "No config is applied to \"" + ((_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)") + "\" because it fails to match one of `only: " + JSON.stringify(only) + "` from \"" + dirname + "\"";

      debug(_message);

      if (context.showConfig) {
        console.log(_message);
      }

      return true;
    }

    return false;
  }

  function matchesPatterns(context, patterns, dirname) {
    return patterns.some(function (pattern) {
      return matchPattern(pattern, dirname, context.filename, context);
    });
  }

  function matchPattern(pattern, dirname, pathToTest, context) {
    if (typeof pattern === "function") {
      return !!pattern(pathToTest, {
        dirname: dirname,
        envName: context.envName,
        caller: context.caller
      });
    }

    if (typeof pathToTest !== "string") {
      throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
    }

    if (typeof pattern === "string") {
      pattern = pathToPattern(pattern, dirname);
    }

    return pattern.test(pathToTest);
  }

  var VALIDATORS = {
    name: assertString,
    manipulateOptions: assertFunction$1,
    pre: assertFunction$1,
    post: assertFunction$1,
    inherits: assertFunction$1,
    visitor: assertVisitorMap,
    parserOverride: assertFunction$1,
    generatorOverride: assertFunction$1
  };

  function assertVisitorMap(loc, value) {
    var obj = assertObject(loc, value);

    if (obj) {
      Object.keys(obj).forEach(function (prop) {
        return assertVisitorHandler(prop, obj[prop]);
      });

      if (obj.enter || obj.exit) {
        throw new Error(msg(loc) + " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.");
      }
    }

    return obj;
  }

  function assertVisitorHandler(key, value) {
    if (value && typeof value === "object") {
      Object.keys(value).forEach(function (handler) {
        if (handler !== "enter" && handler !== "exit") {
          throw new Error(".visitor[\"" + key + "\"] may only have .enter and/or .exit handlers.");
        }
      });
    } else if (typeof value !== "function") {
      throw new Error(".visitor[\"" + key + "\"] must be a function");
    }

    return value;
  }

  function validatePluginObject(obj) {
    var rootPath = {
      type: "root",
      source: "plugin"
    };
    Object.keys(obj).forEach(function (key) {
      var validator = VALIDATORS[key];

      if (validator) {
        var optLoc = {
          type: "option",
          name: key,
          parent: rootPath
        };
        validator(optLoc, obj[key]);
      } else {
        var invalidPluginPropertyError = new Error("." + key + " is not a valid Plugin property");
        invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
        throw invalidPluginPropertyError;
      }
    });
    return obj;
  }

  function makeAPI(cache) {
    var env = function env(value) {
      return cache.using(function (data) {
        if (typeof value === "undefined") return data.envName;

        if (typeof value === "function") {
          return assertSimpleType(value(data.envName));
        }

        if (!Array.isArray(value)) value = [value];
        return value.some(function (entry) {
          if (typeof entry !== "string") {
            throw new Error("Unexpected non-string value");
          }

          return entry === data.envName;
        });
      });
    };

    var caller = function caller(cb) {
      return cache.using(function (data) {
        return assertSimpleType(cb(data.caller));
      });
    };

    return {
      version: version,
      cache: cache.simple(),
      env: env,
      async: function async() {
        return false;
      },
      caller: caller,
      assertVersion: assertVersion
    };
  }

  function assertVersion(range) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    if (semver.satisfies(version, range)) return;
    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version,
      range: range
    });
  }

  var _marked$3 = regenerator.mark(resolveRootMode),
      _marked2$3 = regenerator.mark(loadPrivatePartialConfig);

  function resolveRootMode(rootDir, rootMode) {
    var upwardRootDir, _upwardRootDir;

    return regenerator.wrap(function resolveRootMode$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = rootMode;
            _context.next = _context.t0 === "root" ? 3 : _context.t0 === "upward-optional" ? 4 : _context.t0 === "upward" ? 7 : 12;
            break;

          case 3:
            return _context.abrupt("return", rootDir);

          case 4:
            return _context.delegateYield(findConfigUpwards(), "t1", 5);

          case 5:
            upwardRootDir = _context.t1;
            return _context.abrupt("return", upwardRootDir === null ? rootDir : upwardRootDir);

          case 7:
            return _context.delegateYield(findConfigUpwards(), "t2", 8);

          case 8:
            _upwardRootDir = _context.t2;

            if (!(_upwardRootDir !== null)) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", _upwardRootDir);

          case 11:
            throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\".\n") + "One of the following config files must be in the directory tree: " + ("\"" + ROOT_CONFIG_FILENAMES.join(", ") + "\".")), {
              code: "BABEL_ROOT_NOT_FOUND",
              dirname: rootDir
            });

          case 12:
            throw new Error("Assertion failure - unknown rootMode value.");

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$3);
  }

  function loadPrivatePartialConfig(inputOpts) {
    var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, _args$cloneInputAst, cloneInputAst, absoluteCwd, absoluteRootDir, filename, showConfigPath, context, configChain, options;

    return regenerator.wrap(function loadPrivatePartialConfig$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts)))) {
              _context2.next = 2;
              break;
            }

            throw new Error("Babel options must be an object, null, or undefined");

          case 2:
            args = inputOpts ? validate$3("arguments", inputOpts) : {};
            _args$envName = args.envName, envName = _args$envName === void 0 ? getEnv() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller, _args$cloneInputAst = args.cloneInputAst, cloneInputAst = _args$cloneInputAst === void 0 ? true : _args$cloneInputAst;
            absoluteCwd = path__default['default'].resolve(cwd);
            return _context2.delegateYield(resolveRootMode(path__default['default'].resolve(absoluteCwd, rootDir), rootMode), "t0", 6);

          case 6:
            absoluteRootDir = _context2.t0;
            filename = typeof args.filename === "string" ? path__default['default'].resolve(cwd, args.filename) : undefined;
            return _context2.delegateYield(resolveShowConfigPath(), "t1", 9);

          case 9:
            showConfigPath = _context2.t1;
            context = {
              filename: filename,
              cwd: absoluteCwd,
              root: absoluteRootDir,
              envName: envName,
              caller: caller,
              showConfig: showConfigPath === filename
            };
            return _context2.delegateYield(buildRootChain(args, context), "t2", 12);

          case 12:
            configChain = _context2.t2;

            if (configChain) {
              _context2.next = 15;
              break;
            }

            return _context2.abrupt("return", null);

          case 15:
            options = {};
            configChain.options.forEach(function (opts) {
              mergeOptions(options, opts);
            });
            options.cloneInputAst = cloneInputAst;
            options.babelrc = false;
            options.configFile = false;
            options.passPerPreset = false;
            options.envName = context.envName;
            options.cwd = context.cwd;
            options.root = context.root;
            options.filename = typeof context.filename === "string" ? context.filename : undefined;
            options.plugins = configChain.plugins.map(function (descriptor) {
              return createItemFromDescriptor(descriptor);
            });
            options.presets = configChain.presets.map(function (descriptor) {
              return createItemFromDescriptor(descriptor);
            });
            return _context2.abrupt("return", {
              options: options,
              context: context,
              fileHandling: configChain.fileHandling,
              ignore: configChain.ignore,
              babelrc: configChain.babelrc,
              config: configChain.config,
              files: configChain.files
            });

          case 28:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$3);
  }
  var loadPartialConfig = gensync(regenerator.mark(function _callee(opts) {
    var showIgnoredFiles, _opts, result, options, babelrc, ignore, config, fileHandling, files;

    return regenerator.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            showIgnoredFiles = false;

            if (typeof opts === "object" && opts !== null && !Array.isArray(opts)) {
              _opts = opts;
              showIgnoredFiles = _opts.showIgnoredFiles;
              opts = _objectWithoutPropertiesLoose(_opts, ["showIgnoredFiles"]);
            }

            return _context3.delegateYield(loadPrivatePartialConfig(opts), "t0", 3);

          case 3:
            result = _context3.t0;

            if (result) {
              _context3.next = 6;
              break;
            }

            return _context3.abrupt("return", null);

          case 6:
            options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config, fileHandling = result.fileHandling, files = result.files;

            if (!(fileHandling === "ignored" && !showIgnoredFiles)) {
              _context3.next = 9;
              break;
            }

            return _context3.abrupt("return", null);

          case 9:
            (options.plugins || []).forEach(function (item) {
              if (item.value instanceof Plugin) {
                throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
              }
            });
            return _context3.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files));

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));

  var PartialConfig = function () {
    function PartialConfig(options, babelrc, ignore, config, fileHandling, files) {
      this.options = void 0;
      this.babelrc = void 0;
      this.babelignore = void 0;
      this.config = void 0;
      this.fileHandling = void 0;
      this.files = void 0;
      this.options = options;
      this.babelignore = ignore;
      this.babelrc = babelrc;
      this.config = config;
      this.fileHandling = fileHandling;
      this.files = files;
      Object.freeze(this);
    }

    var _proto = PartialConfig.prototype;

    _proto.hasFilesystemConfig = function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    };

    return PartialConfig;
  }();

  Object.freeze(PartialConfig.prototype);

  var _marked$4 = regenerator.mark(loadPluginDescriptor),
      _marked2$4 = regenerator.mark(loadPresetDescriptor);
  var loadConfig$1 = gensync(regenerator.mark(function loadFullConfig(inputOpts) {
    var result, options, context, fileHandling, optionDefaults, plugins, presets, toDescriptor, presetsDescriptors, initialPluginsDescriptors, pluginDescriptorsByPass, passes, ignored, opts;
    return regenerator.wrap(function loadFullConfig$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

          case 1:
            result = _context3.t0;

            if (result) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return", null);

          case 4:
            options = result.options, context = result.context, fileHandling = result.fileHandling;

            if (!(fileHandling === "ignored")) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", null);

          case 7:
            optionDefaults = {};
            plugins = options.plugins, presets = options.presets;

            if (!(!plugins || !presets)) {
              _context3.next = 11;
              break;
            }

            throw new Error("Assertion failure - plugins and presets exist");

          case 11:
            toDescriptor = function toDescriptor(item) {
              var desc = getItemDescriptor(item);

              if (!desc) {
                throw new Error("Assertion failure - must be config item");
              }

              return desc;
            };

            presetsDescriptors = presets.map(toDescriptor);
            initialPluginsDescriptors = plugins.map(toDescriptor);
            pluginDescriptorsByPass = [[]];
            passes = [];
            return _context3.delegateYield(enhanceError(context, regenerator.mark(function recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
              var presets, i, descriptor, _iterator, _step, _step$value, preset, pass, _ignored;

              return regenerator.wrap(function recursePresetDescriptors$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      presets = [];
                      i = 0;

                    case 2:
                      if (!(i < rawPresets.length)) {
                        _context.next = 30;
                        break;
                      }

                      descriptor = rawPresets[i];

                      if (!(descriptor.options !== false)) {
                        _context.next = 27;
                        break;
                      }

                      _context.prev = 5;

                      if (!descriptor.ownPass) {
                        _context.next = 15;
                        break;
                      }

                      _context.t0 = presets;
                      return _context.delegateYield(loadPresetDescriptor(descriptor, context), "t1", 9);

                    case 9:
                      _context.t2 = _context.t1;
                      _context.t3 = [];
                      _context.t4 = {
                        preset: _context.t2,
                        pass: _context.t3
                      };

                      _context.t0.push.call(_context.t0, _context.t4);

                      _context.next = 21;
                      break;

                    case 15:
                      _context.t5 = presets;
                      return _context.delegateYield(loadPresetDescriptor(descriptor, context), "t6", 17);

                    case 17:
                      _context.t7 = _context.t6;
                      _context.t8 = pluginDescriptorsPass;
                      _context.t9 = {
                        preset: _context.t7,
                        pass: _context.t8
                      };

                      _context.t5.unshift.call(_context.t5, _context.t9);

                    case 21:
                      _context.next = 27;
                      break;

                    case 23:
                      _context.prev = 23;
                      _context.t10 = _context["catch"](5);

                      if (_context.t10.code === "BABEL_UNKNOWN_OPTION") {
                        checkNoUnwrappedItemOptionPairs(rawPresets, i, "preset", _context.t10);
                      }

                      throw _context.t10;

                    case 27:
                      i++;
                      _context.next = 2;
                      break;

                    case 30:
                      if (!(presets.length > 0)) {
                        _context.next = 45;
                        break;
                      }

                      pluginDescriptorsByPass.splice.apply(pluginDescriptorsByPass, [1, 0].concat(presets.map(function (o) {
                        return o.pass;
                      }).filter(function (p) {
                        return p !== pluginDescriptorsPass;
                      })));
                      _iterator = _createForOfIteratorHelperLoose(presets);

                    case 33:
                      if ((_step = _iterator()).done) {
                        _context.next = 45;
                        break;
                      }

                      _step$value = _step.value, preset = _step$value.preset, pass = _step$value.pass;

                      if (preset) {
                        _context.next = 37;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 37:
                      pass.push.apply(pass, preset.plugins);
                      return _context.delegateYield(recursePresetDescriptors(preset.presets, pass), "t11", 39);

                    case 39:
                      _ignored = _context.t11;

                      if (!_ignored) {
                        _context.next = 42;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 42:
                      preset.options.forEach(function (opts) {
                        mergeOptions(optionDefaults, opts);
                      });

                    case 43:
                      _context.next = 33;
                      break;

                    case 45:
                    case "end":
                      return _context.stop();
                  }
                }
              }, recursePresetDescriptors, null, [[5, 23]]);
            }))(presetsDescriptors, pluginDescriptorsByPass[0]), "t1", 17);

          case 17:
            ignored = _context3.t1;

            if (!ignored) {
              _context3.next = 20;
              break;
            }

            return _context3.abrupt("return", null);

          case 20:
            opts = optionDefaults;
            mergeOptions(opts, options);
            return _context3.delegateYield(enhanceError(context, regenerator.mark(function loadPluginDescriptors() {
              var _pluginDescriptorsByP;

              var _iterator2, _step2, descs, pass, i, descriptor;

              return regenerator.wrap(function loadPluginDescriptors$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      (_pluginDescriptorsByP = pluginDescriptorsByPass[0]).unshift.apply(_pluginDescriptorsByP, initialPluginsDescriptors);

                      _iterator2 = _createForOfIteratorHelperLoose(pluginDescriptorsByPass);

                    case 2:
                      if ((_step2 = _iterator2()).done) {
                        _context2.next = 26;
                        break;
                      }

                      descs = _step2.value;
                      pass = [];
                      passes.push(pass);
                      i = 0;

                    case 7:
                      if (!(i < descs.length)) {
                        _context2.next = 24;
                        break;
                      }

                      descriptor = descs[i];

                      if (!(descriptor.options !== false)) {
                        _context2.next = 21;
                        break;
                      }

                      _context2.prev = 10;
                      _context2.t0 = pass;
                      return _context2.delegateYield(loadPluginDescriptor(descriptor, context), "t1", 13);

                    case 13:
                      _context2.t2 = _context2.t1;

                      _context2.t0.push.call(_context2.t0, _context2.t2);

                      _context2.next = 21;
                      break;

                    case 17:
                      _context2.prev = 17;
                      _context2.t3 = _context2["catch"](10);

                      if (_context2.t3.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                        checkNoUnwrappedItemOptionPairs(descs, i, "plugin", _context2.t3);
                      }

                      throw _context2.t3;

                    case 21:
                      i++;
                      _context2.next = 7;
                      break;

                    case 24:
                      _context2.next = 2;
                      break;

                    case 26:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, loadPluginDescriptors, null, [[10, 17]]);
            }))(), "t2", 23);

          case 23:
            opts.plugins = passes[0];
            opts.presets = passes.slice(1).filter(function (plugins) {
              return plugins.length > 0;
            }).map(function (plugins) {
              return {
                plugins: plugins
              };
            });
            opts.passPerPreset = opts.presets.length > 0;
            return _context3.abrupt("return", {
              options: opts,
              passes: passes
            });

          case 27:
          case "end":
            return _context3.stop();
        }
      }
    }, loadFullConfig);
  }));

  function enhanceError(context, fn) {
    return regenerator.mark(function _callee(arg1, arg2) {
      return regenerator.wrap(function _callee$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              return _context4.delegateYield(fn(arg1, arg2), "t0", 2);

            case 2:
              return _context4.abrupt("return", _context4.t0);

            case 5:
              _context4.prev = 5;
              _context4.t1 = _context4["catch"](0);

              if (!/^\[BABEL\]/.test(_context4.t1.message)) {
                _context4.t1.message = "[BABEL] " + (context.filename || "unknown") + ": " + _context4.t1.message;
              }

              throw _context4.t1;

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee, null, [[0, 5]]);
    });
  }

  var loadDescriptor = makeWeakCache(regenerator.mark(function _callee2(_ref, cache) {
    var value, options, dirname, alias, item, api;
    return regenerator.wrap(function _callee2$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            value = _ref.value, options = _ref.options, dirname = _ref.dirname, alias = _ref.alias;

            if (!(options === false)) {
              _context5.next = 3;
              break;
            }

            throw new Error("Assertion failure");

          case 3:
            options = options || {};
            item = value;

            if (!(typeof value === "function")) {
              _context5.next = 15;
              break;
            }

            api = Object.assign({}, context, makeAPI(cache));
            _context5.prev = 7;
            item = value(api, options, dirname);
            _context5.next = 15;
            break;

          case 11:
            _context5.prev = 11;
            _context5.t0 = _context5["catch"](7);

            if (alias) {
              _context5.t0.message += " (While processing: " + JSON.stringify(alias) + ")";
            }

            throw _context5.t0;

          case 15:
            if (!(!item || typeof item !== "object")) {
              _context5.next = 17;
              break;
            }

            throw new Error("Plugin/Preset did not return an object.");

          case 17:
            if (!(typeof item.then === "function")) {
              _context5.next = 20;
              break;
            }

            return _context5.delegateYield([], "t1", 19);

          case 19:
            throw new Error("You appear to be using an async plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");

          case 20:
            return _context5.abrupt("return", {
              value: item,
              options: options,
              dirname: dirname,
              alias: alias
            });

          case 21:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee2, null, [[7, 11]]);
  }));

  function loadPluginDescriptor(descriptor, context) {
    return regenerator.wrap(function loadPluginDescriptor$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(descriptor.value instanceof Plugin)) {
              _context6.next = 4;
              break;
            }

            if (!descriptor.options) {
              _context6.next = 3;
              break;
            }

            throw new Error("Passed options to an existing Plugin instance will not work.");

          case 3:
            return _context6.abrupt("return", descriptor.value);

          case 4:
            _context6.t0 = instantiatePlugin;
            return _context6.delegateYield(loadDescriptor(descriptor, context), "t1", 6);

          case 6:
            _context6.t2 = _context6.t1;
            _context6.t3 = context;
            return _context6.delegateYield((0, _context6.t0)(_context6.t2, _context6.t3), "t4", 9);

          case 9:
            return _context6.abrupt("return", _context6.t4);

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked$4);
  }

  var instantiatePlugin = makeWeakCache(regenerator.mark(function _callee3(_ref2, cache) {
    var value, options, dirname, alias, pluginObj, plugin, inheritsDescriptor, inherits;
    return regenerator.wrap(function _callee3$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            value = _ref2.value, options = _ref2.options, dirname = _ref2.dirname, alias = _ref2.alias;
            pluginObj = validatePluginObject(value);
            plugin = Object.assign({}, pluginObj);

            if (plugin.visitor) {
              plugin.visitor = traverse$1.explode(Object.assign({}, plugin.visitor));
            }

            if (!plugin.inherits) {
              _context7.next = 12;
              break;
            }

            inheritsDescriptor = {
              name: undefined,
              alias: alias + "$inherits",
              value: plugin.inherits,
              options: options,
              dirname: dirname
            };
            return _context7.delegateYield(forwardAsync(loadPluginDescriptor, function (run) {
              return cache.invalidate(function (data) {
                return run(inheritsDescriptor, data);
              });
            }), "t0", 7);

          case 7:
            inherits = _context7.t0;
            plugin.pre = chain$1(inherits.pre, plugin.pre);
            plugin.post = chain$1(inherits.post, plugin.post);
            plugin.manipulateOptions = chain$1(inherits.manipulateOptions, plugin.manipulateOptions);
            plugin.visitor = traverse$1.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);

          case 12:
            return _context7.abrupt("return", new Plugin(plugin, options, alias));

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee3);
  }));

  var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
    if (options.test || options.include || options.exclude) {
      var formattedPresetName = descriptor.name ? "\"" + descriptor.name + "\"" : "/* your preset */";
      throw new Error(["Preset " + formattedPresetName + " requires a filename to be set when babel is called directly,", "```", "babel.transform(code, { filename: 'file.ts', presets: [" + formattedPresetName + "] });", "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
    }
  };

  var validatePreset = function validatePreset(preset, context, descriptor) {
    if (!context.filename) {
      var options = preset.options;
      validateIfOptionNeedsFilename(options, descriptor);

      if (options.overrides) {
        options.overrides.forEach(function (overrideOptions) {
          return validateIfOptionNeedsFilename(overrideOptions, descriptor);
        });
      }
    }
  };

  function loadPresetDescriptor(descriptor, context) {
    var preset;
    return regenerator.wrap(function loadPresetDescriptor$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.t0 = instantiatePreset;
            return _context8.delegateYield(loadDescriptor(descriptor, context), "t1", 2);

          case 2:
            _context8.t2 = _context8.t1;
            preset = (0, _context8.t0)(_context8.t2);
            validatePreset(preset, context, descriptor);
            return _context8.delegateYield(buildPresetChain(preset, context), "t3", 6);

          case 6:
            return _context8.abrupt("return", _context8.t3);

          case 7:
          case "end":
            return _context8.stop();
        }
      }
    }, _marked2$4);
  }

  var instantiatePreset = makeWeakCacheSync(function (_ref3) {
    var value = _ref3.value,
        dirname = _ref3.dirname,
        alias = _ref3.alias;
    return {
      options: validate$3("preset", value),
      alias: alias,
      dirname: dirname
    };
  });

  function chain$1(a, b) {
    var fns = [a, b].filter(Boolean);
    if (fns.length <= 1) return fns[0];
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
        var fn = _step3.value;
        fn.apply(this, args);
      }
    };
  }

  var loadOptionsRunner = gensync(regenerator.mark(function _callee(opts) {
    var _config$options;

    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;
            return _context.abrupt("return", (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  var maybeErrback = function maybeErrback(runner) {
    return function (opts, callback) {
      if (callback === undefined && typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      return callback ? runner.errback(opts, callback) : runner.sync(opts);
    };
  };

  var loadPartialConfig$1 = maybeErrback(loadPartialConfig);
  var loadPartialConfigSync = loadPartialConfig.sync;
  var loadPartialConfigAsync = loadPartialConfig.async;
  var loadOptions = maybeErrback(loadOptionsRunner);
  var loadOptionsSync = loadOptionsRunner.sync;
  var loadOptionsAsync = loadOptionsRunner.async;

  var PluginPass = function () {
    function PluginPass(file, key, options) {
      this._map = new Map();
      this.key = void 0;
      this.file = void 0;
      this.opts = void 0;
      this.cwd = void 0;
      this.filename = void 0;
      this.key = key;
      this.file = file;
      this.opts = options || {};
      this.cwd = file.opts.cwd;
      this.filename = file.opts.filename;
    }

    var _proto = PluginPass.prototype;

    _proto.set = function set(key, val) {
      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      return this.file.availableHelper(name, versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      return this.file.addHelper(name);
    };

    _proto.addImport = function addImport() {
      return this.file.addImport();
    };

    _proto.getModuleName = function getModuleName() {
      return this.file.getModuleName();
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
      return this.file.buildCodeFrameError(node, msg, Error);
    };

    return PluginPass;
  }();

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = typeof value;

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;

  var FUNC_ERROR_TEXT = 'Expected a function';

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  }

  memoize.Cache = _MapCache;
  var memoize_1 = memoize;

  var MAX_MEMOIZE_SIZE = 500;

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  var _stringToPath = stringToPath;

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  var INFINITY$2 = 1 / 0;

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }

  var _toKey = toKey;

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;

  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;

  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  }

  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;

  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;

  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }

    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);

    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      }

      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  var boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      mapTag$5 = '[object Map]',
      numberTag$3 = '[object Number]',
      regexpTag$4 = '[object RegExp]',
      setTag$5 = '[object Set]',
      stringTag$3 = '[object String]',
      symbolTag$3 = '[object Symbol]';
  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]';
  var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$4:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$3:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        return eq_1(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$4:
      case stringTag$3:
        return object == other + '';

      case mapTag$5:
        var convert = _mapToArray;

      case setTag$5:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }

        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1;
        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;

  var COMPARE_PARTIAL_FLAG$2 = 1;
  var objectProto$e = Object.prototype;
  var hasOwnProperty$c = objectProto$e.hasOwnProperty;

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$c.call(other, key))) {
        return false;
      }
    }

    var objStacked = stack.get(object);
    var othStacked = stack.get(other);

    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }

      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  var COMPARE_PARTIAL_FLAG$3 = 1;
  var argsTag$3 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      objectTag$4 = '[object Object]';
  var objectProto$f = Object.prototype;
  var hasOwnProperty$d = objectProto$f.hasOwnProperty;

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$2 : _getTag(object),
        othTag = othIsArr ? arrayTag$2 : _getTag(other);
    objTag = objTag == argsTag$3 ? objectTag$4 : objTag;
    othTag = othTag == argsTag$3 ? objectTag$4 : othTag;
    var objIsObj = objTag == objectTag$4,
        othIsObj = othTag == objectTag$4,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$d.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$d.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  var _baseIsMatch = baseIsMatch;

  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, _isStrictComparable(value)];
    }

    return result;
  }

  var _getMatchData = getMatchData;

  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  function baseMatches(source) {
    var matchData = _getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  function get$2(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get$2;

  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get_1(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  function basePropertyDeep(path) {
    return function (object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  function baseIteratee(value) {
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity_1;
    }

    if (typeof value == 'object') {
      return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
    }

    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  var baseFor = _createBaseFor();
  var _baseFor = baseFor;

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  var baseEach = _createBaseEach(_baseForOwn);
  var _baseEach = baseEach;

  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike_1(collection) ? Array(collection.length) : [];
    _baseEach(collection, function (value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  var _baseMap = baseMap;

  function baseSortBy(array, comparer) {
    var length = array.length;
    array.sort(comparer);

    while (length--) {
      array[length] = array[length].value;
    }

    return array;
  }

  var _baseSortBy = baseSortBy;

  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol_1(value);
      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol_1(other);

      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }

      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }

    return 0;
  }

  var _compareAscending = compareAscending;

  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = _compareAscending(objCriteria[index], othCriteria[index]);

      if (result) {
        if (index >= ordersLength) {
          return result;
        }

        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }

    return object.index - other.index;
  }

  var _compareMultiple = compareMultiple;

  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = _arrayMap(iteratees, function (iteratee) {
        if (isArray_1(iteratee)) {
          return function (value) {
            return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }

        return iteratee;
      });
    } else {
      iteratees = [identity_1];
    }

    var index = -1;
    iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));
    var result = _baseMap(collection, function (value, key, collection) {
      var criteria = _arrayMap(iteratees, function (iteratee) {
        return iteratee(value);
      });
      return {
        'criteria': criteria,
        'index': ++index,
        'value': value
      };
    });
    return _baseSortBy(result, function (object, other) {
      return _compareMultiple(object, other, orders);
    });
  }

  var _baseOrderBy = baseOrderBy;

  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;

  var nativeMax$1 = Math.max;

  function overRest(func, start, transform) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;

  var baseSetToString = !_defineProperty$1 ? identity_1 : function (func, string) {
    return _defineProperty$1(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;

  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  var nativeNow = Date.now;

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  var setToString = _shortOut(_baseSetToString);
  var _setToString = setToString;

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  var sortBy = _baseRest(function (collection, iteratees) {
    if (collection == null) {
      return [];
    }

    var length = iteratees.length;

    if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }

    return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
  });
  var sortBy_1 = sortBy;

  var LOADED_PLUGIN;
  function loadBlockHoistPlugin() {
    if (!LOADED_PLUGIN) {
      var config = loadConfig$1.sync({
        babelrc: false,
        configFile: false,
        plugins: [blockHoistPlugin]
      });
      LOADED_PLUGIN = config ? config.passes[0][0] : undefined;
      if (!LOADED_PLUGIN) throw new Error("Assertion failure");
    }

    return LOADED_PLUGIN;
  }
  var blockHoistPlugin = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit: function exit(_ref) {
          var node = _ref.node;
          var hasChange = false;

          for (var i = 0; i < node.body.length; i++) {
            var bodyNode = node.body[i];

            if ((bodyNode == null ? void 0 : bodyNode._blockHoist) != null) {
              hasChange = true;
              break;
            }
          }

          if (!hasChange) return;
          node.body = sortBy_1(node.body, function (bodyNode) {
            var priority = bodyNode == null ? void 0 : bodyNode._blockHoist;
            if (priority == null) priority = 1;
            if (priority === true) priority = 2;
            return -1 * priority;
          });
        }
      }
    }
  };

  function normalizeOptions$2(config) {
    var _config$options = config.options,
        filename = _config$options.filename,
        cwd = _config$options.cwd,
        _config$options$filen = _config$options.filenameRelative,
        filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? path__default['default'].relative(cwd, filename) : "unknown" : _config$options$filen,
        _config$options$sourc = _config$options.sourceType,
        sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
        inputSourceMap = _config$options.inputSourceMap,
        _config$options$sourc2 = _config$options.sourceMaps,
        sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
        moduleRoot = _config$options.moduleRoot,
        _config$options$sourc3 = _config$options.sourceRoot,
        sourceRoot = _config$options$sourc3 === void 0 ? moduleRoot : _config$options$sourc3,
        _config$options$sourc4 = _config$options.sourceFileName,
        sourceFileName = _config$options$sourc4 === void 0 ? path__default['default'].basename(filenameRelative) : _config$options$sourc4,
        _config$options$comme = _config$options.comments,
        comments = _config$options$comme === void 0 ? true : _config$options$comme,
        _config$options$compa = _config$options.compact,
        compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
    var opts = config.options;
    var options = Object.assign({}, opts, {
      parserOpts: Object.assign({
        sourceType: path__default['default'].extname(filenameRelative) === ".mjs" ? "module" : sourceType,
        sourceFileName: filename,
        plugins: []
      }, opts.parserOpts),
      generatorOpts: Object.assign({
        filename: filename,
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        retainLines: opts.retainLines,
        comments: comments,
        shouldPrintComment: opts.shouldPrintComment,
        compact: compact,
        minified: opts.minified,
        sourceMaps: sourceMaps,
        sourceRoot: sourceRoot,
        sourceFileName: sourceFileName
      }, opts.generatorOpts)
    });

    for (var _iterator = _createForOfIteratorHelperLoose(config.passes), _step; !(_step = _iterator()).done;) {
      var plugins = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
        var plugin = _step2.value;

        if (plugin.manipulateOptions) {
          plugin.manipulateOptions(options, options.parserOpts);
        }
      }
    }

    return options;
  }

  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_SYMBOLS_FLAG$2 = 4;

  function cloneDeep$1(value) {
    return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
  }

  var cloneDeep_1 = cloneDeep$1;

  var safeBuffer = createCommonjsModule(function (module, exports) {
  var Buffer = buffer__default['default'].Buffer;

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer__default['default'];
  } else {
    copyProps(buffer__default['default'], exports);
    exports.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }

  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }

    return buffer__default['default'].SlowBuffer(size);
  };
  });

  var convertSourceMap = createCommonjsModule(function (module, exports) {







  Object.defineProperty(exports, 'commentRegex', {
    get: function getCommentRegex() {
      return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
    }
  });
  Object.defineProperty(exports, 'mapFileCommentRegex', {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
    }
  });

  function decodeBase64(base64) {
    return safeBuffer.Buffer.from(base64, 'base64').toString();
  }

  function stripComment(sm) {
    return sm.split(',').pop();
  }

  function readFromFileMap(sm, dir) {
    var r = exports.mapFileCommentRegex.exec(sm);
    var filename = r[1] || r[2];
    var filepath = path__default['default'].resolve(dir, filename);

    try {
      return fs__default['default'].readFileSync(filepath, 'utf8');
    } catch (e) {
      throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
    }
  }

  function Converter(sm, opts) {
    opts = opts || {};
    if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
    if (opts.hasComment) sm = stripComment(sm);
    if (opts.isEncoded) sm = decodeBase64(sm);
    if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
    this.sourcemap = sm;
  }

  Converter.prototype.toJSON = function (space) {
    return JSON.stringify(this.sourcemap, null, space);
  };

  Converter.prototype.toBase64 = function () {
    var json = this.toJSON();
    return safeBuffer.Buffer.from(json, 'utf8').toString('base64');
  };

  Converter.prototype.toComment = function (options) {
    var base64 = this.toBase64();
    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
  };

  Converter.prototype.toObject = function () {
    return JSON.parse(this.toJSON());
  };

  Converter.prototype.addProperty = function (key, value) {
    if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key, value);
  };

  Converter.prototype.setProperty = function (key, value) {
    this.sourcemap[key] = value;
    return this;
  };

  Converter.prototype.getProperty = function (key) {
    return this.sourcemap[key];
  };

  exports.fromObject = function (obj) {
    return new Converter(obj);
  };

  exports.fromJSON = function (json) {
    return new Converter(json, {
      isJSON: true
    });
  };

  exports.fromBase64 = function (base64) {
    return new Converter(base64, {
      isEncoded: true
    });
  };

  exports.fromComment = function (comment) {
    comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
    return new Converter(comment, {
      isEncoded: true,
      hasComment: true
    });
  };

  exports.fromMapFileComment = function (comment, dir) {
    return new Converter(comment, {
      commentFileDir: dir,
      isFileComment: true,
      isJSON: true
    });
  };

  exports.fromSource = function (content) {
    var m = content.match(exports.commentRegex);
    return m ? exports.fromComment(m.pop()) : null;
  };

  exports.fromMapFileSource = function (content, dir) {
    var m = content.match(exports.mapFileCommentRegex);
    return m ? exports.fromMapFileComment(m.pop(), dir) : null;
  };

  exports.removeComments = function (src) {
    return src.replace(exports.commentRegex, '');
  };

  exports.removeMapFileComments = function (src) {
    return src.replace(exports.mapFileCommentRegex, '');
  };

  exports.generateMapFileComment = function (file, options) {
    var data = 'sourceMappingURL=' + file;
    return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
  };
  });

  var pluginNameMap = {
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://git.io/vb4SL"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://git.io/vb4SL"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-private-methods",
        url: "https://git.io/JvpRG"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://git.io/JTLB6"
      },
      transform: {
        name: "@babel/plugin-proposal-class-static-block",
        url: "https://git.io/JTLBP"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://git.io/JfKOH"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://git.io/vb4y9"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://git.io/vb4ST"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://git.io/vb4yh"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://git.io/vb4S3"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://git.io/vb4Sv"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://git.io/vb4SO"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://git.io/vb4yH"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://git.io/vb4Sf"
      },
      transform: {
        name: "@babel/plugin-proposal-export-namespace-from",
        url: "https://git.io/vb4SG"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://git.io/vb4yb"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://git.io/JfeDn"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://git.io/vb4y7"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://git.io/vb4St"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://git.io/vb4yN"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://git.io/vb4SZ"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://git.io/vbKK6"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://git.io/vb4yA"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://git.io/JfeDR"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://git.io/JUbkv"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://git.io/JTL8G"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://git.io/vb4Sq"
      },
      transform: {
        name: "@babel/plugin-proposal-numeric-separator",
        url: "https://git.io/vb4yS"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://git.io/vb4Sc"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-chaining",
        url: "https://git.io/vb4Sk"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://git.io/vb4yj"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://git.io/vb4SU"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://git.io/JfK3q"
      },
      transform: {
        name: "@babel/plugin-proposal-private-property-in-object",
        url: "https://git.io/JfK3O"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://git.io/JvKp3"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://git.io/vb4SJ"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://git.io/vb4yF"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://git.io/vb4SC"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://git.io/JfeDz"
      }
    },
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://git.io/vb4SY"
      },
      transform: {
        name: "@babel/plugin-proposal-async-generator-functions",
        url: "https://git.io/vb4yp"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://git.io/vAlBp"
      },
      transform: {
        name: "@babel/plugin-proposal-logical-assignment-operators",
        url: "https://git.io/vAlRe"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://git.io/vb4yx"
      },
      transform: {
        name: "@babel/plugin-proposal-nullish-coalescing-operator",
        url: "https://git.io/vb4Se"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://git.io/vb4y5"
      },
      transform: {
        name: "@babel/plugin-proposal-object-rest-spread",
        url: "https://git.io/vb4Ss"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://git.io/vb4Sn"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-catch-binding",
        url: "https://git.io/vb4SI"
      }
    }
  };
  pluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform;

  var getNameURLCombination = function getNameURLCombination(_ref) {
    var name = _ref.name,
        url = _ref.url;
    return name + " (" + url + ")";
  };

  function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
    var helpMessage = "Support for the experimental syntax '" + missingPluginName + "' isn't currently enabled " + ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") + codeFrame;
    var pluginInfo = pluginNameMap[missingPluginName];

    if (pluginInfo) {
      var syntaxPlugin = pluginInfo.syntax,
          transformPlugin = pluginInfo.transform;

      if (syntaxPlugin) {
        var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);

        if (transformPlugin) {
          var transformPluginInfo = getNameURLCombination(transformPlugin);
          var sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          helpMessage += "\n\nAdd " + transformPluginInfo + " to the '" + sectionType + "' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add " + syntaxPluginInfo + " to the 'plugins' section to enable parsing.";
        } else {
          helpMessage += "\n\nAdd " + syntaxPluginInfo + " to the 'plugins' section of your Babel config " + "to enable parsing.";
        }
      }
    }

    return helpMessage;
  }

  var _marked$5 = regenerator.mark(parser);
  function parser(pluginPasses, _ref, code) {
    var parserOpts, _ref$highlightCode, highlightCode, _ref$filename, filename, results, _iterator, _step, plugins, _iterator2, _step2, plugin, parserOverride, ast, loc, missingPlugin, codeFrame;

    return regenerator.wrap(function parser$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            parserOpts = _ref.parserOpts, _ref$highlightCode = _ref.highlightCode, highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode, _ref$filename = _ref.filename, filename = _ref$filename === void 0 ? "unknown" : _ref$filename;
            _context.prev = 1;
            results = [];

            for (_iterator = _createForOfIteratorHelperLoose(pluginPasses); !(_step = _iterator()).done;) {
              plugins = _step.value;

              for (_iterator2 = _createForOfIteratorHelperLoose(plugins); !(_step2 = _iterator2()).done;) {
                plugin = _step2.value;
                parserOverride = plugin.parserOverride;

                if (parserOverride) {
                  ast = parserOverride(code, parserOpts, parse$1);
                  if (ast !== undefined) results.push(ast);
                }
              }
            }

            if (!(results.length === 0)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", parse$1(code, parserOpts));

          case 8:
            if (!(results.length === 1)) {
              _context.next = 13;
              break;
            }

            return _context.delegateYield([], "t0", 10);

          case 10:
            if (!(typeof results[0].then === "function")) {
              _context.next = 12;
              break;
            }

            throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 12:
            return _context.abrupt("return", results[0]);

          case 13:
            throw new Error("More than one plugin attempted to override parsing.");

          case 16:
            _context.prev = 16;
            _context.t1 = _context["catch"](1);

            if (_context.t1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
              _context.t1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
            }

            loc = _context.t1.loc, missingPlugin = _context.t1.missingPlugin;

            if (loc) {
              codeFrame = codeFrameColumns(code, {
                start: {
                  line: loc.line,
                  column: loc.column + 1
                }
              }, {
                highlightCode: highlightCode
              });

              if (missingPlugin) {
                _context.t1.message = filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
              } else {
                _context.t1.message = filename + ": " + _context.t1.message + "\n\n" + codeFrame;
              }

              _context.t1.code = "BABEL_PARSE_ERROR";
            }

            throw _context.t1;

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$5, null, [[1, 16]]);
  }

  var _marked$6 = regenerator.mark(normalizeFile);
  var debug$1 = src("babel:transform:file");
  var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;
  function normalizeFile(pluginPasses, options, code, ast) {
    var cloneInputAst, inputMap, lastComment, _lastComment, match, inputMapContent;

    return regenerator.wrap(function normalizeFile$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            code = "" + (code || "");

            if (!ast) {
              _context.next = 12;
              break;
            }

            if (!(ast.type === "Program")) {
              _context.next = 6;
              break;
            }

            ast = file(ast, [], []);
            _context.next = 8;
            break;

          case 6:
            if (!(ast.type !== "File")) {
              _context.next = 8;
              break;
            }

            throw new Error("AST root must be a Program or File node");

          case 8:
            cloneInputAst = options.cloneInputAst;

            if (cloneInputAst) {
              ast = cloneDeep_1(ast);
            }

            _context.next = 14;
            break;

          case 12:
            return _context.delegateYield(parser(pluginPasses, options, code), "t0", 13);

          case 13:
            ast = _context.t0;

          case 14:
            inputMap = null;

            if (options.inputSourceMap !== false) {
              if (typeof options.inputSourceMap === "object") {
                inputMap = convertSourceMap.fromObject(options.inputSourceMap);
              }

              if (!inputMap) {
                lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

                if (lastComment) {
                  try {
                    inputMap = convertSourceMap.fromComment(lastComment);
                  } catch (err) {
                    debug$1("discarding unknown inline input sourcemap", err);
                  }
                }
              }

              if (!inputMap) {
                _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

                if (typeof options.filename === "string" && _lastComment) {
                  try {
                    match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                    inputMapContent = fs__default['default'].readFileSync(path__default['default'].resolve(path__default['default'].dirname(options.filename), match[1]));

                    if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                      debug$1("skip merging input map > 1 MB");
                    } else {
                      inputMap = convertSourceMap.fromJSON(inputMapContent);
                    }
                  } catch (err) {
                    debug$1("discarding unknown file input sourcemap", err);
                  }
                } else if (_lastComment) {
                  debug$1("discarding un-loadable file input sourcemap");
                }
              }
            }

            return _context.abrupt("return", new File$1(options, {
              code: code,
              ast: ast,
              inputMap: inputMap
            }));

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$6);
  }
  var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
  var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

  function extractCommentsFromList(regex, comments, lastComment) {
    if (comments) {
      comments = comments.filter(function (_ref) {
        var value = _ref.value;

        if (regex.test(value)) {
          lastComment = value;
          return false;
        }

        return true;
      });
    }

    return [comments, lastComment];
  }

  function extractComments(regex, ast) {
    var lastComment = null;
    traverseFast(ast, function (node) {
      var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

      node.leadingComments = _extractCommentsFromL[0];
      lastComment = _extractCommentsFromL[1];

      var _extractCommentsFromL2 = extractCommentsFromList(regex, node.innerComments, lastComment);

      node.innerComments = _extractCommentsFromL2[0];
      lastComment = _extractCommentsFromL2[1];

      var _extractCommentsFromL3 = extractCommentsFromList(regex, node.trailingComments, lastComment);

      node.trailingComments = _extractCommentsFromL3[0];
      lastComment = _extractCommentsFromL3[1];
    });
    return lastComment;
  }

  function mergeSourceMap(inputMap, map) {
    var input = buildMappingData(inputMap);
    var output = buildMappingData(map);
    var mergedGenerator = new sourceMap.SourceMapGenerator();

    for (var _iterator = _createForOfIteratorHelperLoose(input.sources), _step; !(_step = _iterator()).done;) {
      var source = _step.value.source;

      if (typeof source.content === "string") {
        mergedGenerator.setSourceContent(source.path, source.content);
      }
    }

    if (output.sources.length === 1) {
      var defaultSource = output.sources[0];
      var insertedMappings = new Map();
      eachInputGeneratedRange(input, function (generated, original, source) {
        eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
          var key = makeMappingKey(item);
          if (insertedMappings.has(key)) return;
          insertedMappings.set(key, item);
          mergedGenerator.addMapping({
            source: source.path,
            original: {
              line: original.line,
              column: original.columnStart
            },
            generated: {
              line: item.line,
              column: item.columnStart
            },
            name: original.name
          });
        });
      });

      for (var _iterator2 = _createForOfIteratorHelperLoose(insertedMappings.values()), _step2; !(_step2 = _iterator2()).done;) {
        var item = _step2.value;

        if (item.columnEnd === Infinity) {
          continue;
        }

        var clearItem = {
          line: item.line,
          columnStart: item.columnEnd
        };
        var key = makeMappingKey(clearItem);

        if (insertedMappings.has(key)) {
          continue;
        }

        mergedGenerator.addMapping({
          generated: {
            line: clearItem.line,
            column: clearItem.columnStart
          }
        });
      }
    }

    var result = mergedGenerator.toJSON();

    if (typeof input.sourceRoot === "string") {
      result.sourceRoot = input.sourceRoot;
    }

    return result;
  }

  function makeMappingKey(item) {
    return item.line + "/" + item.columnStart;
  }

  function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
    var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);

    for (var _iterator3 = _createForOfIteratorHelperLoose(overlappingOriginal), _step3; !(_step3 = _iterator3()).done;) {
      var generated = _step3.value.generated;

      for (var _iterator4 = _createForOfIteratorHelperLoose(generated), _step4; !(_step4 = _iterator4()).done;) {
        var item = _step4.value;
        callback(item);
      }
    }
  }

  function filterApplicableOriginalRanges(_ref, _ref2) {
    var mappings = _ref.mappings;
    var line = _ref2.line,
        columnStart = _ref2.columnStart,
        columnEnd = _ref2.columnEnd;
    return filterSortedArray(mappings, function (_ref3) {
      var outOriginal = _ref3.original;
      if (line > outOriginal.line) return -1;
      if (line < outOriginal.line) return 1;
      if (columnStart >= outOriginal.columnEnd) return -1;
      if (columnEnd <= outOriginal.columnStart) return 1;
      return 0;
    });
  }

  function eachInputGeneratedRange(map, callback) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(map.sources), _step5; !(_step5 = _iterator5()).done;) {
      var _step5$value = _step5.value,
          source = _step5$value.source,
          mappings = _step5$value.mappings;

      for (var _iterator6 = _createForOfIteratorHelperLoose(mappings), _step6; !(_step6 = _iterator6()).done;) {
        var _step6$value = _step6.value,
            original = _step6$value.original,
            generated = _step6$value.generated;

        for (var _iterator7 = _createForOfIteratorHelperLoose(generated), _step7; !(_step7 = _iterator7()).done;) {
          var item = _step7.value;
          callback(item, original, source);
        }
      }
    }
  }

  function buildMappingData(map) {
    var consumer = new sourceMap.SourceMapConsumer(Object.assign({}, map, {
      sourceRoot: null
    }));
    var sources = new Map();
    var mappings = new Map();
    var last = null;
    consumer.computeColumnSpans();
    consumer.eachMapping(function (m) {
      if (m.originalLine === null) return;
      var source = sources.get(m.source);

      if (!source) {
        source = {
          path: m.source,
          content: consumer.sourceContentFor(m.source, true)
        };
        sources.set(m.source, source);
      }

      var sourceData = mappings.get(source);

      if (!sourceData) {
        sourceData = {
          source: source,
          mappings: []
        };
        mappings.set(source, sourceData);
      }

      var obj = {
        line: m.originalLine,
        columnStart: m.originalColumn,
        columnEnd: Infinity,
        name: m.name
      };

      if (last && last.source === source && last.mapping.line === m.originalLine) {
        last.mapping.columnEnd = m.originalColumn;
      }

      last = {
        source: source,
        mapping: obj
      };
      sourceData.mappings.push({
        original: obj,
        generated: consumer.allGeneratedPositionsFor({
          source: m.source,
          line: m.originalLine,
          column: m.originalColumn
        }).map(function (item) {
          return {
            line: item.line,
            columnStart: item.column,
            columnEnd: item.lastColumn + 1
          };
        })
      });
    }, null, sourceMap.SourceMapConsumer.ORIGINAL_ORDER);
    return {
      file: map.file,
      sourceRoot: map.sourceRoot,
      sources: Array.from(mappings.values())
    };
  }

  function findInsertionLocation(array, callback) {
    var left = 0;
    var right = array.length;

    while (left < right) {
      var mid = Math.floor((left + right) / 2);
      var item = array[mid];
      var result = callback(item);

      if (result === 0) {
        left = mid;
        break;
      }

      if (result >= 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var i = left;

    if (i < array.length) {
      while (i >= 0 && callback(array[i]) >= 0) {
        i--;
      }

      return i + 1;
    }

    return i;
  }

  function filterSortedArray(array, callback) {
    var start = findInsertionLocation(array, callback);
    var results = [];

    for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
      results.push(array[i]);
    }

    return results;
  }

  function generateCode$1(pluginPasses, file) {
    var opts = file.opts,
        ast = file.ast,
        code = file.code,
        inputMap = file.inputMap;
    var results = [];

    for (var _iterator = _createForOfIteratorHelperLoose(pluginPasses), _step; !(_step = _iterator()).done;) {
      var plugins = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
        var plugin = _step2.value;
        var generatorOverride = plugin.generatorOverride;

        if (generatorOverride) {
          var _result2 = generatorOverride(ast, opts.generatorOpts, code, generateCode);

          if (_result2 !== undefined) results.push(_result2);
        }
      }
    }

    var result;

    if (results.length === 0) {
      result = generateCode(ast, opts.generatorOpts, code);
    } else if (results.length === 1) {
      result = results[0];

      if (typeof result.then === "function") {
        throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
      }
    } else {
      throw new Error("More than one plugin attempted to override codegen.");
    }

    var _result = result,
        outputCode = _result.code,
        outputMap = _result.map;

    if (outputMap && inputMap) {
      outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
    }

    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
      outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
    }

    if (opts.sourceMaps === "inline") {
      outputMap = null;
    }

    return {
      outputCode: outputCode,
      outputMap: outputMap
    };
  }

  var _marked$7 = regenerator.mark(run),
      _marked2$5 = regenerator.mark(transformFile);
  function run(config, code, ast) {
    var file, opts, _opts$filename, outputCode, outputMap, _generateCode, _opts$filename2;

    return regenerator.wrap(function run$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(normalizeFile(config.passes, normalizeOptions$2(config), code, ast), "t0", 1);

          case 1:
            file = _context.t0;
            opts = file.opts;
            _context.prev = 3;
            return _context.delegateYield(transformFile(file, config.passes), "t1", 5);

          case 5:
            _context.next = 12;
            break;

          case 7:
            _context.prev = 7;
            _context.t2 = _context["catch"](3);
            _context.t2.message = ((_opts$filename = opts.filename) != null ? _opts$filename : "unknown") + ": " + _context.t2.message;

            if (!_context.t2.code) {
              _context.t2.code = "BABEL_TRANSFORM_ERROR";
            }

            throw _context.t2;

          case 12:
            _context.prev = 12;

            if (opts.code !== false) {
              _generateCode = generateCode$1(config.passes, file);
              outputCode = _generateCode.outputCode;
              outputMap = _generateCode.outputMap;
            }

            _context.next = 21;
            break;

          case 16:
            _context.prev = 16;
            _context.t3 = _context["catch"](12);
            _context.t3.message = ((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown") + ": " + _context.t3.message;

            if (!_context.t3.code) {
              _context.t3.code = "BABEL_GENERATE_ERROR";
            }

            throw _context.t3;

          case 21:
            return _context.abrupt("return", {
              metadata: file.metadata,
              options: opts,
              ast: opts.ast === true ? file.ast : null,
              code: outputCode === undefined ? null : outputCode,
              map: outputMap === undefined ? null : outputMap,
              sourceType: file.ast.program.sourceType
            });

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$7, null, [[3, 7], [12, 16]]);
  }

  function transformFile(file, pluginPasses) {
    var _iterator, _step, pluginPairs, passPairs, passes, visitors, _iterator2, _step2, _plugin2, _pass2, _i, _passPairs, _passPairs$_i, plugin, pass, fn, result, visitor, _i2, _passPairs2, _passPairs2$_i, _plugin, _pass, _fn, _result;

    return regenerator.wrap(function transformFile$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator = _createForOfIteratorHelperLoose(pluginPasses);

          case 1:
            if ((_step = _iterator()).done) {
              _context2.next = 35;
              break;
            }

            pluginPairs = _step.value;
            passPairs = [];
            passes = [];
            visitors = [];

            for (_iterator2 = _createForOfIteratorHelperLoose(pluginPairs.concat([loadBlockHoistPlugin()])); !(_step2 = _iterator2()).done;) {
              _plugin2 = _step2.value;
              _pass2 = new PluginPass(file, _plugin2.key, _plugin2.options);
              passPairs.push([_plugin2, _pass2]);
              passes.push(_pass2);
              visitors.push(_plugin2.visitor);
            }

            _i = 0, _passPairs = passPairs;

          case 8:
            if (!(_i < _passPairs.length)) {
              _context2.next = 19;
              break;
            }

            _passPairs$_i = _passPairs[_i], plugin = _passPairs$_i[0], pass = _passPairs$_i[1];
            fn = plugin.pre;

            if (!fn) {
              _context2.next = 16;
              break;
            }

            result = fn.call(pass, file);
            return _context2.delegateYield([], "t0", 14);

          case 14:
            if (!isThenable$1(result)) {
              _context2.next = 16;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 16:
            _i++;
            _context2.next = 8;
            break;

          case 19:
            visitor = traverse$1.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
            traverse$1(file.ast, visitor, file.scope);
            _i2 = 0, _passPairs2 = passPairs;

          case 22:
            if (!(_i2 < _passPairs2.length)) {
              _context2.next = 33;
              break;
            }

            _passPairs2$_i = _passPairs2[_i2], _plugin = _passPairs2$_i[0], _pass = _passPairs2$_i[1];
            _fn = _plugin.post;

            if (!_fn) {
              _context2.next = 30;
              break;
            }

            _result = _fn.call(_pass, file);
            return _context2.delegateYield([], "t1", 28);

          case 28:
            if (!isThenable$1(_result)) {
              _context2.next = 30;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 30:
            _i2++;
            _context2.next = 22;
            break;

          case 33:
            _context2.next = 1;
            break;

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$5);
  }

  function isThenable$1(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  var transformRunner = gensync(regenerator.mark(function transform(code, opts) {
    var config;
    return regenerator.wrap(function transform$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(run(config, code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, transform);
  }));
  var transform = function transform(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return transformRunner.sync(code, opts);
    transformRunner.errback(code, opts, callback);
  };
  var transformSync = transformRunner.sync;
  var transformAsync = transformRunner.async;

  var transformFile$1 = function transformFile(filename, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
    }

    callback(new Error("Transforming files is not supported in browsers"), null);
  };
  function transformFileSync() {
    throw new Error("Transforming files is not supported in browsers");
  }
  function transformFileAsync() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }

  var transformFromAstRunner = gensync(regenerator.mark(function _callee(ast, code, opts) {
    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            if (ast) {
              _context.next = 6;
              break;
            }

            throw new Error("No AST given");

          case 6:
            return _context.delegateYield(run(config, code, ast), "t1", 7);

          case 7:
            return _context.abrupt("return", _context.t1);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var transformFromAst = function transformFromAst(ast, code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) {
      return transformFromAstRunner.sync(ast, code, opts);
    }

    transformFromAstRunner.errback(ast, code, opts, callback);
  };
  var transformFromAstSync = transformFromAstRunner.sync;
  var transformFromAstAsync = transformFromAstRunner.async;

  var parseRunner = gensync(regenerator.mark(function parse(code, opts) {
    var config;
    return regenerator.wrap(function parse$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig$1(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(parser(config.passes, normalizeOptions$2(config), code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, parse);
  }));
  var parse$2 = function parse(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return parseRunner.sync(code, opts);
    parseRunner.errback(code, opts, callback);
  };
  var parseSync = parseRunner.sync;
  var parseAsync = parseRunner.async;

  var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs"]);
  var OptionManager = function () {
    function OptionManager() {}

    var _proto = OptionManager.prototype;

    _proto.init = function init(opts) {
      return loadOptions(opts);
    };

    return OptionManager;
  }();
  function Plugin$1(alias) {
    throw new Error("The (" + alias + ") Babel 5 plugin is being run with an unsupported Babel version.");
  }

  function declare(builder) {
    return function (api, options, dirname) {
      if (!api.assertVersion) {
        api = Object.assign(copyApiObject(api), {
          assertVersion: function assertVersion(range) {
            throwVersionError(range, api.version);
          }
        });
      }

      return builder(api, options || {}, dirname);
    };
  }

  function copyApiObject(api) {
    var proto = null;

    if (typeof api.version === "string" && /^7\./.test(api.version)) {
      proto = Object.getPrototypeOf(api);

      if (proto && (!has$4(proto, "version") || !has$4(proto, "transform") || !has$4(proto, "template") || !has$4(proto, "types"))) {
        proto = null;
      }
    }

    return Object.assign({}, proto, api);
  }

  function has$4(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function throwVersionError(range, version) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err;

    if (version.slice(0, 2) === "7.") {
      err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"" + version + "\". " + "You'll need to update your @babel/core version.");
    } else {
      err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
    }

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version,
      range: range
    });
  }

  var src$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    declare: declare
  });

  var externalHelpers = declare(function (api, options) {
    api.assertVersion(7);
    var _options$helperVersio = options.helperVersion,
        helperVersion = _options$helperVersio === void 0 ? "7.0.0-beta.0" : _options$helperVersio,
        _options$whitelist = options.whitelist,
        whitelist = _options$whitelist === void 0 ? false : _options$whitelist;

    if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(function (w) {
      return typeof w !== "string";
    }))) {
      throw new Error(".whitelist must be undefined, false, or an array of strings");
    }

    var helperWhitelist = whitelist ? new Set(whitelist) : null;
    return {
      name: "external-helpers",
      pre: function pre(file) {
        file.set("helperGenerator", function (name) {
          if (file.availableHelper && !file.availableHelper(name, helperVersion)) {
            return;
          }

          if (helperWhitelist && !helperWhitelist.has(name)) return;
          return memberExpression(identifier("babelHelpers"), identifier(name));
        });
      }
    };
  });

  var _helperPluginUtils = getCjsExportFromNamespace(src$1);

  var lib = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators = /*@__PURE__*/unwrapExports(lib);

  var syntaxClassProperties = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-class-properties",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
      }
    };
  });

  var syntaxClassStaticBlock = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-class-static-block",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classStaticBlock");
      }
    };
  });

  var syntaxDecimal = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-decimal",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("decimal");
      }
    };
  });

  var syntaxDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a" + " 'decoratorsBeforeExport' option, whose value must be a boolean." + " If you want to use the legacy decorators semantics, you can set" + " the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    return {
      name: "syntax-decorators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
      }
    };
  });

  var syntaxDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-do-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("doExpressions");
      }
    };
  });

  var syntaxExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-default-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportDefaultFrom");
      }
    };
  });

  var syntaxFlow = declare(function (api, options) {
    api.assertVersion(7);
    var all = options.all,
        enums = options.enums;

    if (typeof all !== "boolean" && typeof all !== "undefined") {
      throw new Error(".all must be a boolean, or undefined");
    }

    if (typeof enums !== "boolean" && typeof enums !== "undefined") {
      throw new Error(".enums must be a boolean, or undefined");
    }

    return {
      name: "syntax-flow",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push(["flow", {
          all: all,
          enums: enums
        }]);
      }
    };
  });

  var syntaxFunctionBind = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-bind",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionBind");
      }
    };
  });

  var syntaxFunctionSent = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-sent",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionSent");
      }
    };
  });

  var lib$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-import-meta",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("importMeta");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxImportMeta = /*@__PURE__*/unwrapExports(lib$1);

  var syntaxJsx = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-jsx",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push("jsx");
      }
    };
  });

  var syntaxImportAssertions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-import-assertions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(["importAssertions"]);
      }
    };
  });

  var lib$2 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread = /*@__PURE__*/unwrapExports(lib$2);

  var lib$3 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding = /*@__PURE__*/unwrapExports(lib$3);

  var proposals = ["minimal", "smart", "fsharp"];
  var syntaxPipelineOperator = declare(function (api, _ref) {
    var proposal = _ref.proposal;
    api.assertVersion(7);

    if (typeof proposal !== "string" || !proposals.includes(proposal)) {
      throw new Error("The pipeline operator plugin requires a 'proposal' option." + "'proposal' must be one of: " + proposals.join(", ") + ". More details: https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator");
    }

    return {
      name: "syntax-pipeline-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(["pipelineOperator", {
          proposal: proposal
        }]);
      }
    };
  });

  var syntaxRecordAndTuple = declare(function (api, options) {
    api.assertVersion(7);
    return {
      name: "syntax-record-and-tuple",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        opts.generatorOpts.recordAndTupleSyntaxType = options.syntaxType;
        parserOpts.plugins.push(["recordAndTuple", {
          syntaxType: options.syntaxType
        }]);
      }
    };
  });

  var syntaxTopLevelAwait = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-top-level-await",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("topLevelAwait");
      }
    };
  });

  function removePlugin(plugins, name) {
    var indices = [];
    plugins.forEach(function (plugin, i) {
      var n = Array.isArray(plugin) ? plugin[0] : plugin;

      if (n === name) {
        indices.unshift(i);
      }
    });

    for (var _i = 0, _indices = indices; _i < _indices.length; _i++) {
      var i = _indices[_i];
      plugins.splice(i, 1);
    }
  }

  var syntaxTypescript = declare(function (api, _ref) {
    var isTSX = _ref.isTSX;
    api.assertVersion(7);
    return {
      name: "syntax-typescript",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        var plugins = parserOpts.plugins;
        removePlugin(plugins, "flow");
        removePlugin(plugins, "jsx");
        parserOpts.plugins.push("typescript", "classProperties");

        if (!process.env.BABEL_8_BREAKING) {
          parserOpts.plugins.push("objectRestSpread");
        }

        if (isTSX) {
          parserOpts.plugins.push("jsx");
        }
      }
    };
  });

  var buildAnonymousExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");
  var buildNamedExpressionWrapper = template.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");
  var buildDeclarationWrapper = template("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

  function classOrObjectMethod(path, callId) {
    var node = path.node;
    var body = node.body;
    var container = functionExpression(null, [], blockStatement(body.body), true);
    body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
  }

  function plainFunction(path, callId) {
    var node = path.node;
    var isDeclaration = path.isFunctionDeclaration();
    var functionId = node.id;
    var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

    if (path.isArrowFunctionExpression()) {
      path.arrowFunctionToExpression();
    }

    node.id = null;

    if (isDeclaration) {
      node.type = "FunctionExpression";
    }

    var built = callExpression(callId, [node]);
    var container = wrapper({
      NAME: functionId || null,
      REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
      FUNCTION: built,
      PARAMS: node.params.reduce(function (acc, param) {
        acc.done = acc.done || isAssignmentPattern(param) || isRestElement(param);

        if (!acc.done) {
          acc.params.push(path.scope.generateUidIdentifier("x"));
        }

        return acc;
      }, {
        params: [],
        done: false
      }).params
    });

    if (isDeclaration) {
      path.replaceWith(container[0]);
      path.insertAfter(container[1]);
    } else {
      var retFunction = container.callee.body.body[1].argument;

      if (!functionId) {
        nameFunction({
          node: retFunction,
          parent: path.parent,
          scope: path.scope
        });
      }

      if (!retFunction || retFunction.id || node.params.length) {
        path.replaceWith(container);
      } else {
        path.replaceWith(built);
      }
    }
  }

  function wrapFunction(path, callId) {
    if (path.isMethod()) {
      classOrObjectMethod(path, callId);
    } else {
      plainFunction(path, callId);
    }
  }

  var PURE_ANNOTATION = "#__PURE__";

  var isPureAnnotated = function isPureAnnotated(_ref) {
    var leadingComments = _ref.leadingComments;
    return !!leadingComments && leadingComments.some(function (comment) {
      return /[@#]__PURE__/.test(comment.value);
    });
  };

  function annotateAsPure(pathOrNode) {
    var node = pathOrNode["node"] || pathOrNode;

    if (isPureAnnotated(node)) {
      return;
    }

    addComment(node, "leading", PURE_ANNOTATION);
  }

  var awaitVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path, _ref) {
      var wrapAwait = _ref.wrapAwait;
      var argument = path.get("argument");

      if (path.parentPath.isYieldExpression()) {
        path.replaceWith(argument.node);
        return;
      }

      path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));
    }
  };
  function remapAsyncToGenerator (path, helpers) {
    path.traverse(awaitVisitor, {
      wrapAwait: helpers.wrapAwait
    });
    var isIIFE = checkIsIIFE(path);
    path.node.async = false;
    path.node.generator = true;
    wrapFunction(path, cloneNode(helpers.wrapAsync));
    var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

    if (!isProperty && !isIIFE && path.isExpression()) {
      annotateAsPure(path);
    }

    function checkIsIIFE(path) {
      if (path.parentPath.isCallExpression({
        callee: path.node
      })) {
        return true;
      }

      var parentPath = path.parentPath;

      if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
        name: "bind"
      })) {
        var bindCall = parentPath.parentPath;
        return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
          callee: bindCall.node
        });
      }

      return false;
    }
  }

  var lib$4 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators$1 = /*@__PURE__*/unwrapExports(lib$4);

  var buildForAwait = template("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
  function rewriteForAwait (path, _ref) {
    var getAsyncIterator = _ref.getAsyncIterator;
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var stepKey = scope.generateUidIdentifier("step");
    var stepValue = scope.generateUidIdentifier("value");
    var left = node.left;
    var declar;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = expressionStatement(assignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
    }

    var template = buildForAwait({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      GET_ITERATOR: getAsyncIterator,
      OBJECT: node.right,
      STEP_VALUE: cloneNode(stepValue),
      STEP_KEY: stepKey
    });
    template = template.body.body;
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      node: template,
      declar: declar,
      loop: loop
    };
  }

  var proposalAsyncGeneratorFunctions = declare(function (api) {
    api.assertVersion(7);
    var yieldStarVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(_ref, state) {
        var node = _ref.node;
        if (!node.delegate) return;
        var callee = state.addHelper("asyncGeneratorDelegate");
        node.argument = callExpression(callee, [callExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
      }
    };
    var forAwaitVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      ForOfStatement: function ForOfStatement(path, _ref2) {
        var file = _ref2.file;
        var node = path.node;
        if (!node["await"]) return;
        var build = rewriteForAwait(path, {
          getAsyncIterator: file.addHelper("asyncIterator")
        });
        var declar = build.declar,
            loop = build.loop;
        var block = loop.body;
        path.ensureBlock();

        if (declar) {
          block.body.push(declar);
        }

        block.body = block.body.concat(node.body.body);
        inherits(loop, node);
        inherits(loop.body, node.body);

        if (build.replaceParent) {
          path.parentPath.replaceWithMultiple(build.node);
        } else {
          path.replaceWithMultiple(build.node);
        }
      }
    };
    var visitor = {
      Function: function Function(path, state) {
        if (!path.node.async) return;
        path.traverse(forAwaitVisitor, state);
        if (!path.node.generator) return;
        path.traverse(yieldStarVisitor, state);
        remapAsyncToGenerator(path, {
          wrapAsync: state.addHelper("wrapAsyncGenerator"),
          wrapAwait: state.addHelper("awaitAsyncGenerator")
        });
      }
    };
    return {
      name: "proposal-async-generator-functions",
      inherits: syntaxAsyncGenerators$1,
      visitor: {
        Program: function Program(path, state) {
          path.traverse(visitor, state);
        }
      }
    };
  });

  function assertFieldTransformed(path) {
    if (path.node.declare) {
      throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-proposal-class-properties\n" + " - @babel/plugin-proposal-private-methods\n" + " - @babel/plugin-proposal-decorators");
    }
  }

  function _templateObject18$1() {
    var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "]);

    _templateObject18$1 = function _templateObject18() {
      return data;
    };

    return data;
  }

  function _templateObject17$1() {
    var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "]);

    _templateObject17$1 = function _templateObject17() {
      return data;
    };

    return data;
  }

  function _templateObject16$1() {
    var data = _taggedTemplateLiteralLoose(["", ".add(", ")"]);

    _templateObject16$1 = function _templateObject16() {
      return data;
    };

    return data;
  }

  function _templateObject15$1() {
    var data = _taggedTemplateLiteralLoose(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "]);

    _templateObject15$1 = function _templateObject15() {
      return data;
    };

    return data;
  }

  function _templateObject14$1() {
    var data = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "]);

    _templateObject14$1 = function _templateObject14() {
      return data;
    };

    return data;
  }

  function _templateObject13$2() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "]);

    _templateObject13$2 = function _templateObject13() {
      return data;
    };

    return data;
  }

  function _templateObject12$2() {
    var data = _taggedTemplateLiteralLoose(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "]);

    _templateObject12$2 = function _templateObject12() {
      return data;
    };

    return data;
  }

  function _templateObject11$2() {
    var data = _taggedTemplateLiteralLoose(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "]);

    _templateObject11$2 = function _templateObject11() {
      return data;
    };

    return data;
  }

  function _templateObject10$2() {
    var data = _taggedTemplateLiteralLoose(["", ".set(", ", {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ", ",\n  })"]);

    _templateObject10$2 = function _templateObject10() {
      return data;
    };

    return data;
  }

  function _templateObject9$2() {
    var data = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "]);

    _templateObject9$2 = function _templateObject9() {
      return data;
    };

    return data;
  }

  function _templateObject8$2() {
    var data = _taggedTemplateLiteralLoose(["BASE(REF, PROP)[PROP]"]);

    _templateObject8$2 = function _templateObject8() {
      return data;
    };

    return data;
  }

  function _templateObject7$2() {
    var data = _taggedTemplateLiteralLoose(["", ".has(", ")"]);

    _templateObject7$2 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6$2() {
    var data = _taggedTemplateLiteralLoose(["", " === ", ""]);

    _templateObject6$2 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5$2() {
    var data = _taggedTemplateLiteralLoose(["\n        Object.prototype.hasOwnProperty.call(", ", ", ")\n      "]);

    _templateObject5$2 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

    _templateObject4$2 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakSet();"]);

    _templateObject3$2 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$2() {
    var data = _taggedTemplateLiteralLoose(["var ", " = new WeakMap();"]);

    _templateObject2$2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$4() {
    var data = _taggedTemplateLiteralLoose(["\n          var ", " = ", "(\"", "\")\n        "]);

    _templateObject$4 = function _templateObject() {
      return data;
    };

    return data;
  }
  function buildPrivateNamesMap(props) {
    var privateNamesMap = new Map();

    for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
      var prop = _step.value;
      var isPrivate = prop.isPrivate();
      var isMethod = !prop.isProperty();
      var isInstance = !prop.node["static"];

      if (isPrivate) {
        var name = prop.node.key.id.name;
        var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          "static": !isInstance,
          method: isMethod
        };

        if (prop.node.kind === "get") {
          update.getId = prop.scope.generateUidIdentifier("get_" + name);
        } else if (prop.node.kind === "set") {
          update.setId = prop.scope.generateUidIdentifier("set_" + name);
        } else if (prop.node.kind === "method") {
          update.methodId = prop.scope.generateUidIdentifier(name);
        }

        privateNamesMap.set(name, update);
      }
    }

    return privateNamesMap;
  }
  function buildPrivateNamesNodes(privateNamesMap, loose, state) {
    var initNodes = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(privateNamesMap), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          name = _step2$value[0],
          value = _step2$value[1];
      var isStatic = value["static"],
          isMethod = value.method,
          getId = value.getId,
          setId = value.setId;
      var isAccessor = getId || setId;
      var id = cloneNode(value.id);

      if (loose) {
        initNodes.push(template.statement.ast(_templateObject$4(), id, state.addHelper("classPrivateFieldLooseKey"), name));
      } else if (isMethod && !isStatic) {
        if (isAccessor) {
          initNodes.push(template.statement.ast(_templateObject2$2(), id));
        } else {
          initNodes.push(template.statement.ast(_templateObject3$2(), id));
        }
      } else if (!isStatic) {
        initNodes.push(template.statement.ast(_templateObject4$2(), id));
      }
    }

    return initNodes;
  }

  function privateNameVisitorFactory(visitor) {
    var privateNameVisitor = Object.assign({}, visitor, {
      Class: function Class(path) {
        var privateNamesMap = this.privateNamesMap;
        var body = path.get("body.body");
        var visiblePrivateNames = new Map(privateNamesMap);
        var redeclared = [];

        for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
          var prop = _step3.value;
          if (!prop.isPrivate()) continue;
          var name = prop.node.key.id.name;
          visiblePrivateNames["delete"](name);
          redeclared.push(name);
        }

        if (!redeclared.length) {
          return;
        }

        path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
          redeclared: redeclared
        }));
        path.traverse(privateNameVisitor, Object.assign({}, this, {
          privateNamesMap: visiblePrivateNames
        }));
        path.skipKey("body");
      }
    });
    var nestedVisitor = traverse$1.visitors.merge([Object.assign({}, visitor), environmentVisitor]);
    return privateNameVisitor;
  }

  var privateNameVisitor = privateNameVisitorFactory({
    PrivateName: function PrivateName(path) {
      var privateNamesMap = this.privateNamesMap,
          redeclared = this.redeclared;
      var node = path.node,
          parentPath = path.parentPath;

      if (!parentPath.isMemberExpression({
        property: node
      }) && !parentPath.isOptionalMemberExpression({
        property: node
      })) {
        return;
      }

      var name = node.id.name;
      if (!privateNamesMap.has(name)) return;
      if (redeclared && redeclared.includes(name)) return;
      this.handle(parentPath);
    }
  });
  var privateInVisitor = privateNameVisitorFactory({
    BinaryExpression: function BinaryExpression(path) {
      var _path$node = path.node,
          operator = _path$node.operator,
          left = _path$node.left,
          right = _path$node.right;
      if (operator !== "in") return;
      if (!path.get("left").isPrivateName()) return;
      var loose = this.loose,
          privateNamesMap = this.privateNamesMap,
          redeclared = this.redeclared;
      var name = left.id.name;
      if (!privateNamesMap.has(name)) return;
      if (redeclared && redeclared.includes(name)) return;

      if (loose) {
        var _privateNamesMap$get = privateNamesMap.get(name),
            _id = _privateNamesMap$get.id;

        path.replaceWith(template.expression.ast(_templateObject5$2(), right, cloneNode(_id)));
        return;
      }

      var _privateNamesMap$get2 = privateNamesMap.get(name),
          id = _privateNamesMap$get2.id,
          isStatic = _privateNamesMap$get2["static"];

      if (isStatic) {
        path.replaceWith(template.expression.ast(_templateObject6$2(), right, this.classRef));
        return;
      }

      path.replaceWith(template.expression.ast(_templateObject7$2(), cloneNode(id), right));
    }
  });
  var privateNameHandlerSpec = {
    memoise: function memoise(member, count) {
      var scope = member.scope;
      var object = member.node.object;
      var memo = scope.maybeGenerateMemoised(object);

      if (!memo) {
        return;
      }

      this.memoiser.set(object, memo, count);
    },
    receiver: function receiver(member) {
      var object = member.node.object;

      if (this.memoiser.has(object)) {
        return cloneNode(this.memoiser.get(object));
      }

      return cloneNode(object);
    },
    get: function get(member) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get3 = privateNamesMap.get(name),
          id = _privateNamesMap$get3.id,
          isStatic = _privateNamesMap$get3["static"],
          isMethod = _privateNamesMap$get3.method,
          methodId = _privateNamesMap$get3.methodId,
          getId = _privateNamesMap$get3.getId,
          setId = _privateNamesMap$get3.setId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        return callExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id)]);
      }

      if (isMethod) {
        if (isAccessor) {
          return callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
        }

        return callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), cloneNode(id), cloneNode(methodId)]);
      }

      return callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
    },
    boundGet: function boundGet(member) {
      this.memoise(member, 1);
      return callExpression(memberExpression(this.get(member), identifier("bind")), [this.receiver(member)]);
    },
    set: function set(member, value) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get4 = privateNamesMap.get(name),
          id = _privateNamesMap$get4.id,
          isStatic = _privateNamesMap$get4["static"],
          isMethod = _privateNamesMap$get4.method,
          setId = _privateNamesMap$get4.setId,
          getId = _privateNamesMap$get4.getId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return callExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id), value]);
      }

      if (isMethod) {
        if (setId) {
          return callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
        }

        return callExpression(file.addHelper("classPrivateMethodSet"), []);
      }

      return callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
    },
    destructureSet: function destructureSet(member) {
      var privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get5 = privateNamesMap.get(name),
          id = _privateNamesMap$get5.id;

      return memberExpression(callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneNode(id)]), identifier("value"));
    },
    call: function call(member, args) {
      this.memoise(member, 1);
      return optimiseCallExpression(this.get(member), this.receiver(member), args, false);
    },
    optionalCall: function optionalCall(member, args) {
      this.memoise(member, 1);
      return optimiseCallExpression(this.get(member), this.receiver(member), args, true);
    }
  };
  var privateNameHandlerLoose = {
    get: function get(member) {
      var privateNamesMap = this.privateNamesMap,
          file = this.file;
      var object = member.node.object;
      var name = member.node.property.id.name;
      return template.expression(_templateObject8$2())({
        BASE: file.addHelper("classPrivateFieldLooseBase"),
        REF: cloneNode(object),
        PROP: cloneNode(privateNamesMap.get(name).id)
      });
    },
    boundGet: function boundGet(member) {
      return callExpression(memberExpression(this.get(member), identifier("bind")), [cloneNode(member.node.object)]);
    },
    simpleSet: function simpleSet(member) {
      return this.get(member);
    },
    destructureSet: function destructureSet(member) {
      return this.get(member);
    },
    call: function call(member, args) {
      return callExpression(this.get(member), args);
    },
    optionalCall: function optionalCall(member, args) {
      return optionalCallExpression(this.get(member), args, true);
    }
  };
  function transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state) {
    if (!privateNamesMap.size) return;
    var body = path.get("body");
    var handler = loose ? privateNameHandlerLoose : privateNameHandlerSpec;
    memberExpressionToFunctions(body, privateNameVisitor, Object.assign({
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state
    }, handler));
    body.traverse(privateInVisitor, {
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state,
      loose: loose
    });
  }

  function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
    var _privateNamesMap$get6 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get6.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject9$2(), ref, cloneNode(id), value);
  }

  function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {
    var _privateNamesMap$get7 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get7.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject10$2(), cloneNode(id), ref, value);
  }

  function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    var isAccessor = getId || setId;
    if (!prop.isProperty() && (initAdded || !isAccessor)) return;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject11$2(), cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template.statement.ast(_templateObject12$2(), cloneNode(id), value);
  }

  function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var methodId = privateName.methodId,
        id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;

    if (methodId) {
      return template.statement.ast(_templateObject13$2(), ref, id, methodId.name);
    }

    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject14$1(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }
  }

  function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject15$1(), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template.statement.ast(_templateObject16$1(), id, ref);
  }

  function buildPublicFieldInitLoose(ref, prop) {
    var _prop$node = prop.node,
        key = _prop$node.key,
        computed = _prop$node.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return expressionStatement(assignmentExpression("=", memberExpression(ref, key, computed || isLiteral(key)), value));
  }

  function buildPublicFieldInitSpec(ref, prop, state) {
    var _prop$node2 = prop.node,
        key = _prop$node2.key,
        computed = _prop$node2.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return expressionStatement(callExpression(state.addHelper("defineProperty"), [ref, computed || isLiteral(key) ? key : stringLiteral(key.name), value]));
  }

  function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template.statement.ast(_templateObject17$1(), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template.statement.ast(_templateObject18$1(), ref, id, methodId.name);
  }

  function buildPrivateMethodDeclaration(prop, privateNamesMap, loose) {
    if (loose === void 0) {
      loose = false;
    }

    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        getterDeclared = privateName.getterDeclared,
        setterDeclared = privateName.setterDeclared,
        isStatic = privateName["static"];
    var _prop$node3 = prop.node,
        params = _prop$node3.params,
        body = _prop$node3.body,
        generator = _prop$node3.generator,
        async = _prop$node3.async;
    var methodValue = functionExpression(methodId, params, body, generator, async);
    var isGetter = getId && !getterDeclared && params.length === 0;
    var isSetter = setId && !setterDeclared && params.length > 0;

    if (isGetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        getterDeclared: true
      }));
      return variableDeclaration("var", [variableDeclarator(getId, methodValue)]);
    }

    if (isSetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        setterDeclared: true
      }));
      return variableDeclaration("var", [variableDeclarator(setId, methodValue)]);
    }

    if (isStatic && !loose) {
      return variableDeclaration("var", [variableDeclarator(cloneNode(id), functionExpression(id, params, body, generator, async))]);
    }

    return variableDeclaration("var", [variableDeclarator(cloneNode(methodId), methodValue)]);
  }

  var thisContextVisitor = traverse$1.visitors.merge([{
    ThisExpression: function ThisExpression(path, state) {
      state.needsClassRef = true;
      path.replaceWith(cloneNode(state.classRef));
    }
  }, environmentVisitor]);

  function replaceThisContext(path, ref, superRef, file, loose) {
    var state = {
      classRef: ref,
      needsClassRef: false
    };
    var replacer = new ReplaceSupers({
      methodPath: path,
      isLoose: loose,
      superRef: superRef,
      file: file,
      refToPreserve: ref,
      getObjectRef: function getObjectRef() {
        state.needsClassRef = true;
        return path.node["static"] ? ref : memberExpression(ref, identifier("prototype"));
      }
    });
    replacer.replace();

    if (path.isProperty()) {
      path.traverse(thisContextVisitor, state);
    }

    return state.needsClassRef;
  }

  function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, loose) {
    var staticNodes = [];
    var instanceNodes = [];
    var needsClassRef = false;

    for (var _iterator4 = _createForOfIteratorHelperLoose(props), _step4; !(_step4 = _iterator4()).done;) {
      var prop = _step4.value;
      assertFieldTransformed(prop);
      var isStatic = prop.node["static"];
      var isInstance = !isStatic;
      var isPrivate = prop.isPrivate();
      var isPublic = !isPrivate;
      var isField = prop.isProperty();
      var isMethod = !isField;

      if (isStatic || isMethod && isPrivate) {
        var replaced = replaceThisContext(prop, ref, superRef, state, loose);
        needsClassRef = needsClassRef || replaced;
      }

      switch (true) {
        case isStatic && isPrivate && isField && loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateFieldInitLoose(cloneNode(ref), prop, privateNamesMap));
          break;

        case isStatic && isPrivate && isField && !loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          break;

        case isStatic && isPublic && isField && loose:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitLoose(cloneNode(ref), prop));
          break;

        case isStatic && isPublic && isField && !loose:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitSpec(cloneNode(ref), prop, state));
          break;

        case isInstance && isPrivate && isField && loose:
          instanceNodes.push(buildPrivateFieldInitLoose(thisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isField && !loose:
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(thisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isMethod && loose:
          instanceNodes.unshift(buildPrivateMethodInitLoose(thisExpression(), prop, privateNamesMap));
          staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isInstance && isPrivate && isMethod && !loose:
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(thisExpression(), prop, privateNamesMap));
          staticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isStatic && isPrivate && isMethod && !loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isStatic && isPrivate && isMethod && loose:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticMethodInitLoose(cloneNode(ref), prop, state, privateNamesMap));
          staticNodes.unshift(buildPrivateMethodDeclaration(prop, privateNamesMap, loose));
          break;

        case isInstance && isPublic && isField && loose:
          instanceNodes.push(buildPublicFieldInitLoose(thisExpression(), prop));
          break;

        case isInstance && isPublic && isField && !loose:
          instanceNodes.push(buildPublicFieldInitSpec(thisExpression(), prop, state));
          break;

        default:
          throw new Error("Unreachable.");
      }
    }

    return {
      staticNodes: staticNodes.filter(Boolean),
      instanceNodes: instanceNodes.filter(Boolean),
      wrapClass: function wrapClass(path) {
        for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {
          var prop = _step5.value;
          prop.remove();
        }

        if (!needsClassRef) return path;

        if (path.isClassExpression()) {
          path.scope.push({
            id: ref
          });
          path.replaceWith(assignmentExpression("=", cloneNode(ref), path.node));
        } else if (!path.node.id) {
          path.node.id = ref;
        }

        return path;
      }
    };
  }

  function _templateObject4$3() {
    var data = _taggedTemplateLiteralLoose(["", "(this)"]);

    _templateObject4$3 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$3() {
    var data = _taggedTemplateLiteralLoose(["let ", " = ", ""]);

    _templateObject3$3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$3() {
    var data = _taggedTemplateLiteralLoose(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "]);

    _templateObject2$3 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$5() {
    var data = _taggedTemplateLiteralLoose(["return ", ""]);

    _templateObject$5 = function _templateObject() {
      return data;
    };

    return data;
  }
  function hasOwnDecorators(node) {
    return !!(node.decorators && node.decorators.length);
  }
  function hasDecorators(node) {
    return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
  }

  function prop(key, value) {
    if (!value) return null;
    return objectProperty(identifier(key), value);
  }

  function method(key, body) {
    return objectMethod("method", identifier(key), [], blockStatement(body));
  }

  function takeDecorators(node) {
    var result;

    if (node.decorators && node.decorators.length > 0) {
      result = arrayExpression(node.decorators.map(function (decorator) {
        return decorator.expression;
      }));
    }

    node.decorators = undefined;
    return result;
  }

  function getKey(node) {
    if (node.computed) {
      return node.key;
    } else if (isIdentifier(node.key)) {
      return stringLiteral(node.key.name);
    } else {
      return stringLiteral(String(node.key.value));
    }
  }

  function extractElementDescriptor(classRef, superRef, path) {
    var node = path.node,
        scope = path.scope;
    var isMethod = path.isClassMethod();

    if (path.isPrivate()) {
      throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
    }

    new ReplaceSupers({
      methodPath: path,
      methodNode: node,
      objectRef: classRef,
      isStatic: node["static"],
      superRef: superRef,
      scope: scope,
      file: this,
      refToPreserve: classRef
    }, true).replace();
    var properties = [prop("kind", stringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node["static"] && booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);

    if (isMethod) {
      var id = node.computed ? null : node.key;
      toExpression(node);
      properties.push(prop("value", nameFunction({
        node: node,
        id: id,
        scope: scope
      }) || node));
    } else if (node.value) {
      properties.push(method("value", template.statements.ast(_templateObject$5(), node.value)));
    } else {
      properties.push(prop("value", scope.buildUndefinedNode()));
    }

    path.remove();
    return objectExpression(properties);
  }

  function addDecorateHelper(file) {
    try {
      return file.addHelper("decorate");
    } catch (err) {
      if (err.code === "BABEL_HELPER_UNKNOWN") {
        err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
      }

      throw err;
    }
  }

  function buildDecoratedClass(ref, path, elements, file) {
    var node = path.node,
        scope = path.scope;
    var initializeId = scope.generateUidIdentifier("initialize");
    var isDeclaration = node.id && path.isDeclaration();
    var isStrict = path.isInStrictMode();
    var superClass = node.superClass;
    node.type = "ClassDeclaration";
    if (!node.id) node.id = cloneNode(ref);
    var superId;

    if (superClass) {
      superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
      node.superClass = superId;
    }

    var classDecorators = takeDecorators(node);
    var definitions = arrayExpression(elements.filter(function (element) {
      return !element.node["abstract"];
    }).map(extractElementDescriptor.bind(file, node.id, superId)));
    var replacement = template.expression.ast(_templateObject2$3(), addDecorateHelper(file), classDecorators || nullLiteral(), initializeId, superClass ? cloneNode(superId) : null, node, cloneNode(node.id), definitions, superClass);
    var classPathDesc = "arguments.1.body.body.0";

    if (!isStrict) {
      replacement.arguments[1].body.directives.push(directive(directiveLiteral("use strict")));
    }

    if (isDeclaration) {
      replacement = template.ast(_templateObject3$3(), ref, replacement);
      classPathDesc = "declarations.0.init." + classPathDesc;
    }

    return {
      instanceNodes: [template.statement.ast(_templateObject4$3(), cloneNode(initializeId))],
      wrapClass: function wrapClass(path) {
        path.replaceWith(replacement);
        return path.get(classPathDesc);
      }
    };
  }

  function _templateObject$6() {
    var data = _taggedTemplateLiteralLoose(["super(...args)"]);

    _templateObject$6 = function _templateObject() {
      return data;
    };

    return data;
  }
  var findBareSupers = traverse$1.visitors.merge([{
    Super: function Super(path) {
      var node = path.node,
          parentPath = path.parentPath;

      if (parentPath.isCallExpression({
        callee: node
      })) {
        this.push(parentPath);
      }
    }
  }, environmentVisitor]);
  var referenceVisitor$1 = {
    "TSTypeAnnotation|TypeAnnotation": function TSTypeAnnotationTypeAnnotation(path) {
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      if (this.scope.hasOwnBinding(path.node.name)) {
        this.scope.rename(path.node.name);
        path.skip();
      }
    }
  };

  function handleClassTDZ(path, state) {
    if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
      var classNameTDZError = state.file.addHelper("classNameTDZError");
      var throwNode = callExpression(classNameTDZError, [stringLiteral(path.node.name)]);
      path.replaceWith(sequenceExpression([throwNode, path.node]));
      path.skip();
    }
  }

  var classFieldDefinitionEvaluationTDZVisitor = {
    ReferencedIdentifier: handleClassTDZ
  };
  function injectInitialization(path, constructor, nodes, renamer) {
    if (!nodes.length) return;
    var isDerived = !!path.node.superClass;

    if (!constructor) {
      var newConstructor = classMethod("constructor", identifier("constructor"), [], blockStatement([]));

      if (isDerived) {
        newConstructor.params = [restElement(identifier("args"))];
        newConstructor.body.body.push(template.statement.ast(_templateObject$6()));
      }

      var _path$get$unshiftCont = path.get("body").unshiftContainer("body", newConstructor);

      constructor = _path$get$unshiftCont[0];
    }

    if (renamer) {
      renamer(referenceVisitor$1, {
        scope: constructor.scope
      });
    }

    if (isDerived) {
      var bareSupers = [];
      constructor.traverse(findBareSupers, bareSupers);
      var isFirst = true;

      for (var _i = 0, _bareSupers = bareSupers; _i < _bareSupers.length; _i++) {
        var bareSuper = _bareSupers[_i];

        if (isFirst) {
          bareSuper.insertAfter(nodes);
          isFirst = false;
        } else {
          bareSuper.insertAfter(nodes.map(function (n) {
            return cloneNode(n);
          }));
        }
      }
    } else {
      constructor.get("body").unshiftContainer("body", nodes);
    }
  }
  function extractComputedKeys(ref, path, computedPaths, file) {
    var declarations = [];
    var state = {
      classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
      file: file
    };

    for (var _iterator = _createForOfIteratorHelperLoose(computedPaths), _step; !(_step = _iterator()).done;) {
      var computedPath = _step.value;
      var computedKey = computedPath.get("key");

      if (computedKey.isReferencedIdentifier()) {
        handleClassTDZ(computedKey, state);
      } else {
        computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
      }

      var computedNode = computedPath.node;

      if (!computedKey.isConstantExpression()) {
        var ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
        path.scope.push({
          id: ident,
          kind: "let"
        });
        declarations.push(expressionStatement(assignmentExpression("=", cloneNode(ident), computedNode.key)));
        computedNode.key = cloneNode(ident);
      }
    }

    return declarations;
  }

  var FEATURES = Object.freeze({
    fields: 1 << 1,
    privateMethods: 1 << 2,
    decorators: 1 << 3,
    privateIn: 1 << 4
  });
  var featuresSameLoose = new Map([[FEATURES.fields, "@babel/plugin-proposal-class-properties"], [FEATURES.privateMethods, "@babel/plugin-proposal-private-methods"], [FEATURES.privateIn, "@babel/plugin-proposal-private-private-property-in-object"]]);
  var featuresKey = "@babel/plugin-class-features/featuresKey";
  var looseKey = "@babel/plugin-class-features/looseKey";
  var looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  function enableFeature(file, feature, loose) {
    if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {
      file.set(featuresKey, file.get(featuresKey) | feature);

      if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, true);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, false);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else {
        setLoose(file, feature, loose);
      }
    }

    var resolvedLoose;
    var higherPriorityPluginName;

    for (var _iterator = _createForOfIteratorHelperLoose(featuresSameLoose), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          _mask = _step$value[0],
          _name = _step$value[1];
      if (!hasFeature(file, _mask)) continue;

      var _loose = isLoose(file, _mask);

      if (canIgnoreLoose(file, _mask)) {
        continue;
      } else if (resolvedLoose === !_loose) {
        throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, " + "@babel/plugin-proposal-private-methods and " + "@babel/plugin-proposal-private-property-in-object (when they are enabled).");
      } else {
        resolvedLoose = _loose;
        higherPriorityPluginName = _name;
      }
    }

    if (resolvedLoose !== undefined) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(featuresSameLoose), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
            mask = _step2$value[0],
            name = _step2$value[1];

        if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {
          setLoose(file, mask, resolvedLoose);
          console.warn("Though the \"loose\" option was set to \"" + !resolvedLoose + "\" in your @babel/preset-env " + ("config, it will not be used for " + name + " since the \"loose\" mode option was set to ") + ("\"" + resolvedLoose + "\" for " + higherPriorityPluginName + ".\nThe \"loose\" option must be the ") + "same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods " + "and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can " + "silence this warning by explicitly adding\n" + ("\t[\"" + name + "\", { \"loose\": " + resolvedLoose + " }]\n") + "to the \"plugins\" section of your Babel config.");
        }
      }
    }
  }

  function hasFeature(file, feature) {
    return !!(file.get(featuresKey) & feature);
  }

  function isLoose(file, feature) {
    return !!(file.get(looseKey) & feature);
  }

  function setLoose(file, feature, loose) {
    if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);
    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
  }

  function canIgnoreLoose(file, feature) {
    return !!(file.get(looseLowPriorityKey) & feature);
  }

  function verifyUsedFeatures(path, file) {
    if (hasOwnDecorators(path.node)) {
      if (!hasFeature(file, FEATURES.decorators)) {
        throw path.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "legacy": true }], ' + 'make sure it comes *before* "@babel/plugin-proposal-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n' + '\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
      }

      if (path.isPrivate()) {
        throw path.buildCodeFrameError("Private " + (path.isClassMethod() ? "methods" : "fields") + " in decorated classes are not supported yet.");
      }
    }

    if (path.isPrivate() && path.isMethod()) {
      if (!hasFeature(file, FEATURES.privateMethods)) {
        throw path.buildCodeFrameError("Class private methods are not enabled.");
      }
    }

    if (path.isPrivateName() && path.parentPath.isBinaryExpression({
      operator: "in",
      left: path.node
    })) {
      if (!hasFeature(file, FEATURES.privateIn)) {
        throw path.buildCodeFrameError("Private property in checks are not enabled.");
      }
    }

    if (path.isProperty()) {
      if (!hasFeature(file, FEATURES.fields)) {
        throw path.buildCodeFrameError("Class fields are not enabled.");
      }
    }
  }

  var name = "@babel/helper-create-class-features-plugin";
  var version$1 = "7.12.1";
  var author = "The Babel Team (https://babel.dev/team)";
  var license = "MIT";
  var description = "Compile class public and private fields, private methods and decorators to ES6";
  var repository = {
  	type: "git",
  	url: "https://github.com/babel/babel.git",
  	directory: "packages/babel-helper-create-class-features-plugin"
  };
  var main = "lib/index.js";
  var publishConfig = {
  	access: "public"
  };
  var keywords$2 = [
  	"babel",
  	"babel-plugin"
  ];
  var dependencies = {
  	"@babel/helper-function-name": "workspace:^7.10.4",
  	"@babel/helper-member-expression-to-functions": "workspace:^7.12.1",
  	"@babel/helper-optimise-call-expression": "workspace:^7.10.4",
  	"@babel/helper-replace-supers": "workspace:^7.12.1",
  	"@babel/helper-split-export-declaration": "workspace:^7.10.4"
  };
  var peerDependencies = {
  	"@babel/core": "^7.0.0"
  };
  var devDependencies = {
  	"@babel/core": "workspace:*",
  	"@babel/helper-plugin-test-runner": "workspace:*"
  };
  var pkg = {
  	name: name,
  	version: version$1,
  	author: author,
  	license: license,
  	description: description,
  	repository: repository,
  	main: main,
  	publishConfig: publishConfig,
  	keywords: keywords$2,
  	dependencies: dependencies,
  	peerDependencies: peerDependencies,
  	devDependencies: devDependencies
  };

  var version$2 = pkg.version.split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey = "@babel/plugin-class-features/version";
  function createClassFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        loose = _ref.loose,
        manipulateOptions = _ref.manipulateOptions;
    return {
      name: name,
      manipulateOptions: manipulateOptions,
      pre: function pre() {
        enableFeature(this.file, feature, loose);

        if (!this.file.get(versionKey) || this.file.get(versionKey) < version$2) {
          this.file.set(versionKey, version$2);
        }
      },
      visitor: {
        Class: function Class(path, state) {
          if (this.file.get(versionKey) !== version$2) return;
          verifyUsedFeatures(path, this.file);
          var loose = isLoose(this.file, feature);
          var constructor;
          var isDecorated = hasOwnDecorators(path.node);
          var props = [];
          var elements = [];
          var computedPaths = [];
          var privateNames = new Set();
          var body = path.get("body");

          for (var _iterator = _createForOfIteratorHelperLoose(body.get("body")), _step; !(_step = _iterator()).done;) {
            var _path = _step.value;
            verifyUsedFeatures(_path, this.file);

            if (_path.node.computed) {
              computedPaths.push(_path);
            }

            if (_path.isPrivate()) {
              var _name = _path.node.key.id.name;
              var getName = "get " + _name;
              var setName = "set " + _name;

              if (_path.node.kind === "get") {
                if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(getName).add(_name);
              } else if (_path.node.kind === "set") {
                if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(setName).add(_name);
              } else {
                if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(_name);
              }
            }

            if (_path.isClassMethod({
              kind: "constructor"
            })) {
              constructor = _path;
            } else {
              elements.push(_path);

              if (_path.isProperty() || _path.isPrivate()) {
                props.push(_path);
              }
            }

            if (!isDecorated) isDecorated = hasOwnDecorators(_path.node);

            if (_path.isStaticBlock == null ? void 0 : _path.isStaticBlock()) {
              throw _path.buildCodeFrameError("Incorrect plugin order, `@babel/plugin-proposal-class-static-block` should be placed before class features plugins\n{\n  \"plugins\": [\n    \"@babel/plugin-proposal-class-static-block\",\n    \"@babel/plugin-proposal-private-property-in-object\",\n    \"@babel/plugin-proposal-private-methods\",\n    \"@babel/plugin-proposal-class-properties\",\n  ]\n}");
            }
          }

          if (!props.length && !isDecorated) return;
          var ref;

          if (path.isClassExpression() || !path.node.id) {
            nameFunction(path);
            ref = path.scope.generateUidIdentifier("class");
          } else {
            ref = cloneNode(path.node.id);
          }

          var privateNamesMap = buildPrivateNamesMap(props);
          var privateNamesNodes = buildPrivateNamesNodes(privateNamesMap, loose, state);
          transformPrivateNamesUsage(ref, path, privateNamesMap, loose, state);
          var keysNodes, staticNodes, instanceNodes, wrapClass;

          if (isDecorated) {
            staticNodes = keysNodes = [];

            var _buildDecoratedClass = buildDecoratedClass(ref, path, elements, this.file);

            instanceNodes = _buildDecoratedClass.instanceNodes;
            wrapClass = _buildDecoratedClass.wrapClass;
          } else {
            keysNodes = extractComputedKeys(ref, path, computedPaths, this.file);

            var _buildFieldsInitNodes = buildFieldsInitNodes(ref, path.node.superClass, props, privateNamesMap, state, loose);

            staticNodes = _buildFieldsInitNodes.staticNodes;
            instanceNodes = _buildFieldsInitNodes.instanceNodes;
            wrapClass = _buildFieldsInitNodes.wrapClass;
          }

          if (instanceNodes.length > 0) {
            injectInitialization(path, constructor, instanceNodes, function (referenceVisitor, state) {
              if (isDecorated) return;

              for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
                var prop = _step2.value;
                if (prop.node["static"]) continue;
                prop.traverse(referenceVisitor, state);
              }
            });
          }

          path = wrapClass(path);
          path.insertBefore([].concat(privateNamesNodes, keysNodes));
          path.insertAfter(staticNodes);
        },
        PrivateName: function PrivateName(path) {
          if (this.file.get(versionKey) !== version$2 || path.parentPath.isPrivate({
            key: path.node
          })) {
            return;
          }

          throw path.buildCodeFrameError("Unknown PrivateName \"" + path + "\"");
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (this.file.get(versionKey) !== version$2) return;
          var decl = path.get("declaration");

          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {
            if (decl.node.id) {
              splitExportDeclaration(path);
            } else {
              decl.node.type = "ClassExpression";
            }
          }
        }
      }
    };
  }

  var proposalClassProperties = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-class-properties",
      feature: FEATURES.fields,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classProperties", "classPrivateProperties");
      }
    });
  });

  function _templateObject$7() {
    var data = _taggedTemplateLiteralLoose(["(() => { ", " })()"]);

    _templateObject$7 = function _templateObject() {
      return data;
    };

    return data;
  }

  function generateUid(scope, denyList) {
    var name = "";
    var uid;
    var i = 1;

    do {
      uid = scope._generateUid(name, i);
      i++;
    } while (denyList.has(uid));

    return uid;
  }

  var proposalClassStaticBlock = declare(function (_ref) {
    var t = _ref.types,
        template = _ref.template,
        assertVersion = _ref.assertVersion;
    assertVersion("^7.12.0");
    return {
      name: "proposal-class-static-block",
      inherits: syntaxClassStaticBlock,
      visitor: {
        Class: function (_Class) {
          function Class(_x) {
            return _Class.apply(this, arguments);
          }

          Class.toString = function () {
            return _Class.toString();
          };

          return Class;
        }(function (path) {
          var scope = path.scope;
          var classBody = path.get("body");
          var privateNames = new Set();
          var staticBlockPath;

          for (var _iterator = _createForOfIteratorHelperLoose(classBody.get("body")), _step; !(_step = _iterator()).done;) {
            var _path = _step.value;

            if (_path.isPrivate()) {
              privateNames.add(_path.get("key.id").node.name);
            } else if (_path.isStaticBlock()) {
              staticBlockPath = _path;
            }
          }

          if (!staticBlockPath) {
            return;
          }

          var staticBlockRef = t.privateName(t.identifier(generateUid(scope, privateNames)));
          classBody.pushContainer("body", t.classPrivateProperty(staticBlockRef, template.expression.ast(_templateObject$7(), staticBlockPath.node.body), [], true));
          staticBlockPath.remove();
        })
      }
    };
  });

  var buildClassDecorator = template("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n");
  var buildClassPrototype = template("\n  CLASS_REF.prototype;\n");
  var buildGetDescriptor = template("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n");
  var buildGetObjectInitializer = template("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n");
  var WARNING_CALLS = new WeakSet();

  function applyEnsureOrdering(path) {
    var decorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce(function (acc, prop) {
      return acc.concat(prop.node.decorators || []);
    }, []);
    var identDecorators = decorators.filter(function (decorator) {
      return !isIdentifier(decorator.expression);
    });
    if (identDecorators.length === 0) return;
    return sequenceExpression(identDecorators.map(function (decorator) {
      var expression = decorator.expression;
      var id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
      return assignmentExpression("=", id, expression);
    }).concat([path.node]));
  }

  function applyClassDecorators(classPath) {
    if (!hasClassDecorators(classPath.node)) return;
    var decorators = classPath.node.decorators || [];
    classPath.node.decorators = null;
    var name = classPath.scope.generateDeclaredUidIdentifier("class");
    return decorators.map(function (dec) {
      return dec.expression;
    }).reverse().reduce(function (acc, decorator) {
      return buildClassDecorator({
        CLASS_REF: cloneNode(name),
        DECORATOR: cloneNode(decorator),
        INNER: acc
      }).expression;
    }, classPath.node);
  }

  function hasClassDecorators(classNode) {
    return !!(classNode.decorators && classNode.decorators.length);
  }

  function applyMethodDecorators(path, state) {
    if (!hasMethodDecorators(path.node.body.body)) return;
    return applyTargetDecorators(path, state, path.node.body.body);
  }

  function hasMethodDecorators(body) {
    return body.some(function (node) {
      var _node$decorators;

      return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;
    });
  }

  function applyObjectDecorators(path, state) {
    if (!hasMethodDecorators(path.node.properties)) return;
    return applyTargetDecorators(path, state, path.node.properties);
  }

  function applyTargetDecorators(path, state, decoratedProps) {
    var name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
    var exprs = decoratedProps.reduce(function (acc, node) {
      var decorators = node.decorators || [];
      node.decorators = null;
      if (decorators.length === 0) return acc;

      if (node.computed) {
        throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
      }

      var property = isLiteral(node.key) ? node.key : stringLiteral(node.key.name);
      var target = path.isClass() && !node["static"] ? buildClassPrototype({
        CLASS_REF: name
      }).expression : name;

      if (isClassProperty(node, {
        "static": false
      })) {
        var descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
        var initializer = node.value ? functionExpression(null, [], blockStatement([returnStatement(node.value)])) : nullLiteral();
        node.value = callExpression(state.addHelper("initializerWarningHelper"), [descriptor, thisExpression()]);
        WARNING_CALLS.add(node.value);
        acc = acc.concat([assignmentExpression("=", cloneNode(descriptor), callExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), arrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), objectExpression([objectProperty(identifier("configurable"), booleanLiteral(true)), objectProperty(identifier("enumerable"), booleanLiteral(true)), objectProperty(identifier("writable"), booleanLiteral(true)), objectProperty(identifier("initializer"), initializer)])]))]);
      } else {
        acc = acc.concat(callExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), arrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), isObjectProperty(node) || isClassProperty(node, {
          "static": true
        }) ? buildGetObjectInitializer({
          TEMP: path.scope.generateDeclaredUidIdentifier("init"),
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression : buildGetDescriptor({
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression, cloneNode(target)]));
      }

      return acc;
    }, []);
    return sequenceExpression([assignmentExpression("=", cloneNode(name), path.node), sequenceExpression(exprs), cloneNode(name)]);
  }

  function decoratedClassToExpression(_ref) {
    var node = _ref.node,
        scope = _ref.scope;

    if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
      return;
    }

    var ref = node.id ? cloneNode(node.id) : scope.generateUidIdentifier("class");
    return variableDeclaration("let", [variableDeclarator(ref, toExpression(node))]);
  }

  var legacyVisitor = {
    ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
      var decl = path.get("declaration");
      if (!decl.isClassDeclaration()) return;
      var replacement = decoratedClassToExpression(decl);

      if (replacement) {
        var _path$replaceWithMult = path.replaceWithMultiple([replacement, exportNamedDeclaration(null, [exportSpecifier(cloneNode(replacement.declarations[0].id), identifier("default"))])]),
            varDeclPath = _path$replaceWithMult[0];

        if (!decl.node.id) {
          path.scope.registerDeclaration(varDeclPath);
        }
      }
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var replacement = decoratedClassToExpression(path);

      if (replacement) {
        path.replaceWith(replacement);
      }
    },
    ClassExpression: function ClassExpression(path, state) {
      var decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
      if (decoratedClass) path.replaceWith(decoratedClass);
    },
    ObjectExpression: function ObjectExpression(path, state) {
      var decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
      if (decoratedObject) path.replaceWith(decoratedObject);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      if (!WARNING_CALLS.has(path.node.right)) return;
      path.replaceWith(callExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("left.object").node), stringLiteral(path.get("left.property").node.name || path.get("left.property").node.value), cloneNode(path.get("right.arguments")[0].node), cloneNode(path.get("right.arguments")[1].node)]));
    },
    CallExpression: function CallExpression(path, state) {
      if (path.node.arguments.length !== 3) return;
      if (!WARNING_CALLS.has(path.node.arguments[2])) return;

      if (path.node.callee.name !== state.addHelper("defineProperty").name) {
        return;
      }

      path.replaceWith(callExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("arguments")[0].node), cloneNode(path.get("arguments")[1].node), cloneNode(path.get("arguments.2.arguments")[0].node), cloneNode(path.get("arguments.2.arguments")[1].node)]));
    }
  };

  var proposalDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you want to use the legacy" + " decorators semantics, you can set the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (legacy) {
      return {
        name: "proposal-decorators",
        inherits: syntaxDecorators,
        manipulateOptions: function manipulateOptions(_ref) {
          var generatorOpts = _ref.generatorOpts;
          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
        },
        visitor: legacyVisitor
      };
    }

    return createClassFeaturePlugin({
      name: "proposal-decorators",
      feature: FEATURES.decorators,
      manipulateOptions: function manipulateOptions(_ref2) {
        var generatorOpts = _ref2.generatorOpts,
            parserOpts = _ref2.parserOpts;
        parserOpts.plugins.push(["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
      }
    });
  });

  var proposalDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-do-expressions",
      inherits: syntaxDoExpressions,
      visitor: {
        DoExpression: {
          exit: function exit(path) {
            var body = path.node.body.body;

            if (body.length) {
              path.replaceExpressionWithStatements(body);
            } else {
              path.replaceWith(path.scope.buildUndefinedNode());
            }
          }
        }
      }
    };
  });

  var lib$5 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-dynamic-import",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("dynamicImport");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxDynamicImport = /*@__PURE__*/unwrapExports(lib$5);

  var version$3 = "7.12.1";

  var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
  var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";
  var proposalDynamicImport = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-dynamic-import",
      inherits: syntaxDynamicImport,
      pre: function pre() {
        this.file.set("@babel/plugin-proposal-dynamic-import", version$3);
      },
      visitor: {
        Program: function Program() {
          var modules = this.file.get("@babel/plugin-transform-modules-*");

          if (!SUPPORTED_MODULES.includes(modules)) {
            throw new Error(MODULES_NOT_FOUND);
          }
        }
      }
    };
  });

  var proposalExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-default-from",
      inherits: syntaxExportDefaultFrom,
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          if (!isExportDefaultSpecifier(specifiers[0])) return;
          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier(exported.name);
          var nodes = [importDeclaration([importDefaultSpecifier(uid)], cloneNode(node.source)), exportNamedDeclaration(null, [exportSpecifier(cloneNode(uid), exported)])];

          if (specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              importDeclaration$1 = _path$replaceWithMult[0];

          path.scope.registerDeclaration(importDeclaration$1);
        }
      }
    };
  });

  var lib$6 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-namespace-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportNamespaceFrom");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxExportNamespaceFrom = /*@__PURE__*/unwrapExports(lib$6);

  var proposalExportNamespaceFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-namespace-from",
      inherits: syntaxExportNamespaceFrom,
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var _exported$name;

          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          var index = isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
          if (!isExportNamespaceSpecifier(specifiers[index])) return;
          var nodes = [];

          if (index === 1) {
            nodes.push(exportNamedDeclaration(null, [specifiers.shift()], node.source));
          }

          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
          nodes.push(importDeclaration([importNamespaceSpecifier(uid)], cloneNode(node.source)), exportNamedDeclaration(null, [exportSpecifier(cloneNode(uid), exported)]));

          if (node.specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              importDeclaration$1 = _path$replaceWithMult[0];

          path.scope.registerDeclaration(importDeclaration$1);
        }
      }
    };
  });

  var proposalFunctionBind = declare(function (api) {
    api.assertVersion(7);

    function getTempId(scope) {
      var id = scope.path.getData("functionBind");
      if (id) return cloneNode(id);
      id = scope.generateDeclaredUidIdentifier("context");
      return scope.path.setData("functionBind", id);
    }

    function getStaticContext(bind, scope) {
      var object = bind.object || bind.callee.object;
      return scope.isStatic(object) && (isSuper(object) ? thisExpression() : object);
    }

    function inferBindContext(bind, scope) {
      var staticContext = getStaticContext(bind, scope);
      if (staticContext) return cloneNode(staticContext);
      var tempId = getTempId(scope);

      if (bind.object) {
        bind.callee = sequenceExpression([assignmentExpression("=", tempId, bind.object), bind.callee]);
      } else {
        bind.callee.object = assignmentExpression("=", tempId, bind.callee.object);
      }

      return cloneNode(tempId);
    }

    return {
      name: "proposal-function-bind",
      inherits: syntaxFunctionBind,
      visitor: {
        CallExpression: function CallExpression(_ref) {
          var node = _ref.node,
              scope = _ref.scope;
          var bind = node.callee;
          if (!isBindExpression(bind)) return;
          var context = inferBindContext(bind, scope);
          node.callee = memberExpression(bind.callee, identifier("call"));
          node.arguments.unshift(context);
        },
        BindExpression: function BindExpression(path) {
          var node = path.node,
              scope = path.scope;
          var context = inferBindContext(node, scope);
          path.replaceWith(callExpression(memberExpression(node.callee, identifier("bind")), [context]));
        }
      }
    };
  });

  var proposalFunctionSent = declare(function (api) {
    api.assertVersion(7);

    var isFunctionSent = function isFunctionSent(node) {
      return isIdentifier(node.meta, {
        name: "function"
      }) && isIdentifier(node.property, {
        name: "sent"
      });
    };

    var hasBeenReplaced = function hasBeenReplaced(node, sentId) {
      return isAssignmentExpression(node) && isIdentifier(node.left, {
        name: sentId
      });
    };

    var yieldVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(path) {
        if (!hasBeenReplaced(path.parent, this.sentId)) {
          path.replaceWith(assignmentExpression("=", identifier(this.sentId), path.node));
        }
      },
      MetaProperty: function MetaProperty(path) {
        if (isFunctionSent(path.node)) {
          path.replaceWith(identifier(this.sentId));
        }
      }
    };
    return {
      name: "proposal-function-sent",
      inherits: syntaxFunctionSent,
      visitor: {
        MetaProperty: function MetaProperty(path, state) {
          if (!isFunctionSent(path.node)) return;
          var fnPath = path.getFunctionParent();

          if (!fnPath.node.generator) {
            throw new Error("Parent generator function not found");
          }

          var sentId = path.scope.generateUid("function.sent");
          fnPath.traverse(yieldVisitor, {
            sentId: sentId
          });
          fnPath.node.body.body.unshift(variableDeclaration("let", [variableDeclarator(identifier(sentId), yieldExpression())]));
          wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
        }
      }
    };
  });

  var lib$7 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-json-strings",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsonStrings");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxJsonStrings = /*@__PURE__*/unwrapExports(lib$7);

  var proposalJsonStrings = declare(function (api) {
    api.assertVersion(7);
    var regex = /(\\*)([\u2028\u2029])/g;

    function replace(match, escapes, separator) {
      var isEscaped = escapes.length % 2 === 1;
      if (isEscaped) return match;
      return escapes + "\\u" + separator.charCodeAt(0).toString(16);
    }

    return {
      name: "proposal-json-strings",
      inherits: syntaxJsonStrings,
      visitor: {
        "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
          var node = _ref.node;
          var extra = node.extra;
          if (!(extra == null ? void 0 : extra.raw)) return;
          extra.raw = extra.raw.replace(regex, replace);
        }
      }
    };
  });

  var lib$8 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-logical-assignment-operators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("logicalAssignment");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxLogicalAssignmentOperators = /*@__PURE__*/unwrapExports(lib$8);

  var proposalLogicalAssignmentOperators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-logical-assignment-operators",
      inherits: syntaxLogicalAssignmentOperators,
      visitor: {
        AssignmentExpression: function AssignmentExpression(path) {
          var node = path.node,
              scope = path.scope;
          var operator = node.operator,
              left = node.left,
              right = node.right;
          var operatorTrunc = operator.slice(0, -1);

          if (!LOGICAL_OPERATORS.includes(operatorTrunc)) {
            return;
          }

          var lhs = cloneNode(left);

          if (isMemberExpression(left)) {
            var object = left.object,
                property = left.property,
                computed = left.computed;
            var memo = scope.maybeGenerateMemoised(object);

            if (memo) {
              left.object = memo;
              lhs.object = assignmentExpression("=", cloneNode(memo), object);
            }

            if (computed) {
              var _memo = scope.maybeGenerateMemoised(property);

              if (_memo) {
                left.property = _memo;
                lhs.property = assignmentExpression("=", cloneNode(_memo), property);
              }
            }
          }

          path.replaceWith(logicalExpression(operatorTrunc, lhs, assignmentExpression("=", left, right)));
        }
      }
    };
  });

  var lib$9 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-nullish-coalescing-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("nullishCoalescingOperator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNullishCoalescingOperator = /*@__PURE__*/unwrapExports(lib$9);

  function _templateObject$8() {
    var data = _taggedTemplateLiteralLoose(["(() => ", ")()"]);

    _templateObject$8 = function _templateObject() {
      return data;
    };

    return data;
  }
  var proposalNullishCoalescingOperator = declare(function (api, _ref) {
    var _ref$loose = _ref.loose,
        loose = _ref$loose === void 0 ? false : _ref$loose;
    api.assertVersion(7);
    return {
      name: "proposal-nullish-coalescing-operator",
      inherits: syntaxNullishCoalescingOperator,
      visitor: {
        LogicalExpression: function LogicalExpression(path) {
          var node = path.node,
              scope = path.scope;

          if (node.operator !== "??") {
            return;
          }

          var ref;
          var assignment;

          if (scope.isStatic(node.left)) {
            ref = node.left;
            assignment = cloneNode(node.left);
          } else if (scope.path.isPattern()) {
            path.replaceWith(template.ast(_templateObject$8(), path.node));
            return;
          } else {
            ref = scope.generateUidIdentifierBasedOnNode(node.left);
            scope.push({
              id: cloneNode(ref)
            });
            assignment = assignmentExpression("=", ref, node.left);
          }

          path.replaceWith(conditionalExpression(loose ? binaryExpression("!=", assignment, nullLiteral()) : logicalExpression("&&", binaryExpression("!==", assignment, nullLiteral()), binaryExpression("!==", cloneNode(ref), scope.buildUndefinedNode())), cloneNode(ref), node.right));
        }
      }
    };
  });

  var lib$a = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-numeric-separator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("numericSeparator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNumericSeparator = /*@__PURE__*/unwrapExports(lib$a);

  function remover(_ref) {
    var _extra$raw;

    var node = _ref.node;
    var extra = node.extra;

    if (extra == null ? void 0 : (_extra$raw = extra.raw) == null ? void 0 : _extra$raw.includes("_")) {
      extra.raw = extra.raw.replace(/_/g, "");
    }
  }

  var proposalNumericSeparator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-numeric-separator",
      inherits: syntaxNumericSeparator,
      visitor: {
        NumericLiteral: remover,
        BigIntLiteral: remover
      }
    };
  });

  var lib$b = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread$1 = /*@__PURE__*/unwrapExports(lib$b);

  var buildDefaultParam = template("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
  var buildLooseDefaultParam = template("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
  var buildLooseDestructuredDefaultParam = template("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
  var buildSafeArgumentsAccess = template("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
  var iifeVisitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      var scope = path.scope,
          node = path.node;
      var name = node.name;

      if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
        state.needsOuterBinding = true;
        path.stop();
      }
    },
    "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": function TypeAnnotationTSTypeAnnotationTypeParameterDeclarationTSTypeParameterDeclaration(path) {
      return path.skip();
    }
  };
  function convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement) {
    var params = path.get("params");
    var isSimpleParameterList = params.every(function (param) {
      return param.isIdentifier();
    });
    if (isSimpleParameterList) return false;
    var node = path.node,
        scope = path.scope;
    var state = {
      stop: false,
      needsOuterBinding: false,
      scope: scope
    };
    var body = [];
    var shadowedParams = new Set();

    for (var _iterator = _createForOfIteratorHelperLoose(params), _step; !(_step = _iterator()).done;) {
      var _param2 = _step.value;

      for (var _i = 0, _Object$keys = Object.keys(_param2.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
        var _scope$bindings$name;

        var name = _Object$keys[_i];
        var constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;

        if (constantViolations) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(constantViolations), _step4; !(_step4 = _iterator4()).done;) {
            var redeclarator = _step4.value;
            var _node = redeclarator.node;

            switch (_node.type) {
              case "VariableDeclarator":
                {
                  if (_node.init === null) {
                    var declaration = redeclarator.parentPath;

                    if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                      redeclarator.remove();
                      break;
                    }
                  }

                  shadowedParams.add(name);
                  break;
                }

              case "FunctionDeclaration":
                shadowedParams.add(name);
                break;
            }
          }
        }
      }
    }

    if (shadowedParams.size === 0) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(params), _step2; !(_step2 = _iterator2()).done;) {
        var param = _step2.value;
        if (!param.isIdentifier()) param.traverse(iifeVisitor, state);
        if (state.needsOuterBinding) break;
      }
    }

    var firstOptionalIndex = null;

    for (var i = 0; i < params.length; i++) {
      var _param = params[i];

      if (shouldTransformParam && !shouldTransformParam(i)) {
        continue;
      }

      var transformedRestNodes = [];

      if (replaceRestElement) {
        replaceRestElement(_param.parentPath, _param, transformedRestNodes);
      }

      var paramIsAssignmentPattern = _param.isAssignmentPattern();

      if (paramIsAssignmentPattern && (loose || node.kind === "set")) {
        var left = _param.get("left");

        var right = _param.get("right");

        var undefinedNode = scope.buildUndefinedNode();

        if (left.isIdentifier()) {
          body.push(buildLooseDefaultParam({
            ASSIGNMENT_IDENTIFIER: cloneNode(left.node),
            DEFAULT_VALUE: right.node,
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(left.node);
        } else if (left.isObjectPattern() || left.isArrayPattern()) {
          var paramName = scope.generateUidIdentifier();
          body.push(buildLooseDestructuredDefaultParam({
            ASSIGNMENT_IDENTIFIER: left.node,
            DEFAULT_VALUE: right.node,
            PARAMETER_NAME: cloneNode(paramName),
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(paramName);
        }
      } else if (paramIsAssignmentPattern) {
        if (firstOptionalIndex === null) firstOptionalIndex = i;

        var _left = _param.get("left");

        var _right = _param.get("right");

        var defNode = buildDefaultParam({
          VARIABLE_NAME: _left.node,
          DEFAULT_VALUE: _right.node,
          ARGUMENT_KEY: numericLiteral(i)
        });
        body.push(defNode);
      } else if (firstOptionalIndex !== null) {
        var _defNode = buildSafeArgumentsAccess([_param.node, numericLiteral(i)]);

        body.push(_defNode);
      } else if (_param.isObjectPattern() || _param.isArrayPattern()) {
        var uid = path.scope.generateUidIdentifier("ref");

        var _defNode2 = variableDeclaration("let", [variableDeclarator(_param.node, uid)]);

        body.push(_defNode2);

        _param.replaceWith(cloneNode(uid));
      }

      if (transformedRestNodes) {
        for (var _iterator3 = _createForOfIteratorHelperLoose(transformedRestNodes), _step3; !(_step3 = _iterator3()).done;) {
          var transformedNode = _step3.value;
          body.push(transformedNode);
        }
      }
    }

    if (firstOptionalIndex !== null) {
      node.params = node.params.slice(0, firstOptionalIndex);
    }

    path.ensureBlock();

    if (state.needsOuterBinding || shadowedParams.size > 0) {
      body.push(buildScopeIIFE(shadowedParams, path.get("body").node));
      path.set("body", blockStatement(body));
      var bodyPath = path.get("body.body");
      var arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
      arrowPath.arrowFunctionToExpression();
      arrowPath.node.generator = path.node.generator;
      arrowPath.node.async = path.node.async;
      path.node.generator = false;
    } else {
      path.get("body").unshiftContainer("body", body);
    }

    return true;
  }

  function buildScopeIIFE(shadowedParams, body) {
    var args = [];
    var params = [];

    for (var _iterator5 = _createForOfIteratorHelperLoose(shadowedParams), _step5; !(_step5 = _iterator5()).done;) {
      var name = _step5.value;
      args.push(identifier(name));
      params.push(identifier(name));
    }

    return returnStatement(callExpression(arrowFunctionExpression(params, body), args));
  }

  var buildRest = template("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
  var restIndex = template("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
  var restIndexImpure = template("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
  var restLength = template("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

  function referencesRest(path, state) {
    if (path.node.name === state.name) {
      return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
    }

    return false;
  }

  var memberExpressionOptimisationVisitor = {
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
        path.skip();
      }
    },
    Flow: function Flow(path) {
      if (path.isTypeCastExpression()) return;
      path.skip();
    },
    Function: function Function(path, state) {
      var oldNoOptimise = state.noOptimise;
      state.noOptimise = true;
      path.traverse(memberExpressionOptimisationVisitor, state);
      state.noOptimise = oldNoOptimise;
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var node = path.node;

      if (node.name === "arguments") {
        state.deopted = true;
      }

      if (!referencesRest(path, state)) return;

      if (state.noOptimise) {
        state.deopted = true;
      } else {
        var parentPath = path.parentPath;

        if (parentPath.listKey === "params" && parentPath.key < state.offset) {
          return;
        }

        if (parentPath.isMemberExpression({
          object: node
        })) {
          var grandparentPath = parentPath.parentPath;
          var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
            operator: "delete"
          }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

          if (argsOptEligible) {
            if (parentPath.node.computed) {
              if (parentPath.get("property").isBaseType("number")) {
                state.candidates.push({
                  cause: "indexGetter",
                  path: path
                });
                return;
              }
            } else if (parentPath.node.property.name === "length") {
              state.candidates.push({
                cause: "lengthGetter",
                path: path
              });
              return;
            }
          }
        }

        if (state.offset === 0 && parentPath.isSpreadElement()) {
          var call = parentPath.parentPath;

          if (call.isCallExpression() && call.node.arguments.length === 1) {
            state.candidates.push({
              cause: "argSpread",
              path: path
            });
            return;
          }
        }

        state.references.push(path);
      }
    },
    BindingIdentifier: function BindingIdentifier(path, state) {
      if (referencesRest(path, state)) {
        state.deopted = true;
      }
    }
  };

  function getParamsCount(node) {
    var count = node.params.length;

    if (count > 0 && isIdentifier(node.params[0], {
      name: "this"
    })) {
      count -= 1;
    }

    return count;
  }

  function hasRest(node) {
    var length = node.params.length;
    return length > 0 && isRestElement(node.params[length - 1]);
  }

  function optimiseIndexGetter(path, argsId, offset) {
    var offsetLiteral = numericLiteral(offset);
    var index;

    if (isNumericLiteral(path.parent.property)) {
      index = numericLiteral(path.parent.property.value + offset);
    } else if (offset === 0) {
      index = path.parent.property;
    } else {
      index = binaryExpression("+", path.parent.property, cloneNode(offsetLiteral));
    }

    var scope = path.scope;

    if (!scope.isPure(index)) {
      var temp = scope.generateUidIdentifierBasedOnNode(index);
      scope.push({
        id: temp,
        kind: "var"
      });
      path.parentPath.replaceWith(restIndexImpure({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
        REF: cloneNode(temp)
      }));
    } else {
      var parentPath = path.parentPath;
      parentPath.replaceWith(restIndex({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index
      }));
      var offsetTestPath = parentPath.get("test").get("left");
      var valRes = offsetTestPath.evaluate();

      if (valRes.confident) {
        if (valRes.value === true) {
          parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
        } else {
          parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
        }
      }
    }
  }

  function optimiseLengthGetter(path, argsId, offset) {
    if (offset) {
      path.parentPath.replaceWith(restLength({
        ARGUMENTS: argsId,
        OFFSET: numericLiteral(offset)
      }));
    } else {
      path.replaceWith(argsId);
    }
  }

  function convertFunctionRest(path) {
    var node = path.node,
        scope = path.scope;
    if (!hasRest(node)) return false;
    var rest = node.params.pop().argument;
    var argsId = identifier("arguments");

    if (isPattern(rest)) {
      var pattern = rest;
      rest = scope.generateUidIdentifier("ref");
      var declar = variableDeclaration("let", [variableDeclarator(pattern, rest)]);
      node.body.body.unshift(declar);
    }

    var paramsCount = getParamsCount(node);
    var state = {
      references: [],
      offset: paramsCount,
      argumentsNode: argsId,
      outerBinding: scope.getBindingIdentifier(rest.name),
      candidates: [],
      name: rest.name,
      deopted: false
    };
    path.traverse(memberExpressionOptimisationVisitor, state);

    if (!state.deopted && !state.references.length) {
      for (var _i = 0, _arr = state.candidates; _i < _arr.length; _i++) {
        var _arr$_i = _arr[_i],
            _path = _arr$_i.path,
            cause = _arr$_i.cause;
        var clonedArgsId = cloneNode(argsId);

        switch (cause) {
          case "indexGetter":
            optimiseIndexGetter(_path, clonedArgsId, state.offset);
            break;

          case "lengthGetter":
            optimiseLengthGetter(_path, clonedArgsId, state.offset);
            break;

          default:
            _path.replaceWith(clonedArgsId);

        }
      }

      return true;
    }

    state.references = state.references.concat(state.candidates.map(function (_ref) {
      var path = _ref.path;
      return path;
    }));
    var start = numericLiteral(paramsCount);
    var key = scope.generateUidIdentifier("key");
    var len = scope.generateUidIdentifier("len");
    var arrKey, arrLen;

    if (paramsCount) {
      arrKey = binaryExpression("-", cloneNode(key), cloneNode(start));
      arrLen = conditionalExpression(binaryExpression(">", cloneNode(len), cloneNode(start)), binaryExpression("-", cloneNode(len), cloneNode(start)), numericLiteral(0));
    } else {
      arrKey = identifier(key.name);
      arrLen = identifier(len.name);
    }

    var loop = buildRest({
      ARGUMENTS: argsId,
      ARRAY_KEY: arrKey,
      ARRAY_LEN: arrLen,
      START: start,
      ARRAY: rest,
      KEY: key,
      LEN: len
    });

    if (state.deopted) {
      node.body.body.unshift(loop);
    } else {
      var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
      target.findParent(function (path) {
        if (path.isLoop()) {
          target = path;
        } else {
          return path.isFunction();
        }
      });
      target.insertBefore(loop);
    }

    return true;
  }

  var transformParameters = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    return {
      name: "transform-parameters",
      visitor: {
        Function: function Function(path) {
          if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
            return param.isRestElement() || param.isAssignmentPattern();
          })) {
            path.arrowFunctionToExpression();
          }

          var convertedRest = convertFunctionRest(path);
          var convertedParams = convertFunctionParams(path, loose);

          if (convertedRest || convertedParams) {
            path.scope.crawl();
          }
        }
      }
    };
  });

  var ZERO_REFS = function () {
    var node = identifier("a");
    var property = objectProperty(identifier("key"), node);
    var pattern = objectPattern([property]);
    return isReferenced(node, property, pattern) ? 1 : 0;
  }();

  var proposalObjectRestSpread = declare(function (api, opts) {
    api.assertVersion(7);
    var _opts$useBuiltIns = opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$loose = opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose;

    if (typeof loose !== "boolean") {
      throw new Error(".loose must be a boolean, or undefined");
    }

    function getExtendsHelper(file) {
      return useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
    }

    function hasRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        foundRestElement = true;
        restElement.stop();
      });
      return foundRestElement;
    }

    function hasObjectPatternRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        if (restElement.parentPath.isObjectPattern()) {
          foundRestElement = true;
          restElement.stop();
        }
      });
      return foundRestElement;
    }

    function visitRestElements(path, visitor) {
      path.traverse({
        Expression: function Expression(path) {
          var parentType = path.parent.type;

          if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
            path.skip();
          }
        },
        RestElement: visitor
      });
    }

    function hasSpread(node) {
      for (var _iterator = _createForOfIteratorHelperLoose(node.properties), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (isSpreadElement(prop)) {
          return true;
        }
      }

      return false;
    }

    function extractNormalizedKeys(path) {
      var props = path.node.properties;
      var keys = [];
      var allLiteral = true;

      for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;

        if (isIdentifier(prop.key) && !prop.computed) {
          keys.push(stringLiteral(prop.key.name));
        } else if (isTemplateLiteral(prop.key)) {
          keys.push(cloneNode(prop.key));
        } else if (isLiteral(prop.key)) {
          keys.push(stringLiteral(String(prop.key.value)));
        } else {
          keys.push(cloneNode(prop.key));
          allLiteral = false;
        }
      }

      return {
        keys: keys,
        allLiteral: allLiteral
      };
    }

    function replaceImpureComputedKeys(properties, scope) {
      var impureComputedPropertyDeclarators = [];

      for (var _iterator3 = _createForOfIteratorHelperLoose(properties), _step3; !(_step3 = _iterator3()).done;) {
        var propPath = _step3.value;
        var key = propPath.get("key");

        if (propPath.node.computed && !key.isPure()) {
          var name = scope.generateUidBasedOnNode(key.node);
          var declarator = variableDeclarator(identifier(name), key.node);
          impureComputedPropertyDeclarators.push(declarator);
          key.replaceWith(identifier(name));
        }
      }

      return impureComputedPropertyDeclarators;
    }

    function removeUnusedExcludedKeys(path) {
      var bindings = path.getOuterBindingIdentifierPaths();
      Object.keys(bindings).forEach(function (bindingName) {
        var bindingParentPath = bindings[bindingName].parentPath;

        if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
          return;
        }

        bindingParentPath.remove();
      });
    }

    function createObjectSpread(path, file, objRef) {
      var props = path.get("properties");
      var last = props[props.length - 1];
      assertRestElement(last.node);
      var restElement = cloneNode(last.node);
      last.remove();
      var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

      var _extractNormalizedKey = extractNormalizedKeys(path),
          keys = _extractNormalizedKey.keys,
          allLiteral = _extractNormalizedKey.allLiteral;

      if (keys.length === 0) {
        return [impureComputedPropertyDeclarators, restElement.argument, callExpression(getExtendsHelper(file), [objectExpression([]), cloneNode(objRef)])];
      }

      var keyExpression;

      if (!allLiteral) {
        keyExpression = callExpression(memberExpression(arrayExpression(keys), identifier("map")), [file.addHelper("toPropertyKey")]);
      } else {
        keyExpression = arrayExpression(keys);
      }

      return [impureComputedPropertyDeclarators, restElement.argument, callExpression(file.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression])];
    }

    function replaceRestElement(parentPath, paramPath, container) {
      if (paramPath.isAssignmentPattern()) {
        replaceRestElement(parentPath, paramPath.get("left"), container);
        return;
      }

      if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
        var elements = paramPath.get("elements");

        for (var i = 0; i < elements.length; i++) {
          replaceRestElement(parentPath, elements[i], container);
        }
      }

      if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
        var uid = parentPath.scope.generateUidIdentifier("ref");
        var declar = variableDeclaration("let", [variableDeclarator(paramPath.node, uid)]);

        if (container) {
          container.push(declar);
        } else {
          parentPath.ensureBlock();
          parentPath.get("body").unshiftContainer("body", declar);
        }

        paramPath.replaceWith(cloneNode(uid));
      }
    }

    return {
      name: "proposal-object-rest-spread",
      inherits: syntaxObjectRestSpread$1,
      visitor: {
        Function: function Function(path) {
          var params = path.get("params");
          var paramsWithRestElement = new Set();
          var idsInRestParams = new Set();

          for (var _i = 0; _i < params.length; ++_i) {
            var param = params[_i];

            if (hasRestElement(param)) {
              paramsWithRestElement.add(_i);

              for (var _i2 = 0, _Object$keys = Object.keys(param.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                var name = _Object$keys[_i2];
                idsInRestParams.add(name);
              }
            }
          }

          var idInRest = false;

          var IdentifierHandler = function IdentifierHandler(path, functionScope) {
            var name = path.node.name;

            if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
              idInRest = true;
              path.stop();
            }
          };

          var i;

          for (i = 0; i < params.length && !idInRest; ++i) {
            var _param = params[i];

            if (!paramsWithRestElement.has(i)) {
              if (_param.isReferencedIdentifier() || _param.isBindingIdentifier()) {
                IdentifierHandler(path, path.scope);
              } else {
                _param.traverse({
                  "Scope|TypeAnnotation|TSTypeAnnotation": function ScopeTypeAnnotationTSTypeAnnotation(path) {
                    return path.skip();
                  },
                  "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                }, path.scope);
              }
            }
          }

          if (!idInRest) {
            for (var _i3 = 0; _i3 < params.length; ++_i3) {
              var _param2 = params[_i3];

              if (paramsWithRestElement.has(_i3)) {
                replaceRestElement(_param2.parentPath, _param2);
              }
            }
          } else {
            var shouldTransformParam = function shouldTransformParam(idx) {
              return idx >= i - 1 || paramsWithRestElement.has(idx);
            };

            convertFunctionParams(path, loose, shouldTransformParam, replaceRestElement);
          }
        },
        VariableDeclarator: function VariableDeclarator(path, file) {
          if (!path.get("id").isObjectPattern()) {
            return;
          }

          var insertionPath = path;
          var originalPath = path;
          visitRestElements(path.get("id"), function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            if (originalPath.node.id.properties.length > 1 && !isIdentifier(originalPath.node.init)) {
              var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
              originalPath.insertBefore(variableDeclarator(initRef, originalPath.node.init));
              originalPath.replaceWith(variableDeclarator(originalPath.node.id, cloneNode(initRef)));
              return;
            }

            var ref = originalPath.node.init;
            var refPropertyPath = [];
            var kind;
            path.findParent(function (path) {
              if (path.isObjectProperty()) {
                refPropertyPath.unshift(path);
              } else if (path.isVariableDeclarator()) {
                kind = path.parentPath.node.kind;
                return true;
              }
            });
            var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
            refPropertyPath.forEach(function (prop) {
              var node = prop.node;
              ref = memberExpression(ref, cloneNode(node.key), node.computed || isLiteral(node.key));
            });
            var objectPatternPath = path.findParent(function (path) {
              return path.isObjectPattern();
            });

            var _createObjectSpread = createObjectSpread(objectPatternPath, file, ref),
                impureComputedPropertyDeclarators = _createObjectSpread[0],
                argument = _createObjectSpread[1],
                callExpression = _createObjectSpread[2];

            if (loose) {
              removeUnusedExcludedKeys(objectPatternPath);
            }

            assertIdentifier(argument);
            insertionPath.insertBefore(impureComputedPropertyDeclarators);
            insertionPath.insertBefore(impureObjRefComputedDeclarators);
            insertionPath.insertAfter(variableDeclarator(argument, callExpression));
            insertionPath = insertionPath.getSibling(insertionPath.key + 1);
            path.scope.registerBinding(kind, insertionPath);

            if (objectPatternPath.node.properties.length === 0) {
              objectPatternPath.findParent(function (path) {
                return path.isObjectProperty() || path.isVariableDeclarator();
              }).remove();
            }
          });
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          var hasRest = declaration.get("declarations").some(function (path) {
            return hasObjectPatternRestElement(path.get("id"));
          });
          if (!hasRest) return;
          var specifiers = [];

          for (var _i4 = 0, _Object$keys2 = Object.keys(path.getOuterBindingIdentifiers(path)); _i4 < _Object$keys2.length; _i4++) {
            var name = _Object$keys2[_i4];
            specifiers.push(exportSpecifier(identifier(name), identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(exportNamedDeclaration(null, specifiers));
        },
        CatchClause: function CatchClause(path) {
          var paramPath = path.get("param");
          replaceRestElement(paramPath.parentPath, paramPath);
        },
        AssignmentExpression: function AssignmentExpression(path, file) {
          var leftPath = path.get("left");

          if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
            var nodes = [];
            var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
            nodes.push(variableDeclaration("var", [variableDeclarator(identifier(refName), path.node.right)]));

            var _createObjectSpread2 = createObjectSpread(leftPath, file, identifier(refName)),
                impureComputedPropertyDeclarators = _createObjectSpread2[0],
                argument = _createObjectSpread2[1],
                callExpression = _createObjectSpread2[2];

            if (impureComputedPropertyDeclarators.length > 0) {
              nodes.push(variableDeclaration("var", impureComputedPropertyDeclarators));
            }

            var nodeWithoutSpread = cloneNode(path.node);
            nodeWithoutSpread.right = identifier(refName);
            nodes.push(expressionStatement(nodeWithoutSpread));
            nodes.push(toStatement(assignmentExpression("=", argument, callExpression)));
            nodes.push(expressionStatement(identifier(refName)));
            path.replaceWithMultiple(nodes);
          }
        },
        ForXStatement: function ForXStatement(path) {
          var node = path.node,
              scope = path.scope;
          var leftPath = path.get("left");
          var left = node.left;

          if (!hasObjectPatternRestElement(leftPath)) {
            return;
          }

          if (!isVariableDeclaration(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration("var", [variableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(expressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(expressionStatement(assignmentExpression("=", left, cloneNode(temp))));
          } else {
            var pattern = left.declarations[0].id;
            var key = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration(left.kind, [variableDeclarator(key, null)]);
            path.ensureBlock();
            node.body.body.unshift(variableDeclaration(node.left.kind, [variableDeclarator(pattern, cloneNode(key))]));
          }
        },
        ArrayPattern: function ArrayPattern(path) {
          var objectPatterns = [];
          visitRestElements(path, function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            var objectPattern = path.parentPath;
            var uid = path.scope.generateUidIdentifier("ref");
            objectPatterns.push(variableDeclarator(objectPattern.node, uid));
            objectPattern.replaceWith(cloneNode(uid));
            path.skip();
          });

          if (objectPatterns.length > 0) {
            var statementPath = path.getStatementParent();
            statementPath.insertAfter(variableDeclaration(statementPath.node.kind || "var", objectPatterns));
          }
        },
        ObjectExpression: function ObjectExpression(path, file) {
          if (!hasSpread(path.node)) return;
          var helper;

          if (loose) {
            helper = getExtendsHelper(file);
          } else {
            try {
              helper = file.addHelper("objectSpread2");
            } catch (_unused) {
              this.file.declarations["objectSpread2"] = null;
              helper = file.addHelper("objectSpread");
            }
          }

          var exp = null;
          var props = [];

          function make() {
            var hadProps = props.length > 0;
            var obj = objectExpression(props);
            props = [];

            if (!exp) {
              exp = callExpression(helper, [obj]);
              return;
            }

            if (loose) {
              if (hadProps) {
                exp.arguments.push(obj);
              }

              return;
            }

            exp = callExpression(cloneNode(helper), [exp].concat(hadProps ? [objectExpression([]), obj] : []));
          }

          for (var _i5 = 0, _arr = path.node.properties; _i5 < _arr.length; _i5++) {
            var prop = _arr[_i5];

            if (isSpreadElement(prop)) {
              make();
              exp.arguments.push(prop.argument);
            } else {
              props.push(prop);
            }
          }

          if (props.length) make();
          path.replaceWith(exp);
        }
      }
    };
  });

  var lib$c = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding$1 = /*@__PURE__*/unwrapExports(lib$c);

  var proposalOptionalCatchBinding = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-optional-catch-binding",
      inherits: syntaxOptionalCatchBinding$1,
      visitor: {
        CatchClause: function CatchClause(path) {
          if (!path.node.param) {
            var uid = path.scope.generateUidIdentifier("unused");
            var paramPath = path.get("param");
            paramPath.replaceWith(uid);
          }
        }
      }
    };
  });

  function isTransparentExprWrapper(node) {
    return isTSAsExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
  }
  function skipTransparentExprWrappers(path) {
    while (isTransparentExprWrapper(path.node)) {
      path = path.get("expression");
    }

    return path;
  }

  var lib$d = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-chaining",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalChaining");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalChaining = /*@__PURE__*/unwrapExports(lib$d);

  function willPathCastToBoolean$1(path) {
    var maybeWrapped = findOutermostTransparentParent(path);
    var node = maybeWrapped.node,
        parentPath = maybeWrapped.parentPath;

    if (parentPath.isLogicalExpression()) {
      var _parentPath$node = parentPath.node,
          operator = _parentPath$node.operator,
          right = _parentPath$node.right;

      if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
        return willPathCastToBoolean$1(parentPath);
      }
    }

    if (parentPath.isSequenceExpression()) {
      var expressions = parentPath.node.expressions;

      if (expressions[expressions.length - 1] === node) {
        return willPathCastToBoolean$1(parentPath);
      } else {
        return true;
      }
    }

    return parentPath.isConditional({
      test: node
    }) || parentPath.isUnaryExpression({
      operator: "!"
    }) || parentPath.isLoop({
      test: node
    });
  }
  function findOutermostTransparentParent(path) {
    var maybeWrapped = path;
    path.findParent(function (p) {
      if (!isTransparentExprWrapper(p)) return true;
      maybeWrapped = p;
    });
    return maybeWrapped;
  }

  function _templateObject7$3() {
    var data = _taggedTemplateLiteralLoose(["void 0"]);

    _templateObject7$3 = function _templateObject7() {
      return data;
    };

    return data;
  }

  function _templateObject6$3() {
    var data = _taggedTemplateLiteralLoose(["true"]);

    _templateObject6$3 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5$3() {
    var data = _taggedTemplateLiteralLoose(["\n            ", " === null || ", " === void 0"]);

    _templateObject5$3 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4$4() {
    var data = _taggedTemplateLiteralLoose(["", " == null"]);

    _templateObject4$4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3$4() {
    var data = _taggedTemplateLiteralLoose(["\n            ", " !== null && ", " !== void 0"]);

    _templateObject3$4 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$4() {
    var data = _taggedTemplateLiteralLoose(["", " != null"]);

    _templateObject2$4 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$9() {
    var data = _taggedTemplateLiteralLoose(["(() => ", ")()"]);

    _templateObject$9 = function _templateObject() {
      return data;
    };

    return data;
  }
  var ast = template.expression.ast;
  var proposalOptionalChaining = declare(function (api, options) {
    api.assertVersion(7);
    var _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose;

    function isSimpleMemberExpression(expression) {
      expression = skipTransparentExprWrappers(expression);
      return isIdentifier(expression) || isSuper(expression) || isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
    }

    function needsMemoize(path) {
      var optionalPath = path;
      var scope = path.scope;

      while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
        var _optionalPath = optionalPath,
            node = _optionalPath.node;
        var childKey = optionalPath.isOptionalMemberExpression() ? "object" : "callee";
        var childPath = skipTransparentExprWrappers(optionalPath.get(childKey));

        if (node.optional) {
          return !scope.isStatic(childPath.node);
        }

        optionalPath = childPath;
      }
    }

    return {
      name: "proposal-optional-chaining",
      inherits: syntaxOptionalChaining,
      visitor: {
        "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
          var scope = path.scope;
          var maybeWrapped = findOutermostTransparentParent(path);
          var parentPath = maybeWrapped.parentPath;
          var willReplacementCastToBoolean = willPathCastToBoolean$1(maybeWrapped);
          var isDeleteOperation = false;
          var parentIsCall = parentPath.isCallExpression({
            callee: maybeWrapped.node
          }) && path.isOptionalMemberExpression();
          var optionals = [];
          var optionalPath = path;

          if (scope.path.isPattern() && needsMemoize(optionalPath)) {
            path.replaceWith(template.ast(_templateObject$9(), path.node));
            return;
          }

          while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
            var _optionalPath2 = optionalPath,
                node = _optionalPath2.node;

            if (node.optional) {
              optionals.push(node);
            }

            if (optionalPath.isOptionalMemberExpression()) {
              optionalPath.node.type = "MemberExpression";
              optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
            } else if (optionalPath.isOptionalCallExpression()) {
              optionalPath.node.type = "CallExpression";
              optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
            }
          }

          var replacementPath = path;

          if (parentPath.isUnaryExpression({
            operator: "delete"
          })) {
            replacementPath = parentPath;
            isDeleteOperation = true;
          }

          for (var i = optionals.length - 1; i >= 0; i--) {
            var _node = optionals[i];
            var isCall = isCallExpression(_node);
            var replaceKey = isCall ? "callee" : "object";
            var chainWithTypes = _node[replaceKey];
            var chain = chainWithTypes;

            while (isTransparentExprWrapper(chain)) {
              chain = chain.expression;
            }

            var ref = void 0;
            var check = void 0;

            if (isCall && isIdentifier(chain, {
              name: "eval"
            })) {
              check = ref = chain;
              _node[replaceKey] = sequenceExpression([numericLiteral(0), ref]);
            } else if (loose && isCall && isSimpleMemberExpression(chain)) {
              check = ref = chainWithTypes;
            } else {
              ref = scope.maybeGenerateMemoised(chain);

              if (ref) {
                check = assignmentExpression("=", cloneNode(ref), chainWithTypes);
                _node[replaceKey] = ref;
              } else {
                check = ref = chainWithTypes;
              }
            }

            if (isCall && isMemberExpression(chain)) {
              if (loose && isSimpleMemberExpression(chain)) {
                _node.callee = chainWithTypes;
              } else {
                var _chain = chain,
                    object = _chain.object;
                var context = scope.maybeGenerateMemoised(object);

                if (context) {
                  chain.object = assignmentExpression("=", context, object);
                } else if (isSuper(object)) {
                  context = thisExpression();
                } else {
                  context = object;
                }

                _node.arguments.unshift(cloneNode(context));

                _node.callee = memberExpression(_node.callee, identifier("call"));
              }
            }

            var replacement = replacementPath.node;

            if (i === 0 && parentIsCall) {
              var _baseRef;

              var _object = skipTransparentExprWrappers(replacementPath.get("object")).node;
              var baseRef = void 0;

              if (!loose || !isSimpleMemberExpression(_object)) {
                baseRef = scope.maybeGenerateMemoised(_object);

                if (baseRef) {
                  replacement.object = assignmentExpression("=", baseRef, _object);
                }
              }

              replacement = callExpression(memberExpression(replacement, identifier("bind")), [cloneNode((_baseRef = baseRef) != null ? _baseRef : _object)]);
            }

            if (willReplacementCastToBoolean) {
              var nonNullishCheck = loose ? ast(_templateObject2$4(), cloneNode(check)) : ast(_templateObject3$4(), cloneNode(check), cloneNode(ref));
              replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, replacement));
              replacementPath = skipTransparentExprWrappers(replacementPath.get("right"));
            } else {
              var nullishCheck = loose ? ast(_templateObject4$4(), cloneNode(check)) : ast(_templateObject5$3(), cloneNode(check), cloneNode(ref));
              var returnValue = isDeleteOperation ? ast(_templateObject6$3()) : ast(_templateObject7$3());
              replacementPath.replaceWith(conditionalExpression(nullishCheck, returnValue, replacement));
              replacementPath = skipTransparentExprWrappers(replacementPath.get("alternate"));
            }
          }
        }
      }
    };
  });

  var buildOptimizedSequenceExpression = function buildOptimizedSequenceExpression(_ref) {
    var assign = _ref.assign,
        call = _ref.call,
        path = _ref.path;
    var placeholderNode = assign.left,
        pipelineLeft = assign.right;
    var calledExpression = call.callee;
    var optimizeArrow = isArrowFunctionExpression(calledExpression) && isExpression(calledExpression.body) && !calledExpression.async && !calledExpression.generator;
    var param;

    if (optimizeArrow) {
      var params = calledExpression.params;

      if (params.length === 1 && isIdentifier(params[0])) {
        param = params[0];
      } else if (params.length > 0) {
        optimizeArrow = false;
      }
    } else if (isIdentifier(calledExpression, {
      name: "eval"
    })) {
      var evalSequence = sequenceExpression([numericLiteral(0), calledExpression]);
      call.callee = evalSequence;
      path.scope.push({
        id: cloneNode(placeholderNode)
      });
      return sequenceExpression([assign, call]);
    }

    if (optimizeArrow && !param) {
      return sequenceExpression([pipelineLeft, calledExpression.body]);
    }

    path.scope.push({
      id: cloneNode(placeholderNode)
    });

    if (param) {
      path.get("right").scope.rename(param.name, placeholderNode.name);
      return sequenceExpression([assign, calledExpression.body]);
    }

    return sequenceExpression([assign, call]);
  };

  var minimalVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = callExpression(right, [cloneNode(placeholder)]);
      path.replaceWith(buildOptimizedSequenceExpression({
        assign: assignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      }));
    }
  };

  var updateTopicReferenceVisitor = {
    PipelinePrimaryTopicReference: function PipelinePrimaryTopicReference(path) {
      path.replaceWith(cloneNode(this.topicId));
    },
    PipelineTopicExpression: function PipelineTopicExpression(path) {
      path.skip();
    }
  };
  var smartVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope;
      var node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      scope.push({
        id: placeholder
      });
      var call;

      if (isPipelineTopicExpression(right)) {
        path.get("right").traverse(updateTopicReferenceVisitor, {
          topicId: placeholder
        });
        call = right.expression;
      } else {
        var callee = right.callee;

        if (isIdentifier(callee, {
          name: "eval"
        })) {
          callee = sequenceExpression([numericLiteral(0), callee]);
        }

        call = callExpression(callee, [cloneNode(placeholder)]);
      }

      path.replaceWith(sequenceExpression([assignmentExpression("=", cloneNode(placeholder), left), call]));
    }
  };

  var fsharpVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = right.type === "AwaitExpression" ? awaitExpression(cloneNode(placeholder)) : callExpression(right, [cloneNode(placeholder)]);
      var sequence = buildOptimizedSequenceExpression({
        assign: assignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      });
      path.replaceWith(sequence);
    }
  };

  var visitorsPerProposal = {
    minimal: minimalVisitor,
    smart: smartVisitor,
    fsharp: fsharpVisitor
  };
  var proposalPipelineOperator = declare(function (api, options) {
    api.assertVersion(7);
    return {
      name: "proposal-pipeline-operator",
      inherits: syntaxPipelineOperator,
      visitor: visitorsPerProposal[options.proposal]
    };
  });

  var proposalPrivateMethods = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-private-methods",
      feature: FEATURES.privateMethods,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classPrivateMethods");
      }
    });
  });

  var proposalPrivatePropertyInObject = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-class-properties",
      feature: FEATURES.privateIn,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("privateIn");
      }
    });
  });

  var syntaxThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-throw-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("throwExpressions");
      }
    };
  });

  var proposalThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-throw-expressions",
      inherits: syntaxThrowExpressions,
      visitor: {
        UnaryExpression: function UnaryExpression(path) {
          var _path$node = path.node,
              operator = _path$node.operator,
              argument = _path$node.argument;
          if (operator !== "throw") return;
          var arrow = functionExpression(null, [identifier("e")], blockStatement([throwStatement(identifier("e"))]));
          path.replaceWith(callExpression(arrow, [argument]));
        }
      }
    };
  });

  var regjsgen = createCommonjsModule(function (module, exports) {
  (function () {

    var objectTypes = {
      'function': true,
      'object': true
    };
    var root = objectTypes[typeof window] && window || this;
    var freeExports = objectTypes['object'] && exports && !exports.nodeType && exports;
    var hasFreeModule = objectTypes['object'] && module && !module.nodeType;
    var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;

    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
      root = freeGlobal;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function fromCodePoint() {
      var codePoint = Number(arguments[0]);

      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) != codePoint) {
          throw RangeError('Invalid code point: ' + codePoint);
        }

      if (codePoint <= 0xFFFF) {
        return String.fromCharCode(codePoint);
      } else {
        codePoint -= 0x10000;
        var highSurrogate = (codePoint >> 10) + 0xD800;
        var lowSurrogate = codePoint % 0x400 + 0xDC00;
        return String.fromCharCode(highSurrogate, lowSurrogate);
      }
    }

    var assertTypeRegexMap = {};

    function assertType(type, expected) {
      if (expected.indexOf('|') == -1) {
        if (type == expected) {
          return;
        }

        throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
      }

      expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

      if (expected.test(type)) {
        return;
      }

      throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
    }

    function generate(node) {
      var type = node.type;

      if (hasOwnProperty.call(generators, type)) {
        return generators[type](node);
      }

      throw Error('Invalid node type: ' + type);
    }

    function generateAlternative(node) {
      assertType(node.type, 'alternative');
      var terms = node.body,
          i = -1,
          length = terms.length,
          result = '';

      while (++i < length) {
        result += generateTerm(terms[i]);
      }

      return result;
    }

    function generateAnchor(node) {
      assertType(node.type, 'anchor');

      switch (node.kind) {
        case 'start':
          return '^';

        case 'end':
          return '$';

        case 'boundary':
          return '\\b';

        case 'not-boundary':
          return '\\B';

        default:
          throw Error('Invalid assertion');
      }
    }

    function generateAtom(node) {
      assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
      return generate(node);
    }

    function generateCharacterClass(node) {
      assertType(node.type, 'characterClass');
      var classRanges = node.body,
          i = -1,
          length = classRanges.length,
          result = '';

      if (node.negative) {
        result += '^';
      }

      while (++i < length) {
        result += generateClassAtom(classRanges[i]);
      }

      return '[' + result + ']';
    }

    function generateCharacterClassEscape(node) {
      assertType(node.type, 'characterClassEscape');
      return '\\' + node.value;
    }

    function generateUnicodePropertyEscape(node) {
      assertType(node.type, 'unicodePropertyEscape');
      return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
    }

    function generateCharacterClassRange(node) {
      assertType(node.type, 'characterClassRange');
      var min = node.min,
          max = node.max;

      if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
        throw Error('Invalid character class range');
      }

      return generateClassAtom(min) + '-' + generateClassAtom(max);
    }

    function generateClassAtom(node) {
      assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
      return generate(node);
    }

    function generateDisjunction(node) {
      assertType(node.type, 'disjunction');
      var body = node.body,
          i = -1,
          length = body.length,
          result = '';

      while (++i < length) {
        if (i != 0) {
          result += '|';
        }

        result += generate(body[i]);
      }

      return result;
    }

    function generateDot(node) {
      assertType(node.type, 'dot');
      return '.';
    }

    function generateGroup(node) {
      assertType(node.type, 'group');
      var result = '';

      switch (node.behavior) {
        case 'normal':
          if (node.name) {
            result += '?<' + generateIdentifier(node.name) + '>';
          }

          break;

        case 'ignore':
          result += '?:';
          break;

        case 'lookahead':
          result += '?=';
          break;

        case 'negativeLookahead':
          result += '?!';
          break;

        case 'lookbehind':
          result += '?<=';
          break;

        case 'negativeLookbehind':
          result += '?<!';
          break;

        default:
          throw Error('Invalid behaviour: ' + node.behaviour);
      }

      var body = node.body,
          i = -1,
          length = body.length;

      while (++i < length) {
        result += generate(body[i]);
      }

      return '(' + result + ')';
    }

    function generateIdentifier(node) {
      assertType(node.type, 'identifier');
      return node.value;
    }

    function generateQuantifier(node) {
      assertType(node.type, 'quantifier');
      var quantifier = '',
          min = node.min,
          max = node.max;

      if (max == null) {
        if (min == 0) {
          quantifier = '*';
        } else if (min == 1) {
          quantifier = '+';
        } else {
          quantifier = '{' + min + ',}';
        }
      } else if (min == max) {
        quantifier = '{' + min + '}';
      } else if (min == 0 && max == 1) {
        quantifier = '?';
      } else {
        quantifier = '{' + min + ',' + max + '}';
      }

      if (!node.greedy) {
        quantifier += '?';
      }

      return generateAtom(node.body[0]) + quantifier;
    }

    function generateReference(node) {
      assertType(node.type, 'reference');

      if (node.matchIndex) {
        return '\\' + node.matchIndex;
      }

      if (node.name) {
        return '\\k<' + generateIdentifier(node.name) + '>';
      }

      throw new Error('Unknown reference type');
    }

    function generateTerm(node) {
      assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
      return generate(node);
    }

    function generateValue(node) {
      assertType(node.type, 'value');
      var kind = node.kind,
          codePoint = node.codePoint;

      if (typeof codePoint != 'number') {
        throw new Error('Invalid code point: ' + codePoint);
      }

      switch (kind) {
        case 'controlLetter':
          return '\\c' + fromCodePoint(codePoint + 64);

        case 'hexadecimalEscape':
          return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

        case 'identifier':
          return '\\' + fromCodePoint(codePoint);

        case 'null':
          return '\\' + codePoint;

        case 'octal':
          return '\\' + codePoint.toString(8);

        case 'singleEscape':
          switch (codePoint) {
            case 0x0008:
              return '\\b';

            case 0x0009:
              return '\\t';

            case 0x000A:
              return '\\n';

            case 0x000B:
              return '\\v';

            case 0x000C:
              return '\\f';

            case 0x000D:
              return '\\r';

            default:
              throw Error('Invalid code point: ' + codePoint);
          }

        case 'symbol':
          return fromCodePoint(codePoint);

        case 'unicodeEscape':
          return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

        case 'unicodeCodePointEscape':
          return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

        default:
          throw Error('Unsupported node kind: ' + kind);
      }
    }

    var generators = {
      'alternative': generateAlternative,
      'anchor': generateAnchor,
      'characterClass': generateCharacterClass,
      'characterClassEscape': generateCharacterClassEscape,
      'characterClassRange': generateCharacterClassRange,
      'unicodePropertyEscape': generateUnicodePropertyEscape,
      'disjunction': generateDisjunction,
      'dot': generateDot,
      'group': generateGroup,
      'quantifier': generateQuantifier,
      'reference': generateReference,
      'value': generateValue
    };
    var regjsgen = {
      'generate': generate
    };

    if (freeExports && hasFreeModule) {
        freeExports.generate = generate;
      } else {
        root.regjsgen = regjsgen;
      }
  }).call(commonjsGlobal);
  });

  var parser$1 = createCommonjsModule(function (module) {
  (function () {
    var fromCodePoint = String.fromCodePoint || function () {
      var stringFromCharCode = String.fromCharCode;
      var floor = Math.floor;
      return function fromCodePoint() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;

        if (!length) {
          return '';
        }

        var result = '';

        while (++index < length) {
          var codePoint = Number(arguments[index]);

          if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
              throw RangeError('Invalid code point: ' + codePoint);
            }

          if (codePoint <= 0xFFFF) {
            codeUnits.push(codePoint);
          } else {
            codePoint -= 0x10000;
            highSurrogate = (codePoint >> 10) + 0xD800;
            lowSurrogate = codePoint % 0x400 + 0xDC00;
            codeUnits.push(highSurrogate, lowSurrogate);
          }

          if (index + 1 == length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits);
            codeUnits.length = 0;
          }
        }

        return result;
      };
    }();

    function parse(str, flags, features) {
      if (!features) {
        features = {};
      }

      function addRaw(node) {
        node.raw = str.substring(node.range[0], node.range[1]);
        return node;
      }

      function updateRawStart(node, start) {
        node.range[0] = start;
        return addRaw(node);
      }

      function createAnchor(kind, rawLength) {
        return addRaw({
          type: 'anchor',
          kind: kind,
          range: [pos - rawLength, pos]
        });
      }

      function createValue(kind, codePoint, from, to) {
        return addRaw({
          type: 'value',
          kind: kind,
          codePoint: codePoint,
          range: [from, to]
        });
      }

      function createEscaped(kind, codePoint, value, fromOffset) {
        fromOffset = fromOffset || 0;
        return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
      }

      function createCharacter(matches) {
        var _char = matches[0];

        var first = _char.charCodeAt(0);

        if (hasUnicodeFlag) {
          var second;

          if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
            second = lookahead().charCodeAt(0);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              pos++;
              return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
            }
          }
        }

        return createValue('symbol', first, pos - 1, pos);
      }

      function createDisjunction(alternatives, from, to) {
        return addRaw({
          type: 'disjunction',
          body: alternatives,
          range: [from, to]
        });
      }

      function createDot() {
        return addRaw({
          type: 'dot',
          range: [pos - 1, pos]
        });
      }

      function createCharacterClassEscape(value) {
        return addRaw({
          type: 'characterClassEscape',
          value: value,
          range: [pos - 2, pos]
        });
      }

      function createReference(matchIndex) {
        return addRaw({
          type: 'reference',
          matchIndex: parseInt(matchIndex, 10),
          range: [pos - 1 - matchIndex.length, pos]
        });
      }

      function createNamedReference(name) {
        return addRaw({
          type: 'reference',
          name: name,
          range: [name.range[0] - 3, pos]
        });
      }

      function createGroup(behavior, disjunction, from, to) {
        return addRaw({
          type: 'group',
          behavior: behavior,
          body: disjunction,
          range: [from, to]
        });
      }

      function createQuantifier(min, max, from, to) {
        if (to == null) {
          from = pos - 1;
          to = pos;
        }

        return addRaw({
          type: 'quantifier',
          min: min,
          max: max,
          greedy: true,
          body: null,
          range: [from, to]
        });
      }

      function createAlternative(terms, from, to) {
        return addRaw({
          type: 'alternative',
          body: terms,
          range: [from, to]
        });
      }

      function createCharacterClass(classRanges, negative, from, to) {
        return addRaw({
          type: 'characterClass',
          body: classRanges,
          negative: negative,
          range: [from, to]
        });
      }

      function createClassRange(min, max, from, to) {
        if (min.codePoint > max.codePoint) {
          bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
        }

        return addRaw({
          type: 'characterClassRange',
          min: min,
          max: max,
          range: [from, to]
        });
      }

      function flattenBody(body) {
        if (body.type === 'alternative') {
          return body.body;
        } else {
          return [body];
        }
      }

      function incr(amount) {
        amount = amount || 1;
        var res = str.substring(pos, pos + amount);
        pos += amount || 1;
        return res;
      }

      function skip(value) {
        if (!match(value)) {
          bail('character', value);
        }
      }

      function match(value) {
        if (str.indexOf(value, pos) === pos) {
          return incr(value.length);
        }
      }

      function lookahead() {
        return str[pos];
      }

      function current(value) {
        return str.indexOf(value, pos) === pos;
      }

      function next(value) {
        return str[pos + 1] === value;
      }

      function matchReg(regExp) {
        var subStr = str.substring(pos);
        var res = subStr.match(regExp);

        if (res) {
          res.range = [];
          res.range[0] = pos;
          incr(res[0].length);
          res.range[1] = pos;
        }

        return res;
      }

      function parseDisjunction() {
        var res = [],
            from = pos;
        res.push(parseAlternative());

        while (match('|')) {
          res.push(parseAlternative());
        }

        if (res.length === 1) {
          return res[0];
        }

        return createDisjunction(res, from, pos);
      }

      function parseAlternative() {
        var res = [],
            from = pos;
        var term;

        while (term = parseTerm()) {
          res.push(term);
        }

        if (res.length === 1) {
          return res[0];
        }

        return createAlternative(res, from, pos);
      }

      function parseTerm() {
        if (pos >= str.length || current('|') || current(')')) {
          return null;
        }

        var anchor = parseAnchor();

        if (anchor) {
          return anchor;
        }

        var atom = parseAtomAndExtendedAtom();

        if (!atom) {
          bail('Expected atom');
        }

        var quantifier = parseQuantifier() || false;

        if (quantifier) {
          quantifier.body = flattenBody(atom);
          updateRawStart(quantifier, atom.range[0]);
          return quantifier;
        }

        return atom;
      }

      function parseGroup(matchA, typeA, matchB, typeB) {
        var type = null,
            from = pos;

        if (match(matchA)) {
          type = typeA;
        } else if (match(matchB)) {
          type = typeB;
        } else {
          return false;
        }

        return finishGroup(type, from);
      }

      function finishGroup(type, from) {
        var body = parseDisjunction();

        if (!body) {
          bail('Expected disjunction');
        }

        skip(')');
        var group = createGroup(type, flattenBody(body), from, pos);

        if (type == 'normal') {
          if (firstIteration) {
            closedCaptureCounter++;
          }
        }

        return group;
      }

      function parseAnchor() {

        if (match('^')) {
          return createAnchor('start', 1);
        } else if (match('$')) {
          return createAnchor('end', 1);
        } else if (match('\\b')) {
          return createAnchor('boundary', 2);
        } else if (match('\\B')) {
          return createAnchor('not-boundary', 2);
        } else {
          return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
        }
      }

      function parseQuantifier() {
        var res,
            from = pos;
        var quantifier;
        var min, max;

        if (match('*')) {
          quantifier = createQuantifier(0);
        } else if (match('+')) {
          quantifier = createQuantifier(1);
        } else if (match('?')) {
          quantifier = createQuantifier(0, 1);
        } else if (res = matchReg(/^\{([0-9]+)\}/)) {
          min = parseInt(res[1], 10);
          quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
        } else if (res = matchReg(/^\{([0-9]+),\}/)) {
          min = parseInt(res[1], 10);
          quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
        } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
          min = parseInt(res[1], 10);
          max = parseInt(res[2], 10);

          if (min > max) {
            bail('numbers out of order in {} quantifier', '', from, pos);
          }

          quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
        }

        if (quantifier) {
          if (match('?')) {
            quantifier.greedy = false;
            quantifier.range[1] += 1;
          }
        }

        return quantifier;
      }

      function parseAtomAndExtendedAtom() {
        var res;

        if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
          return createCharacter(res);
        } else if (!hasUnicodeFlag && (res = matchReg(/^(?:]|})/))) {
          return createCharacter(res);
        } else if (match('.')) {
          return createDot();
        } else if (match('\\')) {
          res = parseAtomEscape();

          if (!res) {
            if (!hasUnicodeFlag && lookahead() == 'c') {
              return createValue('symbol', 92, pos - 1, pos);
            }

            bail('atomEscape');
          }

          return res;
        } else if (res = parseCharacterClass()) {
          return res;
        } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
          return res;
        } else if (features.namedGroups && match("(?<")) {
          var name = parseIdentifier();
          skip(">");
          var group = finishGroup("normal", name.range[0] - 3);
          group.name = name;
          return group;
        } else {
          return parseGroup('(?:', 'ignore', '(', 'normal');
        }
      }

      function parseUnicodeSurrogatePairEscape(firstEscape) {
        if (hasUnicodeFlag) {
          var first, second;

          if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
            var prevPos = pos;
            pos++;
            var secondEscape = parseClassEscape();

            if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
              firstEscape.range[1] = secondEscape.range[1];
              firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
              firstEscape.type = 'value';
              firstEscape.kind = 'unicodeCodePointEscape';
              addRaw(firstEscape);
            } else {
              pos = prevPos;
            }
          }
        }

        return firstEscape;
      }

      function parseClassEscape() {
        return parseAtomEscape(true);
      }

      function parseAtomEscape(insideCharacterClass) {
        var res,
            from = pos;
        res = parseDecimalEscape() || parseNamedReference();

        if (res) {
          return res;
        }

        if (insideCharacterClass) {
          if (match('b')) {
            return createEscaped('singleEscape', 0x0008, '\\b');
          } else if (match('B')) {
            bail('\\B not possible inside of CharacterClass', '', from);
          } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
            return createEscaped('controlLetter', res[1] + 16, res[1], 2);
          }

          if (match('-') && hasUnicodeFlag) {
            return createEscaped('singleEscape', 0x002d, '\\-');
          }
        }

        res = parseCharacterEscape();
        return res;
      }

      function parseDecimalEscape() {
        var res, match;

        if (res = matchReg(/^(?!0)\d+/)) {
          match = res[0];
          var refIdx = parseInt(res[0], 10);

          if (refIdx <= closedCaptureCounter) {
            return createReference(res[0]);
          } else {
            backrefDenied.push(refIdx);
            incr(-res[0].length);

            if (res = matchReg(/^[0-7]{1,3}/)) {
              return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
            } else {
              res = createCharacter(matchReg(/^[89]/));
              return updateRawStart(res, res.range[0] - 1);
            }
          }
        } else if (res = matchReg(/^[0-7]{1,3}/)) {
            match = res[0];

            if (/^0{1,3}$/.test(match)) {
              return createEscaped('null', 0x0000, '0', match.length + 1);
            } else {
              return createEscaped('octal', parseInt(match, 8), match, 1);
            }
          } else if (res = matchReg(/^[dDsSwW]/)) {
            return createCharacterClassEscape(res[0]);
          }

        return false;
      }

      function parseNamedReference() {
        if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
          var name = parseIdentifier();
          skip('>');
          return createNamedReference(name);
        }
      }

      function parseRegExpUnicodeEscapeSequence() {
        var res;

        if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
          return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
        } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
          return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
        }
      }

      function parseCharacterEscape() {
        var res;
        var from = pos;

        if (res = matchReg(/^[fnrtv]/)) {
          var codePoint = 0;

          switch (res[0]) {
            case 't':
              codePoint = 0x009;
              break;

            case 'n':
              codePoint = 0x00A;
              break;

            case 'v':
              codePoint = 0x00B;
              break;

            case 'f':
              codePoint = 0x00C;
              break;

            case 'r':
              codePoint = 0x00D;
              break;
          }

          return createEscaped('singleEscape', codePoint, '\\' + res[0]);
        } else if (res = matchReg(/^c([a-zA-Z])/)) {
          return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
        } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
          return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
        } else if (res = parseRegExpUnicodeEscapeSequence()) {
          if (!res || res.codePoint > 0x10FFFF) {
            bail('Invalid escape sequence', null, from, pos);
          }

          return res;
        } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
          return addRaw({
            type: 'unicodePropertyEscape',
            negative: res[1] === 'P',
            value: res[2],
            range: [res.range[0] - 1, res.range[1]],
            raw: res[0]
          });
        } else {
          return parseIdentityEscape();
        }
      }

      function parseIdentifierAtom(check) {
        var ch = lookahead();
        var from = pos;

        if (ch === '\\') {
          incr();
          var esc = parseRegExpUnicodeEscapeSequence();

          if (!esc || !check(esc.codePoint)) {
            bail('Invalid escape sequence', null, from, pos);
          }

          return fromCodePoint(esc.codePoint);
        }

        var code = ch.charCodeAt(0);

        if (code >= 0xD800 && code <= 0xDBFF) {
          ch += str[pos + 1];
          var second = ch.charCodeAt(1);

          if (second >= 0xDC00 && second <= 0xDFFF) {
            code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
          }
        }

        if (!check(code)) return;
        incr();
        if (code > 0xFFFF) incr();
        return ch;
      }

      function parseIdentifier() {
        var start = pos;
        var res = parseIdentifierAtom(isIdentifierStart);

        if (!res) {
          bail('Invalid identifier');
        }

        var ch;

        while (ch = parseIdentifierAtom(isIdentifierPart)) {
          res += ch;
        }

        return addRaw({
          type: 'identifier',
          value: res,
          range: [start, pos]
        });
      }

      function isIdentifierStart(ch) {
        var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
        return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPart(ch) {
        var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
        return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
      }

      function parseIdentityEscape() {
        var tmp;
        var l = lookahead();

        if (hasUnicodeFlag && /[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/.test(l) || !hasUnicodeFlag && l !== "c") {
          if (l === "k" && features.lookbehind) {
            return null;
          }

          tmp = incr();
          return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
        }

        return null;
      }

      function parseCharacterClass() {
        var res,
            from = pos;

        if (res = matchReg(/^\[\^/)) {
          res = parseClassRanges();
          skip(']');
          return createCharacterClass(res, true, from, pos);
        } else if (match('[')) {
          res = parseClassRanges();
          skip(']');
          return createCharacterClass(res, false, from, pos);
        }

        return null;
      }

      function parseClassRanges() {
        var res;

        if (current(']')) {
          return [];
        } else {
          res = parseNonemptyClassRanges();

          if (!res) {
            bail('nonEmptyClassRanges');
          }

          return res;
        }
      }

      function parseHelperClassRanges(atom) {
        var from, to, res;

        if (current('-') && !next(']')) {
          skip('-');
          res = parseClassAtom();

          if (!res) {
            bail('classAtom');
          }

          to = pos;
          var classRanges = parseClassRanges();

          if (!classRanges) {
            bail('classRanges');
          }

          from = atom.range[0];

          if (classRanges.type === 'empty') {
            return [createClassRange(atom, res, from, to)];
          }

          return [createClassRange(atom, res, from, to)].concat(classRanges);
        }

        res = parseNonemptyClassRangesNoDash();

        if (!res) {
          bail('nonEmptyClassRangesNoDash');
        }

        return [atom].concat(res);
      }

      function parseNonemptyClassRanges() {
        var atom = parseClassAtom();

        if (!atom) {
          bail('classAtom');
        }

        if (current(']')) {
          return [atom];
        }

        return parseHelperClassRanges(atom);
      }

      function parseNonemptyClassRangesNoDash() {
        var res = parseClassAtom();

        if (!res) {
          bail('classAtom');
        }

        if (current(']')) {
          return res;
        }

        return parseHelperClassRanges(res);
      }

      function parseClassAtom() {
        if (match('-')) {
          return createCharacter('-');
        } else {
          return parseClassAtomNoDash();
        }
      }

      function parseClassAtomNoDash() {
        var res;

        if (res = matchReg(/^[^\\\]-]/)) {
          return createCharacter(res[0]);
        } else if (match('\\')) {
          res = parseClassEscape();

          if (!res) {
            bail('classEscape');
          }

          return parseUnicodeSurrogatePairEscape(res);
        }
      }

      function bail(message, details, from, to) {
        from = from == null ? pos : from;
        to = to == null ? from : to;
        var contextStart = Math.max(0, from - 10);
        var contextEnd = Math.min(to + 10, str.length);
        var context = '    ' + str.substring(contextStart, contextEnd);
        var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
        throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
      }

      var backrefDenied = [];
      var closedCaptureCounter = 0;
      var firstIteration = true;
      var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
      var pos = 0;
      str = String(str);

      if (str === '') {
        str = '(?:)';
      }

      var result = parseDisjunction();

      if (result.range[1] !== str.length) {
        bail('Could not parse entire input - got stuck', '', result.range[1]);
      }

      for (var i = 0; i < backrefDenied.length; i++) {
        if (backrefDenied[i] <= closedCaptureCounter) {
          pos = 0;
          firstIteration = false;
          return parseDisjunction();
        }
      }

      return result;
    }

    var regjsparser = {
      parse: parse
    };

    if ( module.exports) {
      module.exports = regjsparser;
    } else {
      window.regjsparser = regjsparser;
    }
  })();
  });

  var regenerate = createCommonjsModule(function (module, exports) {

  (function (root) {
    var freeExports =  exports;
    var freeModule =  module && module.exports == freeExports && module;
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      root = freeGlobal;
    }

    var ERRORS = {
      'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
      'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
    };
    var HIGH_SURROGATE_MIN = 0xD800;
    var HIGH_SURROGATE_MAX = 0xDBFF;
    var LOW_SURROGATE_MIN = 0xDC00;
    var LOW_SURROGATE_MAX = 0xDFFF;
    var regexNull = /\\x00([^0123456789]|$)/g;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;

    var extend = function extend(destination, source) {
      var key;

      for (key in source) {
        if (hasOwnProperty.call(source, key)) {
          destination[key] = source[key];
        }
      }

      return destination;
    };

    var forEach = function forEach(array, callback) {
      var index = -1;
      var length = array.length;

      while (++index < length) {
        callback(array[index], index);
      }
    };

    var toString = object.toString;

    var isArray = function isArray(value) {
      return toString.call(value) == '[object Array]';
    };

    var isNumber = function isNumber(value) {
      return typeof value == 'number' || toString.call(value) == '[object Number]';
    };

    var zeroes = '0000';

    var pad = function pad(number, totalCharacters) {
      var string = String(number);
      return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
    };

    var hex = function hex(number) {
      return Number(number).toString(16).toUpperCase();
    };

    var slice = [].slice;

    var dataFromCodePoints = function dataFromCodePoints(codePoints) {
      var index = -1;
      var length = codePoints.length;
      var max = length - 1;
      var result = [];
      var isStart = true;
      var tmp;
      var previous = 0;

      while (++index < length) {
        tmp = codePoints[index];

        if (isStart) {
          result.push(tmp);
          previous = tmp;
          isStart = false;
        } else {
          if (tmp == previous + 1) {
            if (index != max) {
              previous = tmp;
              continue;
            } else {
              isStart = true;
              result.push(tmp + 1);
            }
          } else {
            result.push(previous + 1, tmp);
            previous = tmp;
          }
        }
      }

      if (!isStart) {
        result.push(tmp + 1);
      }

      return result;
    };

    var dataRemove = function dataRemove(data, codePoint) {
      var index = 0;
      var start;
      var end;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          if (codePoint == start) {
            if (end == start + 1) {
              data.splice(index, 2);
              return data;
            } else {
              data[index] = codePoint + 1;
              return data;
            }
          } else if (codePoint == end - 1) {
            data[index + 1] = codePoint;
            return data;
          } else {
            data.splice(index, 2, start, codePoint, codePoint + 1, end);
            return data;
          }
        }

        index += 2;
      }

      return data;
    };

    var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
      if (rangeEnd < rangeStart) {
        throw Error(ERRORS.rangeOrder);
      }

      var index = 0;
      var start;
      var end;

      while (index < data.length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start > rangeEnd) {
          return data;
        }

        if (rangeStart <= start && rangeEnd >= end) {
          data.splice(index, 2);
          continue;
        }

        if (rangeStart >= start && rangeEnd < end) {
          if (rangeStart == start) {
            data[index] = rangeEnd + 1;
            data[index + 1] = end + 1;
            return data;
          }

          data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
          return data;
        }

        if (rangeStart >= start && rangeStart <= end) {
          data[index + 1] = rangeStart;
        } else if (rangeEnd >= start && rangeEnd <= end) {
            data[index] = rangeEnd + 1;
            return data;
          }

        index += 2;
      }

      return data;
    };

    var dataAdd = function dataAdd(data, codePoint) {
      var index = 0;
      var start;
      var end;
      var lastIndex = null;
      var length = data.length;

      if (codePoint < 0x0 || codePoint > 0x10FFFF) {
        throw RangeError(ERRORS.codePointRange);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          return data;
        }

        if (codePoint == start - 1) {
          data[index] = codePoint;
          return data;
        }

        if (start > codePoint) {
          data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
          return data;
        }

        if (codePoint == end) {
          if (codePoint + 1 == data[index + 2]) {
            data.splice(index, 4, start, data[index + 3]);
            return data;
          }

          data[index + 1] = codePoint + 1;
          return data;
        }

        lastIndex = index;
        index += 2;
      }

      data.push(codePoint, codePoint + 1);
      return data;
    };

    var dataAddData = function dataAddData(dataA, dataB) {
      var index = 0;
      var start;
      var end;
      var data = dataA.slice();
      var length = dataB.length;

      while (index < length) {
        start = dataB[index];
        end = dataB[index + 1] - 1;

        if (start == end) {
          data = dataAdd(data, start);
        } else {
          data = dataAddRange(data, start, end);
        }

        index += 2;
      }

      return data;
    };

    var dataRemoveData = function dataRemoveData(dataA, dataB) {
      var index = 0;
      var start;
      var end;
      var data = dataA.slice();
      var length = dataB.length;

      while (index < length) {
        start = dataB[index];
        end = dataB[index + 1] - 1;

        if (start == end) {
          data = dataRemove(data, start);
        } else {
          data = dataRemoveRange(data, start, end);
        }

        index += 2;
      }

      return data;
    };

    var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
      if (rangeEnd < rangeStart) {
        throw Error(ERRORS.rangeOrder);
      }

      if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
        throw RangeError(ERRORS.codePointRange);
      }

      var index = 0;
      var start;
      var end;
      var added = false;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (added) {
          if (start == rangeEnd + 1) {
            data.splice(index - 1, 2);
            return data;
          }

          if (start > rangeEnd) {
            return data;
          }

          if (start >= rangeStart && start <= rangeEnd) {
            if (end > rangeStart && end - 1 <= rangeEnd) {
              data.splice(index, 2);
              index -= 2;
            } else {
              data.splice(index - 1, 2);
              index -= 2;
            }
          }
        } else if (start == rangeEnd + 1) {
          data[index] = rangeStart;
          return data;
        } else if (start > rangeEnd) {
            data.splice(index, 0, rangeStart, rangeEnd + 1);
            return data;
          } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
            return data;
          } else if (rangeStart >= start && rangeStart < end || end == rangeStart) {
            data[index + 1] = rangeEnd + 1;
            added = true;
          } else if (rangeStart <= start && rangeEnd + 1 >= end) {
            data[index] = rangeStart;
            data[index + 1] = rangeEnd + 1;
            added = true;
          }

        index += 2;
      }

      if (!added) {
        data.push(rangeStart, rangeEnd + 1);
      }

      return data;
    };

    var dataContains = function dataContains(data, codePoint) {
      var index = 0;
      var length = data.length;
      var start = data[index];
      var end = data[length - 1];

      if (length >= 2) {
        if (codePoint < start || codePoint > end) {
          return false;
        }
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        if (codePoint >= start && codePoint < end) {
          return true;
        }

        index += 2;
      }

      return false;
    };

    var dataIntersection = function dataIntersection(data, codePoints) {
      var index = 0;
      var length = codePoints.length;
      var codePoint;
      var result = [];

      while (index < length) {
        codePoint = codePoints[index];

        if (dataContains(data, codePoint)) {
          result.push(codePoint);
        }

        ++index;
      }

      return dataFromCodePoints(result);
    };

    var dataIsEmpty = function dataIsEmpty(data) {
      return !data.length;
    };

    var dataIsSingleton = function dataIsSingleton(data) {
      return data.length == 2 && data[0] + 1 == data[1];
    };

    var dataToArray = function dataToArray(data) {
      var index = 0;
      var start;
      var end;
      var result = [];
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1];

        while (start < end) {
          result.push(start);
          ++start;
        }

        index += 2;
      }

      return result;
    };

    var floor = Math.floor;

    var highSurrogate = function highSurrogate(codePoint) {
      return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
    };

    var lowSurrogate = function lowSurrogate(codePoint) {
      return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
    };

    var stringFromCharCode = String.fromCharCode;

    var codePointToString = function codePointToString(codePoint) {
      var string;

      if (codePoint == 0x09) {
        string = '\\t';
      } else if (codePoint == 0x0A) {
          string = '\\n';
        } else if (codePoint == 0x0C) {
          string = '\\f';
        } else if (codePoint == 0x0D) {
          string = '\\r';
        } else if (codePoint == 0x2D) {
          string = '\\x2D';
        } else if (codePoint == 0x5C) {
          string = '\\\\';
        } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
          string = '\\' + stringFromCharCode(codePoint);
        } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
          string = stringFromCharCode(codePoint);
        } else if (codePoint <= 0xFF) {
          string = '\\x' + pad(hex(codePoint), 2);
        } else {
          string = "\\u" + pad(hex(codePoint), 4);
        }

      return string;
    };

    var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
      if (codePoint <= 0xFFFF) {
        return codePointToString(codePoint);
      }

      return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
    };

    var symbolToCodePoint = function symbolToCodePoint(symbol) {
      var length = symbol.length;
      var first = symbol.charCodeAt(0);
      var second;

      if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
          second = symbol.charCodeAt(1);
          return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
        }

      return first;
    };

    var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
      var result = '';
      var index = 0;
      var start;
      var end;
      var length = data.length;

      if (dataIsSingleton(data)) {
        return codePointToString(data[0]);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start == end) {
          result += codePointToString(start);
        } else if (start + 1 == end) {
          result += codePointToString(start) + codePointToString(end);
        } else {
          result += codePointToString(start) + '-' + codePointToString(end);
        }

        index += 2;
      }

      return '[' + result + ']';
    };

    var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
      var result = '';
      var index = 0;
      var start;
      var end;
      var length = data.length;

      if (dataIsSingleton(data)) {
        return codePointToStringUnicode(data[0]);
      }

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start == end) {
          result += codePointToStringUnicode(start);
        } else if (start + 1 == end) {
          result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
        } else {
          result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
        }

        index += 2;
      }

      return '[' + result + ']';
    };

    var splitAtBMP = function splitAtBMP(data) {
      var loneHighSurrogates = [];
      var loneLowSurrogates = [];
      var bmp = [];
      var astral = [];
      var index = 0;
      var start;
      var end;
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;

        if (start < HIGH_SURROGATE_MIN) {
          if (end < HIGH_SURROGATE_MIN) {
            bmp.push(start, end + 1);
          }

          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
          }

          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            bmp.push(start, HIGH_SURROGATE_MIN);
            loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
          if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
            loneHighSurrogates.push(start, end + 1);
          }

          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
            loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
          if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
            loneLowSurrogates.push(start, end + 1);
          }

          if (end > LOW_SURROGATE_MAX) {
            loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

            if (end <= 0xFFFF) {
              bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
            } else {
              bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          }
        } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
          if (end <= 0xFFFF) {
            bmp.push(start, end + 1);
          } else {
            bmp.push(start, 0xFFFF + 1);
            astral.push(0xFFFF + 1, end + 1);
          }
        } else {
          astral.push(start, end + 1);
        }

        index += 2;
      }

      return {
        'loneHighSurrogates': loneHighSurrogates,
        'loneLowSurrogates': loneLowSurrogates,
        'bmp': bmp,
        'astral': astral
      };
    };

    var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
      var result = [];
      var tmpLow = [];
      var addLow = false;
      var mapping;
      var nextMapping;
      var highSurrogates;
      var lowSurrogates;
      var nextHighSurrogates;
      var nextLowSurrogates;
      var index = -1;
      var length = surrogateMappings.length;

      while (++index < length) {
        mapping = surrogateMappings[index];
        nextMapping = surrogateMappings[index + 1];

        if (!nextMapping) {
          result.push(mapping);
          continue;
        }

        highSurrogates = mapping[0];
        lowSurrogates = mapping[1];
        nextHighSurrogates = nextMapping[0];
        nextLowSurrogates = nextMapping[1];
        tmpLow = lowSurrogates;

        while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
          if (dataIsSingleton(nextLowSurrogates)) {
            tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
          } else {
            tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
          }

          ++index;
          mapping = surrogateMappings[index];
          highSurrogates = mapping[0];
          lowSurrogates = mapping[1];
          nextMapping = surrogateMappings[index + 1];
          nextHighSurrogates = nextMapping && nextMapping[0];
          nextLowSurrogates = nextMapping && nextMapping[1];
          addLow = true;
        }

        result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
        addLow = false;
      }

      return optimizeByLowSurrogates(result);
    };

    var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
      if (surrogateMappings.length == 1) {
        return surrogateMappings;
      }

      var index = -1;
      var innerIndex = -1;

      while (++index < surrogateMappings.length) {
        var mapping = surrogateMappings[index];
        var lowSurrogates = mapping[1];
        var lowSurrogateStart = lowSurrogates[0];
        var lowSurrogateEnd = lowSurrogates[1];
        innerIndex = index;

        while (++innerIndex < surrogateMappings.length) {
          var otherMapping = surrogateMappings[innerIndex];
          var otherLowSurrogates = otherMapping[1];
          var otherLowSurrogateStart = otherLowSurrogates[0];
          var otherLowSurrogateEnd = otherLowSurrogates[1];

          if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd) {
            if (dataIsSingleton(otherMapping[0])) {
              mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
            } else {
              mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
            }

            surrogateMappings.splice(innerIndex, 1);
            --innerIndex;
          }
        }
      }

      return surrogateMappings;
    };

    var surrogateSet = function surrogateSet(data) {
      if (!data.length) {
        return [];
      }

      var index = 0;
      var start;
      var end;
      var startHigh;
      var startLow;
      var endHigh;
      var endLow;
      var surrogateMappings = [];
      var length = data.length;

      while (index < length) {
        start = data[index];
        end = data[index + 1] - 1;
        startHigh = highSurrogate(start);
        startLow = lowSurrogate(start);
        endHigh = highSurrogate(end);
        endLow = lowSurrogate(end);
        var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
        var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
        var complete = false;

        if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
          surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
          complete = true;
        } else {
          surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
        }

        if (!complete && startHigh + 1 < endHigh) {
          if (endsWithHighestLowSurrogate) {
            surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
            complete = true;
          } else {
            surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
          }
        }

        if (!complete) {
          surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
        }

        index += 2;
      }

      return optimizeSurrogateMappings(surrogateMappings);
    };

    var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
      var result = [];
      forEach(surrogateMappings, function (surrogateMapping) {
        var highSurrogates = surrogateMapping[0];
        var lowSurrogates = surrogateMapping[1];
        result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
      });
      return result.join('|');
    };

    var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
      if (hasUnicodeFlag) {
        return createUnicodeCharacterClasses(data);
      }

      var result = [];
      var parts = splitAtBMP(data);
      var loneHighSurrogates = parts.loneHighSurrogates;
      var loneLowSurrogates = parts.loneLowSurrogates;
      var bmp = parts.bmp;
      var astral = parts.astral;
      var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
      var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
      var surrogateMappings = surrogateSet(astral);

      if (bmpOnly) {
        bmp = dataAddData(bmp, loneHighSurrogates);
        hasLoneHighSurrogates = false;
        bmp = dataAddData(bmp, loneLowSurrogates);
        hasLoneLowSurrogates = false;
      }

      if (!dataIsEmpty(bmp)) {
        result.push(createBMPCharacterClasses(bmp));
      }

      if (surrogateMappings.length) {
        result.push(createSurrogateCharacterClasses(surrogateMappings));
      }

      if (hasLoneHighSurrogates) {
        result.push(createBMPCharacterClasses(loneHighSurrogates) + "(?![\\uDC00-\\uDFFF])");
      }

      if (hasLoneLowSurrogates) {
        result.push("(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
      }

      return result.join('|');
    };

    var regenerate = function regenerate(value) {
      if (arguments.length > 1) {
        value = slice.call(arguments);
      }

      if (this instanceof regenerate) {
        this.data = [];
        return value ? this.add(value) : this;
      }

      return new regenerate().add(value);
    };

    regenerate.version = '1.3.3';
    var proto = regenerate.prototype;
    extend(proto, {
      'add': function add(value) {
        var $this = this;

        if (value == null) {
          return $this;
        }

        if (value instanceof regenerate) {
          $this.data = dataAddData($this.data, value.data);
          return $this;
        }

        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (isArray(value)) {
          forEach(value, function (item) {
            $this.add(item);
          });
          return $this;
        }

        $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
        return $this;
      },
      'remove': function remove(value) {
        var $this = this;

        if (value == null) {
          return $this;
        }

        if (value instanceof regenerate) {
          $this.data = dataRemoveData($this.data, value.data);
          return $this;
        }

        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (isArray(value)) {
          forEach(value, function (item) {
            $this.remove(item);
          });
          return $this;
        }

        $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
        return $this;
      },
      'addRange': function addRange(start, end) {
        var $this = this;
        $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
        return $this;
      },
      'removeRange': function removeRange(start, end) {
        var $this = this;
        var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
        var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
        $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
        return $this;
      },
      'intersection': function intersection(argument) {
        var $this = this;
        var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
        $this.data = dataIntersection($this.data, array);
        return $this;
      },
      'contains': function contains(codePoint) {
        return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
      },
      'clone': function clone() {
        var set = new regenerate();
        set.data = this.data.slice(0);
        return set;
      },
      'toString': function toString(options) {
        var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

        if (!result) {
          return '[]';
        }

        return result.replace(regexNull, '\\0$1');
      },
      'toRegExp': function toRegExp(flags) {
        var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
          'hasUnicodeFlag': true
        } : null);
        return RegExp(pattern, flags || '');
      },
      'valueOf': function valueOf() {
        return dataToArray(this.data);
      }
    });
    proto.toArray = proto.valueOf;

    if (freeExports && !freeExports.nodeType) {
      if (freeModule) {
        freeModule.exports = regenerate;
      } else {
        freeExports.regenerate = regenerate;
      }
    } else {
      root.regenerate = regenerate;
    }
  })(commonjsGlobal);
  });

  var unicodeCanonicalPropertyNamesEcmascript = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

  var unicodePropertyAliasesEcmascript = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['Ext', 'Extender'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

  var matchProperty = function matchProperty(property) {
    if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
      return property;
    }

    if (unicodePropertyAliasesEcmascript.has(property)) {
      return unicodePropertyAliasesEcmascript.get(property);
    }

    throw new Error("Unknown property: " + property);
  };

  var unicodeMatchPropertyEcmascript = matchProperty;

  var mappings = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

  var matchPropertyValue = function matchPropertyValue(property, value) {
    var aliasToValue = mappings.get(property);

    if (!aliasToValue) {
      throw new Error("Unknown property `" + property + "`.");
    }

    var canonicalValue = aliasToValue.get(value);

    if (canonicalValue) {
      return canonicalValue;
    }

    throw new Error("Unknown value `" + value + "` for property `" + property + "`.");
  };

  var unicodeMatchPropertyValueEcmascript = matchPropertyValue;

  var iuMappings = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x462, 0x1C87], [0x1C80, 0x412], [0x1C81, 0x414], [0x1C82, 0x41E], [0x1C83, 0x421], [0x1C84, 0x1C85], [0x1C85, [0x422, 0x1C84]], [0x1C86, 0x42A], [0x1C87, 0x462], [0x1C88, 0xA64A], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0xA64A, 0x1C88], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

  var REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
  var UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
  var UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);

  var characterClassEscapeSets = {
  	REGULAR: REGULAR,
  	UNICODE: UNICODE,
  	UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
  };

  var _createForOfIteratorHelperLoose$2 = require$$0$1.createForOfIteratorHelperLoose;

  var generate = regjsgen.generate;

  var parse$3 = parser$1.parse;











  var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
  var BMP_SET = regenerate().addRange(0x0, 0xFFFF);
  var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);

  var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
    if (unicode) {
      if (ignoreCase) {
        return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
      }

      return characterClassEscapeSets.UNICODE.get(character);
    }

    return characterClassEscapeSets.REGULAR.get(character);
  };

  var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
    return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
  };

  var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
    var path = value ? property + "/" + value : "Binary_Property/" + property;

    try {
      return commonjsRequire("regenerate-unicode-properties/" + path + ".js");
    } catch (exception) {
      throw new Error("Failed to recognize value `" + value + "` for property " + ("`" + property + "`."));
    }
  };

  var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
    try {
      var _property = 'General_Category';
      var category = unicodeMatchPropertyValueEcmascript(_property, value);
      return getUnicodePropertyValueSet(_property, category);
    } catch (exception) {}

    var property = unicodeMatchPropertyEcmascript(value);
    return getUnicodePropertyValueSet(property);
  };

  var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
    var parts = value.split('=');
    var firstPart = parts[0];
    var set;

    if (parts.length == 1) {
      set = handleLoneUnicodePropertyNameOrValue(firstPart);
    } else {
      var property = unicodeMatchPropertyEcmascript(firstPart);

      var _value = unicodeMatchPropertyValueEcmascript(property, parts[1]);

      set = getUnicodePropertyValueSet(property, _value);
    }

    if (isNegative) {
      return UNICODE_SET.clone().remove(set);
    }

    return set.clone();
  };

  regenerate.prototype.iuAddRange = function (min, max) {
    var $this = this;

    do {
      var folded = caseFold(min);

      if (folded) {
        $this.add(folded);
      }
    } while (++min <= max);

    return $this;
  };

  var update = function update(item, pattern) {
    var tree = parse$3(pattern, config.useUnicodeFlag ? 'u' : '');

    switch (tree.type) {
      case 'characterClass':
      case 'group':
      case 'value':
        break;

      default:
        tree = wrap$1(tree, pattern);
    }

    Object.assign(item, tree);
  };

  var wrap$1 = function wrap(tree, pattern) {
    return {
      'type': 'group',
      'behavior': 'ignore',
      'body': [tree],
      'raw': "(?:" + pattern + ")"
    };
  };

  var caseFold = function caseFold(codePoint) {
    return iuMappings.get(codePoint) || false;
  };

  var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
    var set = regenerate();

    for (var _iterator = _createForOfIteratorHelperLoose$2(characterClassItem.body), _step; !(_step = _iterator()).done;) {
      var item = _step.value;

      switch (item.type) {
        case 'value':
          set.add(item.codePoint);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            var folded = caseFold(item.codePoint);

            if (folded) {
              set.add(folded);
            }
          }

          break;

        case 'characterClassRange':
          var min = item.min.codePoint;
          var max = item.max.codePoint;
          set.addRange(min, max);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            set.iuAddRange(min, max);
          }

          break;

        case 'characterClassEscape':
          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));
          break;

        case 'unicodePropertyEscape':
          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
          break;

        default:
          throw new Error("Unknown term type: " + item.type);
      }
    }

    if (characterClassItem.negative) {
      update(characterClassItem, "(?!" + set.toString(regenerateOptions) + ")[\\s\\S]");
    } else {
      update(characterClassItem, set.toString(regenerateOptions));
    }

    return characterClassItem;
  };

  var updateNamedReference = function updateNamedReference(item, index) {
    delete item.name;
    item.matchIndex = index;
  };

  var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
    var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

    if (unmatchedReferencesNames.length > 0) {
      throw new Error("Unknown group names: " + unmatchedReferencesNames);
    }
  };

  var processTerm = function processTerm(item, regenerateOptions, groups) {
    switch (item.type) {
      case 'dot':
        if (config.useDotAllFlag) {
          break;
        } else if (config.unicode) {
          update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));
        } else if (config.dotAll) {
          update(item, '[\\s\\S]');
        }

        break;

      case 'characterClass':
        item = processCharacterClass(item, regenerateOptions);
        break;

      case 'unicodePropertyEscape':
        if (config.unicodePropertyEscape) {
          update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
        }

        break;

      case 'characterClassEscape':
        update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));
        break;

      case 'group':
        if (item.behavior == 'normal') {
          groups.lastIndex++;
        }

        if (item.name && config.namedGroup) {
          var name = item.name.value;

          if (groups.names[name]) {
            throw new Error("Multiple groups with the same name (" + name + ") are not allowed.");
          }

          var index = groups.lastIndex;
          delete item.name;
          groups.names[name] = index;

          if (groups.onNamedGroup) {
            groups.onNamedGroup.call(null, name, index);
          }

          if (groups.unmatchedReferences[name]) {
            groups.unmatchedReferences[name].forEach(function (reference) {
              updateNamedReference(reference, index);
            });
            delete groups.unmatchedReferences[name];
          }
        }

      case 'alternative':
      case 'disjunction':
      case 'quantifier':
        item.body = item.body.map(function (term) {
          return processTerm(term, regenerateOptions, groups);
        });
        break;

      case 'value':
        var codePoint = item.codePoint;
        var set = regenerate(codePoint);

        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
          var folded = caseFold(codePoint);

          if (folded) {
            set.add(folded);
          }
        }

        update(item, set.toString(regenerateOptions));
        break;

      case 'reference':
        if (item.name) {
          var _name = item.name.value;
          var _index = groups.names[_name];

          if (_index) {
            updateNamedReference(item, _index);
            break;
          }

          if (!groups.unmatchedReferences[_name]) {
            groups.unmatchedReferences[_name] = [];
          }

          groups.unmatchedReferences[_name].push(item);
        }

        break;

      case 'anchor':
      case 'empty':
      case 'group':
        break;

      default:
        throw new Error("Unknown term type: " + item.type);
    }

    return item;
  };

  var config = {
    'ignoreCase': false,
    'unicode': false,
    'dotAll': false,
    'useDotAllFlag': false,
    'useUnicodeFlag': false,
    'unicodePropertyEscape': false,
    'namedGroup': false
  };

  var rewritePattern = function rewritePattern(pattern, flags, options) {
    config.unicode = flags && flags.includes('u');
    var regjsparserFeatures = {
      'unicodePropertyEscape': config.unicode,
      'namedGroups': true,
      'lookbehind': options && options.lookbehind
    };
    config.ignoreCase = flags && flags.includes('i');
    var supportDotAllFlag = options && options.dotAllFlag;
    config.dotAll = supportDotAllFlag && flags && flags.includes('s');
    config.namedGroup = options && options.namedGroup;
    config.useDotAllFlag = options && options.useDotAllFlag;
    config.useUnicodeFlag = options && options.useUnicodeFlag;
    config.unicodePropertyEscape = options && options.unicodePropertyEscape;

    if (supportDotAllFlag && config.useDotAllFlag) {
      throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');
    }

    var regenerateOptions = {
      'hasUnicodeFlag': config.useUnicodeFlag,
      'bmpOnly': !config.unicode
    };
    var groups = {
      'onNamedGroup': options && options.onNamedGroup,
      'lastIndex': 0,
      'names': Object.create(null),
      'unmatchedReferences': Object.create(null)
    };
    var tree = parse$3(pattern, flags, regjsparserFeatures);
    processTerm(tree, regenerateOptions, groups);
    assertNoUnmatchedReferences(groups);
    return generate(tree);
  };

  var rewritePattern_1 = rewritePattern;

  var FEATURES$1 = Object.freeze({
    unicodeFlag: 1 << 0,
    dotAllFlag: 1 << 1,
    unicodePropertyEscape: 1 << 2,
    namedCaptureGroups: 1 << 3
  });
  var featuresKey$1 = "@babel/plugin-regexp-features/featuresKey";
  var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
  function enableFeature$1(features, feature) {
    return features | feature;
  }
  function hasFeature$1(features, feature) {
    return !!(features & feature);
  }

  function generateRegexpuOptions(node, features) {
    var useUnicodeFlag = false,
        dotAllFlag = false,
        unicodePropertyEscape = false,
        namedGroup = false;
    var flags = node.flags,
        pattern = node.pattern;
    var flagsIncludesU = flags.includes("u");

    if (flagsIncludesU) {
      if (!hasFeature$1(features, FEATURES$1.unicodeFlag)) {
        useUnicodeFlag = true;
      }

      if (hasFeature$1(features, FEATURES$1.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
        unicodePropertyEscape = true;
      }
    }

    if (hasFeature$1(features, FEATURES$1.dotAllFlag) && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    if (hasFeature$1(features, FEATURES$1.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
      namedGroup = true;
    }

    if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
      return null;
    }

    if (flagsIncludesU && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    return {
      useUnicodeFlag: useUnicodeFlag,
      onNamedGroup: function onNamedGroup() {},
      namedGroup: namedGroup,
      unicodePropertyEscape: unicodePropertyEscape,
      dotAllFlag: dotAllFlag,
      lookbehind: true
    };
  }

  var name$1 = "@babel/helper-create-regexp-features-plugin";
  var version$4 = "7.12.7";
  var author$1 = "The Babel Team (https://babel.dev/team)";
  var license$1 = "MIT";
  var description$1 = "Compile ESNext Regular Expressions to ES5";
  var repository$1 = {
  	type: "git",
  	url: "https://github.com/babel/babel.git",
  	directory: "packages/babel-helper-create-regexp-features-plugin"
  };
  var main$1 = "lib/index.js";
  var publishConfig$1 = {
  	access: "public"
  };
  var keywords$3 = [
  	"babel",
  	"babel-plugin"
  ];
  var dependencies$1 = {
  	"@babel/helper-annotate-as-pure": "workspace:^7.10.4",
  	"regexpu-core": "^4.7.1"
  };
  var peerDependencies$1 = {
  	"@babel/core": "^7.0.0"
  };
  var devDependencies$1 = {
  	"@babel/core": "workspace:*",
  	"@babel/helper-plugin-test-runner": "workspace:*"
  };
  var pkg$1 = {
  	name: name$1,
  	version: version$4,
  	author: author$1,
  	license: license$1,
  	description: description$1,
  	repository: repository$1,
  	main: main$1,
  	publishConfig: publishConfig$1,
  	keywords: keywords$3,
  	dependencies: dependencies$1,
  	peerDependencies: peerDependencies$1,
  	devDependencies: devDependencies$1
  };

  function pullFlag(node, flag) {
    node.flags = node.flags.replace(flag, "");
  }

  var version$5 = pkg$1.version.split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey$1 = "@babel/plugin-regexp-features/version";
  function createRegExpFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options;
    return {
      name: name,
      pre: function pre() {
        var _file$get;

        var file = this.file;
        var features = (_file$get = file.get(featuresKey$1)) != null ? _file$get : 0;
        var newFeatures = enableFeature$1(features, FEATURES$1[feature]);
        var useUnicodeFlag = options.useUnicodeFlag,
            _options$runtime = options.runtime,
            runtime = _options$runtime === void 0 ? true : _options$runtime;

        if (useUnicodeFlag === false) {
          newFeatures = enableFeature$1(newFeatures, FEATURES$1.unicodeFlag);
        }

        if (newFeatures !== features) {
          file.set(featuresKey$1, newFeatures);
        }

        if (!runtime) {
          file.set(runtimeKey, false);
        }

        if (!file.has(versionKey$1) || file.get(versionKey$1) < version$5) {
          file.set(versionKey$1, version$5);
        }
      },
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var _file$get2;

          var node = path.node;
          var file = this.file;
          var features = file.get(featuresKey$1);
          var runtime = (_file$get2 = file.get(runtimeKey)) != null ? _file$get2 : true;
          var regexpuOptions = generateRegexpuOptions(node, features);

          if (regexpuOptions === null) {
            return;
          }

          var namedCaptureGroups = {};

          if (regexpuOptions.namedGroup) {
            regexpuOptions.onNamedGroup = function (name, index) {
              namedCaptureGroups[name] = index;
            };
          }

          node.pattern = rewritePattern_1(node.pattern, node.flags, regexpuOptions);

          if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
            var call = callExpression(this.addHelper("wrapRegExp"), [node, valueToNode(namedCaptureGroups)]);
            annotateAsPure(call);
            path.replaceWith(call);
          }

          if (hasFeature$1(features, FEATURES$1.unicodeFlag)) {
            pullFlag(node, "u");
          }

          if (hasFeature$1(features, FEATURES$1.dotAllFlag)) {
            pullFlag(node, "s");
          }
        }
      }
    };
  }

  function isRegExpTest(path) {
    return path.parentPath.isMemberExpression({
      object: path.node,
      computed: false
    }) && path.parentPath.get("property").isIdentifier({
      name: "test"
    });
  }

  var proposalUnicodePropertyRegex = declare(function (api, options) {
    api.assertVersion(7);
    var _options$useUnicodeFl = options.useUnicodeFlag,
        useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

    if (typeof useUnicodeFlag !== "boolean") {
      throw new Error(".useUnicodeFlag must be a boolean, or undefined");
    }

    return createRegExpFeaturePlugin({
      name: "proposal-unicode-property-regex",
      feature: "unicodePropertyEscape",
      options: {
        useUnicodeFlag: useUnicodeFlag
      }
    });
  });

  var transformAsyncToGenerator = declare(function (api, options) {
    api.assertVersion(7);
    var method = options.method,
        module = options.module;

    if (method && module) {
      return {
        name: "transform-async-to-generator",
        visitor: {
          Function: function Function(path, state) {
            if (!path.node.async || path.node.generator) return;
            var wrapAsync = state.methodWrapper;

            if (wrapAsync) {
              wrapAsync = cloneNode(wrapAsync);
            } else {
              wrapAsync = state.methodWrapper = addNamed(path, method, module);
            }

            remapAsyncToGenerator(path, {
              wrapAsync: wrapAsync
            });
          }
        }
      };
    }

    return {
      name: "transform-async-to-generator",
      visitor: {
        Function: function Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          remapAsyncToGenerator(path, {
            wrapAsync: state.addHelper("asyncToGenerator")
          });
        }
      }
    };
  });

  var transformArrowFunctions = declare(function (api, options) {
    api.assertVersion(7);
    var spec = options.spec;
    return {
      name: "transform-arrow-functions",
      visitor: {
        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
          if (!path.isArrowFunctionExpression()) return;
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            specCompliant: !!spec
          });
        }
      }
    };
  });

  var transformBlockScopedFunctions = declare(function (api) {
    api.assertVersion(7);

    function statementList(key, path) {
      var paths = path.get(key);

      for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
        var _path = _step.value;
        var func = _path.node;
        if (!_path.isFunctionDeclaration()) continue;
        var declar = variableDeclaration("let", [variableDeclarator(func.id, toExpression(func))]);
        declar._blockHoist = 2;
        func.id = null;

        _path.replaceWith(declar);
      }
    }

    return {
      name: "transform-block-scoped-functions",
      visitor: {
        BlockStatement: function BlockStatement(path) {
          var node = path.node,
              parent = path.parent;

          if (isFunction(parent, {
            body: node
          }) || isExportDeclaration(parent)) {
            return;
          }

          statementList("body", path);
        },
        SwitchCase: function SwitchCase(path) {
          statementList("consequent", path);
        }
      }
    };
  });

  function _templateObject$a() {
    var data = _taggedTemplateLiteralLoose(["", "(\"", "\")"]);

    _templateObject$a = function _templateObject() {
      return data;
    };

    return data;
  }

  function getTDZStatus(refPath, bindingPath) {
    var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

    if (executionStatus === "before") {
      return "outside";
    } else if (executionStatus === "after") {
      return "inside";
    } else {
      return "maybe";
    }
  }

  function buildTDZAssert(node, state) {
    return callExpression(state.addHelper("temporalRef"), [node, stringLiteral(node.name)]);
  }

  function isReference(node, scope, state) {
    var declared = state.letReferences.get(node.name);
    if (!declared) return false;
    return scope.getBindingIdentifier(node.name) === declared;
  }

  var visitor$2 = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (!state.tdzEnabled) return;
      var node = path.node,
          parent = path.parent,
          scope = path.scope;
      if (path.parentPath.isFor({
        left: node
      })) return;
      if (!isReference(node, scope, state)) return;
      var bindingPath = scope.getBinding(node.name).path;
      if (bindingPath.isFunctionDeclaration()) return;
      var status = getTDZStatus(path, bindingPath);
      if (status === "outside") return;

      if (status === "maybe") {
        var assert = buildTDZAssert(node, state);
        bindingPath.parent._tdzThis = true;
        path.skip();

        if (path.parentPath.isUpdateExpression()) {
          if (parent._ignoreBlockScopingTDZ) return;
          path.parentPath.replaceWith(sequenceExpression([assert, parent]));
        } else {
          path.replaceWith(assert);
        }
      } else if (status === "inside") {
        path.replaceWith(template.ast(_templateObject$a(), state.addHelper("tdz"), node.name));
      }
    },
    AssignmentExpression: {
      exit: function exit(path, state) {
        if (!state.tdzEnabled) return;
        var node = path.node;
        if (node._ignoreBlockScopingTDZ) return;
        var nodes = [];
        var ids = path.getBindingIdentifiers();

        for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          var id = ids[name];

          if (isReference(id, path.scope, state)) {
            nodes.push(id);
          }
        }

        if (nodes.length) {
          node._ignoreBlockScopingTDZ = true;
          nodes.push(node);
          path.replaceWithMultiple(nodes.map(function (n) {
            return expressionStatement(n);
          }));
        }
      }
    }
  };

  var DONE = new WeakSet();
  var transformBlockScoping = declare(function (api, opts) {
    api.assertVersion(7);
    var _opts$throwIfClosureR = opts.throwIfClosureRequired,
        throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
        _opts$tdz = opts.tdz,
        tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

    if (typeof throwIfClosureRequired !== "boolean") {
      throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
    }

    if (typeof tdzEnabled !== "boolean") {
      throw new Error(".tdz must be a boolean, or undefined");
    }

    return {
      name: "transform-block-scoping",
      visitor: {
        VariableDeclaration: function VariableDeclaration(path) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          if (!isBlockScoped$1(node)) return;
          convertBlockScopedToVar(path, null, parent, scope, true);

          if (node._tdzThis) {
            var nodes = [node];

            for (var i = 0; i < node.declarations.length; i++) {
              var decl = node.declarations[i];
              var assign = assignmentExpression("=", cloneNode(decl.id), decl.init || scope.buildUndefinedNode());
              assign._ignoreBlockScopingTDZ = true;
              nodes.push(expressionStatement(assign));
              decl.init = this.addHelper("temporalUndefined");
            }

            node._blockHoist = 2;

            if (path.isCompletionRecord()) {
              nodes.push(expressionStatement(scope.buildUndefinedNode()));
            }

            path.replaceWithMultiple(nodes);
          }
        },
        Loop: function Loop(path, state) {
          var parent = path.parent,
              scope = path.scope;
          path.ensureBlock();
          var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          var replace = blockScoping.run();
          if (replace) path.replaceWith(replace);
        },
        CatchClause: function CatchClause(path, state) {
          var parent = path.parent,
              scope = path.scope;
          var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          blockScoping.run();
        },
        "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
          if (!ignoreBlock(path)) {
            var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
            blockScoping.run();
          }
        }
      }
    };
  });

  function ignoreBlock(path) {
    return isLoop(path.parent) || isCatchClause(path.parent);
  }

  var buildRetCheck = template("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

  function isBlockScoped$1(node) {
    if (!isVariableDeclaration(node)) return false;
    if (node[BLOCK_SCOPED_SYMBOL]) return true;
    if (node.kind !== "let" && node.kind !== "const") return false;
    return true;
  }

  function isInLoop(path) {
    var loopOrFunctionParent = path.find(function (path) {
      return path.isLoop() || path.isFunction();
    });
    return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();
  }

  function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent) {
    if (moveBindingsToParent === void 0) {
      moveBindingsToParent = false;
    }

    if (!node) {
      node = path.node;
    }

    if (isInLoop(path) && !isFor(parent)) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        declar.init = declar.init || scope.buildUndefinedNode();
      }
    }

    node[BLOCK_SCOPED_SYMBOL] = true;
    node.kind = "var";

    if (moveBindingsToParent) {
      var parentScope = scope.getFunctionParent() || scope.getProgramParent();

      for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        var binding = scope.getOwnBinding(name);
        if (binding) binding.kind = "var";
        scope.moveBindingTo(name, parentScope);
      }
    }
  }

  function isVar$1(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !isBlockScoped$1(node);
  }

  var letReferenceBlockVisitor = traverse$1.visitors.merge([{
    Loop: {
      enter: function enter(path, state) {
        state.loopDepth++;
      },
      exit: function exit(path, state) {
        state.loopDepth--;
      }
    },
    Function: function Function(path, state) {
      if (state.loopDepth > 0) {
        path.traverse(letReferenceFunctionVisitor, state);
      } else {
        path.traverse(visitor$2, state);
      }

      return path.skip();
    }
  }, visitor$2]);
  var letReferenceFunctionVisitor = traverse$1.visitors.merge([{
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var ref = state.letReferences.get(path.node.name);
      if (!ref) return;
      var localBinding = path.scope.getBindingIdentifier(path.node.name);
      if (localBinding && localBinding !== ref) return;
      state.closurify = true;
    }
  }, visitor$2]);
  var hoistVarDeclarationsVisitor = {
    enter: function enter(path, self) {
      var node = path.node,
          parent = path.parent;

      if (path.isForStatement()) {
        if (isVar$1(node.init)) {
          var nodes = self.pushDeclar(node.init);

          if (nodes.length === 1) {
            node.init = nodes[0];
          } else {
            node.init = sequenceExpression(nodes);
          }
        }
      } else if (path.isFor()) {
        if (isVar$1(node.left)) {
          self.pushDeclar(node.left);
          node.left = node.left.declarations[0].id;
        }
      } else if (isVar$1(node)) {
        path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {
          return expressionStatement(expr);
        }));
      } else if (path.isFunction()) {
        return path.skip();
      }
    }
  };
  var loopLabelVisitor = {
    LabeledStatement: function LabeledStatement(_ref, state) {
      var node = _ref.node;
      state.innerLabels.push(node.label.name);
    }
  };
  var continuationVisitor = {
    enter: function enter(path, state) {
      if (path.isAssignmentExpression() || path.isUpdateExpression()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];

          if (state.outsideReferences.get(name) !== path.scope.getBindingIdentifier(name)) {
            continue;
          }

          state.reassignments[name] = true;
        }
      } else if (path.isReturnStatement()) {
        state.returnStatements.push(path);
      }
    }
  };

  function loopNodeTo(node) {
    if (isBreakStatement(node)) {
      return "break";
    } else if (isContinueStatement(node)) {
      return "continue";
    }
  }

  var loopVisitor = {
    Loop: function Loop(path, state) {
      var oldIgnoreLabeless = state.ignoreLabeless;
      state.ignoreLabeless = true;
      path.traverse(loopVisitor, state);
      state.ignoreLabeless = oldIgnoreLabeless;
      path.skip();
    },
    Function: function Function(path) {
      path.skip();
    },
    SwitchCase: function SwitchCase(path, state) {
      var oldInSwitchCase = state.inSwitchCase;
      state.inSwitchCase = true;
      path.traverse(loopVisitor, state);
      state.inSwitchCase = oldInSwitchCase;
      path.skip();
    },
    "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
      var node = path.node,
          scope = path.scope;
      if (node[this.LOOP_IGNORE]) return;
      var replace;
      var loopText = loopNodeTo(node);

      if (loopText) {
        if (node.label) {
          if (state.innerLabels.indexOf(node.label.name) >= 0) {
            return;
          }

          loopText = loopText + "|" + node.label.name;
        } else {
          if (state.ignoreLabeless) return;
          if (isBreakStatement(node) && state.inSwitchCase) return;
        }

        state.hasBreakContinue = true;
        state.map[loopText] = node;
        replace = stringLiteral(loopText);
      }

      if (path.isReturnStatement()) {
        state.hasReturn = true;
        replace = objectExpression([objectProperty(identifier("v"), node.argument || scope.buildUndefinedNode())]);
      }

      if (replace) {
        replace = returnStatement(replace);
        replace[this.LOOP_IGNORE] = true;
        path.skip();
        path.replaceWith(inherits(replace, node));
      }
    }
  };

  function isStrict(path) {
    return !!path.find(function (_ref2) {
      var node = _ref2.node;

      if (isProgram(node)) {
        if (node.sourceType === "module") return true;
      } else if (!isBlockStatement(node)) return false;

      return node.directives.some(function (directive) {
        return directive.value.value === "use strict";
      });
    });
  }

  var BlockScoping = function () {
    function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
      this.parent = parent;
      this.scope = scope;
      this.state = state;
      this.throwIfClosureRequired = throwIfClosureRequired;
      this.tdzEnabled = tdzEnabled;
      this.blockPath = blockPath;
      this.block = blockPath.node;
      this.outsideLetReferences = new Map();
      this.hasLetReferences = false;
      this.letReferences = new Map();
      this.body = [];

      if (loopPath) {
        this.loopParent = loopPath.parent;
        this.loopLabel = isLabeledStatement(this.loopParent) && this.loopParent.label;
        this.loopPath = loopPath;
        this.loop = loopPath.node;
      }
    }

    var _proto = BlockScoping.prototype;

    _proto.run = function run() {
      var block = this.block;
      if (DONE.has(block)) return;
      DONE.add(block);
      var needsClosure = this.getLetReferences();
      this.checkConstants();

      if (isFunction(this.parent) || isProgram(this.block)) {
        this.updateScopeInfo();
        return;
      }

      if (!this.hasLetReferences) return;

      if (needsClosure) {
        this.wrapClosure();
      } else {
        this.remap();
      }

      this.updateScopeInfo(needsClosure);

      if (this.loopLabel && !isLabeledStatement(this.loopParent)) {
        return labeledStatement(this.loopLabel, this.loop);
      }
    };

    _proto.checkConstants = function checkConstants() {
      var scope = this.scope;
      var state = this.state;

      for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = scope.bindings[name];
        if (binding.kind !== "const") continue;

        for (var _i4 = 0, _arr = binding.constantViolations; _i4 < _arr.length; _i4++) {
          var violation = _arr[_i4];
          var readOnlyError = state.addHelper("readOnlyError");
          var throwNode = callExpression(readOnlyError, [stringLiteral(name)]);

          if (violation.isAssignmentExpression()) {
            violation.get("right").replaceWith(sequenceExpression([throwNode, violation.get("right").node]));
          } else if (violation.isUpdateExpression()) {
            violation.replaceWith(sequenceExpression([throwNode, violation.node]));
          } else if (violation.isForXStatement()) {
            violation.ensureBlock();
            violation.node.body.body.unshift(expressionStatement(throwNode));
          }
        }
      }
    };

    _proto.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {
      var blockScope = this.blockPath.scope;
      var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
      var letRefs = this.letReferences;

      for (var _iterator = _createForOfIteratorHelperLoose(letRefs.keys()), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        var ref = letRefs.get(key);
        var binding = blockScope.getBinding(ref.name);
        if (!binding) continue;

        if (binding.kind === "let" || binding.kind === "const") {
          binding.kind = "var";

          if (wrappedInClosure) {
            if (blockScope.hasOwnBinding(ref.name)) {
              blockScope.removeBinding(ref.name);
            }
          } else {
            blockScope.moveBindingTo(ref.name, parentScope);
          }
        }
      }
    };

    _proto.remap = function remap() {
      var letRefs = this.letReferences;
      var outsideLetRefs = this.outsideLetReferences;
      var scope = this.scope;
      var blockPathScope = this.blockPath.scope;

      for (var _iterator2 = _createForOfIteratorHelperLoose(letRefs.keys()), _step2; !(_step2 = _iterator2()).done;) {
        var key = _step2.value;
        var ref = letRefs.get(key);

        if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
          var binding = scope.getOwnBinding(key);

          if (binding) {
            var parentBinding = scope.parent.getOwnBinding(key);

            if (binding.kind === "hoisted" && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar$1(parentBinding.path.parent)) && !isStrict(binding.path.parentPath)) {
              continue;
            }

            scope.rename(ref.name);
          }

          if (blockPathScope.hasOwnBinding(key)) {
            blockPathScope.rename(ref.name);
          }
        }
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(outsideLetRefs.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var _key = _step3.value;

        var _ref3 = letRefs.get(_key);

        if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
          blockPathScope.rename(_ref3.name);
        }
      }
    };

    _proto.wrapClosure = function wrapClosure() {
      if (this.throwIfClosureRequired) {
        throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
      }

      var block = this.block;
      var outsideRefs = this.outsideLetReferences;

      if (this.loop) {
        for (var _i5 = 0, _Array$from = Array.from(outsideRefs.keys()); _i5 < _Array$from.length; _i5++) {
          var name = _Array$from[_i5];
          var id = outsideRefs.get(name);

          if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
            outsideRefs["delete"](id.name);
            this.letReferences["delete"](id.name);
            this.scope.rename(id.name);
            this.letReferences.set(id.name, id);
            outsideRefs.set(id.name, id);
          }
        }
      }

      this.has = this.checkLoop();
      this.hoistVarDeclarations();
      var args = Array.from(outsideRefs.values(), function (node) {
        return cloneNode(node);
      });
      var params = args.map(function (id) {
        return cloneNode(id);
      });
      var isSwitch = this.blockPath.isSwitchStatement();
      var fn = functionExpression(null, params, blockStatement(isSwitch ? [block] : block.body));
      this.addContinuations(fn);
      var call = callExpression(nullLiteral(), args);
      var basePath = ".callee";
      var hasYield = traverse$1.hasType(fn.body, "YieldExpression", FUNCTION_TYPES);

      if (hasYield) {
        fn.generator = true;
        call = yieldExpression(call, true);
        basePath = ".argument" + basePath;
      }

      var hasAsync = traverse$1.hasType(fn.body, "AwaitExpression", FUNCTION_TYPES);

      if (hasAsync) {
        fn.async = true;
        call = awaitExpression(call);
        basePath = ".argument" + basePath;
      }

      var placeholderPath;
      var index;

      if (this.has.hasReturn || this.has.hasBreakContinue) {
        var ret = this.scope.generateUid("ret");
        this.body.push(variableDeclaration("var", [variableDeclarator(identifier(ret), call)]));
        placeholderPath = "declarations.0.init" + basePath;
        index = this.body.length - 1;
        this.buildHas(ret);
      } else {
        this.body.push(expressionStatement(call));
        placeholderPath = "expression" + basePath;
        index = this.body.length - 1;
      }

      var callPath;

      if (isSwitch) {
        var _this$blockPath = this.blockPath,
            parentPath = _this$blockPath.parentPath,
            listKey = _this$blockPath.listKey,
            key = _this$blockPath.key;
        this.blockPath.replaceWithMultiple(this.body);
        callPath = parentPath.get(listKey)[key + index];
      } else {
        block.body = this.body;
        callPath = this.blockPath.get("body")[index];
      }

      var placeholder = callPath.get(placeholderPath);
      var fnPath;

      if (this.loop) {
        var loopId = this.scope.generateUid("loop");
        var p = this.loopPath.insertBefore(variableDeclaration("var", [variableDeclarator(identifier(loopId), fn)]));
        placeholder.replaceWith(identifier(loopId));
        fnPath = p[0].get("declarations.0.init");
      } else {
        placeholder.replaceWith(fn);
        fnPath = placeholder;
      }

      fnPath.unwrapFunctionEnvironment();
    };

    _proto.addContinuations = function addContinuations(fn) {
      var _this = this;

      var state = {
        reassignments: {},
        returnStatements: [],
        outsideReferences: this.outsideLetReferences
      };
      this.scope.traverse(fn, continuationVisitor, state);

      var _loop = function _loop(i) {
        var param = fn.params[i];
        if (!state.reassignments[param.name]) return "continue";
        var paramName = param.name;

        var newParamName = _this.scope.generateUid(param.name);

        fn.params[i] = identifier(newParamName);

        _this.scope.rename(paramName, newParamName, fn);

        state.returnStatements.forEach(function (returnStatement) {
          returnStatement.insertBefore(expressionStatement(assignmentExpression("=", identifier(paramName), identifier(newParamName))));
        });
        fn.body.body.push(expressionStatement(assignmentExpression("=", identifier(paramName), identifier(newParamName))));
      };

      for (var i = 0; i < fn.params.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      }
    };

    _proto.getLetReferences = function getLetReferences() {
      var _this2 = this;

      var block = this.block;
      var declarators = [];

      if (this.loop) {
        var init = this.loop.left || this.loop.init;

        if (isBlockScoped$1(init)) {
          declarators.push(init);
          var names = getBindingIdentifiers(init);

          for (var _i6 = 0, _Object$keys4 = Object.keys(names); _i6 < _Object$keys4.length; _i6++) {
            var name = _Object$keys4[_i6];
            this.outsideLetReferences.set(name, names[name]);
          }
        }
      }

      var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
        node = node || path.node;

        if (isClassDeclaration(node) || isFunctionDeclaration(node) || isBlockScoped$1(node)) {
          if (isBlockScoped$1(node)) {
            convertBlockScopedToVar(path, node, block, _this2.scope);
          }

          declarators = declarators.concat(node.declarations || node);
        }

        if (isLabeledStatement(node)) {
          addDeclarationsFromChild(path.get("body"), node.body);
        }
      };

      if (block.body) {
        var declarPaths = this.blockPath.get("body");

        for (var i = 0; i < block.body.length; i++) {
          addDeclarationsFromChild(declarPaths[i]);
        }
      }

      if (block.cases) {
        var _declarPaths = this.blockPath.get("cases");

        for (var _i7 = 0; _i7 < block.cases.length; _i7++) {
          var consequents = block.cases[_i7].consequent;

          for (var j = 0; j < consequents.length; j++) {
            var declar = consequents[j];
            addDeclarationsFromChild(_declarPaths[_i7], declar);
          }
        }
      }

      for (var _i8 = 0; _i8 < declarators.length; _i8++) {
        var _declar = declarators[_i8];
        var keys = getBindingIdentifiers(_declar, false, true);

        for (var _i9 = 0, _Object$keys5 = Object.keys(keys); _i9 < _Object$keys5.length; _i9++) {
          var key = _Object$keys5[_i9];
          this.letReferences.set(key, keys[key]);
        }

        this.hasLetReferences = true;
      }

      if (!this.hasLetReferences) return;
      var state = {
        letReferences: this.letReferences,
        closurify: false,
        loopDepth: 0,
        tdzEnabled: this.tdzEnabled,
        addHelper: function addHelper(name) {
          return _this2.state.addHelper(name);
        }
      };

      if (isInLoop(this.blockPath)) {
        state.loopDepth++;
      }

      this.blockPath.traverse(letReferenceBlockVisitor, state);
      return state.closurify;
    };

    _proto.checkLoop = function checkLoop() {
      var state = {
        hasBreakContinue: false,
        ignoreLabeless: false,
        inSwitchCase: false,
        innerLabels: [],
        hasReturn: false,
        isLoop: !!this.loop,
        map: {},
        LOOP_IGNORE: Symbol()
      };
      this.blockPath.traverse(loopLabelVisitor, state);
      this.blockPath.traverse(loopVisitor, state);
      return state;
    };

    _proto.hoistVarDeclarations = function hoistVarDeclarations() {
      this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
    };

    _proto.pushDeclar = function pushDeclar(node) {
      var declars = [];
      var names = getBindingIdentifiers(node);

      for (var _i10 = 0, _Object$keys6 = Object.keys(names); _i10 < _Object$keys6.length; _i10++) {
        var name = _Object$keys6[_i10];
        declars.push(variableDeclarator(names[name]));
      }

      this.body.push(variableDeclaration(node.kind, declars));
      var replace = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        if (!declar.init) continue;
        var expr = assignmentExpression("=", cloneNode(declar.id), cloneNode(declar.init));
        replace.push(inherits(expr, declar));
      }

      return replace;
    };

    _proto.buildHas = function buildHas(ret) {
      var body = this.body;
      var has = this.has;

      if (has.hasBreakContinue) {
        for (var _i11 = 0, _Object$keys7 = Object.keys(has.map); _i11 < _Object$keys7.length; _i11++) {
          var key = _Object$keys7[_i11];
          body.push(ifStatement(binaryExpression("===", identifier(ret), stringLiteral(key)), has.map[key]));
        }
      }

      if (has.hasReturn) {
        body.push(buildRetCheck({
          RETURN: identifier(ret)
        }));
      }
    };

    return BlockScoping;
  }();

  var objectProto$g = Object.prototype;
  var hasOwnProperty$e = objectProto$g.hasOwnProperty;

  function baseHas(object, key) {
    return object != null && hasOwnProperty$e.call(object, key);
  }

  var _baseHas = baseHas;

  function has$5(object, path) {
    return object != null && _hasPath(object, path, _baseHas);
  }

  var has_1 = has$5;

  function toKind(node) {
    if (isClassMethod(node) || isObjectMethod(node)) {
      if (node.kind === "get" || node.kind === "set") {
        return node.kind;
      }
    }

    return "value";
  }

  function push(mutatorMap, node, kind, file, scope) {
    var alias = toKeyAlias(node);
    var map = {};
    if (has_1(mutatorMap, alias)) map = mutatorMap[alias];
    mutatorMap[alias] = map;
    map._inherits = map._inherits || [];

    map._inherits.push(node);

    map._key = node.key;

    if (node.computed) {
      map._computed = true;
    }

    if (node.decorators) {
      var decorators = map.decorators = map.decorators || arrayExpression([]);
      decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
        return dec.expression;
      }).reverse());
    }

    if (map.value || map.initializer) {
      throw file.buildCodeFrameError(node, "Key conflict with sibling node");
    }

    var key, value;

    if (isObjectProperty(node) || isObjectMethod(node) || isClassMethod(node)) {
      key = toComputedKey(node, node.key);
    }

    if (isProperty(node)) {
      value = node.value;
    } else if (isObjectMethod(node) || isClassMethod(node)) {
      value = functionExpression(null, node.params, node.body, node.generator, node.async);
      value.returnType = node.returnType;
    }

    var inheritedKind = toKind(node);

    if (!kind || inheritedKind !== "value") {
      kind = inheritedKind;
    }

    if (scope && isStringLiteral(key) && (kind === "value" || kind === "initializer") && isFunctionExpression(value)) {
      value = nameFunction({
        id: key,
        node: value,
        scope: scope
      });
    }

    if (value) {
      inheritsComments(value, node);
      map[kind] = value;
    }

    return map;
  }
  function toComputedObjectFromClass(obj) {
    var objExpr = arrayExpression([]);

    for (var i = 0; i < obj.properties.length; i++) {
      var prop = obj.properties[i];
      var val = prop.value;
      val.properties.unshift(objectProperty(identifier("key"), toComputedKey(prop)));
      objExpr.elements.push(val);
    }

    return objExpr;
  }
  function toClassObject(mutatorMap) {
    var objExpr = objectExpression([]);
    Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
      var map = mutatorMap[mutatorMapKey];
      var mapNode = objectExpression([]);
      var propNode = objectProperty(map._key, mapNode, map._computed);
      Object.keys(map).forEach(function (key) {
        var node = map[key];
        if (key[0] === "_") return;
        var prop = objectProperty(identifier(key), node);
        inheritsComments(prop, node);
        removeComments(node);
        mapNode.properties.push(prop);
      });
      objExpr.properties.push(propNode);
    });
    return objExpr;
  }
  function toDefineObject(mutatorMap) {
    Object.keys(mutatorMap).forEach(function (key) {
      var map = mutatorMap[key];
      if (map.value) map.writable = booleanLiteral(true);
      map.configurable = booleanLiteral(true);
      map.enumerable = booleanLiteral(true);
    });
    return toClassObject(mutatorMap);
  }

  function _templateObject$b() {
    var data = _taggedTemplateLiteralLoose(["\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n"]);

    _templateObject$b = function _templateObject() {
      return data;
    };

    return data;
  }
  var helperIDs = new WeakMap();
  function addCreateSuperHelper(file) {
    if (helperIDs.has(file)) {
      return (cloneNode || clone$1)(helperIDs.get(file));
    }

    try {
      return file.addHelper("createSuper");
    } catch (_unused) {}

    var id = file.scope.generateUidIdentifier("createSuper");
    helperIDs.set(file, id);
    var fn = helper$1({
      CREATE_SUPER: id,
      GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
      POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
    });
    file.path.unshiftContainer("body", [fn]);
    file.scope.registerDeclaration(file.path.get("body.0"));
    return cloneNode(id);
  }
  var helper$1 = template.statement(_templateObject$b());

  function _templateObject$c() {
    var data = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "]);

    _templateObject$c = function _templateObject() {
      return data;
    };

    return data;
  }

  function buildConstructor(classRef, constructorBody, node) {
    var func = functionDeclaration(cloneNode(classRef), [], constructorBody);
    inherits(func, node);
    return func;
  }

  function transformClass(path, file, builtinClasses, isLoose) {
    var classState = {
      parent: undefined,
      scope: undefined,
      node: undefined,
      path: undefined,
      file: undefined,
      classId: undefined,
      classRef: undefined,
      superFnId: undefined,
      superName: undefined,
      superReturns: [],
      isDerived: false,
      extendsNative: false,
      construct: undefined,
      constructorBody: undefined,
      userConstructor: undefined,
      userConstructorPath: undefined,
      hasConstructor: false,
      instancePropBody: [],
      instancePropRefs: {},
      staticPropBody: [],
      body: [],
      superThises: [],
      pushedConstructor: false,
      pushedInherits: false,
      protoAlias: null,
      isLoose: false,
      hasInstanceDescriptors: false,
      hasStaticDescriptors: false,
      instanceMutatorMap: {},
      staticMutatorMap: {}
    };

    var setState = function setState(newState) {
      Object.assign(classState, newState);
    };

    var findThisesVisitor = traverse$1.visitors.merge([environmentVisitor, {
      ThisExpression: function ThisExpression(path) {
        classState.superThises.push(path);
      }
    }]);

    function pushToMap(node, enumerable, kind, scope) {
      if (kind === void 0) {
        kind = "value";
      }

      var mutatorMap;

      if (node["static"]) {
        setState({
          hasStaticDescriptors: true
        });
        mutatorMap = classState.staticMutatorMap;
      } else {
        setState({
          hasInstanceDescriptors: true
        });
        mutatorMap = classState.instanceMutatorMap;
      }

      var map = push(mutatorMap, node, kind, classState.file, scope);

      if (enumerable) {
        map.enumerable = booleanLiteral(true);
      }

      return map;
    }

    function maybeCreateConstructor() {
      var hasConstructor = false;
      var paths = classState.path.get("body.body");

      for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
        var _path = _step.value;
        hasConstructor = _path.equals("kind", "constructor");
        if (hasConstructor) break;
      }

      if (hasConstructor) return;
      var params, body;

      if (classState.isDerived) {
        var _constructor = template.expression.ast(_templateObject$c());

        params = _constructor.params;
        body = _constructor.body;
      } else {
        params = [];
        body = blockStatement([]);
      }

      classState.path.get("body").unshiftContainer("body", classMethod("constructor", identifier("constructor"), params, body));
    }

    function buildBody() {
      maybeCreateConstructor();
      pushBody();
      verifyConstructor();

      if (classState.userConstructor) {
        var constructorBody = classState.constructorBody,
            userConstructor = classState.userConstructor,
            construct = classState.construct;
        constructorBody.body = constructorBody.body.concat(userConstructor.body.body);
        inherits(construct, userConstructor);
        inherits(constructorBody, userConstructor.body);
      }

      pushDescriptors();
    }

    function pushBody() {
      var classBodyPaths = classState.path.get("body.body");

      for (var _iterator2 = _createForOfIteratorHelperLoose(classBodyPaths), _step2; !(_step2 = _iterator2()).done;) {
        var _path2 = _step2.value;
        var node = _path2.node;

        if (_path2.isClassProperty()) {
          throw _path2.buildCodeFrameError("Missing class properties transform.");
        }

        if (node.decorators) {
          throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
        }

        if (isClassMethod(node)) {
          (function () {
            var isConstructor = node.kind === "constructor";
            var replaceSupers = new ReplaceSupers({
              methodPath: _path2,
              objectRef: classState.classRef,
              superRef: classState.superName,
              isLoose: classState.isLoose,
              file: classState.file,
              refToPreserve: classState.classRef
            });
            replaceSupers.replace();
            var superReturns = [];

            _path2.traverse(traverse$1.visitors.merge([environmentVisitor, {
              ReturnStatement: function ReturnStatement(path) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  superReturns.push(path);
                }
              }
            }]));

            if (isConstructor) {
              pushConstructor(superReturns, node, _path2);
            } else {
              pushMethod(node, _path2);
            }
          })();
        }
      }
    }

    function clearDescriptors() {
      setState({
        hasInstanceDescriptors: false,
        hasStaticDescriptors: false,
        instanceMutatorMap: {},
        staticMutatorMap: {}
      });
    }

    function pushDescriptors() {
      pushInheritsToBody();
      var body = classState.body;
      var instanceProps;
      var staticProps;

      if (classState.hasInstanceDescriptors) {
        instanceProps = toClassObject(classState.instanceMutatorMap);
      }

      if (classState.hasStaticDescriptors) {
        staticProps = toClassObject(classState.staticMutatorMap);
      }

      if (instanceProps || staticProps) {
        if (instanceProps) {
          instanceProps = toComputedObjectFromClass(instanceProps);
        }

        if (staticProps) {
          staticProps = toComputedObjectFromClass(staticProps);
        }

        var args = [cloneNode(classState.classRef), nullLiteral(), nullLiteral()];
        if (instanceProps) args[1] = instanceProps;
        if (staticProps) args[2] = staticProps;
        var lastNonNullIndex = 0;

        for (var i = 0; i < args.length; i++) {
          if (!isNullLiteral(args[i])) lastNonNullIndex = i;
        }

        args = args.slice(0, lastNonNullIndex + 1);
        body.push(expressionStatement(callExpression(classState.file.addHelper("createClass"), args)));
      }

      clearDescriptors();
    }

    function wrapSuperCall(bareSuper, superRef, thisRef, body) {
      var bareSuperNode = bareSuper.node;
      var call;

      if (classState.isLoose) {
        bareSuperNode.arguments.unshift(thisExpression());

        if (bareSuperNode.arguments.length === 2 && isSpreadElement(bareSuperNode.arguments[1]) && isIdentifier(bareSuperNode.arguments[1].argument, {
          name: "arguments"
        })) {
          bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
          bareSuperNode.callee = memberExpression(cloneNode(superRef), identifier("apply"));
        } else {
          bareSuperNode.callee = memberExpression(cloneNode(superRef), identifier("call"));
        }

        call = logicalExpression("||", bareSuperNode, thisExpression());
      } else {
        call = optimiseCallExpression(cloneNode(classState.superFnId), thisExpression(), bareSuperNode.arguments);
      }

      if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
        if (classState.superThises.length) {
          call = assignmentExpression("=", thisRef(), call);
        }

        bareSuper.parentPath.replaceWith(returnStatement(call));
      } else {
        bareSuper.replaceWith(assignmentExpression("=", thisRef(), call));
      }
    }

    function verifyConstructor() {
      if (!classState.isDerived) return;
      var path = classState.userConstructorPath;
      var body = path.get("body");
      path.traverse(findThisesVisitor);

      var _thisRef = function thisRef() {
        var ref = path.scope.generateDeclaredUidIdentifier("this");

        _thisRef = function thisRef() {
          return cloneNode(ref);
        };

        return ref;
      };

      for (var _iterator3 = _createForOfIteratorHelperLoose(classState.superThises), _step3; !(_step3 = _iterator3()).done;) {
        var thisPath = _step3.value;
        var node = thisPath.node,
            parentPath = thisPath.parentPath;

        if (parentPath.isMemberExpression({
          object: node
        })) {
          thisPath.replaceWith(_thisRef());
          continue;
        }

        thisPath.replaceWith(callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
      }

      var bareSupers = new Set();
      path.traverse(traverse$1.visitors.merge([environmentVisitor, {
        Super: function Super(path) {
          var node = path.node,
              parentPath = path.parentPath;

          if (parentPath.isCallExpression({
            callee: node
          })) {
            bareSupers.add(parentPath);
          }
        }
      }]));
      var guaranteedSuperBeforeFinish = !!bareSupers.size;

      for (var _iterator4 = _createForOfIteratorHelperLoose(bareSupers), _step4; !(_step4 = _iterator4()).done;) {
        var bareSuper = _step4.value;
        wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

        if (guaranteedSuperBeforeFinish) {
          bareSuper.find(function (parentPath) {
            if (parentPath === path) {
              return true;
            }

            if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
              guaranteedSuperBeforeFinish = false;
              return true;
            }
          });
        }
      }

      var wrapReturn;

      if (classState.isLoose) {
        wrapReturn = function wrapReturn(returnArg) {
          var thisExpr = callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);
          return returnArg ? logicalExpression("||", returnArg, thisExpr) : thisExpr;
        };
      } else {
        wrapReturn = function wrapReturn(returnArg) {
          return callExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
        };
      }

      var bodyPaths = body.get("body");

      if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
        body.pushContainer("body", returnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
      }

      for (var _iterator5 = _createForOfIteratorHelperLoose(classState.superReturns), _step5; !(_step5 = _iterator5()).done;) {
        var returnPath = _step5.value;
        returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }
    }

    function pushMethod(node, path) {
      var scope = path ? path.scope : classState.scope;

      if (node.kind === "method") {
        if (processMethod(node, scope)) return;
      }

      pushToMap(node, false, null, scope);
    }

    function processMethod(node, scope) {
      if (classState.isLoose && !node.decorators) {
        var classRef = classState.classRef;

        if (!node["static"]) {
          insertProtoAliasOnce();
          classRef = classState.protoAlias;
        }

        var methodName = memberExpression(cloneNode(classRef), node.key, node.computed || isLiteral(node.key));
        var func = functionExpression(null, node.params, node.body, node.generator, node.async);
        inherits(func, node);
        var key = toComputedKey(node, node.key);

        if (isStringLiteral(key)) {
          func = nameFunction({
            node: func,
            id: key,
            scope: scope
          });
        }

        var expr = expressionStatement(assignmentExpression("=", methodName, func));
        inheritsComments(expr, node);
        classState.body.push(expr);
        return true;
      }

      return false;
    }

    function insertProtoAliasOnce() {
      if (classState.protoAlias === null) {
        setState({
          protoAlias: classState.scope.generateUidIdentifier("proto")
        });
        var classProto = memberExpression(classState.classRef, identifier("prototype"));
        var protoDeclaration = variableDeclaration("var", [variableDeclarator(classState.protoAlias, classProto)]);
        classState.body.push(protoDeclaration);
      }
    }

    function pushConstructor(superReturns, method, path) {
      setState({
        userConstructorPath: path,
        userConstructor: method,
        hasConstructor: true,
        superReturns: superReturns
      });
      var construct = classState.construct;
      inheritsComments(construct, method);
      construct.params = method.params;
      inherits(construct.body, method.body);
      construct.body.directives = method.body.directives;
      pushConstructorToBody();
    }

    function pushConstructorToBody() {
      if (classState.pushedConstructor) return;
      classState.pushedConstructor = true;

      if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
        pushDescriptors();
      }

      classState.body.push(classState.construct);
      pushInheritsToBody();
    }

    function pushInheritsToBody() {
      if (!classState.isDerived || classState.pushedInherits) return;
      var superFnId = path.scope.generateUidIdentifier("super");
      setState({
        pushedInherits: true,
        superFnId: superFnId
      });

      if (!classState.isLoose) {
        classState.body.unshift(variableDeclaration("var", [variableDeclarator(superFnId, callExpression(addCreateSuperHelper(classState.file), [cloneNode(classState.classRef)]))]));
      }

      classState.body.unshift(expressionStatement(callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [cloneNode(classState.classRef), cloneNode(classState.superName)])));
    }

    function setupClosureParamsArgs() {
      var superName = classState.superName;
      var closureParams = [];
      var closureArgs = [];

      if (classState.isDerived) {
        var arg = cloneNode(superName);

        if (classState.extendsNative) {
          arg = callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
          annotateAsPure(arg);
        }

        var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
        closureParams.push(param);
        closureArgs.push(arg);
        setState({
          superName: cloneNode(param)
        });
      }

      return {
        closureParams: closureParams,
        closureArgs: closureArgs
      };
    }

    function classTransformer(path, file, builtinClasses, isLoose) {
      setState({
        parent: path.parent,
        scope: path.scope,
        node: path.node,
        path: path,
        file: file,
        isLoose: isLoose
      });
      setState({
        classId: classState.node.id,
        classRef: classState.node.id ? identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
        superName: classState.node.superClass,
        isDerived: !!classState.node.superClass,
        constructorBody: blockStatement([])
      });
      setState({
        extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
      });
      var classRef = classState.classRef,
          node = classState.node,
          constructorBody = classState.constructorBody;
      setState({
        construct: buildConstructor(classRef, constructorBody, node)
      });
      var body = classState.body;

      var _setupClosureParamsAr = setupClosureParamsArgs(),
          closureParams = _setupClosureParamsAr.closureParams,
          closureArgs = _setupClosureParamsAr.closureArgs;

      buildBody();

      if (!classState.isLoose) {
        constructorBody.body.unshift(expressionStatement(callExpression(classState.file.addHelper("classCallCheck"), [thisExpression(), cloneNode(classState.classRef)])));
      }

      body = body.concat(classState.staticPropBody.map(function (fn) {
        return fn(cloneNode(classState.classRef));
      }));
      var isStrict = path.isInStrictMode();
      var constructorOnly = classState.classId && body.length === 1;

      if (constructorOnly && !isStrict) {
        for (var _iterator6 = _createForOfIteratorHelperLoose(classState.construct.params), _step6; !(_step6 = _iterator6()).done;) {
          var param = _step6.value;

          if (!isIdentifier(param)) {
            constructorOnly = false;
            break;
          }
        }
      }

      var directives = constructorOnly ? body[0].body.directives : [];

      if (!isStrict) {
        directives.push(directive(directiveLiteral("use strict")));
      }

      if (constructorOnly) {
        return toExpression(body[0]);
      }

      body.push(returnStatement(cloneNode(classState.classRef)));
      var container = arrowFunctionExpression(closureParams, blockStatement(body, directives));
      return callExpression(container, closureArgs);
    }

    return classTransformer(path, file, builtinClasses, isLoose);
  }

  var getBuiltinClasses = function getBuiltinClasses(category) {
    return Object.keys(globals$2[category]).filter(function (name) {
      return /^[A-Z]/.test(name);
    });
  };

  var builtinClasses = new Set([].concat(getBuiltinClasses("builtin"), getBuiltinClasses("browser")));
  var transformClasses = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var VISITED = Symbol();
    return {
      name: "transform-classes",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (!path.get("declaration").isClassDeclaration()) return;
          splitExportDeclaration(path);
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;
          var ref = node.id || path.scope.generateUidIdentifier("class");
          path.replaceWith(variableDeclaration("let", [variableDeclarator(ref, toExpression(node))]));
        },
        ClassExpression: function ClassExpression(path, state) {
          var node = path.node;
          if (node[VISITED]) return;
          var inferred = nameFunction(path);

          if (inferred && inferred !== node) {
            path.replaceWith(inferred);
            return;
          }

          node[VISITED] = true;
          path.replaceWith(transformClass(path, state.file, builtinClasses, loose));

          if (path.isCallExpression()) {
            annotateAsPure(path);

            if (path.get("callee").isArrowFunctionExpression()) {
              path.get("callee").arrowFunctionToExpression();
            }
          }
        }
      }
    };
  });

  var transformComputedProperties = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    var buildMutatorMapAssign = template("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

    function getValue(prop) {
      if (isObjectProperty(prop)) {
        return prop.value;
      } else if (isObjectMethod(prop)) {
        return functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
      }
    }

    function pushAssign(objId, prop, body) {
      if (prop.kind === "get" && prop.kind === "set") {
        pushMutatorDefine(objId, prop);
      } else {
        body.push(expressionStatement(assignmentExpression("=", memberExpression(cloneNode(objId), prop.key, prop.computed || isLiteral(prop.key)), getValue(prop))));
      }
    }

    function pushMutatorDefine(_ref, prop) {
      var body = _ref.body,
          getMutatorId = _ref.getMutatorId,
          scope = _ref.scope;
      var key = !prop.computed && isIdentifier(prop.key) ? stringLiteral(prop.key.name) : prop.key;
      var maybeMemoise = scope.maybeGenerateMemoised(key);

      if (maybeMemoise) {
        body.push(expressionStatement(assignmentExpression("=", maybeMemoise, key)));
        key = maybeMemoise;
      }

      body.push.apply(body, buildMutatorMapAssign({
        MUTATOR_MAP_REF: getMutatorId(),
        KEY: cloneNode(key),
        VALUE: getValue(prop),
        KIND: identifier(prop.kind)
      }));
    }

    function pushComputedPropsLoose(info) {
      for (var _iterator = _createForOfIteratorHelperLoose(info.computedProps), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else {
          pushAssign(cloneNode(info.objId), prop, info.body);
        }
      }
    }

    function pushComputedPropsSpec(info) {
      var objId = info.objId,
          body = info.body,
          computedProps = info.computedProps,
          state = info.state;

      for (var _iterator2 = _createForOfIteratorHelperLoose(computedProps), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;
        var key = toComputedKey(prop);

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else if (isStringLiteral(key, {
          value: "__proto__"
        })) {
          pushAssign(objId, prop, body);
        } else {
          if (computedProps.length === 1) {
            return callExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
          } else {
            body.push(expressionStatement(callExpression(state.addHelper("defineProperty"), [cloneNode(objId), key, getValue(prop)])));
          }
        }
      }
    }

    return {
      name: "transform-computed-properties",
      visitor: {
        ObjectExpression: {
          exit: function exit(path, state) {
            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            var hasComputed = false;

            for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
              var prop = _arr[_i];
              hasComputed = prop.computed === true;
              if (hasComputed) break;
            }

            if (!hasComputed) return;
            var initProps = [];
            var computedProps = [];
            var foundComputed = false;

            for (var _iterator3 = _createForOfIteratorHelperLoose(node.properties), _step3; !(_step3 = _iterator3()).done;) {
              var _prop = _step3.value;

              if (_prop.computed) {
                foundComputed = true;
              }

              if (foundComputed) {
                computedProps.push(_prop);
              } else {
                initProps.push(_prop);
              }
            }

            var objId = scope.generateUidIdentifierBasedOnNode(parent);
            var initPropExpression = objectExpression(initProps);
            var body = [];
            body.push(variableDeclaration("var", [variableDeclarator(objId, initPropExpression)]));
            var mutatorRef;

            var getMutatorId = function getMutatorId() {
              if (!mutatorRef) {
                mutatorRef = scope.generateUidIdentifier("mutatorMap");
                body.push(variableDeclaration("var", [variableDeclarator(mutatorRef, objectExpression([]))]));
              }

              return cloneNode(mutatorRef);
            };

            var single = pushComputedProps({
              scope: scope,
              objId: objId,
              body: body,
              computedProps: computedProps,
              initPropExpression: initPropExpression,
              getMutatorId: getMutatorId,
              state: state
            });

            if (mutatorRef) {
              body.push(expressionStatement(callExpression(state.addHelper("defineEnumerableProperties"), [cloneNode(objId), cloneNode(mutatorRef)])));
            }

            if (single) {
              path.replaceWith(single);
            } else {
              body.push(expressionStatement(cloneNode(objId)));
              path.replaceWithMultiple(body);
            }
          }
        }
      }
    };
  });

  var transformDestructuring = declare(function (api, options) {
    api.assertVersion(7);
    var _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose,
        _options$useBuiltIns = options.useBuiltIns,
        useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns,
        _options$allowArrayLi = options.allowArrayLike,
        allowArrayLike = _options$allowArrayLi === void 0 ? false : _options$allowArrayLi;

    if (typeof loose !== "boolean") {
      throw new Error(".loose must be a boolean or undefined");
    }

    var arrayOnlySpread = loose;

    function getExtendsHelper(file) {
      return useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
    }

    function variableDeclarationHasPattern(node) {
      for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
        var declar = _arr[_i];

        if (isPattern(declar.id)) {
          return true;
        }
      }

      return false;
    }

    function hasRest(pattern) {
      for (var _i2 = 0, _arr2 = pattern.elements; _i2 < _arr2.length; _i2++) {
        var elem = _arr2[_i2];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    function hasObjectRest(pattern) {
      for (var _i3 = 0, _arr3 = pattern.properties; _i3 < _arr3.length; _i3++) {
        var elem = _arr3[_i3];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    var STOP_TRAVERSAL = {};

    var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
      if (!ancestors.length) {
        return;
      }

      if (isIdentifier(node) && isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
        state.deopt = true;
        throw STOP_TRAVERSAL;
      }
    };

    var DestructuringTransformer = function () {
      function DestructuringTransformer(opts) {
        this.blockHoist = opts.blockHoist;
        this.operator = opts.operator;
        this.arrays = {};
        this.nodes = opts.nodes || [];
        this.scope = opts.scope;
        this.kind = opts.kind;
        this.arrayOnlySpread = opts.arrayOnlySpread;
        this.allowArrayLike = opts.allowArrayLike;
        this.addHelper = opts.addHelper;
      }

      var _proto = DestructuringTransformer.prototype;

      _proto.buildVariableAssignment = function buildVariableAssignment(id, init) {
        var op = this.operator;
        if (isMemberExpression(id)) op = "=";
        var node;

        if (op) {
          node = expressionStatement(assignmentExpression(op, id, cloneNode(init) || this.scope.buildUndefinedNode()));
        } else {
          node = variableDeclaration(this.kind, [variableDeclarator(id, cloneNode(init))]);
        }

        node._blockHoist = this.blockHoist;
        return node;
      };

      _proto.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
        var declar = variableDeclaration("var", [variableDeclarator(cloneNode(id), cloneNode(init))]);
        declar._blockHoist = this.blockHoist;
        return declar;
      };

      _proto.push = function push(id, _init) {
        var init = cloneNode(_init);

        if (isObjectPattern(id)) {
          this.pushObjectPattern(id, init);
        } else if (isArrayPattern(id)) {
          this.pushArrayPattern(id, init);
        } else if (isAssignmentPattern(id)) {
          this.pushAssignmentPattern(id, init);
        } else {
          this.nodes.push(this.buildVariableAssignment(id, init));
        }
      };

      _proto.toArray = function toArray(node, count) {
        if (this.arrayOnlySpread || isIdentifier(node) && this.arrays[node.name]) {
          return node;
        } else {
          return this.scope.toArray(node, count, this.allowArrayLike);
        }
      };

      _proto.pushAssignmentPattern = function pushAssignmentPattern(_ref, valueRef) {
        var left = _ref.left,
            right = _ref.right;
        var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
        var tempConditional = conditionalExpression(binaryExpression("===", cloneNode(tempId), this.scope.buildUndefinedNode()), right, cloneNode(tempId));

        if (isPattern(left)) {
          var patternId;
          var node;

          if (this.kind === "const" || this.kind === "let") {
            patternId = this.scope.generateUidIdentifier(tempId.name);
            node = this.buildVariableDeclaration(patternId, tempConditional);
          } else {
            patternId = tempId;
            node = expressionStatement(assignmentExpression("=", cloneNode(tempId), tempConditional));
          }

          this.nodes.push(node);
          this.push(left, patternId);
        } else {
          this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
      };

      _proto.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        var keys = [];
        var allLiteral = true;

        for (var i = 0; i < pattern.properties.length; i++) {
          var prop = pattern.properties[i];
          if (i >= spreadPropIndex) break;
          if (isRestElement(prop)) continue;
          var key = prop.key;

          if (isIdentifier(key) && !prop.computed) {
            keys.push(stringLiteral(key.name));
          } else if (isTemplateLiteral(prop.key)) {
            keys.push(cloneNode(prop.key));
          } else if (isLiteral(key)) {
            keys.push(stringLiteral(String(key.value)));
          } else {
            keys.push(cloneNode(key));
            allLiteral = false;
          }
        }

        var value;

        if (keys.length === 0) {
          value = callExpression(getExtendsHelper(this), [objectExpression([]), cloneNode(objRef)]);
        } else {
          var keyExpression = arrayExpression(keys);

          if (!allLiteral) {
            keyExpression = callExpression(memberExpression(keyExpression, identifier("map")), [this.addHelper("toPropertyKey")]);
          }

          value = callExpression(this.addHelper("objectWithoutProperties" + (loose ? "Loose" : "")), [cloneNode(objRef), keyExpression]);
        }

        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
      };

      _proto.pushObjectProperty = function pushObjectProperty(prop, propRef) {
        if (isLiteral(prop.key)) prop.computed = true;
        var pattern = prop.value;
        var objRef = memberExpression(cloneNode(propRef), prop.key, prop.computed);

        if (isPattern(pattern)) {
          this.push(pattern, objRef);
        } else {
          this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
      };

      _proto.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
        if (!pattern.properties.length) {
          this.nodes.push(expressionStatement(callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
        }

        if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
          var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
          this.nodes.push(this.buildVariableDeclaration(temp, objRef));
          objRef = temp;
        }

        if (hasObjectRest(pattern)) {
          var copiedPattern;

          for (var i = 0; i < pattern.properties.length; i++) {
            var prop = pattern.properties[i];

            if (isRestElement(prop)) {
              break;
            }

            var key = prop.key;

            if (prop.computed && !this.scope.isPure(key)) {
              var name = this.scope.generateUidIdentifierBasedOnNode(key);
              this.nodes.push(this.buildVariableDeclaration(name, key));

              if (!copiedPattern) {
                copiedPattern = pattern = Object.assign({}, pattern, {
                  properties: pattern.properties.slice()
                });
              }

              copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                key: name
              });
            }
          }
        }

        for (var _i4 = 0; _i4 < pattern.properties.length; _i4++) {
          var _prop = pattern.properties[_i4];

          if (isRestElement(_prop)) {
            this.pushObjectRest(pattern, objRef, _prop, _i4);
          } else {
            this.pushObjectProperty(_prop, objRef);
          }
        }
      };

      _proto.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
        if (!isArrayExpression(arr)) return false;
        if (pattern.elements.length > arr.elements.length) return;

        if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
          return false;
        }

        for (var _i5 = 0, _arr4 = pattern.elements; _i5 < _arr4.length; _i5++) {
          var elem = _arr4[_i5];
          if (!elem) return false;
          if (isMemberExpression(elem)) return false;
        }

        for (var _i6 = 0, _arr5 = arr.elements; _i6 < _arr5.length; _i6++) {
          var _elem = _arr5[_i6];
          if (isSpreadElement(_elem)) return false;
          if (isCallExpression(_elem)) return false;
          if (isMemberExpression(_elem)) return false;
        }

        var bindings = getBindingIdentifiers(pattern);
        var state = {
          deopt: false,
          bindings: bindings
        };

        try {
          traverse(arr, arrayUnpackVisitor, state);
        } catch (e) {
          if (e !== STOP_TRAVERSAL) throw e;
        }

        return !state.deopt;
      };

      _proto.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];

          if (isRestElement(elem)) {
            this.push(elem.argument, arrayExpression(arr.elements.slice(i)));
          } else {
            this.push(elem, arr.elements[i]);
          }
        }
      };

      _proto.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
        if (!pattern.elements) return;

        if (this.canUnpackArrayPattern(pattern, arrayRef)) {
          return this.pushUnpackedArrayPattern(pattern, arrayRef);
        }

        var count = !hasRest(pattern) && pattern.elements.length;
        var toArray = this.toArray(arrayRef, count);

        if (isIdentifier(toArray)) {
          arrayRef = toArray;
        } else {
          arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
          this.arrays[arrayRef.name] = true;
          this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
        }

        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];
          if (!elem) continue;
          var elemRef = void 0;

          if (isRestElement(elem)) {
            elemRef = this.toArray(arrayRef);
            elemRef = callExpression(memberExpression(elemRef, identifier("slice")), [numericLiteral(i)]);
            elem = elem.argument;
          } else {
            elemRef = memberExpression(arrayRef, numericLiteral(i), true);
          }

          this.push(elem, elemRef);
        }
      };

      _proto.init = function init(pattern, ref) {
        if (!isArrayExpression(ref) && !isMemberExpression(ref)) {
          var memo = this.scope.maybeGenerateMemoised(ref, true);

          if (memo) {
            this.nodes.push(this.buildVariableDeclaration(memo, cloneNode(ref)));
            ref = memo;
          }
        }

        this.push(pattern, ref);
        return this.nodes;
      };

      return DestructuringTransformer;
    }();

    return {
      name: "transform-destructuring",
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          if (!variableDeclarationHasPattern(declaration.node)) return;
          var specifiers = [];

          for (var _i7 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i7 < _Object$keys.length; _i7++) {
            var name = _Object$keys[_i7];
            specifiers.push(exportSpecifier(identifier(name), identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(exportNamedDeclaration(null, specifiers));
        },
        ForXStatement: function ForXStatement(path) {
          var _this = this;

          var node = path.node,
              scope = path.scope;
          var left = node.left;

          if (isPattern(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration("var", [variableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(expressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(expressionStatement(assignmentExpression("=", left, temp)));
            return;
          }

          if (!isVariableDeclaration(left)) return;
          var pattern = left.declarations[0].id;
          if (!isPattern(pattern)) return;
          var key = scope.generateUidIdentifier("ref");
          node.left = variableDeclaration(left.kind, [variableDeclarator(key, null)]);
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: left.kind,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: function addHelper(name) {
              return _this.addHelper(name);
            }
          });
          destructuring.init(pattern, key);
          path.ensureBlock();
          var block = node.body;
          block.body = nodes.concat(block.body);
        },
        CatchClause: function CatchClause(_ref2) {
          var _this2 = this;

          var node = _ref2.node,
              scope = _ref2.scope;
          var pattern = node.param;
          if (!isPattern(pattern)) return;
          var ref = scope.generateUidIdentifier("ref");
          node.param = ref;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: "let",
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: function addHelper(name) {
              return _this2.addHelper(name);
            }
          });
          destructuring.init(pattern, ref);
          node.body.body = nodes.concat(node.body.body);
        },
        AssignmentExpression: function AssignmentExpression(path) {
          var _this3 = this;

          var node = path.node,
              scope = path.scope;
          if (!isPattern(node.left)) return;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            operator: node.operator,
            scope: scope,
            nodes: nodes,
            arrayOnlySpread: arrayOnlySpread,
            allowArrayLike: allowArrayLike,
            addHelper: function addHelper(name) {
              return _this3.addHelper(name);
            }
          });
          var ref;

          if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
            ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
            nodes.push(variableDeclaration("var", [variableDeclarator(ref, node.right)]));

            if (isArrayExpression(node.right)) {
              destructuring.arrays[ref.name] = true;
            }
          }

          destructuring.init(node.left, ref || node.right);

          if (ref) {
            if (path.parentPath.isArrowFunctionExpression()) {
              path.replaceWith(blockStatement([]));
              nodes.push(returnStatement(cloneNode(ref)));
            } else {
              nodes.push(expressionStatement(cloneNode(ref)));
            }
          }

          path.replaceWithMultiple(nodes);
          path.scope.crawl();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          var _this4 = this;

          var node = path.node,
              scope = path.scope,
              parent = path.parent;
          if (isForXStatement(parent)) return;
          if (!parent || !path.container) return;
          if (!variableDeclarationHasPattern(node)) return;
          var nodeKind = node.kind;
          var nodes = [];
          var declar;

          for (var i = 0; i < node.declarations.length; i++) {
            declar = node.declarations[i];
            var patternId = declar.init;
            var pattern = declar.id;
            var destructuring = new DestructuringTransformer({
              blockHoist: node._blockHoist,
              nodes: nodes,
              scope: scope,
              kind: node.kind,
              arrayOnlySpread: arrayOnlySpread,
              allowArrayLike: allowArrayLike,
              addHelper: function addHelper(name) {
                return _this4.addHelper(name);
              }
            });

            if (isPattern(pattern)) {
              destructuring.init(pattern, patternId);

              if (+i !== node.declarations.length - 1) {
                inherits(nodes[nodes.length - 1], declar);
              }
            } else {
              nodes.push(inherits(destructuring.buildVariableAssignment(declar.id, cloneNode(declar.init)), declar));
            }
          }

          var tail = null;
          var nodesOut = [];

          for (var _i8 = 0, _nodes = nodes; _i8 < _nodes.length; _i8++) {
            var _node = _nodes[_i8];

            if (tail !== null && isVariableDeclaration(_node)) {
              var _tail$declarations;

              (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _node.declarations);
            } else {
              _node.kind = nodeKind;
              nodesOut.push(_node);
              tail = isVariableDeclaration(_node) ? _node : null;
            }
          }

          for (var _i9 = 0, _nodesOut = nodesOut; _i9 < _nodesOut.length; _i9++) {
            var nodeOut = _nodesOut[_i9];
            if (!nodeOut.declarations) continue;

            for (var _iterator = _createForOfIteratorHelperLoose(nodeOut.declarations), _step; !(_step = _iterator()).done;) {
              var declaration = _step.value;
              var name = declaration.id.name;

              if (scope.bindings[name]) {
                scope.bindings[name].kind = nodeOut.kind;
              }
            }
          }

          if (nodesOut.length === 1) {
            path.replaceWith(nodesOut[0]);
          } else {
            path.replaceWithMultiple(nodesOut);
          }
        }
      }
    };
  });

  var transformDotallRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-dotall-regex",
      feature: "dotAllFlag"
    });
  });

  function getName(key) {
    if (isIdentifier(key)) {
      return key.name;
    }

    return key.value.toString();
  }

  var transformDuplicateKeys = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-duplicate-keys",
      visitor: {
        ObjectExpression: function ObjectExpression(path) {
          var node = path.node;
          var plainProps = node.properties.filter(function (prop) {
            return !isSpreadElement(prop) && !prop.computed;
          });
          var alreadySeenData = Object.create(null);
          var alreadySeenGetters = Object.create(null);
          var alreadySeenSetters = Object.create(null);

          for (var _iterator = _createForOfIteratorHelperLoose(plainProps), _step; !(_step = _iterator()).done;) {
            var prop = _step.value;
            var name = getName(prop.key);
            var isDuplicate = false;

            switch (prop.kind) {
              case "get":
                if (alreadySeenData[name] || alreadySeenGetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenGetters[name] = true;
                break;

              case "set":
                if (alreadySeenData[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenSetters[name] = true;
                break;

              default:
                if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenData[name] = true;
            }

            if (isDuplicate) {
              prop.computed = true;
              prop.key = stringLiteral(name);
            }
          }
        }
      }
    };
  });

  function getObjRef(node, nodes, file, scope) {
    var ref;

    if (isSuper(node)) {
      return node;
    } else if (isIdentifier(node)) {
      if (scope.hasBinding(node.name)) {
        return node;
      } else {
        ref = node;
      }
    } else if (isMemberExpression(node)) {
      ref = node.object;

      if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {
        return ref;
      }
    } else {
      throw new Error("We can't explode this node type " + node.type);
    }

    var temp = scope.generateUidIdentifierBasedOnNode(ref);
    scope.push({
      id: temp
    });
    nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(ref)));
    return temp;
  }

  function getPropRef(node, nodes, file, scope) {
    var prop = node.property;
    var key = toComputedKey(node, prop);
    if (isLiteral(key) && isPureish(key)) return key;
    var temp = scope.generateUidIdentifierBasedOnNode(prop);
    scope.push({
      id: temp
    });
    nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(prop)));
    return temp;
  }

  function explode$1 (node, nodes, file, scope, allowedSingleIdent) {
    var obj;

    if (isIdentifier(node) && allowedSingleIdent) {
      obj = node;
    } else {
      obj = getObjRef(node, nodes, file, scope);
    }

    var ref, uid;

    if (isIdentifier(node)) {
      ref = cloneNode(node);
      uid = obj;
    } else {
      var prop = getPropRef(node, nodes, file, scope);
      var computed = node.computed || isLiteral(prop);
      uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);
      ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);
    }

    return {
      uid: uid,
      ref: ref
    };
  }

  function build (opts) {
    var build = opts.build,
        operator = opts.operator;
    return {
      AssignmentExpression: function AssignmentExpression(path) {
        var node = path.node,
            scope = path.scope;
        if (node.operator !== operator + "=") return;
        var nodes = [];
        var exploded = explode$1(node.left, nodes, this, scope);
        nodes.push(assignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
        path.replaceWith(sequenceExpression(nodes));
      },
      BinaryExpression: function BinaryExpression(path) {
        var node = path.node;

        if (node.operator === operator) {
          path.replaceWith(build(node.left, node.right));
        }
      }
    };
  }

  var transformExponentialOperator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-exponentiation-operator",
      visitor: build({
        operator: "**",
        build: function build(left, right) {
          return callExpression(memberExpression(identifier("Math"), identifier("pow")), [left, right]);
        }
      })
    };
  });

  var transformFlowComments = declare(function (api) {
    api.assertVersion(7);

    function commentFromString(comment) {
      return typeof comment === "string" ? {
        type: "CommentBlock",
        value: comment
      } : comment;
    }

    function attachComment(_ref) {
      var _toPath;

      var ofPath = _ref.ofPath,
          toPath = _ref.toPath,
          _ref$where = _ref.where,
          where = _ref$where === void 0 ? "trailing" : _ref$where,
          _ref$optional = _ref.optional,
          optional = _ref$optional === void 0 ? false : _ref$optional,
          _ref$comments = _ref.comments,
          comments = _ref$comments === void 0 ? generateComment(ofPath, optional) : _ref$comments,
          _ref$keepType = _ref.keepType,
          keepType = _ref$keepType === void 0 ? false : _ref$keepType;

      if (!((_toPath = toPath) == null ? void 0 : _toPath.node)) {
        toPath = ofPath.getPrevSibling();
        where = "trailing";
      }

      if (!toPath.node) {
        toPath = ofPath.getNextSibling();
        where = "leading";
      }

      if (!toPath.node) {
        toPath = ofPath.parentPath;
        where = "inner";
      }

      if (!Array.isArray(comments)) {
        comments = [comments];
      }

      comments = comments.map(commentFromString);

      if (!keepType && (ofPath == null ? void 0 : ofPath.node)) {
        var node = ofPath.node;
        var parent = ofPath.parentPath;
        var prev = ofPath.getPrevSibling();
        var next = ofPath.getNextSibling();
        var isSingleChild = !(prev.node || next.node);
        var leading = node.leadingComments;
        var trailing = node.trailingComments;

        if (isSingleChild && leading) {
          parent.addComments("inner", leading);
        }

        toPath.addComments(where, comments);
        ofPath.remove();

        if (isSingleChild && trailing) {
          parent.addComments("inner", trailing);
        }
      } else {
        toPath.addComments(where, comments);
      }
    }

    function wrapInFlowComment(path) {
      attachComment({
        ofPath: path,
        comments: generateComment(path, path.parent.optional)
      });
    }

    function generateComment(path, optional) {
      var comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
      if (optional) comment = "?" + comment;
      if (comment[0] !== ":") comment = ":: " + comment;
      return comment;
    }

    function isTypeImport(importKind) {
      return importKind === "type" || importKind === "typeof";
    }

    return {
      name: "transform-flow-comments",
      inherits: syntaxFlow,
      visitor: {
        TypeCastExpression: function TypeCastExpression(path) {
          var node = path.node;
          attachComment({
            ofPath: path.get("typeAnnotation"),
            toPath: path.get("expression"),
            keepType: true
          });
          path.replaceWith(parenthesizedExpression(node.expression));
        },
        Identifier: function Identifier(path) {
          if (path.parentPath.isFlow()) return;
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });

            if (node.optional) {
              node.optional = false;
            }
          } else if (node.optional) {
            attachComment({
              toPath: path,
              comments: ":: ?"
            });
            node.optional = false;
          }
        },
        AssignmentPattern: {
          exit: function exit(_ref2) {
            var node = _ref2.node;
            var left = node.left;

            if (left.optional) {
              left.optional = false;
            }
          }
        },
        Function: function Function(path) {
          if (path.isDeclareFunction()) return;
          var node = path.node;

          if (node.typeParameters) {
            attachComment({
              ofPath: path.get("typeParameters"),
              toPath: path.get("id"),
              optional: node.typeParameters.optional
            });
          }

          if (node.returnType) {
            attachComment({
              ofPath: path.get("returnType"),
              toPath: path.get("body"),
              where: "leading",
              optional: node.returnType.typeAnnotation.optional
            });
          }
        },
        ClassProperty: function ClassProperty(path) {
          var node = path.node;

          if (!node.value) {
            wrapInFlowComment(path);
          } else if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path.get("key"),
              optional: node.typeAnnotation.optional
            });
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var node = path.node;

          if (node.exportKind !== "type" && !isFlow(node.declaration)) {
            return;
          }

          wrapInFlowComment(path);
        },
        ImportDeclaration: function ImportDeclaration(path) {
          var node = path.node;

          if (isTypeImport(node.importKind)) {
            wrapInFlowComment(path);
            return;
          }

          var typeSpecifiers = node.specifiers.filter(function (specifier) {
            return isTypeImport(specifier.importKind);
          });
          var nonTypeSpecifiers = node.specifiers.filter(function (specifier) {
            return !isTypeImport(specifier.importKind);
          });
          node.specifiers = nonTypeSpecifiers;

          if (typeSpecifiers.length > 0) {
            var typeImportNode = cloneNode(node);
            typeImportNode.specifiers = typeSpecifiers;
            var comment = ":: " + generateCode(typeImportNode).code;

            if (nonTypeSpecifiers.length > 0) {
              attachComment({
                toPath: path,
                comments: comment
              });
            } else {
              attachComment({
                ofPath: path,
                comments: comment
              });
            }
          }
        },
        ObjectPattern: function ObjectPattern(path) {
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });
          }
        },
        Flow: function Flow(path) {
          wrapInFlowComment(path);
        },
        Class: function Class(path) {
          var node = path.node;
          var comments = [];

          if (node.typeParameters) {
            var typeParameters = path.get("typeParameters");
            comments.push(generateComment(typeParameters, node.typeParameters.optional));
            var trailingComments = node.typeParameters.trailingComments;

            if (trailingComments) {
              var _comments;

              (_comments = comments).push.apply(_comments, trailingComments);
            }

            typeParameters.remove();
          }

          if (node.superClass) {
            if (comments.length > 0) {
              attachComment({
                toPath: path.get("id"),
                comments: comments
              });
              comments = [];
            }

            if (node.superTypeParameters) {
              var superTypeParameters = path.get("superTypeParameters");
              comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
              superTypeParameters.remove();
            }
          }

          if (node["implements"]) {
            var impls = path.get("implements");
            var comment = "implements " + impls.map(function (impl) {
              return generateComment(impl).replace(/^:: /, "");
            }).join(", ");
            delete node["implements"];

            if (comments.length === 1) {
              comments[0] += " " + comment;
            } else {
              comments.push(":: " + comment);
            }
          }

          if (comments.length > 0) {
            attachComment({
              toPath: path.get("body"),
              where: "leading",
              comments: comments
            });
          }
        }
      }
    };
  });

  var transformFlowStripTypes = declare(function (api, opts) {
    api.assertVersion(7);
    var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
    var skipStrip = false;
    var _opts$requireDirectiv = opts.requireDirective,
        requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv;

    if (!process.env.BABEL_8_BREAKING) {
      var _opts$allowDeclareFie = opts.allowDeclareFields,
          allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
    }

    return {
      name: "transform-flow-strip-types",
      inherits: syntaxFlow,
      visitor: {
        Program: function Program(path, _ref) {
          var comments = _ref.file.ast.comments;
          skipStrip = false;
          var directiveFound = false;

          if (comments) {
            for (var _i = 0, _arr = comments; _i < _arr.length; _i++) {
              var comment = _arr[_i];

              if (FLOW_DIRECTIVE.test(comment.value)) {
                directiveFound = true;
                comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

                if (!comment.value.replace(/\*/g, "").trim()) {
                  comment.ignore = true;
                }
              }
            }
          }

          if (!directiveFound && requireDirective) {
            skipStrip = true;
          }
        },
        ImportDeclaration: function ImportDeclaration(path) {
          if (skipStrip) return;
          if (!path.node.specifiers.length) return;
          var typeCount = 0;
          path.node.specifiers.forEach(function (_ref2) {
            var importKind = _ref2.importKind;

            if (importKind === "type" || importKind === "typeof") {
              typeCount++;
            }
          });

          if (typeCount === path.node.specifiers.length) {
            path.remove();
          }
        },
        Flow: function Flow(path) {
          if (skipStrip) {
            throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
          }

          path.remove();
        },
        ClassPrivateProperty: function ClassPrivateProperty(path) {
          if (skipStrip) return;
          path.node.typeAnnotation = null;
        },
        Class: function Class(path) {
          if (skipStrip) return;
          path.node["implements"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassProperty()) {
              var node = child.node;

              if (!process.env.BABEL_8_BREAKING) {
                if (!allowDeclareFields && node.declare) {
                  throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
                }
              }

              if (node.declare) {
                child.remove();
              } else {
                if (!process.env.BABEL_8_BREAKING) {
                  if (!allowDeclareFields && !node.value && !node.decorators) {
                    child.remove();
                    return;
                  }
                }

                node.variance = null;
                node.typeAnnotation = null;
              }
            }
          });
        },
        AssignmentPattern: function AssignmentPattern(_ref3) {
          var node = _ref3.node;
          if (skipStrip) return;
          node.left.optional = false;
        },
        Function: function Function(_ref4) {
          var node = _ref4.node;
          if (skipStrip) return;

          for (var i = 0; i < node.params.length; i++) {
            var param = node.params[i];
            param.optional = false;

            if (param.type === "AssignmentPattern") {
              param.left.optional = false;
            }
          }

          node.predicate = null;
        },
        TypeCastExpression: function TypeCastExpression(path) {
          if (skipStrip) return;
          var node = path.node;

          do {
            node = node.expression;
          } while (isTypeCastExpression(node));

          path.replaceWith(node);
        },
        CallExpression: function CallExpression(_ref5) {
          var node = _ref5.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        OptionalCallExpression: function OptionalCallExpression(_ref6) {
          var node = _ref6.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        NewExpression: function NewExpression(_ref7) {
          var node = _ref7.node;
          if (skipStrip) return;
          node.typeArguments = null;
        }
      }
    };
  });

  function transformWithoutHelper(loose, path, state) {
    var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    var node = path.node;
    var build = pushComputedProps(path, state);
    var declar = build.declar;
    var loop = build.loop;
    var block = loop.body;
    path.ensureBlock();

    if (declar) {
      block.body.push(declar);
    }

    block.body = block.body.concat(node.body.body);
    inherits(loop, node);
    inherits(loop.body, node.body);

    if (build.replaceParent) {
      path.parentPath.replaceWithMultiple(build.node);
      path.remove();
    } else {
      path.replaceWithMultiple(build.node);
    }
  }
  var buildForOfLoose = template("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n");
  var buildForOf = template("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");

  function pushComputedPropsLoose(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar, id, intermediate;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      id = left;
      intermediate = null;
    } else if (isVariableDeclaration(left)) {
      id = scope.generateUidIdentifier("ref");
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, identifier(id.name))]);
      intermediate = variableDeclaration("var", [variableDeclarator(identifier(id.name))]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var iteratorKey = scope.generateUidIdentifier("iterator");
    var isArrayKey = scope.generateUidIdentifier("isArray");
    var loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate
    });
    var isLabeledParent = isLabeledStatement(parent);
    var labeled;

    if (isLabeledParent) {
      labeled = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop
    };
  }

  function pushComputedPropsSpec(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar;
    var stepKey = scope.generateUid("step");
    var stepValue = memberExpression(identifier(stepKey), identifier("value"));

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = expressionStatement(assignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: identifier(stepKey),
      OBJECT: node.right
    });
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template
    };
  }

  var transformForOf = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose,
        assumeArray = options.assumeArray,
        allowArrayLike = options.allowArrayLike;

    if (loose === true && assumeArray === true) {
      throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
    }

    if (assumeArray === true && allowArrayLike === true) {
      throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
    }

    if (allowArrayLike && /^7\.\d\./.test(api.version)) {
      throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
    }

    if (assumeArray) {
      return {
        name: "transform-for-of",
        visitor: {
          ForOfStatement: function ForOfStatement(path) {
            var scope = path.scope;
            var _path$node = path.node,
                left = _path$node.left,
                right = _path$node.right,
                isAwait = _path$node["await"];

            if (isAwait) {
              return;
            }

            var i = scope.generateUidIdentifier("i");
            var array = scope.maybeGenerateMemoised(right, true);
            var inits = [variableDeclarator(i, numericLiteral(0))];

            if (array) {
              inits.push(variableDeclarator(array, right));
            } else {
              array = right;
            }

            var item = memberExpression(cloneNode(array), cloneNode(i), true);
            var assignment;

            if (isVariableDeclaration(left)) {
              assignment = left;
              assignment.declarations[0].init = item;
            } else {
              assignment = expressionStatement(assignmentExpression("=", left, item));
            }

            var blockBody;
            var body = path.get("body");

            if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
              return body.scope.hasOwnBinding(id);
            })) {
              blockBody = blockStatement([assignment, body.node]);
            } else {
              blockBody = toBlock(body.node);
              blockBody.body.unshift(assignment);
            }

            path.replaceWith(forStatement(variableDeclaration("let", inits), binaryExpression("<", cloneNode(i), memberExpression(cloneNode(array), identifier("length"))), updateExpression("++", cloneNode(i)), blockBody));
          }
        }
      };
    }

    var buildForOfArray = template("\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  ");
    var buildForOfLoose = template.statements("\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ALLOW_ARRAY_LIKE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  ");
    var buildForOf = template.statements("\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ALLOW_ARRAY_LIKE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  ");
    var builder = loose ? {
      build: buildForOfLoose,
      helper: "createForOfIteratorHelperLoose",
      getContainer: function getContainer(nodes) {
        return nodes;
      }
    } : {
      build: buildForOf,
      helper: "createForOfIteratorHelper",
      getContainer: function getContainer(nodes) {
        return nodes[1].block.body;
      }
    };

    function _ForOfStatementArray(path) {
      var node = path.node,
          scope = path.scope;
      var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
      var iterationKey = scope.generateUidIdentifier("i");
      var loop = buildForOfArray({
        BODY: node.body,
        KEY: iterationKey,
        NAME: right,
        ARR: node.right
      });
      inherits(loop, node);
      ensureBlock(loop);
      var iterationValue = memberExpression(cloneNode(right), cloneNode(iterationKey), true);
      var left = node.left;

      if (isVariableDeclaration(left)) {
        left.declarations[0].init = iterationValue;
        loop.body.body.unshift(left);
      } else {
        loop.body.body.unshift(expressionStatement(assignmentExpression("=", left, iterationValue)));
      }

      return loop;
    }

    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement: function ForOfStatement(path, state) {
          var right = path.get("right");

          if (right.isArrayExpression() || right.isGenericType("Array") || isArrayTypeAnnotation(right.getTypeAnnotation())) {
            path.replaceWith(_ForOfStatementArray(path));
            return;
          }

          if (!state.availableHelper(builder.helper)) {
            transformWithoutHelper(loose, path, state);
            return;
          }

          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var left = node.left;
          var declar;
          var stepKey = scope.generateUid("step");
          var stepValue = memberExpression(identifier(stepKey), identifier("value"));

          if (isVariableDeclaration(left)) {
            declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
          } else {
            declar = expressionStatement(assignmentExpression("=", left, stepValue));
          }

          path.ensureBlock();
          node.body.body.unshift(declar);
          var nodes = builder.build({
            CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
            ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
            ALLOW_ARRAY_LIKE: allowArrayLike ? booleanLiteral(true) : null,
            STEP_KEY: identifier(stepKey),
            OBJECT: node.right,
            BODY: node.body
          });
          var container = builder.getContainer(nodes);
          inherits(container[0], node);
          inherits(container[0].body, node.body);

          if (isLabeledStatement(parent)) {
            container[0] = labeledStatement(parent.label, container[0]);
            path.parentPath.replaceWithMultiple(nodes);
            path.skip();
          } else {
            path.replaceWithMultiple(nodes);
          }
        }
      }
    };
  });

  var transformFunctionName = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-function-name",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
              var replacement = nameFunction(path);
              if (replacement) path.replaceWith(replacement);
            }
          }
        },
        ObjectProperty: function ObjectProperty(path) {
          var value = path.get("value");

          if (value.isFunction()) {
            var newNode = nameFunction(value);
            if (newNode) value.replaceWith(newNode);
          }
        }
      }
    };
  });

  var transformInstanceof = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-instanceof",
      visitor: {
        BinaryExpression: function BinaryExpression(path) {
          var node = path.node;

          if (node.operator === "instanceof") {
            var helper = this.addHelper("instanceof");
            var isUnderHelper = path.findParent(function (path) {
              return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
            });

            if (isUnderHelper) {
              return;
            } else {
              path.replaceWith(callExpression(helper, [node.left, node.right]));
            }
          }
        }
      }
    };
  });

  var transformJscript = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-jscript",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            var node = path.node;
            if (!node.id) return;
            path.replaceWith(callExpression(functionExpression(null, [], blockStatement([toStatement(node), returnStatement(cloneNode(node.id))])), []));
          }
        }
      }
    };
  });

  var transformLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-literals",
      visitor: {
        NumericLiteral: function NumericLiteral(_ref) {
          var node = _ref.node;

          if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
            node.extra = undefined;
          }
        },
        StringLiteral: function StringLiteral(_ref2) {
          var node = _ref2.node;

          if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
            node.extra = undefined;
          }
        }
      }
    };
  });

  var transformMemberExpressionLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-member-expression-literals",
      visitor: {
        MemberExpression: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var prop = node.property;

            if (!node.computed && isIdentifier(prop) && !isValidES3Identifier(prop.name)) {
              node.property = stringLiteral(prop.name);
              node.computed = true;
            }
          }
        }
      }
    };
  });

  var utils = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  exports.getImportSource = getImportSource;
  exports.createDynamicImportTransform = createDynamicImportTransform;

  function getImportSource(t, callNode) {
    var importArguments = callNode.arguments;

    var _importArguments = _slicedToArray(importArguments, 1),
        importPath = _importArguments[0];

    var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

    if (isString) {
      t.removeComments(importPath);
      return importPath;
    }

    return t.templateLiteral([t.templateElement({
      raw: '',
      cooked: ''
    }), t.templateElement({
      raw: '',
      cooked: ''
    }, true)], importArguments);
  }

  function createDynamicImportTransform(_ref) {
    var template = _ref.template,
        t = _ref.types;
    var builders = {
      'static': {
        interop: template('Promise.resolve().then(() => INTEROP(require(SOURCE)))'),
        noInterop: template('Promise.resolve().then(() => require(SOURCE))')
      },
      dynamic: {
        interop: template('Promise.resolve(SOURCE).then(s => INTEROP(require(s)))'),
        noInterop: template('Promise.resolve(SOURCE).then(s => require(s))')
      }
    };
    var visited = typeof WeakSet === 'function' && new WeakSet();

    var isString = function isString(node) {
      return t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0;
    };

    return function (context, path) {
      if (visited) {
        if (visited.has(path)) {
          return;
        }

        visited.add(path);
      }

      var SOURCE = getImportSource(t, path.parent);
      var builder = isString(SOURCE) ? builders['static'] : builders.dynamic;
      var newImport = context.opts.noInterop ? builder.noInterop({
        SOURCE: SOURCE
      }) : builder.interop({
        SOURCE: SOURCE,
        INTEROP: context.addHelper('interopRequireWildcard')
      });
      path.parentPath.replaceWith(newImport);
    };
  }
  });

  var utils$1 = utils;

  function _templateObject$d() {
    var data = _taggedTemplateLiteralLoose(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"]);

    _templateObject$d = function _templateObject() {
      return data;
    };

    return data;
  }
  var buildWrapper = template("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
  var buildAnonymousWrapper = template("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

  function injectWrapper(path, wrapper) {
    var _path$node = path.node,
        body = _path$node.body,
        directives = _path$node.directives;
    path.node.directives = [];
    path.node.body = [];
    var amdWrapper = path.pushContainer("body", wrapper)[0];
    var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
      return arg.isFunctionExpression();
    })[0].get("body");
    amdFactory.pushContainer("directives", directives);
    amdFactory.pushContainer("body", body);
  }

  var transformModulesAmd = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop;
    return {
      name: "transform-modules-amd",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "amd");
      },
      visitor: {
        CallExpression: function CallExpression(path, state) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var requireId = state.requireId,
              resolveId = state.resolveId,
              rejectId = state.rejectId;

          if (!requireId) {
            requireId = path.scope.generateUidIdentifier("require");
            state.requireId = requireId;
          }

          if (!resolveId || !rejectId) {
            resolveId = path.scope.generateUidIdentifier("resolve");
            rejectId = path.scope.generateUidIdentifier("reject");
            state.resolveId = resolveId;
            state.rejectId = rejectId;
          }

          var result = identifier("imported");
          if (!noInterop) result = wrapInterop(path, result, "namespace");
          path.replaceWith(template.expression.ast(_templateObject$d(), resolveId, rejectId, requireId, utils$1.getImportSource(t, path.node), cloneNode(resolveId), result, cloneNode(rejectId)));
        },
        Program: {
          exit: function exit(path, _ref) {
            var requireId = _ref.requireId;

            if (!isModule(path)) {
              if (requireId) {
                injectWrapper(path, buildAnonymousWrapper({
                  REQUIRE: cloneNode(requireId)
                }));
              }

              return;
            }

            var amdArgs = [];
            var importNames = [];

            if (requireId) {
              amdArgs.push(stringLiteral("require"));
              importNames.push(cloneNode(requireId));
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            if (hasExports(meta)) {
              amdArgs.push(stringLiteral("exports"));
              importNames.push(identifier(meta.exportName));
            }

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _step.value,
                  source = _step$value[0],
                  metadata = _step$value[1];
              amdArgs.push(stringLiteral(source));
              importNames.push(identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = expressionStatement(assignmentExpression("=", identifier(metadata.name), interop));
                  header.loc = metadata.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            injectWrapper(path, buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: arrayExpression(amdArgs),
              IMPORT_NAMES: importNames
            }));
          }
        }
      }
    };
  });

  function _templateObject3$5() {
    var data = _taggedTemplateLiteralLoose(["\n                  var ", " = ", ";\n                "]);

    _templateObject3$5 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2$5() {
    var data = _taggedTemplateLiteralLoose(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "]);

    _templateObject2$5 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$e() {
    var data = _taggedTemplateLiteralLoose(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "]);

    _templateObject$e = function _templateObject() {
      return data;
    };

    return data;
  }
  var transformModulesCommonjs = declare(function (api, options) {
    api.assertVersion(7);
    var transformImportCall = utils$1.createDynamicImportTransform(api);
    var loose = options.loose,
        _options$strictNamesp = options.strictNamespace,
        strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
        _options$mjsStrictNam = options.mjsStrictNamespace,
        mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop,
        _options$lazy = options.lazy,
        lazy = _options$lazy === void 0 ? false : _options$lazy,
        _options$allowCommonJ = options.allowCommonJSExports,
        allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;

    if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
      return typeof item === "string";
    }))) {
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    }

    if (typeof strictNamespace !== "boolean") {
      throw new Error(".strictNamespace must be a boolean, or undefined");
    }

    if (typeof mjsStrictNamespace !== "boolean") {
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    }

    var getAssertion = function getAssertion(localName) {
      return template.expression.ast(_templateObject$e(), localName);
    };

    var moduleExportsVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var localName = path.node.name;
        if (localName !== "module" && localName !== "exports") return;
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = this.scope.getBinding(localName);

        if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
          value: path.node
        }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
          left: path.node
        }) || path.isAssignmentExpression({
          left: path.node
        })) {
          return;
        }

        path.replaceWith(getAssertion(localName));
      },
      AssignmentExpression: function AssignmentExpression(path) {
        var _this = this;

        var left = path.get("left");

        if (left.isIdentifier()) {
          var localName = path.node.name;
          if (localName !== "module" && localName !== "exports") return;
          var localBinding = path.scope.getBinding(localName);
          var rootBinding = this.scope.getBinding(localName);
          if (rootBinding !== localBinding) return;
          var right = path.get("right");
          right.replaceWith(sequenceExpression([right.node, getAssertion(localName)]));
        } else if (left.isPattern()) {
          var ids = left.getOuterBindingIdentifiers();
          var _localName = Object.keys(ids).filter(function (localName) {
            if (localName !== "module" && localName !== "exports") return false;
            return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
          })[0];

          if (_localName) {
            var _right = path.get("right");

            _right.replaceWith(sequenceExpression([_right.node, getAssertion(_localName)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
      },
      visitor: {
        CallExpression: function CallExpression(path) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var scope = path.scope;

          do {
            scope.rename("require");
          } while (scope = scope.parent);

          transformImportCall(this, path.get("callee"));
        },
        Program: {
          exit: function exit(path, state) {
            if (!isModule(path)) return;
            path.scope.rename("exports");
            path.scope.rename("module");
            path.scope.rename("require");
            path.scope.rename("__filename");
            path.scope.rename("__dirname");

            if (!allowCommonJSExports) {
              simplifyAccess(path, new Set(["module", "exports"]));
              path.traverse(moduleExportsVisitor, {
                scope: path.scope
              });
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              exportName: "exports",
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop,
              lazy: lazy,
              esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _step.value,
                  source = _step$value[0],
                  metadata = _step$value[1];
              var loadExpr = callExpression(identifier("require"), [stringLiteral(source)]);
              var header = void 0;

              if (isSideEffectImport(metadata)) {
                if (metadata.lazy) throw new Error("Assertion failure");
                header = expressionStatement(loadExpr);
              } else {
                var init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;

                if (metadata.lazy) {
                  header = template.ast(_templateObject2$5(), metadata.name, init, metadata.name);
                } else {
                  header = template.ast(_templateObject3$5(), metadata.name, init);
                }
              }

              header.loc = metadata.loc;
              headers.push(header);
              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
          }
        }
      }
    };
  });

  var visitor$3 = {
    Scope: function Scope(path, state) {
      if (state.kind === "let") path.skip();
    },
    Function: function Function(path) {
      path.skip();
    },
    VariableDeclaration: function VariableDeclaration(path, state) {
      if (state.kind && path.node.kind !== state.kind) return;
      var nodes = [];
      var declarations = path.get("declarations");
      var firstId;

      for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
        var declar = _step.value;
        firstId = declar.node.id;

        if (declar.node.init) {
          nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
        }

        for (var _i = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          state.emit(identifier(name), name, declar.node.init !== null);
        }
      }

      if (path.parentPath.isFor({
        left: path.node
      })) {
        path.replaceWith(firstId);
      } else {
        path.replaceWithMultiple(nodes);
      }
    }
  };
  function hoistVariables (path, emit, kind) {
    if (kind === void 0) {
      kind = "var";
    }

    path.traverse(visitor$3, {
      kind: kind,
      emit: emit
    });
  }

  var buildTemplate = template("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n");
  var buildExportAll = template("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
  var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";
  function getExportSpecifierName$1(node, stringSpecifiers) {
    if (node.type === "Identifier") {
      return node.name;
    } else if (node.type === "StringLiteral") {
      var stringValue = node.value;

      if (!isIdentifierName(stringValue)) {
        stringSpecifiers.add(stringValue);
      }

      return stringValue;
    } else {
      throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + node.type);
    }
  }

  function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
    var statements = [];

    if (!exportStarTarget) {
      if (exportNames.length === 1) {
        statements.push(expressionStatement(callExpression(exportIdent, [stringLiteral(exportNames[0]), exportValues[0]])));
      } else {
        var objectProperties = [];

        for (var i = 0; i < exportNames.length; i++) {
          var exportName = exportNames[i];
          var exportValue = exportValues[i];
          objectProperties.push(objectProperty(stringSpecifiers.has(exportName) ? stringLiteral(exportName) : identifier(exportName), exportValue));
        }

        statements.push(expressionStatement(callExpression(exportIdent, [objectExpression(objectProperties)])));
      }
    } else {
      var exportObj = path.scope.generateUid("exportObj");
      statements.push(variableDeclaration("var", [variableDeclarator(identifier(exportObj), objectExpression([]))]));
      statements.push(buildExportAll({
        KEY: path.scope.generateUidIdentifier("key"),
        EXPORT_OBJ: identifier(exportObj),
        TARGET: exportStarTarget
      }));

      for (var _i = 0; _i < exportNames.length; _i++) {
        var _exportName = exportNames[_i];
        var _exportValue = exportValues[_i];
        statements.push(expressionStatement(assignmentExpression("=", memberExpression(identifier(exportObj), identifier(_exportName)), _exportValue)));
      }

      statements.push(expressionStatement(callExpression(exportIdent, [identifier(exportObj)])));
    }

    return statements;
  }

  var transformModulesSystemjs = declare(function (api, options) {
    api.assertVersion(7);
    var _options$systemGlobal = options.systemGlobal,
        systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
        _options$allowTopLeve = options.allowTopLevelThis,
        allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
    var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
    var reassignmentVisitor = {
      "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
        if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
        path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
        var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

        if (arg.isObjectPattern() || arg.isArrayPattern()) {
          var exprs = [path.node];

          for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
            var _name = _Object$keys[_i2];

            if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
              return;
            }

            var _exportedNames = this.exports[_name];
            if (!_exportedNames) return;

            for (var _iterator = _createForOfIteratorHelperLoose(_exportedNames), _step; !(_step = _iterator()).done;) {
              var exportedName = _step.value;
              exprs.push(this.buildCall(exportedName, identifier(_name)).expression);
            }
          }

          path.replaceWith(sequenceExpression(exprs));
          return;
        }

        if (!arg.isIdentifier()) return;
        var name = arg.node.name;
        if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
        var exportedNames = this.exports[name];
        if (!exportedNames) return;
        var node = path.node;
        var isPostUpdateExpression = path.isUpdateExpression({
          prefix: false
        });

        if (isPostUpdateExpression) {
          node = binaryExpression(node.operator[0], unaryExpression("+", cloneNode(node.argument)), numericLiteral(1));
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(exportedNames), _step2; !(_step2 = _iterator2()).done;) {
          var _exportedName = _step2.value;
          node = this.buildCall(_exportedName, node).expression;
        }

        if (isPostUpdateExpression) {
          node = sequenceExpression([node, path.node]);
        }

        path.replaceWith(node);
      }
    };
    return {
      name: "transform-modules-systemjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "systemjs");
      },
      visitor: {
        CallExpression: function CallExpression(path, state) {
          if (isImport(path.node.callee)) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
              console.warn(MISSING_PLUGIN_WARNING);
            }

            path.replaceWith(callExpression(memberExpression(identifier(state.contextIdent), identifier("import")), [utils$1.getImportSource(t, path.node)]));
          }
        },
        MetaProperty: function MetaProperty(path, state) {
          if (path.node.meta.name === "import" && path.node.property.name === "meta") {
            path.replaceWith(memberExpression(identifier(state.contextIdent), identifier("meta")));
          }
        },
        ReferencedIdentifier: function ReferencedIdentifier(path, state) {
          if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
            path.replaceWith(memberExpression(identifier(state.contextIdent), identifier("id")));
          }
        },
        Program: {
          enter: function enter(path, state) {
            state.contextIdent = path.scope.generateUid("context");
            state.stringSpecifiers = new Set();

            if (!allowTopLevelThis) {
              rewriteThis(path);
            }
          },
          exit: function exit(path, state) {
            var scope = path.scope;
            var exportIdent = scope.generateUid("export");
            var contextIdent = state.contextIdent,
                stringSpecifiers = state.stringSpecifiers;
            var exportMap = Object.create(null);
            var modules = [];
            var beforeBody = [];
            var setters = [];
            var sources = [];
            var variableIds = [];
            var removedPaths = [];

            function addExportName(key, val) {
              exportMap[key] = exportMap[key] || [];
              exportMap[key].push(val);
            }

            function pushModule(source, key, specifiers) {
              var module;
              modules.forEach(function (m) {
                if (m.key === source) {
                  module = m;
                }
              });

              if (!module) {
                modules.push(module = {
                  key: source,
                  imports: [],
                  exports: []
                });
              }

              module[key] = module[key].concat(specifiers);
            }

            function buildExportCall(name, val) {
              return expressionStatement(callExpression(identifier(exportIdent), [stringLiteral(name), val]));
            }

            var exportNames = [];
            var exportValues = [];
            var body = path.get("body");

            for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
              var _path2 = _step3.value;

              if (_path2.isFunctionDeclaration()) {
                beforeBody.push(_path2.node);
                removedPaths.push(_path2);
              } else if (_path2.isClassDeclaration()) {
                variableIds.push(cloneNode(_path2.node.id));

                _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(_path2.node.id), toExpression(_path2.node))));
              } else if (_path2.isImportDeclaration()) {
                var source = _path2.node.source.value;
                pushModule(source, "imports", _path2.node.specifiers);

                for (var _i4 = 0, _Object$keys2 = Object.keys(_path2.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
                  var name = _Object$keys2[_i4];
                  scope.removeBinding(name);
                  variableIds.push(identifier(name));
                }

                _path2.remove();
              } else if (_path2.isExportAllDeclaration()) {
                pushModule(_path2.node.source.value, "exports", _path2.node);

                _path2.remove();
              } else if (_path2.isExportDefaultDeclaration()) {
                var declar = _path2.get("declaration");

                var id = declar.node.id;

                if (declar.isClassDeclaration()) {
                  if (id) {
                    exportNames.push("default");
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(cloneNode(id));
                    addExportName(id.name, "default");

                    _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(id), toExpression(declar.node))));
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                    removedPaths.push(_path2);
                  }
                } else if (declar.isFunctionDeclaration()) {
                  if (id) {
                    beforeBody.push(declar.node);
                    exportNames.push("default");
                    exportValues.push(cloneNode(id));
                    addExportName(id.name, "default");
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                  }

                  removedPaths.push(_path2);
                } else {
                  _path2.replaceWith(buildExportCall("default", declar.node));
                }
              } else if (_path2.isExportNamedDeclaration()) {
                var _declar = _path2.get("declaration");

                if (_declar.node) {
                  _path2.replaceWith(_declar);

                  if (_path2.isFunction()) {
                    var node = _declar.node;
                    var _name2 = node.id.name;
                    addExportName(_name2, _name2);
                    beforeBody.push(node);
                    exportNames.push(_name2);
                    exportValues.push(cloneNode(node.id));
                    removedPaths.push(_path2);
                  } else if (_path2.isClass()) {
                    var _name3 = _declar.node.id.name;
                    exportNames.push(_name3);
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(cloneNode(_declar.node.id));

                    _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(_declar.node.id), toExpression(_declar.node))));

                    addExportName(_name3, _name3);
                  } else {
                    for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
                      var _name4 = _Object$keys3[_i5];
                      addExportName(_name4, _name4);
                    }
                  }
                } else {
                  var specifiers = _path2.node.specifiers;

                  if (specifiers == null ? void 0 : specifiers.length) {
                    if (_path2.node.source) {
                      pushModule(_path2.node.source.value, "exports", specifiers);

                      _path2.remove();
                    } else {
                      var nodes = [];

                      for (var _iterator7 = _createForOfIteratorHelperLoose(specifiers), _step7; !(_step7 = _iterator7()).done;) {
                        var specifier = _step7.value;
                        var local = specifier.local,
                            exported = specifier.exported;
                        var binding = scope.getBinding(local.name);
                        var exportedName = getExportSpecifierName$1(exported, stringSpecifiers);

                        if (binding && isFunctionDeclaration(binding.path.node)) {
                          exportNames.push(exportedName);
                          exportValues.push(cloneNode(local));
                        } else if (!binding) {
                            nodes.push(buildExportCall(exportedName, local));
                          }

                        addExportName(local.name, exportedName);
                      }

                      _path2.replaceWithMultiple(nodes);
                    }
                  } else {
                    _path2.remove();
                  }
                }
              }
            }

            modules.forEach(function (specifiers) {
              var setterBody = [];
              var target = scope.generateUid(specifiers.key);

              for (var _iterator4 = _createForOfIteratorHelperLoose(specifiers.imports), _step4; !(_step4 = _iterator4()).done;) {
                var specifier = _step4.value;

                if (isImportNamespaceSpecifier(specifier)) {
                  setterBody.push(expressionStatement(assignmentExpression("=", specifier.local, identifier(target))));
                } else if (isImportDefaultSpecifier(specifier)) {
                  specifier = importSpecifier(specifier.local, identifier("default"));
                }

                if (isImportSpecifier(specifier)) {
                  var _specifier = specifier,
                      imported = _specifier.imported;
                  setterBody.push(expressionStatement(assignmentExpression("=", specifier.local, memberExpression(identifier(target), specifier.imported, imported.type === "StringLiteral"))));
                }
              }

              if (specifiers.exports.length) {
                var _exportNames = [];
                var _exportValues = [];
                var hasExportStar = false;

                for (var _iterator5 = _createForOfIteratorHelperLoose(specifiers.exports), _step5; !(_step5 = _iterator5()).done;) {
                  var node = _step5.value;

                  if (isExportAllDeclaration(node)) {
                    hasExportStar = true;
                  } else if (isExportSpecifier(node)) {
                    var exportedName = getExportSpecifierName$1(node.exported, stringSpecifiers);

                    _exportNames.push(exportedName);

                    _exportValues.push(memberExpression(identifier(target), node.local, isStringLiteral(node.local)));
                  } else ;
                }

                setterBody = setterBody.concat(constructExportCall(path, identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? identifier(target) : null, stringSpecifiers));
              }

              sources.push(stringLiteral(specifiers.key));
              setters.push(functionExpression(null, [identifier(target)], blockStatement(setterBody)));
            });
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);
            hoistVariables(path, function (id, name, hasInit) {
              variableIds.push(id);

              if (!hasInit && name in exportMap) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(exportMap[name]), _step6; !(_step6 = _iterator6()).done;) {
                  var exported = _step6.value;
                  exportNames.push(exported);
                  exportValues.push(scope.buildUndefinedNode());
                }
              }
            }, null);

            if (variableIds.length) {
              beforeBody.unshift(variableDeclaration("var", variableIds.map(function (id) {
                return variableDeclarator(id);
              })));
            }

            if (exportNames.length) {
              beforeBody = beforeBody.concat(constructExportCall(path, identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
            }

            path.traverse(reassignmentVisitor, {
              exports: exportMap,
              buildCall: buildExportCall,
              scope: scope
            });

            for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
              var _path = _removedPaths[_i3];

              _path.remove();
            }

            var hasTLA = false;
            path.traverse({
              AwaitExpression: function AwaitExpression(path) {
                hasTLA = true;
                path.stop();
              },
              Function: function Function(path) {
                path.skip();
              },
              noScope: true
            });
            path.node.body = [buildTemplate({
              SYSTEM_REGISTER: memberExpression(identifier(systemGlobal), identifier("register")),
              BEFORE_BODY: beforeBody,
              MODULE_NAME: moduleName,
              SETTERS: arrayExpression(setters),
              EXECUTE: functionExpression(null, [], blockStatement(path.node.body), false, hasTLA),
              SOURCES: arrayExpression(sources),
              EXPORT_IDENTIFIER: identifier(exportIdent),
              CONTEXT_IDENTIFIER: identifier(contextIdent)
            })];
          }
        }
      }
    };
  });

  var buildPrerequisiteAssignment = template("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
  var buildWrapper$1 = template("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");
  var transformModulesUmd = declare(function (api, options) {
    api.assertVersion(7);
    var globals = options.globals,
        exactGlobals = options.exactGlobals,
        loose = options.loose,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop;

    function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
      var moduleNameOrBasename = moduleName ? moduleName.value : path$1.basename(filename, path$1.extname(filename));
      var globalToAssign = memberExpression(identifier("global"), identifier(toIdentifier(moduleNameOrBasename)));
      var initAssignments = [];

      if (exactGlobals) {
        var globalName = browserGlobals[moduleNameOrBasename];

        if (globalName) {
          initAssignments = [];
          var members = globalName.split(".");
          globalToAssign = members.slice(1).reduce(function (accum, curr) {
            initAssignments.push(buildPrerequisiteAssignment({
              GLOBAL_REFERENCE: cloneNode(accum)
            }));
            return memberExpression(accum, identifier(curr));
          }, memberExpression(identifier("global"), identifier(members[0])));
        }
      }

      initAssignments.push(expressionStatement(assignmentExpression("=", globalToAssign, memberExpression(identifier("mod"), identifier("exports")))));
      return initAssignments;
    }

    function buildBrowserArg(browserGlobals, exactGlobals, source) {
      var memberExpression$1;

      if (exactGlobals) {
        var globalRef = browserGlobals[source];

        if (globalRef) {
          memberExpression$1 = globalRef.split(".").reduce(function (accum, curr) {
            return memberExpression(accum, identifier(curr));
          }, identifier("global"));
        } else {
          memberExpression$1 = memberExpression(identifier("global"), identifier(toIdentifier(source)));
        }
      } else {
        var requireName = path$1.basename(source, path$1.extname(source));
        var globalName = browserGlobals[requireName] || requireName;
        memberExpression$1 = memberExpression(identifier("global"), identifier(toIdentifier(globalName)));
      }

      return memberExpression$1;
    }

    return {
      name: "transform-modules-umd",
      visitor: {
        Program: {
          exit: function exit(path) {
            if (!isModule(path)) return;
            var browserGlobals = globals || {};
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              loose: loose,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            var amdArgs = [];
            var commonjsArgs = [];
            var browserArgs = [];
            var importNames = [];

            if (hasExports(meta)) {
              amdArgs.push(stringLiteral("exports"));
              commonjsArgs.push(identifier("exports"));
              browserArgs.push(memberExpression(identifier("mod"), identifier("exports")));
              importNames.push(identifier(meta.exportName));
            }

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _step.value,
                  source = _step$value[0],
                  metadata = _step$value[1];
              amdArgs.push(stringLiteral(source));
              commonjsArgs.push(callExpression(identifier("require"), [stringLiteral(source)]));
              browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
              importNames.push(identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = expressionStatement(assignmentExpression("=", identifier(metadata.name), interop));
                  header.loc = meta.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, buildNamespaceInitStatements(meta, metadata, loose));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            var _path$node = path.node,
                body = _path$node.body,
                directives = _path$node.directives;
            path.node.directives = [];
            path.node.body = [];
            var umdWrapper = path.pushContainer("body", [buildWrapper$1({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: arrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
            })])[0];
            var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
            umdFactory.pushContainer("directives", directives);
            umdFactory.pushContainer("body", body);
          }
        }
      }
    };
  });

  function transformNamedCapturingGroupsRegex (core, options) {
    var _options$runtime = options.runtime,
        runtime = _options$runtime === void 0 ? true : _options$runtime;

    if (typeof runtime !== "boolean") {
      throw new Error("The 'runtime' option must be boolean");
    }

    return createRegExpFeaturePlugin({
      name: "transform-named-capturing-groups-regex",
      feature: "namedCaptureGroups",
      options: {
        runtime: runtime
      }
    });
  }

  var transformNewTarget = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-new-target",
      visitor: {
        MetaProperty: function MetaProperty(path) {
          var meta = path.get("meta");
          var property = path.get("property");
          var scope = path.scope;

          if (meta.isIdentifier({
            name: "new"
          }) && property.isIdentifier({
            name: "target"
          })) {
            var func = path.findParent(function (path) {
              if (path.isClass()) return true;

              if (path.isFunction() && !path.isArrowFunctionExpression()) {
                if (path.isClassMethod({
                  kind: "constructor"
                })) {
                  return false;
                }

                return true;
              }

              return false;
            });

            if (!func) {
              throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
            }

            var node = func.node;

            if (!node.id) {
              if (func.isMethod()) {
                path.replaceWith(scope.buildUndefinedNode());
                return;
              }

              node.id = scope.generateUidIdentifier("target");
            }

            var _constructor = memberExpression(thisExpression(), identifier("constructor"));

            if (func.isClass()) {
              path.replaceWith(_constructor);
              return;
            }

            path.replaceWith(conditionalExpression(binaryExpression("instanceof", thisExpression(), cloneNode(node.id)), _constructor, scope.buildUndefinedNode()));
          }
        }
      }
    };
  });

  var transformObjectAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.assign")) {
            path.node.callee = file.addHelper("extends");
          }
        }
      }
    };
  });

  function replacePropertySuper(path, getObjectRef, file) {
    var replaceSupers = new ReplaceSupers({
      getObjectRef: getObjectRef,
      methodPath: path,
      file: file
    });
    replaceSupers.replace();
  }

  var transformObjectSuper = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-super",
      visitor: {
        ObjectExpression: function ObjectExpression(path, state) {
          var objectRef;

          var getObjectRef = function getObjectRef() {
            return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
          };

          path.get("properties").forEach(function (propPath) {
            if (!propPath.isMethod()) return;
            replacePropertySuper(propPath, getObjectRef, state);
          });

          if (objectRef) {
            path.scope.push({
              id: cloneNode(objectRef)
            });
            path.replaceWith(assignmentExpression("=", cloneNode(objectRef), path.node));
          }
        }
      }
    };
  });

  var transformObjectSetPrototypeOfToAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-set-prototype-of-to-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
            path.node.callee = file.addHelper("defaults");
          }
        }
      }
    };
  });

  var transformPropertyLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-literals",
      visitor: {
        ObjectProperty: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var key = node.key;

            if (!node.computed && isIdentifier(key) && !isValidES3Identifier(key.name)) {
              node.key = stringLiteral(key.name);
            }
          }
        }
      }
    };
  });

  var transformPropertyMutators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-mutators",
      visitor: {
        ObjectExpression: function ObjectExpression(path, file) {
          var node = path.node;
          var hasAny = false;

          for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
            var prop = _arr[_i];

            if (prop.kind === "get" || prop.kind === "set") {
              hasAny = true;
              break;
            }
          }

          if (!hasAny) return;
          var mutatorMap = {};
          node.properties = node.properties.filter(function (prop) {
            if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
              push(mutatorMap, prop, null, file);
              return false;
            } else {
              return true;
            }
          });
          path.replaceWith(callExpression(memberExpression(identifier("Object"), identifier("defineProperties")), [node, toDefineObject(mutatorMap)]));
        }
      }
    };
  });

  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }

    return -1;
  }

  var _baseIndexOfWith = baseIndexOfWith;

  var arrayProto$1 = Array.prototype;
  var splice$1 = arrayProto$1.splice;

  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? _baseIndexOfWith : _baseIndexOf,
        index = -1,
        length = values.length,
        seen = array;

    if (array === values) {
      values = _copyArray(values);
    }

    if (iteratee) {
      seen = _arrayMap(array, _baseUnary(iteratee));
    }

    while (++index < length) {
      var fromIndex = 0,
          value = values[index],
          computed = iteratee ? iteratee(value) : value;

      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice$1.call(seen, fromIndex, 1);
        }

        splice$1.call(array, fromIndex, 1);
      }
    }

    return array;
  }

  var _basePullAll = basePullAll;

  function pullAll(array, values) {
    return array && array.length && values && values.length ? _basePullAll(array, values) : array;
  }

  var pullAll_1 = pullAll;

  var pull = _baseRest(pullAll_1);
  var pull_1 = pull;

  var transformProtoToAssign = declare(function (api) {
    api.assertVersion(7);

    function isProtoKey(node) {
      return isLiteral(toComputedKey(node, node.key), {
        value: "__proto__"
      });
    }

    function isProtoAssignmentExpression(node) {
      var left = node.left;
      return isMemberExpression(left) && isLiteral(toComputedKey(left, left.property), {
        value: "__proto__"
      });
    }

    function buildDefaultsCallExpression(expr, ref, file) {
      return expressionStatement(callExpression(file.addHelper("defaults"), [ref, expr.right]));
    }

    return {
      name: "transform-proto-to-assign",
      visitor: {
        AssignmentExpression: function AssignmentExpression(path, file) {
          if (!isProtoAssignmentExpression(path.node)) return;
          var nodes = [];
          var left = path.node.left.object;
          var temp = path.scope.maybeGenerateMemoised(left);

          if (temp) {
            nodes.push(expressionStatement(assignmentExpression("=", temp, left)));
          }

          nodes.push(buildDefaultsCallExpression(path.node, cloneNode(temp || left), file));
          if (temp) nodes.push(cloneNode(temp));
          path.replaceWithMultiple(nodes);
        },
        ExpressionStatement: function ExpressionStatement(path, file) {
          var expr = path.node.expression;
          if (!isAssignmentExpression(expr, {
            operator: "="
          })) return;

          if (isProtoAssignmentExpression(expr)) {
            path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
          }
        },
        ObjectExpression: function ObjectExpression(path, file) {
          var proto;
          var node = path.node;

          for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
            var prop = _arr[_i];

            if (isProtoKey(prop)) {
              proto = prop.value;
              pull_1(node.properties, prop);
            }
          }

          if (proto) {
            var args = [objectExpression([]), proto];
            if (node.properties.length) args.push(node);
            path.replaceWith(callExpression(file.addHelper("extends"), args));
          }
        }
      }
    };
  });

  var transformReactConstantElements = declare(function (api, options) {
    api.assertVersion(7);
    var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

    if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
      throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
    }

    var HOISTED = new WeakSet();
    var immutabilityVisitor = {
      enter: function enter(path, state) {
        var stop = function stop() {
          state.isImmutable = false;
          path.stop();
        };

        if (path.isJSXClosingElement()) {
          path.skip();
          return;
        }

        if (path.isJSXIdentifier({
          name: "ref"
        }) && path.parentPath.isJSXAttribute({
          name: path.node
        })) {
          return stop();
        }

        if (path.isJSXIdentifier() || path.isIdentifier() || path.isJSXMemberExpression()) {
          return;
        }

        if (!path.isImmutable()) {
          if (path.isPure()) {
            var expressionResult = path.evaluate();

            if (expressionResult.confident) {
              var value = expressionResult.value;
              var isMutable = !state.mutablePropsAllowed && value && typeof value === "object" || typeof value === "function";

              if (!isMutable) {
                path.skip();
                return;
              }
            } else if (isIdentifier(expressionResult.deopt)) {
              return;
            }
          }

          stop();
        }
      }
    };
    return {
      name: "transform-react-constant-elements",
      visitor: {
        JSXElement: function JSXElement(path) {
          if (HOISTED.has(path.node)) return;
          HOISTED.add(path.node);
          var state = {
            isImmutable: true
          };

          if (allowMutablePropsOnTags != null) {
            var namePath = path.get("openingElement.name");

            while (namePath.isJSXMemberExpression()) {
              namePath = namePath.get("property");
            }

            var elementName = namePath.node.name;
            state.mutablePropsAllowed = allowMutablePropsOnTags.indexOf(elementName) > -1;
          }

          path.traverse(immutabilityVisitor, state);
          if (state.isImmutable) path.hoist();
        }
      }
    };
  });

  var transformReactDisplayName = declare(function (api) {
    api.assertVersion(7);

    function addDisplayName(id, call) {
      var props = call.arguments[0].properties;
      var safe = true;

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var key = toComputedKey(prop);

        if (isLiteral(key, {
          value: "displayName"
        })) {
          safe = false;
          break;
        }
      }

      if (safe) {
        props.unshift(objectProperty(identifier("displayName"), stringLiteral(id)));
      }
    }

    var isCreateClassCallExpression = buildMatchMemberExpression("React.createClass");

    var isCreateClassAddon = function isCreateClassAddon(callee) {
      return callee.name === "createReactClass";
    };

    function isCreateClass(node) {
      if (!node || !isCallExpression(node)) return false;

      if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
        return false;
      }

      var args = node.arguments;
      if (args.length !== 1) return false;
      var first = args[0];
      if (!isObjectExpression(first)) return false;
      return true;
    }

    return {
      name: "transform-react-display-name",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref, state) {
          var node = _ref.node;

          if (isCreateClass(node.declaration)) {
            var filename = state.filename || "unknown";
            var displayName = path__default['default'].basename(filename, path__default['default'].extname(filename));

            if (displayName === "index") {
              displayName = path__default['default'].basename(path__default['default'].dirname(filename));
            }

            addDisplayName(displayName, node.declaration);
          }
        },
        CallExpression: function CallExpression(path) {
          var node = path.node;
          if (!isCreateClass(node)) return;
          var id;
          path.find(function (path) {
            if (path.isAssignmentExpression()) {
              id = path.node.left;
            } else if (path.isObjectProperty()) {
              id = path.node.key;
            } else if (path.isVariableDeclarator()) {
              id = path.node.id;
            } else if (path.isStatement()) {
              return true;
            }

            if (id) return true;
          });
          if (!id) return;

          if (isMemberExpression(id)) {
            id = id.property;
          }

          if (isIdentifier(id)) {
            addDisplayName(id.name, node);
          }
        }
      }
    };
  });

  function helper$2 (opts) {
    var visitor = {};

    visitor.JSXNamespacedName = function (path) {
      if (opts.throwIfNamespace) {
        throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
      }
    };

    visitor.JSXSpreadChild = function (path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    };

    visitor.JSXElement = {
      exit: function exit(path, file) {
        var callExpr = buildElementCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    visitor.JSXFragment = {
      exit: function exit(path, file) {
        if (opts.compat) {
          throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");
        }

        var callExpr = buildFragmentCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    return visitor;

    function convertJSXIdentifier(node, parent) {
      if (isJSXIdentifier(node)) {
        if (node.name === "this" && isReferenced(node, parent)) {
          return thisExpression();
        } else if (isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
        } else {
          return stringLiteral(node.name);
        }
      } else if (isJSXMemberExpression(node)) {
        return memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (isJSXNamespacedName(node)) {
        return stringLiteral(node.namespace.name + ":" + node.name.name);
      }

      return node;
    }

    function convertAttributeValue(node) {
      if (isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }

    function convertAttribute(node) {
      var value = convertAttributeValue(node.value || booleanLiteral(true));

      if (isJSXSpreadAttribute(node)) {
        return spreadElement(node.argument);
      }

      if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
        var _value$extra;

        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
      }

      if (isJSXNamespacedName(node.name)) {
        node.name = stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
      } else if (isValidIdentifier(node.name.name, false)) {
        node.name.type = "Identifier";
      } else {
        node.name = stringLiteral(node.name.name);
      }

      return inherits(objectProperty(node.name, value), node);
    }

    function buildElementCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var args = [];
      var tagName;

      if (isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      var attribs = openingPath.node.attributes;

      if (attribs.length) {
        if (process.env.BABEL_8_BREAKING) {
          attribs = objectExpression(attribs.map(convertAttribute));
        } else {
          attribs = buildOpeningElementAttributes(attribs, file);
        }
      } else {
        attribs = nullLiteral();
      }

      args.push.apply(args, [attribs].concat(path.node.children));

      if (opts.post) {
        opts.post(state, file);
      }

      var call = state.call || callExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function pushProps(_props, objs) {
      if (!_props.length) return _props;
      objs.push(objectExpression(_props));
      return [];
    }

    function buildOpeningElementAttributes(attribs, file) {
      var _props = [];
      var objs = [];
      var _file$opts$useSpread = file.opts.useSpread,
          useSpread = _file$opts$useSpread === void 0 ? false : _file$opts$useSpread;

      if (typeof useSpread !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
      }

      var useBuiltIns = file.opts.useBuiltIns || false;

      if (typeof useBuiltIns !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
      }

      if (useSpread && useBuiltIns) {
        throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
      }

      if (useSpread) {
        var props = attribs.map(convertAttribute);
        return objectExpression(props);
      }

      while (attribs.length) {
        var prop = attribs.shift();

        if (isJSXSpreadAttribute(prop)) {
          _props = pushProps(_props, objs);
          objs.push(prop.argument);
        } else {
          _props.push(convertAttribute(prop));
        }
      }

      pushProps(_props, objs);

      if (objs.length === 1) {
        attribs = objs[0];
      } else {
        if (!isObjectExpression(objs[0])) {
          objs.unshift(objectExpression([]));
        }

        var helper = useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
        attribs = callExpression(helper, objs);
      }

      return attribs;
    }

    function buildFragmentCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var args = [];
      var tagName = null;
      var tagExpr = file.get("jsxFragIdentifier")();
      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      args.push.apply(args, [nullLiteral()].concat(path.node.children));

      if (opts.post) {
        opts.post(state, file);
      }

      file.set("usedFragment", true);
      var call = state.call || callExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }
  }

  var transformReactInlineElements = declare(function (api) {
    api.assertVersion(7);

    function hasRefOrSpread(attrs) {
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (isJSXSpreadAttribute(attr)) return true;
        if (isJSXAttributeOfName(attr, "ref")) return true;
      }

      return false;
    }

    function isJSXAttributeOfName(attr, name) {
      return isJSXAttribute(attr) && isJSXIdentifier(attr.name, {
        name: name
      });
    }

    var visitor = helper$2({
      filter: function filter(node) {
        return node.openingElement && !hasRefOrSpread(node.openingElement.attributes);
      },
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(stringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        state.callee = pass.addHelper("jsx");
        var props = state.args[1];
        var hasKey = false;

        if (isObjectExpression(props)) {
          var keyIndex = props.properties.findIndex(function (prop) {
            return isIdentifier(prop.key, {
              name: "key"
            });
          });

          if (keyIndex > -1) {
            state.args.splice(2, 0, props.properties[keyIndex].value);
            props.properties.splice(keyIndex, 1);
            hasKey = true;
          }
        } else if (isNullLiteral(props)) {
          state.args.splice(1, 1, objectExpression([]));
        }

        if (!hasKey && state.args.length > 2) {
          state.args.splice(2, 0, unaryExpression("void", numericLiteral(0)));
        }

        state.pure = true;
      }
    });
    return {
      name: "transform-react-inline-elements",
      visitor: visitor
    };
  });

  var DEFAULT = {
    importSource: "react",
    runtime: "automatic",
    pragma: "React.createElement",
    pragmaFrag: "React.Fragment"
  };
  var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
  var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
  var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
  var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;

  var get$3 = function get(pass, name) {
    return pass.get("@babel/plugin-react-jsx/" + name);
  };

  var set$1 = function set(pass, name, v) {
    return pass.set("@babel/plugin-react-jsx/" + name, v);
  };

  function createPlugin(_ref) {
    var name = _ref.name,
        development = _ref.development;
    return declare(function (api, options) {
      var PURE_ANNOTATION = options.pure,
          _options$throwIfNames = options.throwIfNamespace,
          throwIfNamespace = _options$throwIfNames === void 0 ? true : _options$throwIfNames,
          filter = options.filter,
          _options$runtime = options.runtime,
          RUNTIME_DEFAULT = _options$runtime === void 0 ? development ? "automatic" : "classic" : _options$runtime,
          _options$importSource = options.importSource,
          IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,
          _options$pragma = options.pragma,
          PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,
          _options$pragmaFrag = options.pragmaFrag,
          PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;

      if (process.env.BABEL_8_BREAKING) {
        if ("useSpread" in options) {
          throw new Error('@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the "useSpread" option is no longer available. Please remove it from your config.');
        }

        if ("useBuiltIns" in options) {
          var useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);
          throw new Error("@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n`useBuiltIns: " + useBuiltInsFormatted + "`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": " + useBuiltInsFormatted + " }]\n  ]\n}");
        }
      } else {
        var _options$useSpread = options.useSpread,
            useSpread = _options$useSpread === void 0 ? false : _options$useSpread,
            _options$useBuiltIns = options.useBuiltIns,
            useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

        if (RUNTIME_DEFAULT === "classic") {
          if (typeof useSpread !== "boolean") {
            throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
          }

          if (typeof useBuiltIns !== "boolean") {
            throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
          }

          if (useSpread && useBuiltIns) {
            throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
          }
        }
      }

      var injectMetaPropertiesVisitor = {
        JSXOpeningElement: function JSXOpeningElement(path, state) {
          for (var _iterator = _createForOfIteratorHelperLoose(path.get("attributes")), _step; !(_step = _iterator()).done;) {
            var attr = _step.value;
            if (!attr.isJSXElement()) continue;
            var _name = attr.node.name.name;

            if (_name === "__source" || _name === "__self") {
              throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
            }
          }

          var self = jsxAttribute(jsxIdentifier("__self"), jsxExpressionContainer(thisExpression()));
          var source = jsxAttribute(jsxIdentifier("__source"), jsxExpressionContainer(makeSource(path, state)));
          path.pushContainer("attributes", [self, source]);
        }
      };
      return {
        name: name,
        inherits: syntaxJsx,
        visitor: {
          JSXNamespacedName: function JSXNamespacedName(path) {
            if (throwIfNamespace) {
              throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
            }
          },
          JSXSpreadChild: function JSXSpreadChild(path) {
            throw path.buildCodeFrameError("Spread children are not supported in React.");
          },
          Program: {
            enter: function enter(path, state) {
              var file = state.file;
              var runtime = RUNTIME_DEFAULT;
              var source = IMPORT_SOURCE_DEFAULT;
              var pragma = PRAGMA_DEFAULT;
              var pragmaFrag = PRAGMA_FRAG_DEFAULT;
              var sourceSet = !!options.importSource;
              var pragmaSet = !!options.pragma;
              var pragmaFragSet = !!options.pragmaFrag;

              if (file.ast.comments) {
                for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
                  var comment = _arr[_i];
                  var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                  if (sourceMatches) {
                    source = sourceMatches[1];
                    sourceSet = true;
                  }

                  var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                  if (runtimeMatches) {
                    runtime = runtimeMatches[1];
                  }

                  var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxMatches) {
                    pragma = jsxMatches[1];
                    pragmaSet = true;
                  }

                  var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxFragMatches) {
                    pragmaFrag = jsxFragMatches[1];
                    pragmaFragSet = true;
                  }
                }
              }

              set$1(state, "runtime", runtime);

              if (runtime === "classic") {
                if (sourceSet) {
                  throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
                }

                var createElement = toMemberExpression(pragma);
                var fragment = toMemberExpression(pragmaFrag);
                set$1(state, "id/createElement", function () {
                  return cloneNode(createElement);
                });
                set$1(state, "id/fragment", function () {
                  return cloneNode(fragment);
                });
                set$1(state, "defaultPure", pragma === DEFAULT.pragma);
              } else if (runtime === "automatic") {
                if (pragmaSet || pragmaFragSet) {
                  throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
                }

                var define = function define(name, id) {
                  return set$1(state, name, createImportLazily(state, path, id, source));
                };

                define("id/jsx", development ? "jsxDEV" : "jsx");
                define("id/jsxs", development ? "jsxDEV" : "jsxs");
                define("id/createElement", "createElement");
                define("id/fragment", "Fragment");
                set$1(state, "defaultPure", source === DEFAULT.importSource);
              } else {
                throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
              }

              if (development) {
                path.traverse(injectMetaPropertiesVisitor, state);
              }
            }
          },
          JSXElement: {
            exit: function exit(path, file) {
              var callExpr;

              if (get$3(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
                callExpr = buildCreateElementCall(path, file);
              } else {
                callExpr = buildJSXElementCall(path, file);
              }

              path.replaceWith(inherits(callExpr, path.node));
            }
          },
          JSXFragment: {
            exit: function exit(path, file) {
              var callExpr;

              if (get$3(file, "runtime") === "classic") {
                callExpr = buildCreateElementFragmentCall(path, file);
              } else {
                callExpr = buildJSXFragmentCall(path, file);
              }

              path.replaceWith(inherits(callExpr, path.node));
            }
          },
          JSXAttribute: function JSXAttribute(path) {
            if (isJSXElement(path.node.value)) {
              path.node.value = jsxExpressionContainer(path.node.value);
            }
          }
        }
      };

      function call(pass, name, args) {
        var node = callExpression(get$3(pass, "id/" + name)(), args);
        if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get$3(pass, "defaultPure")) annotateAsPure(node);
        return node;
      }

      function shouldUseCreateElement(path) {
        var openingPath = path.get("openingElement");
        var attributes = openingPath.node.attributes;
        var seenPropsSpread = false;

        for (var i = 0; i < attributes.length; i++) {
          var attr = attributes[i];

          if (seenPropsSpread && isJSXAttribute(attr) && attr.name.name === "key") {
            return true;
          } else if (isJSXSpreadAttribute(attr)) {
            seenPropsSpread = true;
          }
        }

        return false;
      }

      function convertJSXIdentifier(node, parent) {
        if (isJSXIdentifier(node)) {
          if (node.name === "this" && isReferenced(node, parent)) {
            return thisExpression();
          } else if (isValidIdentifier(node.name, false)) {
            node.type = "Identifier";
          } else {
            return stringLiteral(node.name);
          }
        } else if (isJSXMemberExpression(node)) {
          return memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
        } else if (isJSXNamespacedName(node)) {
          return stringLiteral(node.namespace.name + ":" + node.name.name);
        }

        return node;
      }

      function convertAttributeValue(node) {
        if (isJSXExpressionContainer(node)) {
          return node.expression;
        } else {
          return node;
        }
      }

      function accumulateAttribute(array, node) {
        if (isJSXSpreadAttribute(node)) {
          var arg = node.argument;

          if (isObjectExpression(arg)) {
            array.push.apply(array, arg.properties);
          } else {
            array.push(spreadElement(arg));
          }

          return array;
        }

        var value = convertAttributeValue(node.value || booleanLiteral(true));

        if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
          var _value$extra;

          value.value = value.value.replace(/\n\s+/g, " ");
          (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
        }

        if (isJSXNamespacedName(node.name)) {
          node.name = stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
        } else if (isValidIdentifier(node.name.name, false)) {
          node.name.type = "Identifier";
        } else {
          node.name = stringLiteral(node.name.name);
        }

        array.push(inherits(objectProperty(node.name, value), node));
        return array;
      }

      function buildChildrenProperty(children) {
        var childrenNode;

        if (children.length === 1) {
          childrenNode = children[0];
        } else if (children.length > 1) {
          childrenNode = arrayExpression(children);
        } else {
          return undefined;
        }

        return objectProperty(identifier("children"), childrenNode);
      }

      function buildJSXElementCall(path, file) {
        var openingPath = path.get("openingElement");
        var args = [getTag(openingPath)];
        var attribs = [];
        var extracted = Object.create(null);

        for (var _iterator2 = _createForOfIteratorHelperLoose(openingPath.get("attributes")), _step2; !(_step2 = _iterator2()).done;) {
          var attr = _step2.value;

          if (attr.isJSXAttribute() && isJSXIdentifier(attr.node.name)) {
            var _name2 = attr.node.name.name;

            switch (_name2) {
              case "__source":
              case "__self":
                if (extracted[_name2]) throw sourceSelfError(path, _name2);

              case "key":
                extracted[_name2] = convertAttributeValue(attr.node.value);
                break;

              default:
                attribs.push(attr.node);
            }
          } else {
            attribs.push(attr.node);
          }
        }

        var children = react.buildChildren(path.node);

        if (attribs.length || children.length) {
          attribs = buildJSXOpeningElementAttributes(attribs, file, children);
        } else {
          attribs = objectExpression([]);
        }

        args.push(attribs);

        if (development) {
          var _extracted$key, _extracted$__source, _extracted$__self;

          args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : thisExpression());
        } else if (extracted.key !== undefined) {
          args.push(extracted.key);
        }

        return call(file, children.length > 1 ? "jsxs" : "jsx", args);
      }

      function buildJSXOpeningElementAttributes(attribs, file, children) {
        var props = attribs.reduce(accumulateAttribute, []);

        if ((children == null ? void 0 : children.length) > 0) {
          props.push(buildChildrenProperty(children));
        }

        return objectExpression(props);
      }

      function buildJSXFragmentCall(path, file) {
        var args = [get$3(file, "id/fragment")()];
        var children = react.buildChildren(path.node);
        args.push(objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));

        if (development) {
          args.push(path.scope.buildUndefinedNode(), booleanLiteral(children.length > 1));
        }

        return call(file, children.length > 1 ? "jsxs" : "jsx", args);
      }

      function buildCreateElementFragmentCall(path, file) {
        if (filter && !filter(path.node, file)) return;
        return call(file, "createElement", [get$3(file, "id/fragment")(), nullLiteral()].concat(react.buildChildren(path.node)));
      }

      function buildCreateElementCall(path, file) {
        var openingPath = path.get("openingElement");
        return call(file, "createElement", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.node.attributes)].concat(react.buildChildren(path.node)));
      }

      function getTag(openingPath) {
        var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
        var tagName;

        if (isIdentifier(tagExpr)) {
          tagName = tagExpr.name;
        } else if (isLiteral(tagExpr)) {
          tagName = tagExpr.value;
        }

        if (react.isCompatTag(tagName)) {
          return stringLiteral(tagName);
        } else {
          return tagExpr;
        }
      }

      function buildCreateElementOpeningElementAttributes(file, path, attribs) {
        var runtime = get$3(file, "runtime");

        if (!process.env.BABEL_8_BREAKING) {
          if (runtime !== "automatic") {
            var objs = [];

            var _props = attribs.reduce(accumulateAttribute, []);

            if (!useSpread) {
              var start = 0;

              _props.forEach(function (prop, i) {
                if (isSpreadElement(prop)) {
                  if (i > start) {
                    objs.push(objectExpression(_props.slice(start, i)));
                  }

                  objs.push(prop.argument);
                  start = i + 1;
                }
              });

              if (_props.length > start) {
                objs.push(objectExpression(_props.slice(start)));
              }
            } else if (_props.length) {
              objs.push(objectExpression(_props));
            }

            if (!objs.length) {
              return nullLiteral();
            }

            if (objs.length === 1) {
              return objs[0];
            }

            if (!isObjectExpression(objs[0])) {
              objs.unshift(objectExpression([]));
            }

            var helper = useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
            return callExpression(helper, objs);
          }
        }

        var props = [];
        var found = Object.create(null);

        for (var _iterator3 = _createForOfIteratorHelperLoose(attribs), _step3; !(_step3 = _iterator3()).done;) {
          var attr = _step3.value;

          var _name3 = isJSXAttribute(attr) && isJSXIdentifier(attr.name) && attr.name.name;

          if (runtime === "automatic" && (_name3 === "__source" || _name3 === "__self")) {
            if (found[_name3]) throw sourceSelfError(path, _name3);
            found[_name3] = true;
          }

          accumulateAttribute(props, attr);
        }

        return props.length === 1 && isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? objectExpression(props) : nullLiteral();
      }
    });

    function getSource(source, importName) {
      switch (importName) {
        case "Fragment":
          return source + "/" + (development ? "jsx-dev-runtime" : "jsx-runtime");

        case "jsxDEV":
          return source + "/jsx-dev-runtime";

        case "jsx":
        case "jsxs":
          return source + "/jsx-runtime";

        case "createElement":
          return source;
      }
    }

    function createImportLazily(pass, path, importName, source) {
      return function () {
        var actualSource = getSource(source, importName);

        if (isModule(path)) {
          var reference = get$3(pass, "imports/" + importName);
          if (reference) return cloneNode(reference);
          reference = addNamed(path, importName, actualSource, {
            importedInterop: "uncompiled",
            importPosition: "after"
          });
          set$1(pass, "imports/" + importName, reference);
          return reference;
        } else {
          var _reference = get$3(pass, "requires/" + actualSource);

          if (_reference) {
            _reference = cloneNode(_reference);
          } else {
            _reference = addNamespace(path, actualSource, {
              importedInterop: "uncompiled"
            });
            set$1(pass, "requires/" + actualSource, _reference);
          }

          return memberExpression(_reference, identifier(importName));
        }
      };
    }
  }

  function toMemberExpression(id) {
    return id.split(".").map(function (name) {
      return identifier(name);
    }).reduce(function (object, property) {
      return memberExpression(object, property);
    });
  }

  function makeSource(path, state) {
    var location = path.node.loc;

    if (!location) {
      return path.scope.buildUndefinedNode();
    }

    if (!state.fileNameIdentifier) {
      var _state$filename = state.filename,
          filename = _state$filename === void 0 ? "" : _state$filename;
      var fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
      var scope = path.hub.getScope();

      if (scope) {
        scope.push({
          id: fileNameIdentifier,
          init: stringLiteral(filename)
        });
      }

      state.fileNameIdentifier = fileNameIdentifier;
    }

    return makeTrace(cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
  }

  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
    var fileLineLiteral = lineNumber != null ? numericLiteral(lineNumber) : nullLiteral();
    var fileColumnLiteral = column0Based != null ? numericLiteral(column0Based + 1) : nullLiteral();
    var fileNameProperty = objectProperty(identifier("fileName"), fileNameIdentifier);
    var lineNumberProperty = objectProperty(identifier("lineNumber"), fileLineLiteral);
    var columnNumberProperty = objectProperty(identifier("columnNumber"), fileColumnLiteral);
    return objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
  }

  function sourceSelfError(path, name) {
    var pluginName = "transform-react-jsx-" + name.slice(2);
    return path.buildCodeFrameError("Duplicate " + name + " prop found. You are most likely using the deprecated " + pluginName + " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.");
  }

  var transformReactJSX = createPlugin({
    name: "transform-react-jsx",
    development: false
  });

  var transformReactJsxCompat = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-react-jsx-compat",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsx");
      },
      visitor: helper$2({
        pre: function pre(state) {
          state.callee = state.tagExpr;
        },
        post: function post(state) {
          if (react.isCompatTag(state.tagName)) {
            state.call = callExpression(memberExpression(memberExpression(identifier("React"), identifier("DOM")), state.tagExpr, isLiteral(state.tagExpr)), state.args);
          }
        },
        compat: true
      })
    };
  });

  var transformReactJSXDevelopment = createPlugin({
    name: "transform-react-jsx/development",
    development: true
  });

  var TRACE_ID = "__self";
  var transformReactJsxSelf = declare(function (api) {
    api.assertVersion(7);
    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(_ref) {
        var node = _ref.node;
        var id = jsxIdentifier(TRACE_ID);
        var trace = thisExpression();
        node.attributes.push(jsxAttribute(id, jsxExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-self",
      visitor: {
        Program: function Program(path) {
          path.traverse(visitor);
        }
      }
    };
  });

  var TRACE_ID$1 = "__source";
  var FILE_NAME_VAR = "_jsxFileName";
  var transformReactJsxSource = declare(function (api) {
    api.assertVersion(7);

    function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
      var fileLineLiteral = lineNumber != null ? numericLiteral(lineNumber) : nullLiteral();
      var fileColumnLiteral = column0Based != null ? numericLiteral(column0Based + 1) : nullLiteral();
      var fileNameProperty = objectProperty(identifier("fileName"), fileNameIdentifier);
      var lineNumberProperty = objectProperty(identifier("lineNumber"), fileLineLiteral);
      var columnNumberProperty = objectProperty(identifier("columnNumber"), fileColumnLiteral);
      return objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
    }

    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        var id = jsxIdentifier(TRACE_ID$1);
        var location = path.container.openingElement.loc;

        if (!location) {
          return;
        }

        var attributes = path.container.openingElement.attributes;

        for (var i = 0; i < attributes.length; i++) {
          var name = attributes[i].name;

          if ((name == null ? void 0 : name.name) === TRACE_ID$1) {
            return;
          }
        }

        if (!state.fileNameIdentifier) {
          var fileName = state.filename || "";
          var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
          var scope = path.hub.getScope();

          if (scope) {
            scope.push({
              id: fileNameIdentifier,
              init: stringLiteral(fileName)
            });
          }

          state.fileNameIdentifier = fileNameIdentifier;
        }

        var trace = makeTrace(cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
        attributes.push(jsxAttribute(id, jsxExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-source",
      visitor: visitor
    };
  });

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  });

  var interopRequireWildcard = createCommonjsModule(function (module) {
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();

    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };

    return cache;
  }

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || _typeof_1(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }

    var cache = _getRequireWildcardCache();

    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }

    newObj["default"] = obj;

    if (cache) {
      cache.set(obj, newObj);
    }

    return newObj;
  }

  module.exports = _interopRequireWildcard;
  });

  var interopRequireDefault = createCommonjsModule(function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
  });

  var util$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.wrapWithTypes = wrapWithTypes;
  exports.getTypes = getTypes;
  exports.runtimeProperty = runtimeProperty;
  exports.isReference = isReference;
  exports.replaceWithOrRemove = replaceWithOrRemove;
  var currentTypes = null;

  function wrapWithTypes(types, fn) {
    return function () {
      var oldTypes = currentTypes;
      currentTypes = types;

      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return fn.apply(this, args);
      } finally {
        currentTypes = oldTypes;
      }
    };
  }

  function getTypes() {
    return currentTypes;
  }

  function runtimeProperty(name) {
    var t = getTypes();
    return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
  }

  function isReference(path) {
    return path.isReferenced() || path.parentPath.isAssignmentExpression({
      left: path.node
    });
  }

  function replaceWithOrRemove(path, replacement) {
    if (replacement) {
      path.replaceWith(replacement);
    } else {
      path.remove();
    }
  }
  });

  var util$2 = interopRequireWildcard(util$1);

  var hasOwn = Object.prototype.hasOwnProperty;

  var hoist_1 = function (funPath) {
    var t = util$2.getTypes();
    t.assertFunction(funPath.node);
    var vars = {};

    function varDeclToExpr(_ref, includeIdentifiers) {
      var vdec = _ref.node,
          scope = _ref.scope;
      t.assertVariableDeclaration(vdec);
      var exprs = [];
      vdec.declarations.forEach(function (dec) {
        vars[dec.id.name] = t.identifier(dec.id.name);
        scope.removeBinding(dec.id.name);

        if (dec.init) {
          exprs.push(t.assignmentExpression("=", dec.id, dec.init));
        } else if (includeIdentifiers) {
          exprs.push(dec.id);
        }
      });
      if (exprs.length === 0) return null;
      if (exprs.length === 1) return exprs[0];
      return t.sequenceExpression(exprs);
    }

    funPath.get("body").traverse({
      VariableDeclaration: {
        exit: function exit(path) {
          var expr = varDeclToExpr(path, false);

          if (expr === null) {
            path.remove();
          } else {
            util$2.replaceWithOrRemove(path, t.expressionStatement(expr));
          }

          path.skip();
        }
      },
      ForStatement: function ForStatement(path) {
        var init = path.get("init");

        if (init.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(init, varDeclToExpr(init, false));
        }
      },
      ForXStatement: function ForXStatement(path) {
        var left = path.get("left");

        if (left.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(left, varDeclToExpr(left, true));
        }
      },
      FunctionDeclaration: function FunctionDeclaration(path) {
        var node = path.node;
        vars[node.id.name] = node.id;
        var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));

        if (path.parentPath.isBlockStatement()) {
          path.parentPath.unshiftContainer("body", assignment);
          path.remove();
        } else {
          util$2.replaceWithOrRemove(path, assignment);
        }

        path.scope.removeBinding(node.id.name);
        path.skip();
      },
      FunctionExpression: function FunctionExpression(path) {
        path.skip();
      },
      ArrowFunctionExpression: function ArrowFunctionExpression(path) {
        path.skip();
      }
    });
    var paramNames = {};
    funPath.get("params").forEach(function (paramPath) {
      var param = paramPath.node;

      if (t.isIdentifier(param)) {
        paramNames[param.name] = param;
      }
    });
    var declarations = [];
    Object.keys(vars).forEach(function (name) {
      if (!hasOwn.call(paramNames, name)) {
        declarations.push(t.variableDeclarator(vars[name], null));
      }
    });

    if (declarations.length === 0) {
      return null;
    }

    return t.variableDeclaration("var", declarations);
  };

  var hoist$1 = {
  	hoist: hoist_1
  };

  var _assert = interopRequireDefault(assert__default['default']);







  function Entry() {
    _assert["default"].ok(this instanceof Entry);
  }

  function FunctionEntry(returnLoc) {
    Entry.call(this);
    (0, util$1.getTypes)().assertLiteral(returnLoc);
    this.returnLoc = returnLoc;
  }

  (0, util__default['default'].inherits)(FunctionEntry, Entry);
  var FunctionEntry_1 = FunctionEntry;

  function LoopEntry(breakLoc, continueLoc, label) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertLiteral(continueLoc);

    if (label) {
      t.assertIdentifier(label);
    } else {
      label = null;
    }

    this.breakLoc = breakLoc;
    this.continueLoc = continueLoc;
    this.label = label;
  }

  (0, util__default['default'].inherits)(LoopEntry, Entry);
  var LoopEntry_1 = LoopEntry;

  function SwitchEntry(breakLoc) {
    Entry.call(this);
    (0, util$1.getTypes)().assertLiteral(breakLoc);
    this.breakLoc = breakLoc;
  }

  (0, util__default['default'].inherits)(SwitchEntry, Entry);
  var SwitchEntry_1 = SwitchEntry;

  function TryEntry(firstLoc, catchEntry, finallyEntry) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);

    if (catchEntry) {
      _assert["default"].ok(catchEntry instanceof CatchEntry);
    } else {
      catchEntry = null;
    }

    if (finallyEntry) {
      _assert["default"].ok(finallyEntry instanceof FinallyEntry);
    } else {
      finallyEntry = null;
    }

    _assert["default"].ok(catchEntry || finallyEntry);

    this.firstLoc = firstLoc;
    this.catchEntry = catchEntry;
    this.finallyEntry = finallyEntry;
  }

  (0, util__default['default'].inherits)(TryEntry, Entry);
  var TryEntry_1 = TryEntry;

  function CatchEntry(firstLoc, paramId) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertIdentifier(paramId);
    this.firstLoc = firstLoc;
    this.paramId = paramId;
  }

  (0, util__default['default'].inherits)(CatchEntry, Entry);
  var CatchEntry_1 = CatchEntry;

  function FinallyEntry(firstLoc, afterLoc) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertLiteral(afterLoc);
    this.firstLoc = firstLoc;
    this.afterLoc = afterLoc;
  }

  (0, util__default['default'].inherits)(FinallyEntry, Entry);
  var FinallyEntry_1 = FinallyEntry;

  function LabeledEntry(breakLoc, label) {
    Entry.call(this);
    var t = (0, util$1.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertIdentifier(label);
    this.breakLoc = breakLoc;
    this.label = label;
  }

  (0, util__default['default'].inherits)(LabeledEntry, Entry);
  var LabeledEntry_1 = LabeledEntry;

  function LeapManager(emitter) {
    _assert["default"].ok(this instanceof LeapManager);

    _assert["default"].ok(emitter instanceof emit.Emitter);

    this.emitter = emitter;
    this.entryStack = [new FunctionEntry(emitter.finalLoc)];
  }

  var LMp = LeapManager.prototype;
  var LeapManager_1 = LeapManager;

  LMp.withEntry = function (entry, callback) {
    _assert["default"].ok(entry instanceof Entry);

    this.entryStack.push(entry);

    try {
      callback.call(this.emitter);
    } finally {
      var popped = this.entryStack.pop();

      _assert["default"].strictEqual(popped, entry);
    }
  };

  LMp._findLeapLocation = function (property, label) {
    for (var i = this.entryStack.length - 1; i >= 0; --i) {
      var entry = this.entryStack[i];
      var loc = entry[property];

      if (loc) {
        if (label) {
          if (entry.label && entry.label.name === label.name) {
            return loc;
          }
        } else if (entry instanceof LabeledEntry) ; else {
          return loc;
        }
      }
    }

    return null;
  };

  LMp.getBreakLoc = function (label) {
    return this._findLeapLocation("breakLoc", label);
  };

  LMp.getContinueLoc = function (label) {
    return this._findLeapLocation("continueLoc", label);
  };

  var leap = {
  	FunctionEntry: FunctionEntry_1,
  	LoopEntry: LoopEntry_1,
  	SwitchEntry: SwitchEntry_1,
  	TryEntry: TryEntry_1,
  	CatchEntry: CatchEntry_1,
  	FinallyEntry: FinallyEntry_1,
  	LabeledEntry: LabeledEntry_1,
  	LeapManager: LeapManager_1
  };

  var originalObject = Object;
  var originalDefProp = Object.defineProperty;
  var originalCreate = Object.create;

  function defProp(obj, name, value) {
    if (originalDefProp) try {
      originalDefProp.call(originalObject, obj, name, {
        value: value
      });
    } catch (definePropertyIsBrokenInIE8) {
      obj[name] = value;
    } else {
      obj[name] = value;
    }
  }

  function makeSafeToCall(fun) {
    if (fun) {
      defProp(fun, "call", fun.call);
      defProp(fun, "apply", fun.apply);
    }

    return fun;
  }

  makeSafeToCall(originalDefProp);
  makeSafeToCall(originalCreate);
  var hasOwn$1 = makeSafeToCall(Object.prototype.hasOwnProperty);
  var numToStr = makeSafeToCall(Number.prototype.toString);
  var strSlice = makeSafeToCall(String.prototype.slice);

  var cloner = function cloner() {};

  function create(prototype) {
    if (originalCreate) {
      return originalCreate.call(originalObject, prototype);
    }

    cloner.prototype = prototype || null;
    return new cloner();
  }

  var rand = Math.random;
  var uniqueKeys = create(null);

  function makeUniqueKey() {
    do {
      var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
    } while (hasOwn$1.call(uniqueKeys, uniqueKey));

    return uniqueKeys[uniqueKey] = uniqueKey;
  }

  function internString(str) {
    var obj = {};
    obj[str] = true;
    return Object.keys(obj)[0];
  }

  var makeUniqueKey_1 = makeUniqueKey;
  var originalGetOPNs = Object.getOwnPropertyNames;

  Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
    for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
      if (!hasOwn$1.call(uniqueKeys, names[src])) {
        if (src > dst) {
          names[dst] = names[src];
        }

        ++dst;
      }
    }

    names.length = dst;
    return names;
  };

  function defaultCreatorFn(object) {
    return create(null);
  }

  function makeAccessor(secretCreatorFn) {
    var brand = makeUniqueKey();
    var passkey = create(null);
    secretCreatorFn = secretCreatorFn || defaultCreatorFn;

    function register(object) {
      var secret;

      function vault(key, forget) {
        if (key === passkey) {
          return forget ? secret = null : secret || (secret = secretCreatorFn(object));
        }
      }

      defProp(object, brand, vault);
    }

    function accessor(object) {
      if (!hasOwn$1.call(object, brand)) register(object);
      return object[brand](passkey);
    }

    accessor.forget = function (object) {
      if (hasOwn$1.call(object, brand)) object[brand](passkey, true);
    };

    return accessor;
  }

  var makeAccessor_1 = makeAccessor;

  var _private = {
  	makeUniqueKey: makeUniqueKey_1,
  	makeAccessor: makeAccessor_1
  };

  var _assert$1 = interopRequireDefault(assert__default['default']);





  var m$1 = (0, _private.makeAccessor)();
  var hasOwn$2 = Object.prototype.hasOwnProperty;

  function makePredicate(propertyName, knownTypes) {
    function onlyChildren(node) {
      var t = (0, util$1.getTypes)();
      t.assertNode(node);
      var result = false;

      function check(child) {
        if (result) ; else if (Array.isArray(child)) {
          child.some(check);
        } else if (t.isNode(child)) {
          _assert$1["default"].strictEqual(result, false);

          result = predicate(child);
        }

        return result;
      }

      var keys = t.VISITOR_KEYS[node.type];

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = node[key];
          check(child);
        }
      }

      return result;
    }

    function predicate(node) {
      (0, util$1.getTypes)().assertNode(node);
      var meta = m$1(node);
      if (hasOwn$2.call(meta, propertyName)) return meta[propertyName];
      if (hasOwn$2.call(opaqueTypes, node.type)) return meta[propertyName] = false;
      if (hasOwn$2.call(knownTypes, node.type)) return meta[propertyName] = true;
      return meta[propertyName] = onlyChildren(node);
    }

    predicate.onlyChildren = onlyChildren;
    return predicate;
  }

  var opaqueTypes = {
    FunctionExpression: true,
    ArrowFunctionExpression: true
  };
  var sideEffectTypes = {
    CallExpression: true,
    ForInStatement: true,
    UnaryExpression: true,
    BinaryExpression: true,
    AssignmentExpression: true,
    UpdateExpression: true,
    NewExpression: true
  };
  var leapTypes = {
    YieldExpression: true,
    BreakStatement: true,
    ContinueStatement: true,
    ReturnStatement: true,
    ThrowStatement: true
  };

  for (var type$2 in leapTypes) {
    if (hasOwn$2.call(leapTypes, type$2)) {
      sideEffectTypes[type$2] = leapTypes[type$2];
    }
  }

  var hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
  var containsLeap = makePredicate("containsLeap", leapTypes);

  var meta = {
  	hasSideEffects: hasSideEffects,
  	containsLeap: containsLeap
  };

  var _assert$2 = interopRequireDefault(assert__default['default']);

  var leap$1 = interopRequireWildcard(leap);

  var meta$1 = interopRequireWildcard(meta);

  var util$3 = interopRequireWildcard(util$1);

  var hasOwn$3 = Object.prototype.hasOwnProperty;

  function Emitter(contextId) {
    _assert$2["default"].ok(this instanceof Emitter);

    util$3.getTypes().assertIdentifier(contextId);
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap$1.LeapManager(this);
  }

  var Ep = Emitter.prototype;
  var Emitter_1 = Emitter;

  Ep.loc = function () {
    var l = util$3.getTypes().numericLiteral(-1);
    this.insertedLocs.add(l);
    return l;
  };

  Ep.getInsertedLocs = function () {
    return this.insertedLocs;
  };

  Ep.getContextId = function () {
    return util$3.getTypes().clone(this.contextId);
  };

  Ep.mark = function (loc) {
    util$3.getTypes().assertLiteral(loc);
    var index = this.listing.length;

    if (loc.value === -1) {
      loc.value = index;
    } else {
      _assert$2["default"].strictEqual(loc.value, index);
    }

    this.marked[index] = true;
    return loc;
  };

  Ep.emit = function (node) {
    var t = util$3.getTypes();

    if (t.isExpression(node)) {
      node = t.expressionStatement(node);
    }

    t.assertStatement(node);
    this.listing.push(node);
  };

  Ep.emitAssign = function (lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  };

  Ep.assign = function (lhs, rhs) {
    var t = util$3.getTypes();
    return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
  };

  Ep.contextProperty = function (name, computed) {
    var t = util$3.getTypes();
    return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
  };

  Ep.stop = function (rval) {
    if (rval) {
      this.setReturnValue(rval);
    }

    this.jump(this.finalLoc);
  };

  Ep.setReturnValue = function (valuePath) {
    util$3.getTypes().assertExpression(valuePath.value);
    this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
  };

  Ep.clearPendingException = function (tryLoc, assignee) {
    var t = util$3.getTypes();
    t.assertLiteral(tryLoc);
    var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);

    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  };

  Ep.jump = function (toLoc) {
    this.emitAssign(this.contextProperty("next"), toLoc);
    this.emit(util$3.getTypes().breakStatement());
  };

  Ep.jumpIf = function (test, toLoc) {
    var t = util$3.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.jumpIfNot = function (test, toLoc) {
    var t = util$3.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    var negatedTest;

    if (t.isUnaryExpression(test) && test.operator === "!") {
      negatedTest = test.argument;
    } else {
      negatedTest = t.unaryExpression("!", test);
    }

    this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.makeTempVar = function () {
    return this.contextProperty("t" + this.nextTempId++);
  };

  Ep.getContextFunction = function (id) {
    var t = util$3.getTypes();
    return t.functionExpression(id || null, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, false);
  };

  Ep.getDispatchLoop = function () {
    var self = this;
    var t = util$3.getTypes();
    var cases = [];
    var current;
    var alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked.hasOwnProperty(i)) {
        cases.push(t.switchCase(t.numericLiteral(i), current = []));
        alreadyEnded = false;
      }

      if (!alreadyEnded) {
        current.push(stmt);
        if (t.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.listing.length;
    cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
    return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  };

  Ep.getTryLocsList = function () {
    if (this.tryEntries.length === 0) {
      return null;
    }

    var t = util$3.getTypes();
    var lastLocValue = 0;
    return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;

      _assert$2["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");

      lastLocValue = thisLocValue;
      var ce = tryEntry.catchEntry;
      var fe = tryEntry.finallyEntry;
      var locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return t.arrayExpression(locs.map(function (loc) {
        return loc && t.clone(loc);
      }));
    }));
  };

  Ep.explode = function (path, ignoreResult) {
    var t = util$3.getTypes();
    var node = path.node;
    var self = this;
    t.assertNode(node);
    if (t.isDeclaration(node)) throw getDeclError(node);
    if (t.isStatement(node)) return self.explodeStatement(path);
    if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);

    switch (node.type) {
      case "Program":
        return path.get("body").map(self.explodeStatement, self);

      case "VariableDeclarator":
        throw getDeclError(node);

      case "Property":
      case "SwitchCase":
      case "CatchClause":
        throw new Error(node.type + " nodes should be handled by their parents");

      default:
        throw new Error("unknown Node of type " + JSON.stringify(node.type));
    }
  };

  function getDeclError(node) {
    return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
  }

  Ep.explodeStatement = function (path, labelId) {
    var t = util$3.getTypes();
    var stmt = path.node;
    var self = this;
    var before, after, head;
    t.assertStatement(stmt);

    if (labelId) {
      t.assertIdentifier(labelId);
    } else {
      labelId = null;
    }

    if (t.isBlockStatement(stmt)) {
      path.get("body").forEach(function (path) {
        self.explodeStatement(path);
      });
      return;
    }

    if (!meta$1.containsLeap(stmt)) {
      self.emit(stmt);
      return;
    }

    switch (stmt.type) {
      case "ExpressionStatement":
        self.explodeExpression(path.get("expression"), true);
        break;

      case "LabeledStatement":
        after = this.loc();
        self.leapManager.withEntry(new leap$1.LabeledEntry(after, stmt.label), function () {
          self.explodeStatement(path.get("body"), stmt.label);
        });
        self.mark(after);
        break;

      case "WhileStatement":
        before = this.loc();
        after = this.loc();
        self.mark(before);
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        self.leapManager.withEntry(new leap$1.LoopEntry(after, before, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(before);
        self.mark(after);
        break;

      case "DoWhileStatement":
        var first = this.loc();
        var test = this.loc();
        after = this.loc();
        self.mark(first);
        self.leapManager.withEntry(new leap$1.LoopEntry(after, test, labelId), function () {
          self.explode(path.get("body"));
        });
        self.mark(test);
        self.jumpIf(self.explodeExpression(path.get("test")), first);
        self.mark(after);
        break;

      case "ForStatement":
        head = this.loc();
        var update = this.loc();
        after = this.loc();

        if (stmt.init) {
          self.explode(path.get("init"), true);
        }

        self.mark(head);

        if (stmt.test) {
          self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        }

        self.leapManager.withEntry(new leap$1.LoopEntry(after, update, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.mark(update);

        if (stmt.update) {
          self.explode(path.get("update"), true);
        }

        self.jump(head);
        self.mark(after);
        break;

      case "TypeCastExpression":
        return self.explodeExpression(path.get("expression"));

      case "ForInStatement":
        head = this.loc();
        after = this.loc();
        var keyIterNextFn = self.makeTempVar();
        self.emitAssign(keyIterNextFn, t.callExpression(util$3.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
        self.mark(head);
        var keyInfoTmpVar = self.makeTempVar();
        self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
        self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
        self.leapManager.withEntry(new leap$1.LoopEntry(after, head, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(head);
        self.mark(after);
        break;

      case "BreakStatement":
        self.emitAbruptCompletion({
          type: "break",
          target: self.leapManager.getBreakLoc(stmt.label)
        });
        break;

      case "ContinueStatement":
        self.emitAbruptCompletion({
          type: "continue",
          target: self.leapManager.getContinueLoc(stmt.label)
        });
        break;

      case "SwitchStatement":
        var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
        after = this.loc();
        var defaultLoc = this.loc();
        var condition = defaultLoc;
        var caseLocs = [];
        var cases = stmt.cases || [];

        for (var i = cases.length - 1; i >= 0; --i) {
          var c = cases[i];
          t.assertSwitchCase(c);

          if (c.test) {
            condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
          } else {
            caseLocs[i] = defaultLoc;
          }
        }

        var discriminant = path.get("discriminant");
        util$3.replaceWithOrRemove(discriminant, condition);
        self.jump(self.explodeExpression(discriminant));
        self.leapManager.withEntry(new leap$1.SwitchEntry(after), function () {
          path.get("cases").forEach(function (casePath) {
            var i = casePath.key;
            self.mark(caseLocs[i]);
            casePath.get("consequent").forEach(function (path) {
              self.explodeStatement(path);
            });
          });
        });
        self.mark(after);

        if (defaultLoc.value === -1) {
          self.mark(defaultLoc);

          _assert$2["default"].strictEqual(after.value, defaultLoc.value);
        }

        break;

      case "IfStatement":
        var elseLoc = stmt.alternate && this.loc();
        after = this.loc();
        self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
        self.explodeStatement(path.get("consequent"));

        if (elseLoc) {
          self.jump(after);
          self.mark(elseLoc);
          self.explodeStatement(path.get("alternate"));
        }

        self.mark(after);
        break;

      case "ReturnStatement":
        self.emitAbruptCompletion({
          type: "return",
          value: self.explodeExpression(path.get("argument"))
        });
        break;

      case "WithStatement":
        throw new Error("WithStatement not supported in generator functions.");

      case "TryStatement":
        after = this.loc();
        var handler = stmt.handler;
        var catchLoc = handler && this.loc();
        var catchEntry = catchLoc && new leap$1.CatchEntry(catchLoc, handler.param);
        var finallyLoc = stmt.finalizer && this.loc();
        var finallyEntry = finallyLoc && new leap$1.FinallyEntry(finallyLoc, after);
        var tryEntry = new leap$1.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
        self.tryEntries.push(tryEntry);
        self.updateContextPrevLoc(tryEntry.firstLoc);
        self.leapManager.withEntry(tryEntry, function () {
          self.explodeStatement(path.get("block"));

          if (catchLoc) {
            if (finallyLoc) {
              self.jump(finallyLoc);
            } else {
              self.jump(after);
            }

            self.updateContextPrevLoc(self.mark(catchLoc));
            var bodyPath = path.get("handler.body");
            var safeParam = self.makeTempVar();
            self.clearPendingException(tryEntry.firstLoc, safeParam);
            bodyPath.traverse(catchParamVisitor, {
              getSafeParam: function getSafeParam() {
                return t.cloneDeep(safeParam);
              },
              catchParamName: handler.param.name
            });
            self.leapManager.withEntry(catchEntry, function () {
              self.explodeStatement(bodyPath);
            });
          }

          if (finallyLoc) {
            self.updateContextPrevLoc(self.mark(finallyLoc));
            self.leapManager.withEntry(finallyEntry, function () {
              self.explodeStatement(path.get("finalizer"));
            });
            self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
          }
        });
        self.mark(after);
        break;

      case "ThrowStatement":
        self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
        break;

      default:
        throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
    }
  };

  var catchParamVisitor = {
    Identifier: function Identifier(path, state) {
      if (path.node.name === state.catchParamName && util$3.isReference(path)) {
        util$3.replaceWithOrRemove(path, state.getSafeParam());
      }
    },
    Scope: function Scope(path, state) {
      if (path.scope.hasOwnBinding(state.catchParamName)) {
        path.skip();
      }
    }
  };

  Ep.emitAbruptCompletion = function (record) {
    if (!isValidCompletion(record)) {
      _assert$2["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
    }

    _assert$2["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");

    var t = util$3.getTypes();
    var abruptArgs = [t.stringLiteral(record.type)];

    if (record.type === "break" || record.type === "continue") {
      t.assertLiteral(record.target);
      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
    } else if (record.type === "return" || record.type === "throw") {
      if (record.value) {
        t.assertExpression(record.value);
        abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
      }
    }

    this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
  };

  function isValidCompletion(record) {
    var type = record.type;

    if (type === "normal") {
      return !hasOwn$3.call(record, "target");
    }

    if (type === "break" || type === "continue") {
      return !hasOwn$3.call(record, "value") && util$3.getTypes().isLiteral(record.target);
    }

    if (type === "return" || type === "throw") {
      return hasOwn$3.call(record, "value") && !hasOwn$3.call(record, "target");
    }

    return false;
  }

  Ep.getUnmarkedCurrentLoc = function () {
    return util$3.getTypes().numericLiteral(this.listing.length);
  };

  Ep.updateContextPrevLoc = function (loc) {
    var t = util$3.getTypes();

    if (loc) {
      t.assertLiteral(loc);

      if (loc.value === -1) {
        loc.value = this.listing.length;
      } else {
        _assert$2["default"].strictEqual(loc.value, this.listing.length);
      }
    } else {
      loc = this.getUnmarkedCurrentLoc();
    }

    this.emitAssign(this.contextProperty("prev"), loc);
  };

  Ep.explodeExpression = function (path, ignoreResult) {
    var t = util$3.getTypes();
    var expr = path.node;

    if (expr) {
      t.assertExpression(expr);
    } else {
      return expr;
    }

    var self = this;
    var result;
    var after;

    function finish(expr) {
      t.assertExpression(expr);

      if (ignoreResult) {
        self.emit(expr);
      } else {
        return expr;
      }
    }

    if (!meta$1.containsLeap(expr)) {
      return finish(expr);
    }

    var hasLeapingChildren = meta$1.containsLeap.onlyChildren(expr);

    function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
      _assert$2["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");

      var result = self.explodeExpression(childPath, ignoreChildResult);

      if (ignoreChildResult) ; else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
        result = self.emitAssign(tempVar || self.makeTempVar(), result);
      }

      return result;
    }

    switch (expr.type) {
      case "MemberExpression":
        return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

      case "CallExpression":
        var calleePath = path.get("callee");
        var argsPath = path.get("arguments");
        var newCallee;
        var newArgs = [];
        var hasLeapingArgs = false;
        argsPath.forEach(function (argPath) {
          hasLeapingArgs = hasLeapingArgs || meta$1.containsLeap(argPath.node);
        });

        if (t.isMemberExpression(calleePath.node)) {
          if (hasLeapingArgs) {
            var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object"));
            var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
            newArgs.unshift(newObject);
            newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
          } else {
            newCallee = self.explodeExpression(calleePath);
          }
        } else {
          newCallee = explodeViaTempVar(null, calleePath);

          if (t.isMemberExpression(newCallee)) {
            newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
          }
        }

        argsPath.forEach(function (argPath) {
          newArgs.push(explodeViaTempVar(null, argPath));
        });
        return finish(t.callExpression(newCallee, newArgs.map(function (arg) {
          return t.cloneDeep(arg);
        })));

      case "NewExpression":
        return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function (argPath) {
          return explodeViaTempVar(null, argPath);
        })));

      case "ObjectExpression":
        return finish(t.objectExpression(path.get("properties").map(function (propPath) {
          if (propPath.isObjectProperty()) {
            return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed);
          } else {
            return propPath.node;
          }
        })));

      case "ArrayExpression":
        return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
          return explodeViaTempVar(null, elemPath);
        })));

      case "SequenceExpression":
        var lastIndex = expr.expressions.length - 1;
        path.get("expressions").forEach(function (exprPath) {
          if (exprPath.key === lastIndex) {
            result = self.explodeExpression(exprPath, ignoreResult);
          } else {
            self.explodeExpression(exprPath, true);
          }
        });
        return result;

      case "LogicalExpression":
        after = this.loc();

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        var left = explodeViaTempVar(result, path.get("left"));

        if (expr.operator === "&&") {
          self.jumpIfNot(left, after);
        } else {
          _assert$2["default"].strictEqual(expr.operator, "||");

          self.jumpIf(left, after);
        }

        explodeViaTempVar(result, path.get("right"), ignoreResult);
        self.mark(after);
        return result;

      case "ConditionalExpression":
        var elseLoc = this.loc();
        after = this.loc();
        var test = self.explodeExpression(path.get("test"));
        self.jumpIfNot(test, elseLoc);

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        explodeViaTempVar(result, path.get("consequent"), ignoreResult);
        self.jump(after);
        self.mark(elseLoc);
        explodeViaTempVar(result, path.get("alternate"), ignoreResult);
        self.mark(after);
        return result;

      case "UnaryExpression":
        return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

      case "BinaryExpression":
        return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

      case "AssignmentExpression":
        if (expr.operator === "=") {
          return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
        }

        var lhs = self.explodeExpression(path.get("left"));
        var temp = self.emitAssign(self.makeTempVar(), lhs);
        return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

      case "UpdateExpression":
        return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

      case "YieldExpression":
        after = this.loc();
        var arg = expr.argument && self.explodeExpression(path.get("argument"));

        if (arg && expr.delegate) {
          var _result = self.makeTempVar();

          var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));

          _ret.loc = expr.loc;
          self.emit(_ret);
          self.mark(after);
          return _result;
        }

        self.emitAssign(self.contextProperty("next"), after);
        var ret = t.returnStatement(t.cloneDeep(arg) || null);
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return self.contextProperty("sent");

      default:
        throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
    }
  };

  var emit = {
  	Emitter: Emitter_1
  };

  var replaceShorthandObjectMethod_1 = createCommonjsModule(function (module, exports) {



  exports.__esModule = true;
  exports["default"] = replaceShorthandObjectMethod;

  var util = interopRequireWildcard(util$1);

  function replaceShorthandObjectMethod(path) {
    var t = util.getTypes();

    if (!path.node || !t.isFunction(path.node)) {
      throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
    }

    if (!t.isObjectMethod(path.node)) {
      return path;
    }

    if (!path.node.generator) {
      return path;
    }

    var parameters = path.node.params.map(function (param) {
      return t.cloneDeep(param);
    });
    var functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
    util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
    return path.get("value");
  }
  });

  var _assert$3 = interopRequireDefault(assert__default['default']);





  var _replaceShorthandObjectMethod = interopRequireDefault(replaceShorthandObjectMethod_1);

  var util$4 = interopRequireWildcard(util$1);



  var getVisitor = function (_ref) {
    var t = _ref.types;
    return {
      Method: function Method(path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return;
        var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
        path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
        node.async = false;
        node.generator = false;
        path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
      },
      Function: {
        exit: util$4.wrapWithTypes(t, function (path, state) {
          var node = path.node;
          if (!shouldRegenerate(node, state)) return;
          path = (0, _replaceShorthandObjectMethod["default"])(path);
          node = path.node;
          var contextId = path.scope.generateUidIdentifier("context");
          var argsId = path.scope.generateUidIdentifier("args");
          path.ensureBlock();
          var bodyBlockPath = path.get("body");

          if (node.async) {
            bodyBlockPath.traverse(awaitVisitor$1);
          }

          bodyBlockPath.traverse(functionSentVisitor, {
            context: contextId
          });
          var outerBody = [];
          var innerBody = [];
          bodyBlockPath.get("body").forEach(function (childPath) {
            var node = childPath.node;

            if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
              outerBody.push(node);
            } else if (node && node._blockHoist != null) {
              outerBody.push(node);
            } else {
              innerBody.push(node);
            }
          });

          if (outerBody.length > 0) {
            bodyBlockPath.node.body = innerBody;
          }

          var outerFnExpr = getOuterFnExpr(path);
          t.assertIdentifier(node.id);
          var innerFnId = t.identifier(node.id.name + "$");
          var vars = (0, hoist$1.hoist)(path);
          var context = {
            usesThis: false,
            usesArguments: false,
            getArgsId: function getArgsId() {
              return t.clone(argsId);
            }
          };
          path.traverse(argumentsThisVisitor, context);

          if (context.usesArguments) {
            vars = vars || t.variableDeclaration("var", []);
            var argumentIdentifier = t.identifier("arguments");
            argumentIdentifier._shadowedFunctionLiteral = path;
            vars.declarations.push(t.variableDeclarator(t.clone(argsId), argumentIdentifier));
          }

          var emitter = new emit.Emitter(contextId);
          emitter.explode(path.get("body"));

          if (vars && vars.declarations.length > 0) {
            outerBody.push(vars);
          }

          var wrapArgs = [emitter.getContextFunction(innerFnId)];
          var tryLocsList = emitter.getTryLocsList();

          if (node.generator) {
            wrapArgs.push(outerFnExpr);
          } else if (context.usesThis || tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (context.usesThis) {
            wrapArgs.push(t.thisExpression());
          } else if (tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (tryLocsList) {
            wrapArgs.push(tryLocsList);
          } else if (node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (node.async) {
            var currentScope = path.scope;

            do {
              if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
            } while (currentScope = currentScope.parent);

            wrapArgs.push(t.identifier("Promise"));
          }

          var wrapCall = t.callExpression(util$4.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
          outerBody.push(t.returnStatement(wrapCall));
          node.body = t.blockStatement(outerBody);
          path.get("body.body").forEach(function (p) {
            return p.scope.registerDeclaration(p);
          });
          var oldDirectives = bodyBlockPath.node.directives;

          if (oldDirectives) {
            node.body.directives = oldDirectives;
          }

          var wasGeneratorFunction = node.generator;

          if (wasGeneratorFunction) {
            node.generator = false;
          }

          if (node.async) {
            node.async = false;
          }

          if (wasGeneratorFunction && t.isExpression(node)) {
            util$4.replaceWithOrRemove(path, t.callExpression(util$4.runtimeProperty("mark"), [node]));
            path.addComment("leading", "#__PURE__");
          }

          var insertedLocs = emitter.getInsertedLocs();
          path.traverse({
            NumericLiteral: function NumericLiteral(path) {
              if (!insertedLocs.has(path.node)) {
                return;
              }

              path.replaceWith(t.numericLiteral(path.node.value));
            }
          });
          path.requeue();
        })
      }
    };
  };

  function shouldRegenerate(node, state) {
    if (node.generator) {
      if (node.async) {
        return state.opts.asyncGenerators !== false;
      } else {
        return state.opts.generators !== false;
      }
    } else if (node.async) {
      return state.opts.async !== false;
    } else {
      return false;
    }
  }

  function getOuterFnExpr(funPath) {
    var t = util$4.getTypes();
    var node = funPath.node;
    t.assertFunction(node);

    if (!node.id) {
      node.id = funPath.scope.parent.generateUidIdentifier("callee");
    }

    if (node.generator && t.isFunctionDeclaration(node)) {
      return getMarkedFunctionId(funPath);
    }

    return t.clone(node.id);
  }

  var getMarkInfo = (0, _private.makeAccessor)();

  function getMarkedFunctionId(funPath) {
    var t = util$4.getTypes();
    var node = funPath.node;
    t.assertIdentifier(node.id);
    var blockPath = funPath.findParent(function (path) {
      return path.isProgram() || path.isBlockStatement();
    });

    if (!blockPath) {
      return node.id;
    }

    var block = blockPath.node;

    _assert$3["default"].ok(Array.isArray(block.body));

    var info = getMarkInfo(block);

    if (!info.decl) {
      info.decl = t.variableDeclaration("var", []);
      blockPath.unshiftContainer("body", info.decl);
      info.declPath = blockPath.get("body.0");
    }

    _assert$3["default"].strictEqual(info.declPath.node, info.decl);

    var markedId = blockPath.scope.generateUidIdentifier("marked");
    var markCallExp = t.callExpression(util$4.runtimeProperty("mark"), [t.clone(node.id)]);
    var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
    var markCallExpPath = info.declPath.get("declarations." + index + ".init");

    _assert$3["default"].strictEqual(markCallExpPath.node, markCallExp);

    markCallExpPath.addComment("leading", "#__PURE__");
    return t.clone(markedId);
  }

  var argumentsThisVisitor = {
    "FunctionExpression|FunctionDeclaration|Method": function FunctionExpressionFunctionDeclarationMethod(path) {
      path.skip();
    },
    Identifier: function Identifier(path, state) {
      if (path.node.name === "arguments" && util$4.isReference(path)) {
        util$4.replaceWithOrRemove(path, state.getArgsId());
        state.usesArguments = true;
      }
    },
    ThisExpression: function ThisExpression(path, state) {
      state.usesThis = true;
    }
  };
  var functionSentVisitor = {
    MetaProperty: function MetaProperty(path) {
      var node = path.node;

      if (node.meta.name === "function" && node.property.name === "sent") {
        var t = util$4.getTypes();
        util$4.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
      }
    }
  };
  var awaitVisitor$1 = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path) {
      var t = util$4.getTypes();
      var argument = path.node.argument;
      util$4.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util$4.runtimeProperty("awrap"), [argument]), false));
    }
  };

  var visit$2 = {
  	getVisitor: getVisitor
  };

  var lib$e = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = _default;



  function _default(context) {
    var plugin = {
      visitor: (0, visit$2.getVisitor)(context)
    };
    var version = context && context.version;

    if (version && parseInt(version, 10) >= 7) {
      plugin.name = "regenerator-transform";
    }

    return plugin;
  }
  });

  var transformRegenerator = /*@__PURE__*/unwrapExports(lib$e);

  var transformReservedWords = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-reserved-words",
      visitor: {
        "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
          if (!isValidES3Identifier(path.node.name)) {
            path.scope.rename(path.node.name);
          }
        }
      }
    };
  });

  var semver$1 = createCommonjsModule(function (module, exports) {
  exports = module.exports = SemVer;
  var debug;

  if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function debug() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };
  } else {
    debug = function debug() {};
  }

  exports.SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports.re = [];
  var src = exports.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
  var MAINVERSION = R++;
  src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASE = R++;
  src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
  var BUILD = R++;
  src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
  var FULL = R++;
  var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
  src[FULL] = '^' + FULLPLAIN + '$';
  var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
  var LOOSE = R++;
  src[LOOSE] = '^' + LOOSEPLAIN + '$';
  var GTLT = R++;
  src[GTLT] = '((?:<|>)?=?)';
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGE = R++;
  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
  var COERCE = R++;
  src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
  var LONETILDE = R++;
  src[LONETILDE] = '(?:~>?)';
  var TILDETRIM = R++;
  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
  var tildeTrimReplace = '$1~';
  var TILDE = R++;
  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
  var TILDELOOSE = R++;
  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
  var LONECARET = R++;
  src[LONECARET] = '(?:\\^)';
  var CARETTRIM = R++;
  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
  var caretTrimReplace = '$1^';
  var CARET = R++;
  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
  var CARETLOOSE = R++;
  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
  var COMPARATOR = R++;
  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
  var comparatorTrimReplace = '$1$2$3';
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
  var STAR = R++;
  src[STAR] = '(<|>)?=?\\s*\\*';

  for (var i = 0; i < R; i++) {
    debug(i, src[i]);

    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }

  exports.parse = parse;

  function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH) {
      return null;
    }

    var r = options.loose ? re[LOOSE] : re[FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }

  exports.valid = valid;

  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }

  exports.clean = clean;

  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  }

  exports.SemVer = SemVer;

  function SemVer(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version);
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

    if (!m) {
      throw new TypeError('Invalid Version: ' + version);
    }

    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch;

    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.');
    }

    return this.version;
  };

  SemVer.prototype.toString = function () {
    return this.version;
  };

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return this.compareMain(other) || this.comparePre(other);
  };

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    var i = 0;

    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  };

  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;

      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;

      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error('invalid increment argument: ' + release);
    }

    this.format();
    this.raw = this.version;
    return this;
  };

  exports.inc = inc;

  function inc(version, release, loose, identifier) {
    if (typeof loose === 'string') {
      identifier = loose;
      loose = undefined;
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }

  exports.diff = diff;

  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = '';

      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre';
        var defaultResult = 'prerelease';
      }

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  }

  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;

  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }

  exports.rcompareIdentifiers = rcompareIdentifiers;

  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }

  exports.major = major;

  function major(a, loose) {
    return new SemVer(a, loose).major;
  }

  exports.minor = minor;

  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }

  exports.patch = patch;

  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }

  exports.compare = compare;

  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }

  exports.compareLoose = compareLoose;

  function compareLoose(a, b) {
    return compare(a, b, true);
  }

  exports.rcompare = rcompare;

  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }

  exports.sort = sort;

  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose);
    });
  }

  exports.rsort = rsort;

  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose);
    });
  }

  exports.gt = gt;

  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }

  exports.lt = lt;

  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }

  exports.eq = eq;

  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }

  exports.neq = neq;

  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }

  exports.gte = gte;

  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }

  exports.lte = lte;

  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }

  exports.cmp = cmp;

  function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq(a, b, loose);

      case '!=':
        return neq(a, b, loose);

      case '>':
        return gt(a, b, loose);

      case '>=':
        return gte(a, b, loose);

      case '<':
        return lt(a, b, loose);

      case '<=':
        return lte(a, b, loose);

      default:
        throw new TypeError('Invalid operator: ' + op);
    }
  }

  exports.Comparator = Comparator;

  function Comparator(comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  var ANY = {};

  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp);
    }

    this.operator = m[1];

    if (this.operator === '=') {
      this.operator = '';
    }

    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };

  Comparator.prototype.toString = function () {
    return this.value;
  };

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose);

    if (this.semver === ANY) {
      return true;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    return cmp(version, this.operator, this.semver, this.options);
  };

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required');
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    var rangeTmp;

    if (this.operator === '') {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === '') {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }

    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };

  exports.Range = Range;

  function Range(range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }

    if (!(this instanceof Range)) {
      return new Range(range, options);
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    });

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range);
    }

    this.format();
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim();
    }).join('||').trim();
    return this.range;
  };

  Range.prototype.toString = function () {
    return this.range;
  };

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug('hyphen replace', range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug('comparator trim', range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(' ');
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options);
    }, this).join(' ').split(/\s+/);

    if (this.options.loose) {
      set = set.filter(function (comp) {
        return !!comp.match(compRe);
      });
    }

    set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required');
    }

    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };

  exports.toComparators = toComparators;

  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  }

  function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  }

  function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  }

  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(' ');
  }

  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      }

      debug('tilde return', ret);
      return ret;
    });
  }

  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(' ');
  }

  function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
        }
      } else {
        debug('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
      }

      debug('caret return', ret);
      return ret;
    });
  }

  function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(' ');
  }

  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        ret = gtlt + M + '.' + m + '.' + p;
      } else if (xm) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      }

      debug('xRange return', ret);
      return ret;
    });
  }

  function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[STAR], '');
  }

  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0';
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0';
    } else {
      from = '>=' + from;
    }

    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0';
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0';
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
    } else {
      to = '<=' + to;
    }

    return (from + ' ' + to).trim();
  }

  Range.prototype.test = function (version) {
    if (!version) {
      return false;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true;
      }
    }

    return false;
  };

  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver);

        if (set[i].semver === ANY) {
          continue;
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  exports.satisfies = satisfies;

  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  }

  exports.maxSatisfying = maxSatisfying;

  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }

  exports.minSatisfying = minSatisfying;

  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }

  exports.minVersion = minVersion;

  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new SemVer('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error('Unexpected operation: ' + comparator.operator);
        }
      });
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  }

  exports.validRange = validRange;

  function validRange(range, options) {
    try {
      return new Range(range, options).range || '*';
    } catch (er) {
      return null;
    }
  }

  exports.ltr = ltr;

  function ltr(version, range, options) {
    return outside(version, range, '<', options);
  }

  exports.gtr = gtr;

  function gtr(version, range, options) {
    return outside(version, range, '>', options);
  }

  exports.outside = outside;

  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies(version, range, options)) {
      return false;
    }

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }

    return true;
  }

  exports.prerelease = prerelease;

  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }

  exports.intersects = intersects;

  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }

  exports.coerce = coerce;

  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    var match = version.match(re[COERCE]);

    if (match == null) {
      return null;
    }

    return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
  }
  });

  function hasMinVersion(minVersion, runtimeVersion) {
    if (!runtimeVersion) return true;
    if (semver$1.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
    return !semver$1.intersects("<" + minVersion, runtimeVersion) && !semver$1.intersects(">=8.0.0", runtimeVersion);
  }
  function typeAnnotationToString(node) {
    switch (node.type) {
      case "GenericTypeAnnotation":
        if (isIdentifier(node.id, {
          name: "Array"
        })) return "array";
        break;

      case "StringTypeAnnotation":
        return "string";
    }
  }

  var getCoreJS2Definitions = (function (runtimeVersion) {
    var includeMathModule = hasMinVersion("7.0.1", runtimeVersion);
    return {
      BuiltIns: {
        Symbol: {
          stable: true,
          path: "symbol"
        },
        Promise: {
          stable: true,
          path: "promise"
        },
        Map: {
          stable: true,
          path: "map"
        },
        WeakMap: {
          stable: true,
          path: "weak-map"
        },
        Set: {
          stable: true,
          path: "set"
        },
        WeakSet: {
          stable: true,
          path: "weak-set"
        },
        setImmediate: {
          stable: true,
          path: "set-immediate"
        },
        clearImmediate: {
          stable: true,
          path: "clear-immediate"
        },
        parseFloat: {
          stable: true,
          path: "parse-float"
        },
        parseInt: {
          stable: true,
          path: "parse-int"
        }
      },
      StaticProperties: Object.assign({
        Array: {
          from: {
            stable: true,
            path: "array/from"
          },
          isArray: {
            stable: true,
            path: "array/is-array"
          },
          of: {
            stable: true,
            path: "array/of"
          }
        },
        JSON: {
          stringify: {
            stable: true,
            path: "json/stringify"
          }
        },
        Object: {
          assign: {
            stable: true,
            path: "object/assign"
          },
          create: {
            stable: true,
            path: "object/create"
          },
          defineProperties: {
            stable: true,
            path: "object/define-properties"
          },
          defineProperty: {
            stable: true,
            path: "object/define-property"
          },
          entries: {
            stable: true,
            path: "object/entries"
          },
          freeze: {
            stable: true,
            path: "object/freeze"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "object/get-own-property-descriptor"
          },
          getOwnPropertyDescriptors: {
            stable: true,
            path: "object/get-own-property-descriptors"
          },
          getOwnPropertyNames: {
            stable: true,
            path: "object/get-own-property-names"
          },
          getOwnPropertySymbols: {
            stable: true,
            path: "object/get-own-property-symbols"
          },
          getPrototypeOf: {
            stable: true,
            path: "object/get-prototype-of"
          },
          isExtensible: {
            stable: true,
            path: "object/is-extensible"
          },
          isFrozen: {
            stable: true,
            path: "object/is-frozen"
          },
          isSealed: {
            stable: true,
            path: "object/is-sealed"
          },
          is: {
            stable: true,
            path: "object/is"
          },
          keys: {
            stable: true,
            path: "object/keys"
          },
          preventExtensions: {
            stable: true,
            path: "object/prevent-extensions"
          },
          seal: {
            stable: true,
            path: "object/seal"
          },
          setPrototypeOf: {
            stable: true,
            path: "object/set-prototype-of"
          },
          values: {
            stable: true,
            path: "object/values"
          }
        }
      }, includeMathModule ? {
        Math: {
          acosh: {
            stable: true,
            path: "math/acosh"
          },
          asinh: {
            stable: true,
            path: "math/asinh"
          },
          atanh: {
            stable: true,
            path: "math/atanh"
          },
          cbrt: {
            stable: true,
            path: "math/cbrt"
          },
          clz32: {
            stable: true,
            path: "math/clz32"
          },
          cosh: {
            stable: true,
            path: "math/cosh"
          },
          expm1: {
            stable: true,
            path: "math/expm1"
          },
          fround: {
            stable: true,
            path: "math/fround"
          },
          hypot: {
            stable: true,
            path: "math/hypot"
          },
          imul: {
            stable: true,
            path: "math/imul"
          },
          log10: {
            stable: true,
            path: "math/log10"
          },
          log1p: {
            stable: true,
            path: "math/log1p"
          },
          log2: {
            stable: true,
            path: "math/log2"
          },
          sign: {
            stable: true,
            path: "math/sign"
          },
          sinh: {
            stable: true,
            path: "math/sinh"
          },
          tanh: {
            stable: true,
            path: "math/tanh"
          },
          trunc: {
            stable: true,
            path: "math/trunc"
          }
        }
      } : {}, {
        Symbol: {
          "for": {
            stable: true,
            path: "symbol/for"
          },
          hasInstance: {
            stable: true,
            path: "symbol/has-instance"
          },
          isConcatSpreadable: {
            stable: true,
            path: "symbol/is-concat-spreadable"
          },
          iterator: {
            stable: true,
            path: "symbol/iterator"
          },
          keyFor: {
            stable: true,
            path: "symbol/key-for"
          },
          match: {
            stable: true,
            path: "symbol/match"
          },
          replace: {
            stable: true,
            path: "symbol/replace"
          },
          search: {
            stable: true,
            path: "symbol/search"
          },
          species: {
            stable: true,
            path: "symbol/species"
          },
          split: {
            stable: true,
            path: "symbol/split"
          },
          toPrimitive: {
            stable: true,
            path: "symbol/to-primitive"
          },
          toStringTag: {
            stable: true,
            path: "symbol/to-string-tag"
          },
          unscopables: {
            stable: true,
            path: "symbol/unscopables"
          }
        },
        String: {
          at: {
            stable: true,
            path: "string/at"
          },
          fromCodePoint: {
            stable: true,
            path: "string/from-code-point"
          },
          raw: {
            stable: true,
            path: "string/raw"
          }
        },
        Number: {
          EPSILON: {
            stable: true,
            path: "number/epsilon"
          },
          isFinite: {
            stable: true,
            path: "number/is-finite"
          },
          isInteger: {
            stable: true,
            path: "number/is-integer"
          },
          isNaN: {
            stable: true,
            path: "number/is-nan"
          },
          isSafeInteger: {
            stable: true,
            path: "number/is-safe-integer"
          },
          MAX_SAFE_INTEGER: {
            stable: true,
            path: "number/max-safe-integer"
          },
          MIN_SAFE_INTEGER: {
            stable: true,
            path: "number/min-safe-integer"
          },
          parseFloat: {
            stable: true,
            path: "number/parse-float"
          },
          parseInt: {
            stable: true,
            path: "number/parse-int"
          }
        },
        Reflect: {
          apply: {
            stable: true,
            path: "reflect/apply"
          },
          construct: {
            stable: true,
            path: "reflect/construct"
          },
          defineProperty: {
            stable: true,
            path: "reflect/define-property"
          },
          deleteProperty: {
            stable: true,
            path: "reflect/delete-property"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "reflect/get-own-property-descriptor"
          },
          getPrototypeOf: {
            stable: true,
            path: "reflect/get-prototype-of"
          },
          get: {
            stable: true,
            path: "reflect/get"
          },
          has: {
            stable: true,
            path: "reflect/has"
          },
          isExtensible: {
            stable: true,
            path: "reflect/is-extensible"
          },
          ownKeys: {
            stable: true,
            path: "reflect/own-keys"
          },
          preventExtensions: {
            stable: true,
            path: "reflect/prevent-extensions"
          },
          setPrototypeOf: {
            stable: true,
            path: "reflect/set-prototype-of"
          },
          set: {
            stable: true,
            path: "reflect/set"
          }
        },
        Date: {
          now: {
            stable: true,
            path: "date/now"
          }
        }
      })
    };
  });

  var getCoreJS3Definitions = (function () {
    return {
      BuiltIns: {
        AggregateError: {
          stable: false,
          path: "aggregate-error"
        },
        Map: {
          stable: true,
          path: "map"
        },
        Observable: {
          stable: false,
          path: "observable"
        },
        Promise: {
          stable: true,
          path: "promise"
        },
        Set: {
          stable: true,
          path: "set"
        },
        Symbol: {
          stable: true,
          path: "symbol"
        },
        URL: {
          stable: true,
          path: "url"
        },
        URLSearchParams: {
          stable: true,
          path: "url-search-params"
        },
        WeakMap: {
          stable: true,
          path: "weak-map"
        },
        WeakSet: {
          stable: true,
          path: "weak-set"
        },
        clearImmediate: {
          stable: true,
          path: "clear-immediate"
        },
        compositeKey: {
          stable: false,
          path: "composite-key"
        },
        compositeSymbol: {
          stable: false,
          path: "composite-symbol"
        },
        globalThis: {
          stable: false,
          path: "global-this"
        },
        parseFloat: {
          stable: true,
          path: "parse-float"
        },
        parseInt: {
          stable: true,
          path: "parse-int"
        },
        queueMicrotask: {
          stable: true,
          path: "queue-microtask"
        },
        setImmediate: {
          stable: true,
          path: "set-immediate"
        },
        setInterval: {
          stable: true,
          path: "set-interval"
        },
        setTimeout: {
          stable: true,
          path: "set-timeout"
        }
      },
      StaticProperties: {
        Array: {
          from: {
            stable: true,
            path: "array/from"
          },
          isArray: {
            stable: true,
            path: "array/is-array"
          },
          of: {
            stable: true,
            path: "array/of"
          }
        },
        Date: {
          now: {
            stable: true,
            path: "date/now"
          }
        },
        JSON: {
          stringify: {
            stable: true,
            path: "json/stringify"
          }
        },
        Math: {
          DEG_PER_RAD: {
            stable: false,
            path: "math/deg-per-rad"
          },
          RAD_PER_DEG: {
            stable: false,
            path: "math/rad-per-deg"
          },
          acosh: {
            stable: true,
            path: "math/acosh"
          },
          asinh: {
            stable: true,
            path: "math/asinh"
          },
          atanh: {
            stable: true,
            path: "math/atanh"
          },
          cbrt: {
            stable: true,
            path: "math/cbrt"
          },
          clamp: {
            stable: false,
            path: "math/clamp"
          },
          clz32: {
            stable: true,
            path: "math/clz32"
          },
          cosh: {
            stable: true,
            path: "math/cosh"
          },
          degrees: {
            stable: false,
            path: "math/degrees"
          },
          expm1: {
            stable: true,
            path: "math/expm1"
          },
          fround: {
            stable: true,
            path: "math/fround"
          },
          fscale: {
            stable: false,
            path: "math/fscale"
          },
          hypot: {
            stable: true,
            path: "math/hypot"
          },
          iaddh: {
            stable: false,
            path: "math/iaddh"
          },
          imul: {
            stable: true,
            path: "math/imul"
          },
          imulh: {
            stable: false,
            path: "math/imulh"
          },
          isubh: {
            stable: false,
            path: "math/isubh"
          },
          log10: {
            stable: true,
            path: "math/log10"
          },
          log1p: {
            stable: true,
            path: "math/log1p"
          },
          log2: {
            stable: true,
            path: "math/log2"
          },
          radians: {
            stable: false,
            path: "math/radians"
          },
          scale: {
            stable: false,
            path: "math/scale"
          },
          seededPRNG: {
            stable: false,
            path: "math/seeded-prng"
          },
          sign: {
            stable: true,
            path: "math/sign"
          },
          signbit: {
            stable: false,
            path: "math/signbit"
          },
          sinh: {
            stable: true,
            path: "math/sinh"
          },
          tanh: {
            stable: true,
            path: "math/tanh"
          },
          trunc: {
            stable: true,
            path: "math/trunc"
          },
          umulh: {
            stable: false,
            path: "math/umulh"
          }
        },
        Number: {
          EPSILON: {
            stable: true,
            path: "number/epsilon"
          },
          MAX_SAFE_INTEGER: {
            stable: true,
            path: "number/max-safe-integer"
          },
          MIN_SAFE_INTEGER: {
            stable: true,
            path: "number/min-safe-integer"
          },
          fromString: {
            stable: false,
            path: "number/from-string"
          },
          isFinite: {
            stable: true,
            path: "number/is-finite"
          },
          isInteger: {
            stable: true,
            path: "number/is-integer"
          },
          isNaN: {
            stable: true,
            path: "number/is-nan"
          },
          isSafeInteger: {
            stable: true,
            path: "number/is-safe-integer"
          },
          parseFloat: {
            stable: true,
            path: "number/parse-float"
          },
          parseInt: {
            stable: true,
            path: "number/parse-int"
          }
        },
        Object: {
          assign: {
            stable: true,
            path: "object/assign"
          },
          create: {
            stable: true,
            path: "object/create"
          },
          defineProperties: {
            stable: true,
            path: "object/define-properties"
          },
          defineProperty: {
            stable: true,
            path: "object/define-property"
          },
          entries: {
            stable: true,
            path: "object/entries"
          },
          freeze: {
            stable: true,
            path: "object/freeze"
          },
          fromEntries: {
            stable: true,
            path: "object/from-entries"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "object/get-own-property-descriptor"
          },
          getOwnPropertyDescriptors: {
            stable: true,
            path: "object/get-own-property-descriptors"
          },
          getOwnPropertyNames: {
            stable: true,
            path: "object/get-own-property-names"
          },
          getOwnPropertySymbols: {
            stable: true,
            path: "object/get-own-property-symbols"
          },
          getPrototypeOf: {
            stable: true,
            path: "object/get-prototype-of"
          },
          isExtensible: {
            stable: true,
            path: "object/is-extensible"
          },
          isFrozen: {
            stable: true,
            path: "object/is-frozen"
          },
          isSealed: {
            stable: true,
            path: "object/is-sealed"
          },
          is: {
            stable: true,
            path: "object/is"
          },
          keys: {
            stable: true,
            path: "object/keys"
          },
          preventExtensions: {
            stable: true,
            path: "object/prevent-extensions"
          },
          seal: {
            stable: true,
            path: "object/seal"
          },
          setPrototypeOf: {
            stable: true,
            path: "object/set-prototype-of"
          },
          values: {
            stable: true,
            path: "object/values"
          }
        },
        Reflect: {
          apply: {
            stable: true,
            path: "reflect/apply"
          },
          construct: {
            stable: true,
            path: "reflect/construct"
          },
          defineMetadata: {
            stable: false,
            path: "reflect/define-metadata"
          },
          defineProperty: {
            stable: true,
            path: "reflect/define-property"
          },
          deleteMetadata: {
            stable: false,
            path: "reflect/delete-metadata"
          },
          deleteProperty: {
            stable: true,
            path: "reflect/delete-property"
          },
          getMetadata: {
            stable: false,
            path: "reflect/get-metadata"
          },
          getMetadataKeys: {
            stable: false,
            path: "reflect/get-metadata-keys"
          },
          getOwnMetadata: {
            stable: false,
            path: "reflect/get-own-metadata"
          },
          getOwnMetadataKeys: {
            stable: false,
            path: "reflect/get-own-metadata-keys"
          },
          getOwnPropertyDescriptor: {
            stable: true,
            path: "reflect/get-own-property-descriptor"
          },
          getPrototypeOf: {
            stable: true,
            path: "reflect/get-prototype-of"
          },
          get: {
            stable: true,
            path: "reflect/get"
          },
          has: {
            stable: true,
            path: "reflect/has"
          },
          hasMetadata: {
            stable: false,
            path: "reflect/has-metadata"
          },
          hasOwnMetadata: {
            stable: false,
            path: "reflect/has-own-metadata"
          },
          isExtensible: {
            stable: true,
            path: "reflect/is-extensible"
          },
          metadata: {
            stable: false,
            path: "reflect/metadata"
          },
          ownKeys: {
            stable: true,
            path: "reflect/own-keys"
          },
          preventExtensions: {
            stable: true,
            path: "reflect/prevent-extensions"
          },
          set: {
            stable: true,
            path: "reflect/set"
          },
          setPrototypeOf: {
            stable: true,
            path: "reflect/set-prototype-of"
          }
        },
        String: {
          fromCodePoint: {
            stable: true,
            path: "string/from-code-point"
          },
          raw: {
            stable: true,
            path: "string/raw"
          }
        },
        Symbol: {
          asyncIterator: {
            stable: true,
            path: "symbol/async-iterator"
          },
          dispose: {
            stable: false,
            path: "symbol/dispose"
          },
          "for": {
            stable: true,
            path: "symbol/for"
          },
          hasInstance: {
            stable: true,
            path: "symbol/has-instance"
          },
          isConcatSpreadable: {
            stable: true,
            path: "symbol/is-concat-spreadable"
          },
          iterator: {
            stable: true,
            path: "symbol/iterator"
          },
          keyFor: {
            stable: true,
            path: "symbol/key-for"
          },
          match: {
            stable: true,
            path: "symbol/match"
          },
          observable: {
            stable: false,
            path: "symbol/observable"
          },
          patternMatch: {
            stable: false,
            path: "symbol/pattern-match"
          },
          replace: {
            stable: true,
            path: "symbol/replace"
          },
          search: {
            stable: true,
            path: "symbol/search"
          },
          species: {
            stable: true,
            path: "symbol/species"
          },
          split: {
            stable: true,
            path: "symbol/split"
          },
          toPrimitive: {
            stable: true,
            path: "symbol/to-primitive"
          },
          toStringTag: {
            stable: true,
            path: "symbol/to-string-tag"
          },
          unscopables: {
            stable: true,
            path: "symbol/unscopables"
          }
        }
      },
      InstanceProperties: {
        at: {
          stable: false,
          path: "at"
        },
        bind: {
          stable: true,
          path: "bind"
        },
        codePointAt: {
          stable: true,
          path: "code-point-at"
        },
        codePoints: {
          stable: false,
          path: "code-points"
        },
        concat: {
          stable: true,
          path: "concat",
          types: ["array"]
        },
        copyWithin: {
          stable: true,
          path: "copy-within"
        },
        endsWith: {
          stable: true,
          path: "ends-with"
        },
        entries: {
          stable: true,
          path: "entries"
        },
        every: {
          stable: true,
          path: "every"
        },
        fill: {
          stable: true,
          path: "fill"
        },
        filter: {
          stable: true,
          path: "filter"
        },
        find: {
          stable: true,
          path: "find"
        },
        findIndex: {
          stable: true,
          path: "find-index"
        },
        flags: {
          stable: true,
          path: "flags"
        },
        flatMap: {
          stable: true,
          path: "flat-map"
        },
        flat: {
          stable: true,
          path: "flat"
        },
        forEach: {
          stable: true,
          path: "for-each"
        },
        includes: {
          stable: true,
          path: "includes"
        },
        indexOf: {
          stable: true,
          path: "index-of"
        },
        keys: {
          stable: true,
          path: "keys"
        },
        lastIndexOf: {
          stable: true,
          path: "last-index-of"
        },
        map: {
          stable: true,
          path: "map"
        },
        matchAll: {
          stable: false,
          path: "match-all"
        },
        padEnd: {
          stable: true,
          path: "pad-end"
        },
        padStart: {
          stable: true,
          path: "pad-start"
        },
        reduce: {
          stable: true,
          path: "reduce"
        },
        reduceRight: {
          stable: true,
          path: "reduce-right"
        },
        repeat: {
          stable: true,
          path: "repeat"
        },
        replaceAll: {
          stable: false,
          path: "replace-all"
        },
        reverse: {
          stable: true,
          path: "reverse"
        },
        slice: {
          stable: true,
          path: "slice"
        },
        some: {
          stable: true,
          path: "some"
        },
        sort: {
          stable: true,
          path: "sort"
        },
        splice: {
          stable: true,
          path: "splice"
        },
        startsWith: {
          stable: true,
          path: "starts-with"
        },
        trim: {
          stable: true,
          path: "trim"
        },
        trimEnd: {
          stable: true,
          path: "trim-end"
        },
        trimLeft: {
          stable: true,
          path: "trim-left"
        },
        trimRight: {
          stable: true,
          path: "trim-right"
        },
        trimStart: {
          stable: true,
          path: "trim-start"
        },
        values: {
          stable: true,
          path: "values"
        }
      }
    };
  });

  function getRuntimePath (moduleName, dirname, absoluteRuntime) {
    if (absoluteRuntime === false) return moduleName;
    return resolveAbsoluteRuntime(moduleName, path__default['default'].resolve(dirname, absoluteRuntime === true ? "." : absoluteRuntime));
  }

  function resolveAbsoluteRuntime(moduleName, dirname) {
    try {
      return path__default['default'].dirname((parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref, M) {
        var _ref$paths = _ref.paths,
            b = _ref$paths[0];

        if (M === void 0) {
          M = require("module");
        }

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '" + r + "'");
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(moduleName + "/package.json", {
        paths: [dirname]
      })).replace(/\\/g, "/");
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND") throw err;
      throw Object.assign(new Error("Failed to resolve \"" + moduleName + "\" relative to \"" + dirname + "\""), {
        code: "BABEL_RUNTIME_NOT_FOUND",
        runtime: moduleName,
        dirname: dirname
      });
    }
  }

  function supportsStaticESM(caller) {
    return !!(caller == null ? void 0 : caller.supportsStaticESM);
  }

  var transformRuntime = declare(function (api, options, dirname) {
    api.assertVersion(7);
    var corejs = options.corejs,
        _options$helpers = options.helpers,
        useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
        _options$regenerator = options.regenerator,
        useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
        _options$useESModules = options.useESModules,
        useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
        _options$version = options.version,
        runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
        _options$absoluteRunt = options.absoluteRuntime,
        absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
    var proposals = false;
    var rawVersion;

    if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var corejsVersion = rawVersion ? Number(rawVersion) : false;

    if (![false, 2, 3].includes(corejsVersion)) {
      throw new Error("The `core-js` version must be false, 2 or 3, but got " + JSON.stringify(rawVersion) + ".");
    }

    if (proposals && (!corejsVersion || corejsVersion < 3)) {
      throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
    }

    if (typeof useRuntimeRegenerator !== "boolean") {
      throw new Error("The 'regenerator' option must be undefined, or a boolean.");
    }

    if (typeof useRuntimeHelpers !== "boolean") {
      throw new Error("The 'helpers' option must be undefined, or a boolean.");
    }

    if (typeof useESModules !== "boolean" && useESModules !== "auto") {
      throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
    }

    if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
      throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
    }

    if (typeof runtimeVersion !== "string") {
      throw new Error("The 'version' option must be a version string.");
    }

    function has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    function hasMapping(methods, name) {
      return has(methods, name) && (proposals || methods[name].stable);
    }

    function hasStaticMapping(object, method) {
      return has(StaticProperties, object) && hasMapping(StaticProperties[object], method);
    }

    function isNamespaced(path) {
      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return false;
      return binding.path.isImportNamespaceSpecifier();
    }

    function maybeNeedsPolyfill(path, methods, name) {
      if (isNamespaced(path.get("object"))) return false;
      if (!methods[name].types) return true;
      var typeAnnotation = path.get("object").getTypeAnnotation();
      var type = typeAnnotationToString(typeAnnotation);
      if (!type) return true;
      return methods[name].types.some(function (name) {
        return name === type;
      });
    }

    function resolvePropertyName(path, computed) {
      var node = path.node;
      if (!computed) return node.name;
      if (path.isStringLiteral()) return node.value;
      var result = path.evaluate();
      return result.value;
    }

    if (has(options, "useBuiltIns")) {
      if (options.useBuiltIns) {
        throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
      } else {
        throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "polyfill")) {
      if (options.polyfill === false) {
        throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
      } else {
        throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "moduleName")) {
      throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
    }

    var esModules = useESModules === "auto" ? api.caller(supportsStaticESM) : useESModules;
    var injectCoreJS2 = corejsVersion === 2;
    var injectCoreJS3 = corejsVersion === 3;
    var injectCoreJS = corejsVersion !== false;
    var moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
    var corejsRoot = injectCoreJS3 && !proposals ? "core-js-stable" : "core-js";

    var _ref = (injectCoreJS2 ? getCoreJS2Definitions : getCoreJS3Definitions)(runtimeVersion),
        BuiltIns = _ref.BuiltIns,
        StaticProperties = _ref.StaticProperties,
        InstanceProperties = _ref.InstanceProperties;

    var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
    var modulePath = getRuntimePath(moduleName, dirname, absoluteRuntime);
    return {
      name: "transform-runtime",
      pre: function pre(file) {
        var _this = this;

        if (useRuntimeHelpers) {
          file.set("helperGenerator", function (name) {
            if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
              return;
            }

            var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
            var blockHoist = isInteropHelper && !isModule(file.path) ? 4 : undefined;
            var helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
            return _this.addDefaultImport(modulePath + "/" + helpersDir + "/" + name, name, blockHoist);
          });
        }

        var cache = new Map();

        this.addDefaultImport = function (source, nameHint, blockHoist) {
          var cacheKey = isModule(file.path);
          var key = source + ":" + nameHint + ":" + (cacheKey || "");
          var cached = cache.get(key);

          if (cached) {
            cached = cloneNode(cached);
          } else {
            cached = addDefault(file.path, source, {
              importedInterop: "uncompiled",
              nameHint: nameHint,
              blockHoist: blockHoist
            });
            cache.set(key, cached);
          }

          return cached;
        };
      },
      visitor: {
        ReferencedIdentifier: function ReferencedIdentifier(path) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var name = node.name;

          if (name === "regeneratorRuntime" && useRuntimeRegenerator) {
            path.replaceWith(this.addDefaultImport(modulePath + "/regenerator", "regeneratorRuntime"));
            return;
          }

          if (!injectCoreJS) return;
          if (isMemberExpression(parent)) return;
          if (!hasMapping(BuiltIns, name)) return;
          if (scope.getBindingIdentifier(name)) return;
          path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name));
        },
        CallExpression: function CallExpression(path) {
          if (!injectCoreJS) return;
          var node = path.node;
          var callee = node.callee;
          if (!isMemberExpression(callee)) return;
          var object = callee.object;
          var propertyName = resolvePropertyName(path.get("callee.property"), callee.computed);

          if (injectCoreJS3 && !hasStaticMapping(object.name, propertyName)) {
            if (hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path.get("callee"), InstanceProperties, propertyName)) {
              var context1, context2;

              if (isIdentifier(object)) {
                context1 = object;
                context2 = cloneNode(object);
              } else {
                context1 = path.scope.generateDeclaredUidIdentifier("context");
                context2 = assignmentExpression("=", cloneNode(context1), object);
              }

              node.callee = memberExpression(callExpression(this.addDefaultImport(modulePath + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [context2]), identifier("call"));
              node.arguments.unshift(context1);
              return;
            }
          }

          if (node.arguments.length) return;
          if (!callee.computed) return;

          if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
            return;
          }

          path.replaceWith(callExpression(this.addDefaultImport(modulePath + "/core-js/get-iterator", "getIterator"), [object]));
        },
        BinaryExpression: function BinaryExpression(path) {
          if (!injectCoreJS) return;
          if (path.node.operator !== "in") return;
          if (!path.get("left").matchesPattern("Symbol.iterator")) return;
          path.replaceWith(callExpression(this.addDefaultImport(modulePath + "/core-js/is-iterable", "isIterable"), [path.node.right]));
        },
        MemberExpression: {
          enter: function enter(path) {
            if (!injectCoreJS) return;
            if (!path.isReferenced()) return;
            if (path.parentPath.isUnaryExpression({
              operator: "delete"
            })) return;
            var node = path.node;
            var object = node.object;
            if (!isReferenced(object, node)) return;

            if (!injectCoreJS2 && node.computed && path.get("property").matchesPattern("Symbol.iterator")) {
              path.replaceWith(callExpression(this.addDefaultImport(modulePath + "/core-js/get-iterator-method", "getIteratorMethod"), [object]));
              return;
            }

            var objectName = object.name;
            var propertyName = resolvePropertyName(path.get("property"), node.computed);

            if (path.scope.getBindingIdentifier(objectName) || !hasStaticMapping(objectName, propertyName)) {
              if (injectCoreJS3 && hasMapping(InstanceProperties, propertyName) && maybeNeedsPolyfill(path, InstanceProperties, propertyName)) {
                path.replaceWith(callExpression(this.addDefaultImport(modulePath + "/" + corejsRoot + "/instance/" + InstanceProperties[propertyName].path, propertyName + "InstanceProperty"), [object]));
              }

              return;
            }

            path.replaceWith(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + StaticProperties[objectName][propertyName].path, objectName + "$" + propertyName));
          },
          exit: function exit(path) {
            if (!injectCoreJS) return;
            if (!path.isReferenced()) return;
            if (path.node.computed) return;
            var node = path.node;
            var object = node.object;
            var name = object.name;
            if (!hasMapping(BuiltIns, name)) return;
            if (path.scope.getBindingIdentifier(name)) return;
            path.replaceWith(memberExpression(this.addDefaultImport(modulePath + "/" + corejsRoot + "/" + BuiltIns[name].path, name), node.property));
          }
        }
      }
    };
  });

  var transformShorthandProperties = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-shorthand-properties",
      visitor: {
        ObjectMethod: function ObjectMethod(path) {
          var node = path.node;

          if (node.kind === "method") {
            var func = functionExpression(null, node.params, node.body, node.generator, node.async);
            func.returnType = node.returnType;
            path.replaceWith(objectProperty(node.key, func, node.computed));
          }
        },
        ObjectProperty: function ObjectProperty(_ref) {
          var node = _ref.node;

          if (node.shorthand) {
            node.shorthand = false;
          }
        }
      }
    };
  });

  var transformSpread = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose,
        allowArrayLike = options.allowArrayLike;

    function getSpreadLiteral(spread, scope) {
      if (loose && !isIdentifier(spread.argument, {
        name: "arguments"
      })) {
        return spread.argument;
      } else {
        return scope.toArray(spread.argument, true, allowArrayLike);
      }
    }

    function hasSpread(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (isSpreadElement(nodes[i])) {
          return true;
        }
      }

      return false;
    }

    function push(_props, nodes) {
      if (!_props.length) return _props;
      nodes.push(arrayExpression(_props));
      return [];
    }

    function build(props, scope) {
      var nodes = [];
      var _props = [];

      for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (isSpreadElement(prop)) {
          _props = push(_props, nodes);
          nodes.push(getSpreadLiteral(prop, scope));
        } else {
          _props.push(prop);
        }
      }

      push(_props, nodes);
      return nodes;
    }

    return {
      name: "transform-spread",
      visitor: {
        ArrayExpression: function ArrayExpression(path) {
          var node = path.node,
              scope = path.scope;
          var elements = node.elements;
          if (!hasSpread(elements)) return;
          var nodes = build(elements, scope);
          var first = nodes[0];

          if (nodes.length === 1 && first !== elements[0].argument) {
            path.replaceWith(first);
            return;
          }

          if (!isArrayExpression(first)) {
            first = arrayExpression([]);
          } else {
            nodes.shift();
          }

          path.replaceWith(callExpression(memberExpression(first, identifier("concat")), nodes));
        },
        CallExpression: function CallExpression(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var calleePath = skipTransparentExprWrappers(path.get("callee"));
          if (calleePath.isSuper()) return;
          var contextLiteral = scope.buildUndefinedNode();
          node.arguments = [];
          var nodes;

          if (args.length === 1 && args[0].argument.name === "arguments") {
            nodes = [args[0].argument];
          } else {
            nodes = build(args, scope);
          }

          var first = nodes.shift();

          if (nodes.length) {
            node.arguments.push(callExpression(memberExpression(first, identifier("concat")), nodes));
          } else {
            node.arguments.push(first);
          }

          var callee = calleePath.node;

          if (calleePath.isMemberExpression()) {
            var temp = scope.maybeGenerateMemoised(callee.object);

            if (temp) {
              callee.object = assignmentExpression("=", temp, callee.object);
              contextLiteral = temp;
            } else {
              contextLiteral = cloneNode(callee.object);
            }
          }

          node.callee = memberExpression(node.callee, identifier("apply"));

          if (isSuper(contextLiteral)) {
            contextLiteral = thisExpression();
          }

          node.arguments.unshift(cloneNode(contextLiteral));
        },
        NewExpression: function NewExpression(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var nodes = build(args, scope);
          var first = nodes.shift();

          if (nodes.length) {
            args = callExpression(memberExpression(first, identifier("concat")), nodes);
          } else {
            args = first;
          }

          path.replaceWith(callExpression(path.hub.addHelper("construct"), [node.callee, args]));
        }
      }
    };
  });

  var transformStickyRegex = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-sticky-regex",
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var node = path.node;
          if (!node.flags.includes("y")) return;
          path.replaceWith(newExpression(identifier("RegExp"), [stringLiteral(node.pattern), stringLiteral(node.flags)]));
        }
      }
    };
  });

  var transformStrictMode = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-strict-mode",
      visitor: {
        Program: function Program(path) {
          var node = path.node;

          for (var _i = 0, _arr = node.directives; _i < _arr.length; _i++) {
            var directive$1 = _arr[_i];
            if (directive$1.value.value === "use strict") return;
          }

          path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
        }
      }
    };
  });

  function _templateObject$f() {
    var data = _taggedTemplateLiteralLoose(["\n              ", " || (\n                ", " = ", "(", ")\n              )\n            "]);

    _templateObject$f = function _templateObject() {
      return data;
    };

    return data;
  }
  var transformTemplateLiterals = declare(function (api, options) {
    api.assertVersion(7);
    var loose = options.loose;
    var helperName = "taggedTemplateLiteral";
    if (loose) helperName += "Loose";

    function buildConcatCallExpressions(items) {
      var avail = true;
      return items.reduce(function (left, right) {
        var canBeInserted = isLiteral(right);

        if (!canBeInserted && avail) {
          canBeInserted = true;
          avail = false;
        }

        if (canBeInserted && isCallExpression(left)) {
          left.arguments.push(right);
          return left;
        }

        return callExpression(memberExpression(left, identifier("concat")), [right]);
      });
    }

    return {
      name: "transform-template-literals",
      visitor: {
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          var node = path.node;
          var quasi = node.quasi;
          var strings = [];
          var raws = [];
          var isStringsRawEqual = true;

          for (var _i = 0, _arr = quasi.quasis; _i < _arr.length; _i++) {
            var elem = _arr[_i];
            var _elem$value = elem.value,
                raw = _elem$value.raw,
                cooked = _elem$value.cooked;
            var value = cooked == null ? path.scope.buildUndefinedNode() : stringLiteral(cooked);
            strings.push(value);
            raws.push(stringLiteral(raw));

            if (raw !== cooked) {
              isStringsRawEqual = false;
            }
          }

          var helperArgs = [arrayExpression(strings)];

          if (!isStringsRawEqual) {
            helperArgs.push(arrayExpression(raws));
          }

          var tmp = path.scope.generateUidIdentifier("templateObject");
          path.scope.getProgramParent().push({
            id: cloneNode(tmp)
          });
          path.replaceWith(callExpression(node.tag, [template.expression.ast(_templateObject$f(), cloneNode(tmp), tmp, this.addHelper(helperName), helperArgs)].concat(quasi.expressions)));
        },
        TemplateLiteral: function TemplateLiteral(path) {
          var nodes = [];
          var expressions = path.get("expressions");
          var index = 0;

          for (var _i2 = 0, _arr2 = path.node.quasis; _i2 < _arr2.length; _i2++) {
            var elem = _arr2[_i2];

            if (elem.value.cooked) {
              nodes.push(stringLiteral(elem.value.cooked));
            }

            if (index < expressions.length) {
              var expr = expressions[index++];
              var node = expr.node;

              if (!isStringLiteral(node, {
                value: ""
              })) {
                nodes.push(node);
              }
            }
          }

          var considerSecondNode = !loose || !isStringLiteral(nodes[1]);

          if (!isStringLiteral(nodes[0]) && considerSecondNode) {
            nodes.unshift(stringLiteral(""));
          }

          var root = nodes[0];

          if (loose) {
            for (var i = 1; i < nodes.length; i++) {
              root = binaryExpression("+", root, nodes[i]);
            }
          } else if (nodes.length > 1) {
            root = buildConcatCallExpressions(nodes);
          }

          path.replaceWith(root);
        }
      }
    };
  });

  var transformTypeofSymbol = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-typeof-symbol",
      visitor: {
        Scope: function Scope(_ref) {
          var scope = _ref.scope;

          if (!scope.getBinding("Symbol")) {
            return;
          }

          scope.rename("Symbol");
        },
        UnaryExpression: function UnaryExpression(path) {
          var node = path.node,
              parent = path.parent;
          if (node.operator !== "typeof") return;

          if (path.parentPath.isBinaryExpression() && EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
            var opposite = path.getOpposite();

            if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
              return;
            }
          }

          var isUnderHelper = path.findParent(function (path) {
            if (path.isFunction()) {
              var _path$get;

              return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
            }
          });
          if (isUnderHelper) return;
          var helper = this.addHelper("typeof");
          isUnderHelper = path.findParent(function (path) {
            return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
          });

          if (isUnderHelper) {
            return;
          }

          var call = callExpression(helper, [node.argument]);
          var arg = path.get("argument");

          if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
            var unary = unaryExpression("typeof", cloneNode(node.argument));
            path.replaceWith(conditionalExpression(binaryExpression("===", unary, stringLiteral("undefined")), stringLiteral("undefined"), call));
          } else {
            path.replaceWith(call);
          }
        }
      }
    };
  });

  function transpileEnum(path, t) {
    var node = path.node;

    if (node["const"]) {
      throw path.buildCodeFrameError("'const' enums are not supported.");
    }

    if (node.declare) {
      path.remove();
      return;
    }

    var name = node.id.name;
    var fill = enumFill(path, t, node.id);

    switch (path.parent.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program":
        {
          path.insertAfter(fill);

          if (seen(path.parentPath)) {
            path.remove();
          } else {
            var isGlobal = t.isProgram(path.parent);
            path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"))[0]);
          }

          break;
        }

      default:
        throw new Error("Unexpected enum parent '" + path.parent.type);
    }

    function seen(parentPath) {
      if (parentPath.isExportDeclaration()) {
        return seen(parentPath.parentPath);
      }

      if (parentPath.getData(name)) {
        return true;
      } else {
        parentPath.setData(name, true);
        return false;
      }
    }
  }

  function makeVar(id, t, kind) {
    return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
  }

  var buildEnumWrapper = template("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");
  var buildStringAssignment = template("\n  ENUM[\"NAME\"] = VALUE;\n");
  var buildNumericAssignment = template("\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n");

  var buildEnumMember = function buildEnumMember(isString, options) {
    return (isString ? buildStringAssignment : buildNumericAssignment)(options);
  };

  function enumFill(path, t, id) {
    var x = translateEnumValues(path, t);
    var assignments = x.map(function (_ref) {
      var memberName = _ref[0],
          memberValue = _ref[1];
      return buildEnumMember(t.isStringLiteral(memberValue), {
        ENUM: t.cloneNode(id),
        NAME: memberName,
        VALUE: memberValue
      });
    });
    return buildEnumWrapper({
      ID: t.cloneNode(id),
      ASSIGNMENTS: assignments
    });
  }

  function translateEnumValues(path, t) {
    var seen = Object.create(null);
    var prev = -1;
    return path.node.members.map(function (member) {
      var name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
      var initializer = member.initializer;
      var value;

      if (initializer) {
        var constValue = evaluate$1(initializer, seen);

        if (constValue !== undefined) {
          seen[name] = constValue;

          if (typeof constValue === "number") {
            value = t.numericLiteral(constValue);
            prev = constValue;
          } else {
            assert__default['default'](typeof constValue === "string");
            value = t.stringLiteral(constValue);
            prev = undefined;
          }
        } else {
          value = initializer;
          prev = undefined;
        }
      } else {
        if (prev !== undefined) {
          prev++;
          value = t.numericLiteral(prev);
          seen[name] = prev;
        } else {
          throw path.buildCodeFrameError("Enum member must have initializer.");
        }
      }

      return [name, value];
    });
  }

  function evaluate$1(expr, seen) {
    return evalConstant(expr);

    function evalConstant(expr) {
      switch (expr.type) {
        case "StringLiteral":
          return expr.value;

        case "UnaryExpression":
          return evalUnaryExpression(expr);

        case "BinaryExpression":
          return evalBinaryExpression(expr);

        case "NumericLiteral":
          return expr.value;

        case "ParenthesizedExpression":
          return evalConstant(expr.expression);

        case "Identifier":
          return seen[expr.name];

        case "TemplateLiteral":
          if (expr.quasis.length === 1) {
            return expr.quasis[0].value.cooked;
          }

        default:
          return undefined;
      }
    }

    function evalUnaryExpression(_ref2) {
      var argument = _ref2.argument,
          operator = _ref2.operator;
      var value = evalConstant(argument);

      if (value === undefined) {
        return undefined;
      }

      switch (operator) {
        case "+":
          return value;

        case "-":
          return -value;

        case "~":
          return ~value;

        default:
          return undefined;
      }
    }

    function evalBinaryExpression(expr) {
      var left = evalConstant(expr.left);

      if (left === undefined) {
        return undefined;
      }

      var right = evalConstant(expr.right);

      if (right === undefined) {
        return undefined;
      }

      switch (expr.operator) {
        case "|":
          return left | right;

        case "&":
          return left & right;

        case ">>":
          return left >> right;

        case ">>>":
          return left >>> right;

        case "<<":
          return left << right;

        case "^":
          return left ^ right;

        case "*":
          return left * right;

        case "/":
          return left / right;

        case "+":
          return left + right;

        case "-":
          return left - right;

        case "%":
          return left % right;

        default:
          return undefined;
      }
    }
  }

  function _templateObject2$6() {
    var data = _taggedTemplateLiteralLoose(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "]);

    _templateObject2$6 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject$g() {
    var data = _taggedTemplateLiteralLoose(["\n      ", " ||\n        (", " = ", ")\n    "]);

    _templateObject$g = function _templateObject() {
      return data;
    };

    return data;
  }
  function transpileNamespace(path, t, allowNamespaces) {
    if (path.node.declare || path.node.id.type === "StringLiteral") {
      path.remove();
      return;
    }

    if (!allowNamespaces) {
      throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }

    var name = path.node.id.name;
    var value = handleNested(path, t, t.cloneDeep(path.node));
    var bound = path.scope.hasOwnBinding(name);

    if (path.parent.type === "ExportNamedDeclaration") {
      if (!bound) {
        path.parentPath.insertAfter(value);
        path.replaceWith(getDeclaration(t, name));
        path.scope.registerDeclaration(path.parentPath);
      } else {
        path.parentPath.replaceWith(value);
      }
    } else if (bound) {
      path.replaceWith(value);
    } else {
      path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
    }
  }

  function getDeclaration(t, name) {
    return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
  }

  function getMemberExpression(t, name, itemName) {
    return t.memberExpression(t.identifier(name), t.identifier(itemName));
  }

  function handleNested(path, t, node, parentExport) {
    var names = new Set();
    var realName = node.id;
    var name = path.scope.generateUid(realName.name);
    var namespaceTopLevel = node.body.body;

    for (var i = 0; i < namespaceTopLevel.length; i++) {
      var subNode = namespaceTopLevel[i];

      switch (subNode.type) {
        case "TSModuleDeclaration":
          {
            var transformed = handleNested(path, t, subNode);
            var moduleName = subNode.id.name;

            if (names.has(moduleName)) {
              namespaceTopLevel[i] = transformed;
            } else {
              names.add(moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
            }

            continue;
          }

        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          names.add(subNode.id.name);
          continue;

        case "VariableDeclaration":
          for (var _iterator = _createForOfIteratorHelperLoose(subNode.declarations), _step; !(_step = _iterator()).done;) {
            var variable = _step.value;
            names.add(variable.id.name);
          }

          continue;

        default:
          continue;

        case "ExportNamedDeclaration":
      }

      switch (subNode.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          {
            var itemName = subNode.declaration.id.name;
            names.add(itemName);
            namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
            break;
          }

        case "VariableDeclaration":
          if (subNode.declaration.kind !== "const") {
            throw path.hub.file.buildCodeFrameError(subNode.declaration, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(subNode.declaration.declarations), _step2; !(_step2 = _iterator2()).done;) {
            var _variable = _step2.value;
            _variable.init = t.assignmentExpression("=", getMemberExpression(t, name, _variable.id.name), _variable.init);
          }

          namespaceTopLevel[i] = subNode.declaration;
          break;

        case "TSModuleDeclaration":
          {
            var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

            var _moduleName = subNode.declaration.id.name;

            if (names.has(_moduleName)) {
              namespaceTopLevel[i] = _transformed;
            } else {
              names.add(_moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
            }
          }
      }
    }

    var fallthroughValue = t.objectExpression([]);

    if (parentExport) {
      var memberExpr = t.memberExpression(parentExport, realName);
      fallthroughValue = template.expression.ast(_templateObject$g(), t.cloneNode(memberExpr), t.cloneNode(memberExpr), fallthroughValue);
    }

    return template.statement.ast(_templateObject2$6(), t.identifier(name), namespaceTopLevel, realName, t.cloneNode(realName), fallthroughValue);
  }

  function _templateObject$h() {
    var data = _taggedTemplateLiteralLoose(["\n              this.", " = ", ""]);

    _templateObject$h = function _templateObject() {
      return data;
    };

    return data;
  }

  function isInType(path) {
    switch (path.parent.type) {
      case "TSTypeReference":
      case "TSQualifiedName":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;

      case "ExportSpecifier":
        return path.parentPath.parent.exportKind === "type";

      default:
        return false;
    }
  }

  var PARSED_PARAMS = new WeakSet();
  var GLOBAL_TYPES = new WeakMap();

  function isGlobalType(path, name) {
    var program = path.find(function (path) {
      return path.isProgram();
    }).node;
    if (path.scope.hasOwnBinding(name)) return false;
    if (GLOBAL_TYPES.get(program).has(name)) return true;
    console.warn("The exported identifier \"" + name + "\" is not declared in Babel's scope tracker\n" + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + ("\"" + name + "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
    return false;
  }

  function registerGlobalType(programScope, name) {
    GLOBAL_TYPES.get(programScope.path.node).add(name);
  }

  var transformTypeScript = declare(function (api, opts) {
    api.assertVersion(7);
    var JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
    var _opts$jsxPragma = opts.jsxPragma,
        jsxPragma = _opts$jsxPragma === void 0 ? "React.createElement" : _opts$jsxPragma,
        _opts$jsxPragmaFrag = opts.jsxPragmaFrag,
        jsxPragmaFrag = _opts$jsxPragmaFrag === void 0 ? "React.Fragment" : _opts$jsxPragmaFrag,
        _opts$allowNamespaces = opts.allowNamespaces,
        allowNamespaces = _opts$allowNamespaces === void 0 ? false : _opts$allowNamespaces,
        _opts$onlyRemoveTypeI = opts.onlyRemoveTypeImports,
        onlyRemoveTypeImports = _opts$onlyRemoveTypeI === void 0 ? false : _opts$onlyRemoveTypeI;

    if (!process.env.BABEL_8_BREAKING) {
      var _opts$allowDeclareFie = opts.allowDeclareFields,
          allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
    }

    var classMemberVisitors = {
      field: function field(path) {
        var node = path.node;

        if (!process.env.BABEL_8_BREAKING) {
          if (!allowDeclareFields && node.declare) {
            throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
          }
        }

        if (node.declare) {
          if (node.value) {
            throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          }

          if (!node.decorators) {
            path.remove();
          }
        } else if (node.definite) {
          if (node.value) {
            throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          }

          if (!process.env.BABEL_8_BREAKING) {
            if (!allowDeclareFields && !node.decorators) {
              path.remove();
            }
          }
        } else if (!process.env.BABEL_8_BREAKING) {
          if (!allowDeclareFields && !node.value && !node.decorators && !isClassPrivateProperty(node)) {
            path.remove();
          }
        }

        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.readonly) node.readonly = null;
        if (node.optional) node.optional = null;
        if (node.typeAnnotation) node.typeAnnotation = null;
        if (node.definite) node.definite = null;
        if (node.declare) node.declare = null;
      },
      method: function method(_ref) {
        var node = _ref.node;
        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.optional) node.optional = null;
      },
      constructor: function constructor(path, classPath) {
        if (path.node.accessibility) path.node.accessibility = null;
        var parameterProperties = [];

        for (var _iterator = _createForOfIteratorHelperLoose(path.node.params), _step; !(_step = _iterator()).done;) {
          var param = _step.value;

          if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
            PARSED_PARAMS.add(param.parameter);
            parameterProperties.push(param.parameter);
          }
        }

        if (parameterProperties.length) {
          var assigns = parameterProperties.map(function (p) {
            var id;

            if (isIdentifier(p)) {
              id = p;
            } else if (isAssignmentPattern(p) && isIdentifier(p.left)) {
              id = p.left;
            } else {
              throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            }

            return template.statement.ast(_templateObject$h(), cloneNode(id), cloneNode(id));
          });
          injectInitialization(classPath, path, assigns);
        }
      }
    };
    return {
      name: "transform-typescript",
      inherits: syntaxTypescript,
      visitor: {
        Pattern: visitPattern,
        Identifier: visitPattern,
        RestElement: visitPattern,
        Program: function Program(path, state) {
          var file = state.file;
          var fileJsxPragma = null;
          var fileJsxPragmaFrag = null;

          if (!GLOBAL_TYPES.has(path.node)) {
            GLOBAL_TYPES.set(path.node, new Set());
          }

          if (file.ast.comments) {
            for (var _i = 0, _arr = file.ast.comments; _i < _arr.length; _i++) {
              var comment = _arr[_i];
              var jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);

              if (jsxMatches) {
                if (jsxMatches[1]) {
                  fileJsxPragmaFrag = jsxMatches[2];
                } else {
                  fileJsxPragma = jsxMatches[2];
                }
              }
            }
          }

          var pragmaImportName = fileJsxPragma || jsxPragma;

          if (pragmaImportName) {
            var _pragmaImportName$spl = pragmaImportName.split(".");

            pragmaImportName = _pragmaImportName$spl[0];
          }

          var pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;

          if (pragmaFragImportName) {
            var _pragmaFragImportName = pragmaFragImportName.split(".");

            pragmaFragImportName = _pragmaFragImportName[0];
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("body")), _step2; !(_step2 = _iterator2()).done;) {
            var stmt = _step2.value;

            if (isImportDeclaration(stmt)) {
              if (stmt.node.importKind === "type") {
                stmt.remove();
                continue;
              }

              if (!onlyRemoveTypeImports) {
                if (stmt.node.specifiers.length === 0) {
                  continue;
                }

                var allElided = true;
                var importsToRemove = [];

                for (var _iterator3 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step3; !(_step3 = _iterator3()).done;) {
                  var specifier = _step3.value;
                  var binding = stmt.scope.getBinding(specifier.local.name);

                  if (binding && isImportTypeOnly({
                    binding: binding,
                    programPath: path,
                    pragmaImportName: pragmaImportName,
                    pragmaFragImportName: pragmaFragImportName
                  })) {
                    importsToRemove.push(binding.path);
                  } else {
                    allElided = false;
                  }
                }

                if (allElided) {
                  stmt.remove();
                } else {
                  for (var _iterator4 = _createForOfIteratorHelperLoose(importsToRemove), _step4; !(_step4 = _iterator4()).done;) {
                    var importPath = _step4.value;
                    importPath.remove();
                  }
                }
              }

              continue;
            }

            if (stmt.isExportDeclaration()) {
              stmt = stmt.get("declaration");
            }

            if (stmt.isVariableDeclaration({
              declare: true
            })) {
              for (var _i2 = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                var name = _Object$keys[_i2];
                registerGlobalType(path.scope, name);
              }
            } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
              declare: true
            }) || stmt.isTSEnumDeclaration({
              declare: true
            }) || stmt.isTSModuleDeclaration({
              declare: true
            }) && stmt.get("id").isIdentifier()) {
              registerGlobalType(path.scope, stmt.node.id.name);
            }
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          if (path.node.exportKind === "type") {
            path.remove();
            return;
          }

          if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (_ref2) {
            var local = _ref2.local;
            return isGlobalType(path, local.name);
          })) {
            path.remove();
          }
        },
        ExportSpecifier: function ExportSpecifier(path) {
          if (!path.parent.source && isGlobalType(path, path.node.local.name)) {
            path.remove();
          }
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
            path.remove();
          }
        },
        TSDeclareFunction: function TSDeclareFunction(path) {
          path.remove();
        },
        TSDeclareMethod: function TSDeclareMethod(path) {
          path.remove();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          if (path.node.declare) {
            path.remove();
          }
        },
        VariableDeclarator: function VariableDeclarator(_ref3) {
          var node = _ref3.node;
          if (node.definite) node.definite = null;
        },
        TSIndexSignature: function TSIndexSignature(path) {
          path.remove();
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;

          if (node.declare) {
            path.remove();
            return;
          }
        },
        Class: function Class(path) {
          var node = path.node;
          if (node.typeParameters) node.typeParameters = null;
          if (node.superTypeParameters) node.superTypeParameters = null;
          if (node["implements"]) node["implements"] = null;
          if (node["abstract"]) node["abstract"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassMethod() || child.isClassPrivateMethod()) {
              if (child.node.kind === "constructor") {
                classMemberVisitors.constructor(child, path);
              } else {
                classMemberVisitors.method(child, path);
              }
            } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
              classMemberVisitors.field(child, path);
            }
          });
        },
        Function: function Function(_ref4) {
          var node = _ref4.node;
          if (node.typeParameters) node.typeParameters = null;
          if (node.returnType) node.returnType = null;
          var p0 = node.params[0];

          if (p0 && isIdentifier(p0) && p0.name === "this") {
            node.params.shift();
          }

          node.params = node.params.map(function (p) {
            return p.type === "TSParameterProperty" ? p.parameter : p;
          });
        },
        TSModuleDeclaration: function TSModuleDeclaration(path) {
          transpileNamespace(path, t, allowNamespaces);
        },
        TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
          path.remove();
        },
        TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
          path.remove();
        },
        TSEnumDeclaration: function TSEnumDeclaration(path) {
          transpileEnum(path, t);
        },
        TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
          throw path.buildCodeFrameError("`import =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + "`import <moduleName> from '<moduleName>';` alongside " + "Typescript's --allowSyntheticDefaultImports option.");
        },
        TSExportAssignment: function TSExportAssignment(path) {
          throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
        },
        TSTypeAssertion: function TSTypeAssertion(path) {
          path.replaceWith(path.node.expression);
        },
        TSAsExpression: function TSAsExpression(path) {
          var node = path.node;

          do {
            node = node.expression;
          } while (isTSAsExpression(node));

          path.replaceWith(node);
        },
        TSNonNullExpression: function TSNonNullExpression(path) {
          path.replaceWith(path.node.expression);
        },
        CallExpression: function CallExpression(path) {
          path.node.typeParameters = null;
        },
        OptionalCallExpression: function OptionalCallExpression(path) {
          path.node.typeParameters = null;
        },
        NewExpression: function NewExpression(path) {
          path.node.typeParameters = null;
        },
        JSXOpeningElement: function JSXOpeningElement(path) {
          path.node.typeParameters = null;
        },
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          path.node.typeParameters = null;
        }
      }
    };

    function visitPattern(_ref5) {
      var node = _ref5.node;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (isIdentifier(node) && node.optional) node.optional = null;
    }

    function isImportTypeOnly(_ref6) {
      var binding = _ref6.binding,
          programPath = _ref6.programPath,
          pragmaImportName = _ref6.pragmaImportName,
          pragmaFragImportName = _ref6.pragmaFragImportName;

      for (var _iterator5 = _createForOfIteratorHelperLoose(binding.referencePaths), _step5; !(_step5 = _iterator5()).done;) {
        var path = _step5.value;

        if (!isInType(path)) {
          return false;
        }
      }

      if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
        return true;
      }

      var sourceFileHasJsx = false;
      programPath.traverse({
        "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
          sourceFileHasJsx = true;
          path.stop();
        }
      });
      return !sourceFileHasJsx;
    }
  });

  var transformUnicodeEscapes = declare(function (api) {
    api.assertVersion(7);
    var surrogate = /[\ud800-\udfff]/g;
    var unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;

    function escape(code) {
      var str = code.toString(16);

      while (str.length < 4) {
        str = "0" + str;
      }

      return "\\u" + str;
    }

    function replacer(match, backslashes, code) {
      if (backslashes.length % 2 === 0) {
        return match;
      }

      var _char = String.fromCodePoint(parseInt(code, 16));

      var escaped = backslashes.slice(0, -1) + escape(_char.charCodeAt(0));
      return _char.length === 1 ? escaped : escaped + escape(_char.charCodeAt(1));
    }

    function replaceUnicodeEscapes(str) {
      return str.replace(unicodeEscape, replacer);
    }

    function getUnicodeEscape(str) {
      var match;

      while (match = unicodeEscape.exec(str)) {
        if (match[1].length % 2 === 0) continue;
        unicodeEscape.lastIndex = 0;
        return match[0];
      }

      return null;
    }

    return {
      name: "transform-unicode-escapes",
      visitor: {
        Identifier: function Identifier(path) {
          var node = path.node,
              key = path.key;
          var name = node.name;
          var replaced = name.replace(surrogate, function (c) {
            return "_u" + c.charCodeAt(0).toString(16);
          });
          if (name === replaced) return;
          var str = inherits(stringLiteral(name), node);

          if (key === "key") {
            path.replaceWith(str);
            return;
          }

          var parentPath = path.parentPath,
              scope = path.scope;

          if (parentPath.isMemberExpression({
            property: node
          }) || parentPath.isOptionalMemberExpression({
            property: node
          })) {
            parentPath.node.computed = true;
            path.replaceWith(str);
            return;
          }

          var binding = scope.getBinding(name);

          if (binding) {
            scope.rename(name, scope.generateUid(replaced));
            return;
          }

          throw path.buildCodeFrameError("Can't reference '" + name + "' as a bare identifier");
        },
        "StringLiteral|DirectiveLiteral": function StringLiteralDirectiveLiteral(path) {
          var node = path.node;
          var extra = node.extra;
          if (extra == null ? void 0 : extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
        },
        TemplateElement: function TemplateElement(path) {
          var node = path.node,
              parentPath = path.parentPath;
          var value = node.value;
          var firstEscape = getUnicodeEscape(value.raw);
          if (!firstEscape) return;
          var grandParent = parentPath.parentPath;

          if (grandParent.isTaggedTemplateExpression()) {
            throw path.buildCodeFrameError("Can't replace Unicode escape '" + firstEscape + "' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.");
          }

          value.raw = replaceUnicodeEscapes(value.raw);
        }
      }
    };
  });

  var transformUnicodeRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-unicode-regex",
      feature: "unicodeFlag"
    });
  });

  var all = {
    "external-helpers": externalHelpers,
    "syntax-async-generators": syntaxAsyncGenerators,
    "syntax-class-properties": syntaxClassProperties,
    "syntax-class-static-block": syntaxClassStaticBlock,
    "syntax-decimal": syntaxDecimal,
    "syntax-decorators": syntaxDecorators,
    "syntax-do-expressions": syntaxDoExpressions,
    "syntax-export-default-from": syntaxExportDefaultFrom,
    "syntax-flow": syntaxFlow,
    "syntax-function-bind": syntaxFunctionBind,
    "syntax-function-sent": syntaxFunctionSent,
    "syntax-import-meta": syntaxImportMeta,
    "syntax-jsx": syntaxJsx,
    "syntax-import-assertions": syntaxImportAssertions,
    "syntax-object-rest-spread": syntaxObjectRestSpread,
    "syntax-optional-catch-binding": syntaxOptionalCatchBinding,
    "syntax-pipeline-operator": syntaxPipelineOperator,
    "syntax-record-and-tuple": syntaxRecordAndTuple,
    "syntax-top-level-await": syntaxTopLevelAwait,
    "syntax-typescript": syntaxTypescript,
    "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
    "proposal-class-properties": proposalClassProperties,
    "proposal-class-static-block": proposalClassStaticBlock,
    "proposal-decorators": proposalDecorators,
    "proposal-do-expressions": proposalDoExpressions,
    "proposal-dynamic-import": proposalDynamicImport,
    "proposal-export-default-from": proposalExportDefaultFrom,
    "proposal-export-namespace-from": proposalExportNamespaceFrom,
    "proposal-function-bind": proposalFunctionBind,
    "proposal-function-sent": proposalFunctionSent,
    "proposal-json-strings": proposalJsonStrings,
    "proposal-logical-assignment-operators": proposalLogicalAssignmentOperators,
    "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
    "proposal-numeric-separator": proposalNumericSeparator,
    "proposal-object-rest-spread": proposalObjectRestSpread,
    "proposal-optional-catch-binding": proposalOptionalCatchBinding,
    "proposal-optional-chaining": proposalOptionalChaining,
    "proposal-pipeline-operator": proposalPipelineOperator,
    "proposal-private-methods": proposalPrivateMethods,
    "proposal-private-property-in-object": proposalPrivatePropertyInObject,
    "proposal-throw-expressions": proposalThrowExpressions,
    "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
    "transform-async-to-generator": transformAsyncToGenerator,
    "transform-arrow-functions": transformArrowFunctions,
    "transform-block-scoped-functions": transformBlockScopedFunctions,
    "transform-block-scoping": transformBlockScoping,
    "transform-classes": transformClasses,
    "transform-computed-properties": transformComputedProperties,
    "transform-destructuring": transformDestructuring,
    "transform-dotall-regex": transformDotallRegex,
    "transform-duplicate-keys": transformDuplicateKeys,
    "transform-exponentiation-operator": transformExponentialOperator,
    "transform-flow-comments": transformFlowComments,
    "transform-flow-strip-types": transformFlowStripTypes,
    "transform-for-of": transformForOf,
    "transform-function-name": transformFunctionName,
    "transform-instanceof": transformInstanceof,
    "transform-jscript": transformJscript,
    "transform-literals": transformLiterals,
    "transform-member-expression-literals": transformMemberExpressionLiterals,
    "transform-modules-amd": transformModulesAmd,
    "transform-modules-commonjs": transformModulesCommonjs,
    "transform-modules-systemjs": transformModulesSystemjs,
    "transform-modules-umd": transformModulesUmd,
    "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
    "transform-new-target": transformNewTarget,
    "transform-object-assign": transformObjectAssign,
    "transform-object-super": transformObjectSuper,
    "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
    "transform-parameters": transformParameters,
    "transform-property-literals": transformPropertyLiterals,
    "transform-property-mutators": transformPropertyMutators,
    "transform-proto-to-assign": transformProtoToAssign,
    "transform-react-constant-elements": transformReactConstantElements,
    "transform-react-display-name": transformReactDisplayName,
    "transform-react-inline-elements": transformReactInlineElements,
    "transform-react-jsx": transformReactJSX,
    "transform-react-jsx-compat": transformReactJsxCompat,
    "transform-react-jsx-development": transformReactJSXDevelopment,
    "transform-react-jsx-self": transformReactJsxSelf,
    "transform-react-jsx-source": transformReactJsxSource,
    "transform-regenerator": transformRegenerator,
    "transform-reserved-words": transformReservedWords,
    "transform-runtime": transformRuntime,
    "transform-shorthand-properties": transformShorthandProperties,
    "transform-spread": transformSpread,
    "transform-sticky-regex": transformStickyRegex,
    "transform-strict-mode": transformStrictMode,
    "transform-template-literals": transformTemplateLiterals,
    "transform-typeof-symbol": transformTypeofSymbol,
    "transform-typescript": transformTypeScript,
    "transform-unicode-escapes": transformUnicodeEscapes,
    "transform-unicode-regex": transformUnicodeRegex
  };

  var preset2015 = (function (_, opts) {
    var loose = false;
    var modules = "commonjs";
    var spec = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
      if (opts.modules !== undefined) modules = opts.modules;
      if (opts.spec !== undefined) spec = opts.spec;
    }

    var optsLoose = {
      loose: loose
    };
    return {
      plugins: [[transformTemplateLiterals, {
        loose: loose,
        spec: spec
      }], transformLiterals, transformFunctionName, [transformArrowFunctions, {
        spec: spec
      }], transformBlockScopedFunctions, [transformClasses, optsLoose], transformObjectSuper, transformShorthandProperties, transformDuplicateKeys, [transformComputedProperties, optsLoose], [transformForOf, optsLoose], transformStickyRegex, transformUnicodeEscapes, transformUnicodeRegex, [transformSpread, optsLoose], [transformParameters, optsLoose], [transformDestructuring, optsLoose], transformBlockScoping, transformTypeofSymbol, transformInstanceof, (modules === "commonjs" || modules === "cjs") && [transformModulesCommonjs, optsLoose], modules === "systemjs" && [transformModulesSystemjs, optsLoose], modules === "amd" && [transformModulesAmd, optsLoose], modules === "umd" && [transformModulesUmd, optsLoose], [transformRegenerator, {
        async: false,
        asyncGenerators: false
      }]].filter(Boolean)
    };
  });

  var presetStage3 = (function (_, opts) {
    var loose = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
    }

    return {
      plugins: [syntaxImportAssertions, syntaxImportMeta, syntaxTopLevelAwait, proposalExportNamespaceFrom, proposalLogicalAssignmentOperators, [proposalOptionalChaining, {
        loose: loose
      }], [proposalNullishCoalescingOperator, {
        loose: loose
      }], [proposalClassProperties, {
        loose: loose
      }], proposalJsonStrings, proposalNumericSeparator, [proposalPrivateMethods, {
        loose: loose
      }]]
    };
  });

  var presetStage2 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport;
    return {
      presets: [[presetStage3, {
        loose: loose,
        useBuiltIns: useBuiltIns
      }]],
      plugins: [proposalClassStaticBlock, [proposalDecorators, {
        legacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }], proposalFunctionSent, proposalPrivatePropertyInObject, proposalThrowExpressions]
    };
  });

  var presetStage1 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
        _opts$recordAndTupleS = _opts.recordAndTupleSyntax,
        recordAndTupleSyntax = _opts$recordAndTupleS === void 0 ? "hash" : _opts$recordAndTupleS;
    return {
      presets: [[presetStage2, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }]],
      plugins: [syntaxDecimal, [syntaxRecordAndTuple, {
        syntaxType: recordAndTupleSyntax
      }], proposalExportDefaultFrom, [proposalPipelineOperator, {
        proposal: pipelineProposal
      }], proposalDoExpressions]
    };
  });

  var presetStage0 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
        _opts$importAssertion = _opts.importAssertionsVersion,
        importAssertionsVersion = _opts$importAssertion === void 0 ? "september-2020" : _opts$importAssertion;
    return {
      presets: [[presetStage1, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport,
        pipelineProposal: pipelineProposal,
        importAssertionsVersion: importAssertionsVersion
      }]],
      plugins: [proposalFunctionBind]
    };
  });

  var semver$2 = createCommonjsModule(function (module, exports) {
  exports = module.exports = SemVer;
  var debug;

  if (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function debug() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };
  } else {
    debug = function debug() {};
  }

  exports.SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports.re = [];
  var src = exports.src = [];
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
  var MAINVERSION = R++;
  src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\.' + '(' + src[NUMERICIDENTIFIER] + ')';
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASE = R++;
  src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
  var BUILD = R++;
  src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
  var FULL = R++;
  var FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
  src[FULL] = '^' + FULLPLAIN + '$';
  var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';
  var LOOSE = R++;
  src[LOOSE] = '^' + LOOSEPLAIN + '$';
  var GTLT = R++;
  src[GTLT] = '((?:<|>)?=?)';
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';
  var XRANGE = R++;
  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
  var COERCE = R++;
  src[COERCE] = '(?:^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
  var LONETILDE = R++;
  src[LONETILDE] = '(?:~>?)';
  var TILDETRIM = R++;
  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
  var tildeTrimReplace = '$1~';
  var TILDE = R++;
  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
  var TILDELOOSE = R++;
  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
  var LONECARET = R++;
  src[LONECARET] = '(?:\\^)';
  var CARETTRIM = R++;
  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
  var caretTrimReplace = '$1^';
  var CARET = R++;
  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
  var CARETLOOSE = R++;
  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
  var COMPARATOR = R++;
  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
  var comparatorTrimReplace = '$1$2$3';
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\s*$';
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\s*$';
  var STAR = R++;
  src[STAR] = '(<|>)?=?\\s*\\*';

  for (var i = 0; i < R; i++) {
    debug(i, src[i]);

    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }

  exports.parse = parse;

  function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH) {
      return null;
    }

    var r = options.loose ? re[LOOSE] : re[FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }

  exports.valid = valid;

  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }

  exports.clean = clean;

  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  }

  exports.SemVer = SemVer;

  function SemVer(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version);
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
    }

    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

    if (!m) {
      throw new TypeError('Invalid Version: ' + version);
    }

    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }

    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch;

    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.');
    }

    return this.version;
  };

  SemVer.prototype.toString = function () {
    return this.version;
  };

  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return this.compareMain(other) || this.comparePre(other);
  };

  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };

  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    var i = 0;

    do {
      var a = this.prerelease[i];
      var b = other.prerelease[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  };

  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;

      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;

      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error('invalid increment argument: ' + release);
    }

    this.format();
    this.raw = this.version;
    return this;
  };

  exports.inc = inc;

  function inc(version, release, loose, identifier) {
    if (typeof loose === 'string') {
      identifier = loose;
      loose = undefined;
    }

    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }

  exports.diff = diff;

  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = '';

      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre';
        var defaultResult = 'prerelease';
      }

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  }

  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;

  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }

  exports.rcompareIdentifiers = rcompareIdentifiers;

  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }

  exports.major = major;

  function major(a, loose) {
    return new SemVer(a, loose).major;
  }

  exports.minor = minor;

  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }

  exports.patch = patch;

  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }

  exports.compare = compare;

  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }

  exports.compareLoose = compareLoose;

  function compareLoose(a, b) {
    return compare(a, b, true);
  }

  exports.rcompare = rcompare;

  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }

  exports.sort = sort;

  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports.compare(a, b, loose);
    });
  }

  exports.rsort = rsort;

  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports.rcompare(a, b, loose);
    });
  }

  exports.gt = gt;

  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }

  exports.lt = lt;

  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }

  exports.eq = eq;

  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }

  exports.neq = neq;

  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }

  exports.gte = gte;

  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }

  exports.lte = lte;

  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }

  exports.cmp = cmp;

  function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq(a, b, loose);

      case '!=':
        return neq(a, b, loose);

      case '>':
        return gt(a, b, loose);

      case '>=':
        return gte(a, b, loose);

      case '<':
        return lt(a, b, loose);

      case '<=':
        return lte(a, b, loose);

      default:
        throw new TypeError('Invalid operator: ' + op);
    }
  }

  exports.Comparator = Comparator;

  function Comparator(comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }

    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }

    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug('comp', this);
  }

  var ANY = {};

  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);

    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp);
    }

    this.operator = m[1];

    if (this.operator === '=') {
      this.operator = '';
    }

    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };

  Comparator.prototype.toString = function () {
    return this.value;
  };

  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose);

    if (this.semver === ANY) {
      return true;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    return cmp(version, this.operator, this.semver, this.options);
  };

  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required');
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    var rangeTmp;

    if (this.operator === '') {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === '') {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }

    var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
    var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
    var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
    var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };

  exports.Range = Range;

  function Range(range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }

    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }

    if (!(this instanceof Range)) {
      return new Range(range, options);
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function (range) {
      return this.parseRange(range.trim());
    }, this).filter(function (c) {
      return c.length;
    });

    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range);
    }

    this.format();
  }

  Range.prototype.format = function () {
    this.range = this.set.map(function (comps) {
      return comps.join(' ').trim();
    }).join('||').trim();
    return this.range;
  };

  Range.prototype.toString = function () {
    return this.range;
  };

  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug('hyphen replace', range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug('comparator trim', range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(' ');
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range.split(' ').map(function (comp) {
      return parseComparator(comp, this.options);
    }, this).join(' ').split(/\s+/);

    if (this.options.loose) {
      set = set.filter(function (comp) {
        return !!comp.match(compRe);
      });
    }

    set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };

  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required');
    }

    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };

  exports.toComparators = toComparators;

  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  }

  function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  }

  function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  }

  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(' ');
  }

  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      }

      debug('tilde return', ret);
      return ret;
    });
  }

  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(' ');
  }

  function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
        }
      } else {
        debug('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
      }

      debug('caret return', ret);
      return ret;
    });
  }

  function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(' ');
  }

  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        ret = gtlt + M + '.' + m + '.' + p;
      } else if (xm) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      }

      debug('xRange return', ret);
      return ret;
    });
  }

  function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[STAR], '');
  }

  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0';
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0';
    } else {
      from = '>=' + from;
    }

    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0';
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0';
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
    } else {
      to = '<=' + to;
    }

    return (from + ' ' + to).trim();
  }

  Range.prototype.test = function (version) {
    if (!version) {
      return false;
    }

    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }

    for (var i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true;
      }
    }

    return false;
  };

  function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (i = 0; i < set.length; i++) {
        debug(set[i].semver);

        if (set[i].semver === ANY) {
          continue;
        }

        if (set[i].semver.prerelease.length > 0) {
          var allowed = set[i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  }

  exports.satisfies = satisfies;

  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  }

  exports.maxSatisfying = maxSatisfying;

  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }

  exports.minSatisfying = minSatisfying;

  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;

    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }

  exports.minVersion = minVersion;

  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new SemVer('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error('Unexpected operation: ' + comparator.operator);
        }
      });
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  }

  exports.validRange = validRange;

  function validRange(range, options) {
    try {
      return new Range(range, options).range || '*';
    } catch (er) {
      return null;
    }
  }

  exports.ltr = ltr;

  function ltr(version, range, options) {
    return outside(version, range, '<', options);
  }

  exports.gtr = gtr;

  function gtr(version, range, options) {
    return outside(version, range, '>', options);
  }

  exports.outside = outside;

  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies(version, range, options)) {
      return false;
    }

    for (var i = 0; i < range.set.length; ++i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }

    return true;
  }

  exports.prerelease = prerelease;

  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }

  exports.intersects = intersects;

  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }

  exports.coerce = coerce;

  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    var match = version.match(re[COERCE]);

    if (match == null) {
      return null;
    }

    return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
  }
  });

  var envs = [
  	{
  		name: "nodejs",
  		version: "0.2.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.3.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.4.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.5.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.6.0",
  		date: "2011-11-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.7.0",
  		date: "2012-01-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.8.0",
  		date: "2012-06-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.9.0",
  		date: "2012-07-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.10.0",
  		date: "2013-03-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.11.0",
  		date: "2013-03-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.12.0",
  		date: "2015-02-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "iojs",
  		version: "1.0.0",
  		date: "2015-01-14"
  	},
  	{
  		name: "iojs",
  		version: "1.1.0",
  		date: "2015-02-03"
  	},
  	{
  		name: "iojs",
  		version: "1.2.0",
  		date: "2015-02-11"
  	},
  	{
  		name: "iojs",
  		version: "1.3.0",
  		date: "2015-02-20"
  	},
  	{
  		name: "iojs",
  		version: "1.5.0",
  		date: "2015-03-06"
  	},
  	{
  		name: "iojs",
  		version: "1.6.0",
  		date: "2015-03-20"
  	},
  	{
  		name: "iojs",
  		version: "2.0.0",
  		date: "2015-05-04"
  	},
  	{
  		name: "iojs",
  		version: "2.1.0",
  		date: "2015-05-24"
  	},
  	{
  		name: "iojs",
  		version: "2.2.0",
  		date: "2015-06-01"
  	},
  	{
  		name: "iojs",
  		version: "2.3.0",
  		date: "2015-06-13"
  	},
  	{
  		name: "iojs",
  		version: "2.4.0",
  		date: "2015-07-17"
  	},
  	{
  		name: "iojs",
  		version: "2.5.0",
  		date: "2015-07-28"
  	},
  	{
  		name: "iojs",
  		version: "3.0.0",
  		date: "2015-08-04"
  	},
  	{
  		name: "iojs",
  		version: "3.1.0",
  		date: "2015-08-19"
  	},
  	{
  		name: "iojs",
  		version: "3.2.0",
  		date: "2015-08-25"
  	},
  	{
  		name: "iojs",
  		version: "3.3.0",
  		date: "2015-09-02"
  	},
  	{
  		name: "nodejs",
  		version: "4.0.0",
  		date: "2015-09-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.1.0",
  		date: "2015-09-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.2.0",
  		date: "2015-10-12",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.3.0",
  		date: "2016-02-09",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.4.0",
  		date: "2016-03-08",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.5.0",
  		date: "2016-08-16",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.6.0",
  		date: "2016-09-27",
  		lts: "Argon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "4.7.0",
  		date: "2016-12-06",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.8.0",
  		date: "2017-02-21",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.9.0",
  		date: "2018-03-28",
  		lts: "Argon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "5.0.0",
  		date: "2015-10-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.1.0",
  		date: "2015-11-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.2.0",
  		date: "2015-12-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.3.0",
  		date: "2015-12-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.4.0",
  		date: "2016-01-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.5.0",
  		date: "2016-01-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.6.0",
  		date: "2016-02-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.7.0",
  		date: "2016-02-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.8.0",
  		date: "2016-03-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.9.0",
  		date: "2016-03-16",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.10.0",
  		date: "2016-04-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.11.0",
  		date: "2016-04-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.12.0",
  		date: "2016-06-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.0.0",
  		date: "2016-04-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.1.0",
  		date: "2016-05-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.2.0",
  		date: "2016-05-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.3.0",
  		date: "2016-07-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.4.0",
  		date: "2016-08-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.5.0",
  		date: "2016-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.6.0",
  		date: "2016-09-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.7.0",
  		date: "2016-09-27",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.8.0",
  		date: "2016-10-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.9.0",
  		date: "2016-10-18",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.10.0",
  		date: "2017-02-21",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.11.0",
  		date: "2017-06-06",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.12.0",
  		date: "2017-11-06",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.13.0",
  		date: "2018-02-10",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.14.0",
  		date: "2018-03-28",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.15.0",
  		date: "2018-11-27",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.16.0",
  		date: "2018-12-26",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.17.0",
  		date: "2019-02-28",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "7.0.0",
  		date: "2016-10-25",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.1.0",
  		date: "2016-11-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.2.0",
  		date: "2016-11-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.3.0",
  		date: "2016-12-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.4.0",
  		date: "2017-01-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.5.0",
  		date: "2017-01-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.6.0",
  		date: "2017-02-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.7.0",
  		date: "2017-02-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.8.0",
  		date: "2017-03-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.9.0",
  		date: "2017-04-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.10.0",
  		date: "2017-05-02",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.0.0",
  		date: "2017-05-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.1.0",
  		date: "2017-06-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.2.0",
  		date: "2017-07-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.3.0",
  		date: "2017-08-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.4.0",
  		date: "2017-08-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.5.0",
  		date: "2017-09-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.6.0",
  		date: "2017-09-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.7.0",
  		date: "2017-10-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.8.0",
  		date: "2017-10-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.9.0",
  		date: "2017-10-31",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.10.0",
  		date: "2018-03-06",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.11.0",
  		date: "2018-03-28",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "8.12.0",
  		date: "2018-09-10",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.13.0",
  		date: "2018-11-20",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.14.0",
  		date: "2018-11-27",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "8.15.0",
  		date: "2018-12-26",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.16.0",
  		date: "2019-04-16",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.17.0",
  		date: "2019-12-17",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "9.0.0",
  		date: "2017-10-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.1.0",
  		date: "2017-11-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.2.0",
  		date: "2017-11-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.3.0",
  		date: "2017-12-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.4.0",
  		date: "2018-01-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.5.0",
  		date: "2018-01-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.6.0",
  		date: "2018-02-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.7.0",
  		date: "2018-03-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.8.0",
  		date: "2018-03-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.9.0",
  		date: "2018-03-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.10.0",
  		date: "2018-03-28",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "9.11.0",
  		date: "2018-04-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.0.0",
  		date: "2018-04-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.1.0",
  		date: "2018-05-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.2.0",
  		date: "2018-05-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.3.0",
  		date: "2018-05-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.4.0",
  		date: "2018-06-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.5.0",
  		date: "2018-06-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.6.0",
  		date: "2018-07-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.7.0",
  		date: "2018-07-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.8.0",
  		date: "2018-08-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.9.0",
  		date: "2018-08-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.10.0",
  		date: "2018-09-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.11.0",
  		date: "2018-09-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.12.0",
  		date: "2018-10-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.13.0",
  		date: "2018-10-30",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.14.0",
  		date: "2018-11-27",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.15.0",
  		date: "2018-12-26",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.16.0",
  		date: "2019-05-28",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.17.0",
  		date: "2019-10-22",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.18.0",
  		date: "2019-12-17",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.19.0",
  		date: "2020-02-05",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.20.0",
  		date: "2020-03-26",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.21.0",
  		date: "2020-06-02",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.22.0",
  		date: "2020-07-21",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.0.0",
  		date: "2018-10-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.1.0",
  		date: "2018-10-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.2.0",
  		date: "2018-11-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.3.0",
  		date: "2018-11-27",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "11.4.0",
  		date: "2018-12-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.5.0",
  		date: "2018-12-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.6.0",
  		date: "2018-12-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.7.0",
  		date: "2019-01-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.8.0",
  		date: "2019-01-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.9.0",
  		date: "2019-01-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.10.0",
  		date: "2019-02-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.11.0",
  		date: "2019-03-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.12.0",
  		date: "2019-03-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.13.0",
  		date: "2019-03-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.14.0",
  		date: "2019-04-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.15.0",
  		date: "2019-04-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.0.0",
  		date: "2019-04-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.1.0",
  		date: "2019-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.2.0",
  		date: "2019-05-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.3.0",
  		date: "2019-05-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.4.0",
  		date: "2019-06-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.5.0",
  		date: "2019-06-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.6.0",
  		date: "2019-07-03",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.7.0",
  		date: "2019-07-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.8.0",
  		date: "2019-08-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.9.0",
  		date: "2019-08-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.10.0",
  		date: "2019-09-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.11.0",
  		date: "2019-09-25",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.12.0",
  		date: "2019-10-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.13.0",
  		date: "2019-10-21",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.14.0",
  		date: "2019-12-17",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.15.0",
  		date: "2020-02-05",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.16.0",
  		date: "2020-02-11",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.17.0",
  		date: "2020-05-26",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.18.0",
  		date: "2020-06-02",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.19.0",
  		date: "2020-10-06",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.0.0",
  		date: "2019-10-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.1.0",
  		date: "2019-11-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.2.0",
  		date: "2019-11-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.3.0",
  		date: "2019-12-03",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.4.0",
  		date: "2019-12-17",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "13.5.0",
  		date: "2019-12-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.6.0",
  		date: "2020-01-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.7.0",
  		date: "2020-01-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.8.0",
  		date: "2020-02-05",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "13.9.0",
  		date: "2020-02-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.10.0",
  		date: "2020-03-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.11.0",
  		date: "2020-03-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.12.0",
  		date: "2020-03-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.13.0",
  		date: "2020-04-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.14.0",
  		date: "2020-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.0.0",
  		date: "2020-04-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.1.0",
  		date: "2020-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.2.0",
  		date: "2020-05-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.3.0",
  		date: "2020-05-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.4.0",
  		date: "2020-06-02",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "14.5.0",
  		date: "2020-06-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.6.0",
  		date: "2020-07-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.7.0",
  		date: "2020-07-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.8.0",
  		date: "2020-08-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.9.0",
  		date: "2020-08-27",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.10.0",
  		date: "2020-09-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.11.0",
  		date: "2020-09-15",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "14.12.0",
  		date: "2020-09-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.13.0",
  		date: "2020-09-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.14.0",
  		date: "2020-10-15",
  		lts: false,
  		security: false
  	}
  ];

  var envs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': envs
  });

  var browsers = {
    A: "ie",
    B: "edge",
    C: "firefox",
    D: "chrome",
    E: "safari",
    F: "opera",
    G: "ios_saf",
    H: "op_mini",
    I: "android",
    J: "bb",
    K: "op_mob",
    L: "and_chr",
    M: "and_ff",
    N: "ie_mob",
    O: "and_uc",
    P: "samsung",
    Q: "and_qq",
    R: "baidu",
    S: "kaios"
  };

  var browsers_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var browsers$1 = exports.browsers = browsers;
  });

  var browserVersions = {
    "0": "46",
    "1": "47",
    "2": "48",
    "3": "49",
    "4": "50",
    "5": "51",
    "6": "52",
    "7": "53",
    "8": "54",
    "9": "55",
    A: "10",
    B: "11",
    C: "12",
    D: "14",
    E: "9",
    F: "7",
    G: "4",
    H: "8",
    I: "15",
    J: "16",
    K: "17",
    L: "18",
    M: "81",
    N: "13",
    O: "6",
    P: "80",
    Q: "12.1",
    R: "83",
    S: "84",
    T: "11.1",
    U: "86",
    V: "72",
    W: "71",
    X: "66",
    Y: "5",
    Z: "19",
    a: "20",
    b: "21",
    c: "22",
    d: "23",
    e: "24",
    f: "25",
    g: "26",
    h: "27",
    i: "28",
    j: "29",
    k: "30",
    l: "31",
    m: "32",
    n: "33",
    o: "34",
    p: "35",
    q: "36",
    r: "37",
    s: "38",
    t: "39",
    u: "40",
    v: "41",
    w: "42",
    x: "43",
    y: "44",
    z: "45",
    AB: "56",
    BB: "57",
    CB: "58",
    DB: "59",
    EB: "60",
    FB: "70",
    GB: "62",
    HB: "63",
    IB: "64",
    JB: "65",
    KB: "79",
    LB: "67",
    MB: "68",
    NB: "69",
    OB: "82",
    PB: "61",
    QB: "74",
    RB: "75",
    SB: "76",
    TB: "77",
    UB: "78",
    VB: "73",
    WB: "3.2",
    XB: "10.1",
    YB: "85",
    ZB: "11.5",
    aB: "4.2-4.3",
    bB: "3",
    cB: "89",
    dB: "3.1",
    eB: "2",
    fB: "5.1",
    gB: "6.1",
    hB: "7.1",
    iB: "9.1",
    jB: "2.5",
    kB: "3.5",
    lB: "5.5",
    mB: "13.1",
    nB: "TP",
    oB: "9.5-9.6",
    pB: "10.0-10.1",
    qB: "10.5",
    rB: "10.6",
    sB: "3.6",
    tB: "11.6",
    uB: "4.0-4.1",
    vB: "87",
    wB: "88",
    xB: "6.0-6.1",
    yB: "7.0-7.1",
    zB: "8.1-8.4",
    "0B": "9.0-9.2",
    "1B": "9.3",
    "2B": "10.0-10.2",
    "3B": "10.3",
    "4B": "11.0-11.2",
    "5B": "11.3-11.4",
    "6B": "12.0-12.1",
    "7B": "12.2-12.4",
    "8B": "13.0-13.1",
    "9B": "13.2",
    AC: "13.3",
    BC: "13.4-13.7",
    CC: "all",
    DC: "2.1",
    EC: "2.2",
    FC: "2.3",
    GC: "4.1",
    HC: "4.4",
    IC: "4.4.3-4.4.4",
    JC: "12.12",
    KC: "5.0-5.4",
    LC: "6.2-6.4",
    MC: "7.2-7.4",
    NC: "8.2",
    OC: "9.2",
    PC: "11.1-11.2",
    QC: "12.0",
    RC: "10.4",
    SC: "7.12",
    TC: "5.0-5.1"
  };

  var browserVersions_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var browserVersions$1 = exports.browserVersions = browserVersions;
  });

  var agents = {
    A: {
      A: {
        O: 0.0130886,
        F: 0.00621152,
        H: 0.065443,
        E: 0.209417,
        A: 0.0196329,
        B: 1.08635,
        lB: 0.009298
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "lB", "O", "F", "H", "E", "A", "B", "", "", ""],
      E: "IE",
      F: {
        lB: 962323200,
        O: 998870400,
        F: 1161129600,
        H: 1237420800,
        E: 1300060800,
        A: 1346716800,
        B: 1381968000
      }
    },
    B: {
      A: {
        C: 0.009782,
        N: 0.004891,
        D: 0.009782,
        I: 0.009782,
        J: 0.014673,
        K: 0.04891,
        L: 0.29346,
        KB: 0,
        P: 0.009782,
        M: 0.00944,
        R: 0.004891,
        S: 0.019564,
        YB: 0.973309,
        U: 1.82923
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "N", "D", "I", "J", "K", "L", "KB", "P", "M", "R", "S", "YB", "U", "", "", ""],
      E: "Edge",
      F: {
        C: 1438128000,
        N: 1447286400,
        D: 1470096000,
        I: 1491868800,
        J: 1508198400,
        K: 1525046400,
        L: 1542067200,
        KB: 1579046400,
        P: 1581033600,
        M: 1586736000,
        R: 1590019200,
        S: 1594857600,
        YB: 1598486400,
        U: 1602201600
      },
      D: {
        C: "ms",
        N: "ms",
        D: "ms",
        I: "ms",
        J: "ms",
        K: "ms",
        L: "ms"
      }
    },
    C: {
      A: {
        "0": 0.004525,
        "1": 0.009782,
        "2": 0.014673,
        "3": 0.004538,
        "4": 0.00472,
        "5": 0.004642,
        "6": 0.092929,
        "7": 0.004335,
        "8": 0.004891,
        "9": 0.004891,
        eB: 0.004827,
        bB: 0.004538,
        G: 0.014673,
        Y: 0.004879,
        O: 0.020136,
        F: 0.005725,
        H: 0.004525,
        E: 0.00533,
        A: 0.004283,
        B: 0.004711,
        C: 0.004471,
        N: 0.004486,
        D: 0.00453,
        I: 0.004465,
        J: 0.004417,
        K: 0.008922,
        L: 0.004393,
        Z: 0.004443,
        a: 0.004283,
        b: 0.013596,
        c: 0.013698,
        d: 0.013614,
        e: 0.008786,
        f: 0.004403,
        g: 0.004317,
        h: 0.004393,
        i: 0.004418,
        j: 0.008834,
        k: 0.004403,
        l: 0.008928,
        m: 0.004471,
        n: 0.009284,
        o: 0.004707,
        p: 0.009076,
        q: 0.004891,
        r: 0.004783,
        s: 0.00472,
        t: 0.004783,
        u: 0.00487,
        v: 0.005029,
        w: 0.0047,
        x: 0.04891,
        y: 0.004891,
        z: 0.004891,
        AB: 0.019564,
        BB: 0.004891,
        CB: 0.00944,
        DB: 0.004891,
        EB: 0.014673,
        PB: 0.00472,
        GB: 0.004891,
        HB: 0.019564,
        IB: 0.009782,
        JB: 0.009782,
        X: 0.014673,
        LB: 0.004891,
        MB: 0.039128,
        NB: 0.004891,
        FB: 0.004891,
        W: 0.004891,
        V: 0.019564,
        VB: 0.004891,
        QB: 0.009782,
        RB: 0.009782,
        SB: 0.009782,
        TB: 0.019564,
        UB: 0.166294,
        KB: 0.029346,
        P: 0.107602,
        M: 2.50908,
        OB: 0.396171,
        R: 0.014673,
        S: 0,
        kB: 0.008786,
        sB: 0.00487
      },
      B: "moz",
      C: ["eB", "bB", "kB", "sB", "G", "Y", "O", "F", "H", "E", "A", "B", "C", "N", "D", "I", "J", "K", "L", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "PB", "GB", "HB", "IB", "JB", "X", "LB", "MB", "NB", "FB", "W", "V", "VB", "QB", "RB", "SB", "TB", "UB", "KB", "P", "M", "OB", "R", "S", ""],
      E: "Firefox",
      F: {
        "0": 1461628800,
        "1": 1465257600,
        "2": 1470096000,
        "3": 1474329600,
        "4": 1479168000,
        "5": 1485216000,
        "6": 1488844800,
        "7": 1492560000,
        "8": 1497312000,
        "9": 1502150400,
        eB: 1161648000,
        bB: 1213660800,
        kB: 1246320000,
        sB: 1264032000,
        G: 1300752000,
        Y: 1308614400,
        O: 1313452800,
        F: 1317081600,
        H: 1317081600,
        E: 1320710400,
        A: 1324339200,
        B: 1327968000,
        C: 1331596800,
        N: 1335225600,
        D: 1338854400,
        I: 1342483200,
        J: 1346112000,
        K: 1349740800,
        L: 1353628800,
        Z: 1357603200,
        a: 1361232000,
        b: 1364860800,
        c: 1368489600,
        d: 1372118400,
        e: 1375747200,
        f: 1379376000,
        g: 1386633600,
        h: 1391472000,
        i: 1395100800,
        j: 1398729600,
        k: 1402358400,
        l: 1405987200,
        m: 1409616000,
        n: 1413244800,
        o: 1417392000,
        p: 1421107200,
        q: 1424736000,
        r: 1428278400,
        s: 1431475200,
        t: 1435881600,
        u: 1439251200,
        v: 1442880000,
        w: 1446508800,
        x: 1450137600,
        y: 1453852800,
        z: 1457395200,
        AB: 1506556800,
        BB: 1510617600,
        CB: 1516665600,
        DB: 1520985600,
        EB: 1525824000,
        PB: 1529971200,
        GB: 1536105600,
        HB: 1540252800,
        IB: 1544486400,
        JB: 1548720000,
        X: 1552953600,
        LB: 1558396800,
        MB: 1562630400,
        NB: 1567468800,
        FB: 1571788800,
        W: 1575331200,
        V: 1578355200,
        VB: 1581379200,
        QB: 1583798400,
        RB: 1586304000,
        SB: 1588636800,
        TB: 1591056000,
        UB: 1593475200,
        KB: 1595894400,
        P: 1598313600,
        M: 1600732800,
        OB: 1603152000,
        R: null,
        S: null
      }
    },
    D: {
      A: {
        "0": 0.004891,
        "1": 0.009782,
        "2": 0.019564,
        "3": 0.24455,
        "4": 0.004891,
        "5": 0.004891,
        "6": 0.004891,
        "7": 0.039128,
        "8": 0.014673,
        "9": 0.009782,
        G: 0.004706,
        Y: 0.004879,
        O: 0.004879,
        F: 0.005591,
        H: 0.005591,
        E: 0.005591,
        A: 0.004534,
        B: 0.004464,
        C: 0.010424,
        N: 0.009782,
        D: 0.004706,
        I: 0.015087,
        J: 0.004393,
        K: 0.004393,
        L: 0.008652,
        Z: 0.004418,
        a: 0.004393,
        b: 0.004317,
        c: 0.009782,
        d: 0.008786,
        e: 0.004538,
        f: 0.004461,
        g: 0.004711,
        h: 0.004326,
        i: 0.0047,
        j: 0.004538,
        k: 0.004335,
        l: 0.009782,
        m: 0.004566,
        n: 0.009422,
        o: 0.009782,
        p: 0.004335,
        q: 0.004335,
        r: 0.004464,
        s: 0.024455,
        t: 0.004464,
        u: 0.009782,
        v: 0.0236,
        w: 0.004403,
        x: 0.009782,
        y: 0.004465,
        z: 0.004642,
        AB: 0.029346,
        BB: 0.019564,
        CB: 0.014673,
        DB: 0.009782,
        EB: 0.014673,
        PB: 0.039128,
        GB: 0.014673,
        HB: 0.034237,
        IB: 0.014673,
        JB: 0.034237,
        X: 0.024455,
        LB: 0.039128,
        MB: 0.029346,
        NB: 0.088038,
        FB: 0.088038,
        W: 0.107602,
        V: 0.088038,
        VB: 0.063583,
        QB: 0.092929,
        RB: 0.078256,
        SB: 0.092929,
        TB: 0.068474,
        UB: 0.107602,
        KB: 0.161403,
        P: 0.224986,
        M: 0.151621,
        R: 0.303242,
        S: 0.503773,
        YB: 12.1199,
        U: 17.9255,
        vB: 0.034237,
        wB: 0.019564,
        cB: 0
      },
      B: "webkit",
      C: ["", "G", "Y", "O", "F", "H", "E", "A", "B", "C", "N", "D", "I", "J", "K", "L", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "PB", "GB", "HB", "IB", "JB", "X", "LB", "MB", "NB", "FB", "W", "V", "VB", "QB", "RB", "SB", "TB", "UB", "KB", "P", "M", "R", "S", "YB", "U", "vB", "wB", "cB"],
      E: "Chrome",
      F: {
        "0": 1444780800,
        "1": 1449014400,
        "2": 1453248000,
        "3": 1456963200,
        "4": 1460592000,
        "5": 1464134400,
        "6": 1469059200,
        "7": 1472601600,
        "8": 1476230400,
        "9": 1480550400,
        G: 1264377600,
        Y: 1274745600,
        O: 1283385600,
        F: 1287619200,
        H: 1291248000,
        E: 1296777600,
        A: 1299542400,
        B: 1303862400,
        C: 1307404800,
        N: 1312243200,
        D: 1316131200,
        I: 1316131200,
        J: 1319500800,
        K: 1323734400,
        L: 1328659200,
        Z: 1332892800,
        a: 1337040000,
        b: 1340668800,
        c: 1343692800,
        d: 1348531200,
        e: 1352246400,
        f: 1357862400,
        g: 1361404800,
        h: 1364428800,
        i: 1369094400,
        j: 1374105600,
        k: 1376956800,
        l: 1384214400,
        m: 1389657600,
        n: 1392940800,
        o: 1397001600,
        p: 1400544000,
        q: 1405468800,
        r: 1409011200,
        s: 1412640000,
        t: 1416268800,
        u: 1421798400,
        v: 1425513600,
        w: 1429401600,
        x: 1432080000,
        y: 1437523200,
        z: 1441152000,
        AB: 1485302400,
        BB: 1489017600,
        CB: 1492560000,
        DB: 1496707200,
        EB: 1500940800,
        PB: 1504569600,
        GB: 1508198400,
        HB: 1512518400,
        IB: 1516752000,
        JB: 1520294400,
        X: 1523923200,
        LB: 1527552000,
        MB: 1532390400,
        NB: 1536019200,
        FB: 1539648000,
        W: 1543968000,
        V: 1548720000,
        VB: 1552348800,
        QB: 1555977600,
        RB: 1559606400,
        SB: 1564444800,
        TB: 1568073600,
        UB: 1571702400,
        KB: 1575936000,
        P: 1580860800,
        M: 1586304000,
        R: 1589846400,
        S: 1594684800,
        YB: 1598313600,
        U: 1601942400,
        vB: null,
        wB: null,
        cB: null
      }
    },
    E: {
      A: {
        G: 0,
        Y: 0.004566,
        O: 0.004656,
        F: 0.004465,
        H: 0.004891,
        E: 0.004891,
        A: 0.004891,
        B: 0.014673,
        C: 0.039128,
        N: 0.224986,
        D: 1.50154,
        dB: 0,
        WB: 0.008692,
        fB: 0.136948,
        gB: 0.00456,
        hB: 0.004283,
        iB: 0.029346,
        XB: 0.039128,
        T: 0.102711,
        Q: 0.180967,
        mB: 2.0102,
        nB: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "dB", "WB", "G", "Y", "fB", "O", "gB", "F", "hB", "H", "E", "iB", "A", "XB", "B", "T", "C", "Q", "N", "mB", "D", "nB", "", ""],
      E: "Safari",
      F: {
        dB: 1205798400,
        WB: 1226534400,
        G: 1244419200,
        Y: 1275868800,
        fB: 1311120000,
        O: 1343174400,
        gB: 1382400000,
        F: 1382400000,
        hB: 1410998400,
        H: 1413417600,
        E: 1443657600,
        iB: 1458518400,
        A: 1474329600,
        XB: 1490572800,
        B: 1505779200,
        T: 1522281600,
        C: 1537142400,
        Q: 1553472000,
        N: 1568851200,
        mB: 1585008000,
        D: 1600214400,
        nB: null
      }
    },
    F: {
      A: {
        "0": 0.004417,
        "1": 0.008942,
        "2": 0.004707,
        "3": 0.004827,
        "4": 0.004707,
        "5": 0.004707,
        "6": 0.004326,
        "7": 0.008922,
        "8": 0.014349,
        "9": 0.004725,
        E: 0.0082,
        B: 0.016581,
        C: 0.004317,
        I: 0.00685,
        J: 0.00685,
        K: 0.00685,
        L: 0.005014,
        Z: 0.006015,
        a: 0.004879,
        b: 0.006597,
        c: 0.006597,
        d: 0.013434,
        e: 0.006702,
        f: 0.006015,
        g: 0.005595,
        h: 0.004393,
        i: 0.008652,
        j: 0.004879,
        k: 0.004879,
        l: 0.004711,
        m: 0.005152,
        n: 0.005014,
        o: 0.009758,
        p: 0.004879,
        q: 0.009782,
        r: 0.004283,
        s: 0.004367,
        t: 0.004534,
        u: 0.004367,
        v: 0.004227,
        w: 0.004418,
        x: 0.009042,
        y: 0.004227,
        z: 0.004725,
        AB: 0.00472,
        BB: 0.00472,
        CB: 0.00944,
        EB: 0.00472,
        GB: 0.004532,
        HB: 0.004566,
        IB: 0.02283,
        JB: 0.00867,
        X: 0.004656,
        LB: 0.004642,
        MB: 0.009782,
        NB: 0.00944,
        FB: 0.122275,
        W: 0.92929,
        V: 0.019564,
        oB: 0.00685,
        pB: 0,
        qB: 0.008392,
        rB: 0.004706,
        T: 0.006229,
        ZB: 0.004879,
        tB: 0.008786,
        Q: 0.00472
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "oB", "pB", "qB", "rB", "B", "T", "ZB", "tB", "C", "Q", "I", "J", "K", "L", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "EB", "GB", "HB", "IB", "JB", "X", "LB", "MB", "NB", "FB", "W", "V", "", "", ""],
      E: "Opera",
      F: {
        "0": 1498003200,
        "1": 1502236800,
        "2": 1506470400,
        "3": 1510099200,
        "4": 1515024000,
        "5": 1517961600,
        "6": 1521676800,
        "7": 1525910400,
        "8": 1530144000,
        "9": 1534982400,
        E: 1150761600,
        oB: 1223424000,
        pB: 1251763200,
        qB: 1267488000,
        rB: 1277942400,
        B: 1292457600,
        T: 1302566400,
        ZB: 1309219200,
        tB: 1323129600,
        C: 1323129600,
        Q: 1352073600,
        I: 1372723200,
        J: 1377561600,
        K: 1381104000,
        L: 1386288000,
        Z: 1390867200,
        a: 1393891200,
        b: 1399334400,
        c: 1401753600,
        d: 1405987200,
        e: 1409616000,
        f: 1413331200,
        g: 1417132800,
        h: 1422316800,
        i: 1425945600,
        j: 1430179200,
        k: 1433808000,
        l: 1438646400,
        m: 1442448000,
        n: 1445904000,
        o: 1449100800,
        p: 1454371200,
        q: 1457308800,
        r: 1462320000,
        s: 1465344000,
        t: 1470096000,
        u: 1474329600,
        v: 1477267200,
        w: 1481587200,
        x: 1486425600,
        y: 1490054400,
        z: 1494374400,
        AB: 1537833600,
        BB: 1543363200,
        CB: 1548201600,
        EB: 1554768000,
        GB: 1561593600,
        HB: 1566259200,
        IB: 1570406400,
        JB: 1573689600,
        X: 1578441600,
        LB: 1583971200,
        MB: 1587513600,
        NB: 1592956800,
        FB: 1595894400,
        W: 1600128000,
        V: 1603238400
      },
      D: {
        E: "o",
        B: "o",
        C: "o",
        oB: "o",
        pB: "o",
        qB: "o",
        rB: "o",
        T: "o",
        ZB: "o",
        tB: "o",
        Q: "o"
      }
    },
    G: {
      A: {
        H: 0,
        D: 5.38701,
        WB: 0.0129052,
        uB: 0.0110616,
        aB: 0.0018436,
        TC: 0.00921801,
        xB: 0.00553081,
        yB: 0.0129052,
        zB: 0.0424029,
        "0B": 0.0239668,
        "1B": 0.306038,
        "2B": 0.0516209,
        "3B": 0.283915,
        "4B": 0.106929,
        "5B": 0.182517,
        "6B": 0.186204,
        "7B": 1.85651,
        "8B": 0.153019,
        "9B": 0.0755877,
        AC: 0.575204,
        BC: 3.06407
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "WB", "uB", "aB", "TC", "xB", "yB", "H", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "D", "", "", ""],
      E: "iOS Safari",
      F: {
        WB: 1270252800,
        uB: 1283904000,
        aB: 1299628800,
        TC: 1331078400,
        xB: 1359331200,
        yB: 1394409600,
        H: 1410912000,
        zB: 1413763200,
        "0B": 1442361600,
        "1B": 1458518400,
        "2B": 1473724800,
        "3B": 1490572800,
        "4B": 1505779200,
        "5B": 1522281600,
        "6B": 1537142400,
        "7B": 1553472000,
        "8B": 1568851200,
        "9B": 1572220800,
        AC: 1580169600,
        BC: 1585008000,
        D: 1600214400
      }
    },
    H: {
      A: {
        CC: 0.875474
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "", "", ""],
      E: "Opera Mini",
      F: {
        CC: 1426464000
      }
    },
    I: {
      A: {
        bB: 0,
        G: 0.0373129,
        M: 0,
        DC: 0,
        EC: 0,
        FC: 0.000298503,
        GC: 0.0188057,
        aB: 0.00835809,
        HC: 0,
        IC: 0.0680588
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "DC", "EC", "FC", "bB", "G", "GC", "aB", "HC", "IC", "M", "", "", ""],
      E: "Android Browser",
      F: {
        DC: 1256515200,
        EC: 1274313600,
        FC: 1291593600,
        bB: 1298332800,
        G: 1318896000,
        GC: 1341792000,
        aB: 1374624000,
        HC: 1386547200,
        IC: 1401667200,
        M: 1587427200
      }
    },
    J: {
      A: {
        F: 0,
        A: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "A", "", "", ""],
      E: "Blackberry Browser",
      F: {
        F: 1325376000,
        A: 1359504000
      }
    },
    K: {
      A: {
        A: 0,
        B: 0,
        C: 0,
        DB: 0.0111391,
        T: 0,
        ZB: 0,
        Q: 0
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "T", "ZB", "C", "Q", "DB", "", "", ""],
      E: "Opera Mobile",
      F: {
        A: 1287100800,
        B: 1300752000,
        T: 1314835200,
        ZB: 1318291200,
        C: 1330300800,
        Q: 1349740800,
        DB: 1593475200
      },
      D: {
        DB: "webkit"
      }
    },
    L: {
      A: {
        U: 33.5525
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "U", "", "", ""],
      E: "Chrome for Android",
      F: {
        U: 1602028800
      }
    },
    M: {
      A: {
        OB: 0.229905
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OB", "", "", ""],
      E: "Firefox for Android",
      F: {
        OB: 1601596800
      }
    },
    N: {
      A: {
        A: 0.0115934,
        B: 0.022664
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
      E: "IE Mobile",
      F: {
        A: 1340150400,
        B: 1353456000
      }
    },
    O: {
      A: {
        JC: 1.21083
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "JC", "", "", ""],
      E: "UC Browser for Android",
      F: {
        JC: 1471392000
      },
      D: {
        JC: "webkit"
      }
    },
    P: {
      A: {
        G: 0.251766,
        KC: 0.0104903,
        LC: 0.010304,
        MC: 0.0629416,
        NC: 0.0209805,
        OC: 0.115393,
        XB: 0.0734319,
        PC: 0.178335,
        QC: 2.63306
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "KC", "LC", "MC", "NC", "OC", "XB", "PC", "QC", "", "", ""],
      E: "Samsung Internet",
      F: {
        G: 1461024000,
        KC: 1481846400,
        LC: 1509408000,
        MC: 1528329600,
        NC: 1546128000,
        OC: 1554163200,
        XB: 1567900800,
        PC: 1582588800,
        QC: 1593475200
      }
    },
    Q: {
      A: {
        RC: 0.199251
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "", "", ""],
      E: "QQ Browser",
      F: {
        RC: 1589846400
      }
    },
    R: {
      A: {
        SC: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "SC", "", "", ""],
      E: "Baidu Browser",
      F: {
        SC: 1491004800
      }
    },
    S: {
      A: {
        jB: 0.035763
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "jB", "", "", ""],
      E: "KaiOS Browser",
      F: {
        jB: 1527811200
      }
    }
  };

  var agents_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.agents = undefined;







  function unpackBrowserVersions(versionsData) {
    return Object.keys(versionsData).reduce(function (usage, version) {
      usage[browserVersions_1.browserVersions[version]] = versionsData[version];
      return usage;
    }, {});
  }

  var agents$1 = exports.agents = Object.keys(agents).reduce(function (map, key) {
    var versionsData = agents[key];
    map[browsers_1.browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
      if (entry === 'A') {
        data.usage_global = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'C') {
        data.versions = versionsData[entry].reduce(function (list, version) {
          if (version === '') {
            list.push(null);
          } else {
            list.push(browserVersions_1.browserVersions[version]);
          }

          return list;
        }, []);
      } else if (entry === 'D') {
        data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'E') {
        data.browser = versionsData[entry];
      } else if (entry === 'F') {
        data.release_date = Object.keys(versionsData[entry]).reduce(function (map, key) {
          map[browserVersions_1.browserVersions[key]] = versionsData[entry][key];
          return map;
        }, {});
      } else {
        data.prefix = versionsData[entry];
      }

      return data;
    }, {});
    return map;
  }, {});
  });

  var v4 = {
  	start: "2015-09-08",
  	lts: "2015-10-12",
  	maintenance: "2017-04-01",
  	end: "2018-04-30",
  	codename: "Argon"
  };
  var v5 = {
  	start: "2015-10-29",
  	maintenance: "2016-04-30",
  	end: "2016-06-30"
  };
  var v6 = {
  	start: "2016-04-26",
  	lts: "2016-10-18",
  	maintenance: "2018-04-30",
  	end: "2019-04-30",
  	codename: "Boron"
  };
  var v7 = {
  	start: "2016-10-25",
  	maintenance: "2017-04-30",
  	end: "2017-06-30"
  };
  var v8 = {
  	start: "2017-05-30",
  	lts: "2017-10-31",
  	maintenance: "2019-01-01",
  	end: "2019-12-31",
  	codename: "Carbon"
  };
  var v9 = {
  	start: "2017-10-01",
  	maintenance: "2018-04-01",
  	end: "2018-06-30"
  };
  var v10 = {
  	start: "2018-04-24",
  	lts: "2018-10-30",
  	maintenance: "2020-05-19",
  	end: "2021-04-30",
  	codename: "Dubnium"
  };
  var v11 = {
  	start: "2018-10-23",
  	maintenance: "2019-04-22",
  	end: "2019-06-01"
  };
  var v12 = {
  	start: "2019-04-23",
  	lts: "2019-10-21",
  	maintenance: "2020-11-30",
  	end: "2022-04-30",
  	codename: "Erbium"
  };
  var v13 = {
  	start: "2019-10-22",
  	maintenance: "2020-04-01",
  	end: "2020-06-01"
  };
  var v14 = {
  	start: "2020-04-21",
  	lts: "2020-10-27",
  	maintenance: "2021-10-19",
  	end: "2023-04-30",
  	codename: ""
  };
  var v15 = {
  	start: "2020-10-20",
  	maintenance: "2021-04-01",
  	end: "2021-06-01"
  };
  var v16 = {
  	start: "2021-04-20",
  	lts: "2021-10-26",
  	maintenance: "2022-10-18",
  	end: "2024-04-30",
  	codename: ""
  };
  var releaseSchedule = {
  	"v0.10": {
  	start: "2013-03-11",
  	end: "2016-10-31"
  },
  	"v0.12": {
  	start: "2015-02-06",
  	end: "2016-12-31"
  },
  	v4: v4,
  	v5: v5,
  	v6: v6,
  	v7: v7,
  	v8: v8,
  	v9: v9,
  	v10: v10,
  	v11: v11,
  	v12: v12,
  	v13: v13,
  	v14: v14,
  	v15: v15,
  	v16: v16
  };

  var releaseSchedule$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    v4: v4,
    v5: v5,
    v6: v6,
    v7: v7,
    v8: v8,
    v9: v9,
    v10: v10,
    v11: v11,
    v12: v12,
    v13: v13,
    v14: v14,
    v15: v15,
    v16: v16,
    'default': releaseSchedule
  });

  var versions = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "10.0": "85",
    "10.1": "85",
    "11.0": "87"
  };

  function BrowserslistError(message) {
    this.name = 'BrowserslistError';
    this.message = message;
    this.browserslist = true;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, BrowserslistError);
    }
  }

  BrowserslistError.prototype = Error.prototype;
  var error = BrowserslistError;

  var statuses = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = {
    1: "ls",
    2: "rec",
    3: "pr",
    4: "cr",
    5: "wd",
    6: "other",
    7: "unoff"
  };
  });

  var supported = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = {
    y: 1 << 0,
    n: 1 << 1,
    a: 1 << 2,
    p: 1 << 3,
    u: 1 << 4,
    x: 1 << 5,
    d: 1 << 6
  };
  });

  var feature = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = unpackFeature;



  var _statuses2 = _interopRequireDefault(statuses);



  var _supported2 = _interopRequireDefault(supported);





  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  var MATH2LOG = Math.log(2);

  function unpackSupport(cipher) {
    var stats = Object.keys(_supported2["default"]).reduce(function (list, support) {
      if (cipher & _supported2["default"][support]) list.push(support);
      return list;
    }, []);
    var notes = cipher >> 7;
    var notesArray = [];

    while (notes) {
      var note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
      notesArray.unshift('#' + note);
      notes -= Math.pow(2, note - 1);
    }

    return stats.concat(notesArray).join(' ');
  }

  function unpackFeature(packed) {
    var unpacked = {
      status: _statuses2["default"][packed.B],
      title: packed.C
    };
    unpacked.stats = Object.keys(packed.A).reduce(function (browserStats, key) {
      var browser = packed.A[key];
      browserStats[browsers_1.browsers[key]] = Object.keys(browser).reduce(function (stats, support) {
        var packedVersions = browser[support].split(' ');
        var unpacked = unpackSupport(support);
        packedVersions.forEach(function (v) {
          return stats[browserVersions_1.browserVersions[v]] = unpacked;
        });
        return stats;
      }, {});
      return browserStats;
    }, {});
    return unpacked;
  }
  });

  var region = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = unpackRegion;



  function unpackRegion(packed) {
    return Object.keys(packed).reduce(function (list, browser) {
      var data = packed[browser];
      list[browsers_1.browsers[browser]] = Object.keys(data).reduce(function (memo, key) {
        var stats = data[key];

        if (key === '_') {
          stats.split(' ').forEach(function (version) {
            return memo[version] = null;
          });
        } else {
          memo[key] = stats;
        }

        return memo;
      }, {});
      return list;
    }, {});
  }
  });

  var node$2 = createCommonjsModule(function (module) {
  var feature$1 = feature["default"];

  var region$1 = region["default"];







  var IS_SECTION = /^\s*\[(.+)]\s*$/;
  var CONFIG_PATTERN = /^browserslist-config-/;
  var SCOPED_CONFIG__PATTERN = /@[^/]+\/browserslist-config(-|$|\/)/;
  var TIME_TO_UPDATE_CANIUSE = 6 * 30 * 24 * 60 * 60 * 1000;
  var FORMAT = 'Browserslist config should be a string or an array ' + 'of strings with browser queries';
  var dataTimeChecked = false;
  var filenessCache = {};
  var configCache = {};

  function checkExtend(name) {
    var use = ' Use `dangerousExtend` option to disable.';

    if (!CONFIG_PATTERN.test(name) && !SCOPED_CONFIG__PATTERN.test(name)) {
      throw new error('Browserslist config needs `browserslist-config-` prefix. ' + use);
    }

    if (name.replace(/^@[^/]+\//, '').indexOf('.') !== -1) {
      throw new error('`.` not allowed in Browserslist config name. ' + use);
    }

    if (name.indexOf('node_modules') !== -1) {
      throw new error('`node_modules` not allowed in Browserslist config.' + use);
    }
  }

  function isFile(file) {
    if (file in filenessCache) {
      return filenessCache[file];
    }

    var result = fs__default['default'].existsSync(file) && fs__default['default'].statSync(file).isFile();

    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      filenessCache[file] = result;
    }

    return result;
  }

  function eachParent(file, callback) {
    var dir = isFile(file) ? path__default['default'].dirname(file) : file;
    var loc = path__default['default'].resolve(dir);

    do {
      var result = callback(loc);
      if (typeof result !== 'undefined') return result;
    } while (loc !== (loc = path__default['default'].dirname(loc)));

    return undefined;
  }

  function check(section) {
    if (Array.isArray(section)) {
      for (var i = 0; i < section.length; i++) {
        if (typeof section[i] !== 'string') {
          throw new error(FORMAT);
        }
      }
    } else if (typeof section !== 'string') {
      throw new error(FORMAT);
    }
  }

  function pickEnv(config, opts) {
    if (typeof config !== 'object') return config;
    var name;

    if (typeof opts.env === 'string') {
      name = opts.env;
    } else if (process.env.BROWSERSLIST_ENV) {
      name = process.env.BROWSERSLIST_ENV;
    } else {
      name = 'production';
    }

    return config[name] || config.defaults;
  }

  function parsePackage(file) {
    var config = JSON.parse(fs__default['default'].readFileSync(file));

    if (config.browserlist && !config.browserslist) {
      throw new error('`browserlist` key instead of `browserslist` in ' + file);
    }

    var list = config.browserslist;

    if (Array.isArray(list) || typeof list === 'string') {
      list = {
        defaults: list
      };
    }

    for (var i in list) {
      check(list[i]);
    }

    return list;
  }

  function latestReleaseTime(agents) {
    var latest = 0;

    for (var name in agents) {
      var dates = agents[name].releaseDate || {};

      for (var key in dates) {
        if (latest < dates[key]) {
          latest = dates[key];
        }
      }
    }

    return latest * 1000;
  }

  function normalizeStats(data, stats) {
    if (stats && 'dataByBrowser' in stats) {
      stats = stats.dataByBrowser;
    }

    if (typeof stats !== 'object') return undefined;
    var normalized = {};

    for (var i in stats) {
      var versions = Object.keys(stats[i]);

      if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
        var normal = Object.keys(data[i].versions)[0];
        normalized[i] = {};
        normalized[i][normal] = stats[i][versions[0]];
      } else {
        normalized[i] = stats[i];
      }
    }

    return normalized;
  }

  function normalizeUsageData(usageData, data) {
    for (var browser in usageData) {
      var browserUsage = usageData[browser];

      if ('0' in browserUsage) {
        var versions = data[browser].versions;
        browserUsage[versions[versions.length - 1]] = browserUsage[0];
        delete browserUsage[0];
      }
    }
  }

  module.exports = {
    loadQueries: function loadQueries(ctx, name) {
      if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
        checkExtend(name);
      }

      var queries = commonjsRequire((parseFloat(process.versions.node) >= 8.9 ? commonjsRequire.resolve : function (r, _ref, M) {
        var _ref$paths = _ref.paths,
            b = _ref$paths[0];

        if (M === void 0) {
          M = module__default['default'];
        }

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '" + r + "'");
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(name, {
        paths: ['.']
      }));

      if (queries) {
        if (Array.isArray(queries)) {
          return queries;
        } else if (typeof queries === 'object') {
          if (!queries.defaults) queries.defaults = [];
          return pickEnv(queries, ctx);
        }
      }

      throw new error('`' + name + '` config exports not an array of queries' + ' or an object of envs');
    },
    loadStat: function loadStat(ctx, name, data) {
      if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
        checkExtend(name);
      }

      var stats = commonjsRequire((parseFloat(process.versions.node) >= 8.9 ? commonjsRequire.resolve : function (r, _ref2, M) {
        var _ref2$paths = _ref2.paths,
            b = _ref2$paths[0];

        if (M === void 0) {
          M = module__default['default'];
        }

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '" + r + "'");
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(path__default['default'].join(name, 'browserslist-stats.json'), {
        paths: ['.']
      }));

      return normalizeStats(data, stats);
    },
    getStat: function getStat(opts, data) {
      var stats;

      if (opts.stats) {
        stats = opts.stats;
      } else if (process.env.BROWSERSLIST_STATS) {
        stats = process.env.BROWSERSLIST_STATS;
      } else if (opts.path && path__default['default'].resolve && fs__default['default'].existsSync) {
        stats = eachParent(opts.path, function (dir) {
          var file = path__default['default'].join(dir, 'browserslist-stats.json');
          return isFile(file) ? file : undefined;
        });
      }

      if (typeof stats === 'string') {
        try {
          stats = JSON.parse(fs__default['default'].readFileSync(stats));
        } catch (e) {
          throw new error('Can\'t read ' + stats);
        }
      }

      return normalizeStats(data, stats);
    },
    loadConfig: function loadConfig(opts) {
      if (process.env.BROWSERSLIST) {
        return process.env.BROWSERSLIST;
      } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
        var file = opts.config || process.env.BROWSERSLIST_CONFIG;

        if (path__default['default'].basename(file) === 'package.json') {
          return pickEnv(parsePackage(file), opts);
        } else {
          return pickEnv(module.exports.readConfig(file), opts);
        }
      } else if (opts.path) {
        return pickEnv(module.exports.findConfig(opts.path), opts);
      } else {
        return undefined;
      }
    },
    loadCountry: function loadCountry(usage, country, data) {
      var code = country.replace(/[^\w-]/g, '');

      if (!usage[code]) {
        var compressed = commonjsRequire();

        var usageData = region$1(compressed);
        normalizeUsageData(usageData, data);
        usage[country] = {};

        for (var i in usageData) {
          for (var j in usageData[i]) {
            usage[country][i + ' ' + j] = usageData[i][j];
          }
        }
      }
    },
    loadFeature: function loadFeature(features, name) {
      name = name.replace(/[^\w-]/g, '');
      if (features[name]) return;

      var compressed = commonjsRequire();

      var stats = feature$1(compressed).stats;
      features[name] = {};

      for (var i in stats) {
        for (var j in stats[i]) {
          features[name][i + ' ' + j] = stats[i][j];
        }
      }
    },
    parseConfig: function parseConfig(string) {
      var result = {
        defaults: []
      };
      var sections = ['defaults'];
      string.toString().replace(/#[^\n]*/g, '').split(/\n|,/).map(function (line) {
        return line.trim();
      }).filter(function (line) {
        return line !== '';
      }).forEach(function (line) {
        if (IS_SECTION.test(line)) {
          sections = line.match(IS_SECTION)[1].trim().split(' ');
          sections.forEach(function (section) {
            if (result[section]) {
              throw new error('Duplicate section ' + section + ' in Browserslist config');
            }

            result[section] = [];
          });
        } else {
          sections.forEach(function (section) {
            result[section].push(line);
          });
        }
      });
      return result;
    },
    readConfig: function readConfig(file) {
      if (!isFile(file)) {
        throw new error('Can\'t read ' + file + ' config');
      }

      return module.exports.parseConfig(fs__default['default'].readFileSync(file));
    },
    findConfig: function findConfig(from) {
      from = path__default['default'].resolve(from);
      var passed = [];
      var resolved = eachParent(from, function (dir) {
        if (dir in configCache) {
          return configCache[dir];
        }

        passed.push(dir);
        var config = path__default['default'].join(dir, 'browserslist');
        var pkg = path__default['default'].join(dir, 'package.json');
        var rc = path__default['default'].join(dir, '.browserslistrc');
        var pkgBrowserslist;

        if (isFile(pkg)) {
          try {
            pkgBrowserslist = parsePackage(pkg);
          } catch (e) {
            if (e.name === 'BrowserslistError') throw e;
            console.warn('[Browserslist] Could not parse ' + pkg + '. Ignoring it.');
          }
        }

        if (isFile(config) && pkgBrowserslist) {
          throw new error(dir + ' contains both browserslist and package.json with browsers');
        } else if (isFile(rc) && pkgBrowserslist) {
          throw new error(dir + ' contains both .browserslistrc and package.json with browsers');
        } else if (isFile(config) && isFile(rc)) {
          throw new error(dir + ' contains both .browserslistrc and browserslist');
        } else if (isFile(config)) {
          return module.exports.readConfig(config);
        } else if (isFile(rc)) {
          return module.exports.readConfig(rc);
        } else {
          return pkgBrowserslist;
        }
      });

      if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
        passed.forEach(function (dir) {
          configCache[dir] = resolved;
        });
      }

      return resolved;
    },
    clearCaches: function clearCaches() {
      dataTimeChecked = false;
      filenessCache = {};
      configCache = {};
      this.cache = {};
    },
    oldDataWarning: function oldDataWarning(agentsObj) {},
    currentNode: function currentNode() {
      return 'node ' + process.versions.node;
    }
  };
  });

  var jsReleases = getCjsExportFromNamespace(envs$1);

  var jsEOL = getCjsExportFromNamespace(releaseSchedule$1);

  var agents$1 = agents_1.agents;











  var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
  var ANDROID_EVERGREEN_FIRST = 37;
  var QUERY_OR = 1;
  var QUERY_AND = 2;

  function isVersionsMatch(versionA, versionB) {
    return (versionA + '.').indexOf(versionB + '.') === 0;
  }

  function isEolReleased(name) {
    var version = name.slice(1);
    return jsReleases.some(function (i) {
      return isVersionsMatch(i.version, version);
    });
  }

  function normalize(versions) {
    return versions.filter(function (version) {
      return typeof version === 'string';
    });
  }

  function normalizeElectron(version) {
    var versionToUse = version;

    if (version.split('.').length === 3) {
      versionToUse = version.split('.').slice(0, -1).join('.');
    }

    return versionToUse;
  }

  function nameMapper(name) {
    return function mapName(version) {
      return name + ' ' + version;
    };
  }

  function getMajor(version) {
    return parseInt(version.split('.')[0]);
  }

  function getMajorVersions(released, number) {
    if (released.length === 0) return [];
    var majorVersions = uniq(released.map(getMajor));
    var minimum = majorVersions[majorVersions.length - number];

    if (!minimum) {
      return released;
    }

    var selected = [];

    for (var i = released.length - 1; i >= 0; i--) {
      if (minimum > getMajor(released[i])) break;
      selected.unshift(released[i]);
    }

    return selected;
  }

  function uniq(array) {
    var filtered = [];

    for (var i = 0; i < array.length; i++) {
      if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
    }

    return filtered;
  }

  function fillUsage(result, name, data) {
    for (var i in data) {
      result[name + ' ' + i] = data[i];
    }
  }

  function generateFilter(sign, version) {
    version = parseFloat(version);

    if (sign === '>') {
      return function (v) {
        return parseFloat(v) > version;
      };
    } else if (sign === '>=') {
      return function (v) {
        return parseFloat(v) >= version;
      };
    } else if (sign === '<') {
      return function (v) {
        return parseFloat(v) < version;
      };
    } else {
      return function (v) {
        return parseFloat(v) <= version;
      };
    }
  }

  function generateSemverFilter(sign, version) {
    version = version.split('.').map(parseSimpleInt);
    version[1] = version[1] || 0;
    version[2] = version[2] || 0;

    if (sign === '>') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) > 0;
      };
    } else if (sign === '>=') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) >= 0;
      };
    } else if (sign === '<') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) > 0;
      };
    } else {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) >= 0;
      };
    }
  }

  function parseSimpleInt(x) {
    return parseInt(x);
  }

  function compare(a, b) {
    if (a < b) return -1;
    if (a > b) return +1;
    return 0;
  }

  function compareSemver(a, b) {
    return compare(parseInt(a[0]), parseInt(b[0])) || compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
  }

  function semverFilterLoose(operator, range) {
    range = range.split('.').map(parseSimpleInt);

    if (typeof range[1] === 'undefined') {
      range[1] = 'x';
    }

    switch (operator) {
      case '<=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) <= 0;
        };

      default:
      case '>=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) >= 0;
        };
    }
  }

  function compareSemverLoose(version, range) {
    if (version[0] !== range[0]) {
      return version[0] < range[0] ? -1 : +1;
    }

    if (range[1] === 'x') {
      return 0;
    }

    if (version[1] !== range[1]) {
      return version[1] < range[1] ? -1 : +1;
    }

    return 0;
  }

  function resolveVersion(data, version) {
    if (data.versions.indexOf(version) !== -1) {
      return version;
    } else if (browserslist.versionAliases[data.name][version]) {
      return browserslist.versionAliases[data.name][version];
    } else {
      return false;
    }
  }

  function normalizeVersion(data, version) {
    var resolved = resolveVersion(data, version);

    if (resolved) {
      return resolved;
    } else if (data.versions.length === 1) {
      return data.versions[0];
    } else {
      return false;
    }
  }

  function filterByYear(since, context) {
    since = since / 1000;
    return Object.keys(agents$1).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var versions = Object.keys(data.releaseDate).filter(function (v) {
        return data.releaseDate[v] >= since;
      });
      return selected.concat(versions.map(nameMapper(data.name)));
    }, []);
  }

  function cloneData(data) {
    return {
      name: data.name,
      versions: data.versions,
      released: data.released,
      releaseDate: data.releaseDate
    };
  }

  function mapVersions(data, map) {
    data.versions = data.versions.map(function (i) {
      return map[i] || i;
    });
    data.released = data.versions.map(function (i) {
      return map[i] || i;
    });
    var fixedDate = {};

    for (var i in data.releaseDate) {
      fixedDate[map[i] || i] = data.releaseDate[i];
    }

    data.releaseDate = fixedDate;
    return data;
  }

  function byName(name, context) {
    name = name.toLowerCase();
    name = browserslist.aliases[name] || name;

    if (context.mobileToDesktop && browserslist.desktopNames[name]) {
      var desktop = browserslist.data[browserslist.desktopNames[name]];

      if (name === 'android') {
        return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
      } else {
        var cloned = cloneData(desktop);
        cloned.name = name;

        if (name === 'op_mob') {
          cloned = mapVersions(cloned, {
            '10.0-10.1': '10'
          });
        }

        return cloned;
      }
    }

    return browserslist.data[name];
  }

  function normalizeAndroidVersions(androidVersions, chromeVersions) {
    var firstEvergreen = ANDROID_EVERGREEN_FIRST;
    var last = chromeVersions[chromeVersions.length - 1];
    return androidVersions.filter(function (version) {
      return /^(?:[2-4]\.|[34]$)/.test(version);
    }).concat(chromeVersions.slice(firstEvergreen - last - 1));
  }

  function normalizeAndroidData(android, chrome) {
    android.released = normalizeAndroidVersions(android.released, chrome.released);
    android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
    return android;
  }

  function checkName(name, context) {
    var data = byName(name, context);
    if (!data) throw new error('Unknown browser ' + name);
    return data;
  }

  function unknownQuery(query) {
    return new error('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
  }

  function filterAndroid(list, versions, context) {
    if (context.mobileToDesktop) return list;
    var released = browserslist.data.android.released;
    var last = released[released.length - 1];
    var diff = last - ANDROID_EVERGREEN_FIRST - versions;

    if (diff > 0) {
      return list.slice(-1);
    } else {
      return list.slice(diff - 1);
    }
  }

  function resolve$1(queries, context) {
    if (Array.isArray(queries)) {
      queries = flatten(queries.map(parse$4));
    } else {
      queries = parse$4(queries);
    }

    return queries.reduce(function (result, query, index) {
      var selection = query.queryString;
      var isExclude = selection.indexOf('not ') === 0;

      if (isExclude) {
        if (index === 0) {
          throw new error('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
        }

        selection = selection.slice(4);
      }

      for (var i = 0; i < QUERIES.length; i++) {
        var type = QUERIES[i];
        var match = selection.match(type.regexp);

        if (match) {
          var args = [context].concat(match.slice(1));
          var array = type.select.apply(browserslist, args).map(function (j) {
            var parts = j.split(' ');

            if (parts[1] === '0') {
              return parts[0] + ' ' + byName(parts[0], context).versions[0];
            } else {
              return j;
            }
          });

          switch (query.type) {
            case QUERY_AND:
              if (isExclude) {
                return result.filter(function (j) {
                  return array.indexOf(j) === -1;
                });
              } else {
                return result.filter(function (j) {
                  return array.indexOf(j) !== -1;
                });
              }

            case QUERY_OR:
            default:
              if (isExclude) {
                var filter = {};
                array.forEach(function (j) {
                  filter[j] = true;
                });
                return result.filter(function (j) {
                  return !filter[j];
                });
              }

              return result.concat(array);
          }
        }
      }

      throw unknownQuery(selection);
    }, []);
  }

  var cache$1 = {};

  function browserslist(queries, opts) {
    if (typeof opts === 'undefined') opts = {};

    if (typeof opts.path === 'undefined') {
      opts.path = path__default['default'].resolve ? path__default['default'].resolve('.') : '.';
    }

    if (typeof queries === 'undefined' || queries === null) {
      var config = browserslist.loadConfig(opts);

      if (config) {
        queries = config;
      } else {
        queries = browserslist.defaults;
      }
    }

    if (!(typeof queries === 'string' || Array.isArray(queries))) {
      throw new error('Browser queries must be an array or string. Got ' + typeof queries + '.');
    }

    var context = {
      ignoreUnknownVersions: opts.ignoreUnknownVersions,
      dangerousExtend: opts.dangerousExtend,
      mobileToDesktop: opts.mobileToDesktop,
      env: opts.env
    };
    node$2.oldDataWarning(browserslist.data);
    var stats = node$2.getStat(opts, browserslist.data);

    if (stats) {
      context.customUsage = {};

      for (var browser in stats) {
        fillUsage(context.customUsage, browser, stats[browser]);
      }
    }

    var cacheKey = JSON.stringify([queries, context]);
    if (cache$1[cacheKey]) return cache$1[cacheKey];
    var result = uniq(resolve$1(queries, context)).sort(function (name1, name2) {
      name1 = name1.split(' ');
      name2 = name2.split(' ');

      if (name1[0] === name2[0]) {
        var version1 = name1[1].split('-')[0];
        var version2 = name2[1].split('-')[0];
        return compareSemver(version2.split('.'), version1.split('.'));
      } else {
        return compare(name1[0], name2[0]);
      }
    });

    if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
      cache$1[cacheKey] = result;
    }

    return result;
  }

  function parse$4(queries) {
    var qs = [];

    do {
      queries = doMatch(queries, qs);
    } while (queries);

    return qs;
  }

  function doMatch(string, qs) {
    var or = /^(?:,\s*|\s+or\s+)(.*)/i;
    var and = /^\s+and\s+(.*)/i;
    return find$2(string, function (parsed, n, max) {
      if (and.test(parsed)) {
        qs.unshift({
          type: QUERY_AND,
          queryString: parsed.match(and)[1]
        });
        return true;
      } else if (or.test(parsed)) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.match(or)[1]
        });
        return true;
      } else if (n === max) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.trim()
        });
        return true;
      }

      return false;
    });
  }

  function find$2(string, predicate) {
    for (var n = 1, max = string.length; n <= max; n++) {
      var parsed = string.substr(-n, n);

      if (predicate(parsed, n, max)) {
        return string.slice(0, -n);
      }
    }

    return '';
  }

  function flatten(array) {
    if (!Array.isArray(array)) return [array];
    return array.reduce(function (a, b) {
      return a.concat(flatten(b));
    }, []);
  }

  browserslist.cache = {};
  browserslist.data = {};
  browserslist.usage = {
    global: {},
    custom: null
  };
  browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];
  browserslist.aliases = {
    fx: 'firefox',
    ff: 'firefox',
    ios: 'ios_saf',
    explorer: 'ie',
    blackberry: 'bb',
    explorermobile: 'ie_mob',
    operamini: 'op_mini',
    operamobile: 'op_mob',
    chromeandroid: 'and_chr',
    firefoxandroid: 'and_ff',
    ucandroid: 'and_uc',
    qqandroid: 'and_qq'
  };
  browserslist.desktopNames = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    android: 'chrome'
  };
  browserslist.versionAliases = {};
  browserslist.clearCaches = node$2.clearCaches;
  browserslist.parseConfig = node$2.parseConfig;
  browserslist.readConfig = node$2.readConfig;
  browserslist.findConfig = node$2.findConfig;
  browserslist.loadConfig = node$2.loadConfig;

  browserslist.coverage = function (browsers, stats) {
    var data;

    if (typeof stats === 'undefined') {
      data = browserslist.usage.global;
    } else if (stats === 'my stats') {
      var opts = {};
      opts.path = path__default['default'].resolve ? path__default['default'].resolve('.') : '.';
      var customStats = node$2.getStat(opts);

      if (!customStats) {
        throw new error('Custom usage statistics was not provided');
      }

      data = {};

      for (var browser in customStats) {
        fillUsage(data, browser, customStats[browser]);
      }
    } else if (typeof stats === 'string') {
      if (stats.length > 2) {
        stats = stats.toLowerCase();
      } else {
        stats = stats.toUpperCase();
      }

      node$2.loadCountry(browserslist.usage, stats, browserslist.data);
      data = browserslist.usage[stats];
    } else {
      if ('dataByBrowser' in stats) {
        stats = stats.dataByBrowser;
      }

      data = {};

      for (var name in stats) {
        for (var version in stats[name]) {
          data[name + ' ' + version] = stats[name][version];
        }
      }
    }

    return browsers.reduce(function (all, i) {
      var usage = data[i];

      if (usage === undefined) {
        usage = data[i.replace(/ \S+$/, ' 0')];
      }

      return all + (usage || 0);
    }, 0);
  };

  var QUERIES = [{
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = getMajorVersions(data.released, versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.released.slice(-versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function select(context, versions$1) {
      var validVersions = getMajorVersions(Object.keys(versions), versions$1);
      return validVersions.map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var validVersions = getMajorVersions(data.released, versions);
      var list = validVersions.map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function select(context, versions$1) {
      return Object.keys(versions).slice(-versions$1).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var list = data.released.slice(-versions).map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^unreleased\s+versions$/i,
    select: function select(context) {
      return Object.keys(agents$1).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1;
        });
        list = list.map(nameMapper(data.name));
        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function select() {
      return [];
    }
  }, {
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function select(context, name) {
      var data = checkName(name, context);
      return data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1;
      }).map(nameMapper(data.name));
    }
  }, {
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function select(context, years) {
      return filterByYear(Date.now() - YEAR * years, context);
    }
  }, {
    regexp: /^since (\d+)(?:-(\d+))?(?:-(\d+))?$/i,
    select: function select(context, year, month, date) {
      year = parseInt(year);
      month = parseInt(month || '01') - 1;
      date = parseInt(date || '01');
      return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);
      var usage = browserslist.usage.global;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+my\s+stats$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function select(context, sign, popularity, name) {
      popularity = parseFloat(popularity);
      var stats = node$2.loadStat(context, name, browserslist.data);

      if (stats) {
        context.customUsage = {};

        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser]);
        }
      }

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d*\.?\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function select(context, sign, popularity, place) {
      popularity = parseFloat(popularity);

      if (place.length === 2) {
        place = place.toUpperCase();
      } else {
        place = place.toLowerCase();
      }

      node$2.loadCountry(browserslist.usage, place, browserslist.data);
      var usage = browserslist.usage[place];
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^cover\s+(\d*\.?\d+)%(\s+in\s+(my\s+stats|(alt-)?\w\w))?$/,
    select: function select(context, coverage, statMode) {
      coverage = parseFloat(coverage);
      var usage = browserslist.usage.global;

      if (statMode) {
        if (statMode.match(/^\s+in\s+my\s+stats$/)) {
          if (!context.customUsage) {
            throw new error('Custom usage statistics was not provided');
          }

          usage = context.customUsage;
        } else {
          var match = statMode.match(/\s+in\s+((alt-)?\w\w)/);
          var place = match[1];

          if (place.length === 2) {
            place = place.toUpperCase();
          } else {
            place = place.toLowerCase();
          }

          node$2.loadCountry(browserslist.usage, place, browserslist.data);
          usage = browserslist.usage[place];
        }
      }

      var versions = Object.keys(usage).sort(function (a, b) {
        return usage[b] - usage[a];
      });
      var coveraged = 0;
      var result = [];
      var version;

      for (var i = 0; i <= versions.length; i++) {
        version = versions[i];
        if (usage[version] === 0) break;
        coveraged += usage[version];
        result.push(version);
        if (coveraged >= coverage) break;
      }

      return result;
    }
  }, {
    regexp: /^supports\s+([\w-]+)$/,
    select: function select(context, feature) {
      node$2.loadFeature(browserslist.cache, feature);
      var features = browserslist.cache[feature];
      return Object.keys(features).reduce(function (result, version) {
        var flags = features[version];

        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var fromToUse = normalizeElectron(from);
      var toToUse = normalizeElectron(to);

      if (!versions[fromToUse]) {
        throw new error('Unknown version ' + from + ' of electron');
      }

      if (!versions[toToUse]) {
        throw new error('Unknown version ' + to + ' of electron');
      }

      from = parseFloat(from);
      to = parseFloat(to);
      return Object.keys(versions).filter(function (i) {
        var parsed = parseFloat(i);
        return parsed >= from && parsed <= to;
      }).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      var semverRegExp = /^(0|[1-9]\d*)(\.(0|[1-9]\d*)){0,2}$/;

      if (!semverRegExp.test(from)) {
        throw new error('Unknown version ' + from + ' of Node.js');
      }

      if (!semverRegExp.test(to)) {
        throw new error('Unknown version ' + to + ' of Node.js');
      }

      return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, name, from, to) {
      var data = checkName(name, context);
      from = parseFloat(normalizeVersion(data, from) || from);
      to = parseFloat(normalizeVersion(data, to) || to);

      function filter(v) {
        var parsed = parseFloat(v);
        return parsed >= from && parsed <= to;
      }

      return data.released.filter(filter).map(nameMapper(data.name));
    }
  }, {
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var versionToUse = normalizeElectron(version);
      return Object.keys(versions).filter(generateFilter(sign, versionToUse)).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function select(context, name, sign, version) {
      var data = checkName(name, context);
      var alias = browserslist.versionAliases[data.name][version];

      if (alias) {
        version = alias;
      }

      return data.released.filter(generateFilter(sign, version)).map(function (v) {
        return data.name + ' ' + v;
      });
    }
  }, {
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function select() {
      return ['firefox 78'];
    }
  }, {
    regexp: /(operamini|op_mini)\s+all/i,
    select: function select() {
      return ['op_mini all'];
    }
  }, {
    regexp: /^electron\s+([\d.]+)$/i,
    select: function select(context, version) {
      var versionToUse = normalizeElectron(version);
      var chrome = versions[versionToUse];

      if (!chrome) {
        throw new error('Unknown version ' + version + ' of electron');
      }

      return ['chrome ' + chrome];
    }
  }, {
    regexp: /^node\s+(\d+(\.\d+)?(\.\d+)?)$/i,
    select: function select(context, version) {
      var nodeReleases = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      });
      var matched = nodeReleases.filter(function (i) {
        return isVersionsMatch(i.version, version);
      });

      if (matched.length === 0) {
        if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new error('Unknown version ' + version + ' of Node.js');
        }
      }

      return ['node ' + matched[matched.length - 1].version];
    }
  }, {
    regexp: /^current\s+node$/i,
    select: function select(context) {
      return [node$2.currentNode(resolve$1, context)];
    }
  }, {
    regexp: /^maintained\s+node\s+versions$/i,
    select: function select(context) {
      var now = Date.now();
      var queries = Object.keys(jsEOL).filter(function (key) {
        return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
      }).map(function (key) {
        return 'node ' + key.slice(1);
      });
      return resolve$1(queries, context);
    }
  }, {
    regexp: /^phantomjs\s+1.9$/i,
    select: function select() {
      return ['safari 5'];
    }
  }, {
    regexp: /^phantomjs\s+2.1$/i,
    select: function select() {
      return ['safari 6'];
    }
  }, {
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function select(context, name, version) {
      if (/^tp$/i.test(version)) version = 'TP';
      var data = checkName(name, context);
      var alias = normalizeVersion(data, version);

      if (alias) {
        version = alias;
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0';
        } else {
          alias = version.replace(/\.0$/, '');
        }

        alias = normalizeVersion(data, alias);

        if (alias) {
          version = alias;
        } else if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new error('Unknown version ' + version + ' of ' + name);
        }
      }

      return [data.name + ' ' + version];
    }
  }, {
    regexp: /^extends (.+)$/i,
    select: function select(context, name) {
      return resolve$1(node$2.loadQueries(context, name), context);
    }
  }, {
    regexp: /^defaults$/i,
    select: function select(context) {
      return resolve$1(browserslist.defaults, context);
    }
  }, {
    regexp: /^dead$/i,
    select: function select(context) {
      var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
      return resolve$1(dead, context);
    }
  }, {
    regexp: /^(\w+)$/i,
    select: function select(context, name) {
      if (byName(name, context)) {
        throw new error('Specify versions in Browserslist query for browser ' + name);
      } else {
        throw unknownQuery(name);
      }
    }
  }];

  (function () {
    for (var name in agents$1) {
      var browser = agents$1[name];
      browserslist.data[name] = {
        name: name,
        versions: normalize(agents$1[name].versions),
        released: normalize(agents$1[name].versions.slice(0, -3)),
        releaseDate: agents$1[name].release_date
      };
      fillUsage(browserslist.usage.global, name, browser.usage_global);
      browserslist.versionAliases[name] = {};

      for (var i = 0; i < browser.versions.length; i++) {
        var full = browser.versions[i];
        if (!full) continue;

        if (full.indexOf('-') !== -1) {
          var interval = full.split('-');

          for (var j = 0; j < interval.length; j++) {
            browserslist.versionAliases[name][interval[j]] = full;
          }
        }
      }
    }

    browserslist.versionAliases.op_mob['59'] = '58';
  })();

  var browserslist_1 = browserslist;

  var min = Math.min;

  function levenshtein(a, b) {
    var t = [],
        u = [],
        i,
        j;
    var m = a.length,
        n = b.length;

    if (!m) {
      return n;
    }

    if (!n) {
      return m;
    }

    for (j = 0; j <= n; j++) {
      t[j] = j;
    }

    for (i = 1; i <= m; i++) {
      for (u = [i], j = 1; j <= n; j++) {
        u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
      }

      t = u;
    }

    return u[n];
  }

  function findSuggestion(str, arr) {
    var distances = arr.map(function (el) {
      return levenshtein(el, str);
    });
    return arr[distances.indexOf(min.apply(void 0, distances))];
  }

  var OptionValidator = function () {
    function OptionValidator(descriptor) {
      this.descriptor = descriptor;
    }

    var _proto = OptionValidator.prototype;

    _proto.validateTopLevelOptions = function validateTopLevelOptions(options, TopLevelOptionShape) {
      var validOptionNames = Object.keys(TopLevelOptionShape);

      for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
        var option = _Object$keys[_i];

        if (!validOptionNames.includes(option)) {
          throw new Error(this.formatMessage("'" + option + "' is not a valid top-level option.\n- Did you mean '" + findSuggestion(option, validOptionNames) + "'?"));
        }
      }
    };

    _proto.validateBooleanOption = function validateBooleanOption(name, value, defaultValue) {
      if (value === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value === "boolean", "'" + name + "' option must be a boolean.");
      }

      return value;
    };

    _proto.validateStringOption = function validateStringOption(name, value, defaultValue) {
      if (value === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value === "string", "'" + name + "' option must be a string.");
      }

      return value;
    };

    _proto.invariant = function invariant(condition, message) {
      if (!condition) {
        throw new Error(this.formatMessage(message));
      }
    };

    _proto.formatMessage = function formatMessage(message) {
      return this.descriptor + ": " + message;
    };

    return OptionValidator;
  }();

  var nativeModules = {
  	"es6.module": {
  	chrome: "61",
  	and_chr: "61",
  	edge: "16",
  	firefox: "60",
  	and_ff: "60",
  	node: "13.2.0",
  	opera: "48",
  	op_mob: "48",
  	safari: "10.1",
  	ios_saf: "10.3",
  	samsung: "8.2",
  	android: "61",
  	electron: "2.0"
  }
  };

  var nativeModules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': nativeModules
  });

  var require$$0$2 = getCjsExportFromNamespace(nativeModules$1);

  var nativeModules$2 = require$$0$2;

  var name$2 = "@babel/helper-compilation-targets";

  var unreleasedLabels = {
    safari: "tp"
  };
  var browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    op_mob: "opera",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };

  var versionRegExp = /^(\d+|\d+.\d+)$/;
  var v = new OptionValidator(name$2);
  function semverMin(first, second) {
    return first && semver$2.lt(first, second) ? first : second;
  }
  function semverify(version) {
    if (typeof version === "string" && semver$2.valid(version)) {
      return version;
    }

    v.invariant(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'" + version + "' is not a valid version");
    var split = version.toString().split(".");

    while (split.length < 3) {
      split.push("0");
    }

    return split.join(".");
  }
  function isUnreleasedVersion(version, env) {
    var unreleasedLabel = unreleasedLabels[env];
    return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
  }
  function getLowestUnreleased(a, b, env) {
    var unreleasedLabel = unreleasedLabels[env];
    var hasUnreleased = [a, b].some(function (item) {
      return item === unreleasedLabel;
    });

    if (hasUnreleased) {
      return a === hasUnreleased ? b : a || b;
    }

    return semverMin(a, b);
  }
  function getLowestImplementedVersion(plugin, environment) {
    var result = plugin[environment];

    if (!result && environment === "android") {
      return plugin.chrome;
    }

    return result;
  }

  var TargetNames = {
    node: "node",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung"
  };

  function prettifyVersion(version) {
    if (typeof version !== "string") {
      return version;
    }

    var parts = [semver$2.major(version)];
    var minor = semver$2.minor(version);
    var patch = semver$2.patch(version);

    if (minor || patch) {
      parts.push(minor);
    }

    if (patch) {
      parts.push(patch);
    }

    return parts.join(".");
  }
  function prettifyTargets(targets) {
    return Object.keys(targets).reduce(function (results, target) {
      var value = targets[target];
      var unreleasedLabel = unreleasedLabels[target];

      if (typeof value === "string" && unreleasedLabel !== value) {
        value = prettifyVersion(value);
      }

      results[target] = value;
      return results;
    }, {});
  }

  function getInclusionReasons(item, targetVersions, list) {
    var minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce(function (result, env) {
      var minVersion = getLowestImplementedVersion(minVersions, env);
      var targetVersion = targetVersions[env];

      if (!minVersion) {
        result[env] = prettifyVersion(targetVersion);
      } else {
        var minIsUnreleased = isUnreleasedVersion(minVersion, env);
        var targetIsUnreleased = isUnreleasedVersion(targetVersion, env);

        if (!targetIsUnreleased && (minIsUnreleased || semver$2.lt(targetVersion.toString(), semverify(minVersion)))) {
          result[env] = prettifyVersion(targetVersion);
        }
      }

      return result;
    }, {});
  }

  var plugins = {
  	"proposal-class-properties": {
  	chrome: "74",
  	opera: "62",
  	edge: "79",
  	node: "12",
  	samsung: "11",
  	electron: "6.0"
  },
  	"proposal-private-methods": {
  	chrome: "84",
  	opera: "70",
  	edge: "84",
  	node: "14.6",
  	electron: "10.0"
  },
  	"proposal-numeric-separator": {
  	chrome: "75",
  	opera: "62",
  	edge: "79",
  	firefox: "70",
  	safari: "13",
  	node: "12.5",
  	ios: "13",
  	samsung: "11",
  	electron: "6.0"
  },
  	"proposal-logical-assignment-operators": {
  	chrome: "85",
  	firefox: "79",
  	safari: "14",
  	node: "15",
  	electron: "10.0"
  },
  	"proposal-nullish-coalescing-operator": {
  	chrome: "80",
  	opera: "67",
  	edge: "80",
  	firefox: "72",
  	safari: "13.1",
  	node: "14",
  	ios: "13.4",
  	samsung: "13",
  	electron: "8.0"
  },
  	"proposal-optional-chaining": {
  	chrome: "80",
  	opera: "67",
  	edge: "80",
  	firefox: "74",
  	safari: "13.1",
  	node: "14",
  	ios: "13.4",
  	samsung: "13",
  	electron: "8.0"
  },
  	"proposal-json-strings": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "62",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"proposal-optional-catch-binding": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "58",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "18",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"proposal-async-generator-functions": {
  	chrome: "63",
  	opera: "50",
  	edge: "79",
  	firefox: "57",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"proposal-object-rest-spread": {
  	chrome: "60",
  	opera: "47",
  	edge: "79",
  	firefox: "55",
  	safari: "11.1",
  	node: "8.3",
  	ios: "11.3",
  	samsung: "8",
  	electron: "2.0"
  },
  	"transform-dotall-regex": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "8.10",
  	ios: "11.3",
  	samsung: "8",
  	electron: "3.0"
  },
  	"proposal-unicode-property-regex": {
  	chrome: "64",
  	opera: "51",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-named-capturing-groups-regex": {
  	chrome: "64",
  	opera: "51",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-async-to-generator": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "11",
  	node: "7.6",
  	ios: "11",
  	samsung: "6",
  	electron: "1.6"
  },
  	"transform-exponentiation-operator": {
  	chrome: "52",
  	opera: "39",
  	edge: "14",
  	firefox: "52",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.3"
  },
  	"transform-template-literals": {
  	chrome: "41",
  	opera: "28",
  	edge: "13",
  	firefox: "34",
  	safari: "13",
  	node: "4",
  	ios: "13",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"transform-literals": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "53",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-arrow-functions": {
  	chrome: "47",
  	opera: "34",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-block-scoped-functions": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "46",
  	safari: "10",
  	node: "4",
  	ie: "11",
  	ios: "10",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"transform-classes": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-object-super": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-shorthand-properties": {
  	chrome: "43",
  	opera: "30",
  	edge: "12",
  	firefox: "33",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.27"
  },
  	"transform-duplicate-keys": {
  	chrome: "42",
  	opera: "29",
  	edge: "12",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.25"
  },
  	"transform-computed-properties": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "34",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-for-of": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-sticky-regex": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "3",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-unicode-escapes": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "53",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-unicode-regex": {
  	chrome: "50",
  	opera: "37",
  	edge: "13",
  	firefox: "46",
  	safari: "12",
  	node: "6",
  	ios: "12",
  	samsung: "5",
  	electron: "1.1"
  },
  	"transform-spread": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "36",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-destructuring": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-block-scoping": {
  	chrome: "49",
  	opera: "36",
  	edge: "14",
  	firefox: "51",
  	safari: "11",
  	node: "6",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-typeof-symbol": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"transform-new-target": {
  	chrome: "46",
  	opera: "33",
  	edge: "14",
  	firefox: "41",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-regenerator": {
  	chrome: "50",
  	opera: "37",
  	edge: "13",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"transform-member-expression-literals": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "2",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"transform-property-literals": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "2",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"transform-reserved-words": {
  	chrome: "13",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4.4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"proposal-export-namespace-from": {
  	chrome: "72",
  	and_chr: "72",
  	edge: "79",
  	firefox: "80",
  	node: "13.2",
  	opera: "60",
  	op_mob: "51",
  	samsung: "11.0",
  	android: "72",
  	electron: "5.0"
  }
  };

  var plugins$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugins
  });

  var require$$0$3 = getCjsExportFromNamespace(plugins$1);

  var plugins$2 = require$$0$3;

  function targetsSupported(target, support) {
    var targetEnvironments = Object.keys(target);

    if (targetEnvironments.length === 0) {
      return false;
    }

    var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
      var lowestImplementedVersion = getLowestImplementedVersion(support, environment);

      if (!lowestImplementedVersion) {
        return true;
      }

      var lowestTargetedVersion = target[environment];

      if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
        return false;
      }

      if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
        return true;
      }

      if (!semver$2.valid(lowestTargetedVersion.toString())) {
        throw new Error("Invalid version passed for target \"" + environment + "\": \"" + lowestTargetedVersion + "\". " + "Versions must be in semver format (major.minor.patch)");
      }

      return semver$2.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
    });
    return unsupportedEnvironments.length === 0;
  }
  function isRequired(name, targets, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$compatData = _ref.compatData,
        compatData = _ref$compatData === void 0 ? plugins$2 : _ref$compatData,
        includes = _ref.includes,
        excludes = _ref.excludes;

    if (excludes == null ? void 0 : excludes.has(name)) return false;
    if (includes == null ? void 0 : includes.has(name)) return true;
    return !targetsSupported(targets, compatData[name]);
  }
  function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    var result = new Set();
    var options = {
      compatData: list,
      includes: includes,
      excludes: excludes
    };

    for (var item in list) {
      if (isRequired(item, targets, options)) {
        result.add(item);
      } else if (pluginSyntaxMap) {
        var shippedProposalsSyntax = pluginSyntaxMap.get(item);

        if (shippedProposalsSyntax) {
          result.add(shippedProposalsSyntax);
        }
      }
    }

    if (defaultIncludes) {
      defaultIncludes.forEach(function (item) {
        return !excludes.has(item) && result.add(item);
      });
    }

    if (defaultExcludes) {
      defaultExcludes.forEach(function (item) {
        return !includes.has(item) && result["delete"](item);
      });
    }

    return result;
  }

  var v$1 = new OptionValidator(name$2);
  var browserslistDefaults = browserslist_1.defaults;

  function validateTargetNames(targets) {
    var validTargets = Object.keys(TargetNames);

    for (var _i = 0, _Object$keys = Object.keys(targets); _i < _Object$keys.length; _i++) {
      var target = _Object$keys[_i];

      if (!(target in TargetNames)) {
        throw new Error(v$1.formatMessage("'" + target + "' is not a valid target\n- Did you mean '" + findSuggestion(target, validTargets) + "'?"));
      }
    }

    return targets;
  }

  function isBrowsersQueryValid(browsers) {
    return typeof browsers === "string" || Array.isArray(browsers);
  }

  function validateBrowsers(browsers) {
    v$1.invariant(browsers === undefined || isBrowsersQueryValid(browsers), "'" + String(browsers) + "' is not a valid browserslist query");
    return browsers;
  }

  function getLowestVersions(browsers) {
    return browsers.reduce(function (all, browser) {
      var _browser$split = browser.split(" "),
          browserName = _browser$split[0],
          browserVersion = _browser$split[1];

      var normalizedBrowserName = browserNameMap[browserName];

      if (!normalizedBrowserName) {
        return all;
      }

      try {
        var splitVersion = browserVersion.split("-")[0].toLowerCase();
        var isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);

        if (!all[normalizedBrowserName]) {
          all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
          return all;
        }

        var version = all[normalizedBrowserName];
        var isUnreleased = isUnreleasedVersion(version, browserName);

        if (isUnreleased && isSplitUnreleased) {
          all[normalizedBrowserName] = getLowestUnreleased(version, splitVersion, browserName);
        } else if (isUnreleased) {
          all[normalizedBrowserName] = semverify(splitVersion);
        } else if (!isUnreleased && !isSplitUnreleased) {
          var parsedBrowserVersion = semverify(splitVersion);
          all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
        }
      } catch (e) {}

      return all;
    }, {});
  }

  function outputDecimalWarning(decimalTargets) {
    if (!decimalTargets.length) {
      return;
    }

    console.warn("Warning, the following targets are using a decimal version:\n");
    decimalTargets.forEach(function (_ref) {
      var target = _ref.target,
          value = _ref.value;
      return console.warn("  " + target + ": " + value);
    });
    console.warn("\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n");
  }

  function semverifyTarget(target, value) {
    try {
      return semverify(value);
    } catch (error) {
      throw new Error(v$1.formatMessage("'" + value + "' is not a valid value for 'targets." + target + "'."));
    }
  }

  var targetParserMap = {
    __default: function __default(target, value) {
      var version = isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
      return [target, version];
    },
    node: function node(target, value) {
      var parsed = value === true || value === "current" ? process.versions.node : semverifyTarget(target, value);
      return [target, parsed];
    }
  };

  function generateTargets(inputTargets) {
    var input = Object.assign({}, inputTargets);
    delete input.esmodules;
    delete input.browsers;
    return input;
  }

  function getTargets(inputTargets, options) {
    if (inputTargets === void 0) {
      inputTargets = {};
    }

    if (options === void 0) {
      options = {};
    }

    var _inputTargets = inputTargets,
        browsers = _inputTargets.browsers;

    if (inputTargets.esmodules) {
      var supportsESModules = nativeModules$2["es6.module"];
      browsers = Object.keys(supportsESModules).map(function (browser) {
        return browser + " " + supportsESModules[browser];
      }).join(", ");
    }

    var browsersquery = validateBrowsers(browsers);
    var input = generateTargets(inputTargets);
    var targets = validateTargetNames(input);
    var shouldParseBrowsers = !!browsersquery;
    var hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
    var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

    if (shouldParseBrowsers || shouldSearchForConfig) {
      if (!hasTargets) {
        browserslist_1.defaults = [];
      }

      var _browsers = browserslist_1(browsersquery, {
        path: options.configPath,
        mobileToDesktop: true,
        env: options.browserslistEnv
      });

      var queryBrowsers = getLowestVersions(_browsers);
      targets = Object.assign(queryBrowsers, targets);
      browserslist_1.defaults = browserslistDefaults;
    }

    var result = {};
    var decimalWarnings = [];

    for (var _iterator = _createForOfIteratorHelperLoose(Object.keys(targets).sort()), _step; !(_step = _iterator()).done;) {
      var _targetParserMap$targ;

      var target = _step.value;
      var value = targets[target];

      if (typeof value === "number" && value % 1 !== 0) {
        decimalWarnings.push({
          target: target,
          value: value
        });
      }

      var parser = (_targetParserMap$targ = targetParserMap[target]) != null ? _targetParserMap$targ : targetParserMap.__default;

      var _parser = parser(target, value),
          parsedTarget = _parser[0],
          parsedValue = _parser[1];

      if (parsedValue) {
        result[parsedTarget] = parsedValue;
      }
    }

    outputDecimalWarning(decimalWarnings);
    return result;
  }

  var wordEnds = function wordEnds(size) {
    return size > 1 ? "s" : "";
  };

  var logPluginOrPolyfill = function logPluginOrPolyfill(item, targetVersions, list) {
    var filteredList = getInclusionReasons(item, targetVersions, list);
    var formattedTargets = JSON.stringify(filteredList).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
    console.log("  " + item + " " + formattedTargets);
  };
  var logEntryPolyfills = function logEntryPolyfills(polyfillName, importPolyfillIncluded, polyfills, filename, polyfillTargets, allBuiltInsList) {
    if (process.env.BABEL_ENV === "test") {
      filename = filename.replace(/\\/g, "/");
    }

    if (!importPolyfillIncluded) {
      console.log("\n[" + filename + "] Import of " + polyfillName + " was not found.");
      return;
    }

    if (!polyfills.size) {
      console.log("\n[" + filename + "] Based on your targets, polyfills were not added.");
      return;
    }

    console.log("\n[" + filename + "] Replaced " + polyfillName + " entries with the following polyfill" + wordEnds(polyfills.size) + ":");

    for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
      var polyfill = _step.value;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  };
  var logUsagePolyfills = function logUsagePolyfills(polyfills, filename, polyfillTargets, allBuiltInsList) {
    if (process.env.BABEL_ENV === "test") {
      filename = filename.replace(/\\/g, "/");
    }

    if (!polyfills.size) {
      console.log("\n[" + filename + "] Based on your code and targets, core-js polyfills were not added.");
      return;
    }

    console.log("\n[" + filename + "] Added following core-js polyfill" + wordEnds(polyfills.size) + ":");

    for (var _iterator2 = _createForOfIteratorHelperLoose(polyfills), _step2; !(_step2 = _iterator2()).done;) {
      var polyfill = _step2.value;
      logPluginOrPolyfill(polyfill, polyfillTargets, allBuiltInsList);
    }
  };

  var defaultExcludesForLooseMode = ["transform-typeof-symbol"];
  function getOptionSpecificExcludesFor (_ref) {
    var loose = _ref.loose;
    return loose ? defaultExcludesForLooseMode : null;
  }

  function removeUnnecessaryItems(items, overlapping) {
    items.forEach(function (item) {
      var _overlapping$item;

      (_overlapping$item = overlapping[item]) == null ? void 0 : _overlapping$item.forEach(function (name) {
        return items["delete"](name);
      });
    });
  }

  var moduleTransformations = {
    auto: "transform-modules-commonjs",
    amd: "transform-modules-amd",
    commonjs: "transform-modules-commonjs",
    cjs: "transform-modules-commonjs",
    systemjs: "transform-modules-systemjs",
    umd: "transform-modules-umd"
  };

  var corejs3Polyfills = {
  	"es.symbol": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.description": {
  	android: "70",
  	chrome: "70",
  	edge: "74",
  	electron: "5.0",
  	firefox: "63",
  	ios: "12.2",
  	node: "11.0",
  	opera: "57",
  	opera_mobile: "49",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"es.symbol.async-iterator": {
  	android: "63",
  	chrome: "63",
  	edge: "74",
  	electron: "3.0",
  	firefox: "55",
  	ios: "12.0",
  	node: "10.0",
  	opera: "50",
  	opera_mobile: "46",
  	safari: "12.0",
  	samsung: "8.0"
  },
  	"es.symbol.has-instance": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.is-concat-spreadable": {
  	android: "48",
  	chrome: "48",
  	edge: "15",
  	electron: "0.37",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.0",
  	opera: "35",
  	opera_mobile: "35",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.iterator": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "36",
  	ios: "9.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.symbol.match": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.match-all": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.symbol.replace": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.search": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.species": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "41",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.split": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.to-primitive": {
  	android: "47",
  	chrome: "47",
  	edge: "15",
  	electron: "0.36",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.to-string-tag": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.unscopables": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "48",
  	ios: "9.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.aggregate-error": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0"
  },
  	"es.array.concat": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.copy-within": {
  	android: "45",
  	chrome: "45",
  	edge: "12",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.every": {
  	android: "48",
  	chrome: "48",
  	edge: "15",
  	electron: "0.37",
  	firefox: "50",
  	ios: "9.0",
  	node: "6.0",
  	opera: "35",
  	opera_mobile: "35",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.fill": {
  	android: "45",
  	chrome: "45",
  	edge: "12",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.filter": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.find": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.find-index": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.flat": {
  	android: "69",
  	chrome: "69",
  	edge: "74",
  	electron: "4.0",
  	firefox: "62",
  	ios: "12.0",
  	node: "11.0",
  	opera: "56",
  	opera_mobile: "48",
  	safari: "12.0",
  	samsung: "10.0"
  },
  	"es.array.flat-map": {
  	android: "69",
  	chrome: "69",
  	edge: "74",
  	electron: "4.0",
  	firefox: "62",
  	ios: "12.0",
  	node: "11.0",
  	opera: "56",
  	opera_mobile: "48",
  	safari: "12.0",
  	samsung: "10.0"
  },
  	"es.array.for-each": {
  	android: "48",
  	chrome: "48",
  	edge: "15",
  	electron: "0.37",
  	firefox: "50",
  	ios: "9.0",
  	node: "6.0",
  	opera: "35",
  	opera_mobile: "35",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.from": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "9.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.includes": {
  	android: "53",
  	chrome: "53",
  	edge: "15",
  	electron: "1.4",
  	firefox: "48",
  	ios: "10.0",
  	node: "7.0",
  	opera: "40",
  	opera_mobile: "40",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.array.index-of": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "50",
  	ios: "11.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "11.0",
  	samsung: "5.0"
  },
  	"es.array.is-array": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.array.iterator": {
  	android: "66",
  	chrome: "66",
  	edge: "15",
  	electron: "3.0",
  	firefox: "60",
  	ios: "10.0",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "10.0",
  	samsung: "9.0"
  },
  	"es.array.join": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "4",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.array.last-index-of": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "50",
  	ios: "11.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "11.0",
  	samsung: "5.0"
  },
  	"es.array.map": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "50",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "25",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.reduce": {
  	android: "83",
  	chrome: "83",
  	edge: "15",
  	electron: "9.0",
  	firefox: "50",
  	ios: "9.0",
  	node: "6.0",
  	opera: "69",
  	opera_mobile: "59",
  	safari: "9.0",
  	samsung: "13.0"
  },
  	"es.array.reduce-right": {
  	android: "83",
  	chrome: "83",
  	edge: "15",
  	electron: "9.0",
  	firefox: "50",
  	ios: "9.0",
  	node: "6.0",
  	opera: "69",
  	opera_mobile: "59",
  	safari: "9.0",
  	samsung: "13.0"
  },
  	"es.array.reverse": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "5.5",
  	ios: "12.2",
  	node: "0.0.3",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	safari: "12.0.2",
  	samsung: "1.0"
  },
  	"es.array.slice": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "48",
  	ios: "11.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "11.0",
  	samsung: "5.0"
  },
  	"es.array.some": {
  	android: "48",
  	chrome: "48",
  	edge: "15",
  	electron: "0.37",
  	firefox: "50",
  	ios: "9.0",
  	node: "6.0",
  	opera: "35",
  	opera_mobile: "35",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.sort": {
  	android: "63",
  	chrome: "63",
  	edge: "12",
  	electron: "3.0",
  	firefox: "4",
  	ie: "9",
  	ios: "12.0",
  	node: "10.0",
  	opera: "50",
  	opera_mobile: "46",
  	safari: "12.0",
  	samsung: "8.0"
  },
  	"es.array.species": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.splice": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "49",
  	ios: "11.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "11.0",
  	samsung: "5.0"
  },
  	"es.array.unscopables.flat": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.array.unscopables.flat-map": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.array-buffer.constructor": {
  	android: "4.4",
  	chrome: "26",
  	edge: "14",
  	electron: "0.20",
  	firefox: "44",
  	ios: "12.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "12.0",
  	samsung: "1.5"
  },
  	"es.array-buffer.is-view": {
  	android: "4.4.3",
  	chrome: "32",
  	edge: "12",
  	electron: "0.20",
  	firefox: "29",
  	ie: "11",
  	ios: "8.0",
  	node: "0.11.9",
  	opera: "19",
  	opera_mobile: "19",
  	safari: "7.1",
  	samsung: "2.0"
  },
  	"es.array-buffer.slice": {
  	android: "4.4.3",
  	chrome: "31",
  	edge: "12",
  	electron: "0.20",
  	firefox: "46",
  	ie: "11",
  	ios: "12.2",
  	node: "0.11.8",
  	opera: "18",
  	opera_mobile: "18",
  	safari: "12.1",
  	samsung: "2.0"
  },
  	"es.data-view": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "15",
  	ie: "10",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.date.now": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.date.to-iso-string": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "7",
  	ie: "9",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.date.to-json": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "10.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "10.0",
  	samsung: "1.5"
  },
  	"es.date.to-primitive": {
  	android: "47",
  	chrome: "47",
  	edge: "15",
  	electron: "0.36",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.date.to-string": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ie: "9",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.function.bind": {
  	android: "3.0",
  	chrome: "7",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.101",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.function.has-instance": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "50",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.function.name": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.global-this": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "65",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"es.json.stringify": {
  	android: "72",
  	chrome: "72",
  	edge: "74",
  	electron: "5.0",
  	firefox: "64",
  	ios: "12.2",
  	node: "12.0",
  	opera: "59",
  	opera_mobile: "51",
  	safari: "12.1",
  	samsung: "11.0"
  },
  	"es.json.to-string-tag": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.map": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.math.acosh": {
  	android: "54",
  	chrome: "54",
  	edge: "13",
  	electron: "1.4",
  	firefox: "25",
  	ios: "8.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "7.1",
  	samsung: "6.0"
  },
  	"es.math.asinh": {
  	android: "38",
  	chrome: "38",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.atanh": {
  	android: "38",
  	chrome: "38",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.cbrt": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.clz32": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.math.cosh": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.expm1": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "46",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.fround": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "26",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.hypot": {
  	android: "78",
  	chrome: "78",
  	edge: "12",
  	electron: "7.0",
  	firefox: "27",
  	ios: "8.0",
  	node: "13.0",
  	opera: "65",
  	opera_mobile: "56",
  	safari: "7.1",
  	samsung: "12.0"
  },
  	"es.math.imul": {
  	android: "4.4",
  	chrome: "28",
  	edge: "13",
  	electron: "0.20",
  	firefox: "20",
  	ios: "9.0",
  	node: "0.11.1",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.math.log10": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.log1p": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.log2": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.sign": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "9.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.math.sinh": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.tanh": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.to-string-tag": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.math.trunc": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.number.constructor": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "46",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.number.epsilon": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.is-finite": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "16",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.number.is-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "16",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.is-nan": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "15",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.number.is-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "32",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.max-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.min-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.parse-float": {
  	android: "37",
  	chrome: "35",
  	edge: "13",
  	electron: "0.20",
  	firefox: "39",
  	ios: "11.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "11.0",
  	samsung: "3.0"
  },
  	"es.number.parse-int": {
  	android: "37",
  	chrome: "35",
  	edge: "13",
  	electron: "0.20",
  	firefox: "39",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.number.to-fixed": {
  	android: "4.4",
  	chrome: "26",
  	edge: "74",
  	electron: "0.20",
  	firefox: "4",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.number.to-precision": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "8",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.object.assign": {
  	android: "49",
  	chrome: "49",
  	edge: "74",
  	electron: "0.37",
  	firefox: "36",
  	ios: "9.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.object.create": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "1.9",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.object.define-getter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.define-properties": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.object.define-property": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.object.define-setter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.entries": {
  	android: "54",
  	chrome: "54",
  	edge: "14",
  	electron: "1.4",
  	firefox: "47",
  	ios: "10.3",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.1",
  	samsung: "6.0"
  },
  	"es.object.freeze": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.from-entries": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "63",
  	ios: "12.2",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "12.1",
  	samsung: "11.0"
  },
  	"es.object.get-own-property-descriptor": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.get-own-property-descriptors": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "50",
  	ios: "10.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.object.get-own-property-names": {
  	android: "40",
  	chrome: "40",
  	edge: "13",
  	electron: "0.21",
  	firefox: "34",
  	ios: "9.0",
  	node: "1.0",
  	opera: "27",
  	opera_mobile: "27",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.object.get-prototype-of": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "22",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.object.is-extensible": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is-frozen": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is-sealed": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.keys": {
  	android: "40",
  	chrome: "40",
  	edge: "13",
  	electron: "0.21",
  	firefox: "35",
  	ios: "9.0",
  	node: "1.0",
  	opera: "27",
  	opera_mobile: "27",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.object.lookup-getter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.lookup-setter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.prevent-extensions": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.seal": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.set-prototype-of": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ie: "11",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.object.to-string": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.object.values": {
  	android: "54",
  	chrome: "54",
  	edge: "14",
  	electron: "1.4",
  	firefox: "47",
  	ios: "10.3",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.1",
  	samsung: "6.0"
  },
  	"es.parse-float": {
  	android: "37",
  	chrome: "35",
  	edge: "12",
  	electron: "0.20",
  	firefox: "8",
  	ie: "8",
  	ios: "8.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.parse-int": {
  	android: "37",
  	chrome: "35",
  	edge: "12",
  	electron: "0.20",
  	firefox: "21",
  	ie: "9",
  	ios: "8.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.promise": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "69",
  	ios: "11.0",
  	node: "10.4",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "11.0",
  	samsung: "9.0"
  },
  	"es.promise.all-settled": {
  	android: "76",
  	chrome: "76",
  	edge: "76",
  	electron: "6.0",
  	firefox: "71",
  	ios: "13.0",
  	node: "12.9",
  	opera: "63",
  	opera_mobile: "54",
  	safari: "13",
  	samsung: "12.0"
  },
  	"es.promise.any": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0"
  },
  	"es.promise.finally": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "69",
  	ios: "13.2.3",
  	node: "10.4",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "13.0.3",
  	samsung: "9.0"
  },
  	"es.reflect.apply": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.construct": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.define-property": {
  	android: "49",
  	chrome: "49",
  	edge: "13",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.delete-property": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get-own-property-descriptor": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get-prototype-of": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.has": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.is-extensible": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.own-keys": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.prevent-extensions": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.set": {
  	android: "49",
  	chrome: "49",
  	edge: "74",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.set-prototype-of": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.to-string-tag": {
  	android: "86",
  	chrome: "86",
  	edge: "86",
  	electron: "11.0",
  	firefox: "82",
  	ios: "14.0",
  	node: "15.0",
  	opera: "72",
  	safari: "14.0"
  },
  	"es.regexp.constructor": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.regexp.exec": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "44",
  	ios: "10.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "10.0",
  	samsung: "1.5"
  },
  	"es.regexp.flags": {
  	android: "49",
  	chrome: "49",
  	edge: "74",
  	electron: "0.37",
  	firefox: "37",
  	ios: "9.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.regexp.sticky": {
  	android: "49",
  	chrome: "49",
  	edge: "13",
  	electron: "0.37",
  	firefox: "3",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.regexp.test": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "46",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.regexp.to-string": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "46",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.set": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.code-point-at": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "29",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.ends-with": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.from-code-point": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "29",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.includes": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.iterator": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "36",
  	ios: "9.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.match": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.match-all": {
  	android: "80",
  	chrome: "80",
  	edge: "80",
  	electron: "8.0",
  	firefox: "73",
  	ios: "13.4",
  	node: "14.0",
  	opera: "67",
  	opera_mobile: "57",
  	safari: "13.1",
  	samsung: "13.0"
  },
  	"es.string.pad-end": {
  	android: "57",
  	chrome: "57",
  	edge: "15",
  	electron: "1.7",
  	firefox: "48",
  	ios: "11.0",
  	node: "8.0",
  	opera: "44",
  	opera_mobile: "43",
  	safari: "11.0",
  	samsung: "7.0"
  },
  	"es.string.pad-start": {
  	android: "57",
  	chrome: "57",
  	edge: "15",
  	electron: "1.7",
  	firefox: "48",
  	ios: "11.0",
  	node: "8.0",
  	opera: "44",
  	opera_mobile: "43",
  	safari: "11.0",
  	samsung: "7.0"
  },
  	"es.string.raw": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "34",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.repeat": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "24",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.replace": {
  	android: "64",
  	chrome: "64",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "14.0",
  	node: "10.0",
  	opera: "51",
  	opera_mobile: "47",
  	safari: "14.0",
  	samsung: "9.0"
  },
  	"es.string.replace-all": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "77",
  	ios: "13.4",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "13.1"
  },
  	"es.string.search": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.split": {
  	android: "54",
  	chrome: "54",
  	edge: "74",
  	electron: "1.4",
  	firefox: "49",
  	ios: "10.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.string.starts-with": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.trim": {
  	android: "59",
  	chrome: "59",
  	edge: "15",
  	electron: "1.8",
  	firefox: "52",
  	ios: "12.2",
  	node: "8.3",
  	opera: "46",
  	opera_mobile: "43",
  	safari: "12.1",
  	samsung: "7.0"
  },
  	"es.string.trim-end": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "61",
  	ios: "12.2",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "12.1",
  	samsung: "9.0"
  },
  	"es.string.trim-start": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "61",
  	ios: "12.0",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "12.0",
  	samsung: "9.0"
  },
  	"es.string.anchor": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.big": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.blink": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.bold": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.fixed": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.fontcolor": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.fontsize": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.italics": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.link": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.small": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.strike": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.sub": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.sup": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.typed-array.float32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.float64-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.int8-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.int16-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.int32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.uint8-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.uint8-clamped-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.uint16-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.uint32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.copy-within": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "34",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.every": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.fill": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.filter": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.find": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.find-index": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.for-each": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.from": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.includes": {
  	android: "49",
  	chrome: "49",
  	edge: "14",
  	electron: "0.37",
  	firefox: "43",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.index-of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.iterator": {
  	android: "47",
  	chrome: "47",
  	edge: "13",
  	electron: "0.36",
  	firefox: "37",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.join": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.last-index-of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.map": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.of": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	samsung: "6.0"
  },
  	"es.typed-array.reduce": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.reduce-right": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.reverse": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.set": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "15",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.typed-array.slice": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.some": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.sort": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "46",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.subarray": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "15",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.typed-array.to-locale-string": {
  	android: "45",
  	chrome: "45",
  	edge: "74",
  	electron: "0.31",
  	firefox: "51",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.to-string": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.weak-map": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.weak-set": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"esnext.aggregate-error": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0"
  },
  	"esnext.array.at": {
  },
  	"esnext.array.filter-out": {
  },
  	"esnext.array.is-template-object": {
  },
  	"esnext.array.last-index": {
  },
  	"esnext.array.last-item": {
  },
  	"esnext.array.unique-by": {
  },
  	"esnext.async-iterator.constructor": {
  },
  	"esnext.async-iterator.as-indexed-pairs": {
  },
  	"esnext.async-iterator.drop": {
  },
  	"esnext.async-iterator.every": {
  },
  	"esnext.async-iterator.filter": {
  },
  	"esnext.async-iterator.find": {
  },
  	"esnext.async-iterator.flat-map": {
  },
  	"esnext.async-iterator.for-each": {
  },
  	"esnext.async-iterator.from": {
  },
  	"esnext.async-iterator.map": {
  },
  	"esnext.async-iterator.reduce": {
  },
  	"esnext.async-iterator.some": {
  },
  	"esnext.async-iterator.take": {
  },
  	"esnext.async-iterator.to-array": {
  },
  	"esnext.bigint.range": {
  },
  	"esnext.composite-key": {
  },
  	"esnext.composite-symbol": {
  },
  	"esnext.global-this": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "65",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"esnext.iterator.constructor": {
  },
  	"esnext.iterator.as-indexed-pairs": {
  },
  	"esnext.iterator.drop": {
  },
  	"esnext.iterator.every": {
  },
  	"esnext.iterator.filter": {
  },
  	"esnext.iterator.find": {
  },
  	"esnext.iterator.flat-map": {
  },
  	"esnext.iterator.for-each": {
  },
  	"esnext.iterator.from": {
  },
  	"esnext.iterator.map": {
  },
  	"esnext.iterator.reduce": {
  },
  	"esnext.iterator.some": {
  },
  	"esnext.iterator.take": {
  },
  	"esnext.iterator.to-array": {
  },
  	"esnext.map.delete-all": {
  },
  	"esnext.map.emplace": {
  },
  	"esnext.map.every": {
  },
  	"esnext.map.filter": {
  },
  	"esnext.map.find": {
  },
  	"esnext.map.find-key": {
  },
  	"esnext.map.from": {
  },
  	"esnext.map.group-by": {
  },
  	"esnext.map.includes": {
  },
  	"esnext.map.key-by": {
  },
  	"esnext.map.key-of": {
  },
  	"esnext.map.map-keys": {
  },
  	"esnext.map.map-values": {
  },
  	"esnext.map.merge": {
  },
  	"esnext.map.of": {
  },
  	"esnext.map.reduce": {
  },
  	"esnext.map.some": {
  },
  	"esnext.map.update": {
  },
  	"esnext.map.update-or-insert": {
  },
  	"esnext.map.upsert": {
  },
  	"esnext.math.clamp": {
  },
  	"esnext.math.deg-per-rad": {
  },
  	"esnext.math.degrees": {
  },
  	"esnext.math.fscale": {
  },
  	"esnext.math.iaddh": {
  },
  	"esnext.math.imulh": {
  },
  	"esnext.math.isubh": {
  },
  	"esnext.math.rad-per-deg": {
  },
  	"esnext.math.radians": {
  },
  	"esnext.math.scale": {
  },
  	"esnext.math.seeded-prng": {
  },
  	"esnext.math.signbit": {
  },
  	"esnext.math.umulh": {
  },
  	"esnext.number.from-string": {
  },
  	"esnext.number.range": {
  },
  	"esnext.object.iterate-entries": {
  },
  	"esnext.object.iterate-keys": {
  },
  	"esnext.object.iterate-values": {
  },
  	"esnext.observable": {
  },
  	"esnext.promise.all-settled": {
  	android: "76",
  	chrome: "76",
  	edge: "76",
  	electron: "6.0",
  	firefox: "71",
  	ios: "13.0",
  	node: "12.9",
  	opera: "63",
  	opera_mobile: "54",
  	safari: "13",
  	samsung: "12.0"
  },
  	"esnext.promise.any": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0"
  },
  	"esnext.promise.try": {
  },
  	"esnext.reflect.define-metadata": {
  },
  	"esnext.reflect.delete-metadata": {
  },
  	"esnext.reflect.get-metadata": {
  },
  	"esnext.reflect.get-metadata-keys": {
  },
  	"esnext.reflect.get-own-metadata": {
  },
  	"esnext.reflect.get-own-metadata-keys": {
  },
  	"esnext.reflect.has-metadata": {
  },
  	"esnext.reflect.has-own-metadata": {
  },
  	"esnext.reflect.metadata": {
  },
  	"esnext.set.add-all": {
  },
  	"esnext.set.delete-all": {
  },
  	"esnext.set.difference": {
  },
  	"esnext.set.every": {
  },
  	"esnext.set.filter": {
  },
  	"esnext.set.find": {
  },
  	"esnext.set.from": {
  },
  	"esnext.set.intersection": {
  },
  	"esnext.set.is-disjoint-from": {
  },
  	"esnext.set.is-subset-of": {
  },
  	"esnext.set.is-superset-of": {
  },
  	"esnext.set.join": {
  },
  	"esnext.set.map": {
  },
  	"esnext.set.of": {
  },
  	"esnext.set.reduce": {
  },
  	"esnext.set.some": {
  },
  	"esnext.set.symmetric-difference": {
  },
  	"esnext.set.union": {
  },
  	"esnext.string.at": {
  },
  	"esnext.string.code-points": {
  },
  	"esnext.string.match-all": {
  	android: "80",
  	chrome: "80",
  	edge: "80",
  	electron: "8.0",
  	firefox: "73",
  	ios: "13.4",
  	node: "14.0",
  	opera: "67",
  	opera_mobile: "57",
  	safari: "13.1",
  	samsung: "13.0"
  },
  	"esnext.string.replace-all": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "77",
  	ios: "13.4",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "13.1"
  },
  	"esnext.symbol.async-dispose": {
  },
  	"esnext.symbol.dispose": {
  },
  	"esnext.symbol.observable": {
  },
  	"esnext.symbol.pattern-match": {
  },
  	"esnext.symbol.replace-all": {
  },
  	"esnext.typed-array.at": {
  },
  	"esnext.typed-array.filter-out": {
  },
  	"esnext.weak-map.delete-all": {
  },
  	"esnext.weak-map.from": {
  },
  	"esnext.weak-map.of": {
  },
  	"esnext.weak-map.emplace": {
  },
  	"esnext.weak-map.upsert": {
  },
  	"esnext.weak-set.add-all": {
  },
  	"esnext.weak-set.delete-all": {
  },
  	"esnext.weak-set.from": {
  },
  	"esnext.weak-set.of": {
  },
  	"web.dom-collections.for-each": {
  	android: "58",
  	chrome: "58",
  	edge: "16",
  	electron: "1.7",
  	firefox: "50",
  	ios: "10.0",
  	node: "0.0.1",
  	opera: "45",
  	opera_mobile: "43",
  	safari: "10.0",
  	samsung: "7.0"
  },
  	"web.dom-collections.iterator": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "60",
  	ios: "13.4",
  	node: "0.0.1",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "13.1",
  	samsung: "9.0"
  },
  	"web.immediate": {
  	ie: "10",
  	node: "0.9.1"
  },
  	"web.queue-microtask": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "69",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"web.timers": {
  	android: "1.5",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "10",
  	ios: "1.0",
  	node: "0.0.1",
  	opera: "7",
  	opera_mobile: "7",
  	phantom: "1.9",
  	safari: "1.0",
  	samsung: "1.0"
  },
  	"web.url": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "57",
  	node: "10.0",
  	opera: "54",
  	opera_mobile: "48",
  	samsung: "9.0"
  },
  	"web.url.to-json": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "57",
  	node: "10.0",
  	opera: "58",
  	opera_mobile: "50",
  	samsung: "10.0"
  },
  	"web.url-search-params": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "57",
  	node: "10.0",
  	opera: "54",
  	opera_mobile: "48",
  	samsung: "9.0"
  }
  };

  var corejs2BuiltIns = {
  	"es6.array.copy-within": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "32",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.every": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.fill": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "31",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.filter": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.find": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.find-index": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es7.array.flat-map": {
  	chrome: "69",
  	opera: "56",
  	edge: "79",
  	firefox: "62",
  	safari: "12",
  	node: "11",
  	ios: "12",
  	samsung: "10",
  	electron: "4.0"
  },
  	"es6.array.for-each": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.from": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "36",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.array.includes": {
  	chrome: "47",
  	opera: "34",
  	edge: "14",
  	firefox: "43",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"es6.array.index-of": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.is-array": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.iterator": {
  	chrome: "66",
  	opera: "53",
  	edge: "12",
  	firefox: "60",
  	safari: "9",
  	node: "10",
  	ios: "9",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es6.array.last-index-of": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.map": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.of": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.reduce": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.reduce-right": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.some": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.sort": {
  	chrome: "63",
  	opera: "50",
  	edge: "12",
  	firefox: "5",
  	safari: "12",
  	node: "10",
  	ie: "9",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.array.species": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.date.now": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-iso-string": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3.5",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-json": {
  	chrome: "5",
  	opera: "12.10",
  	edge: "12",
  	firefox: "4",
  	safari: "10",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "10",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-primitive": {
  	chrome: "47",
  	opera: "34",
  	edge: "15",
  	firefox: "44",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"es6.date.to-string": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.function.bind": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.function.has-instance": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "50",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.function.name": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "14",
  	firefox: "2",
  	safari: "4",
  	node: "0.10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.map": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.math.acosh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.asinh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.atanh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.cbrt": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.clz32": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.cosh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.expm1": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.fround": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "26",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.hypot": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "27",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.imul": {
  	chrome: "30",
  	opera: "17",
  	edge: "12",
  	firefox: "23",
  	safari: "7",
  	node: "0.12",
  	android: "4.4",
  	ios: "7",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.math.log1p": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.log10": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.log2": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.sign": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.sinh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.tanh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.trunc": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.number.constructor": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.number.epsilon": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.is-finite": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "16",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.number.is-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "16",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.is-nan": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "15",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.number.is-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "32",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.max-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.min-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.parse-float": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.parse-int": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.object.assign": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "36",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.object.create": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.object.define-getter": {
  	chrome: "62",
  	opera: "49",
  	edge: "16",
  	firefox: "48",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es7.object.define-setter": {
  	chrome: "62",
  	opera: "49",
  	edge: "16",
  	firefox: "48",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.object.define-property": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.object.define-properties": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.object.entries": {
  	chrome: "54",
  	opera: "41",
  	edge: "14",
  	firefox: "47",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.object.freeze": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.get-own-property-descriptor": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es7.object.get-own-property-descriptors": {
  	chrome: "54",
  	opera: "41",
  	edge: "15",
  	firefox: "50",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.object.get-own-property-names": {
  	chrome: "40",
  	opera: "27",
  	edge: "12",
  	firefox: "33",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.object.get-prototype-of": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es7.object.lookup-getter": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "36",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es7.object.lookup-setter": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "36",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.object.prevent-extensions": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.to-string": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "51",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es6.object.is": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "22",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.object.is-frozen": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.is-sealed": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.is-extensible": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.keys": {
  	chrome: "40",
  	opera: "27",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.object.seal": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.set-prototype-of": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ie: "11",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es7.object.values": {
  	chrome: "54",
  	opera: "41",
  	edge: "14",
  	firefox: "47",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.promise": {
  	chrome: "51",
  	opera: "38",
  	edge: "14",
  	firefox: "45",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.promise.finally": {
  	chrome: "63",
  	opera: "50",
  	edge: "18",
  	firefox: "58",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.reflect.apply": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.construct": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.define-property": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.delete-property": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get-own-property-descriptor": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get-prototype-of": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.has": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.is-extensible": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.own-keys": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.prevent-extensions": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.set": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.set-prototype-of": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.regexp.constructor": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "40",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.flags": {
  	chrome: "49",
  	opera: "36",
  	edge: "79",
  	firefox: "37",
  	safari: "9",
  	node: "6",
  	ios: "9",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.regexp.match": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.replace": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.split": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.search": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.to-string": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "39",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.set": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.symbol": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "51",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.symbol.async-iterator": {
  	chrome: "63",
  	opera: "50",
  	edge: "79",
  	firefox: "57",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.string.anchor": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.big": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.blink": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.bold": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.code-point-at": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.ends-with": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.fixed": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.fontcolor": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.fontsize": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.from-code-point": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.includes": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "40",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.italics": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.iterator": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.string.link": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.string.pad-start": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "48",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es7.string.pad-end": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "48",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es6.string.raw": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.repeat": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "24",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.small": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.starts-with": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.strike": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.sub": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.sup": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.trim": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3.5",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.string.trim-left": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "61",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es7.string.trim-right": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "61",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es6.typed.array-buffer": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.data-view": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "15",
  	safari: "5.1",
  	node: "0.10",
  	ie: "10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.typed.int8-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint8-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint8-clamped-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.int16-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint16-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.int32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.float32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.float64-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.weak-map": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "9",
  	node: "6.5",
  	ios: "9",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.weak-set": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "9",
  	node: "6.5",
  	ios: "9",
  	samsung: "5",
  	electron: "1.2"
  }
  };

  var corejs2BuiltIns$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': corejs2BuiltIns
  });

  var require$$0$4 = getCjsExportFromNamespace(corejs2BuiltIns$1);

  var corejs2BuiltIns$2 = require$$0$4;

  var pluginBugfixes = {
  	"transform-async-to-generator": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "10.1",
  	node: "7.6",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.6"
  },
  	"bugfix/transform-async-arrows-in-class": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "11",
  	node: "7.6",
  	ios: "11",
  	samsung: "6",
  	electron: "1.6"
  },
  	"transform-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-edge-default-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "18",
  	firefox: "52",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "14",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"bugfix/transform-edge-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-block-scoping": {
  	chrome: "49",
  	opera: "36",
  	edge: "14",
  	firefox: "51",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-safari-block-shadowing": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "44",
  	safari: "11",
  	node: "6",
  	ie: "11",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-safari-for-shadowing": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "4",
  	safari: "11",
  	node: "6",
  	ie: "11",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-template-literals": {
  	chrome: "41",
  	opera: "28",
  	edge: "13",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"bugfix/transform-tagged-template-caching": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "34",
  	safari: "13",
  	node: "4",
  	ios: "13",
  	samsung: "3.4",
  	electron: "0.21"
  }
  };

  var pluginBugfixes$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': pluginBugfixes
  });

  var require$$0$5 = getCjsExportFromNamespace(pluginBugfixes$1);

  var pluginBugfixes$2 = require$$0$5;

  var lib$f = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-async-generators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("asyncGenerators");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxAsyncGenerators$2 = /*@__PURE__*/unwrapExports(lib$f);

  var lib$g = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-dynamic-import",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("dynamicImport");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxDynamicImport$1 = /*@__PURE__*/unwrapExports(lib$g);

  var lib$h = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-namespace-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportNamespaceFrom");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxExportNamespaceFrom$1 = /*@__PURE__*/unwrapExports(lib$h);

  var lib$i = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-json-strings",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsonStrings");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxJsonStrings$1 = /*@__PURE__*/unwrapExports(lib$i);

  var lib$j = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-logical-assignment-operators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("logicalAssignment");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxLogicalAssignmentOperators$1 = /*@__PURE__*/unwrapExports(lib$j);

  var lib$k = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-nullish-coalescing-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("nullishCoalescingOperator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNullishCoalescingOperator$1 = /*@__PURE__*/unwrapExports(lib$k);

  var lib$l = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-numeric-separator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("numericSeparator");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxNumericSeparator$1 = /*@__PURE__*/unwrapExports(lib$l);

  var lib$m = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-object-rest-spread",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("objectRestSpread");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxObjectRestSpread$2 = /*@__PURE__*/unwrapExports(lib$m);

  var lib$n = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-catch-binding",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalCatchBinding");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalCatchBinding$2 = /*@__PURE__*/unwrapExports(lib$n);

  var lib$o = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;



  var _default = (0, _helperPluginUtils.declare)(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-optional-chaining",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("optionalChaining");
      }
    };
  });

  exports["default"] = _default;
  });

  var syntaxOptionalChaining$1 = /*@__PURE__*/unwrapExports(lib$o);

  var transformAsyncArrowsInClass = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;
  var OPTS = {
    allowInsertArrow: false,
    specCompliant: false
  };

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-async-arrows-in-class",
      visitor: {
        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
          if (path.node.async && path.findParent(t.isClassMethod)) {
            path.arrowFunctionToExpression(OPTS);
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixAsyncArrowsInClass = /*@__PURE__*/unwrapExports(transformAsyncArrowsInClass);

  var transformEdgeDefaultParameters = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;

    var isArrowParent = function isArrowParent(p) {
      return p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
    };

    return {
      name: "transform-edge-default-parameters",
      visitor: {
        AssignmentPattern: function AssignmentPattern(path) {
          var arrowArgParent = path.find(isArrowParent);

          if (arrowArgParent && path.parent.shorthand) {
            path.parent.shorthand = false;
            (path.parent.extra || {}).shorthand = false;
            path.scope.rename(path.parent.key.name);
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixEdgeDefaultParameters = /*@__PURE__*/unwrapExports(transformEdgeDefaultParameters);

  var transformEdgeFunctionName = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-edge-function-name",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            if (!path.node.id && t.isIdentifier(path.parent.id)) {
              var id = t.cloneNode(path.parent.id);
              var binding = path.scope.getBinding(id.name);

              if (binding.constantViolations.length) {
                path.scope.rename(id.name);
              }

              path.node.id = id;
            }
          }
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixEdgeFunctionName = /*@__PURE__*/unwrapExports(transformEdgeFunctionName);

  var transformTaggedTemplateCaching = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  var _default = function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-tagged-template-caching",
      visitor: {
        TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
          var processed = state.get("processed");

          if (!processed) {
            processed = new Map();
            state.set("processed", processed);
          }

          if (processed.has(path.node)) return path.skip();
          var expressions = path.node.quasi.expressions;
          var identity = state.get("identity");

          if (!identity) {
            identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
            state.set("identity", identity);
            var binding = path.scope.getBinding(identity.name);
            binding.path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
          }

          var template = t.taggedTemplateExpression(identity, t.templateLiteral(path.node.quasi.quasis, expressions.map(function () {
            return t.numericLiteral(0);
          })));
          processed.set(template, true);
          var ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
          path.scope.getBinding(ident.name).path.parent.kind = "let";
          var inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", ident, template));
          var node = t.callExpression(path.node.tag, [inlineCache].concat(expressions));
          path.replaceWith(node);
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixTaggedTemplateCaching = /*@__PURE__*/unwrapExports(transformTaggedTemplateCaching);

  var transformSafariBlockShadowing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = _default;

  function _default(_ref) {
    var t = _ref.types;
    return {
      name: "transform-safari-block-shadowing",
      visitor: {
        VariableDeclarator: function VariableDeclarator(path) {
          var kind = path.parent.kind;
          if (kind !== "let" && kind !== "const") return;
          var block = path.scope.block;
          if (t.isFunction(block) || t.isProgram(block)) return;
          var bindings = t.getOuterBindingIdentifiers(path.node.id);

          for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
            var name = _Object$keys[_i];
            var scope = path.scope;
            if (!scope.hasOwnBinding(name)) continue;

            while (scope = scope.parent) {
              if (scope.hasOwnBinding(name)) {
                path.scope.rename(name);
                break;
              }

              if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
                break;
              }
            }
          }
        }
      }
    };
  }

  module.exports = exports["default"];
  });

  var bugfixSafariBlockShadowing = /*@__PURE__*/unwrapExports(transformSafariBlockShadowing);

  var transformSafariForShadowing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports["default"] = void 0;

  function handle(declaration) {
    if (!declaration.isVariableDeclaration()) return;
    var fn = declaration.getFunctionParent();
    var name = declaration.node.declarations[0].id.name;

    if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
      declaration.scope.rename(name);
    }
  }

  var _default = function _default() {
    return {
      name: "transform-safari-for-shadowing",
      visitor: {
        ForXStatement: function ForXStatement(path) {
          handle(path.get("left"));
        },
        ForStatement: function ForStatement(path) {
          handle(path.get("init"));
        }
      }
    };
  };

  exports["default"] = _default;
  module.exports = exports["default"];
  });

  var bugfixSafariForShadowing = /*@__PURE__*/unwrapExports(transformSafariForShadowing);

  var availablePlugins = {
    "bugfix/transform-async-arrows-in-class": bugfixAsyncArrowsInClass,
    "bugfix/transform-edge-default-parameters": bugfixEdgeDefaultParameters,
    "bugfix/transform-edge-function-name": bugfixEdgeFunctionName,
    "bugfix/transform-safari-block-shadowing": bugfixSafariBlockShadowing,
    "bugfix/transform-safari-for-shadowing": bugfixSafariForShadowing,
    "bugfix/transform-tagged-template-caching": bugfixTaggedTemplateCaching,
    "proposal-async-generator-functions": proposalAsyncGeneratorFunctions,
    "proposal-class-properties": proposalClassProperties,
    "proposal-dynamic-import": proposalDynamicImport,
    "proposal-export-namespace-from": proposalExportNamespaceFrom,
    "proposal-json-strings": proposalJsonStrings,
    "proposal-logical-assignment-operators": proposalLogicalAssignmentOperators,
    "proposal-nullish-coalescing-operator": proposalNullishCoalescingOperator,
    "proposal-numeric-separator": proposalNumericSeparator,
    "proposal-object-rest-spread": proposalObjectRestSpread,
    "proposal-optional-catch-binding": proposalOptionalCatchBinding,
    "proposal-optional-chaining": proposalOptionalChaining,
    "proposal-private-methods": proposalPrivateMethods,
    "proposal-unicode-property-regex": proposalUnicodePropertyRegex,
    "syntax-async-generators": syntaxAsyncGenerators$2,
    "syntax-class-properties": syntaxClassProperties,
    "syntax-dynamic-import": syntaxDynamicImport$1,
    "syntax-export-namespace-from": syntaxExportNamespaceFrom$1,
    "syntax-json-strings": syntaxJsonStrings$1,
    "syntax-logical-assignment-operators": syntaxLogicalAssignmentOperators$1,
    "syntax-nullish-coalescing-operator": syntaxNullishCoalescingOperator$1,
    "syntax-numeric-separator": syntaxNumericSeparator$1,
    "syntax-object-rest-spread": syntaxObjectRestSpread$2,
    "syntax-optional-catch-binding": syntaxOptionalCatchBinding$2,
    "syntax-optional-chaining": syntaxOptionalChaining$1,
    "syntax-top-level-await": syntaxTopLevelAwait,
    "transform-arrow-functions": transformArrowFunctions,
    "transform-async-to-generator": transformAsyncToGenerator,
    "transform-block-scoped-functions": transformBlockScopedFunctions,
    "transform-block-scoping": transformBlockScoping,
    "transform-classes": transformClasses,
    "transform-computed-properties": transformComputedProperties,
    "transform-destructuring": transformDestructuring,
    "transform-dotall-regex": transformDotallRegex,
    "transform-duplicate-keys": transformDuplicateKeys,
    "transform-exponentiation-operator": transformExponentialOperator,
    "transform-for-of": transformForOf,
    "transform-function-name": transformFunctionName,
    "transform-literals": transformLiterals,
    "transform-member-expression-literals": transformMemberExpressionLiterals,
    "transform-modules-amd": transformModulesAmd,
    "transform-modules-commonjs": transformModulesCommonjs,
    "transform-modules-systemjs": transformModulesSystemjs,
    "transform-modules-umd": transformModulesUmd,
    "transform-named-capturing-groups-regex": transformNamedCapturingGroupsRegex,
    "transform-new-target": transformNewTarget,
    "transform-object-super": transformObjectSuper,
    "transform-parameters": transformParameters,
    "transform-property-literals": transformPropertyLiterals,
    "transform-regenerator": transformRegenerator,
    "transform-reserved-words": transformReservedWords,
    "transform-shorthand-properties": transformShorthandProperties,
    "transform-spread": transformSpread,
    "transform-sticky-regex": transformStickyRegex,
    "transform-template-literals": transformTemplateLiterals,
    "transform-typeof-symbol": transformTypeofSymbol,
    "transform-unicode-escapes": transformUnicodeEscapes,
    "transform-unicode-regex": transformUnicodeRegex
  };

  var pluginsFiltered = {};
  var bugfixPluginsFiltered = {};

  for (var _i$4 = 0, _Object$keys$2 = Object.keys(plugins$2); _i$4 < _Object$keys$2.length; _i$4++) {
    var plugin = _Object$keys$2[_i$4];

    if (Object.hasOwnProperty.call(availablePlugins, plugin)) {
      pluginsFiltered[plugin] = plugins$2[plugin];
    }
  }

  for (var _i2$2 = 0, _Object$keys2$1 = Object.keys(pluginBugfixes$2); _i2$2 < _Object$keys2$1.length; _i2$2++) {
    var _plugin = _Object$keys2$1[_i2$2];

    if (Object.hasOwnProperty.call(availablePlugins, _plugin)) {
      bugfixPluginsFiltered[_plugin] = pluginBugfixes$2[_plugin];
    }
  }

  pluginsFiltered["proposal-class-properties"] = pluginsFiltered["proposal-private-methods"];

  var TopLevelOptions = {
    bugfixes: "bugfixes",
    configPath: "configPath",
    corejs: "corejs",
    debug: "debug",
    exclude: "exclude",
    forceAllTransforms: "forceAllTransforms",
    ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
    include: "include",
    loose: "loose",
    modules: "modules",
    shippedProposals: "shippedProposals",
    spec: "spec",
    targets: "targets",
    useBuiltIns: "useBuiltIns",
    browserslistEnv: "browserslistEnv"
  };
  var ModulesOption = {
    "false": false,
    auto: "auto",
    amd: "amd",
    commonjs: "commonjs",
    cjs: "cjs",
    systemjs: "systemjs",
    umd: "umd"
  };
  var UseBuiltInsOption = {
    "false": false,
    entry: "entry",
    usage: "usage"
  };

  var defaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
  function getPlatformSpecificDefaultFor (targets) {
    var targetNames = Object.keys(targets);
    var isAnyTarget = !targetNames.length;
    var isWebTarget = targetNames.some(function (name) {
      return name !== "node";
    });
    return isAnyTarget || isWebTarget ? defaultWebIncludes : null;
  }

  var name$3 = "@babel/preset-env";

  var v$2 = new OptionValidator(name$3);
  var allPluginsList = Object.keys(pluginsFiltered);
  var modulePlugins = ["proposal-dynamic-import"].concat(Object.keys(moduleTransformations).map(function (m) {
    return moduleTransformations[m];
  }));

  var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
    return new Set([].concat(allPluginsList, type === "exclude" ? modulePlugins : [], corejs ? corejs == 2 ? [].concat(Object.keys(corejs2BuiltIns$2), defaultWebIncludes) : Object.keys(corejs3Polyfills) : []));
  };

  var pluginToRegExp = function pluginToRegExp(plugin) {
    if (plugin instanceof RegExp) return plugin;

    try {
      return new RegExp("^" + normalizePluginName(plugin) + "$");
    } catch (e) {
      return null;
    }
  };

  var selectPlugins = function selectPlugins(regexp, type, corejs) {
    return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
      return regexp instanceof RegExp && regexp.test(item);
    });
  };

  var flatten$1 = function flatten(array) {
    var _ref;

    return (_ref = []).concat.apply(_ref, array);
  };

  var expandIncludesAndExcludes = function expandIncludesAndExcludes(plugins, type, corejs) {
    if (plugins === void 0) {
      plugins = [];
    }

    if (plugins.length === 0) return [];
    var selectedPlugins = plugins.map(function (plugin) {
      return selectPlugins(pluginToRegExp(plugin), type, corejs);
    });
    var invalidRegExpList = plugins.filter(function (p, i) {
      return selectedPlugins[i].length === 0;
    });
    v$2.invariant(invalidRegExpList.length === 0, "The plugins/built-ins '" + invalidRegExpList.join(", ") + "' passed to the '" + type + "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env");
    return flatten$1(selectedPlugins);
  };

  var normalizePluginName = function normalizePluginName(plugin) {
    return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
  };
  var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(include, exclude) {
    if (include === void 0) {
      include = [];
    }

    if (exclude === void 0) {
      exclude = [];
    }

    var duplicates = include.filter(function (opt) {
      return exclude.indexOf(opt) >= 0;
    });
    v$2.invariant(duplicates.length === 0, "The plugins/built-ins '" + duplicates.join(", ") + "' were found in both the \"include\" and\n    \"exclude\" options.");
  };

  var normalizeTargets = function normalizeTargets(targets) {
    if (typeof targets === "string" || Array.isArray(targets)) {
      return {
        browsers: targets
      };
    }

    return Object.assign({}, targets);
  };

  var validateModulesOption = function validateModulesOption(modulesOpt) {
    if (modulesOpt === void 0) {
      modulesOpt = ModulesOption.auto;
    }

    v$2.invariant(ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption["false"], "The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
    return modulesOpt;
  };
  var validateUseBuiltInsOption = function validateUseBuiltInsOption(builtInsOpt) {
    if (builtInsOpt === void 0) {
      builtInsOpt = false;
    }

    v$2.invariant(UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === UseBuiltInsOption["false"], "The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
    return builtInsOpt;
  };
  function normalizeCoreJSOption(corejs, useBuiltIns) {
    var proposals = false;
    var rawVersion;

    if (useBuiltIns && corejs === undefined) {
      rawVersion = 2;
      console.warn("\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n\n" + "More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\n" + "More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs");
    } else if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var version = rawVersion ? semver$2.coerce(String(rawVersion)) : false;

    if (!useBuiltIns && version) {
      console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
    }

    if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
      throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
    }

    return {
      version: version,
      proposals: proposals
    };
  }
  function normalizeOptions$3(opts) {
    v$2.validateTopLevelOptions(opts, TopLevelOptions);
    var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
    var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
    var include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major);
    var exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
    checkDuplicateIncludeExcludes(include, exclude);
    return {
      bugfixes: v$2.validateBooleanOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
      configPath: v$2.validateStringOption(TopLevelOptions.configPath, opts.configPath, process.cwd()),
      corejs: corejs,
      debug: v$2.validateBooleanOption(TopLevelOptions.debug, opts.debug, false),
      include: include,
      exclude: exclude,
      forceAllTransforms: v$2.validateBooleanOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
      ignoreBrowserslistConfig: v$2.validateBooleanOption(TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false),
      loose: v$2.validateBooleanOption(TopLevelOptions.loose, opts.loose, false),
      modules: validateModulesOption(opts.modules),
      shippedProposals: v$2.validateBooleanOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false),
      spec: v$2.validateBooleanOption(TopLevelOptions.spec, opts.spec, false),
      targets: normalizeTargets(opts.targets),
      useBuiltIns: useBuiltIns,
      browserslistEnv: v$2.validateStringOption(TopLevelOptions.browserslistEnv, opts.browserslistEnv)
    };
  }

  var proposalPlugins = new Set(["proposal-class-properties", "proposal-private-methods"]);
  var pluginSyntaxObject = {
    "proposal-async-generator-functions": "syntax-async-generators",
    "proposal-class-properties": "syntax-class-properties",
    "proposal-json-strings": "syntax-json-strings",
    "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
    "proposal-numeric-separator": "syntax-numeric-separator",
    "proposal-object-rest-spread": "syntax-object-rest-spread",
    "proposal-optional-catch-binding": "syntax-optional-catch-binding",
    "proposal-optional-chaining": "syntax-optional-chaining",
    "proposal-private-methods": "syntax-class-properties",
    "proposal-unicode-property-regex": null
  };
  var pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
    return [key, pluginSyntaxObject[key]];
  });
  var pluginSyntaxMap = new Map(pluginSyntaxEntries);
  var shippedProposals = {
    pluginSyntaxMap: pluginSyntaxMap,
    proposalPlugins: proposalPlugins
  };

  var overlappingPlugins = {
  	"transform-async-to-generator": [
  	"bugfix/transform-async-arrows-in-class"
  ],
  	"transform-parameters": [
  	"bugfix/transform-edge-default-parameters"
  ],
  	"transform-function-name": [
  	"bugfix/transform-edge-function-name"
  ],
  	"transform-block-scoping": [
  	"bugfix/transform-safari-block-shadowing",
  	"bugfix/transform-safari-for-shadowing"
  ],
  	"transform-template-literals": [
  	"bugfix/transform-tagged-template-caching"
  ]
  };

  var overlappingPlugins$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': overlappingPlugins
  });

  var require$$0$6 = getCjsExportFromNamespace(overlappingPlugins$1);

  var overlappingPlugins$2 = require$$0$6;

  var ArrayNatureIterators = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
  var CommonIterators = ["es6.string.iterator"].concat(ArrayNatureIterators);
  var PromiseDependencies = ["es6.object.to-string", "es6.promise"];
  var BuiltIns = {
    DataView: "es6.typed.data-view",
    Float32Array: "es6.typed.float32-array",
    Float64Array: "es6.typed.float64-array",
    Int8Array: "es6.typed.int8-array",
    Int16Array: "es6.typed.int16-array",
    Int32Array: "es6.typed.int32-array",
    Map: ["es6.map"].concat(CommonIterators),
    Number: "es6.number.constructor",
    Promise: PromiseDependencies,
    RegExp: ["es6.regexp.constructor"],
    Set: ["es6.set"].concat(CommonIterators),
    Symbol: ["es6.symbol", "es7.symbol.async-iterator"],
    Uint8Array: "es6.typed.uint8-array",
    Uint8ClampedArray: "es6.typed.uint8-clamped-array",
    Uint16Array: "es6.typed.uint16-array",
    Uint32Array: "es6.typed.uint32-array",
    WeakMap: ["es6.weak-map"].concat(CommonIterators),
    WeakSet: ["es6.weak-set"].concat(CommonIterators)
  };
  var InstanceProperties = {
    __defineGetter__: ["es7.object.define-getter"],
    __defineSetter__: ["es7.object.define-setter"],
    __lookupGetter__: ["es7.object.lookup-getter"],
    __lookupSetter__: ["es7.object.lookup-setter"],
    anchor: ["es6.string.anchor"],
    big: ["es6.string.big"],
    bind: ["es6.function.bind"],
    blink: ["es6.string.blink"],
    bold: ["es6.string.bold"],
    codePointAt: ["es6.string.code-point-at"],
    copyWithin: ["es6.array.copy-within"],
    endsWith: ["es6.string.ends-with"],
    entries: ArrayNatureIterators,
    every: ["es6.array.is-array"],
    fill: ["es6.array.fill"],
    filter: ["es6.array.filter"],
    "finally": ["es7.promise.finally"].concat(PromiseDependencies),
    find: ["es6.array.find"],
    findIndex: ["es6.array.find-index"],
    fixed: ["es6.string.fixed"],
    flags: ["es6.regexp.flags"],
    flatMap: ["es7.array.flat-map"],
    fontcolor: ["es6.string.fontcolor"],
    fontsize: ["es6.string.fontsize"],
    forEach: ["es6.array.for-each"],
    includes: ["es6.string.includes", "es7.array.includes"],
    indexOf: ["es6.array.index-of"],
    italics: ["es6.string.italics"],
    keys: ArrayNatureIterators,
    lastIndexOf: ["es6.array.last-index-of"],
    link: ["es6.string.link"],
    map: ["es6.array.map"],
    match: ["es6.regexp.match"],
    name: ["es6.function.name"],
    padStart: ["es7.string.pad-start"],
    padEnd: ["es7.string.pad-end"],
    reduce: ["es6.array.reduce"],
    reduceRight: ["es6.array.reduce-right"],
    repeat: ["es6.string.repeat"],
    replace: ["es6.regexp.replace"],
    search: ["es6.regexp.search"],
    slice: ["es6.array.slice"],
    small: ["es6.string.small"],
    some: ["es6.array.some"],
    sort: ["es6.array.sort"],
    split: ["es6.regexp.split"],
    startsWith: ["es6.string.starts-with"],
    strike: ["es6.string.strike"],
    sub: ["es6.string.sub"],
    sup: ["es6.string.sup"],
    toISOString: ["es6.date.to-iso-string"],
    toJSON: ["es6.date.to-json"],
    toString: ["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"],
    trim: ["es6.string.trim"],
    trimEnd: ["es7.string.trim-right"],
    trimLeft: ["es7.string.trim-left"],
    trimRight: ["es7.string.trim-right"],
    trimStart: ["es7.string.trim-left"],
    values: ArrayNatureIterators
  };
  var StaticProperties = {
    Array: {
      from: ["es6.array.from", "es6.string.iterator"],
      isArray: "es6.array.is-array",
      of: "es6.array.of"
    },
    Date: {
      now: "es6.date.now"
    },
    Object: {
      assign: "es6.object.assign",
      create: "es6.object.create",
      defineProperty: "es6.object.define-property",
      defineProperties: "es6.object.define-properties",
      entries: "es7.object.entries",
      freeze: "es6.object.freeze",
      getOwnPropertyDescriptors: "es7.object.get-own-property-descriptors",
      getOwnPropertySymbols: "es6.symbol",
      is: "es6.object.is",
      isExtensible: "es6.object.is-extensible",
      isFrozen: "es6.object.is-frozen",
      isSealed: "es6.object.is-sealed",
      keys: "es6.object.keys",
      preventExtensions: "es6.object.prevent-extensions",
      seal: "es6.object.seal",
      setPrototypeOf: "es6.object.set-prototype-of",
      values: "es7.object.values"
    },
    Math: {
      acosh: "es6.math.acosh",
      asinh: "es6.math.asinh",
      atanh: "es6.math.atanh",
      cbrt: "es6.math.cbrt",
      clz32: "es6.math.clz32",
      cosh: "es6.math.cosh",
      expm1: "es6.math.expm1",
      fround: "es6.math.fround",
      hypot: "es6.math.hypot",
      imul: "es6.math.imul",
      log1p: "es6.math.log1p",
      log10: "es6.math.log10",
      log2: "es6.math.log2",
      sign: "es6.math.sign",
      sinh: "es6.math.sinh",
      tanh: "es6.math.tanh",
      trunc: "es6.math.trunc"
    },
    String: {
      fromCodePoint: "es6.string.from-code-point",
      raw: "es6.string.raw"
    },
    Number: {
      EPSILON: "es6.number.epsilon",
      MIN_SAFE_INTEGER: "es6.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es6.number.max-safe-integer",
      isFinite: "es6.number.is-finite",
      isInteger: "es6.number.is-integer",
      isSafeInteger: "es6.number.is-safe-integer",
      isNaN: "es6.number.is-nan",
      parseFloat: "es6.number.parse-float",
      parseInt: "es6.number.parse-int"
    },
    Promise: {
      all: CommonIterators,
      race: CommonIterators
    },
    Reflect: {
      apply: "es6.reflect.apply",
      construct: "es6.reflect.construct",
      defineProperty: "es6.reflect.define-property",
      deleteProperty: "es6.reflect.delete-property",
      get: "es6.reflect.get",
      getOwnPropertyDescriptor: "es6.reflect.get-own-property-descriptor",
      getPrototypeOf: "es6.reflect.get-prototype-of",
      has: "es6.reflect.has",
      isExtensible: "es6.reflect.is-extensible",
      ownKeys: "es6.reflect.own-keys",
      preventExtensions: "es6.reflect.prevent-extensions",
      set: "es6.reflect.set",
      setPrototypeOf: "es6.reflect.set-prototype-of"
    }
  };

  var has$6 = Object.hasOwnProperty.call.bind(Object.hasOwnProperty);
  function getType$1(target) {
    return Object.prototype.toString.call(target).slice(8, -1).toLowerCase();
  }
  function intersection(first, second, third) {
    var result = new Set();

    for (var _iterator = _createForOfIteratorHelperLoose(first), _step; !(_step = _iterator()).done;) {
      var el = _step.value;
      if (second.has(el) && third.has(el)) result.add(el);
    }

    return result;
  }
  function filterStageFromList(list, stageList) {
    return Object.keys(list).reduce(function (result, item) {
      if (!stageList.has(item)) {
        result[item] = list[item];
      }

      return result;
    }, {});
  }
  function getImportSource(_ref) {
    var node = _ref.node;
    if (node.specifiers.length === 0) return node.source.value;
  }
  function getRequireSource(_ref2) {
    var node = _ref2.node;
    if (!isExpressionStatement(node)) return;
    var expression = node.expression;
    var isRequire = isCallExpression(expression) && isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && isStringLiteral(expression.arguments[0]);
    if (isRequire) return expression.arguments[0].value;
  }
  function isPolyfillSource(source) {
    return source === "@babel/polyfill" || source === "core-js";
  }
  var modulePathMap = {
    "regenerator-runtime": "regenerator-runtime/runtime.js"
  };
  function getModulePath(mod) {
    return modulePathMap[mod] || "core-js/modules/" + mod + ".js";
  }
  function createImport(path, mod) {
    return addSideEffect(path, getModulePath(mod));
  }
  function isNamespaced(path) {
    if (!path.node) return false;
    var binding = path.scope.getBinding(path.node.name);
    if (!binding) return false;
    return binding.path.isImportNamespaceSpecifier();
  }

  var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the `import '@babel/polyfill'` call or use `useBuiltIns: 'entry'` instead.";
  function addCoreJS2UsagePlugin (_ref, _ref2) {
    var t = _ref.types;
    var include = _ref2.include,
        exclude = _ref2.exclude,
        polyfillTargets = _ref2.polyfillTargets,
        debug = _ref2.debug;
    var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
    var addAndRemovePolyfillImports = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT);
          path.remove();
        }
      },
      Program: function Program(path) {
        path.get("body").forEach(function (bodyPath) {
          if (isPolyfillSource(getRequireSource(bodyPath))) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT);
            bodyPath.remove();
          }
        });
      },
      ReferencedIdentifier: function ReferencedIdentifier(_ref3) {
        var name = _ref3.node.name,
            parent = _ref3.parent,
            scope = _ref3.scope;
        if (t.isMemberExpression(parent)) return;
        if (!has$6(BuiltIns, name)) return;
        if (scope.getBindingIdentifier(name)) return;
        var BuiltInDependencies = BuiltIns[name];
        this.addUnsupported(BuiltInDependencies);
      },
      CallExpression: function CallExpression(path) {
        if (path.node.arguments.length) return;
        var callee = path.node.callee;
        if (!t.isMemberExpression(callee)) return;
        if (!callee.computed) return;

        if (!path.get("callee.property").matchesPattern("Symbol.iterator")) {
          return;
        }

        this.addImport("web.dom.iterable");
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        if (!path.get("left").matchesPattern("Symbol.iterator")) return;
        this.addImport("web.dom.iterable");
      },
      YieldExpression: function YieldExpression(path) {
        if (path.node.delegate) {
          this.addImport("web.dom.iterable");
        }
      },
      MemberExpression: {
        enter: function enter(path) {
          var node = path.node;
          var object = node.object,
              property = node.property;
          if (isNamespaced(path.get("object"))) return;
          var evaluatedPropType = object.name;
          var propertyName = "";
          var instanceType = "";

          if (node.computed) {
            if (t.isStringLiteral(property)) {
              propertyName = property.value;
            } else {
              var result = path.get("property").evaluate();

              if (result.confident && result.value) {
                propertyName = result.value;
              }
            }
          } else {
            propertyName = property.name;
          }

          if (path.scope.getBindingIdentifier(object.name)) {
            var _result = path.get("object").evaluate();

            if (_result.value) {
              instanceType = getType$1(_result.value);
            } else if (_result.deopt && _result.deopt.isIdentifier()) {
              evaluatedPropType = _result.deopt.node.name;
            }
          }

          if (has$6(StaticProperties, evaluatedPropType)) {
            var BuiltInProperties = StaticProperties[evaluatedPropType];

            if (has$6(BuiltInProperties, propertyName)) {
              var StaticPropertyDependencies = BuiltInProperties[propertyName];
              this.addUnsupported(StaticPropertyDependencies);
            }
          }

          if (has$6(InstanceProperties, propertyName)) {
            var InstancePropertyDependencies = InstanceProperties[propertyName];

            if (instanceType) {
              InstancePropertyDependencies = InstancePropertyDependencies.filter(function (module) {
                return module.includes(instanceType);
              });
            }

            this.addUnsupported(InstancePropertyDependencies);
          }
        },
        exit: function exit(path) {
          var name = path.node.object.name;
          if (!has$6(BuiltIns, name)) return;
          if (path.scope.getBindingIdentifier(name)) return;
          var BuiltInDependencies = BuiltIns[name];
          this.addUnsupported(BuiltInDependencies);
        }
      },
      VariableDeclarator: function VariableDeclarator(path) {
        var node = path.node;
        var id = node.id,
            init = node.init;
        if (!t.isObjectPattern(id)) return;
        if (init && path.scope.getBindingIdentifier(init.name)) return;

        for (var _iterator = _createForOfIteratorHelperLoose(id.properties), _step; !(_step = _iterator()).done;) {
          var key = _step.value.key;

          if (!node.computed && t.isIdentifier(key) && has$6(InstanceProperties, key.name)) {
            var InstancePropertyDependencies = InstanceProperties[key.name];
            this.addUnsupported(InstancePropertyDependencies);
          }
        }
      }
    };
    return {
      name: "corejs2-usage",
      pre: function pre(_ref4) {
        var path = _ref4.path;
        this.polyfillsSet = new Set();

        this.addImport = function (builtIn) {
          if (!this.polyfillsSet.has(builtIn)) {
            this.polyfillsSet.add(builtIn);
            createImport(path, builtIn);
          }
        };

        this.addUnsupported = function (builtIn) {
          var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

          for (var _iterator2 = _createForOfIteratorHelperLoose(modules), _step2; !(_step2 = _iterator2()).done;) {
            var module = _step2.value;

            if (polyfills.has(module)) {
              this.addImport(module);
            }
          }
        };
      },
      post: function post() {
        if (debug) {
          logUsagePolyfills(this.polyfillsSet, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
        }
      },
      visitor: addAndRemovePolyfillImports
    };
  }

  var corejs3ShippedProposals = [
  	"esnext.global-this",
  	"esnext.promise.all-settled",
  	"esnext.string.match-all"
  ];

  var corejs3ShippedProposals$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': corejs3ShippedProposals
  });

  var require$$0$7 = getCjsExportFromNamespace(corejs3ShippedProposals$1);

  var corejs3ShippedProposals$2 = require$$0$7;

  var debug$2 = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1 = debug$2;

  var SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var constants = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
    MAX_LENGTH: MAX_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
  };

  var re_1 = createCommonjsModule(function (module, exports) {
  var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;



  exports = module.exports = {};
  var re = exports.re = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;

  var createToken = function createToken(name, value, isGlobal) {
    var index = R++;
    debug_1(index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
  };

  createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
  createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
  createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
  createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
  createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
  createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
  createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
  createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
  createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
  createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
  createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
  createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
  createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
  createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
  createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
  createToken('GTLT', '((?:<|>)?=?)');
  createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
  createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
  createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
  createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
  createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
  createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
  createToken('COERCERTL', src[t.COERCE], true);
  createToken('LONETILDE', '(?:~>?)');
  createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
  exports.tildeTrimReplace = '$1~';
  createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
  createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('LONECARET', '(?:\\^)');
  createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
  exports.caretTrimReplace = '$1^';
  createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
  createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
  createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
  createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
  createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
  exports.comparatorTrimReplace = '$1$2$3';
  createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
  createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
  createToken('STAR', '(<|>)?=?\\s*\\*');
  });

  var numeric = /^[0-9]+$/;

  var compareIdentifiers = function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  };

  var identifiers = {
    compareIdentifiers: compareIdentifiers,
    rcompareIdentifiers: rcompareIdentifiers
  };

  var MAX_LENGTH$1 = constants.MAX_LENGTH,
      MAX_SAFE_INTEGER$3 = constants.MAX_SAFE_INTEGER;

  var re = re_1.re,
      t$1 = re_1.t;

  var compareIdentifiers$1 = identifiers.compareIdentifiers;

  var SemVer = function () {

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$1) {
        throw new TypeError("version is longer than " + MAX_LENGTH$1 + " characters");
      }

      debug_1('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re[t$1.LOOSE] : re[t$1.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER$3 || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER$3 || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER$3 || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER$3) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers$1(this.major, other.major) || compareIdentifiers$1(this.minor, other.minor) || compareIdentifiers$1(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$1(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$1(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$3 = SemVer;

  var compare$1 = function compare(a, b, loose) {
    return new semver$3(a, loose).compare(new semver$3(b, loose));
  };

  var compare_1 = compare$1;

  var eq$1 = function eq(a, b, loose) {
    return compare_1(a, b, loose) === 0;
  };

  var eq_1$1 = eq$1;

  var neq = function neq(a, b, loose) {
    return compare_1(a, b, loose) !== 0;
  };

  var neq_1 = neq;

  var gt = function gt(a, b, loose) {
    return compare_1(a, b, loose) > 0;
  };

  var gt_1 = gt;

  var gte = function gte(a, b, loose) {
    return compare_1(a, b, loose) >= 0;
  };

  var gte_1 = gte;

  var lt = function lt(a, b, loose) {
    return compare_1(a, b, loose) < 0;
  };

  var lt_1 = lt;

  var lte = function lte(a, b, loose) {
    return compare_1(a, b, loose) <= 0;
  };

  var lte_1 = lte;

  var cmp = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1$1(a, b, loose);

      case '!=':
        return neq_1(a, b, loose);

      case '>':
        return gt_1(a, b, loose);

      case '>=':
        return gte_1(a, b, loose);

      case '<':
        return lt_1(a, b, loose);

      case '<=':
        return lte_1(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1 = cmp;

  var MAX_LENGTH$2 = constants.MAX_LENGTH;

  var re$1 = re_1.re,
      t$2 = re_1.t;



  var parse$5 = function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof semver$3) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH$2) {
      return null;
    }

    var r = options.loose ? re$1[t$2.LOOSE] : re$1[t$2.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$3(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1 = parse$5;

  var re$2 = re_1.re,
      t$3 = re_1.t;

  var coerce = function coerce(version, options) {
    if (version instanceof semver$3) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re$2[t$3.COERCE]);
    } else {
      var next;

      while ((next = re$2[t$3.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re$2[t$3.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re$2[t$3.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1 = coerce;

  var has$7 = Function.call.bind({}.hasOwnProperty);

  function compare$2(a, operator, b) {
    return cmp_1(coerce_1(a), operator, coerce_1(b));
  }

  function intersection$1(list, order) {
    var set = list instanceof Set ? list : new Set(list);
    return order.filter(function (name) {
      return set.has(name);
    });
  }

  function sortObjectByKey(object, fn) {
    return Object.keys(object).sort(fn).reduce(function (memo, key) {
      memo[key] = object[key];
      return memo;
    }, {});
  }

  var helpers$1 = {
    compare: compare$2,
    has: has$7,
    intersection: intersection$1,
    semver: coerce_1,
    sortObjectByKey: sortObjectByKey
  };

  var modulesByVersions = {
  	"3.0": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.map.delete-all",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"3.1": [
  	"es.string.match-all",
  	"es.symbol.match-all",
  	"esnext.symbol.replace-all"
  ],
  	"3.2": [
  	"es.promise.all-settled",
  	"esnext.array.is-template-object",
  	"esnext.map.update-or-insert",
  	"esnext.symbol.async-dispose"
  ],
  	"3.3": [
  	"es.global-this",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.upsert",
  	"esnext.weak-map.upsert"
  ],
  	"3.4": [
  	"es.json.stringify"
  ],
  	"3.5": [
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"3.6": [
  	"es.regexp.sticky",
  	"es.regexp.test"
  ],
  	"3.7": [
  	"es.aggregate-error",
  	"es.promise.any",
  	"es.reflect.to-string-tag",
  	"es.string.replace-all",
  	"esnext.map.emplace",
  	"esnext.weak-map.emplace"
  ],
  	"3.8": [
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.unique-by",
  	"esnext.bigint.range",
  	"esnext.number.range",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out"
  ]
  };

  var modulesByVersions$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': modulesByVersions
  });

  var modules = [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ];

  var modules$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': modules
  });

  var modulesByVersions$2 = getCjsExportFromNamespace(modulesByVersions$1);

  var modules$2 = getCjsExportFromNamespace(modules$1);

  var compare$3 = helpers$1.compare,
      intersection$2 = helpers$1.intersection,
      semver$4 = helpers$1.semver;





  var getModulesListForTargetVersion = function (raw) {
    var corejs = semver$4(raw);

    if (corejs.major !== 3) {
      throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
    }

    var result = [];

    for (var _i = 0, _Object$keys = Object.keys(modulesByVersions$2); _i < _Object$keys.length; _i++) {
      var version = _Object$keys[_i];

      if (compare$3(version, '<=', corejs)) {
        result.push.apply(result, modulesByVersions$2[version]);
      }
    }

    return intersection$2(result, modules$2);
  };

  var ArrayNatureIterators$1 = ["es.array.iterator", "web.dom-collections.iterator"];
  var CommonIterators$1 = ["es.string.iterator"].concat(ArrayNatureIterators$1);
  var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators$1);
  var CommonIteratorsWithTag = ["es.object.to-string"].concat(CommonIterators$1);
  var TypedArrayDependencies = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
  var TypedArrayStaticMethods = {
    from: "es.typed-array.from",
    of: "es.typed-array.of"
  };
  var PromiseDependencies$1 = ["es.promise", "es.object.to-string"];
  var PromiseDependenciesWithIterators = [].concat(PromiseDependencies$1, CommonIterators$1);
  var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
  var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(CommonIteratorsWithTag);
  var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(CommonIteratorsWithTag);
  var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all"].concat(CommonIteratorsWithTag);
  var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(CommonIteratorsWithTag);
  var URLSearchParamsDependencies = ["web.url"].concat(CommonIteratorsWithTag);
  var BuiltIns$1 = {
    AggregateError: ["esnext.aggregate-error"].concat(CommonIterators$1),
    ArrayBuffer: ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"],
    DataView: ["es.data-view", "es.array-buffer.slice", "es.object.to-string"],
    Date: ["es.date.to-string"],
    Float32Array: ["es.typed-array.float32-array"].concat(TypedArrayDependencies),
    Float64Array: ["es.typed-array.float64-array"].concat(TypedArrayDependencies),
    Int8Array: ["es.typed-array.int8-array"].concat(TypedArrayDependencies),
    Int16Array: ["es.typed-array.int16-array"].concat(TypedArrayDependencies),
    Int32Array: ["es.typed-array.int32-array"].concat(TypedArrayDependencies),
    Uint8Array: ["es.typed-array.uint8-array"].concat(TypedArrayDependencies),
    Uint8ClampedArray: ["es.typed-array.uint8-clamped-array"].concat(TypedArrayDependencies),
    Uint16Array: ["es.typed-array.uint16-array"].concat(TypedArrayDependencies),
    Uint32Array: ["es.typed-array.uint32-array"].concat(TypedArrayDependencies),
    Map: MapDependencies,
    Number: ["es.number.constructor"],
    Observable: ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(CommonIteratorsWithTag),
    Promise: PromiseDependencies$1,
    RegExp: ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"],
    Set: SetDependencies,
    Symbol: SymbolDependencies,
    URL: ["web.url"].concat(URLSearchParamsDependencies),
    URLSearchParams: URLSearchParamsDependencies,
    WeakMap: WeakMapDependencies,
    WeakSet: WeakSetDependencies,
    clearImmediate: ["web.immediate"],
    compositeKey: ["esnext.composite-key"],
    compositeSymbol: ["esnext.composite-symbol"].concat(SymbolDependencies),
    fetch: PromiseDependencies$1,
    globalThis: ["es.global-this", "esnext.global-this"],
    parseFloat: ["es.parse-float"],
    parseInt: ["es.parse-int"],
    queueMicrotask: ["web.queue-microtask"],
    setTimeout: ["web.timers"],
    setInterval: ["web.timers"],
    setImmediate: ["web.immediate"]
  };
  var InstanceProperties$1 = {
    at: ["esnext.string.at"],
    anchor: ["es.string.anchor"],
    big: ["es.string.big"],
    bind: ["es.function.bind"],
    blink: ["es.string.blink"],
    bold: ["es.string.bold"],
    codePointAt: ["es.string.code-point-at"],
    codePoints: ["esnext.string.code-points"],
    concat: ["es.array.concat"],
    copyWithin: ["es.array.copy-within"],
    description: ["es.symbol", "es.symbol.description"],
    endsWith: ["es.string.ends-with"],
    entries: ArrayNatureIteratorsWithTag,
    every: ["es.array.every"],
    exec: ["es.regexp.exec"],
    fill: ["es.array.fill"],
    filter: ["es.array.filter"],
    "finally": ["es.promise.finally"].concat(PromiseDependencies$1),
    find: ["es.array.find"],
    findIndex: ["es.array.find-index"],
    fixed: ["es.string.fixed"],
    flags: ["es.regexp.flags"],
    flat: ["es.array.flat", "es.array.unscopables.flat"],
    flatMap: ["es.array.flat-map", "es.array.unscopables.flat-map"],
    fontcolor: ["es.string.fontcolor"],
    fontsize: ["es.string.fontsize"],
    forEach: ["es.array.for-each", "web.dom-collections.for-each"],
    includes: ["es.array.includes", "es.string.includes"],
    indexOf: ["es.array.index-of"],
    italics: ["es.string.italics"],
    join: ["es.array.join"],
    keys: ArrayNatureIteratorsWithTag,
    lastIndex: ["esnext.array.last-index"],
    lastIndexOf: ["es.array.last-index-of"],
    lastItem: ["esnext.array.last-item"],
    link: ["es.string.link"],
    match: ["es.string.match", "es.regexp.exec"],
    matchAll: ["es.string.match-all", "esnext.string.match-all"],
    map: ["es.array.map"],
    name: ["es.function.name"],
    padEnd: ["es.string.pad-end"],
    padStart: ["es.string.pad-start"],
    reduce: ["es.array.reduce"],
    reduceRight: ["es.array.reduce-right"],
    repeat: ["es.string.repeat"],
    replace: ["es.string.replace", "es.regexp.exec"],
    replaceAll: ["esnext.string.replace-all"],
    reverse: ["es.array.reverse"],
    search: ["es.string.search", "es.regexp.exec"],
    slice: ["es.array.slice"],
    small: ["es.string.small"],
    some: ["es.array.some"],
    sort: ["es.array.sort"],
    splice: ["es.array.splice"],
    split: ["es.string.split", "es.regexp.exec"],
    startsWith: ["es.string.starts-with"],
    strike: ["es.string.strike"],
    sub: ["es.string.sub"],
    sup: ["es.string.sup"],
    toFixed: ["es.number.to-fixed"],
    toISOString: ["es.date.to-iso-string"],
    toJSON: ["es.date.to-json", "web.url.to-json"],
    toPrecision: ["es.number.to-precision"],
    toString: ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"],
    trim: ["es.string.trim"],
    trimEnd: ["es.string.trim-end"],
    trimLeft: ["es.string.trim-start"],
    trimRight: ["es.string.trim-end"],
    trimStart: ["es.string.trim-start"],
    values: ArrayNatureIteratorsWithTag,
    __defineGetter__: ["es.object.define-getter"],
    __defineSetter__: ["es.object.define-setter"],
    __lookupGetter__: ["es.object.lookup-getter"],
    __lookupSetter__: ["es.object.lookup-setter"]
  };
  var StaticProperties$1 = {
    Array: {
      from: ["es.array.from", "es.string.iterator"],
      isArray: ["es.array.is-array"],
      of: ["es.array.of"]
    },
    Date: {
      now: "es.date.now"
    },
    Object: {
      assign: "es.object.assign",
      create: "es.object.create",
      defineProperty: "es.object.define-property",
      defineProperties: "es.object.define-properties",
      entries: "es.object.entries",
      freeze: "es.object.freeze",
      fromEntries: ["es.object.from-entries", "es.array.iterator"],
      getOwnPropertyDescriptor: "es.object.get-own-property-descriptor",
      getOwnPropertyDescriptors: "es.object.get-own-property-descriptors",
      getOwnPropertyNames: "es.object.get-own-property-names",
      getOwnPropertySymbols: "es.symbol",
      getPrototypeOf: "es.object.get-prototype-of",
      is: "es.object.is",
      isExtensible: "es.object.is-extensible",
      isFrozen: "es.object.is-frozen",
      isSealed: "es.object.is-sealed",
      keys: "es.object.keys",
      preventExtensions: "es.object.prevent-extensions",
      seal: "es.object.seal",
      setPrototypeOf: "es.object.set-prototype-of",
      values: "es.object.values"
    },
    Math: {
      DEG_PER_RAD: "esnext.math.deg-per-rad",
      RAD_PER_DEG: "esnext.math.rad-per-deg",
      acosh: "es.math.acosh",
      asinh: "es.math.asinh",
      atanh: "es.math.atanh",
      cbrt: "es.math.cbrt",
      clamp: "esnext.math.clamp",
      clz32: "es.math.clz32",
      cosh: "es.math.cosh",
      degrees: "esnext.math.degrees",
      expm1: "es.math.expm1",
      fround: "es.math.fround",
      fscale: "esnext.math.fscale",
      hypot: "es.math.hypot",
      iaddh: "esnext.math.iaddh",
      imul: "es.math.imul",
      imulh: "esnext.math.imulh",
      isubh: "esnext.math.isubh",
      log1p: "es.math.log1p",
      log10: "es.math.log10",
      log2: "es.math.log2",
      radians: "esnext.math.radians",
      scale: "esnext.math.scale",
      seededPRNG: "esnext.math.seeded-prng",
      sign: "es.math.sign",
      signbit: "esnext.math.signbit",
      sinh: "es.math.sinh",
      tanh: "es.math.tanh",
      trunc: "es.math.trunc",
      umulh: "esnext.math.umulh"
    },
    String: {
      fromCodePoint: "es.string.from-code-point",
      raw: "es.string.raw"
    },
    Number: {
      EPSILON: "es.number.epsilon",
      MIN_SAFE_INTEGER: "es.number.min-safe-integer",
      MAX_SAFE_INTEGER: "es.number.max-safe-integer",
      fromString: "esnext.number.from-string",
      isFinite: "es.number.is-finite",
      isInteger: "es.number.is-integer",
      isSafeInteger: "es.number.is-safe-integer",
      isNaN: "es.number.is-nan",
      parseFloat: "es.number.parse-float",
      parseInt: "es.number.parse-int"
    },
    Map: {
      from: ["esnext.map.from"].concat(MapDependencies),
      groupBy: ["esnext.map.group-by"].concat(MapDependencies),
      keyBy: ["esnext.map.key-by"].concat(MapDependencies),
      of: ["esnext.map.of"].concat(MapDependencies)
    },
    Set: {
      from: ["esnext.set.from"].concat(SetDependencies),
      of: ["esnext.set.of"].concat(SetDependencies)
    },
    WeakMap: {
      from: ["esnext.weak-map.from"].concat(WeakMapDependencies),
      of: ["esnext.weak-map.of"].concat(WeakMapDependencies)
    },
    WeakSet: {
      from: ["esnext.weak-set.from"].concat(WeakSetDependencies),
      of: ["esnext.weak-set.of"].concat(WeakSetDependencies)
    },
    Promise: {
      all: PromiseDependenciesWithIterators,
      allSettled: ["es.promise.all-settled", "esnext.promise.all-settled"].concat(PromiseDependenciesWithIterators),
      any: ["esnext.promise.any", "esnext.aggregate-error"].concat(PromiseDependenciesWithIterators),
      race: PromiseDependenciesWithIterators,
      "try": ["esnext.promise.try"].concat(PromiseDependenciesWithIterators)
    },
    Reflect: {
      apply: "es.reflect.apply",
      construct: "es.reflect.construct",
      defineMetadata: "esnext.reflect.define-metadata",
      defineProperty: "es.reflect.define-property",
      deleteMetadata: "esnext.reflect.delete-metadata",
      deleteProperty: "es.reflect.delete-property",
      get: "es.reflect.get",
      getMetadata: "esnext.reflect.get-metadata",
      getMetadataKeys: "esnext.reflect.get-metadata-keys",
      getOwnMetadata: "esnext.reflect.get-own-metadata",
      getOwnMetadataKeys: "esnext.reflect.get-own-metadata-keys",
      getOwnPropertyDescriptor: "es.reflect.get-own-property-descriptor",
      getPrototypeOf: "es.reflect.get-prototype-of",
      has: "es.reflect.has",
      hasMetadata: "esnext.reflect.has-metadata",
      hasOwnMetadata: "esnext.reflect.has-own-metadata",
      isExtensible: "es.reflect.is-extensible",
      metadata: "esnext.reflect.metadata",
      ownKeys: "es.reflect.own-keys",
      preventExtensions: "es.reflect.prevent-extensions",
      set: "es.reflect.set",
      setPrototypeOf: "es.reflect.set-prototype-of"
    },
    Symbol: {
      asyncIterator: ["es.symbol.async-iterator"],
      dispose: ["esnext.symbol.dispose"],
      hasInstance: ["es.symbol.has-instance", "es.function.has-instance"],
      isConcatSpreadable: ["es.symbol.is-concat-spreadable", "es.array.concat"],
      iterator: ["es.symbol.iterator"].concat(CommonIteratorsWithTag),
      match: ["es.symbol.match", "es.string.match"],
      observable: ["esnext.symbol.observable"],
      patternMatch: ["esnext.symbol.pattern-match"],
      replace: ["es.symbol.replace", "es.string.replace"],
      search: ["es.symbol.search", "es.string.search"],
      species: ["es.symbol.species", "es.array.species"],
      split: ["es.symbol.split", "es.string.split"],
      toPrimitive: ["es.symbol.to-primitive", "es.date.to-primitive"],
      toStringTag: ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"],
      unscopables: ["es.symbol.unscopables"]
    },
    ArrayBuffer: {
      isView: ["es.array-buffer.is-view"]
    },
    Int8Array: TypedArrayStaticMethods,
    Uint8Array: TypedArrayStaticMethods,
    Uint8ClampedArray: TypedArrayStaticMethods,
    Int16Array: TypedArrayStaticMethods,
    Uint16Array: TypedArrayStaticMethods,
    Int32Array: TypedArrayStaticMethods,
    Uint32Array: TypedArrayStaticMethods,
    Float32Array: TypedArrayStaticMethods,
    Float64Array: TypedArrayStaticMethods
  };
  var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);
  var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);

  var NO_DIRECT_POLYFILL_IMPORT$1 = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: 'entry'` instead.";
  var corejs3PolyfillsWithoutProposals = Object.keys(corejs3Polyfills).filter(function (name) {
    return !name.startsWith("esnext.");
  }).reduce(function (memo, key) {
    memo[key] = corejs3Polyfills[key];
    return memo;
  }, {});
  var corejs3PolyfillsWithShippedProposals = corejs3ShippedProposals$2.reduce(function (memo, key) {
    memo[key] = corejs3Polyfills[key];
    return memo;
  }, Object.assign({}, corejs3PolyfillsWithoutProposals));
  function addCoreJS3UsagePlugin (_, _ref) {
    var corejs = _ref.corejs,
        include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        proposals = _ref.proposals,
        shippedProposals = _ref.shippedProposals,
        debug = _ref.debug;
    var polyfills = filterItems(proposals ? corejs3Polyfills : shippedProposals ? corejs3PolyfillsWithShippedProposals : corejs3PolyfillsWithoutProposals, include, exclude, polyfillTargets, null);
    var available = new Set(getModulesListForTargetVersion(corejs.version));

    function resolveKey(path, computed) {
      var node = path.node,
          parent = path.parent,
          scope = path.scope;
      if (path.isStringLiteral()) return node.value;
      var name = node.name;
      var isIdentifier = path.isIdentifier();
      if (isIdentifier && !(computed || parent.computed)) return name;

      if (!isIdentifier || scope.getBindingIdentifier(name)) {
        var _path$evaluate = path.evaluate(),
            value = _path$evaluate.value;

        if (typeof value === "string") return value;
      }
    }

    function resolveSource(path) {
      var node = path.node,
          scope = path.scope;
      var builtIn, instanceType;

      if (node) {
        builtIn = node.name;

        if (!path.isIdentifier() || scope.getBindingIdentifier(builtIn)) {
          var _path$evaluate2 = path.evaluate(),
              deopt = _path$evaluate2.deopt,
              value = _path$evaluate2.value;

          if (value !== undefined) {
            instanceType = getType$1(value);
          } else if (deopt == null ? void 0 : deopt.isIdentifier()) {
            builtIn = deopt.node.name;
          }
        }
      }

      return {
        builtIn: builtIn,
        instanceType: instanceType,
        isNamespaced: isNamespaced(path)
      };
    }

    var addAndRemovePolyfillImports = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
          path.remove();
        }
      },
      Program: {
        enter: function enter(path) {
          path.get("body").forEach(function (bodyPath) {
            if (isPolyfillSource(getRequireSource(bodyPath))) {
              console.warn(NO_DIRECT_POLYFILL_IMPORT$1);
              bodyPath.remove();
            }
          });
        },
        exit: function exit(path) {
          var _this = this;

          var filtered = intersection(polyfills, this.polyfillsSet, available);
          var reversed = Array.from(filtered).reverse();

          for (var _iterator = _createForOfIteratorHelperLoose(reversed), _step; !(_step = _iterator()).done;) {
            var module = _step.value;

            if (!this.injectedPolyfills.has(module)) {
              createImport(path, module);
            }
          }

          filtered.forEach(function (module) {
            return _this.injectedPolyfills.add(module);
          });
        }
      },
      Import: function Import() {
        this.addUnsupported(PromiseDependencies$1);
      },
      Function: function Function(_ref2) {
        var node = _ref2.node;

        if (node.async) {
          this.addUnsupported(PromiseDependencies$1);
        }
      },
      "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern() {
        this.addUnsupported(CommonIterators$1);
      },
      SpreadElement: function SpreadElement(_ref3) {
        var parentPath = _ref3.parentPath;

        if (!parentPath.isObjectExpression()) {
          this.addUnsupported(CommonIterators$1);
        }
      },
      YieldExpression: function YieldExpression(_ref4) {
        var node = _ref4.node;

        if (node.delegate) {
          this.addUnsupported(CommonIterators$1);
        }
      },
      ReferencedIdentifier: function ReferencedIdentifier(_ref5) {
        var name = _ref5.node.name,
            scope = _ref5.scope;
        if (scope.getBindingIdentifier(name)) return;
        this.addBuiltInDependencies(name);
      },
      MemberExpression: function MemberExpression(path) {
        var source = resolveSource(path.get("object"));
        var key = resolveKey(path.get("property"));
        this.addPropertyDependencies(source, key);
      },
      ObjectPattern: function ObjectPattern(path) {
        var parentPath = path.parentPath,
            parent = path.parent,
            key = path.key;
        var source;

        if (parentPath.isVariableDeclarator()) {
          source = resolveSource(parentPath.get("init"));
        } else if (parentPath.isAssignmentExpression()) {
          source = resolveSource(parentPath.get("right"));
        } else if (parentPath.isFunctionExpression()) {
          var grand = parentPath.parentPath;

          if (grand.isCallExpression() || grand.isNewExpression()) {
            if (grand.node.callee === parent) {
              source = resolveSource(grand.get("arguments")[key]);
            }
          }
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
          var property = _step2.value;

          if (property.isObjectProperty()) {
            var _key = resolveKey(property.get("key"));

            this.addPropertyDependencies(source, _key);
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        var source = resolveSource(path.get("right"));
        var key = resolveKey(path.get("left"), true);
        this.addPropertyDependencies(source, key);
      }
    };
    return {
      name: "corejs3-usage",
      pre: function pre() {
        this.injectedPolyfills = new Set();
        this.polyfillsSet = new Set();

        this.addUnsupported = function (builtIn) {
          var modules = Array.isArray(builtIn) ? builtIn : [builtIn];

          for (var _iterator3 = _createForOfIteratorHelperLoose(modules), _step3; !(_step3 = _iterator3()).done;) {
            var module = _step3.value;
            this.polyfillsSet.add(module);
          }
        };

        this.addBuiltInDependencies = function (builtIn) {
          if (has$6(BuiltIns$1, builtIn)) {
            var BuiltInDependencies = BuiltIns$1[builtIn];
            this.addUnsupported(BuiltInDependencies);
          }
        };

        this.addPropertyDependencies = function (source, key) {
          if (source === void 0) {
            source = {};
          }

          var _source = source,
              builtIn = _source.builtIn,
              instanceType = _source.instanceType,
              isNamespaced = _source.isNamespaced;
          if (isNamespaced) return;

          if (PossibleGlobalObjects.has(builtIn)) {
            this.addBuiltInDependencies(key);
          } else if (has$6(StaticProperties$1, builtIn)) {
            var BuiltInProperties = StaticProperties$1[builtIn];

            if (has$6(BuiltInProperties, key)) {
              var StaticPropertyDependencies = BuiltInProperties[key];
              return this.addUnsupported(StaticPropertyDependencies);
            }
          }

          if (!has$6(InstanceProperties$1, key)) return;
          var InstancePropertyDependencies = InstanceProperties$1[key];

          if (instanceType) {
            InstancePropertyDependencies = InstancePropertyDependencies.filter(function (m) {
              return m.includes(instanceType) || CommonInstanceDependencies.has(m);
            });
          }

          this.addUnsupported(InstancePropertyDependencies);
        };
      },
      post: function post() {
        if (debug) {
          logUsagePolyfills(this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
        }
      },
      visitor: addAndRemovePolyfillImports
    };
  }

  function addRegeneratorUsagePlugin () {
    return {
      name: "regenerator-usage",
      pre: function pre() {
        this.usesRegenerator = false;
      },
      visitor: {
        Function: function Function(path) {
          var node = path.node;

          if (!this.usesRegenerator && (node.generator || node.async)) {
            this.usesRegenerator = true;
            createImport(path, "regenerator-runtime");
          }
        }
      },
      post: function post() {
        if (this.opts.debug && this.usesRegenerator) {
          var filename = this.file.opts.filename;

          if (process.env.BABEL_ENV === "test") {
            filename = filename.replace(/\\/g, "/");
          }

          console.log("\n[" + filename + "] Based on your code and targets, added regenerator-runtime.");
        }
      }
    };
  }

  function replaceCoreJS2EntryPlugin (_, _ref) {
    var include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        regenerator = _ref.regenerator,
        debug = _ref.debug;
    var polyfills = filterItems(corejs2BuiltIns$2, include, exclude, polyfillTargets, getPlatformSpecificDefaultFor(polyfillTargets));
    var isPolyfillImport = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isPolyfillSource(getImportSource(path))) {
          this.replaceBySeparateModulesImport(path);
        }
      },
      Program: function Program(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          if (isPolyfillSource(getRequireSource(bodyPath))) {
            _this.replaceBySeparateModulesImport(bodyPath);
          }
        });
      }
    };
    return {
      name: "corejs2-entry",
      visitor: isPolyfillImport,
      pre: function pre() {
        this.importPolyfillIncluded = false;

        this.replaceBySeparateModulesImport = function (path) {
          this.importPolyfillIncluded = true;

          if (regenerator) {
            createImport(path, "regenerator-runtime");
          }

          var modules = Array.from(polyfills).reverse();

          for (var _iterator = _createForOfIteratorHelperLoose(modules), _step; !(_step = _iterator()).done;) {
            var module = _step.value;
            createImport(path, module);
          }

          path.remove();
        };
      },
      post: function post() {
        if (debug) {
          logEntryPolyfills("@babel/polyfill", this.importPolyfillIncluded, polyfills, this.file.opts.filename, polyfillTargets, corejs2BuiltIns$2);
        }
      }
    };
  }

  var corejsEntries = {
  	"core-js": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/es": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set"
  ],
  	"core-js/es/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.string.iterator"
  ],
  	"core-js/es/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/es/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/es/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/es/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/es/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/every": [
  	"es.array.every"
  ],
  	"core-js/es/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/array/find": [
  	"es.array.find"
  ],
  	"core-js/es/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/es/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/es/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/es/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/join": [
  	"es.array.join"
  ],
  	"core-js/es/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/array/map": [
  	"es.array.map"
  ],
  	"core-js/es/array/of": [
  	"es.array.of"
  ],
  	"core-js/es/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/array/some": [
  	"es.array.some"
  ],
  	"core-js/es/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/es/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/array/virtual/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/es/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/es/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/es/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/es/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/es/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/es/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/es/date": [
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/es/date/now": [
  	"es.date.now"
  ],
  	"core-js/es/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/es/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/es/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/es/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/es/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/es/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/es/function/name": [
  	"es.function.name"
  ],
  	"core-js/es/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/es/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/global-this": [
  	"es.global-this"
  ],
  	"core-js/es/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/instance/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/instance/every": [
  	"es.array.every"
  ],
  	"core-js/es/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/instance/find": [
  	"es.array.find"
  ],
  	"core-js/es/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/es/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/instance/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/es/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/instance/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/instance/map": [
  	"es.array.map"
  ],
  	"core-js/es/instance/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/instance/some": [
  	"es.array.some"
  ],
  	"core-js/es/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/instance/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/es/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/es/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/es/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc"
  ],
  	"core-js/es/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/es/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/es/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/es/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/es/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/es/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/es/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/es/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/es/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/es/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/es/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/es/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/es/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/es/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/es/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/es/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/es/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/es/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/es/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/es/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/es/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/es/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/es/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/es/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/es/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/es/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/es/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/es/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/es/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/es/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/es/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/es/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/es/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/es/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/es/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/es/object/create": [
  	"es.object.create"
  ],
  	"core-js/es/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/es/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/es/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/es/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/es/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/es/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/es/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/es/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/es/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/es/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/es/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/es/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/es/object/is": [
  	"es.object.is"
  ],
  	"core-js/es/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/es/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/es/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/es/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/es/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/es/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/es/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/es/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/es/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/es/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/object/values": [
  	"es.object.values"
  ],
  	"core-js/es/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/es/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/es/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled"
  ],
  	"core-js/es/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any"
  ],
  	"core-js/es/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/es/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/es/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/es/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/es/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/es/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/es/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/es/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/es/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/es/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/es/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/es/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/es/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/es/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/es/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/es/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/es/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/es/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/es/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/es/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/es/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/es/regexp/sticky": [
  	"es.regexp.sticky"
  ],
  	"core-js/es/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/es/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/es/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/es/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/es/string/big": [
  	"es.string.big"
  ],
  	"core-js/es/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/es/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/es/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/es/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/es/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/es/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/es/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/es/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/es/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/es/string/link": [
  	"es.string.link"
  ],
  	"core-js/es/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/es/string/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/es/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/es/string/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/es/string/small": [
  	"es.string.small"
  ],
  	"core-js/es/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/es/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/es/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/es/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/es/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/es/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/es/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/es/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/es/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/es/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/es/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/es/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/es/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/es/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/es/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/es/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/es/string/virtual/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/string/virtual/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/es/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/es/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/es/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/es/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/es/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/es/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/es/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/es/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/es/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/es/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/es/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/es/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/es/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/es/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/es/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/es/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/es/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/es/typed-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/es/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/es/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/es/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/es/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/es/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/es/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/es/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/es/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/es/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/es/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/es/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/es/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/es/typed-array/methods": [
  	"es.object.to-string",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/es/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/es/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/es/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/es/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/es/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/es/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/es/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/es/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/es/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/es/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/features/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.map",
  	"es.string.iterator",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/features/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/features/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/features/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/features/array/at": [
  	"esnext.array.at"
  ],
  	"core-js/features/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/every": [
  	"es.array.every"
  ],
  	"core-js/features/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/array/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/array/find": [
  	"es.array.find"
  ],
  	"core-js/features/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/features/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/features/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/features/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/features/array/is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/features/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/join": [
  	"es.array.join"
  ],
  	"core-js/features/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/last-index": [
  	"esnext.array.last-index"
  ],
  	"core-js/features/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/array/last-item": [
  	"esnext.array.last-item"
  ],
  	"core-js/features/array/map": [
  	"es.array.map"
  ],
  	"core-js/features/array/of": [
  	"es.array.of"
  ],
  	"core-js/features/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/array/some": [
  	"es.array.some"
  ],
  	"core-js/features/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/array/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/virtual/at": [
  	"esnext.array.at"
  ],
  	"core-js/features/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/features/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/array/virtual/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/features/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/features/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/features/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/features/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/features/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/features/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/array/virtual/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/features/async-iterator": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/as-indexed-pairs": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/drop": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.drop",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/every": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.every",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/filter": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.filter",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/find": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.find",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/flat-map": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.flat-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/for-each": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/from": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/map": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/reduce": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.reduce",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/some": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.some",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/take": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.take",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/to-array": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/bigint": [
  	"esnext.bigint.range"
  ],
  	"core-js/features/bigint/range": [
  	"esnext.bigint.range"
  ],
  	"core-js/features/clear-immediate": [
  	"web.immediate"
  ],
  	"core-js/features/composite-key": [
  	"esnext.composite-key"
  ],
  	"core-js/features/composite-symbol": [
  	"es.symbol",
  	"esnext.composite-symbol"
  ],
  	"core-js/features/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/features/date": [
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/features/date/now": [
  	"es.date.now"
  ],
  	"core-js/features/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/features/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/features/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/features/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/features/dom-collections": [
  	"es.array.iterator",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/dom-collections/for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/features/dom-collections/iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/features/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/features/function/name": [
  	"es.function.name"
  ],
  	"core-js/features/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/features/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/get-iterator": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/get-iterator-method": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/global-this": [
  	"es.global-this",
  	"esnext.global-this"
  ],
  	"core-js/features/instance/at": [
  	"esnext.array.at",
  	"esnext.string.at"
  ],
  	"core-js/features/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/instance/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/instance/entries": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/every": [
  	"es.array.every"
  ],
  	"core-js/features/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/instance/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/instance/find": [
  	"es.array.find"
  ],
  	"core-js/features/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/features/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/instance/for-each": [
  	"es.array.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/features/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/instance/keys": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/instance/map": [
  	"es.array.map"
  ],
  	"core-js/features/instance/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/features/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/instance/some": [
  	"es.array.some"
  ],
  	"core-js/features/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/instance/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/instance/values": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/is-iterable": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/as-indexed-pairs": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/drop": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.drop",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/every": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.every",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/filter": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.filter",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/find": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.find",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/flat-map": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.flat-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/for-each": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/from": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/map": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/reduce": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.reduce",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/some": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.some",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/take": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.take",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/to-array": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/features/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/features/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/features/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/delete-all": [
  	"es.map",
  	"esnext.map.delete-all"
  ],
  	"core-js/features/map/emplace": [
  	"es.map",
  	"esnext.map.emplace"
  ],
  	"core-js/features/map/every": [
  	"es.map",
  	"esnext.map.every"
  ],
  	"core-js/features/map/filter": [
  	"es.map",
  	"esnext.map.filter"
  ],
  	"core-js/features/map/find": [
  	"es.map",
  	"esnext.map.find"
  ],
  	"core-js/features/map/find-key": [
  	"es.map",
  	"esnext.map.find-key"
  ],
  	"core-js/features/map/from": [
  	"es.map",
  	"es.string.iterator",
  	"esnext.map.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/group-by": [
  	"es.map",
  	"esnext.map.group-by"
  ],
  	"core-js/features/map/includes": [
  	"es.map",
  	"esnext.map.includes"
  ],
  	"core-js/features/map/key-by": [
  	"es.map",
  	"esnext.map.key-by"
  ],
  	"core-js/features/map/key-of": [
  	"es.map",
  	"esnext.map.key-of"
  ],
  	"core-js/features/map/map-keys": [
  	"es.map",
  	"esnext.map.map-keys"
  ],
  	"core-js/features/map/map-values": [
  	"es.map",
  	"esnext.map.map-values"
  ],
  	"core-js/features/map/merge": [
  	"es.map",
  	"esnext.map.merge"
  ],
  	"core-js/features/map/of": [
  	"es.map",
  	"es.string.iterator",
  	"esnext.map.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/reduce": [
  	"es.map",
  	"esnext.map.reduce"
  ],
  	"core-js/features/map/some": [
  	"es.map",
  	"esnext.map.some"
  ],
  	"core-js/features/map/update": [
  	"es.map",
  	"esnext.map.update"
  ],
  	"core-js/features/map/update-or-insert": [
  	"es.map",
  	"esnext.map.update-or-insert"
  ],
  	"core-js/features/map/upsert": [
  	"es.map",
  	"esnext.map.upsert"
  ],
  	"core-js/features/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh"
  ],
  	"core-js/features/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/features/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/features/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/features/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/features/math/clamp": [
  	"esnext.math.clamp"
  ],
  	"core-js/features/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/features/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/features/math/deg-per-rad": [
  	"esnext.math.deg-per-rad"
  ],
  	"core-js/features/math/degrees": [
  	"esnext.math.degrees"
  ],
  	"core-js/features/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/features/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/features/math/fscale": [
  	"esnext.math.fscale"
  ],
  	"core-js/features/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/features/math/iaddh": [
  	"esnext.math.iaddh"
  ],
  	"core-js/features/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/features/math/imulh": [
  	"esnext.math.imulh"
  ],
  	"core-js/features/math/isubh": [
  	"esnext.math.isubh"
  ],
  	"core-js/features/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/features/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/features/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/features/math/rad-per-deg": [
  	"esnext.math.rad-per-deg"
  ],
  	"core-js/features/math/radians": [
  	"esnext.math.radians"
  ],
  	"core-js/features/math/scale": [
  	"esnext.math.scale"
  ],
  	"core-js/features/math/seeded-prng": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/features/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/features/math/signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/features/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/features/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/features/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/features/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/features/math/umulh": [
  	"esnext.math.umulh"
  ],
  	"core-js/features/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"esnext.number.from-string",
  	"esnext.number.range"
  ],
  	"core-js/features/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/features/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/features/number/from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/features/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/features/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/features/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/features/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/features/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/features/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/features/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/features/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/features/number/range": [
  	"esnext.number.range"
  ],
  	"core-js/features/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/features/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/features/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/features/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/features/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/features/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"core-js/features/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/features/object/create": [
  	"es.object.create"
  ],
  	"core-js/features/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/features/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/features/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/features/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/features/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/features/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/features/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/features/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/features/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/features/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/features/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/features/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/features/object/is": [
  	"es.object.is"
  ],
  	"core-js/features/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/features/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/features/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/features/object/iterate-entries": [
  	"esnext.object.iterate-entries"
  ],
  	"core-js/features/object/iterate-keys": [
  	"esnext.object.iterate-keys"
  ],
  	"core-js/features/object/iterate-values": [
  	"esnext.object.iterate-values"
  ],
  	"core-js/features/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/features/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/features/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/features/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/features/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/features/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/features/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/object/values": [
  	"es.object.values"
  ],
  	"core-js/features/observable": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.observable",
  	"esnext.symbol.observable",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/features/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/features/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled",
  	"esnext.promise.all-settled"
  ],
  	"core-js/features/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any",
  	"esnext.aggregate-error",
  	"esnext.promise.any"
  ],
  	"core-js/features/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/features/promise/try": [
  	"es.promise",
  	"esnext.promise.try"
  ],
  	"core-js/features/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/features/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata"
  ],
  	"core-js/features/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/features/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/features/reflect/define-metadata": [
  	"esnext.reflect.define-metadata"
  ],
  	"core-js/features/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/features/reflect/delete-metadata": [
  	"esnext.reflect.delete-metadata"
  ],
  	"core-js/features/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/features/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/features/reflect/get-metadata": [
  	"esnext.reflect.get-metadata"
  ],
  	"core-js/features/reflect/get-metadata-keys": [
  	"esnext.reflect.get-metadata-keys"
  ],
  	"core-js/features/reflect/get-own-metadata": [
  	"esnext.reflect.get-own-metadata"
  ],
  	"core-js/features/reflect/get-own-metadata-keys": [
  	"esnext.reflect.get-own-metadata-keys"
  ],
  	"core-js/features/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/features/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/features/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/features/reflect/has-metadata": [
  	"esnext.reflect.has-metadata"
  ],
  	"core-js/features/reflect/has-own-metadata": [
  	"esnext.reflect.has-own-metadata"
  ],
  	"core-js/features/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/features/reflect/metadata": [
  	"esnext.reflect.metadata"
  ],
  	"core-js/features/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/features/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/features/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/features/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/features/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/features/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/features/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/features/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/features/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/features/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/features/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/features/regexp/sticky": [
  	"es.regexp.sticky"
  ],
  	"core-js/features/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/features/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/features/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set-immediate": [
  	"web.immediate"
  ],
  	"core-js/features/set-interval": [
  	"web.timers"
  ],
  	"core-js/features/set-timeout": [
  	"web.timers"
  ],
  	"core-js/features/set/add-all": [
  	"es.set",
  	"esnext.set.add-all"
  ],
  	"core-js/features/set/delete-all": [
  	"es.set",
  	"esnext.set.delete-all"
  ],
  	"core-js/features/set/difference": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.difference",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/every": [
  	"es.set",
  	"esnext.set.every"
  ],
  	"core-js/features/set/filter": [
  	"es.set",
  	"esnext.set.filter"
  ],
  	"core-js/features/set/find": [
  	"es.set",
  	"esnext.set.find"
  ],
  	"core-js/features/set/from": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/intersection": [
  	"es.set",
  	"esnext.set.intersection"
  ],
  	"core-js/features/set/is-disjoint-from": [
  	"es.set",
  	"esnext.set.is-disjoint-from"
  ],
  	"core-js/features/set/is-subset-of": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.is-subset-of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/is-superset-of": [
  	"es.set",
  	"esnext.set.is-superset-of"
  ],
  	"core-js/features/set/join": [
  	"es.set",
  	"esnext.set.join"
  ],
  	"core-js/features/set/map": [
  	"es.set",
  	"esnext.set.map"
  ],
  	"core-js/features/set/of": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/reduce": [
  	"es.set",
  	"esnext.set.reduce"
  ],
  	"core-js/features/set/some": [
  	"es.set",
  	"esnext.set.some"
  ],
  	"core-js/features/set/symmetric-difference": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.symmetric-difference",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/union": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.union",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/features/string/at": [
  	"esnext.string.at"
  ],
  	"core-js/features/string/big": [
  	"es.string.big"
  ],
  	"core-js/features/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/features/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/features/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/string/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/features/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/features/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/features/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/features/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/features/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/features/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/features/string/link": [
  	"es.string.link"
  ],
  	"core-js/features/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/features/string/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/features/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/features/string/replace-all": [
  	"es.string.replace-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/features/string/small": [
  	"es.string.small"
  ],
  	"core-js/features/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/features/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/features/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/features/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/features/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/features/string/virtual/at": [
  	"esnext.string.at"
  ],
  	"core-js/features/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/features/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/features/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/features/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/string/virtual/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/features/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/features/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/features/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/features/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/features/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/features/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/features/string/virtual/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/string/virtual/replace-all": [
  	"es.string.replace-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/features/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/features/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/features/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/features/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/features/symbol/async-dispose": [
  	"esnext.symbol.async-dispose"
  ],
  	"core-js/features/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/features/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/features/symbol/dispose": [
  	"esnext.symbol.dispose"
  ],
  	"core-js/features/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/features/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/features/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/features/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/features/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/features/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/features/symbol/observable": [
  	"esnext.symbol.observable"
  ],
  	"core-js/features/symbol/pattern-match": [
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/features/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/features/symbol/replace-all": [
  	"esnext.symbol.replace-all"
  ],
  	"core-js/features/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/features/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/features/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/features/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/features/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/features/typed-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/features/typed-array/at": [
  	"esnext.typed-array.at"
  ],
  	"core-js/features/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/features/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/features/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/features/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/features/typed-array/filter-out": [
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/features/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/features/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/features/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/features/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/features/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/features/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/features/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/features/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/features/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/features/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/features/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/features/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/features/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/features/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/features/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/features/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/features/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/features/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/features/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/features/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/features/url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/features/url/to-json": [
  	"web.url.to-json"
  ],
  	"core-js/features/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/delete-all": [
  	"es.weak-map",
  	"esnext.weak-map.delete-all"
  ],
  	"core-js/features/weak-map/emplace": [
  	"es.weak-map",
  	"esnext.weak-map.emplace"
  ],
  	"core-js/features/weak-map/from": [
  	"es.string.iterator",
  	"es.weak-map",
  	"esnext.weak-map.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/of": [
  	"es.string.iterator",
  	"es.weak-map",
  	"esnext.weak-map.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/upsert": [
  	"es.weak-map",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/features/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-set/add-all": [
  	"es.weak-set",
  	"esnext.weak-set.add-all"
  ],
  	"core-js/features/weak-set/delete-all": [
  	"es.weak-set",
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/features/weak-set/from": [
  	"es.string.iterator",
  	"es.weak-set",
  	"esnext.weak-set.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-set/of": [
  	"es.string.iterator",
  	"es.weak-set",
  	"esnext.weak-set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/modules/es.aggregate-error": [
  	"es.aggregate-error"
  ],
  	"core-js/modules/es.array-buffer.constructor": [
  	"es.array-buffer.constructor"
  ],
  	"core-js/modules/es.array-buffer.is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/modules/es.array-buffer.slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/modules/es.array.concat": [
  	"es.array.concat"
  ],
  	"core-js/modules/es.array.copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/modules/es.array.every": [
  	"es.array.every"
  ],
  	"core-js/modules/es.array.fill": [
  	"es.array.fill"
  ],
  	"core-js/modules/es.array.filter": [
  	"es.array.filter"
  ],
  	"core-js/modules/es.array.find": [
  	"es.array.find"
  ],
  	"core-js/modules/es.array.find-index": [
  	"es.array.find-index"
  ],
  	"core-js/modules/es.array.flat": [
  	"es.array.flat"
  ],
  	"core-js/modules/es.array.flat-map": [
  	"es.array.flat-map"
  ],
  	"core-js/modules/es.array.for-each": [
  	"es.array.for-each"
  ],
  	"core-js/modules/es.array.from": [
  	"es.array.from"
  ],
  	"core-js/modules/es.array.includes": [
  	"es.array.includes"
  ],
  	"core-js/modules/es.array.index-of": [
  	"es.array.index-of"
  ],
  	"core-js/modules/es.array.is-array": [
  	"es.array.is-array"
  ],
  	"core-js/modules/es.array.iterator": [
  	"es.array.iterator"
  ],
  	"core-js/modules/es.array.join": [
  	"es.array.join"
  ],
  	"core-js/modules/es.array.last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/modules/es.array.map": [
  	"es.array.map"
  ],
  	"core-js/modules/es.array.of": [
  	"es.array.of"
  ],
  	"core-js/modules/es.array.reduce": [
  	"es.array.reduce"
  ],
  	"core-js/modules/es.array.reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/modules/es.array.reverse": [
  	"es.array.reverse"
  ],
  	"core-js/modules/es.array.slice": [
  	"es.array.slice"
  ],
  	"core-js/modules/es.array.some": [
  	"es.array.some"
  ],
  	"core-js/modules/es.array.sort": [
  	"es.array.sort"
  ],
  	"core-js/modules/es.array.species": [
  	"es.array.species"
  ],
  	"core-js/modules/es.array.splice": [
  	"es.array.splice"
  ],
  	"core-js/modules/es.array.unscopables.flat": [
  	"es.array.unscopables.flat"
  ],
  	"core-js/modules/es.array.unscopables.flat-map": [
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/modules/es.data-view": [
  	"es.data-view"
  ],
  	"core-js/modules/es.date.now": [
  	"es.date.now"
  ],
  	"core-js/modules/es.date.to-iso-string": [
  	"es.date.to-iso-string"
  ],
  	"core-js/modules/es.date.to-json": [
  	"es.date.to-json"
  ],
  	"core-js/modules/es.date.to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/modules/es.date.to-string": [
  	"es.date.to-string"
  ],
  	"core-js/modules/es.function.bind": [
  	"es.function.bind"
  ],
  	"core-js/modules/es.function.has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/modules/es.function.name": [
  	"es.function.name"
  ],
  	"core-js/modules/es.global-this": [
  	"es.global-this"
  ],
  	"core-js/modules/es.json.stringify": [
  	"es.json.stringify"
  ],
  	"core-js/modules/es.json.to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/modules/es.map": [
  	"es.map"
  ],
  	"core-js/modules/es.math.acosh": [
  	"es.math.acosh"
  ],
  	"core-js/modules/es.math.asinh": [
  	"es.math.asinh"
  ],
  	"core-js/modules/es.math.atanh": [
  	"es.math.atanh"
  ],
  	"core-js/modules/es.math.cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/modules/es.math.clz32": [
  	"es.math.clz32"
  ],
  	"core-js/modules/es.math.cosh": [
  	"es.math.cosh"
  ],
  	"core-js/modules/es.math.expm1": [
  	"es.math.expm1"
  ],
  	"core-js/modules/es.math.fround": [
  	"es.math.fround"
  ],
  	"core-js/modules/es.math.hypot": [
  	"es.math.hypot"
  ],
  	"core-js/modules/es.math.imul": [
  	"es.math.imul"
  ],
  	"core-js/modules/es.math.log10": [
  	"es.math.log10"
  ],
  	"core-js/modules/es.math.log1p": [
  	"es.math.log1p"
  ],
  	"core-js/modules/es.math.log2": [
  	"es.math.log2"
  ],
  	"core-js/modules/es.math.sign": [
  	"es.math.sign"
  ],
  	"core-js/modules/es.math.sinh": [
  	"es.math.sinh"
  ],
  	"core-js/modules/es.math.tanh": [
  	"es.math.tanh"
  ],
  	"core-js/modules/es.math.to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/modules/es.math.trunc": [
  	"es.math.trunc"
  ],
  	"core-js/modules/es.number.constructor": [
  	"es.number.constructor"
  ],
  	"core-js/modules/es.number.epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/modules/es.number.is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/modules/es.number.is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/modules/es.number.is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/modules/es.number.is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/modules/es.number.max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/modules/es.number.min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/modules/es.number.parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/modules/es.number.parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/modules/es.number.to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/modules/es.number.to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/modules/es.object.assign": [
  	"es.object.assign"
  ],
  	"core-js/modules/es.object.create": [
  	"es.object.create"
  ],
  	"core-js/modules/es.object.define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/modules/es.object.define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/modules/es.object.define-property": [
  	"es.object.define-property"
  ],
  	"core-js/modules/es.object.define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/modules/es.object.entries": [
  	"es.object.entries"
  ],
  	"core-js/modules/es.object.freeze": [
  	"es.object.freeze"
  ],
  	"core-js/modules/es.object.from-entries": [
  	"es.object.from-entries"
  ],
  	"core-js/modules/es.object.get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/modules/es.object.get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/modules/es.object.get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/modules/es.object.get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/modules/es.object.is": [
  	"es.object.is"
  ],
  	"core-js/modules/es.object.is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/modules/es.object.is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/modules/es.object.is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/modules/es.object.keys": [
  	"es.object.keys"
  ],
  	"core-js/modules/es.object.lookup-getter": [
  	"es.object.lookup-getter"
  ],
  	"core-js/modules/es.object.lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/modules/es.object.prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/modules/es.object.seal": [
  	"es.object.seal"
  ],
  	"core-js/modules/es.object.set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/modules/es.object.to-string": [
  	"es.object.to-string"
  ],
  	"core-js/modules/es.object.values": [
  	"es.object.values"
  ],
  	"core-js/modules/es.parse-float": [
  	"es.parse-float"
  ],
  	"core-js/modules/es.parse-int": [
  	"es.parse-int"
  ],
  	"core-js/modules/es.promise": [
  	"es.promise"
  ],
  	"core-js/modules/es.promise.all-settled": [
  	"es.promise.all-settled"
  ],
  	"core-js/modules/es.promise.any": [
  	"es.promise.any"
  ],
  	"core-js/modules/es.promise.finally": [
  	"es.promise.finally"
  ],
  	"core-js/modules/es.reflect.apply": [
  	"es.reflect.apply"
  ],
  	"core-js/modules/es.reflect.construct": [
  	"es.reflect.construct"
  ],
  	"core-js/modules/es.reflect.define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/modules/es.reflect.delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/modules/es.reflect.get": [
  	"es.reflect.get"
  ],
  	"core-js/modules/es.reflect.get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/modules/es.reflect.get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/modules/es.reflect.has": [
  	"es.reflect.has"
  ],
  	"core-js/modules/es.reflect.is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/modules/es.reflect.own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/modules/es.reflect.prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/modules/es.reflect.set": [
  	"es.reflect.set"
  ],
  	"core-js/modules/es.reflect.set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/modules/es.reflect.to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/modules/es.regexp.constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/modules/es.regexp.exec": [
  	"es.regexp.exec"
  ],
  	"core-js/modules/es.regexp.flags": [
  	"es.regexp.flags"
  ],
  	"core-js/modules/es.regexp.sticky": [
  	"es.regexp.sticky"
  ],
  	"core-js/modules/es.regexp.test": [
  	"es.regexp.test"
  ],
  	"core-js/modules/es.regexp.to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/modules/es.set": [
  	"es.set"
  ],
  	"core-js/modules/es.string.anchor": [
  	"es.string.anchor"
  ],
  	"core-js/modules/es.string.big": [
  	"es.string.big"
  ],
  	"core-js/modules/es.string.blink": [
  	"es.string.blink"
  ],
  	"core-js/modules/es.string.bold": [
  	"es.string.bold"
  ],
  	"core-js/modules/es.string.code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/modules/es.string.ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/modules/es.string.fixed": [
  	"es.string.fixed"
  ],
  	"core-js/modules/es.string.fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/modules/es.string.fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/modules/es.string.from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/modules/es.string.includes": [
  	"es.string.includes"
  ],
  	"core-js/modules/es.string.italics": [
  	"es.string.italics"
  ],
  	"core-js/modules/es.string.iterator": [
  	"es.string.iterator"
  ],
  	"core-js/modules/es.string.link": [
  	"es.string.link"
  ],
  	"core-js/modules/es.string.match": [
  	"es.string.match"
  ],
  	"core-js/modules/es.string.match-all": [
  	"es.string.match-all"
  ],
  	"core-js/modules/es.string.pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/modules/es.string.pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/modules/es.string.raw": [
  	"es.string.raw"
  ],
  	"core-js/modules/es.string.repeat": [
  	"es.string.repeat"
  ],
  	"core-js/modules/es.string.replace": [
  	"es.string.replace"
  ],
  	"core-js/modules/es.string.replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/modules/es.string.search": [
  	"es.string.search"
  ],
  	"core-js/modules/es.string.small": [
  	"es.string.small"
  ],
  	"core-js/modules/es.string.split": [
  	"es.string.split"
  ],
  	"core-js/modules/es.string.starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/modules/es.string.strike": [
  	"es.string.strike"
  ],
  	"core-js/modules/es.string.sub": [
  	"es.string.sub"
  ],
  	"core-js/modules/es.string.sup": [
  	"es.string.sup"
  ],
  	"core-js/modules/es.string.trim": [
  	"es.string.trim"
  ],
  	"core-js/modules/es.string.trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/modules/es.string.trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/modules/es.symbol": [
  	"es.symbol"
  ],
  	"core-js/modules/es.symbol.async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/modules/es.symbol.description": [
  	"es.symbol.description"
  ],
  	"core-js/modules/es.symbol.has-instance": [
  	"es.symbol.has-instance"
  ],
  	"core-js/modules/es.symbol.is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable"
  ],
  	"core-js/modules/es.symbol.iterator": [
  	"es.symbol.iterator"
  ],
  	"core-js/modules/es.symbol.match": [
  	"es.symbol.match"
  ],
  	"core-js/modules/es.symbol.match-all": [
  	"es.symbol.match-all"
  ],
  	"core-js/modules/es.symbol.replace": [
  	"es.symbol.replace"
  ],
  	"core-js/modules/es.symbol.search": [
  	"es.symbol.search"
  ],
  	"core-js/modules/es.symbol.species": [
  	"es.symbol.species"
  ],
  	"core-js/modules/es.symbol.split": [
  	"es.symbol.split"
  ],
  	"core-js/modules/es.symbol.to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/modules/es.symbol.to-string-tag": [
  	"es.symbol.to-string-tag"
  ],
  	"core-js/modules/es.symbol.unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/modules/es.typed-array.copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/modules/es.typed-array.every": [
  	"es.typed-array.every"
  ],
  	"core-js/modules/es.typed-array.fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/modules/es.typed-array.filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/modules/es.typed-array.find": [
  	"es.typed-array.find"
  ],
  	"core-js/modules/es.typed-array.find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/modules/es.typed-array.float32-array": [
  	"es.typed-array.float32-array"
  ],
  	"core-js/modules/es.typed-array.float64-array": [
  	"es.typed-array.float64-array"
  ],
  	"core-js/modules/es.typed-array.for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/modules/es.typed-array.from": [
  	"es.typed-array.from"
  ],
  	"core-js/modules/es.typed-array.includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/modules/es.typed-array.index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/modules/es.typed-array.int16-array": [
  	"es.typed-array.int16-array"
  ],
  	"core-js/modules/es.typed-array.int32-array": [
  	"es.typed-array.int32-array"
  ],
  	"core-js/modules/es.typed-array.int8-array": [
  	"es.typed-array.int8-array"
  ],
  	"core-js/modules/es.typed-array.iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/modules/es.typed-array.join": [
  	"es.typed-array.join"
  ],
  	"core-js/modules/es.typed-array.last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/modules/es.typed-array.map": [
  	"es.typed-array.map"
  ],
  	"core-js/modules/es.typed-array.of": [
  	"es.typed-array.of"
  ],
  	"core-js/modules/es.typed-array.reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/modules/es.typed-array.reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/modules/es.typed-array.reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/modules/es.typed-array.set": [
  	"es.typed-array.set"
  ],
  	"core-js/modules/es.typed-array.slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/modules/es.typed-array.some": [
  	"es.typed-array.some"
  ],
  	"core-js/modules/es.typed-array.sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/modules/es.typed-array.subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/modules/es.typed-array.to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/modules/es.typed-array.to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/modules/es.typed-array.uint16-array": [
  	"es.typed-array.uint16-array"
  ],
  	"core-js/modules/es.typed-array.uint32-array": [
  	"es.typed-array.uint32-array"
  ],
  	"core-js/modules/es.typed-array.uint8-array": [
  	"es.typed-array.uint8-array"
  ],
  	"core-js/modules/es.typed-array.uint8-clamped-array": [
  	"es.typed-array.uint8-clamped-array"
  ],
  	"core-js/modules/es.weak-map": [
  	"es.weak-map"
  ],
  	"core-js/modules/es.weak-set": [
  	"es.weak-set"
  ],
  	"core-js/modules/esnext.aggregate-error": [
  	"esnext.aggregate-error"
  ],
  	"core-js/modules/esnext.array.at": [
  	"esnext.array.at"
  ],
  	"core-js/modules/esnext.array.filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/modules/esnext.array.is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/modules/esnext.array.last-index": [
  	"esnext.array.last-index"
  ],
  	"core-js/modules/esnext.array.last-item": [
  	"esnext.array.last-item"
  ],
  	"core-js/modules/esnext.array.unique-by": [
  	"esnext.array.unique-by"
  ],
  	"core-js/modules/esnext.async-iterator.as-indexed-pairs": [
  	"esnext.async-iterator.as-indexed-pairs"
  ],
  	"core-js/modules/esnext.async-iterator.constructor": [
  	"esnext.async-iterator.constructor"
  ],
  	"core-js/modules/esnext.async-iterator.drop": [
  	"esnext.async-iterator.drop"
  ],
  	"core-js/modules/esnext.async-iterator.every": [
  	"esnext.async-iterator.every"
  ],
  	"core-js/modules/esnext.async-iterator.filter": [
  	"esnext.async-iterator.filter"
  ],
  	"core-js/modules/esnext.async-iterator.find": [
  	"esnext.async-iterator.find"
  ],
  	"core-js/modules/esnext.async-iterator.flat-map": [
  	"esnext.async-iterator.flat-map"
  ],
  	"core-js/modules/esnext.async-iterator.for-each": [
  	"esnext.async-iterator.for-each"
  ],
  	"core-js/modules/esnext.async-iterator.from": [
  	"esnext.async-iterator.from"
  ],
  	"core-js/modules/esnext.async-iterator.map": [
  	"esnext.async-iterator.map"
  ],
  	"core-js/modules/esnext.async-iterator.reduce": [
  	"esnext.async-iterator.reduce"
  ],
  	"core-js/modules/esnext.async-iterator.some": [
  	"esnext.async-iterator.some"
  ],
  	"core-js/modules/esnext.async-iterator.take": [
  	"esnext.async-iterator.take"
  ],
  	"core-js/modules/esnext.async-iterator.to-array": [
  	"esnext.async-iterator.to-array"
  ],
  	"core-js/modules/esnext.bigint.range": [
  	"esnext.bigint.range"
  ],
  	"core-js/modules/esnext.composite-key": [
  	"esnext.composite-key"
  ],
  	"core-js/modules/esnext.composite-symbol": [
  	"esnext.composite-symbol"
  ],
  	"core-js/modules/esnext.global-this": [
  	"esnext.global-this"
  ],
  	"core-js/modules/esnext.iterator.as-indexed-pairs": [
  	"esnext.iterator.as-indexed-pairs"
  ],
  	"core-js/modules/esnext.iterator.constructor": [
  	"esnext.iterator.constructor"
  ],
  	"core-js/modules/esnext.iterator.drop": [
  	"esnext.iterator.drop"
  ],
  	"core-js/modules/esnext.iterator.every": [
  	"esnext.iterator.every"
  ],
  	"core-js/modules/esnext.iterator.filter": [
  	"esnext.iterator.filter"
  ],
  	"core-js/modules/esnext.iterator.find": [
  	"esnext.iterator.find"
  ],
  	"core-js/modules/esnext.iterator.flat-map": [
  	"esnext.iterator.flat-map"
  ],
  	"core-js/modules/esnext.iterator.for-each": [
  	"esnext.iterator.for-each"
  ],
  	"core-js/modules/esnext.iterator.from": [
  	"esnext.iterator.from"
  ],
  	"core-js/modules/esnext.iterator.map": [
  	"esnext.iterator.map"
  ],
  	"core-js/modules/esnext.iterator.reduce": [
  	"esnext.iterator.reduce"
  ],
  	"core-js/modules/esnext.iterator.some": [
  	"esnext.iterator.some"
  ],
  	"core-js/modules/esnext.iterator.take": [
  	"esnext.iterator.take"
  ],
  	"core-js/modules/esnext.iterator.to-array": [
  	"esnext.iterator.to-array"
  ],
  	"core-js/modules/esnext.map.delete-all": [
  	"esnext.map.delete-all"
  ],
  	"core-js/modules/esnext.map.emplace": [
  	"esnext.map.emplace"
  ],
  	"core-js/modules/esnext.map.every": [
  	"esnext.map.every"
  ],
  	"core-js/modules/esnext.map.filter": [
  	"esnext.map.filter"
  ],
  	"core-js/modules/esnext.map.find": [
  	"esnext.map.find"
  ],
  	"core-js/modules/esnext.map.find-key": [
  	"esnext.map.find-key"
  ],
  	"core-js/modules/esnext.map.from": [
  	"esnext.map.from"
  ],
  	"core-js/modules/esnext.map.group-by": [
  	"esnext.map.group-by"
  ],
  	"core-js/modules/esnext.map.includes": [
  	"esnext.map.includes"
  ],
  	"core-js/modules/esnext.map.key-by": [
  	"esnext.map.key-by"
  ],
  	"core-js/modules/esnext.map.key-of": [
  	"esnext.map.key-of"
  ],
  	"core-js/modules/esnext.map.map-keys": [
  	"esnext.map.map-keys"
  ],
  	"core-js/modules/esnext.map.map-values": [
  	"esnext.map.map-values"
  ],
  	"core-js/modules/esnext.map.merge": [
  	"esnext.map.merge"
  ],
  	"core-js/modules/esnext.map.of": [
  	"esnext.map.of"
  ],
  	"core-js/modules/esnext.map.reduce": [
  	"esnext.map.reduce"
  ],
  	"core-js/modules/esnext.map.some": [
  	"esnext.map.some"
  ],
  	"core-js/modules/esnext.map.update": [
  	"esnext.map.update"
  ],
  	"core-js/modules/esnext.map.update-or-insert": [
  	"esnext.map.update-or-insert"
  ],
  	"core-js/modules/esnext.map.upsert": [
  	"esnext.map.upsert"
  ],
  	"core-js/modules/esnext.math.clamp": [
  	"esnext.math.clamp"
  ],
  	"core-js/modules/esnext.math.deg-per-rad": [
  	"esnext.math.deg-per-rad"
  ],
  	"core-js/modules/esnext.math.degrees": [
  	"esnext.math.degrees"
  ],
  	"core-js/modules/esnext.math.fscale": [
  	"esnext.math.fscale"
  ],
  	"core-js/modules/esnext.math.iaddh": [
  	"esnext.math.iaddh"
  ],
  	"core-js/modules/esnext.math.imulh": [
  	"esnext.math.imulh"
  ],
  	"core-js/modules/esnext.math.isubh": [
  	"esnext.math.isubh"
  ],
  	"core-js/modules/esnext.math.rad-per-deg": [
  	"esnext.math.rad-per-deg"
  ],
  	"core-js/modules/esnext.math.radians": [
  	"esnext.math.radians"
  ],
  	"core-js/modules/esnext.math.scale": [
  	"esnext.math.scale"
  ],
  	"core-js/modules/esnext.math.seeded-prng": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/modules/esnext.math.signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/modules/esnext.math.umulh": [
  	"esnext.math.umulh"
  ],
  	"core-js/modules/esnext.number.from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/modules/esnext.number.range": [
  	"esnext.number.range"
  ],
  	"core-js/modules/esnext.object.iterate-entries": [
  	"esnext.object.iterate-entries"
  ],
  	"core-js/modules/esnext.object.iterate-keys": [
  	"esnext.object.iterate-keys"
  ],
  	"core-js/modules/esnext.object.iterate-values": [
  	"esnext.object.iterate-values"
  ],
  	"core-js/modules/esnext.observable": [
  	"esnext.observable"
  ],
  	"core-js/modules/esnext.promise.all-settled": [
  	"esnext.promise.all-settled"
  ],
  	"core-js/modules/esnext.promise.any": [
  	"esnext.promise.any"
  ],
  	"core-js/modules/esnext.promise.try": [
  	"esnext.promise.try"
  ],
  	"core-js/modules/esnext.reflect.define-metadata": [
  	"esnext.reflect.define-metadata"
  ],
  	"core-js/modules/esnext.reflect.delete-metadata": [
  	"esnext.reflect.delete-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-metadata": [
  	"esnext.reflect.get-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-metadata-keys": [
  	"esnext.reflect.get-metadata-keys"
  ],
  	"core-js/modules/esnext.reflect.get-own-metadata": [
  	"esnext.reflect.get-own-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-own-metadata-keys": [
  	"esnext.reflect.get-own-metadata-keys"
  ],
  	"core-js/modules/esnext.reflect.has-metadata": [
  	"esnext.reflect.has-metadata"
  ],
  	"core-js/modules/esnext.reflect.has-own-metadata": [
  	"esnext.reflect.has-own-metadata"
  ],
  	"core-js/modules/esnext.reflect.metadata": [
  	"esnext.reflect.metadata"
  ],
  	"core-js/modules/esnext.set.add-all": [
  	"esnext.set.add-all"
  ],
  	"core-js/modules/esnext.set.delete-all": [
  	"esnext.set.delete-all"
  ],
  	"core-js/modules/esnext.set.difference": [
  	"esnext.set.difference"
  ],
  	"core-js/modules/esnext.set.every": [
  	"esnext.set.every"
  ],
  	"core-js/modules/esnext.set.filter": [
  	"esnext.set.filter"
  ],
  	"core-js/modules/esnext.set.find": [
  	"esnext.set.find"
  ],
  	"core-js/modules/esnext.set.from": [
  	"esnext.set.from"
  ],
  	"core-js/modules/esnext.set.intersection": [
  	"esnext.set.intersection"
  ],
  	"core-js/modules/esnext.set.is-disjoint-from": [
  	"esnext.set.is-disjoint-from"
  ],
  	"core-js/modules/esnext.set.is-subset-of": [
  	"esnext.set.is-subset-of"
  ],
  	"core-js/modules/esnext.set.is-superset-of": [
  	"esnext.set.is-superset-of"
  ],
  	"core-js/modules/esnext.set.join": [
  	"esnext.set.join"
  ],
  	"core-js/modules/esnext.set.map": [
  	"esnext.set.map"
  ],
  	"core-js/modules/esnext.set.of": [
  	"esnext.set.of"
  ],
  	"core-js/modules/esnext.set.reduce": [
  	"esnext.set.reduce"
  ],
  	"core-js/modules/esnext.set.some": [
  	"esnext.set.some"
  ],
  	"core-js/modules/esnext.set.symmetric-difference": [
  	"esnext.set.symmetric-difference"
  ],
  	"core-js/modules/esnext.set.union": [
  	"esnext.set.union"
  ],
  	"core-js/modules/esnext.string.at": [
  	"esnext.string.at"
  ],
  	"core-js/modules/esnext.string.at-alternative": [
  	"esnext.string.at-alternative"
  ],
  	"core-js/modules/esnext.string.code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/modules/esnext.string.match-all": [
  	"esnext.string.match-all"
  ],
  	"core-js/modules/esnext.string.replace-all": [
  	"esnext.string.replace-all"
  ],
  	"core-js/modules/esnext.symbol.async-dispose": [
  	"esnext.symbol.async-dispose"
  ],
  	"core-js/modules/esnext.symbol.dispose": [
  	"esnext.symbol.dispose"
  ],
  	"core-js/modules/esnext.symbol.observable": [
  	"esnext.symbol.observable"
  ],
  	"core-js/modules/esnext.symbol.pattern-match": [
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/modules/esnext.symbol.replace-all": [
  	"esnext.symbol.replace-all"
  ],
  	"core-js/modules/esnext.typed-array.at": [
  	"esnext.typed-array.at"
  ],
  	"core-js/modules/esnext.typed-array.filter-out": [
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/modules/esnext.weak-map.delete-all": [
  	"esnext.weak-map.delete-all"
  ],
  	"core-js/modules/esnext.weak-map.emplace": [
  	"esnext.weak-map.emplace"
  ],
  	"core-js/modules/esnext.weak-map.from": [
  	"esnext.weak-map.from"
  ],
  	"core-js/modules/esnext.weak-map.of": [
  	"esnext.weak-map.of"
  ],
  	"core-js/modules/esnext.weak-map.upsert": [
  	"esnext.weak-map.upsert"
  ],
  	"core-js/modules/esnext.weak-set.add-all": [
  	"esnext.weak-set.add-all"
  ],
  	"core-js/modules/esnext.weak-set.delete-all": [
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/modules/esnext.weak-set.from": [
  	"esnext.weak-set.from"
  ],
  	"core-js/modules/esnext.weak-set.of": [
  	"esnext.weak-set.of"
  ],
  	"core-js/modules/web.dom-collections.for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/modules/web.dom-collections.iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/modules/web.immediate": [
  	"web.immediate"
  ],
  	"core-js/modules/web.queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/modules/web.timers": [
  	"web.timers"
  ],
  	"core-js/modules/web.url": [
  	"web.url"
  ],
  	"core-js/modules/web.url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/modules/web.url.to-json": [
  	"web.url.to-json"
  ],
  	"core-js/proposals": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/proposals/array-filtering": [
  	"esnext.array.filter-out",
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/proposals/array-is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/proposals/array-last": [
  	"esnext.array.last-index",
  	"esnext.array.last-item"
  ],
  	"core-js/proposals/array-unique": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/proposals/collection-methods": [
  	"esnext.map.delete-all",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/proposals/collection-of-from": [
  	"esnext.map.from",
  	"esnext.map.of",
  	"esnext.set.from",
  	"esnext.set.of",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of"
  ],
  	"core-js/proposals/efficient-64-bit-arithmetic": [
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.umulh"
  ],
  	"core-js/proposals/global-this": [
  	"esnext.global-this"
  ],
  	"core-js/proposals/iterator-helpers": [
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array"
  ],
  	"core-js/proposals/keys-composition": [
  	"esnext.composite-key",
  	"esnext.composite-symbol"
  ],
  	"core-js/proposals/map-update-or-insert": [
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/proposals/map-upsert": [
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/proposals/math-extensions": [
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale"
  ],
  	"core-js/proposals/math-signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/proposals/number-from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/proposals/number-range": [
  	"esnext.bigint.range",
  	"esnext.number.range"
  ],
  	"core-js/proposals/object-iteration": [
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"core-js/proposals/observable": [
  	"esnext.observable",
  	"esnext.symbol.observable"
  ],
  	"core-js/proposals/pattern-matching": [
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/proposals/promise-all-settled": [
  	"esnext.promise.all-settled"
  ],
  	"core-js/proposals/promise-any": [
  	"esnext.aggregate-error",
  	"esnext.promise.any"
  ],
  	"core-js/proposals/promise-try": [
  	"esnext.promise.try"
  ],
  	"core-js/proposals/reflect-metadata": [
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata"
  ],
  	"core-js/proposals/relative-indexing-method": [
  	"esnext.array.at",
  	"esnext.typed-array.at"
  ],
  	"core-js/proposals/seeded-random": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/proposals/set-methods": [
  	"esnext.set.difference",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union"
  ],
  	"core-js/proposals/string-at": [
  	"esnext.string.at"
  ],
  	"core-js/proposals/string-code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/proposals/string-match-all": [
  	"esnext.string.match-all"
  ],
  	"core-js/proposals/string-replace-all": [
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/proposals/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/proposals/using-statement": [
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose"
  ],
  	"core-js/stable": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stable/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.string.iterator"
  ],
  	"core-js/stable/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/stable/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/stable/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/stable/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/stable/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/every": [
  	"es.array.every"
  ],
  	"core-js/stable/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/array/find": [
  	"es.array.find"
  ],
  	"core-js/stable/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/stable/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/stable/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/stable/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/stable/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/join": [
  	"es.array.join"
  ],
  	"core-js/stable/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/array/map": [
  	"es.array.map"
  ],
  	"core-js/stable/array/of": [
  	"es.array.of"
  ],
  	"core-js/stable/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/array/some": [
  	"es.array.some"
  ],
  	"core-js/stable/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/stable/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/stable/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/stable/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/stable/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/stable/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/stable/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/stable/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/stable/clear-immediate": [
  	"web.immediate"
  ],
  	"core-js/stable/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/stable/date": [
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/stable/date/now": [
  	"es.date.now"
  ],
  	"core-js/stable/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/stable/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/stable/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/stable/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/stable/dom-collections": [
  	"es.array.iterator",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/dom-collections/for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/stable/dom-collections/iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/stable/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/stable/function/name": [
  	"es.function.name"
  ],
  	"core-js/stable/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/stable/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/global-this": [
  	"es.global-this"
  ],
  	"core-js/stable/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/instance/entries": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/every": [
  	"es.array.every"
  ],
  	"core-js/stable/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/instance/find": [
  	"es.array.find"
  ],
  	"core-js/stable/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/stable/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/instance/for-each": [
  	"es.array.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/stable/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/instance/keys": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/instance/map": [
  	"es.array.map"
  ],
  	"core-js/stable/instance/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/instance/some": [
  	"es.array.some"
  ],
  	"core-js/stable/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/instance/values": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/stable/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/stable/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/stable/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc"
  ],
  	"core-js/stable/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/stable/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/stable/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/stable/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/stable/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/stable/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/stable/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/stable/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/stable/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/stable/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/stable/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/stable/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/stable/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/stable/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/stable/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/stable/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/stable/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/stable/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/stable/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/stable/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/stable/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/stable/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/stable/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/stable/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/stable/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/stable/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/stable/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/stable/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/stable/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/stable/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/stable/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/stable/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/stable/object/create": [
  	"es.object.create"
  ],
  	"core-js/stable/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/stable/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/stable/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/stable/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/stable/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/stable/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/stable/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/stable/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/stable/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/stable/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/stable/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/stable/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/stable/object/is": [
  	"es.object.is"
  ],
  	"core-js/stable/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/stable/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/stable/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/stable/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/stable/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/stable/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/stable/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/stable/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/stable/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/stable/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/object/values": [
  	"es.object.values"
  ],
  	"core-js/stable/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/stable/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/stable/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled"
  ],
  	"core-js/stable/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any"
  ],
  	"core-js/stable/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/stable/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/stable/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/stable/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/stable/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/stable/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/stable/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/stable/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/stable/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/stable/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/stable/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/stable/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/stable/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/stable/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/stable/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/stable/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/stable/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/stable/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/stable/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/stable/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/stable/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/stable/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/stable/regexp/sticky": [
  	"es.regexp.sticky"
  ],
  	"core-js/stable/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/stable/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/stable/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/set-immediate": [
  	"web.immediate"
  ],
  	"core-js/stable/set-interval": [
  	"web.timers"
  ],
  	"core-js/stable/set-timeout": [
  	"web.timers"
  ],
  	"core-js/stable/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/stable/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/stable/string/big": [
  	"es.string.big"
  ],
  	"core-js/stable/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/stable/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/stable/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/stable/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/stable/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/stable/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/stable/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/stable/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/stable/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/stable/string/link": [
  	"es.string.link"
  ],
  	"core-js/stable/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/stable/string/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/stable/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/stable/string/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/stable/string/small": [
  	"es.string.small"
  ],
  	"core-js/stable/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/stable/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/stable/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/stable/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/stable/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/stable/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/stable/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/stable/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/stable/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/stable/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/stable/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/stable/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/stable/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/stable/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/stable/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/stable/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/stable/string/virtual/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/string/virtual/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/stable/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/stable/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/stable/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/stable/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/stable/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/stable/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/stable/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/stable/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/stable/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/stable/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/stable/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/stable/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/stable/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/stable/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/stable/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/stable/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/stable/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/stable/typed-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/stable/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/stable/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/stable/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/stable/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/stable/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/stable/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/stable/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/stable/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/stable/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/stable/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/stable/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/stable/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/stable/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/stable/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/stable/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/stable/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/stable/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/stable/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/stable/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/stable/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/stable/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/stable/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/stable/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stable/url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/stable/url/to-json": [
  	"web.url.to-json"
  ],
  	"core-js/stable/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stage": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stage/0": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stage/1": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of"
  ],
  	"core-js/stage/2": [
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.is-template-object",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.set.difference",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/stage/3": [
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.global-this",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at"
  ],
  	"core-js/stage/4": [
  	"esnext.aggregate-error",
  	"esnext.global-this",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/stage/pre": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web": [
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web/dom-collections": [
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/web/immediate": [
  	"web.immediate"
  ],
  	"core-js/web/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/web/timers": [
  	"web.timers"
  ],
  	"core-js/web/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web/url-search-params": [
  	"web.url-search-params"
  ]
  };

  function isBabelPolyfillSource(source) {
    return source === "@babel/polyfill" || source === "babel-polyfill";
  }

  function isCoreJSSource(source) {
    if (typeof source === "string") {
      source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
    }

    return has$6(corejsEntries, source) && corejsEntries[source];
  }

  var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
  function replaceCoreJS3EntryPlugin (_, _ref) {
    var corejs = _ref.corejs,
        include = _ref.include,
        exclude = _ref.exclude,
        polyfillTargets = _ref.polyfillTargets,
        debug = _ref.debug;
    var polyfills = filterItems(corejs3Polyfills, include, exclude, polyfillTargets, null);
    var available = new Set(getModulesListForTargetVersion(corejs.version));

    function shouldReplace(source, modules) {
      if (!modules) return false;

      if (modules.length === 1 && polyfills.has(modules[0]) && available.has(modules[0]) && getModulePath(modules[0]) === source) {
        return false;
      }

      return true;
    }

    var isPolyfillImport = {
      ImportDeclaration: function ImportDeclaration(path) {
        var source = getImportSource(path);
        if (!source) return;

        if (isBabelPolyfillSource(source)) {
          console.warn(BABEL_POLYFILL_DEPRECATION);
        } else {
          var modules = isCoreJSSource(source);

          if (shouldReplace(source, modules)) {
            this.replaceBySeparateModulesImport(path, modules);
          }
        }
      },
      Program: {
        enter: function enter(path) {
          var _this = this;

          path.get("body").forEach(function (bodyPath) {
            var source = getRequireSource(bodyPath);
            if (!source) return;

            if (isBabelPolyfillSource(source)) {
              console.warn(BABEL_POLYFILL_DEPRECATION);
            } else {
              var modules = isCoreJSSource(source);

              if (shouldReplace(source, modules)) {
                _this.replaceBySeparateModulesImport(bodyPath, modules);
              }
            }
          });
        },
        exit: function exit(path) {
          var _this2 = this;

          var filtered = intersection(polyfills, this.polyfillsSet, available);
          var reversed = Array.from(filtered).reverse();

          for (var _iterator = _createForOfIteratorHelperLoose(reversed), _step; !(_step = _iterator()).done;) {
            var module = _step.value;

            if (!this.injectedPolyfills.has(module)) {
              createImport(path, module);
            }
          }

          filtered.forEach(function (module) {
            return _this2.injectedPolyfills.add(module);
          });
        }
      }
    };
    return {
      name: "corejs3-entry",
      visitor: isPolyfillImport,
      pre: function pre() {
        this.injectedPolyfills = new Set();
        this.polyfillsSet = new Set();

        this.replaceBySeparateModulesImport = function (path, modules) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(modules), _step2; !(_step2 = _iterator2()).done;) {
            var module = _step2.value;
            this.polyfillsSet.add(module);
          }

          path.remove();
        };
      },
      post: function post() {
        if (debug) {
          logEntryPolyfills("core-js", this.injectedPolyfills.size > 0, this.injectedPolyfills, this.file.opts.filename, polyfillTargets, corejs3Polyfills);
        }
      }
    };
  }

  function isRegeneratorSource(source) {
    return source === "regenerator-runtime/runtime";
  }

  function removeRegeneratorEntryPlugin () {
    var visitor = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isRegeneratorSource(getImportSource(path))) {
          this.regeneratorImportExcluded = true;
          path.remove();
        }
      },
      Program: function Program(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          if (isRegeneratorSource(getRequireSource(bodyPath))) {
            _this.regeneratorImportExcluded = true;
            bodyPath.remove();
          }
        });
      }
    };
    return {
      name: "regenerator-entry",
      visitor: visitor,
      pre: function pre() {
        this.regeneratorImportExcluded = false;
      },
      post: function post() {
        if (this.opts.debug && this.regeneratorImportExcluded) {
          var filename = this.file.opts.filename;

          if (process.env.BABEL_ENV === "test") {
            filename = filename.replace(/\\/g, "/");
          }

          console.log("\n[" + filename + "] Based on your targets, regenerator-runtime import excluded.");
        }
      }
    };
  }

  var pluginLists = {
    withProposals: {
      withoutBugfixes: pluginsFiltered,
      withBugfixes: Object.assign({}, pluginsFiltered, bugfixPluginsFiltered)
    },
    withoutProposals: {
      withoutBugfixes: filterStageFromList(pluginsFiltered, shippedProposals.proposalPlugins),
      withBugfixes: filterStageFromList(Object.assign({}, pluginsFiltered, bugfixPluginsFiltered), shippedProposals.proposalPlugins)
    }
  };

  function getPluginList(proposals, bugfixes) {
    if (proposals) {
      if (bugfixes) return pluginLists.withProposals.withBugfixes;else return pluginLists.withProposals.withoutBugfixes;
    } else {
      if (bugfixes) return pluginLists.withoutProposals.withBugfixes;else return pluginLists.withoutProposals.withoutBugfixes;
    }
  }

  var getPlugin = function getPlugin(pluginName) {
    var plugin = availablePlugins[pluginName];

    if (!plugin) {
      throw new Error("Could not find plugin \"" + pluginName + "\". Ensure there is an entry in ./available-plugins.js for it.");
    }

    return plugin;
  };

  var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
    return opts.reduce(function (result, opt) {
      var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
      result[target].add(opt);
      return result;
    }, {
      all: opts,
      plugins: new Set(),
      builtIns: new Set()
    });
  };
  var getModulesPluginNames = function getModulesPluginNames(_ref) {
    var modules = _ref.modules,
        transformations = _ref.transformations,
        shouldTransformESM = _ref.shouldTransformESM,
        shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
        shouldTransformExportNamespaceFrom = _ref.shouldTransformExportNamespaceFrom,
        shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
    var modulesPluginNames = [];

    if (modules !== false && transformations[modules]) {
      if (shouldTransformESM) {
        modulesPluginNames.push(transformations[modules]);
      }

      if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
        modulesPluginNames.push("proposal-dynamic-import");
      } else {
        if (shouldTransformDynamicImport) {
          console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
        }

        modulesPluginNames.push("syntax-dynamic-import");
      }
    } else {
      modulesPluginNames.push("syntax-dynamic-import");
    }

    if (shouldTransformExportNamespaceFrom) {
      modulesPluginNames.push("proposal-export-namespace-from");
    } else {
      modulesPluginNames.push("syntax-export-namespace-from");
    }

    if (shouldParseTopLevelAwait) {
      modulesPluginNames.push("syntax-top-level-await");
    }

    return modulesPluginNames;
  };
  var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
    var useBuiltIns = _ref2.useBuiltIns,
        corejs = _ref2.corejs,
        polyfillTargets = _ref2.polyfillTargets,
        include = _ref2.include,
        exclude = _ref2.exclude,
        proposals = _ref2.proposals,
        shippedProposals = _ref2.shippedProposals,
        regenerator = _ref2.regenerator,
        debug = _ref2.debug;
    var polyfillPlugins = [];

    if (useBuiltIns === "usage" || useBuiltIns === "entry") {
      var pluginOptions = {
        corejs: corejs,
        polyfillTargets: polyfillTargets,
        include: include,
        exclude: exclude,
        proposals: proposals,
        shippedProposals: shippedProposals,
        regenerator: regenerator,
        debug: debug
      };

      if (corejs) {
        if (useBuiltIns === "usage") {
          if (corejs.major === 2) {
            polyfillPlugins.push([addCoreJS2UsagePlugin, pluginOptions]);
          } else {
            polyfillPlugins.push([addCoreJS3UsagePlugin, pluginOptions]);
          }

          if (regenerator) {
            polyfillPlugins.push([addRegeneratorUsagePlugin, pluginOptions]);
          }
        } else {
          if (corejs.major === 2) {
            polyfillPlugins.push([replaceCoreJS2EntryPlugin, pluginOptions]);
          } else {
            polyfillPlugins.push([replaceCoreJS3EntryPlugin, pluginOptions]);

            if (!regenerator) {
              polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
            }
          }
        }
      }
    }

    return polyfillPlugins;
  };

  function supportsStaticESM$1(caller) {
    return !!(caller == null ? void 0 : caller.supportsStaticESM);
  }

  function supportsDynamicImport(caller) {
    return !!(caller == null ? void 0 : caller.supportsDynamicImport);
  }

  function supportsExportNamespaceFrom(caller) {
    return !!(caller == null ? void 0 : caller.supportsExportNamespaceFrom);
  }

  function supportsTopLevelAwait(caller) {
    return !!(caller == null ? void 0 : caller.supportsTopLevelAwait);
  }

  var presetEnv = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions$3(opts),
        bugfixes = _normalizeOptions.bugfixes,
        configPath = _normalizeOptions.configPath,
        debug = _normalizeOptions.debug,
        optionsExclude = _normalizeOptions.exclude,
        forceAllTransforms = _normalizeOptions.forceAllTransforms,
        ignoreBrowserslistConfig = _normalizeOptions.ignoreBrowserslistConfig,
        optionsInclude = _normalizeOptions.include,
        loose = _normalizeOptions.loose,
        modules = _normalizeOptions.modules,
        shippedProposals = _normalizeOptions.shippedProposals,
        spec = _normalizeOptions.spec,
        optionsTargets = _normalizeOptions.targets,
        useBuiltIns = _normalizeOptions.useBuiltIns,
        _normalizeOptions$cor = _normalizeOptions.corejs,
        corejs = _normalizeOptions$cor.version,
        proposals = _normalizeOptions$cor.proposals,
        browserslistEnv = _normalizeOptions.browserslistEnv;

    if (!process.env.BABEL_8_BREAKING) {
      var hasUglifyTarget = false;

      if (optionsTargets == null ? void 0 : optionsTargets.uglify) {
        hasUglifyTarget = true;
        delete optionsTargets.uglify;
        console.warn("\nThe uglify target has been deprecated. Set the top level\noption `forceAllTransforms: true` instead.\n");
      }
    }

    if ((optionsTargets == null ? void 0 : optionsTargets.esmodules) && optionsTargets.browsers) {
      console.warn("\n@babel/preset-env: esmodules and browsers targets have been specified together.\n`browsers` target, `" + optionsTargets.browsers.toString() + "` will be ignored.\n");
    }

    var targets = getTargets(optionsTargets, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath,
      browserslistEnv: browserslistEnv
    });
    var include = transformIncludesAndExcludes(optionsInclude);
    var exclude = transformIncludesAndExcludes(optionsExclude);
    var transformTargets = (process.env.BABEL_8_BREAKING ? forceAllTransforms : forceAllTransforms || hasUglifyTarget) ? {} : targets;
    var compatData = getPluginList(shippedProposals, bugfixes);
    var shouldSkipExportNamespaceFrom = modules === "auto" && (api.caller == null ? void 0 : api.caller(supportsExportNamespaceFrom)) || modules === false && !isRequired("proposal-export-namespace-from", transformTargets, {
      compatData: compatData,
      includes: include.plugins,
      excludes: exclude.plugins
    });
    var modulesPluginNames = getModulesPluginNames({
      modules: modules,
      transformations: moduleTransformations,
      shouldTransformESM: modules !== "auto" || !(api.caller == null ? void 0 : api.caller(supportsStaticESM$1)),
      shouldTransformDynamicImport: modules !== "auto" || !(api.caller == null ? void 0 : api.caller(supportsDynamicImport)),
      shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom,
      shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
    });
    var pluginNames = filterItems(compatData, include.plugins, exclude.plugins, transformTargets, modulesPluginNames, getOptionSpecificExcludesFor({
      loose: loose
    }), shippedProposals.pluginSyntaxMap);
    removeUnnecessaryItems(pluginNames, overlappingPlugins$2);
    var polyfillPlugins = getPolyfillPlugins({
      useBuiltIns: useBuiltIns,
      corejs: corejs,
      polyfillTargets: targets,
      include: include.builtIns,
      exclude: exclude.builtIns,
      proposals: proposals,
      shippedProposals: shippedProposals,
      regenerator: pluginNames.has("transform-regenerator"),
      debug: debug
    });
    var pluginUseBuiltIns = useBuiltIns !== false;
    var plugins = Array.from(pluginNames).map(function (pluginName) {
      if (pluginName === "proposal-class-properties" || pluginName === "proposal-private-methods" || pluginName === "proposal-private-property-in-object") {
        return [getPlugin(pluginName), {
          loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
        }];
      }

      return [getPlugin(pluginName), {
        spec: spec,
        loose: loose,
        useBuiltIns: pluginUseBuiltIns
      }];
    }).concat(polyfillPlugins);

    if (debug) {
      console.log("@babel/preset-env: `DEBUG` option");
      console.log("\nUsing targets:");
      console.log(JSON.stringify(prettifyTargets(targets), null, 2));
      console.log("\nUsing modules transform: " + modules.toString());
      console.log("\nUsing plugins:");
      pluginNames.forEach(function (pluginName) {
        logPluginOrPolyfill(pluginName, targets, pluginsFiltered);
      });

      if (!useBuiltIns) {
        console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
      } else {
        console.log("\nUsing polyfills with `" + useBuiltIns + "` option:");
      }
    }

    return {
      plugins: plugins
    };
  });

  var presetFlow = declare(function (api, _ref) {
    var all = _ref.all,
        allowDeclareFields = _ref.allowDeclareFields;
    api.assertVersion(7);
    return {
      plugins: [[transformFlowStripTypes, {
        all: all,
        allowDeclareFields: allowDeclareFields
      }]]
    };
  });

  var PURE_CALLS = new Map([["react", ["cloneElement", "createContext", "createElement", "createFactory", "createRef", "forwardRef", "isValidElement", "memo", "lazy"]], ["react-dom", ["createPortal"]]]);
  var transformReactPure = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-react-pure-annotations",
      visitor: {
        CallExpression: function CallExpression(path) {
          if (isReactCall(path)) {
            annotateAsPure(path);
          }
        }
      }
    };
  });

  function isReactCall(path) {
    if (!isMemberExpression(path.node.callee)) {
      var callee = path.get("callee");

      for (var _iterator = _createForOfIteratorHelperLoose(PURE_CALLS), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
            module = _step$value[0],
            methods = _step$value[1];

        for (var _iterator2 = _createForOfIteratorHelperLoose(methods), _step2; !(_step2 = _iterator2()).done;) {
          var method = _step2.value;

          if (callee.referencesImport(module, method)) {
            return true;
          }
        }
      }

      return false;
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(PURE_CALLS), _step3; !(_step3 = _iterator3()).done;) {
      var _step3$value = _step3.value,
          _module = _step3$value[0],
          _methods = _step3$value[1];
      var object = path.get("callee.object");

      if (object.referencesImport(_module, "default") || object.referencesImport(_module, "*")) {
        for (var _iterator4 = _createForOfIteratorHelperLoose(_methods), _step4; !(_step4 = _iterator4()).done;) {
          var _method = _step4.value;

          if (isIdentifier(path.node.callee.property, {
            name: _method
          })) {
            return true;
          }
        }

        return false;
      }
    }

    return false;
  }

  var presetReact = declare(function (api, opts) {
    api.assertVersion(7);
    var pragma = opts.pragma,
        pragmaFrag = opts.pragmaFrag;
    var pure = opts.pure,
        _opts$throwIfNamespac = opts.throwIfNamespace,
        throwIfNamespace = _opts$throwIfNamespac === void 0 ? true : _opts$throwIfNamespac,
        _opts$runtime = opts.runtime,
        runtime = _opts$runtime === void 0 ? "classic" : _opts$runtime,
        importSource = opts.importSource;

    if (runtime === "classic") {
      pragma = pragma || "React.createElement";
      pragmaFrag = pragmaFrag || "React.Fragment";
    }

    var development = !!opts.development;

    if (process.env.BABEL_8_BREAKING) {
      if ("useSpread" in opts) {
        throw new Error('@babel/preset-react: Since Babel 8, an inline object with spread elements is always used, and the "useSpread" option is no longer available. Please remove it from your config.');
      }

      if ("useBuiltIns" in opts) {
        var useBuiltInsFormatted = JSON.stringify(opts.useBuiltIns);
        throw new Error("@babel/preset-react: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n`useBuiltIns: " + useBuiltInsFormatted + "`, you can use the following config\n{\n  \"plugins\": [\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": " + useBuiltInsFormatted + " }]\n  ],\n  \"presets\": [\"@babel/preset-react\"]\n}");
      }
    }

    if (typeof development !== "boolean") {
      throw new Error("@babel/preset-react 'development' option must be a boolean.");
    }

    return {
      plugins: [[development ? transformReactJSXDevelopment : transformReactJSX, process.env.BABEL_8_BREAKING ? {
        importSource: importSource,
        pragma: pragma,
        pragmaFrag: pragmaFrag,
        runtime: runtime,
        throwIfNamespace: throwIfNamespace,
        pure: pure
      } : {
        importSource: importSource,
        pragma: pragma,
        pragmaFrag: pragmaFrag,
        runtime: runtime,
        throwIfNamespace: throwIfNamespace,
        pure: pure,
        useBuiltIns: !!opts.useBuiltIns,
        useSpread: opts.useSpread
      }], transformReactDisplayName, pure !== false && transformReactPure].filter(Boolean)
    };
  });

  var v$3 = new OptionValidator("@babel/preset-typescript");
  function normalizeOptions$4(options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        allowNamespaces = _options.allowNamespaces,
        jsxPragma = _options.jsxPragma,
        onlyRemoveTypeImports = _options.onlyRemoveTypeImports;

    if (process.env.BABEL_8_BREAKING) {
      var TopLevelOptions = {
        allExtensions: "allExtensions",
        allowNamespaces: "allowNamespaces",
        isTSX: "isTSX",
        jsxPragma: "jsxPragma",
        jsxPragmaFrag: "jsxPragmaFrag",
        onlyRemoveTypeImports: "onlyRemoveTypeImports"
      };
      v$3.validateTopLevelOptions(options, TopLevelOptions);
      allowNamespaces = v$3.validateBooleanOption(TopLevelOptions.allowNamespaces, options.allowNamespaces, true);
      jsxPragma = v$3.validateStringOption(TopLevelOptions.jsxPragma, options.jsxPragma, "React");
      onlyRemoveTypeImports = v$3.validateBooleanOption(TopLevelOptions.onlyRemoveTypeImports, options.onlyRemoveTypeImports, true);
    }

    var jsxPragmaFrag = v$3.validateStringOption("jsxPragmaFrag", options.jsxPragmaFrag, "React.Fragment");
    var allExtensions = v$3.validateBooleanOption("allExtensions", options.allExtensions, false);
    var isTSX = v$3.validateBooleanOption("isTSX", options.isTSX, false);

    if (isTSX) {
      v$3.invariant(allExtensions, "isTSX:true requires allExtensions:true");
    }

    return {
      allExtensions: allExtensions,
      allowNamespaces: allowNamespaces,
      isTSX: isTSX,
      jsxPragma: jsxPragma,
      jsxPragmaFrag: jsxPragmaFrag,
      onlyRemoveTypeImports: onlyRemoveTypeImports
    };
  }

  var presetTypescript = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions$4(opts),
        allExtensions = _normalizeOptions.allExtensions,
        allowNamespaces = _normalizeOptions.allowNamespaces,
        isTSX = _normalizeOptions.isTSX,
        jsxPragma = _normalizeOptions.jsxPragma,
        jsxPragmaFrag = _normalizeOptions.jsxPragmaFrag,
        onlyRemoveTypeImports = _normalizeOptions.onlyRemoveTypeImports;

    var pluginOptions = process.env.BABEL_8_BREAKING ? function (isTSX) {
      return {
        allowNamespaces: allowNamespaces,
        isTSX: isTSX,
        jsxPragma: jsxPragma,
        jsxPragmaFrag: jsxPragmaFrag,
        onlyRemoveTypeImports: onlyRemoveTypeImports
      };
    } : function (isTSX) {
      return {
        allowDeclareFields: opts.allowDeclareFields,
        allowNamespaces: allowNamespaces,
        isTSX: isTSX,
        jsxPragma: jsxPragma,
        jsxPragmaFrag: jsxPragmaFrag,
        onlyRemoveTypeImports: onlyRemoveTypeImports
      };
    };
    return {
      overrides: allExtensions ? [{
        plugins: [[transformTypeScript, pluginOptions(isTSX)]]
      }] : [{
        test: /\.ts$/,
        plugins: [[transformTypeScript, pluginOptions(false)]]
      }, {
        test: /\.tsx$/,
        plugins: [[transformTypeScript, pluginOptions(true)]]
      }]
    };
  });

  var scriptTypes = ["text/jsx", "text/babel"];
  var headEl;
  var inlineScriptCount = 0;

  function transformCode(transformFn, script) {
    var source;

    if (script.url != null) {
      source = script.url;
    } else {
      source = "Inline Babel script";
      inlineScriptCount++;

      if (inlineScriptCount > 1) {
        source += " (" + inlineScriptCount + ")";
      }
    }

    return transformFn(script.content, buildBabelOptions(script, source)).code;
  }

  function buildBabelOptions(script, filename) {
    var presets = script.presets;

    if (!presets) {
      if (script.type === "module") {
        presets = ["react", ["env", {
          targets: {
            esmodules: true
          },
          modules: false
        }]];
      } else {
        presets = ["react", "env"];
      }
    }

    return {
      filename: filename,
      presets: presets,
      plugins: script.plugins || ["proposal-class-properties", "proposal-object-rest-spread", "transform-flow-strip-types"],
      sourceMaps: "inline",
      sourceFileName: filename
    };
  }

  function run$1(transformFn, script) {
    var scriptEl = document.createElement("script");

    if (script.type) {
      scriptEl.setAttribute("type", script.type);
    }

    scriptEl.text = transformCode(transformFn, script);
    headEl.appendChild(scriptEl);
  }

  function load(url, successCallback, errorCallback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if ("overrideMimeType" in xhr) {
      xhr.overrideMimeType("text/plain");
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 0 || xhr.status === 200) {
          successCallback(xhr.responseText);
        } else {
          errorCallback();
          throw new Error("Could not load " + url);
        }
      }
    };

    return xhr.send(null);
  }

  function getPluginsOrPresetsFromScript(script, attributeName) {
    var rawValue = script.getAttribute(attributeName);

    if (rawValue === "") {
      return [];
    }

    if (!rawValue) {
      return null;
    }

    return rawValue.split(",").map(function (item) {
      return item.trim();
    });
  }

  function loadScripts(transformFn, scripts) {
    var result = [];
    var count = scripts.length;

    function check() {
      var script, i;

      for (i = 0; i < count; i++) {
        script = result[i];

        if (script.loaded && !script.executed) {
          script.executed = true;
          run$1(transformFn, script);
        } else if (!script.loaded && !script.error && !script.async) {
          break;
        }
      }
    }

    scripts.forEach(function (script, i) {
      var scriptData = {
        async: script.hasAttribute("async"),
        type: script.getAttribute("data-type"),
        error: false,
        executed: false,
        plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
        presets: getPluginsOrPresetsFromScript(script, "data-presets")
      };

      if (script.src) {
        result[i] = Object.assign({}, scriptData, {
          content: null,
          loaded: false,
          url: script.src
        });
        load(script.src, function (content) {
          result[i].loaded = true;
          result[i].content = content;
          check();
        }, function () {
          result[i].error = true;
          check();
        });
      } else {
        result[i] = Object.assign({}, scriptData, {
          content: script.innerHTML,
          loaded: true,
          url: script.getAttribute("data-module") || null
        });
      }
    });
    check();
  }

  function runScripts(transformFn, scripts) {
    headEl = document.getElementsByTagName("head")[0];

    if (!scripts) {
      scripts = document.getElementsByTagName("script");
    }

    var jsxScripts = [];

    for (var i = 0; i < scripts.length; i++) {
      var script = scripts.item(i);
      var type = script.type.split(";")[0];

      if (scriptTypes.indexOf(type) !== -1) {
        jsxScripts.push(script);
      }
    }

    if (jsxScripts.length === 0) {
      return;
    }

    console.warn("You are using the in-browser Babel transformer. Be sure to precompile " + "your scripts for production - https://babeljs.io/docs/setup/");
    loadScripts(transformFn, jsxScripts);
  }

  var _window;

  var isArray$2 = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };

  function loadBuiltin(builtinTable, name) {
    if (isArray$2(name) && typeof name[0] === "string") {
      if (Object.prototype.hasOwnProperty.call(builtinTable, name[0])) {
        return [builtinTable[name[0]]].concat(name.slice(1));
      }

      return;
    } else if (typeof name === "string") {
      return builtinTable[name];
    }

    return name;
  }

  function processOptions(options) {
    var presets = (options.presets || []).map(function (presetName) {
      var preset = loadBuiltin(availablePresets, presetName);

      if (preset) {
        if (isArray$2(preset) && typeof preset[0] === "object" && Object.prototype.hasOwnProperty.call(preset[0], "buildPreset")) {
          preset[0] = Object.assign({}, preset[0], {
            buildPreset: preset[0].buildPreset
          });
        }
      } else {
        throw new Error("Invalid preset specified in Babel options: \"" + presetName + "\"");
      }

      return preset;
    });
    var plugins = (options.plugins || []).map(function (pluginName) {
      var plugin = loadBuiltin(availablePlugins$1, pluginName);

      if (!plugin) {
        throw new Error("Invalid plugin specified in Babel options: \"" + pluginName + "\"");
      }

      return plugin;
    });
    return Object.assign({
      babelrc: false
    }, options, {
      presets: presets,
      plugins: plugins
    });
  }

  function transform$1(code, options) {
    return transform(code, processOptions(options));
  }
  function transformFromAst$1(ast, code, options) {
    return transformFromAst(ast, code, processOptions(options));
  }
  var availablePlugins$1 = {};
  var availablePresets = {};
  var buildExternalHelpers = babelBuildExternalHelpers;
  function registerPlugin(name, plugin) {
    if (Object.prototype.hasOwnProperty.call(availablePlugins$1, name)) {
      console.warn("A plugin named \"" + name + "\" is already registered, it will be overridden");
    }

    availablePlugins$1[name] = plugin;
  }
  function registerPlugins(newPlugins) {
    Object.keys(newPlugins).forEach(function (name) {
      return registerPlugin(name, newPlugins[name]);
    });
  }
  function registerPreset(name, preset) {
    if (Object.prototype.hasOwnProperty.call(availablePresets, name)) {
      if (name === "env") {
        console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone");
      } else {
        console.warn("A preset named \"" + name + "\" is already registered, it will be overridden");
      }
    }

    availablePresets[name] = preset;
  }
  function registerPresets(newPresets) {
    Object.keys(newPresets).forEach(function (name) {
      return registerPreset(name, newPresets[name]);
    });
  }
  registerPlugins(all);
  registerPresets({
    env: presetEnv,
    es2015: preset2015,
    es2016: function es2016() {
      return {
        plugins: [availablePlugins$1["transform-exponentiation-operator"]]
      };
    },
    es2017: function es2017() {
      return {
        plugins: [availablePlugins$1["transform-async-to-generator"]]
      };
    },
    react: presetReact,
    "stage-0": presetStage0,
    "stage-1": presetStage1,
    "stage-2": presetStage2,
    "stage-3": presetStage3,
    "es2015-loose": {
      presets: [[preset2015, {
        loose: true
      }]]
    },
    "es2015-no-commonjs": {
      presets: [[preset2015, {
        modules: false
      }]]
    },
    typescript: presetTypescript,
    flow: presetFlow
  });
  var version$6 = "7.12.12";

  function onDOMContentLoaded() {
    transformScriptTags();
  }

  if (typeof window !== "undefined" && ((_window = window) == null ? void 0 : _window.addEventListener)) {
    window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
  }

  function transformScriptTags(scriptTags) {
    runScripts(transform$1, scriptTags);
  }
  function disableScriptTags() {
    window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
  }

  exports.availablePlugins = availablePlugins$1;
  exports.availablePresets = availablePresets;
  exports.buildExternalHelpers = buildExternalHelpers;
  exports.disableScriptTags = disableScriptTags;
  exports.registerPlugin = registerPlugin;
  exports.registerPlugins = registerPlugins;
  exports.registerPreset = registerPreset;
  exports.registerPresets = registerPresets;
  exports.transform = transform$1;
  exports.transformFromAst = transformFromAst$1;
  exports.transformScriptTags = transformScriptTags;
  exports.version = version$6;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
